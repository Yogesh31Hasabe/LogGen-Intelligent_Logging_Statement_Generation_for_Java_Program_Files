file_name,original_file_content,Input,Label,Output,OriginalWithPlaceholder
src/examples/java/ActivityExample.java,"import com.flickr4java.flickr.Flickr;
import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.REST;
import com.flickr4java.flickr.RequestContext;
import com.flickr4java.flickr.activity.ActivityInterface;
import com.flickr4java.flickr.activity.Event;
import com.flickr4java.flickr.activity.Item;
import com.flickr4java.flickr.activity.ItemList;
import com.flickr4java.flickr.auth.Auth;
import com.flickr4java.flickr.auth.Permission;
import com.flickr4java.flickr.util.IOUtilities;

import org.xml.sax.SAXException;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Properties;

/**
 * Demonstration of howto use the ActivityInterface.
 * 
 * @author mago
 * @version $Id: ActivityExample.java,v 1.3 2008/07/05 22:19:48 x-mago Exp $
 */
public class ActivityExample {
    static String apiKey;

    static String sharedSecret;

    Flickr f;

    REST rest;

    RequestContext requestContext;

    Properties properties = null;

    public ActivityExample() throws IOException {
        InputStream in = null;
        try {
            in = getClass().getResourceAsStream(""/setup.properties"");
            properties = new Properties();
            properties.load(in);
        } finally {
            IOUtilities.close(in);
        }
        f = new Flickr(properties.getProperty(""apiKey""), properties.getProperty(""secret""), new REST());
        requestContext = RequestContext.getRequestContext();
        Auth auth = new Auth();
        auth.setPermission(Permission.READ);
        auth.setToken(properties.getProperty(""token""));
        auth.setTokenSecret(properties.getProperty(""tokensecret""));
        requestContext.setAuth(auth);
        Flickr.debugRequest = false;
        Flickr.debugStream = false;
    }

    public void showActivity() throws FlickrException, IOException, SAXException {
        ActivityInterface iface = f.getActivityInterface();
        ItemList list = iface.userComments(10, 0);
        for (int j = 0; j < list.size(); j++) {
            Item item = (Item) list.get(j);
            System.out.println(""Item "" + (j + 1) + ""/"" + list.size() + "" type: "" + item.getType());
            System.out.println(""Item-id:       "" + item.getId() + ""\n"");
            ArrayList events = (ArrayList) item.getEvents();
            for (int i = 0; i < events.size(); i++) {
                System.out.println(""Event "" + (i + 1) + ""/"" + events.size() + "" of Item "" + (j + 1));
                System.out.println(""Event-type: "" + ((Event) events.get(i)).getType());
                System.out.println(""User:       "" + ((Event) events.get(i)).getUser());
                System.out.println(""Username:   "" + ((Event) events.get(i)).getUsername());
                System.out.println(""Value:      "" + ((Event) events.get(i)).getValue() + ""\n"");
            }
        }
        ActivityInterface iface2 = f.getActivityInterface();
        list = iface2.userPhotos(50, 0, ""300d"");
        for (int j = 0; j < list.size(); j++) {
            Item item = (Item) list.get(j);
            System.out.println(""Item "" + (j + 1) + ""/"" + list.size() + "" type: "" + item.getType());
            System.out.println(""Item-id:       "" + item.getId() + ""\n"");
            ArrayList events = (ArrayList) item.getEvents();
            for (int i = 0; i < events.size(); i++) {
                System.out.println(""Event "" + (i + 1) + ""/"" + events.size() + "" of Item "" + (j + 1));
                System.out.println(""Event-type: "" + ((Event) events.get(i)).getType());
                if (((Event) events.get(i)).getType().equals(""note"")) {
                    System.out.println(""Note-id:    "" + ((Event) events.get(i)).getId());
                } else if (((Event) events.get(i)).getType().equals(""comment"")) {
                    System.out.println(""Comment-id: "" + ((Event) events.get(i)).getId());
                }
                System.out.println(""User:       "" + ((Event) events.get(i)).getUser());
                System.out.println(""Username:   "" + ((Event) events.get(i)).getUsername());
                System.out.println(""Value:      "" + ((Event) events.get(i)).getValue());
                System.out.println(""Dateadded:  "" + ((Event) events.get(i)).getDateadded() + ""\n"");
            }
        }
    }

    public static void main(String[] args) {
        try {
            ActivityExample t = new ActivityExample();
            t.showActivity();
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.exit(0);
    }

}
","import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.REST; import com.flickr4java.flickr.RequestContext; import com.flickr4java.flickr.activity.ActivityInterface; import com.flickr4java.flickr.activity.Event; import com.flickr4java.flickr.activity.Item; import com.flickr4java.flickr.activity.ItemList; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.auth.Permission; import com.flickr4java.flickr.util.IOUtilities; import org.xml.sax.SAXException; import java.io.IOException; import java.io.InputStream; import java.util.ArrayList; import java.util.Properties; public class ActivityExample { static String apiKey; static String sharedSecret; Flickr f; REST rest; RequestContext requestContext; Properties properties = null; public ActivityExample() throws IOException { InputStream in = null; try { in = getClass().getResourceAsStream(""/setup.properties""); properties = new Properties(); properties.load(in); } finally { IOUtilities.close(in); } f = new Flickr(properties.getProperty(""apiKey""), properties.getProperty(""secret""), new REST()); requestContext = RequestContext.getRequestContext(); Auth auth = new Auth(); auth.setPermission(Permission.READ); auth.setToken(properties.getProperty(""token"")); auth.setTokenSecret(properties.getProperty(""tokensecret"")); requestContext.setAuth(auth); Flickr.debugRequest = false; Flickr.debugStream = false; } public void showActivity() throws FlickrException, IOException, SAXException { ActivityInterface iface = f.getActivityInterface(); ItemList list = iface.userComments(10, 0); for (int j = 0; j < list.size(); j++) { Item item = (Item) list.get(j); System.out.println(""Item "" + (j + 1) + ""/"" + list.size() + "" type: "" + item.getType()); System.out.println(""Item-id:       "" + item.getId() + ""\n""); ArrayList events = (ArrayList) item.getEvents(); for (int i = 0; i < events.size(); i++) { System.out.println(""Event "" + (i + 1) + ""/"" + events.size() + "" of Item "" + (j + 1)); System.out.println(""Event-type: "" + ((Event) events.get(i)).getType()); System.out.println(""User:       "" + ((Event) events.get(i)).getUser()); System.out.println(""Username:   "" + ((Event) events.get(i)).getUsername()); System.out.println(""Value:      "" + ((Event) events.get(i)).getValue() + ""\n""); } } ActivityInterface iface2 = f.getActivityInterface(); list = iface2.userPhotos(50, 0, ""300d""); for (int j = 0; j < list.size(); j++) { Item item = (Item) list.get(j); System.out.println(""Item "" + (j + 1) + ""/"" + list.size() + "" type: "" + item.getType()); System.out.println(""Item-id:       "" + item.getId() + ""\n""); ArrayList events = (ArrayList) item.getEvents(); for (int i = 0; i < events.size(); i++) { System.out.println(""Event "" + (i + 1) + ""/"" + events.size() + "" of Item "" + (j + 1)); System.out.println(""Event-type: "" + ((Event) events.get(i)).getType()); if (((Event) events.get(i)).getType().equals(""note"")) { System.out.println(""Note-id:    "" + ((Event) events.get(i)).getId()); } else if (((Event) events.get(i)).getType().equals(""comment"")) { System.out.println(""Comment-id: "" + ((Event) events.get(i)).getId()); } System.out.println(""User:       "" + ((Event) events.get(i)).getUser()); System.out.println(""Username:   "" + ((Event) events.get(i)).getUsername()); System.out.println(""Value:      "" + ((Event) events.get(i)).getValue()); System.out.println(""Dateadded:  "" + ((Event) events.get(i)).getDateadded() + ""\n""); } } } public static void main(String[] args) { try { ActivityExample t = new ActivityExample(); t.showActivity(); } catch (Exception e) { e.printStackTrace(); } System.exit(0); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.REST; import com.flickr4java.flickr.RequestContext; import com.flickr4java.flickr.activity.ActivityInterface; import com.flickr4java.flickr.activity.Event; import com.flickr4java.flickr.activity.Item; import com.flickr4java.flickr.activity.ItemList; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.auth.Permission; import com.flickr4java.flickr.util.IOUtilities; import org.xml.sax.SAXException; import java.io.IOException; import java.io.InputStream; import java.util.ArrayList; import java.util.Properties; public class ActivityExample { static String apiKey; static String sharedSecret; Flickr f; REST rest; RequestContext requestContext; Properties properties = null; public ActivityExample() throws IOException { InputStream in = null; try { in = getClass().getResourceAsStream(""/setup.properties""); properties = new Properties(); properties.load(in); } finally { IOUtilities.close(in); } f = new Flickr(properties.getProperty(""apiKey""), properties.getProperty(""secret""), new REST()); requestContext = RequestContext.getRequestContext(); Auth auth = new Auth(); auth.setPermission(Permission.READ); auth.setToken(properties.getProperty(""token"")); auth.setTokenSecret(properties.getProperty(""tokensecret"")); requestContext.setAuth(auth); Flickr.debugRequest = false; Flickr.debugStream = false; } public void showActivity() throws FlickrException, IOException, SAXException { ActivityInterface iface = f.getActivityInterface(); ItemList list = iface.userComments(10, 0); for (int j = 0; j < list.size(); j++) { Item item = (Item) list.get(j); System.out.println(""Item "" + (j + 1) + ""/"" + list.size() + "" type: "" + item.getType()); System.out.println(""Item-id:       "" + item.getId() + ""\n""); ArrayList events = (ArrayList) item.getEvents(); for (int i = 0; i < events.size(); i++) { System.out.println(""Event "" + (i + 1) + ""/"" + events.size() + "" of Item "" + (j + 1)); System.out.println(""Event-type: "" + ((Event) events.get(i)).getType()); System.out.println(""User:       "" + ((Event) events.get(i)).getUser()); System.out.println(""Username:   "" + ((Event) events.get(i)).getUsername()); System.out.println(""Value:      "" + ((Event) events.get(i)).getValue() + ""\n""); } } ActivityInterface iface2 = f.getActivityInterface(); list = iface2.userPhotos(50, 0, ""300d""); for (int j = 0; j < list.size(); j++) { Item item = (Item) list.get(j); System.out.println(""Item "" + (j + 1) + ""/"" + list.size() + "" type: "" + item.getType()); System.out.println(""Item-id:       "" + item.getId() + ""\n""); ArrayList events = (ArrayList) item.getEvents(); for (int i = 0; i < events.size(); i++) { System.out.println(""Event "" + (i + 1) + ""/"" + events.size() + "" of Item "" + (j + 1)); System.out.println(""Event-type: "" + ((Event) events.get(i)).getType()); if (((Event) events.get(i)).getType().equals(""note"")) { System.out.println(""Note-id:    "" + ((Event) events.get(i)).getId()); } else if (((Event) events.get(i)).getType().equals(""comment"")) { System.out.println(""Comment-id: "" + ((Event) events.get(i)).getId()); } System.out.println(""User:       "" + ((Event) events.get(i)).getUser()); System.out.println(""Username:   "" + ((Event) events.get(i)).getUsername()); System.out.println(""Value:      "" + ((Event) events.get(i)).getValue()); System.out.println(""Dateadded:  "" + ((Event) events.get(i)).getDateadded() + ""\n""); } } } public static void main(String[] args) { try { ActivityExample t = new ActivityExample(); t.showActivity(); } catch (Exception e) { e.printStackTrace(); } System.exit(0); } } ","import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.REST; import com.flickr4java.flickr.RequestContext; import com.flickr4java.flickr.activity.ActivityInterface; import com.flickr4java.flickr.activity.Event; import com.flickr4java.flickr.activity.Item; import com.flickr4java.flickr.activity.ItemList; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.auth.Permission; import com.flickr4java.flickr.util.IOUtilities;  import org.xml.sax.SAXException;  import java.io.IOException; import java.io.InputStream; import java.util.ArrayList; import java.util.Properties;  /**
 * Demonstration of howto use the ActivityInterface.
 * 
 * @author mago
 * @version $Id: ActivityExample.java,v 1.3 2008/07/05 22:19:48 x-mago Exp $
 */ public class ActivityExample { static String apiKey;  static String sharedSecret;  Flickr f;  REST rest;  RequestContext requestContext;  Properties properties = null;  public ActivityExample() throws IOException { InputStream in = null; try { in = getClass().getResourceAsStream(""/setup.properties""); properties = new Properties(); properties.load(in); } finally { IOUtilities.close(in); } f = new Flickr(properties.getProperty(""apiKey""), properties.getProperty(""secret""), new REST()); requestContext = RequestContext.getRequestContext(); Auth auth = new Auth(); auth.setPermission(Permission.READ); auth.setToken(properties.getProperty(""token"")); auth.setTokenSecret(properties.getProperty(""tokensecret"")); requestContext.setAuth(auth); Flickr.debugRequest = false; Flickr.debugStream = false; }  public void showActivity() throws FlickrException, IOException, SAXException { ActivityInterface iface = f.getActivityInterface(); ItemList list = iface.userComments(10, 0); for (int j = 0; j < list.size(); j++) { Item item = (Item) list.get(j); System.out.println(""Item "" + (j + 1) + ""/"" + list.size() + "" type: "" + item.getType()); System.out.println(""Item-id:       "" + item.getId() + ""\n""); ArrayList events = (ArrayList) item.getEvents(); for (int i = 0; i < events.size(); i++) { System.out.println(""Event "" + (i + 1) + ""/"" + events.size() + "" of Item "" + (j + 1)); System.out.println(""Event-type: "" + ((Event) events.get(i)).getType()); System.out.println(""User:       "" + ((Event) events.get(i)).getUser()); System.out.println(""Username:   "" + ((Event) events.get(i)).getUsername()); System.out.println(""Value:      "" + ((Event) events.get(i)).getValue() + ""\n""); } } ActivityInterface iface2 = f.getActivityInterface(); list = iface2.userPhotos(50, 0, ""300d""); for (int j = 0; j < list.size(); j++) { Item item = (Item) list.get(j); System.out.println(""Item "" + (j + 1) + ""/"" + list.size() + "" type: "" + item.getType()); System.out.println(""Item-id:       "" + item.getId() + ""\n""); ArrayList events = (ArrayList) item.getEvents(); for (int i = 0; i < events.size(); i++) { System.out.println(""Event "" + (i + 1) + ""/"" + events.size() + "" of Item "" + (j + 1)); System.out.println(""Event-type: "" + ((Event) events.get(i)).getType()); if (((Event) events.get(i)).getType().equals(""note"")) { System.out.println(""Note-id:    "" + ((Event) events.get(i)).getId()); } else if (((Event) events.get(i)).getType().equals(""comment"")) { System.out.println(""Comment-id: "" + ((Event) events.get(i)).getId()); } System.out.println(""User:       "" + ((Event) events.get(i)).getUser()); System.out.println(""Username:   "" + ((Event) events.get(i)).getUsername()); System.out.println(""Value:      "" + ((Event) events.get(i)).getValue()); System.out.println(""Dateadded:  "" + ((Event) events.get(i)).getDateadded() + ""\n""); } } }  public static void main(String[] args) { try { ActivityExample t = new ActivityExample(); t.showActivity(); } catch (Exception e) { e.printStackTrace(); } System.exit(0); }  }  "
src/examples/java/AuthExample.java,"import com.flickr4java.flickr.Flickr;
import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.REST;
import com.flickr4java.flickr.auth.Auth;
import com.flickr4java.flickr.auth.AuthInterface;
import com.flickr4java.flickr.auth.Permission;
import com.flickr4java.flickr.util.IOUtilities;
import com.github.scribejava.core.model.OAuth1RequestToken;
import com.github.scribejava.core.model.OAuth1Token;

import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;
import java.util.Scanner;
import java.util.concurrent.ExecutionException;

/**
 * Demonstrates the authentication-process.
 * <p>
 * 
 * If you registered API keys, you find them with the shared secret at your <a href=""http://www.flickr.com/services/api/registered_keys.gne"">list of API
 * keys</a>
 * 
 * @author mago
 * @version $Id: AuthExample.java,v 1.6 2009/08/25 19:37:45 x-mago Exp $
 */
public class AuthExample {

    public static void auth() throws IOException, FlickrException, ExecutionException, InterruptedException {
        Properties properties;
        InputStream in = null;
        try {
            in = AuthExample.class.getResourceAsStream(""/setup.properties"");
            properties = new Properties();
            properties.load(in);
        } finally {
            IOUtilities.close(in);
        }

        Flickr flickr = new Flickr(properties.getProperty(""apiKey""), properties.getProperty(""secret""), new REST());
        Flickr.debugStream = false;
        AuthInterface authInterface = flickr.getAuthInterface();

        Scanner scanner = new Scanner(System.in);

        OAuth1RequestToken requestToken = authInterface.getRequestToken();
        System.out.println(""token: "" + requestToken);

        String url = authInterface.getAuthorizationUrl(requestToken, Permission.DELETE);
        System.out.println(""Follow this URL to authorise yourself on Flickr"");
        System.out.println(url);
        System.out.println(""Paste in the token it gives you:"");
        System.out.print("">>"");

        String tokenKey = scanner.nextLine();
        scanner.close();

        OAuth1Token accessToken = authInterface.getAccessToken(requestToken, tokenKey);
        System.out.println(""Authentication success"");

        Auth auth = authInterface.checkToken(accessToken);

        // This token can be used until the user revokes it.
        System.out.println(""Token: "" + accessToken.getToken());
        System.out.println(""Secret: "" + accessToken.getTokenSecret());
        System.out.println(""nsid: "" + auth.getUser().getId());
        System.out.println(""Realname: "" + auth.getUser().getRealName());
        System.out.println(""Username: "" + auth.getUser().getUsername());
        System.out.println(""Permission: "" + auth.getPermission().getType());
    }

    public static void main(String[] args) {
        try {
            AuthExample.auth();
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.exit(0);
    }
}
","import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.REST; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.auth.AuthInterface; import com.flickr4java.flickr.auth.Permission; import com.flickr4java.flickr.util.IOUtilities; import com.github.scribejava.core.model.OAuth1RequestToken; import com.github.scribejava.core.model.OAuth1Token; import java.io.IOException; import java.io.InputStream; import java.util.Properties; import java.util.Scanner; import java.util.concurrent.ExecutionException; public class AuthExample { public static void auth() throws IOException, FlickrException, ExecutionException, InterruptedException { Properties properties; InputStream in = null; try { in = AuthExample.class.getResourceAsStream(""/setup.properties""); properties = new Properties(); properties.load(in); } finally { IOUtilities.close(in); } Flickr flickr = new Flickr(properties.getProperty(""apiKey""), properties.getProperty(""secret""), new REST()); Flickr.debugStream = false; AuthInterface authInterface = flickr.getAuthInterface(); Scanner scanner = new Scanner(System.in); OAuth1RequestToken requestToken = authInterface.getRequestToken(); System.out.println(""token: "" + requestToken); String url = authInterface.getAuthorizationUrl(requestToken, Permission.DELETE); System.out.println(""Follow this URL to authorise yourself on Flickr""); System.out.println(url); System.out.println(""Paste in the token it gives you:""); System.out.print("">>""); String tokenKey = scanner.nextLine(); scanner.close(); OAuth1Token accessToken = authInterface.getAccessToken(requestToken, tokenKey); System.out.println(""Authentication success""); Auth auth = authInterface.checkToken(accessToken); System.out.println(""Token: "" + accessToken.getToken()); System.out.println(""Secret: "" + accessToken.getTokenSecret()); System.out.println(""nsid: "" + auth.getUser().getId()); System.out.println(""Realname: "" + auth.getUser().getRealName()); System.out.println(""Username: "" + auth.getUser().getUsername()); System.out.println(""Permission: "" + auth.getPermission().getType()); } public static void main(String[] args) { try { AuthExample.auth(); } catch (Exception e) { e.printStackTrace(); } System.exit(0); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.REST; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.auth.AuthInterface; import com.flickr4java.flickr.auth.Permission; import com.flickr4java.flickr.util.IOUtilities; import com.github.scribejava.core.model.OAuth1RequestToken; import com.github.scribejava.core.model.OAuth1Token; import java.io.IOException; import java.io.InputStream; import java.util.Properties; import java.util.Scanner; import java.util.concurrent.ExecutionException; public class AuthExample { public static void auth() throws IOException, FlickrException, ExecutionException, InterruptedException { Properties properties; InputStream in = null; try { in = AuthExample.class.getResourceAsStream(""/setup.properties""); properties = new Properties(); properties.load(in); } finally { IOUtilities.close(in); } Flickr flickr = new Flickr(properties.getProperty(""apiKey""), properties.getProperty(""secret""), new REST()); Flickr.debugStream = false; AuthInterface authInterface = flickr.getAuthInterface(); Scanner scanner = new Scanner(System.in); OAuth1RequestToken requestToken = authInterface.getRequestToken(); System.out.println(""token: "" + requestToken); String url = authInterface.getAuthorizationUrl(requestToken, Permission.DELETE); System.out.println(""Follow this URL to authorise yourself on Flickr""); System.out.println(url); System.out.println(""Paste in the token it gives you:""); System.out.print("">>""); String tokenKey = scanner.nextLine(); scanner.close(); OAuth1Token accessToken = authInterface.getAccessToken(requestToken, tokenKey); System.out.println(""Authentication success""); Auth auth = authInterface.checkToken(accessToken); System.out.println(""Token: "" + accessToken.getToken()); System.out.println(""Secret: "" + accessToken.getTokenSecret()); System.out.println(""nsid: "" + auth.getUser().getId()); System.out.println(""Realname: "" + auth.getUser().getRealName()); System.out.println(""Username: "" + auth.getUser().getUsername()); System.out.println(""Permission: "" + auth.getPermission().getType()); } public static void main(String[] args) { try { AuthExample.auth(); } catch (Exception e) { e.printStackTrace(); } System.exit(0); } } ","import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.REST; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.auth.AuthInterface; import com.flickr4java.flickr.auth.Permission; import com.flickr4java.flickr.util.IOUtilities; import com.github.scribejava.core.model.OAuth1RequestToken; import com.github.scribejava.core.model.OAuth1Token;  import java.io.IOException; import java.io.InputStream; import java.util.Properties; import java.util.Scanner; import java.util.concurrent.ExecutionException;  /**
 * Demonstrates the authentication-process.
 * <p>
 * 
 * If you registered API keys, you find them with the shared secret at your <a href=""http://www.flickr.com/services/api/registered_keys.gne"">list of API
 * keys</a>
 * 
 * @author mago
 * @version $Id: AuthExample.java,v 1.6 2009/08/25 19:37:45 x-mago Exp $
 */ public class AuthExample {  public static void auth() throws IOException, FlickrException, ExecutionException, InterruptedException { Properties properties; InputStream in = null; try { in = AuthExample.class.getResourceAsStream(""/setup.properties""); properties = new Properties(); properties.load(in); } finally { IOUtilities.close(in); }  Flickr flickr = new Flickr(properties.getProperty(""apiKey""), properties.getProperty(""secret""), new REST()); Flickr.debugStream = false; AuthInterface authInterface = flickr.getAuthInterface();  Scanner scanner = new Scanner(System.in);  OAuth1RequestToken requestToken = authInterface.getRequestToken(); System.out.println(""token: "" + requestToken);  String url = authInterface.getAuthorizationUrl(requestToken, Permission.DELETE); System.out.println(""Follow this URL to authorise yourself on Flickr""); System.out.println(url); System.out.println(""Paste in the token it gives you:""); System.out.print("">>"");  String tokenKey = scanner.nextLine(); scanner.close();  OAuth1Token accessToken = authInterface.getAccessToken(requestToken, tokenKey); System.out.println(""Authentication success"");  Auth auth = authInterface.checkToken(accessToken);  // This token can be used until the user revokes it. System.out.println(""Token: "" + accessToken.getToken()); System.out.println(""Secret: "" + accessToken.getTokenSecret()); System.out.println(""nsid: "" + auth.getUser().getId()); System.out.println(""Realname: "" + auth.getUser().getRealName()); System.out.println(""Username: "" + auth.getUser().getUsername()); System.out.println(""Permission: "" + auth.getPermission().getType()); }  public static void main(String[] args) { try { AuthExample.auth(); } catch (Exception e) { e.printStackTrace(); } System.exit(0); } }  "
src/examples/java/Backup.java,"import com.flickr4java.flickr.Flickr;
import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.REST;
import com.flickr4java.flickr.RequestContext;
import com.flickr4java.flickr.auth.Auth;
import com.flickr4java.flickr.auth.AuthInterface;
import com.flickr4java.flickr.auth.Permission;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoList;
import com.flickr4java.flickr.photos.PhotosInterface;
import com.flickr4java.flickr.photos.Size;
import com.flickr4java.flickr.photosets.Photoset;
import com.flickr4java.flickr.photosets.PhotosetsInterface;
import com.flickr4java.flickr.util.AuthStore;
import com.flickr4java.flickr.util.FileAuthStore;
import com.github.scribejava.core.model.OAuth1RequestToken;
import com.github.scribejava.core.model.OAuth1Token;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Scanner;

/**
 * A simple program to backup all of a users private and public photos in a photoset aware manner. If photos are classified in multiple photosets, they will be
 * copied. Its a sample, its not perfect :-)
 * 
 * This sample also uses the AuthStore interface, so users will only be asked to authorize on the first run.
 * 
 * @author Matthew MacKenzie
 * @version $Id: Backup.java,v 1.6 2009/01/01 16:44:57 x-mago Exp $
 */

public class Backup {

    private final String nsid;

    private final Flickr flickr;

    private AuthStore authStore;

    public Backup(String apiKey, String nsid, String sharedSecret, File authsDir) throws FlickrException {
        flickr = new Flickr(apiKey, sharedSecret, new REST());
        this.nsid = nsid;

        if (authsDir != null) {
            this.authStore = new FileAuthStore(authsDir);
        }
    }

    private void authorize() throws IOException, FlickrException {
        AuthInterface authInterface = flickr.getAuthInterface();
        OAuth1RequestToken requestToken = authInterface.getRequestToken();

        String url = authInterface.getAuthorizationUrl(requestToken, Permission.READ);
        System.out.println(""Follow this URL to authorise yourself on Flickr"");
        System.out.println(url);
        System.out.println(""Paste in the token it gives you:"");
        System.out.print("">>"");

        String tokenKey = new Scanner(System.in).nextLine();

        OAuth1Token accessToken = authInterface.getAccessToken(requestToken, tokenKey);

        Auth auth = authInterface.checkToken(accessToken);
        RequestContext.getRequestContext().setAuth(auth);
        this.authStore.store(auth);
        System.out.println(""Thanks.  You probably will not have to do this every time.  Now starting backup."");
    }

    public void doBackup(File directory) throws Exception {
        if (!directory.exists()) {
            directory.mkdir();
        }

        RequestContext rc = RequestContext.getRequestContext();

        if (this.authStore != null) {
            Auth auth = this.authStore.retrieve(this.nsid);
            if (auth == null) {
                this.authorize();
            } else {
                rc.setAuth(auth);
            }
        }

        PhotosetsInterface pi = flickr.getPhotosetsInterface();
        PhotosInterface photoInt = flickr.getPhotosInterface();
        Map<String, Collection> allPhotos = new HashMap<String, Collection>();

        Iterator sets = pi.getList(this.nsid).getPhotosets().iterator();

        while (sets.hasNext()) {
            Photoset set = (Photoset) sets.next();
            PhotoList photos = pi.getPhotos(set.getId(), 500, 1);
            allPhotos.put(set.getTitle(), photos);
        }

        int notInSetPage = 1;
        Collection notInASet = new ArrayList();
        while (true) {
            Collection nis = photoInt.getNotInSet(50, notInSetPage);
            notInASet.addAll(nis);
            if (nis.size() < 50) {
                break;
            }
            notInSetPage++;
        }
        allPhotos.put(""NotInASet"", notInASet);

        Iterator allIter = allPhotos.keySet().iterator();

        while (allIter.hasNext()) {
            String setTitle = (String) allIter.next();
            String setDirectoryName = makeSafeFilename(setTitle);

            Collection currentSet = allPhotos.get(setTitle);
            Iterator setIterator = currentSet.iterator();
            File setDirectory = new File(directory, setDirectoryName);
            setDirectory.mkdir();
            while (setIterator.hasNext()) {

                Photo p = (Photo) setIterator.next();
                String url = p.getLargeUrl();
                URL u = new URL(url);
                String filename = u.getFile();
                filename = filename.substring(filename.lastIndexOf(""/"") + 1, filename.length());
                System.out.println(""Now writing "" + filename + "" to "" + setDirectory.getCanonicalPath());
                BufferedInputStream inStream = new BufferedInputStream(photoInt.getImageAsStream(p, Size.LARGE));
                File newFile = new File(setDirectory, filename);

                FileOutputStream fos = new FileOutputStream(newFile);

                int read;

                while ((read = inStream.read()) != -1) {
                    fos.write(read);
                }
                fos.flush();
                fos.close();
                inStream.close();
            }
        }

    }

    private String makeSafeFilename(String input) {
        byte[] fname = input.getBytes();
        byte[] bad = new byte[] { '\\', '/', '""' };
        byte replace = '_';
        for (int i = 0; i < fname.length; i++) {
            for (byte element : bad) {
                if (fname[i] == element) {
                    fname[i] = replace;
                }
            }
        }
        return new String(fname);
    }

    public static void main(String[] args) throws Exception {
        if (args.length < 4) {
            System.out.println(""Usage: java "" + Backup.class.getName() + "" api_key nsid shared_secret output_dir"");
            System.exit(1);
        }
        Backup bf = new Backup(args[0], args[1], args[2], new File(System.getProperty(""user.home"") + File.separatorChar + "".flickrAuth""));
        bf.doBackup(new File(args[3]));
    }
}
","import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.REST; import com.flickr4java.flickr.RequestContext; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.auth.AuthInterface; import com.flickr4java.flickr.auth.Permission; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotosInterface; import com.flickr4java.flickr.photos.Size; import com.flickr4java.flickr.photosets.Photoset; import com.flickr4java.flickr.photosets.PhotosetsInterface; import com.flickr4java.flickr.util.AuthStore; import com.flickr4java.flickr.util.FileAuthStore; import com.github.scribejava.core.model.OAuth1RequestToken; import com.github.scribejava.core.model.OAuth1Token; import java.io.BufferedInputStream; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.net.URL; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Scanner; public class Backup { private final String nsid; private final Flickr flickr; private AuthStore authStore; public Backup(String apiKey, String nsid, String sharedSecret, File authsDir) throws FlickrException { flickr = new Flickr(apiKey, sharedSecret, new REST()); this.nsid = nsid; if (authsDir != null) { this.authStore = new FileAuthStore(authsDir); } } private void authorize() throws IOException, FlickrException { AuthInterface authInterface = flickr.getAuthInterface(); OAuth1RequestToken requestToken = authInterface.getRequestToken(); String url = authInterface.getAuthorizationUrl(requestToken, Permission.READ); System.out.println(""Follow this URL to authorise yourself on Flickr""); System.out.println(url); System.out.println(""Paste in the token it gives you:""); System.out.print("">>""); String tokenKey = new Scanner(System.in).nextLine(); OAuth1Token accessToken = authInterface.getAccessToken(requestToken, tokenKey); Auth auth = authInterface.checkToken(accessToken); RequestContext.getRequestContext().setAuth(auth); this.authStore.store(auth); System.out.println(""Thanks.  You probably will not have to do this every time.  Now starting backup.""); } public void doBackup(File directory) throws Exception { if (!directory.exists()) { directory.mkdir(); } RequestContext rc = RequestContext.getRequestContext(); if (this.authStore != null) { Auth auth = this.authStore.retrieve(this.nsid); if (auth == null) { this.authorize(); } else { rc.setAuth(auth); } } PhotosetsInterface pi = flickr.getPhotosetsInterface(); PhotosInterface photoInt = flickr.getPhotosInterface(); Map<String, Collection> allPhotos = new HashMap<String, Collection>(); Iterator sets = pi.getList(this.nsid).getPhotosets().iterator(); while (sets.hasNext()) { Photoset set = (Photoset) sets.next(); PhotoList photos = pi.getPhotos(set.getId(), 500, 1); allPhotos.put(set.getTitle(), photos); } int notInSetPage = 1; Collection notInASet = new ArrayList(); while (true) { Collection nis = photoInt.getNotInSet(50, notInSetPage); notInASet.addAll(nis); if (nis.size() < 50) { break; } notInSetPage++; } allPhotos.put(""NotInASet"", notInASet); Iterator allIter = allPhotos.keySet().iterator(); while (allIter.hasNext()) { String setTitle = (String) allIter.next(); String setDirectoryName = makeSafeFilename(setTitle); Collection currentSet = allPhotos.get(setTitle); Iterator setIterator = currentSet.iterator(); File setDirectory = new File(directory, setDirectoryName); setDirectory.mkdir(); while (setIterator.hasNext()) { Photo p = (Photo) setIterator.next(); String url = p.getLargeUrl(); URL u = new URL(url); String filename = u.getFile(); filename = filename.substring(filename.lastIndexOf(""/"") + 1, filename.length()); System.out.println(""Now writing "" + filename + "" to "" + setDirectory.getCanonicalPath()); BufferedInputStream inStream = new BufferedInputStream(photoInt.getImageAsStream(p, Size.LARGE)); File newFile = new File(setDirectory, filename); FileOutputStream fos = new FileOutputStream(newFile); int read; while ((read = inStream.read()) != -1) { fos.write(read); } fos.flush(); fos.close(); inStream.close(); } } } private String makeSafeFilename(String input) { byte[] fname = input.getBytes(); byte[] bad = new byte[] { '\\', '/', '""' } ; byte replace = '_'; for (int i = 0; i < fname.length; i++) { for (byte element : bad) { if (fname[i] == element) { fname[i] = replace; } } } return new String(fname); } public static void main(String[] args) throws Exception { if (args.length < 4) { System.out.println(""Usage: java "" + Backup.class.getName() + "" api_key nsid shared_secret output_dir""); System.exit(1); } Backup bf = new Backup(args[0], args[1], args[2], new File(System.getProperty(""user.home"") + File.separatorChar + "".flickrAuth"")); bf.doBackup(new File(args[3])); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.REST; import com.flickr4java.flickr.RequestContext; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.auth.AuthInterface; import com.flickr4java.flickr.auth.Permission; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotosInterface; import com.flickr4java.flickr.photos.Size; import com.flickr4java.flickr.photosets.Photoset; import com.flickr4java.flickr.photosets.PhotosetsInterface; import com.flickr4java.flickr.util.AuthStore; import com.flickr4java.flickr.util.FileAuthStore; import com.github.scribejava.core.model.OAuth1RequestToken; import com.github.scribejava.core.model.OAuth1Token; import java.io.BufferedInputStream; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.net.URL; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Scanner; public class Backup { private final String nsid; private final Flickr flickr; private AuthStore authStore; public Backup(String apiKey, String nsid, String sharedSecret, File authsDir) throws FlickrException { flickr = new Flickr(apiKey, sharedSecret, new REST()); this.nsid = nsid; if (authsDir != null) { this.authStore = new FileAuthStore(authsDir); } } private void authorize() throws IOException, FlickrException { AuthInterface authInterface = flickr.getAuthInterface(); OAuth1RequestToken requestToken = authInterface.getRequestToken(); String url = authInterface.getAuthorizationUrl(requestToken, Permission.READ); System.out.println(""Follow this URL to authorise yourself on Flickr""); System.out.println(url); System.out.println(""Paste in the token it gives you:""); System.out.print("">>""); String tokenKey = new Scanner(System.in).nextLine(); OAuth1Token accessToken = authInterface.getAccessToken(requestToken, tokenKey); Auth auth = authInterface.checkToken(accessToken); RequestContext.getRequestContext().setAuth(auth); this.authStore.store(auth); System.out.println(""Thanks.  You probably will not have to do this every time.  Now starting backup.""); } public void doBackup(File directory) throws Exception { if (!directory.exists()) { directory.mkdir(); } RequestContext rc = RequestContext.getRequestContext(); if (this.authStore != null) { Auth auth = this.authStore.retrieve(this.nsid); if (auth == null) { this.authorize(); } else { rc.setAuth(auth); } } PhotosetsInterface pi = flickr.getPhotosetsInterface(); PhotosInterface photoInt = flickr.getPhotosInterface(); Map<String, Collection> allPhotos = new HashMap<String, Collection>(); Iterator sets = pi.getList(this.nsid).getPhotosets().iterator(); while (sets.hasNext()) { Photoset set = (Photoset) sets.next(); PhotoList photos = pi.getPhotos(set.getId(), 500, 1); allPhotos.put(set.getTitle(), photos); } int notInSetPage = 1; Collection notInASet = new ArrayList(); while (true) { Collection nis = photoInt.getNotInSet(50, notInSetPage); notInASet.addAll(nis); if (nis.size() < 50) { break; } notInSetPage++; } allPhotos.put(""NotInASet"", notInASet); Iterator allIter = allPhotos.keySet().iterator(); while (allIter.hasNext()) { String setTitle = (String) allIter.next(); String setDirectoryName = makeSafeFilename(setTitle); Collection currentSet = allPhotos.get(setTitle); Iterator setIterator = currentSet.iterator(); File setDirectory = new File(directory, setDirectoryName); setDirectory.mkdir(); while (setIterator.hasNext()) { Photo p = (Photo) setIterator.next(); String url = p.getLargeUrl(); URL u = new URL(url); String filename = u.getFile(); filename = filename.substring(filename.lastIndexOf(""/"") + 1, filename.length()); System.out.println(""Now writing "" + filename + "" to "" + setDirectory.getCanonicalPath()); BufferedInputStream inStream = new BufferedInputStream(photoInt.getImageAsStream(p, Size.LARGE)); File newFile = new File(setDirectory, filename); FileOutputStream fos = new FileOutputStream(newFile); int read; while ((read = inStream.read()) != -1) { fos.write(read); } fos.flush(); fos.close(); inStream.close(); } } } private String makeSafeFilename(String input) { byte[] fname = input.getBytes(); byte[] bad = new byte[] { '\\', '/', '""' } ; byte replace = '_'; for (int i = 0; i < fname.length; i++) { for (byte element : bad) { if (fname[i] == element) { fname[i] = replace; } } } return new String(fname); } public static void main(String[] args) throws Exception { if (args.length < 4) { System.out.println(""Usage: java "" + Backup.class.getName() + "" api_key nsid shared_secret output_dir""); System.exit(1); } Backup bf = new Backup(args[0], args[1], args[2], new File(System.getProperty(""user.home"") + File.separatorChar + "".flickrAuth"")); bf.doBackup(new File(args[3])); } } ","import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.REST; import com.flickr4java.flickr.RequestContext; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.auth.AuthInterface; import com.flickr4java.flickr.auth.Permission; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotosInterface; import com.flickr4java.flickr.photos.Size; import com.flickr4java.flickr.photosets.Photoset; import com.flickr4java.flickr.photosets.PhotosetsInterface; import com.flickr4java.flickr.util.AuthStore; import com.flickr4java.flickr.util.FileAuthStore; import com.github.scribejava.core.model.OAuth1RequestToken; import com.github.scribejava.core.model.OAuth1Token;  import java.io.BufferedInputStream; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.net.URL; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Scanner;  /**
 * A simple program to backup all of a users private and public photos in a photoset aware manner. If photos are classified in multiple photosets, they will be
 * copied. Its a sample, its not perfect :-)
 * 
 * This sample also uses the AuthStore interface, so users will only be asked to authorize on the first run.
 * 
 * @author Matthew MacKenzie
 * @version $Id: Backup.java,v 1.6 2009/01/01 16:44:57 x-mago Exp $
 */  public class Backup {  private final String nsid;  private final Flickr flickr;  private AuthStore authStore;  public Backup(String apiKey, String nsid, String sharedSecret, File authsDir) throws FlickrException { flickr = new Flickr(apiKey, sharedSecret, new REST()); this.nsid = nsid;  if (authsDir != null) { this.authStore = new FileAuthStore(authsDir); } }  private void authorize() throws IOException, FlickrException { AuthInterface authInterface = flickr.getAuthInterface(); OAuth1RequestToken requestToken = authInterface.getRequestToken();  String url = authInterface.getAuthorizationUrl(requestToken, Permission.READ); System.out.println(""Follow this URL to authorise yourself on Flickr""); System.out.println(url); System.out.println(""Paste in the token it gives you:""); System.out.print("">>"");  String tokenKey = new Scanner(System.in).nextLine();  OAuth1Token accessToken = authInterface.getAccessToken(requestToken, tokenKey);  Auth auth = authInterface.checkToken(accessToken); RequestContext.getRequestContext().setAuth(auth); this.authStore.store(auth); System.out.println(""Thanks.  You probably will not have to do this every time.  Now starting backup.""); }  public void doBackup(File directory) throws Exception { if (!directory.exists()) { directory.mkdir(); }  RequestContext rc = RequestContext.getRequestContext();  if (this.authStore != null) { Auth auth = this.authStore.retrieve(this.nsid); if (auth == null) { this.authorize(); } else { rc.setAuth(auth); } }  PhotosetsInterface pi = flickr.getPhotosetsInterface(); PhotosInterface photoInt = flickr.getPhotosInterface(); Map<String, Collection> allPhotos = new HashMap<String, Collection>();  Iterator sets = pi.getList(this.nsid).getPhotosets().iterator();  while (sets.hasNext()) { Photoset set = (Photoset) sets.next(); PhotoList photos = pi.getPhotos(set.getId(), 500, 1); allPhotos.put(set.getTitle(), photos); }  int notInSetPage = 1; Collection notInASet = new ArrayList(); while (true) { Collection nis = photoInt.getNotInSet(50, notInSetPage); notInASet.addAll(nis); if (nis.size() < 50) { break; } notInSetPage++; } allPhotos.put(""NotInASet"", notInASet);  Iterator allIter = allPhotos.keySet().iterator();  while (allIter.hasNext()) { String setTitle = (String) allIter.next(); String setDirectoryName = makeSafeFilename(setTitle);  Collection currentSet = allPhotos.get(setTitle); Iterator setIterator = currentSet.iterator(); File setDirectory = new File(directory, setDirectoryName); setDirectory.mkdir(); while (setIterator.hasNext()) {  Photo p = (Photo) setIterator.next(); String url = p.getLargeUrl(); URL u = new URL(url); String filename = u.getFile(); filename = filename.substring(filename.lastIndexOf(""/"") + 1, filename.length()); System.out.println(""Now writing "" + filename + "" to "" + setDirectory.getCanonicalPath()); BufferedInputStream inStream = new BufferedInputStream(photoInt.getImageAsStream(p, Size.LARGE)); File newFile = new File(setDirectory, filename);  FileOutputStream fos = new FileOutputStream(newFile);  int read;  while ((read = inStream.read()) != -1) { fos.write(read); } fos.flush(); fos.close(); inStream.close(); } }  }  private String makeSafeFilename(String input) { byte[] fname = input.getBytes(); byte[] bad = new byte[] { '\\', '/', '""' } ; byte replace = '_'; for (int i = 0; i < fname.length; i++) { for (byte element : bad) { if (fname[i] == element) { fname[i] = replace; } } } return new String(fname); }  public static void main(String[] args) throws Exception { if (args.length < 4) { System.out.println(""Usage: java "" + Backup.class.getName() + "" api_key nsid shared_secret output_dir""); System.exit(1); } Backup bf = new Backup(args[0], args[1], args[2], new File(System.getProperty(""user.home"") + File.separatorChar + "".flickrAuth"")); bf.doBackup(new File(args[3])); } }  "
src/examples/java/FlickrCrawler.java,"import com.flickr4java.flickr.Flickr;
import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.REST;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoList;
import com.flickr4java.flickr.photos.SearchParameters;

import javax.imageio.ImageIO;
import java.io.File;
import java.io.IOException;
import java.util.Iterator;
import java.util.prefs.Preferences;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/*
 *  - Java 7 is needed
 *  - insert your api- and secretkey
 *
 *  start main with wanted tags as parameter, for example: FlickrCrawler.main(Sunset) and all pics will be saved in original size or large to pics\sunset\...
 */
public class FlickrCrawler {

    private static String path = """";
    private static Preferences userPrefs = Preferences.userNodeForPackage(FlickrCrawler.class);

    // convert filename to clean filename
    public static String convertToFileSystemChar(String name) {
        String erg = """";
        Matcher m = Pattern.compile(""[a-z0-9 _#&@\\[\\(\\)\\]\\-\\.]"", Pattern.CASE_INSENSITIVE).matcher(name);
        while (m.find()) {
            erg += name.substring(m.start(), m.end());
        }
        if (erg.length() > 200) {
            erg = erg.substring(0, 200);
            System.out.println(""cut filename: "" + erg);
        }
        return erg;
    }

    public static boolean saveImage(Flickr f, Photo p) {

        String cleanTitle = convertToFileSystemChar(p.getTitle());

        File orgFile = new File(path + File.separator + cleanTitle + ""_"" + p.getId() + ""_o."" + p.getOriginalFormat());
        File largeFile = new File(path + File.separator + cleanTitle + ""_"" + p.getId() + ""_b."" + p.getOriginalFormat());

        if (orgFile.exists() || largeFile.exists()) {
            System.out.println(p.getTitle() + ""\t"" + p.getLargeUrl() + "" skipped!"");
            return false;
        }

        try {
            Photo nfo = f.getPhotosInterface().getInfo(p.getId(), null);
            if (nfo.getOriginalSecret().isEmpty()) {
                ImageIO.write(p.getLargeImage(), p.getOriginalFormat(), largeFile);
                System.out.println(p.getTitle() + ""\t"" + p.getLargeUrl() + "" was written to "" + largeFile.getName());
            } else {
                p.setOriginalSecret(nfo.getOriginalSecret());
                ImageIO.write(p.getOriginalImage(), p.getOriginalFormat(), orgFile);
                System.out.println(p.getTitle() + ""\t"" + p.getOriginalUrl() + "" was written to "" + orgFile.getName());
            }
        } catch (FlickrException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return true;
    }

    public static void main(String[] args) {
        if (args.length == 0) {
            System.out.println(""Parameter are needed as for searching. Example: FlickrCrawler.java sunset"");
            return;
        }

        String apikey = ""apikey"";
        String secret = ""secret"";

        Flickr flickr = new Flickr(apikey, secret, new REST());
        SearchParameters searchParameters = new SearchParameters();
        searchParameters.setAccuracy(1);

        StringBuilder tagsBuilder = new StringBuilder();
        for (String tmp : args) {
            tagsBuilder.append("" "" + tmp);
        }
        path = ""pics"" + File.separator + tagsBuilder.toString().substring(1);

        new File(path).mkdirs();
        searchParameters.setTags(args);

        for (int i = userPrefs.getInt(path, 0); true; i++) {
            userPrefs.putInt( path, i );
            System.out.println(""\tcurrent page: "" + userPrefs.getInt(path, 0));
            try {
                PhotoList<Photo> list = flickr.getPhotosInterface().search(searchParameters, 500, i);
                if (list.isEmpty())
                    break;
                    
                Iterator itr = list.iterator();
                while (itr.hasNext()) {
                    saveImage(flickr, (Photo) itr.next());
                }
            } catch (FlickrException e) {
                e.printStackTrace();
            }
        }
    }
}
","public class FlickrCrawler { private static String path = """"; private static Preferences userPrefs = Preferences.userNodeForPackage(FlickrCrawler.class); public static String convertToFileSystemChar(String name) { String erg = """"; Matcher m = Pattern.compile(""[a-z0-9 _#&@\\[\\(\\)\\]\\-\\.]"", Pattern.CASE_INSENSITIVE).matcher(name); while (m.find()) { erg += name.substring(m.start(), m.end()); } if (erg.length() > 200) { erg = erg.substring(0, 200); System.out.println(""cut filename: "" + erg); } return erg; } public static boolean saveImage(Flickr f, Photo p) { String cleanTitle = convertToFileSystemChar(p.getTitle()); File orgFile = new File(path + File.separator + cleanTitle + ""_"" + p.getId() + ""_o."" + p.getOriginalFormat()); File largeFile = new File(path + File.separator + cleanTitle + ""_"" + p.getId() + ""_b."" + p.getOriginalFormat()); if (orgFile.exists() || largeFile.exists()) { System.out.println(p.getTitle() + ""\t"" + p.getLargeUrl() + "" skipped!""); return false; } try { Photo nfo = f.getPhotosInterface().getInfo(p.getId(), null); if (nfo.getOriginalSecret().isEmpty()) { ImageIO.write(p.getLargeImage(), p.getOriginalFormat(), largeFile); System.out.println(p.getTitle() + ""\t"" + p.getLargeUrl() + "" was written to "" + largeFile.getName()); } else { p.setOriginalSecret(nfo.getOriginalSecret()); ImageIO.write(p.getOriginalImage(), p.getOriginalFormat(), orgFile); System.out.println(p.getTitle() + ""\t"" + p.getOriginalUrl() + "" was written to "" + orgFile.getName()); } } catch (FlickrException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return true; } public static void main(String[] args) { if (args.length == 0) { System.out.println(""Parameter are needed as for searching. Example: FlickrCrawler.java sunset""); return; } String apikey = ""apikey""; String secret = ""secret""; Flickr flickr = new Flickr(apikey, secret, new REST()); SearchParameters searchParameters = new SearchParameters(); searchParameters.setAccuracy(1); StringBuilder tagsBuilder = new StringBuilder(); for (String tmp : args) { tagsBuilder.append("" "" + tmp); } path = ""pics"" + File.separator + tagsBuilder.toString().substring(1); new File(path).mkdirs(); searchParameters.setTags(args); for (int i = userPrefs.getInt(path, 0); true; i++) { userPrefs.putInt( path, i ); System.out.println(""\tcurrent page: "" + userPrefs.getInt(path, 0)); try { PhotoList<Photo> list = flickr.getPhotosInterface().search(searchParameters, 500, i); if (list.isEmpty())
                    break; Iterator itr = list.iterator(); while (itr.hasNext()) { saveImage(flickr, (Photo) itr.next()); } } catch (FlickrException e) { e.printStackTrace(); } } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"public class FlickrCrawler { private static String path = """"; private static Preferences userPrefs = Preferences.userNodeForPackage(FlickrCrawler.class); public static String convertToFileSystemChar(String name) { String erg = """"; Matcher m = Pattern.compile(""[a-z0-9 _#&@\\[\\(\\)\\]\\-\\.]"", Pattern.CASE_INSENSITIVE).matcher(name); while (m.find()) { erg += name.substring(m.start(), m.end()); } if (erg.length() > 200) { erg = erg.substring(0, 200); System.out.println(""cut filename: "" + erg); } return erg; } public static boolean saveImage(Flickr f, Photo p) { String cleanTitle = convertToFileSystemChar(p.getTitle()); File orgFile = new File(path + File.separator + cleanTitle + ""_"" + p.getId() + ""_o."" + p.getOriginalFormat()); File largeFile = new File(path + File.separator + cleanTitle + ""_"" + p.getId() + ""_b."" + p.getOriginalFormat()); if (orgFile.exists() || largeFile.exists()) { System.out.println(p.getTitle() + ""\t"" + p.getLargeUrl() + "" skipped!""); return false; } try { Photo nfo = f.getPhotosInterface().getInfo(p.getId(), null); if (nfo.getOriginalSecret().isEmpty()) { ImageIO.write(p.getLargeImage(), p.getOriginalFormat(), largeFile); System.out.println(p.getTitle() + ""\t"" + p.getLargeUrl() + "" was written to "" + largeFile.getName()); } else { p.setOriginalSecret(nfo.getOriginalSecret()); ImageIO.write(p.getOriginalImage(), p.getOriginalFormat(), orgFile); System.out.println(p.getTitle() + ""\t"" + p.getOriginalUrl() + "" was written to "" + orgFile.getName()); } } catch (FlickrException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return true; } public static void main(String[] args) { if (args.length == 0) { System.out.println(""Parameter are needed as for searching. Example: FlickrCrawler.java sunset""); return; } String apikey = ""apikey""; String secret = ""secret""; Flickr flickr = new Flickr(apikey, secret, new REST()); SearchParameters searchParameters = new SearchParameters(); searchParameters.setAccuracy(1); StringBuilder tagsBuilder = new StringBuilder(); for (String tmp : args) { tagsBuilder.append("" "" + tmp); } path = ""pics"" + File.separator + tagsBuilder.toString().substring(1); new File(path).mkdirs(); searchParameters.setTags(args); for (int i = userPrefs.getInt(path, 0); true; i++) { userPrefs.putInt( path, i ); System.out.println(""\tcurrent page: "" + userPrefs.getInt(path, 0)); try { PhotoList<Photo> list = flickr.getPhotosInterface().search(searchParameters, 500, i); if (list.isEmpty())
                    break; Iterator itr = list.iterator(); while (itr.hasNext()) { saveImage(flickr, (Photo) itr.next()); } } catch (FlickrException e) { e.printStackTrace(); } } } } ","import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.REST; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.SearchParameters; 
import javax.imageio.ImageIO; import java.io.File; import java.io.IOException; import java.util.Iterator; import java.util.prefs.Preferences; import java.util.regex.Matcher; import java.util.regex.Pattern;  /*
 *  - Java 7 is needed
 *  - insert your api- and secretkey
 *
 *  start main with wanted tags as parameter, for example: FlickrCrawler.main(Sunset) and all pics will be saved in original size or large to pics\sunset\...
 */ public class FlickrCrawler {  private static String path = """"; private static Preferences userPrefs = Preferences.userNodeForPackage(FlickrCrawler.class);  // convert filename to clean filename public static String convertToFileSystemChar(String name) { String erg = """"; Matcher m = Pattern.compile(""[a-z0-9 _#&@\\[\\(\\)\\]\\-\\.]"", Pattern.CASE_INSENSITIVE).matcher(name); while (m.find()) { erg += name.substring(m.start(), m.end()); } if (erg.length() > 200) { erg = erg.substring(0, 200); System.out.println(""cut filename: "" + erg); } return erg; }  public static boolean saveImage(Flickr f, Photo p) {  String cleanTitle = convertToFileSystemChar(p.getTitle());  File orgFile = new File(path + File.separator + cleanTitle + ""_"" + p.getId() + ""_o."" + p.getOriginalFormat()); File largeFile = new File(path + File.separator + cleanTitle + ""_"" + p.getId() + ""_b."" + p.getOriginalFormat());  if (orgFile.exists() || largeFile.exists()) { System.out.println(p.getTitle() + ""\t"" + p.getLargeUrl() + "" skipped!""); return false; }  try { Photo nfo = f.getPhotosInterface().getInfo(p.getId(), null); if (nfo.getOriginalSecret().isEmpty()) { ImageIO.write(p.getLargeImage(), p.getOriginalFormat(), largeFile); System.out.println(p.getTitle() + ""\t"" + p.getLargeUrl() + "" was written to "" + largeFile.getName()); } else { p.setOriginalSecret(nfo.getOriginalSecret()); ImageIO.write(p.getOriginalImage(), p.getOriginalFormat(), orgFile); System.out.println(p.getTitle() + ""\t"" + p.getOriginalUrl() + "" was written to "" + orgFile.getName()); } } catch (FlickrException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return true; }  public static void main(String[] args) { if (args.length == 0) { System.out.println(""Parameter are needed as for searching. Example: FlickrCrawler.java sunset""); return; }  String apikey = ""apikey""; String secret = ""secret"";  Flickr flickr = new Flickr(apikey, secret, new REST()); SearchParameters searchParameters = new SearchParameters(); searchParameters.setAccuracy(1);  StringBuilder tagsBuilder = new StringBuilder(); for (String tmp : args) { tagsBuilder.append("" "" + tmp); } path = ""pics"" + File.separator + tagsBuilder.toString().substring(1);  new File(path).mkdirs(); searchParameters.setTags(args);  for (int i = userPrefs.getInt(path, 0); true; i++) { userPrefs.putInt( path, i ); System.out.println(""\tcurrent page: "" + userPrefs.getInt(path, 0)); try { PhotoList<Photo> list = flickr.getPhotosInterface().search(searchParameters, 500, i); if (list.isEmpty())
                    break;                      Iterator itr = list.iterator(); while (itr.hasNext()) { saveImage(flickr, (Photo) itr.next()); } } catch (FlickrException e) { e.printStackTrace(); } } } }  "
src/examples/java/SearchExample.java,"import com.flickr4java.flickr.Flickr;
import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.REST;
import com.flickr4java.flickr.RequestContext;
import com.flickr4java.flickr.auth.Auth;
import com.flickr4java.flickr.auth.Permission;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoList;
import com.flickr4java.flickr.photos.PhotosInterface;
import com.flickr4java.flickr.photos.SearchParameters;
import com.flickr4java.flickr.util.IOUtilities;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Demonstration of how to search.
 */
public class SearchExample
{
    static String apiKey;

    static String sharedSecret;

    Flickr f;

    REST rest;

    RequestContext requestContext;

    Properties properties;

    public SearchExample() throws IOException
    {
        String setupPropertiesPath = System.getenv(""SETUP_PROPERTIES_PATH"");

        InputStream in = null;
        try
        {
            if (setupPropertiesPath != null)
            {
                in = new FileInputStream(new File(setupPropertiesPath));
            } else
            {
                in = getClass().getResourceAsStream(""/setup.properties"");
            }
            properties = new Properties();
            properties.load(in);
        } finally
        {
            IOUtilities.close(in);
        }

        f = new Flickr(properties.getProperty(""apiKey""), properties.getProperty(""secret""), new REST());
        requestContext = RequestContext.getRequestContext();
        Auth auth = new Auth();
        auth.setPermission(Permission.READ);
        auth.setToken(properties.getProperty(""token""));
        auth.setTokenSecret(properties.getProperty(""tokensecret""));
        requestContext.setAuth(auth);
        Flickr.debugRequest = false;
        Flickr.debugStream = false;
    }

    private void search(String text) throws FlickrException
    {
        PhotosInterface photos = f.getPhotosInterface();
        SearchParameters params = new SearchParameters();
        params.setMedia(""videos""); // One of ""photos"", ""videos"" or ""all""
        params.setExtras(Stream.of(""media"").collect(Collectors.toSet()));
        params.setText(text);
        PhotoList<Photo> results = photos.search(params, 5, 0);

        results.forEach(p ->
        {
            System.out.println(String.format(""Title: %s"", p.getTitle()));
            System.out.println(String.format(""Media: %s"", p.getMedia()));
            System.out.println(String.format(""Original Video URL: %s"", p.getVideoOriginalUrl()));
        });

    }

    public static void main(String[] args) throws Exception
    {
        SearchExample t = new SearchExample();
        t.search(args.length == 0 ? ""London"" : args[0]);
    }

}
","import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.REST; import com.flickr4java.flickr.RequestContext; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.auth.Permission; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotosInterface; import com.flickr4java.flickr.photos.SearchParameters; import com.flickr4java.flickr.util.IOUtilities; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.util.Properties; import java.util.stream.Collectors; import java.util.stream.Stream; public class SearchExample
{ static String apiKey; static String sharedSecret; Flickr f; REST rest; RequestContext requestContext; Properties properties; public SearchExample() throws IOException
    { String setupPropertiesPath = System.getenv(""SETUP_PROPERTIES_PATH""); InputStream in = null; try
        { if (setupPropertiesPath != null)
            { in = new FileInputStream(new File(setupPropertiesPath)); } else
            { in = getClass().getResourceAsStream(""/setup.properties""); } properties = new Properties(); properties.load(in); } finally
        { IOUtilities.close(in); } f = new Flickr(properties.getProperty(""apiKey""), properties.getProperty(""secret""), new REST()); requestContext = RequestContext.getRequestContext(); Auth auth = new Auth(); auth.setPermission(Permission.READ); auth.setToken(properties.getProperty(""token"")); auth.setTokenSecret(properties.getProperty(""tokensecret"")); requestContext.setAuth(auth); Flickr.debugRequest = false; Flickr.debugStream = false; } private void search(String text) throws FlickrException
    { PhotosInterface photos = f.getPhotosInterface(); SearchParameters params = new SearchParameters(); params.setMedia(""videos""); params.setExtras(Stream.of(""media"").collect(Collectors.toSet())); params.setText(text); PhotoList<Photo> results = photos.search(params, 5, 0); results.forEach(p ->
        { System.out.println(String.format(""Title: %s"", p.getTitle())); System.out.println(String.format(""Media: %s"", p.getMedia())); System.out.println(String.format(""Original Video URL: %s"", p.getVideoOriginalUrl())); } ); } public static void main(String[] args) throws Exception
    { SearchExample t = new SearchExample(); t.search(args.length == 0 ? ""London"" : args[0]); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.REST; import com.flickr4java.flickr.RequestContext; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.auth.Permission; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotosInterface; import com.flickr4java.flickr.photos.SearchParameters; import com.flickr4java.flickr.util.IOUtilities; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.util.Properties; import java.util.stream.Collectors; import java.util.stream.Stream; public class SearchExample
{ static String apiKey; static String sharedSecret; Flickr f; REST rest; RequestContext requestContext; Properties properties; public SearchExample() throws IOException
    { String setupPropertiesPath = System.getenv(""SETUP_PROPERTIES_PATH""); InputStream in = null; try
        { if (setupPropertiesPath != null)
            { in = new FileInputStream(new File(setupPropertiesPath)); } else
            { in = getClass().getResourceAsStream(""/setup.properties""); } properties = new Properties(); properties.load(in); } finally
        { IOUtilities.close(in); } f = new Flickr(properties.getProperty(""apiKey""), properties.getProperty(""secret""), new REST()); requestContext = RequestContext.getRequestContext(); Auth auth = new Auth(); auth.setPermission(Permission.READ); auth.setToken(properties.getProperty(""token"")); auth.setTokenSecret(properties.getProperty(""tokensecret"")); requestContext.setAuth(auth); Flickr.debugRequest = false; Flickr.debugStream = false; } private void search(String text) throws FlickrException
    { PhotosInterface photos = f.getPhotosInterface(); SearchParameters params = new SearchParameters(); params.setMedia(""videos""); params.setExtras(Stream.of(""media"").collect(Collectors.toSet())); params.setText(text); PhotoList<Photo> results = photos.search(params, 5, 0); results.forEach(p ->
        { System.out.println(String.format(""Title: %s"", p.getTitle())); System.out.println(String.format(""Media: %s"", p.getMedia())); System.out.println(String.format(""Original Video URL: %s"", p.getVideoOriginalUrl())); } ); } public static void main(String[] args) throws Exception
    { SearchExample t = new SearchExample(); t.search(args.length == 0 ? ""London"" : args[0]); } } ","import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.REST; import com.flickr4java.flickr.RequestContext; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.auth.Permission; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotosInterface; import com.flickr4java.flickr.photos.SearchParameters; import com.flickr4java.flickr.util.IOUtilities;  import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.util.Properties; import java.util.stream.Collectors; import java.util.stream.Stream;  /**
 * Demonstration of how to search.
 */ public class SearchExample
{ static String apiKey;  static String sharedSecret;  Flickr f;  REST rest;  RequestContext requestContext;  Properties properties;  public SearchExample() throws IOException
    { String setupPropertiesPath = System.getenv(""SETUP_PROPERTIES_PATH"");  InputStream in = null; try
        { if (setupPropertiesPath != null)
            { in = new FileInputStream(new File(setupPropertiesPath)); } else
            { in = getClass().getResourceAsStream(""/setup.properties""); } properties = new Properties(); properties.load(in); } finally
        { IOUtilities.close(in); }  f = new Flickr(properties.getProperty(""apiKey""), properties.getProperty(""secret""), new REST()); requestContext = RequestContext.getRequestContext(); Auth auth = new Auth(); auth.setPermission(Permission.READ); auth.setToken(properties.getProperty(""token"")); auth.setTokenSecret(properties.getProperty(""tokensecret"")); requestContext.setAuth(auth); Flickr.debugRequest = false; Flickr.debugStream = false; }  private void search(String text) throws FlickrException
    { PhotosInterface photos = f.getPhotosInterface(); SearchParameters params = new SearchParameters(); params.setMedia(""videos""); // One of ""photos"", ""videos"" or ""all"" params.setExtras(Stream.of(""media"").collect(Collectors.toSet())); params.setText(text); PhotoList<Photo> results = photos.search(params, 5, 0);  results.forEach(p ->
        { System.out.println(String.format(""Title: %s"", p.getTitle())); System.out.println(String.format(""Media: %s"", p.getMedia())); System.out.println(String.format(""Original Video URL: %s"", p.getVideoOriginalUrl())); } );  }  public static void main(String[] args) throws Exception
    { SearchExample t = new SearchExample(); t.search(args.length == 0 ? ""London"" : args[0]); }  }  "
src/examples/java/UploadPhoto.java,"import com.flickr4java.flickr.Flickr;
import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.REST;
import com.flickr4java.flickr.RequestContext;
import com.flickr4java.flickr.auth.Auth;
import com.flickr4java.flickr.auth.AuthInterface;
import com.flickr4java.flickr.auth.Permission;
import com.flickr4java.flickr.people.PeopleInterface;
import com.flickr4java.flickr.people.User;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoList;
import com.flickr4java.flickr.photos.PhotosInterface;
import com.flickr4java.flickr.photosets.Photoset;
import com.flickr4java.flickr.photosets.Photosets;
import com.flickr4java.flickr.photosets.PhotosetsInterface;
import com.flickr4java.flickr.prefs.PrefsInterface;
import com.flickr4java.flickr.uploader.UploadMetaData;
import com.flickr4java.flickr.uploader.Uploader;
import com.flickr4java.flickr.util.AuthStore;
import com.flickr4java.flickr.util.FileAuthStore;
import com.github.scribejava.core.model.OAuth1RequestToken;
import com.github.scribejava.core.model.OAuth1Token;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;
import java.util.Scanner;
import java.util.Set;

/**
 * A simple program to upload photos to a set. It checks for files already uploaded assuming the title is not changed so that it can be rerun if partial upload
 * is done. It uses the tag field to store the filename as OrigFileName to be used while downloading if the title has been changed. If setup.properties is not
 * available, pass the apiKey and secret as arguments to the program.
 * 
 * This sample also uses the AuthStore interface, so users will only be asked to authorize on the first run.
 * 
 * Please NOTE that this needs Java 7 to work. Java 7 was released on July 28, 2011 and soon Java 6 may not be supported anymore ( Jul 2014).
 * 
 * @author Keyur Parikh
 */

public class UploadPhoto {

    private static final Logger logger = LoggerFactory.getLogger(UploadPhoto.class);

    private String nsid;

    private String username;

    // private final String sharedSecret;

    private final Flickr flickr;

    private AuthStore authStore;

    public boolean flickrDebug = false;

    private boolean setOrigFilenameTag = true;

    private boolean replaceSpaces = false;

    private int privacy = -1;

    HashMap<String, Photoset> allSetsMap = new HashMap<String, Photoset>();

    HashMap<String, ArrayList<String>> setNameToId = new HashMap<String, ArrayList<String>>();

    public static final SimpleDateFormat smp = new SimpleDateFormat(""yyyy.MM.dd HH:mm:ss a"");

    public UploadPhoto(String apiKey, String nsid, String sharedSecret, File authsDir, String username) throws FlickrException {
        flickr = new Flickr(apiKey, sharedSecret, new REST());

        this.username = username;
        this.nsid = nsid;
        // this.sharedSecret = sharedSecret;

        if (authsDir != null) {
            this.authStore = new FileAuthStore(authsDir);
        }

        // If one of them is not filled in, find and populate it.
        if (username == null || username.equals(""""))
            setUserName();
        if (nsid == null || nsid.equals(""""))
            setNsid();

    }

    private void setUserName() throws FlickrException {
        if (nsid != null && !nsid.equals("""")) {
            Auth auth = null;
            if (authStore != null) {
                auth = authStore.retrieve(nsid);
                if (auth != null) {
                    username = auth.getUser().getUsername();
                }
            }
            // For this to work: REST.java or PeopleInterface needs to change to pass apiKey
            // as the parameter to the call which is not authenticated.

            if (auth == null) {
                // Get nsid using flickr.people.findByUsername
                PeopleInterface peopleInterf = flickr.getPeopleInterface();
                User u = peopleInterf.getInfo(nsid);
                if (u != null) {
                    username = u.getUsername();
                }
            }
        }
    }

    /**
     * Check local saved copy first ??. If Auth by username is available, then we will not need to make the API call.
     * 
     * @throws FlickrException if there was a problem connecting to Flickr
     */

    private void setNsid() throws FlickrException {

        if (username != null && !username.equals("""")) {
            Auth auth = null;
            if (authStore != null) {
                auth = authStore.retrieve(username); // assuming FileAuthStore is enhanced else need to
                // keep in user-level files.

                if (auth != null) {
                    nsid = auth.getUser().getId();
                }
            }
            if (auth != null)
                return;

            Auth[] allAuths = authStore.retrieveAll();
            for (int i = 0; i < allAuths.length; i++) {
                if (username.equals(allAuths[i].getUser().getUsername())) {
                    nsid = allAuths[i].getUser().getId();
                    return;
                }
            }

            // For this to work: REST.java or PeopleInterface needs to change to pass apiKey
            // as the parameter to the call which is not authenticated.

            // Get nsid using flickr.people.findByUsername
            PeopleInterface peopleInterf = flickr.getPeopleInterface();
            User u = peopleInterf.findByUsername(username);
            if (u != null) {
                nsid = u.getId();
            }
        }
    }

    private void authorize() throws IOException, FlickrException {
        AuthInterface authInterface = flickr.getAuthInterface();
        OAuth1RequestToken accessToken = authInterface.getRequestToken();

        // Try with DELETE permission. At least need write permission for upload and add-to-set.
        String url = authInterface.getAuthorizationUrl(accessToken, Permission.DELETE);
        System.out.println(""Follow this URL to authorise yourself on Flickr"");
        System.out.println(url);
        System.out.println(""Paste in the token it gives you:"");
        System.out.print("">>"");

        Scanner scanner = new Scanner(System.in);
        String tokenKey = scanner.nextLine();

        OAuth1Token requestToken = authInterface.getAccessToken(accessToken, tokenKey);

        Auth auth = authInterface.checkToken(requestToken);
        RequestContext.getRequestContext().setAuth(auth);
        this.authStore.store(auth);
        scanner.close();
        System.out.println(""Thanks.  You probably will not have to do this every time. Auth saved for user: "" + auth.getUser().getUsername() + "" nsid is: ""
                + auth.getUser().getId());
        System.out.println("" AuthToken: "" + auth.getToken() + "" tokenSecret: "" + auth.getTokenSecret());
    }

    /**
     * If the Authtoken was already created in a separate program but not saved to file.
     * 
     * @param authToken
     * @param tokenSecret
     * @param username
     * @return
     * @throws IOException
     */
    private Auth constructAuth(String authToken, String tokenSecret, String username) throws IOException {

        Auth auth = new Auth();
        auth.setToken(authToken);
        auth.setTokenSecret(tokenSecret);

        // Prompt to ask what permission is needed: read, update or delete.
        auth.setPermission(Permission.fromString(""delete""));

        User user = new User();
        // Later change the following 3. Either ask user to pass on command line or read
        // from saved file.
        user.setId(nsid);
        user.setUsername((username));
        user.setRealName("""");
        auth.setUser(user);
        this.authStore.store(auth);
        return auth;
    }

    public void setAuth(String authToken, String username, String tokenSecret) throws IOException, FlickrException {
        RequestContext rc = RequestContext.getRequestContext();
        Auth auth = null;

        if (authToken != null && !authToken.equals("""") && tokenSecret != null && !tokenSecret.equals("""")) {
            auth = constructAuth(authToken, tokenSecret, username);
            rc.setAuth(auth);
        } else {
            if (this.authStore != null) {
                auth = this.authStore.retrieve(this.nsid);
                if (auth == null) {
                    this.authorize();
                } else {
                    rc.setAuth(auth);
                }
            }
        }
    }

    public int getPrivacy() throws Exception {

        PrefsInterface prefi = flickr.getPrefsInterface();
        privacy = prefi.getPrivacy();

        return (privacy);
    }

    private String makeSafeFilename(String input) {
        byte[] fname = input.getBytes();
        byte[] bad = new byte[] { '\\', '/', '""', '*' };
        byte replace = '_';
        for (int i = 0; i < fname.length; i++) {
            for (byte element : bad) {
                if (fname[i] == element) {
                    fname[i] = replace;
                }
            }
            if (replaceSpaces && fname[i] == ' ')
                fname[i] = '_';
        }
        return new String(fname);
    }

    public String uploadfile(String filename, String inpTitle) throws Exception {
        String photoId;

        RequestContext rc = RequestContext.getRequestContext();

        if (this.authStore != null) {
            Auth auth = this.authStore.retrieve(this.nsid);
            if (auth == null) {
                this.authorize();
            } else {
                rc.setAuth(auth);
            }
        }

        // PhotosetsInterface pi = flickr.getPhotosetsInterface();
        // PhotosInterface photoInt = flickr.getPhotosInterface();
        // Map<String, Collection> allPhotos = new HashMap<String, Collection>();
        /**
         * 1 : Public 2 : Friends only 3 : Family only 4 : Friends and Family 5 : Private
         **/
        if (privacy == -1)
            getPrivacy();

        UploadMetaData metaData = new UploadMetaData();

        if (privacy == 1)
            metaData.setPublicFlag(true);
        if (privacy == 2 || privacy == 4)
            metaData.setFriendFlag(true);
        if (privacy == 3 || privacy == 4)
            metaData.setFamilyFlag(true);

        if (basefilename == null || basefilename.equals(""""))
            basefilename = filename; // ""image.jpg"";

        String title = basefilename;
        boolean setMimeType = true; // change during testing. Doesn't seem to be supported at this time in flickr.
        if (setMimeType) {
            if (basefilename.lastIndexOf('.') > 0) {
                title = basefilename.substring(0, basefilename.lastIndexOf('.'));
                String suffix = basefilename.substring(basefilename.lastIndexOf('.') + 1);
                // Set Mime Type if known.

                // Later use a mime-type properties file or a hash table of all known photo and video types
                // allowed by flickr.

                if (suffix.equalsIgnoreCase(""png"")) {
                    metaData.setFilemimetype(""image/png"");
                } else if (suffix.equalsIgnoreCase(""mpg"") || suffix.equalsIgnoreCase(""mpeg"")) {
                    metaData.setFilemimetype(""video/mpeg"");
                } else if (suffix.equalsIgnoreCase(""mov"")) {
                    metaData.setFilemimetype(""video/quicktime"");
                }
            }
        }
        logger.debug("" File : "" + filename);
        logger.debug("" basefilename : "" + basefilename);

        if (inpTitle != null && !inpTitle.equals("""")) {
            title = inpTitle;
            logger.debug("" title : "" + inpTitle);
            metaData.setTitle(title);
        } // flickr defaults the title field from file name.

        // UploadMeta is using String not Tag class.

        // Tags are getting mangled by yahoo stripping off the = , '.' and many other punctuation characters
        // and converting to lower case: use the raw tag field to find the real value for checking and
        // for download.
        if (setOrigFilenameTag) {
            List<String> tags = new ArrayList<String>();
            String tmp = basefilename;
            basefilename = makeSafeFilename(basefilename);
            tags.add(""OrigFileName='"" + basefilename + ""'"");
            metaData.setTags(tags);

            if (!tmp.equals(basefilename)) {
                System.out.println("" File : "" + basefilename + "" contains special characters.  stored as "" + basefilename + "" in tag field"");
            }
        }

        // File imageFile = new File(filename);
        // InputStream in = null;
        Uploader uploader = flickr.getUploader();

        // ByteArrayOutputStream out = null;
        try {
            // in = new FileInputStream(imageFile);
            // out = new ByteArrayOutputStream();

            // int b = -1;
            /**
             * while ((b = in.read()) != -1) { out.write((byte) b); }
             **/

            /**
             * byte[] buf = new byte[1024]; while ((b = in.read(buf)) != -1) { // fos.write(read); out.write(buf, 0, b); }
             **/

            metaData.setFilename(basefilename);
            // check correct handling of escaped value

            File f = new File(filename);
            photoId = uploader.upload(f, metaData);

            logger.debug("" File : "" + filename + "" uploaded: photoId = "" + photoId);
        } finally {

        }

        return (photoId);
    }

    public void getPhotosetsInfo() {

        PhotosetsInterface pi = flickr.getPhotosetsInterface();
        try {
            int setsPage = 1;
            while (true) {
                Photosets photosets = pi.getList(nsid, 500, setsPage, null);
                Collection<Photoset> setsColl = photosets.getPhotosets();
                Iterator<Photoset> setsIter = setsColl.iterator();
                while (setsIter.hasNext()) {
                    Photoset set = setsIter.next();
                    allSetsMap.put(set.getId(), set);

                    // 2 or more sets can in theory have the same name. !!!
                    ArrayList<String> setIdarr = setNameToId.get(set.getTitle());
                    if (setIdarr == null) {
                        setIdarr = new ArrayList<String>();
                        setIdarr.add(new String(set.getId()));
                        setNameToId.put(set.getTitle(), setIdarr);
                    } else {
                        setIdarr.add(new String(set.getId()));
                    }
                }

                if (setsColl.size() < 500) {
                    break;
                }
                setsPage++;
            }
            logger.debug("" Sets retrieved: "" + allSetsMap.size());
            // all_sets_retrieved = true;
            // Print dups if any.

            Set<String> keys = setNameToId.keySet();
            Iterator<String> iter = keys.iterator();
            while (iter.hasNext()) {
                String name = iter.next();
                ArrayList<String> setIdarr = setNameToId.get(name);
                if (setIdarr != null && setIdarr.size() > 1) {
                    System.out.println(""There is more than 1 set with this name : "" + setNameToId.get(name));
                    for (int j = 0; j < setIdarr.size(); j++) {
                        System.out.println(""           id: "" + setIdarr.get(j));
                    }
                }
            }

        } catch (FlickrException e) {
            e.printStackTrace();
        }
    }

    private String setid = null;

    private String basefilename = null;

    private final PhotoList<Photo> photos = new PhotoList<Photo>();

    private final HashMap<String, Photo> filePhotos = new HashMap<String, Photo>();

    private static void Usage() {
        System.out.println(""Usage: java "" + UploadPhoto.class.getName() + ""  [ -n nsid | -u username ] -s setName { File../Directories}"");
        System.out.println(""	Must pass either -u username or -n nsid "");
        System.out.println(""	Must pass  -s followed by set-name(albums)  followed by file/directories."");
        System.out
                .println(""apiKey and shared secret must be available as apiKey and secret via setup.properties or passed as -apiKey key -secret shared-secret"");
        System.exit(1);
    }

    /**
     * @return the setOrigFilenameTag
     */
    public boolean isSetorigfilenametag() {
        return setOrigFilenameTag;
    }

    /**
     * @param setOrigFilenameTag
     *            the setOrigFilenameTag to set
     */
    public void setSetorigfilenametag(boolean setOrigFilenameTag) {
        this.setOrigFilenameTag = setOrigFilenameTag;
    }

    public static void main(String[] args) throws Exception {

        String apiKey = null; // args[0];
        String sharedSecret = null; // args[1];

        Properties properties = new Properties();
        InputStream in = null;
        try {
            in = UploadPhoto.class.getResourceAsStream(""/setup.properties"");
            if (in != null) {
                properties.load(in);
                apiKey = properties.getProperty(""apiKey"");
                sharedSecret = properties.getProperty(""secret"");
                if (apiKey != null && sharedSecret != null)
                    logger.debug(""Found setup.properties in classpath and set apiKey and shared secret"");
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (in != null)
                in.close();
        }

        if (args.length < 5) {
            Usage();
            System.exit(1);
        }

        ArrayList<String> uploadfileArgs = new ArrayList<String>();
        ArrayList<String> optionArgs = new ArrayList<String>();

        // Flickr.debugRequest = true; // keep it false else entire file will be in stdout.

        // Flickr.debugStream = true;

        String authsDirStr = System.getProperty(""user.home"") + File.separatorChar + "".flickrAuth"";

        String nsid = null;
        String username = null;
        String accessToken = null; // Optional entry.
        String tokenSecret = null; // Optional entry.
        String setName = null;

        boolean settagname = true; // Default to true to add tag while uploading.

        int i = 0;
        /***
         * for(i = 0; i < args.length; i++) { System.out.println(""args["" + i + ""] "" + args[i]); }
         **/

        for (i = 0; i < args.length; i++) {
            switch (args[i]) {
            case ""-n"":
                if (i < args.length)
                    nsid = args[++i];
                break;
            case ""-u"":
                if (i < args.length)
                    username = args[++i];
                break;
            case ""-apiKey"":
                if (i < args.length)
                    apiKey = args[++i];
                break;

            case ""-secret"":
                if (i < args.length)
                    sharedSecret = args[++i];
                break;
            case ""-notags"":
                if (i < args.length)
                    settagname = false;
                break;

            case ""-a"":
                if (i < args.length)
                    accessToken = args[++i];
                break;
            case ""-t"":
                if (i < args.length)
                    tokenSecret = args[++i];
                break;
            case ""-s"":
                if (i < args.length)
                    setName = args[++i];
                break;
            case ""-option"":
                if (i < args.length)
                    optionArgs.add(args[++i]);
                break;
            default:
                if (setName != null)
                    uploadfileArgs.add(args[i]);
                else {
                    Usage();
                    System.exit(1);
                }
            }
        }

        if (apiKey == null || sharedSecret == null || (username == null && nsid == null) || (setName == null) || (uploadfileArgs.size() == 0)) {
            Usage();
            System.exit(1);
        }

        UploadPhoto bf = new UploadPhoto(apiKey, nsid, sharedSecret, new File(authsDirStr), username);
        for (i = 0; i < optionArgs.size(); i++) {
            bf.addOption(optionArgs.get(i));
        }
        bf.setSetorigfilenametag(settagname);
        bf.setAuth(accessToken, username, tokenSecret);

        if (!bf.canUpload())
            System.exit(1);

        bf.getPrivacy();

        bf.getPhotosetsInfo();

        if (setName != null && !setName.equals("""")) {

            bf.getSetPhotos(setName);
        }

        // String photoid;

        for (i = 0; i < uploadfileArgs.size(); i++) {
            String filename = uploadfileArgs.get(i);

            File f = new File(filename);
            if (f.isDirectory()) {
                String[] filelist = f.list(new UploadFilenameFilter());
                logger.debug(""Processing directory  : "" + uploadfileArgs.get(i));
                for (int j = 0; j < filelist.length; j++) {
                    bf.processFileArg(uploadfileArgs.get(i) + File.separatorChar + filelist[j], setName);
                }
            } else {
                bf.processFileArg(filename, setName);
            }
        }
    }

    private static final String[] photoSuffixes = { ""jpg"", ""jpeg"", ""png"", ""gif"", ""bmp"", ""tif"", ""tiff"" };

    private static final String[] videoSuffixes = { ""3gp"", ""3gp"", ""avi"", ""mov"", ""mp4"", ""mpg"", ""mpeg"", ""wmv"", ""ogg"", ""ogv"", ""m2v"" };

    static class UploadFilenameFilter implements FilenameFilter {

        // Following suffixes from flickr upload page. An App should have this configurable,
        // for videos and photos separately.

        @Override
        public boolean accept(File dir, String name) {
            if (isValidSuffix(name))
                return true;
            else
                return false;
        }

    }

    private static boolean isValidSuffix(String basefilename) {
        if (basefilename.lastIndexOf('.') <= 0) {
            return false;
        }
        String suffix = basefilename.substring(basefilename.lastIndexOf('.') + 1).toLowerCase();
        for (int i = 0; i < photoSuffixes.length; i++) {
            if (photoSuffixes[i].equals(suffix))
                return true;
        }
        for (int i = 0; i < videoSuffixes.length; i++) {
            if (videoSuffixes[i].equals(suffix))
                return true;
        }
        logger.debug(basefilename + "" does not have a valid suffix, skipped."");
        return false;
    }

    private void processFileArg(String filename, String setName) throws Exception {
        String photoid;
        if (filename.equals("""")) {
            System.out.println(""filename must be entered for uploadfile "");
            return;
        }
        if (filename.lastIndexOf(File.separatorChar) > 0)
            basefilename = filename.substring(filename.lastIndexOf(File.separatorChar) + 1, filename.length());
        else
            basefilename = filename;

        boolean fileUploaded = checkIfLoaded(filename);

        if (!fileUploaded) {
            if (!isValidSuffix(basefilename)) {
                System.out.println("" File: "" + basefilename + "" is not a supported filetype for flickr (invalid suffix)"");
                return;
            }

            File f = new File(filename);
            if (!f.exists() || !f.canRead()) {
                System.out.println("" File: "" + filename + "" cannot be processed, does not exist or is unreadable."");
                return;
            }
            logger.debug(""Calling uploadfile for filename : "" + filename);
            logger.info(""Upload of "" + filename + "" started at: "" + smp.format(new Date()) + ""\n"");

            photoid = uploadfile(filename, null);
            // Add to Set. Create set if it does not exist.
            if (photoid != null) {
                addPhotoToSet(photoid, setName);
            }
            logger.info(""Upload of "" + filename + "" finished at: "" + smp.format(new Date()) + ""\n"");

        } else {
            logger.info("" File: "" + filename + "" has already been loaded on "" + getUploadedTime(filename));
        }
    }

    private void addOption(String opt) {

        switch (opt) {
        case ""replaceSpaces"":
            replaceSpaces = true;
            break;

        case ""notags"":
            setSetorigfilenametag(false);
            break;

        default: // Not supported at this time.
            System.out.println(""Option: "" + opt + "" is not supported at this time"");
        }
    }

    private boolean canUpload() {
        RequestContext rc = RequestContext.getRequestContext();
        Auth auth = null;
        auth = rc.getAuth();
        if (auth == null) {
            System.out.println("" Cannot upload, there is no authorization information."");
            return false;
        }
        Permission perm = auth.getPermission();
        if ((perm.getType() == Permission.WRITE_TYPE) || (perm.getType() == Permission.DELETE_TYPE))
            return true;
        else {
            System.out.println("" Cannot upload, You need write or delete permission, you have : "" + perm.toString());
            return false;
        }
    }

    /**
     * The assumption here is that for a given set only unique file-names will be loaded and the title field can be used. Later change to use the tags field (
     * OrigFileName) and strip off the suffix.
     * 
     * @param filename
     * @return
     */
    private boolean checkIfLoaded(String filename) {

        String title;
        if (basefilename.lastIndexOf('.') > 0)
            title = basefilename.substring(0, basefilename.lastIndexOf('.'));
        else
            return false;

        if (filePhotos.containsKey(title))
            return true;

        return false;
    }

    private String getUploadedTime(String filename) {

        String title = """";
        if (basefilename.lastIndexOf('.') > 0)
            title = basefilename.substring(0, basefilename.lastIndexOf('.'));

        if (filePhotos.containsKey(title)) {
            Photo p = filePhotos.get(title);
            if (p.getDatePosted() != null) {
                return (smp.format(p.getDatePosted()));
            }
        }

        return """";
    }

    private void getSetPhotos(String setName) throws FlickrException {
        // Check if this is an existing set. If it is get all the photo list to avoid reloading already
        // loaded photos.
        ArrayList<String> setIdarr;
        setIdarr = setNameToId.get(setName);
        if (setIdarr != null) {
            setid = setIdarr.get(0);
            PhotosetsInterface pi = flickr.getPhotosetsInterface();

            Set<String> extras = new HashSet<String>();
            /**
             * A comma-delimited list of extra information to fetch for each returned record. Currently supported fields are: license, date_upload, date_taken,
             * owner_name, icon_server, original_format, last_update, geo, tags, machine_tags, o_dims, views, media, path_alias, url_sq, url_t, url_s, url_m,
             * url_o
             */

            extras.add(""date_upload"");
            extras.add(""original_format"");
            extras.add(""media"");
            // extras.add(""url_o"");
            extras.add(""tags"");

            int setPage = 1;
            while (true) {
                PhotoList<Photo> tmpSet = pi.getPhotos(setid, extras, Flickr.PRIVACY_LEVEL_NO_FILTER, 500, setPage);

                int tmpSetSize = tmpSet.size();
                photos.addAll(tmpSet);
                if (tmpSetSize < 500) {
                    break;
                }
                setPage++;
            }
            for (int i = 0; i < photos.size(); i++) {
                filePhotos.put(photos.get(i).getTitle(), photos.get(i));
            }
            if (flickrDebug) {
                logger.debug(""Set title: "" + setName + ""  id:  "" + setid + "" found"");
                logger.debug(""   Photos in Set already loaded: "" + photos.size());
            }
        }
    }

    public void addPhotoToSet(String photoid, String setName) throws Exception {

        ArrayList<String> setIdarr;

        // all_set_maps.

        PhotosetsInterface psetsInterface = flickr.getPhotosetsInterface();

        Photoset set = null;

        if (setid == null) {
            // In case it is a new photo-set.
            setIdarr = setNameToId.get(setName);
            if (setIdarr == null) {
                // setIdarr should be null since we checked it getSetPhotos.
                // Create the new set.
                // set the setid .

                String description = """";
                set = psetsInterface.create(setName, description, photoid);
                setid = set.getId();

                setIdarr = new ArrayList<String>();
                setIdarr.add(new String(setid));
                setNameToId.put(setName, setIdarr);

                allSetsMap.put(set.getId(), set);
            }
        } else {
            set = allSetsMap.get(setid);
            psetsInterface.addPhoto(setid, photoid);
        }
        // Add to photos .

        // Add Photo to existing set.
        PhotosInterface photoInt = flickr.getPhotosInterface();
        Photo p = photoInt.getPhoto(photoid);
        if (p != null) {
            photos.add(p);
            String title;
            if (basefilename.lastIndexOf('.') > 0)
                title = basefilename.substring(0, basefilename.lastIndexOf('.'));
            else
                title = p.getTitle();
            filePhotos.put(title, p);
        }
    }
}
","public class UploadPhoto { private static final Logger logger = LoggerFactory.getLogger(UploadPhoto.class); private String nsid; private String username; private final Flickr flickr; private AuthStore authStore; public boolean flickrDebug = false; private boolean setOrigFilenameTag = true; private boolean replaceSpaces = false; private int privacy = -1; HashMap<String, Photoset> allSetsMap = new HashMap<String, Photoset>(); HashMap<String, ArrayList<String>> setNameToId = new HashMap<String, ArrayList<String>>(); public static final SimpleDateFormat smp = new SimpleDateFormat(""yyyy.MM.dd HH:mm:ss a""); public UploadPhoto(String apiKey, String nsid, String sharedSecret, File authsDir, String username) throws FlickrException { flickr = new Flickr(apiKey, sharedSecret, new REST()); this.username = username; this.nsid = nsid; if (authsDir != null) { this.authStore = new FileAuthStore(authsDir); } if (username == null || username.equals(""""))
            setUserName(); if (nsid == null || nsid.equals(""""))
            setNsid(); } private void setUserName() throws FlickrException { if (nsid != null && !nsid.equals("""")) { Auth auth = null; if (authStore != null) { auth = authStore.retrieve(nsid); if (auth != null) { username = auth.getUser().getUsername(); } } if (auth == null) { PeopleInterface peopleInterf = flickr.getPeopleInterface(); User u = peopleInterf.getInfo(nsid); if (u != null) { username = u.getUsername(); } } } } private void setNsid() throws FlickrException { if (username != null && !username.equals("""")) { Auth auth = null; if (authStore != null) { auth = authStore.retrieve(username); if (auth != null) { nsid = auth.getUser().getId(); } } if (auth != null)
                return; Auth[] allAuths = authStore.retrieveAll(); for (int i = 0; i < allAuths.length; i++) { if (username.equals(allAuths[i].getUser().getUsername())) { nsid = allAuths[i].getUser().getId(); return; } } PeopleInterface peopleInterf = flickr.getPeopleInterface(); User u = peopleInterf.findByUsername(username); if (u != null) { nsid = u.getId(); } } } private void authorize() throws IOException, FlickrException { AuthInterface authInterface = flickr.getAuthInterface(); OAuth1RequestToken accessToken = authInterface.getRequestToken(); String url = authInterface.getAuthorizationUrl(accessToken, Permission.DELETE); System.out.println(""Follow this URL to authorise yourself on Flickr""); System.out.println(url); System.out.println(""Paste in the token it gives you:""); System.out.print("">>""); Scanner scanner = new Scanner(System.in); String tokenKey = scanner.nextLine(); OAuth1Token requestToken = authInterface.getAccessToken(accessToken, tokenKey); Auth auth = authInterface.checkToken(requestToken); RequestContext.getRequestContext().setAuth(auth); this.authStore.store(auth); scanner.close(); System.out.println(""Thanks.  You probably will not have to do this every time. Auth saved for user: "" + auth.getUser().getUsername() + "" nsid is: ""
                + auth.getUser().getId()); System.out.println("" AuthToken: "" + auth.getToken() + "" tokenSecret: "" + auth.getTokenSecret()); } private Auth constructAuth(String authToken, String tokenSecret, String username) throws IOException { Auth auth = new Auth(); auth.setToken(authToken); auth.setTokenSecret(tokenSecret); auth.setPermission(Permission.fromString(""delete"")); User user = new User(); user.setId(nsid); user.setUsername((username)); user.setRealName(""""); auth.setUser(user); this.authStore.store(auth); return auth; } public void setAuth(String authToken, String username, String tokenSecret) throws IOException, FlickrException { RequestContext rc = RequestContext.getRequestContext(); Auth auth = null; if (authToken != null && !authToken.equals("""") && tokenSecret != null && !tokenSecret.equals("""")) { auth = constructAuth(authToken, tokenSecret, username); rc.setAuth(auth); } else { if (this.authStore != null) { auth = this.authStore.retrieve(this.nsid); if (auth == null) { this.authorize(); } else { rc.setAuth(auth); } } } } public int getPrivacy() throws Exception { PrefsInterface prefi = flickr.getPrefsInterface(); privacy = prefi.getPrivacy(); return (privacy); } private String makeSafeFilename(String input) { byte[] fname = input.getBytes(); byte[] bad = new byte[] { '\\', '/', '""', '*' } ; byte replace = '_'; for (int i = 0; i < fname.length; i++) { for (byte element : bad) { if (fname[i] == element) { fname[i] = replace; } } if (replaceSpaces && fname[i] == ' ')
                fname[i] = '_'; } return new String(fname); } public String uploadfile(String filename, String inpTitle) throws Exception { String photoId; RequestContext rc = RequestContext.getRequestContext(); if (this.authStore != null) { Auth auth = this.authStore.retrieve(this.nsid); if (auth == null) { this.authorize(); } else { rc.setAuth(auth); } } if (privacy == -1)
            getPrivacy(); UploadMetaData metaData = new UploadMetaData(); if (privacy == 1)
            metaData.setPublicFlag(true); if (privacy == 2 || privacy == 4)
            metaData.setFriendFlag(true); if (privacy == 3 || privacy == 4)
            metaData.setFamilyFlag(true); if (basefilename == null || basefilename.equals(""""))
            basefilename = filename; String title = basefilename; boolean setMimeType = true; if (setMimeType) { if (basefilename.lastIndexOf('.') > 0) { title = basefilename.substring(0, basefilename.lastIndexOf('.')); String suffix = basefilename.substring(basefilename.lastIndexOf('.') + 1); if (suffix.equalsIgnoreCase(""png"")) { metaData.setFilemimetype(""image/png""); } else if (suffix.equalsIgnoreCase(""mpg"") || suffix.equalsIgnoreCase(""mpeg"")) { metaData.setFilemimetype(""video/mpeg""); } else if (suffix.equalsIgnoreCase(""mov"")) { metaData.setFilemimetype(""video/quicktime""); } } } if (inpTitle != null && !inpTitle.equals("""")) { title = inpTitle; metaData.setTitle(title); } if (setOrigFilenameTag) { List<String> tags = new ArrayList<String>(); String tmp = basefilename; basefilename = makeSafeFilename(basefilename); tags.add(""OrigFileName='"" + basefilename + ""'""); metaData.setTags(tags); if (!tmp.equals(basefilename)) { System.out.println("" File : "" + basefilename + "" contains special characters.  stored as "" + basefilename + "" in tag field""); } } Uploader uploader = flickr.getUploader(); try { metaData.setFilename(basefilename); File f = new File(filename); photoId = uploader.upload(f, metaData); } finally { } return (photoId); } public void getPhotosetsInfo() { PhotosetsInterface pi = flickr.getPhotosetsInterface(); try { int setsPage = 1; while (true) { Photosets photosets = pi.getList(nsid, 500, setsPage, null); Collection<Photoset> setsColl = photosets.getPhotosets(); Iterator<Photoset> setsIter = setsColl.iterator(); while (setsIter.hasNext()) { Photoset set = setsIter.next(); allSetsMap.put(set.getId(), set); ArrayList<String> setIdarr = setNameToId.get(set.getTitle()); if (setIdarr == null) { setIdarr = new ArrayList<String>(); setIdarr.add(new String(set.getId())); setNameToId.put(set.getTitle(), setIdarr); } else { setIdarr.add(new String(set.getId())); } } if (setsColl.size() < 500) { break; } setsPage++; } Set<String> keys = setNameToId.keySet(); Iterator<String> iter = keys.iterator(); while (iter.hasNext()) { String name = iter.next(); ArrayList<String> setIdarr = setNameToId.get(name); if (setIdarr != null && setIdarr.size() > 1) { System.out.println(""There is more than 1 set with this name : "" + setNameToId.get(name)); for (int j = 0; j < setIdarr.size(); j++) { System.out.println(""           id: "" + setIdarr.get(j)); } } } } catch (FlickrException e) { e.printStackTrace(); } } private String setid = null; private String basefilename = null; private final PhotoList<Photo> photos = new PhotoList<Photo>(); private final HashMap<String, Photo> filePhotos = new HashMap<String, Photo>(); private static void Usage() { System.out.println(""Usage: java "" + UploadPhoto.class.getName() + ""  [ -n nsid | -u username ] -s setName { File../Directories} ""); System.out.println(""	Must pass either -u username or -n nsid ""); System.out.println(""	Must pass  -s followed by set-name(albums)  followed by file/directories.""); System.out
                .println(""apiKey and shared secret must be available as apiKey and secret via setup.properties or passed as -apiKey key -secret shared-secret""); System.exit(1); } public boolean isSetorigfilenametag() { return setOrigFilenameTag; } public void setSetorigfilenametag(boolean setOrigFilenameTag) { this.setOrigFilenameTag = setOrigFilenameTag; } public static void main(String[] args) throws Exception { String apiKey = null; String sharedSecret = null; Properties properties = new Properties(); InputStream in = null; try { in = UploadPhoto.class.getResourceAsStream(""/setup.properties""); if (in != null) { properties.load(in); apiKey = properties.getProperty(""apiKey""); sharedSecret = properties.getProperty(""secret""); } } catch (Exception e) { e.printStackTrace(); } finally { if (in != null)
                in.close(); } if (args.length < 5) { Usage(); System.exit(1); } ArrayList<String> uploadfileArgs = new ArrayList<String>(); ArrayList<String> optionArgs = new ArrayList<String>(); String authsDirStr = System.getProperty(""user.home"") + File.separatorChar + "".flickrAuth""; String nsid = null; String username = null; String accessToken = null; String tokenSecret = null; String setName = null; boolean settagname = true; int i = 0; for (i = 0; i < args.length; i++) { switch (args[i]) { case ""-n"":
                if (i < args.length)
                    nsid = args[++i]; break; case ""-u"":
                if (i < args.length)
                    username = args[++i]; break; case ""-apiKey"":
                if (i < args.length)
                    apiKey = args[++i]; break; case ""-secret"":
                if (i < args.length)
                    sharedSecret = args[++i]; break; case ""-notags"":
                if (i < args.length)
                    settagname = false; break; case ""-a"":
                if (i < args.length)
                    accessToken = args[++i]; break; case ""-t"":
                if (i < args.length)
                    tokenSecret = args[++i]; break; case ""-s"":
                if (i < args.length)
                    setName = args[++i]; break; case ""-option"":
                if (i < args.length)
                    optionArgs.add(args[++i]); break; default:
                if (setName != null)
                    uploadfileArgs.add(args[i]); else { Usage(); System.exit(1); } } } if (apiKey == null || sharedSecret == null || (username == null && nsid == null) || (setName == null) || (uploadfileArgs.size() == 0)) { Usage(); System.exit(1); } UploadPhoto bf = new UploadPhoto(apiKey, nsid, sharedSecret, new File(authsDirStr), username); for (i = 0; i < optionArgs.size(); i++) { bf.addOption(optionArgs.get(i)); } bf.setSetorigfilenametag(settagname); bf.setAuth(accessToken, username, tokenSecret); if (!bf.canUpload())
            System.exit(1); bf.getPrivacy(); bf.getPhotosetsInfo(); if (setName != null && !setName.equals("""")) { bf.getSetPhotos(setName); } for (i = 0; i < uploadfileArgs.size(); i++) { String filename = uploadfileArgs.get(i); File f = new File(filename); if (f.isDirectory()) { String[] filelist = f.list(new UploadFilenameFilter()); for (int j = 0; j < filelist.length; j++) { bf.processFileArg(uploadfileArgs.get(i) + File.separatorChar + filelist[j], setName); } } else { bf.processFileArg(filename, setName); } } } private static final String[] photoSuffixes = { ""jpg"", ""jpeg"", ""png"", ""gif"", ""bmp"", ""tif"", ""tiff"" } ; private static final String[] videoSuffixes = { ""3gp"", ""3gp"", ""avi"", ""mov"", ""mp4"", ""mpg"", ""mpeg"", ""wmv"", ""ogg"", ""ogv"", ""m2v"" } ; static class UploadFilenameFilter implements FilenameFilter { @Override
        public boolean accept(File dir, String name) { if (isValidSuffix(name))
                return true; else
                return false; } } private static boolean isValidSuffix(String basefilename) { if (basefilename.lastIndexOf('.') <= 0) { return false; } String suffix = basefilename.substring(basefilename.lastIndexOf('.') + 1).toLowerCase(); for (int i = 0; i < photoSuffixes.length; i++) { if (photoSuffixes[i].equals(suffix))
                return true; } for (int i = 0; i < videoSuffixes.length; i++) { if (videoSuffixes[i].equals(suffix))
                return true; } return false; } private void processFileArg(String filename, String setName) throws Exception { String photoid; if (filename.equals("""")) { System.out.println(""filename must be entered for uploadfile ""); return; } if (filename.lastIndexOf(File.separatorChar) > 0)
            basefilename = filename.substring(filename.lastIndexOf(File.separatorChar) + 1, filename.length()); else
            basefilename = filename; boolean fileUploaded = checkIfLoaded(filename); if (!fileUploaded) { if (!isValidSuffix(basefilename)) { System.out.println("" File: "" + basefilename + "" is not a supported filetype for flickr (invalid suffix)""); return; } File f = new File(filename); if (!f.exists() || !f.canRead()) { System.out.println("" File: "" + filename + "" cannot be processed, does not exist or is unreadable.""); return; } photoid = uploadfile(filename, null); if (photoid != null) { addPhotoToSet(photoid, setName); } } else { } } private void addOption(String opt) { switch (opt) { case ""replaceSpaces"":
            replaceSpaces = true; break; case ""notags"":
            setSetorigfilenametag(false); break; System.out.println(""Option: "" + opt + "" is not supported at this time""); } } private boolean canUpload() { RequestContext rc = RequestContext.getRequestContext(); Auth auth = null; auth = rc.getAuth(); if (auth == null) { System.out.println("" Cannot upload, there is no authorization information.""); return false; } Permission perm = auth.getPermission(); if ((perm.getType() == Permission.WRITE_TYPE) || (perm.getType() == Permission.DELETE_TYPE))
            return true; else { System.out.println("" Cannot upload, You need write or delete permission, you have : "" + perm.toString()); return false; } } private boolean checkIfLoaded(String filename) { String title; if (basefilename.lastIndexOf('.') > 0)
            title = basefilename.substring(0, basefilename.lastIndexOf('.')); else
            return false; if (filePhotos.containsKey(title))
            return true; return false; } private String getUploadedTime(String filename) { String title = """"; if (basefilename.lastIndexOf('.') > 0)
            title = basefilename.substring(0, basefilename.lastIndexOf('.')); if (filePhotos.containsKey(title)) { Photo p = filePhotos.get(title); if (p.getDatePosted() != null) { return (smp.format(p.getDatePosted())); } } return """"; } private void getSetPhotos(String setName) throws FlickrException { ArrayList<String> setIdarr; setIdarr = setNameToId.get(setName); if (setIdarr != null) { setid = setIdarr.get(0); PhotosetsInterface pi = flickr.getPhotosetsInterface(); Set<String> extras = new HashSet<String>(); extras.add(""date_upload""); extras.add(""original_format""); extras.add(""media""); extras.add(""tags""); int setPage = 1; while (true) { PhotoList<Photo> tmpSet = pi.getPhotos(setid, extras, Flickr.PRIVACY_LEVEL_NO_FILTER, 500, setPage); int tmpSetSize = tmpSet.size(); photos.addAll(tmpSet); if (tmpSetSize < 500) { break; } setPage++; } for (int i = 0; i < photos.size(); i++) { filePhotos.put(photos.get(i).getTitle(), photos.get(i)); } if (flickrDebug) { } } } public void addPhotoToSet(String photoid, String setName) throws Exception { ArrayList<String> setIdarr; PhotosetsInterface psetsInterface = flickr.getPhotosetsInterface(); Photoset set = null; if (setid == null) { setIdarr = setNameToId.get(setName); if (setIdarr == null) { String description = """"; set = psetsInterface.create(setName, description, photoid); setid = set.getId(); setIdarr = new ArrayList<String>(); setIdarr.add(new String(setid)); setNameToId.put(setName, setIdarr); allSetsMap.put(set.getId(), set); } } else { set = allSetsMap.get(setid); psetsInterface.addPhoto(setid, photoid); } PhotosInterface photoInt = flickr.getPhotosInterface(); Photo p = photoInt.getPhoto(photoid); if (p != null) { photos.add(p); String title; if (basefilename.lastIndexOf('.') > 0)
                title = basefilename.substring(0, basefilename.lastIndexOf('.')); else
                title = p.getTitle(); filePhotos.put(title, p); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"public class UploadPhoto { private static final Logger logger = LoggerFactory.getLogger(UploadPhoto.class); private String nsid; private String username; private final Flickr flickr; private AuthStore authStore; public boolean flickrDebug = false; private boolean setOrigFilenameTag = true; private boolean replaceSpaces = false; private int privacy = -1; HashMap<String, Photoset> allSetsMap = new HashMap<String, Photoset>(); HashMap<String, ArrayList<String>> setNameToId = new HashMap<String, ArrayList<String>>(); public static final SimpleDateFormat smp = new SimpleDateFormat(""yyyy.MM.dd HH:mm:ss a""); public UploadPhoto(String apiKey, String nsid, String sharedSecret, File authsDir, String username) throws FlickrException { flickr = new Flickr(apiKey, sharedSecret, new REST()); this.username = username; this.nsid = nsid; if (authsDir != null) { this.authStore = new FileAuthStore(authsDir); } <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> if (username == null || username.equals(""""))
            setUserName(); if (nsid == null || nsid.equals(""""))
            setNsid(); } private void setUserName() throws FlickrException { if (nsid != null && !nsid.equals("""")) { Auth auth = null; if (authStore != null) { auth = authStore.retrieve(nsid); if (auth != null) { username = auth.getUser().getUsername(); } } if (auth == null) { PeopleInterface peopleInterf = flickr.getPeopleInterface(); User u = peopleInterf.getInfo(nsid); if (u != null) { username = u.getUsername(); } } } } private void setNsid() throws FlickrException { if (username != null && !username.equals("""")) { Auth auth = null; if (authStore != null) { auth = authStore.retrieve(username); if (auth != null) { nsid = auth.getUser().getId(); } } if (auth != null)
                return; Auth[] allAuths = authStore.retrieveAll(); for (int i = 0; i < allAuths.length; i++) { if (username.equals(allAuths[i].getUser().getUsername())) { nsid = allAuths[i].getUser().getId(); return; } } PeopleInterface peopleInterf = flickr.getPeopleInterface(); User u = peopleInterf.findByUsername(username); if (u != null) { nsid = u.getId(); } } } private void authorize() throws IOException, FlickrException { AuthInterface authInterface = flickr.getAuthInterface(); OAuth1RequestToken accessToken = authInterface.getRequestToken(); String url = authInterface.getAuthorizationUrl(accessToken, Permission.DELETE); System.out.println(""Follow this URL to authorise yourself on Flickr""); System.out.println(url); System.out.println(""Paste in the token it gives you:""); System.out.print("">>""); Scanner scanner = new Scanner(System.in); String tokenKey = scanner.nextLine(); OAuth1Token requestToken = authInterface.getAccessToken(accessToken, tokenKey); Auth auth = authInterface.checkToken(requestToken); RequestContext.getRequestContext().setAuth(auth); this.authStore.store(auth); scanner.close(); System.out.println(""Thanks.  You probably will not have to do this every time. Auth saved for user: "" + auth.getUser().getUsername() + "" nsid is: ""
                + auth.getUser().getId()); System.out.println("" AuthToken: "" + auth.getToken() + "" tokenSecret: "" + auth.getTokenSecret()); } private Auth constructAuth(String authToken, String tokenSecret, String username) throws IOException { Auth auth = new Auth(); auth.setToken(authToken); auth.setTokenSecret(tokenSecret); auth.setPermission(Permission.fromString(""delete"")); User user = new User(); user.setId(nsid); user.setUsername((username)); user.setRealName(""""); auth.setUser(user); this.authStore.store(auth); return auth; } public void setAuth(String authToken, String username, String tokenSecret) throws IOException, FlickrException { RequestContext rc = RequestContext.getRequestContext(); Auth auth = null; if (authToken != null && !authToken.equals("""") && tokenSecret != null && !tokenSecret.equals("""")) { auth = constructAuth(authToken, tokenSecret, username); rc.setAuth(auth); } else { <FILL_ME> if (this.authStore != null) { auth = this.authStore.retrieve(this.nsid); if (auth == null) { this.authorize(); } else { rc.setAuth(auth); } } } } public int getPrivacy() throws Exception { PrefsInterface prefi = flickr.getPrefsInterface(); privacy = prefi.getPrivacy(); return (privacy); } private String makeSafeFilename(String input) { byte[] fname = input.getBytes(); byte[] bad = new byte[] { '\\', '/', '""', '*' } ; byte replace = '_'; for (int i = 0; i < fname.length; i++) { for (byte element : bad) { if (fname[i] == element) { fname[i] = replace; } } if (replaceSpaces && fname[i] == ' ')
                fname[i] = '_'; } return new String(fname); } public String uploadfile(String filename, String inpTitle) throws Exception { String photoId; RequestContext rc = RequestContext.getRequestContext(); if (this.authStore != null) { Auth auth = this.authStore.retrieve(this.nsid); if (auth == null) { this.authorize(); } else { rc.setAuth(auth); } } if (privacy == -1)
            getPrivacy(); UploadMetaData metaData = new UploadMetaData(); if (privacy == 1)
            metaData.setPublicFlag(true); if (privacy == 2 || privacy == 4)
            metaData.setFriendFlag(true); if (privacy == 3 || privacy == 4)
            metaData.setFamilyFlag(true); if (basefilename == null || basefilename.equals(""""))
            basefilename = filename; String title = basefilename; boolean setMimeType = true; if (setMimeType) { if (basefilename.lastIndexOf('.') > 0) { title = basefilename.substring(0, basefilename.lastIndexOf('.')); String suffix = basefilename.substring(basefilename.lastIndexOf('.') + 1); if (suffix.equalsIgnoreCase(""png"")) { metaData.setFilemimetype(""image/png""); } else if (suffix.equalsIgnoreCase(""mpg"") || suffix.equalsIgnoreCase(""mpeg"")) { metaData.setFilemimetype(""video/mpeg""); } else if (suffix.equalsIgnoreCase(""mov"")) { metaData.setFilemimetype(""video/quicktime""); } } } if (inpTitle != null && !inpTitle.equals("""")) { title = inpTitle; <FILL_ME> metaData.setTitle(title); } if (setOrigFilenameTag) { List<String> tags = new ArrayList<String>(); String tmp = basefilename; basefilename = makeSafeFilename(basefilename); tags.add(""OrigFileName='"" + basefilename + ""'""); metaData.setTags(tags); if (!tmp.equals(basefilename)) { System.out.println("" File : "" + basefilename + "" contains special characters.  stored as "" + basefilename + "" in tag field""); } } Uploader uploader = flickr.getUploader(); try { metaData.setFilename(basefilename); File f = new File(filename); photoId = uploader.upload(f, metaData); <FILL_ME> } finally { } return (photoId); } public void getPhotosetsInfo() { PhotosetsInterface pi = flickr.getPhotosetsInterface(); try { int setsPage = 1; while (true) { Photosets photosets = pi.getList(nsid, 500, setsPage, null); Collection<Photoset> setsColl = photosets.getPhotosets(); Iterator<Photoset> setsIter = setsColl.iterator(); while (setsIter.hasNext()) { Photoset set = setsIter.next(); allSetsMap.put(set.getId(), set); ArrayList<String> setIdarr = setNameToId.get(set.getTitle()); if (setIdarr == null) { setIdarr = new ArrayList<String>(); setIdarr.add(new String(set.getId())); setNameToId.put(set.getTitle(), setIdarr); } else { setIdarr.add(new String(set.getId())); } } if (setsColl.size() < 500) { break; } setsPage++; } Set<String> keys = setNameToId.keySet(); Iterator<String> iter = keys.iterator(); while (iter.hasNext()) { String name = iter.next(); ArrayList<String> setIdarr = setNameToId.get(name); if (setIdarr != null && setIdarr.size() > 1) { System.out.println(""There is more than 1 set with this name : "" + setNameToId.get(name)); for (int j = 0; j < setIdarr.size(); j++) { System.out.println(""           id: "" + setIdarr.get(j)); } } } } catch (FlickrException e) { e.printStackTrace(); } } private String setid = null; private String basefilename = null; private final PhotoList<Photo> photos = new PhotoList<Photo>(); private final HashMap<String, Photo> filePhotos = new HashMap<String, Photo>(); private static void Usage() { System.out.println(""Usage: java "" + UploadPhoto.class.getName() + ""  [ -n nsid | -u username ] -s setName { File../Directories} ""); System.out.println(""	Must pass either -u username or -n nsid ""); System.out.println(""	Must pass  -s followed by set-name(albums)  followed by file/directories.""); System.out
                .println(""apiKey and shared secret must be available as apiKey and secret via setup.properties or passed as -apiKey key -secret shared-secret""); System.exit(1); } public boolean isSetorigfilenametag() { return setOrigFilenameTag; } public void setSetorigfilenametag(boolean setOrigFilenameTag) { this.setOrigFilenameTag = setOrigFilenameTag; } public static void main(String[] args) throws Exception { String apiKey = null; String sharedSecret = null; Properties properties = new Properties(); InputStream in = null; try { in = UploadPhoto.class.getResourceAsStream(""/setup.properties""); if (in != null) { properties.load(in); apiKey = properties.getProperty(""apiKey""); sharedSecret = properties.getProperty(""secret""); <FILL_ME> } } catch (Exception e) { e.printStackTrace(); } finally { if (in != null)
                in.close(); } if (args.length < 5) { Usage(); System.exit(1); } ArrayList<String> uploadfileArgs = new ArrayList<String>(); ArrayList<String> optionArgs = new ArrayList<String>(); String authsDirStr = System.getProperty(""user.home"") + File.separatorChar + "".flickrAuth""; String nsid = null; String username = null; String accessToken = null; String tokenSecret = null; String setName = null; boolean settagname = true; int i = 0; for (i = 0; i < args.length; i++) { switch (args[i]) { case ""-n"":
                if (i < args.length)
                    nsid = args[++i]; break; case ""-u"":
                if (i < args.length)
                    username = args[++i]; break; case ""-apiKey"":
                if (i < args.length)
                    apiKey = args[++i]; break; case ""-secret"":
                if (i < args.length)
                    sharedSecret = args[++i]; break; case ""-notags"":
                if (i < args.length)
                    settagname = false; break; case ""-a"":
                if (i < args.length)
                    accessToken = args[++i]; break; case ""-t"":
                if (i < args.length)
                    tokenSecret = args[++i]; break; case ""-s"":
                if (i < args.length)
                    setName = args[++i]; break; case ""-option"":
                if (i < args.length)
                    optionArgs.add(args[++i]); break; default:
                if (setName != null)
                    uploadfileArgs.add(args[i]); else { Usage(); System.exit(1); } } } if (apiKey == null || sharedSecret == null || (username == null && nsid == null) || (setName == null) || (uploadfileArgs.size() == 0)) { Usage(); System.exit(1); } UploadPhoto bf = new UploadPhoto(apiKey, nsid, sharedSecret, new File(authsDirStr), username); for (i = 0; i < optionArgs.size(); i++) { bf.addOption(optionArgs.get(i)); } bf.setSetorigfilenametag(settagname); bf.setAuth(accessToken, username, tokenSecret); if (!bf.canUpload())
            System.exit(1); bf.getPrivacy(); bf.getPhotosetsInfo(); if (setName != null && !setName.equals("""")) { bf.getSetPhotos(setName); } for (i = 0; i < uploadfileArgs.size(); i++) { String filename = uploadfileArgs.get(i); File f = new File(filename); if (f.isDirectory()) { String[] filelist = f.list(new UploadFilenameFilter()); <FILL_ME> for (int j = 0; j < filelist.length; j++) { bf.processFileArg(uploadfileArgs.get(i) + File.separatorChar + filelist[j], setName); } } else { bf.processFileArg(filename, setName); } } } private static final String[] photoSuffixes = { ""jpg"", ""jpeg"", ""png"", ""gif"", ""bmp"", ""tif"", ""tiff"" } ; private static final String[] videoSuffixes = { ""3gp"", ""3gp"", ""avi"", ""mov"", ""mp4"", ""mpg"", ""mpeg"", ""wmv"", ""ogg"", ""ogv"", ""m2v"" } ; static class UploadFilenameFilter implements FilenameFilter { @Override
        public boolean accept(File dir, String name) { if (isValidSuffix(name))
                return true; else
                return false; } } private static boolean isValidSuffix(String basefilename) { if (basefilename.lastIndexOf('.') <= 0) { return false; } String suffix = basefilename.substring(basefilename.lastIndexOf('.') + 1).toLowerCase(); for (int i = 0; i < photoSuffixes.length; i++) { if (photoSuffixes[i].equals(suffix))
                return true; } for (int i = 0; i < videoSuffixes.length; i++) { if (videoSuffixes[i].equals(suffix))
                return true; } return false; } private void processFileArg(String filename, String setName) throws Exception { String photoid; if (filename.equals("""")) { System.out.println(""filename must be entered for uploadfile ""); return; } if (filename.lastIndexOf(File.separatorChar) > 0)
            basefilename = filename.substring(filename.lastIndexOf(File.separatorChar) + 1, filename.length()); else
            basefilename = filename; boolean fileUploaded = checkIfLoaded(filename); if (!fileUploaded) { if (!isValidSuffix(basefilename)) { System.out.println("" File: "" + basefilename + "" is not a supported filetype for flickr (invalid suffix)""); return; } File f = new File(filename); if (!f.exists() || !f.canRead()) { System.out.println("" File: "" + filename + "" cannot be processed, does not exist or is unreadable.""); return; } photoid = uploadfile(filename, null); if (photoid != null) { addPhotoToSet(photoid, setName); } } else { } } private void addOption(String opt) { switch (opt) { case ""replaceSpaces"":
            replaceSpaces = true; break; case ""notags"":
            setSetorigfilenametag(false); break; System.out.println(""Option: "" + opt + "" is not supported at this time""); } } private boolean canUpload() { RequestContext rc = RequestContext.getRequestContext(); Auth auth = null; auth = rc.getAuth(); if (auth == null) { System.out.println("" Cannot upload, there is no authorization information.""); return false; } Permission perm = auth.getPermission(); if ((perm.getType() == Permission.WRITE_TYPE) || (perm.getType() == Permission.DELETE_TYPE))
            return true; else { System.out.println("" Cannot upload, You need write or delete permission, you have : "" + perm.toString()); return false; } } private boolean checkIfLoaded(String filename) { String title; if (basefilename.lastIndexOf('.') > 0)
            title = basefilename.substring(0, basefilename.lastIndexOf('.')); else
            return false; if (filePhotos.containsKey(title))
            return true; return false; } private String getUploadedTime(String filename) { String title = """"; if (basefilename.lastIndexOf('.') > 0)
            title = basefilename.substring(0, basefilename.lastIndexOf('.')); if (filePhotos.containsKey(title)) { Photo p = filePhotos.get(title); if (p.getDatePosted() != null) { return (smp.format(p.getDatePosted())); } } return """"; } private void getSetPhotos(String setName) throws FlickrException { ArrayList<String> setIdarr; setIdarr = setNameToId.get(setName); if (setIdarr != null) { setid = setIdarr.get(0); PhotosetsInterface pi = flickr.getPhotosetsInterface(); Set<String> extras = new HashSet<String>(); extras.add(""date_upload""); extras.add(""original_format""); extras.add(""media""); extras.add(""tags""); int setPage = 1; while (true) { PhotoList<Photo> tmpSet = pi.getPhotos(setid, extras, Flickr.PRIVACY_LEVEL_NO_FILTER, 500, setPage); int tmpSetSize = tmpSet.size(); photos.addAll(tmpSet); if (tmpSetSize < 500) { break; } setPage++; } for (int i = 0; i < photos.size(); i++) { filePhotos.put(photos.get(i).getTitle(), photos.get(i)); } if (flickrDebug) { <FILL_ME> } } } public void addPhotoToSet(String photoid, String setName) throws Exception { ArrayList<String> setIdarr; PhotosetsInterface psetsInterface = flickr.getPhotosetsInterface(); Photoset set = null; if (setid == null) { setIdarr = setNameToId.get(setName); if (setIdarr == null) { String description = """"; set = psetsInterface.create(setName, description, photoid); setid = set.getId(); setIdarr = new ArrayList<String>(); setIdarr.add(new String(setid)); setNameToId.put(setName, setIdarr); allSetsMap.put(set.getId(), set); } } else { set = allSetsMap.get(setid); psetsInterface.addPhoto(setid, photoid); } PhotosInterface photoInt = flickr.getPhotosInterface(); Photo p = photoInt.getPhoto(photoid); if (p != null) { photos.add(p); String title; if (basefilename.lastIndexOf('.') > 0)
                title = basefilename.substring(0, basefilename.lastIndexOf('.')); else
                title = p.getTitle(); filePhotos.put(title, p); } } } ","import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.REST; import com.flickr4java.flickr.RequestContext; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.auth.AuthInterface; import com.flickr4java.flickr.auth.Permission; import com.flickr4java.flickr.people.PeopleInterface; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotosInterface; import com.flickr4java.flickr.photosets.Photoset; import com.flickr4java.flickr.photosets.Photosets; import com.flickr4java.flickr.photosets.PhotosetsInterface; import com.flickr4java.flickr.prefs.PrefsInterface; import com.flickr4java.flickr.uploader.UploadMetaData; import com.flickr4java.flickr.uploader.Uploader; import com.flickr4java.flickr.util.AuthStore; import com.flickr4java.flickr.util.FileAuthStore; import com.github.scribejava.core.model.OAuth1RequestToken; import com.github.scribejava.core.model.OAuth1Token; import org.slf4j.Logger; import org.slf4j.LoggerFactory; 
import java.io.File; import java.io.FilenameFilter; import java.io.IOException; import java.io.InputStream; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Collection; import java.util.Date; import java.util.HashMap; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.Properties; import java.util.Scanner; import java.util.Set;  /**
 * A simple program to upload photos to a set. It checks for files already uploaded assuming the title is not changed so that it can be rerun if partial upload
 * is done. It uses the tag field to store the filename as OrigFileName to be used while downloading if the title has been changed. If setup.properties is not
 * available, pass the apiKey and secret as arguments to the program.
 * 
 * This sample also uses the AuthStore interface, so users will only be asked to authorize on the first run.
 * 
 * Please NOTE that this needs Java 7 to work. Java 7 was released on July 28, 2011 and soon Java 6 may not be supported anymore ( Jul 2014).
 * 
 * @author Keyur Parikh
 */  public class UploadPhoto {  private static final Logger logger = LoggerFactory.getLogger(UploadPhoto.class);  private String nsid;  private String username;  // private final String sharedSecret;  private final Flickr flickr;  private AuthStore authStore;  public boolean flickrDebug = false;  private boolean setOrigFilenameTag = true;  private boolean replaceSpaces = false;  private int privacy = -1;  HashMap<String, Photoset> allSetsMap = new HashMap<String, Photoset>();  HashMap<String, ArrayList<String>> setNameToId = new HashMap<String, ArrayList<String>>();  public static final SimpleDateFormat smp = new SimpleDateFormat(""yyyy.MM.dd HH:mm:ss a"");  public UploadPhoto(String apiKey, String nsid, String sharedSecret, File authsDir, String username) throws FlickrException { flickr = new Flickr(apiKey, sharedSecret, new REST());  this.username = username; this.nsid = nsid; // this.sharedSecret = sharedSecret;  if (authsDir != null) { this.authStore = new FileAuthStore(authsDir); } <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME>  // If one of them is not filled in, find and populate it. if (username == null || username.equals(""""))
            setUserName(); if (nsid == null || nsid.equals(""""))
            setNsid();  }  private void setUserName() throws FlickrException { if (nsid != null && !nsid.equals("""")) { Auth auth = null; if (authStore != null) { auth = authStore.retrieve(nsid); if (auth != null) { username = auth.getUser().getUsername(); } } // For this to work: REST.java or PeopleInterface needs to change to pass apiKey // as the parameter to the call which is not authenticated.  if (auth == null) { // Get nsid using flickr.people.findByUsername PeopleInterface peopleInterf = flickr.getPeopleInterface(); User u = peopleInterf.getInfo(nsid); if (u != null) { username = u.getUsername(); } } } }  /**
     * Check local saved copy first ??. If Auth by username is available, then we will not need to make the API call.
     * 
     * @throws FlickrException if there was a problem connecting to Flickr
     */  private void setNsid() throws FlickrException {  if (username != null && !username.equals("""")) { Auth auth = null; if (authStore != null) { auth = authStore.retrieve(username); // assuming FileAuthStore is enhanced else need to // keep in user-level files.  if (auth != null) { nsid = auth.getUser().getId(); } } if (auth != null)
                return;  Auth[] allAuths = authStore.retrieveAll(); for (int i = 0; i < allAuths.length; i++) { if (username.equals(allAuths[i].getUser().getUsername())) { nsid = allAuths[i].getUser().getId(); return; } }  // For this to work: REST.java or PeopleInterface needs to change to pass apiKey // as the parameter to the call which is not authenticated.  // Get nsid using flickr.people.findByUsername PeopleInterface peopleInterf = flickr.getPeopleInterface(); User u = peopleInterf.findByUsername(username); if (u != null) { nsid = u.getId(); } } }  private void authorize() throws IOException, FlickrException { AuthInterface authInterface = flickr.getAuthInterface(); OAuth1RequestToken accessToken = authInterface.getRequestToken();  // Try with DELETE permission. At least need write permission for upload and add-to-set. String url = authInterface.getAuthorizationUrl(accessToken, Permission.DELETE); System.out.println(""Follow this URL to authorise yourself on Flickr""); System.out.println(url); System.out.println(""Paste in the token it gives you:""); System.out.print("">>"");  Scanner scanner = new Scanner(System.in); String tokenKey = scanner.nextLine();  OAuth1Token requestToken = authInterface.getAccessToken(accessToken, tokenKey);  Auth auth = authInterface.checkToken(requestToken); RequestContext.getRequestContext().setAuth(auth); this.authStore.store(auth); scanner.close(); System.out.println(""Thanks.  You probably will not have to do this every time. Auth saved for user: "" + auth.getUser().getUsername() + "" nsid is: ""
                + auth.getUser().getId()); System.out.println("" AuthToken: "" + auth.getToken() + "" tokenSecret: "" + auth.getTokenSecret()); }  /**
     * If the Authtoken was already created in a separate program but not saved to file.
     * 
     * @param authToken
     * @param tokenSecret
     * @param username
     * @return
     * @throws IOException
     */ private Auth constructAuth(String authToken, String tokenSecret, String username) throws IOException {  Auth auth = new Auth(); auth.setToken(authToken); auth.setTokenSecret(tokenSecret);  // Prompt to ask what permission is needed: read, update or delete. auth.setPermission(Permission.fromString(""delete""));  User user = new User(); // Later change the following 3. Either ask user to pass on command line or read // from saved file. user.setId(nsid); user.setUsername((username)); user.setRealName(""""); auth.setUser(user); this.authStore.store(auth); return auth; }  public void setAuth(String authToken, String username, String tokenSecret) throws IOException, FlickrException { RequestContext rc = RequestContext.getRequestContext(); Auth auth = null;  if (authToken != null && !authToken.equals("""") && tokenSecret != null && !tokenSecret.equals("""")) { auth = constructAuth(authToken, tokenSecret, username); rc.setAuth(auth); } else { <FILL_ME> if (this.authStore != null) { auth = this.authStore.retrieve(this.nsid); if (auth == null) { this.authorize(); } else { rc.setAuth(auth); } } } }  public int getPrivacy() throws Exception {  PrefsInterface prefi = flickr.getPrefsInterface(); privacy = prefi.getPrivacy();  return (privacy); }  private String makeSafeFilename(String input) { byte[] fname = input.getBytes(); byte[] bad = new byte[] { '\\', '/', '""', '*' } ; byte replace = '_'; for (int i = 0; i < fname.length; i++) { for (byte element : bad) { if (fname[i] == element) { fname[i] = replace; } } if (replaceSpaces && fname[i] == ' ')
                fname[i] = '_'; } return new String(fname); }  public String uploadfile(String filename, String inpTitle) throws Exception { String photoId;  RequestContext rc = RequestContext.getRequestContext();  if (this.authStore != null) { Auth auth = this.authStore.retrieve(this.nsid); if (auth == null) { this.authorize(); } else { rc.setAuth(auth); } }  // PhotosetsInterface pi = flickr.getPhotosetsInterface(); // PhotosInterface photoInt = flickr.getPhotosInterface(); // Map<String, Collection> allPhotos = new HashMap<String, Collection>(); /**
         * 1 : Public 2 : Friends only 3 : Family only 4 : Friends and Family 5 : Private
         **/ if (privacy == -1)
            getPrivacy();  UploadMetaData metaData = new UploadMetaData();  if (privacy == 1)
            metaData.setPublicFlag(true); if (privacy == 2 || privacy == 4)
            metaData.setFriendFlag(true); if (privacy == 3 || privacy == 4)
            metaData.setFamilyFlag(true);  if (basefilename == null || basefilename.equals(""""))
            basefilename = filename; // ""image.jpg"";  String title = basefilename; boolean setMimeType = true; // change during testing. Doesn't seem to be supported at this time in flickr. if (setMimeType) { if (basefilename.lastIndexOf('.') > 0) { title = basefilename.substring(0, basefilename.lastIndexOf('.')); String suffix = basefilename.substring(basefilename.lastIndexOf('.') + 1); // Set Mime Type if known.  // Later use a mime-type properties file or a hash table of all known photo and video types // allowed by flickr.  if (suffix.equalsIgnoreCase(""png"")) { metaData.setFilemimetype(""image/png""); } else if (suffix.equalsIgnoreCase(""mpg"") || suffix.equalsIgnoreCase(""mpeg"")) { metaData.setFilemimetype(""video/mpeg""); } else if (suffix.equalsIgnoreCase(""mov"")) { metaData.setFilemimetype(""video/quicktime""); } } }  if (inpTitle != null && !inpTitle.equals("""")) { title = inpTitle; <FILL_ME> metaData.setTitle(title); } // flickr defaults the title field from file name.  // UploadMeta is using String not Tag class.  // Tags are getting mangled by yahoo stripping off the = , '.' and many other punctuation characters // and converting to lower case: use the raw tag field to find the real value for checking and // for download. if (setOrigFilenameTag) { List<String> tags = new ArrayList<String>(); String tmp = basefilename; basefilename = makeSafeFilename(basefilename); tags.add(""OrigFileName='"" + basefilename + ""'""); metaData.setTags(tags);  if (!tmp.equals(basefilename)) { System.out.println("" File : "" + basefilename + "" contains special characters.  stored as "" + basefilename + "" in tag field""); } }  // File imageFile = new File(filename); // InputStream in = null; Uploader uploader = flickr.getUploader();  // ByteArrayOutputStream out = null; try { // in = new FileInputStream(imageFile); // out = new ByteArrayOutputStream();  // int b = -1; /**
             * while ((b = in.read()) != -1) { out.write((byte) b); }
             **/  /**
             * byte[] buf = new byte[1024]; while ((b = in.read(buf)) != -1) { // fos.write(read); out.write(buf, 0, b); }
             **/  metaData.setFilename(basefilename); // check correct handling of escaped value  File f = new File(filename); photoId = uploader.upload(f, metaData); <FILL_ME>  } finally {  }  return (photoId); }  public void getPhotosetsInfo() {  PhotosetsInterface pi = flickr.getPhotosetsInterface(); try { int setsPage = 1; while (true) { Photosets photosets = pi.getList(nsid, 500, setsPage, null); Collection<Photoset> setsColl = photosets.getPhotosets(); Iterator<Photoset> setsIter = setsColl.iterator(); while (setsIter.hasNext()) { Photoset set = setsIter.next(); allSetsMap.put(set.getId(), set);  // 2 or more sets can in theory have the same name. !!! ArrayList<String> setIdarr = setNameToId.get(set.getTitle()); if (setIdarr == null) { setIdarr = new ArrayList<String>(); setIdarr.add(new String(set.getId())); setNameToId.put(set.getTitle(), setIdarr); } else { setIdarr.add(new String(set.getId())); } }  if (setsColl.size() < 500) { break; } setsPage++; } // all_sets_retrieved = true; // Print dups if any.  Set<String> keys = setNameToId.keySet(); Iterator<String> iter = keys.iterator(); while (iter.hasNext()) { String name = iter.next(); ArrayList<String> setIdarr = setNameToId.get(name); if (setIdarr != null && setIdarr.size() > 1) { System.out.println(""There is more than 1 set with this name : "" + setNameToId.get(name)); for (int j = 0; j < setIdarr.size(); j++) { System.out.println(""           id: "" + setIdarr.get(j)); } } }  } catch (FlickrException e) { e.printStackTrace(); } }  private String setid = null;  private String basefilename = null;  private final PhotoList<Photo> photos = new PhotoList<Photo>();  private final HashMap<String, Photo> filePhotos = new HashMap<String, Photo>();  private static void Usage() { System.out.println(""Usage: java "" + UploadPhoto.class.getName() + ""  [ -n nsid | -u username ] -s setName { File../Directories} ""); System.out.println(""	Must pass either -u username or -n nsid ""); System.out.println(""	Must pass  -s followed by set-name(albums)  followed by file/directories.""); System.out
                .println(""apiKey and shared secret must be available as apiKey and secret via setup.properties or passed as -apiKey key -secret shared-secret""); System.exit(1); }  /**
     * @return the setOrigFilenameTag
     */ public boolean isSetorigfilenametag() { return setOrigFilenameTag; }  /**
     * @param setOrigFilenameTag
     *            the setOrigFilenameTag to set
     */ public void setSetorigfilenametag(boolean setOrigFilenameTag) { this.setOrigFilenameTag = setOrigFilenameTag; }  public static void main(String[] args) throws Exception {  String apiKey = null; // args[0]; String sharedSecret = null; // args[1];  Properties properties = new Properties(); InputStream in = null; try { in = UploadPhoto.class.getResourceAsStream(""/setup.properties""); if (in != null) { properties.load(in); apiKey = properties.getProperty(""apiKey""); sharedSecret = properties.getProperty(""secret""); <FILL_ME> } } catch (Exception e) { e.printStackTrace(); } finally { if (in != null)
                in.close(); }  if (args.length < 5) { Usage(); System.exit(1); }  ArrayList<String> uploadfileArgs = new ArrayList<String>(); ArrayList<String> optionArgs = new ArrayList<String>();  // Flickr.debugRequest = true; // keep it false else entire file will be in stdout.  // Flickr.debugStream = true;  String authsDirStr = System.getProperty(""user.home"") + File.separatorChar + "".flickrAuth"";  String nsid = null; String username = null; String accessToken = null; // Optional entry. String tokenSecret = null; // Optional entry. String setName = null;  boolean settagname = true; // Default to true to add tag while uploading.  int i = 0; /***
         * for(i = 0; i < args.length; i++) { System.out.println(""args["" + i + ""] "" + args[i]); }
         **/  for (i = 0; i < args.length; i++) { switch (args[i]) { case ""-n"":
                if (i < args.length)
                    nsid = args[++i]; break; case ""-u"":
                if (i < args.length)
                    username = args[++i]; break; case ""-apiKey"":
                if (i < args.length)
                    apiKey = args[++i]; break;  case ""-secret"":
                if (i < args.length)
                    sharedSecret = args[++i]; break; case ""-notags"":
                if (i < args.length)
                    settagname = false; break;  case ""-a"":
                if (i < args.length)
                    accessToken = args[++i]; break; case ""-t"":
                if (i < args.length)
                    tokenSecret = args[++i]; break; case ""-s"":
                if (i < args.length)
                    setName = args[++i]; break; case ""-option"":
                if (i < args.length)
                    optionArgs.add(args[++i]); break; default:
                if (setName != null)
                    uploadfileArgs.add(args[i]); else { Usage(); System.exit(1); } } }  if (apiKey == null || sharedSecret == null || (username == null && nsid == null) || (setName == null) || (uploadfileArgs.size() == 0)) { Usage(); System.exit(1); }  UploadPhoto bf = new UploadPhoto(apiKey, nsid, sharedSecret, new File(authsDirStr), username); for (i = 0; i < optionArgs.size(); i++) { bf.addOption(optionArgs.get(i)); } bf.setSetorigfilenametag(settagname); bf.setAuth(accessToken, username, tokenSecret);  if (!bf.canUpload())
            System.exit(1);  bf.getPrivacy();  bf.getPhotosetsInfo();  if (setName != null && !setName.equals("""")) {  bf.getSetPhotos(setName); }  // String photoid;  for (i = 0; i < uploadfileArgs.size(); i++) { String filename = uploadfileArgs.get(i);  File f = new File(filename); if (f.isDirectory()) { String[] filelist = f.list(new UploadFilenameFilter()); <FILL_ME> for (int j = 0; j < filelist.length; j++) { bf.processFileArg(uploadfileArgs.get(i) + File.separatorChar + filelist[j], setName); } } else { bf.processFileArg(filename, setName); } } }  private static final String[] photoSuffixes = { ""jpg"", ""jpeg"", ""png"", ""gif"", ""bmp"", ""tif"", ""tiff"" } ;  private static final String[] videoSuffixes = { ""3gp"", ""3gp"", ""avi"", ""mov"", ""mp4"", ""mpg"", ""mpeg"", ""wmv"", ""ogg"", ""ogv"", ""m2v"" } ;  static class UploadFilenameFilter implements FilenameFilter {  // Following suffixes from flickr upload page. An App should have this configurable, // for videos and photos separately.  @Override
        public boolean accept(File dir, String name) { if (isValidSuffix(name))
                return true; else
                return false; }  }  private static boolean isValidSuffix(String basefilename) { if (basefilename.lastIndexOf('.') <= 0) { return false; } String suffix = basefilename.substring(basefilename.lastIndexOf('.') + 1).toLowerCase(); for (int i = 0; i < photoSuffixes.length; i++) { if (photoSuffixes[i].equals(suffix))
                return true; } for (int i = 0; i < videoSuffixes.length; i++) { if (videoSuffixes[i].equals(suffix))
                return true; } return false; }  private void processFileArg(String filename, String setName) throws Exception { String photoid; if (filename.equals("""")) { System.out.println(""filename must be entered for uploadfile ""); return; } if (filename.lastIndexOf(File.separatorChar) > 0)
            basefilename = filename.substring(filename.lastIndexOf(File.separatorChar) + 1, filename.length()); else
            basefilename = filename;  boolean fileUploaded = checkIfLoaded(filename);  if (!fileUploaded) { if (!isValidSuffix(basefilename)) { System.out.println("" File: "" + basefilename + "" is not a supported filetype for flickr (invalid suffix)""); return; }  File f = new File(filename); if (!f.exists() || !f.canRead()) { System.out.println("" File: "" + filename + "" cannot be processed, does not exist or is unreadable.""); return; }  photoid = uploadfile(filename, null); // Add to Set. Create set if it does not exist. if (photoid != null) { addPhotoToSet(photoid, setName); }  } else { } }  private void addOption(String opt) {  switch (opt) { case ""replaceSpaces"":
            replaceSpaces = true; break;  case ""notags"":
            setSetorigfilenametag(false); break;  // Not supported at this time. System.out.println(""Option: "" + opt + "" is not supported at this time""); } }  private boolean canUpload() { RequestContext rc = RequestContext.getRequestContext(); Auth auth = null; auth = rc.getAuth(); if (auth == null) { System.out.println("" Cannot upload, there is no authorization information.""); return false; } Permission perm = auth.getPermission(); if ((perm.getType() == Permission.WRITE_TYPE) || (perm.getType() == Permission.DELETE_TYPE))
            return true; else { System.out.println("" Cannot upload, You need write or delete permission, you have : "" + perm.toString()); return false; } }  /**
     * The assumption here is that for a given set only unique file-names will be loaded and the title field can be used. Later change to use the tags field (
     * OrigFileName) and strip off the suffix.
     * 
     * @param filename
     * @return
     */ private boolean checkIfLoaded(String filename) {  String title; if (basefilename.lastIndexOf('.') > 0)
            title = basefilename.substring(0, basefilename.lastIndexOf('.')); else
            return false;  if (filePhotos.containsKey(title))
            return true;  return false; }  private String getUploadedTime(String filename) {  String title = """"; if (basefilename.lastIndexOf('.') > 0)
            title = basefilename.substring(0, basefilename.lastIndexOf('.'));  if (filePhotos.containsKey(title)) { Photo p = filePhotos.get(title); if (p.getDatePosted() != null) { return (smp.format(p.getDatePosted())); } }  return """"; }  private void getSetPhotos(String setName) throws FlickrException { // Check if this is an existing set. If it is get all the photo list to avoid reloading already // loaded photos. ArrayList<String> setIdarr; setIdarr = setNameToId.get(setName); if (setIdarr != null) { setid = setIdarr.get(0); PhotosetsInterface pi = flickr.getPhotosetsInterface();  Set<String> extras = new HashSet<String>(); /**
             * A comma-delimited list of extra information to fetch for each returned record. Currently supported fields are: license, date_upload, date_taken,
             * owner_name, icon_server, original_format, last_update, geo, tags, machine_tags, o_dims, views, media, path_alias, url_sq, url_t, url_s, url_m,
             * url_o
             */  extras.add(""date_upload""); extras.add(""original_format""); extras.add(""media""); // extras.add(""url_o""); extras.add(""tags"");  int setPage = 1; while (true) { PhotoList<Photo> tmpSet = pi.getPhotos(setid, extras, Flickr.PRIVACY_LEVEL_NO_FILTER, 500, setPage);  int tmpSetSize = tmpSet.size(); photos.addAll(tmpSet); if (tmpSetSize < 500) { break; } setPage++; } for (int i = 0; i < photos.size(); i++) { filePhotos.put(photos.get(i).getTitle(), photos.get(i)); } if (flickrDebug) { <FILL_ME> } } }  public void addPhotoToSet(String photoid, String setName) throws Exception {  ArrayList<String> setIdarr;  // all_set_maps.  PhotosetsInterface psetsInterface = flickr.getPhotosetsInterface();  Photoset set = null;  if (setid == null) { // In case it is a new photo-set. setIdarr = setNameToId.get(setName); if (setIdarr == null) { // setIdarr should be null since we checked it getSetPhotos. // Create the new set. // set the setid .  String description = """"; set = psetsInterface.create(setName, description, photoid); setid = set.getId();  setIdarr = new ArrayList<String>(); setIdarr.add(new String(setid)); setNameToId.put(setName, setIdarr);  allSetsMap.put(set.getId(), set); } } else { set = allSetsMap.get(setid); psetsInterface.addPhoto(setid, photoid); } // Add to photos .  // Add Photo to existing set. PhotosInterface photoInt = flickr.getPhotosInterface(); Photo p = photoInt.getPhoto(photoid); if (p != null) { photos.add(p); String title; if (basefilename.lastIndexOf('.') > 0)
                title = basefilename.substring(0, basefilename.lastIndexOf('.')); else
                title = p.getTitle(); filePhotos.put(title, p); } } }  "
src/main/java/com/flickr4java/flickr/Flickr.java,"
package com.flickr4java.flickr;

import com.flickr4java.flickr.activity.ActivityInterface;
import com.flickr4java.flickr.auth.Auth;
import com.flickr4java.flickr.auth.AuthInterface;
import com.flickr4java.flickr.blogs.BlogsInterface;
import com.flickr4java.flickr.cameras.CamerasInterface;
import com.flickr4java.flickr.collections.CollectionsInterface;
import com.flickr4java.flickr.commons.CommonsInterface;
import com.flickr4java.flickr.contacts.ContactsInterface;
import com.flickr4java.flickr.favorites.FavoritesInterface;
import com.flickr4java.flickr.galleries.GalleriesInterface;
import com.flickr4java.flickr.groups.GroupsInterface;
import com.flickr4java.flickr.groups.discuss.GroupDiscussInterface;
import com.flickr4java.flickr.groups.members.MembersInterface;
import com.flickr4java.flickr.groups.pools.PoolsInterface;
import com.flickr4java.flickr.interestingness.InterestingnessInterface;
import com.flickr4java.flickr.machinetags.MachinetagsInterface;
import com.flickr4java.flickr.panda.PandaInterface;
import com.flickr4java.flickr.people.PeopleInterface;
import com.flickr4java.flickr.photos.PhotosInterface;
import com.flickr4java.flickr.photos.comments.CommentsInterface;
import com.flickr4java.flickr.photos.geo.GeoInterface;
import com.flickr4java.flickr.photos.licenses.LicensesInterface;
import com.flickr4java.flickr.photos.notes.NotesInterface;
import com.flickr4java.flickr.photos.suggestions.SuggestionsInterface;
import com.flickr4java.flickr.photos.transform.TransformInterface;
import com.flickr4java.flickr.photos.upload.UploadInterface;
import com.flickr4java.flickr.photosets.PhotosetsInterface;
import com.flickr4java.flickr.photosets.comments.PhotosetsCommentsInterface;
import com.flickr4java.flickr.places.PlacesInterface;
import com.flickr4java.flickr.prefs.PrefsInterface;
import com.flickr4java.flickr.reflection.ReflectionInterface;
import com.flickr4java.flickr.stats.StatsInterface;
import com.flickr4java.flickr.tags.TagsInterface;
import com.flickr4java.flickr.test.TestInterface;
import com.flickr4java.flickr.uploader.Uploader;
import com.flickr4java.flickr.urls.UrlsInterface;

import java.util.Set;

/**
 * Main entry point for the Flickr4Java API. This class is used to acquire Interface classes which wrap the Flickr API.
 * <p>
 * 
 * If you registered API keys, you find them with the shared secret at your <a href=""http://www.flickr.com/services/api/registered_keys.gne"">list of API
 * keys</a>
 * <p>
 * 
 * The user who authenticates himself, can manage this permissions at <a href=""http://www.flickr.com/services/auth/list.gne"">his list of Third-party
 * applications</a> (You / Your account / Extending Flickr / Account Links / edit).
 * 
 * @author Anthony Eden
 * @version $Id: Flickr.java,v 1.45 2009/06/23 21:51:25 x-mago Exp $
 */
public class Flickr implements IFlickr {

    /**
     * The default endpoint host.
     */
    public static final String DEFAULT_HOST = ""api.flickr.com"";

    /**
     * The key used when the API key is stored for passing to the Transport methods.
     */
    public static final String API_KEY = ""api_key"";

    /**
     * Set to true to enable response debugging (print the response stream)
     */
    public static boolean debugStream = false;

    /**
     * Set to true to enable request debugging (print the request stream, used for ""post"")
     */
    public static boolean debugRequest = false;

    private String apiKey;

    private String sharedSecret;

    private Transport transport;

    private Auth auth;

    private AuthInterface authInterface;

    private ActivityInterface activityInterface;

    private BlogsInterface blogsInterface;

    private CommentsInterface commentsInterface;

    private CommonsInterface commonsInterface;

    private ContactsInterface contactsInterface;

    private FavoritesInterface favoritesInterface;

    private GeoInterface geoInterface;

    private GroupsInterface groupsInterface;

    private InterestingnessInterface interestingnessInterface;

    private LicensesInterface licensesInterface;

    private MembersInterface membersInterface;

    private MachinetagsInterface machinetagsInterface;

    private NotesInterface notesInterface;

    private PandaInterface pandaInterface;

    private PoolsInterface poolsInterface;

    private PeopleInterface peopleInterface;

    private PhotosInterface photosInterface;

    private PhotosetsCommentsInterface photosetsCommentsInterface;

    private PhotosetsInterface photosetsInterface;

    private CollectionsInterface collectionsInterface;

    private PlacesInterface placesInterface;

    private PrefsInterface prefsInterface;

    private ReflectionInterface reflectionInterface;

    private TagsInterface tagsInterface;

    private TestInterface testInterface;

    private TransformInterface transformInterface;

    private UploadInterface uploadInterface;

    private Uploader uploader;

    private UrlsInterface urlsInterface;

    private GalleriesInterface galleriesInterface;

    private StatsInterface statsInterface;

    private CamerasInterface cameraInterface;

    private SuggestionsInterface suggestionsInterface;

    private GroupDiscussInterface discussionInterface;

    /**
     * @see com.flickr4java.flickr.photos.PhotosInterface#setContentType(String, String)
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getContentType()
     * @see com.flickr4java.flickr.uploader.UploadMetaData#setContentType(String)
     */
    public static final String CONTENTTYPE_PHOTO = ""1"";

    /**
     * @see com.flickr4java.flickr.photos.PhotosInterface#setContentType(String, String)
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getContentType()
     * @see com.flickr4java.flickr.uploader.UploadMetaData#setContentType(String)
     */
    public static final String CONTENTTYPE_SCREENSHOT = ""2"";

    /**
     * @see com.flickr4java.flickr.photos.PhotosInterface#setContentType(String, String)
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getContentType()
     * @see com.flickr4java.flickr.uploader.UploadMetaData#setContentType(String)
     */
    public static final String CONTENTTYPE_OTHER = ""3"";

    /**
     * The lowest accuracy for bounding-box searches.
     * 
     * @see com.flickr4java.flickr.photos.SearchParameters#setAccuracy(int)
     */
    public static final int ACCURACY_WORLD = 1;

    /**
     * @see com.flickr4java.flickr.photos.SearchParameters#setAccuracy(int)
     */
    public static final int ACCURACY_COUNTRY = 3;

    /**
     * @see com.flickr4java.flickr.photos.SearchParameters#setAccuracy(int)
     */
    public static final int ACCURACY_REGION = 6;

    /**
     * @see com.flickr4java.flickr.photos.SearchParameters#setAccuracy(int)
     */
    public static final int ACCURACY_CITY = 11;

    /**
     * The highest accuracy for bounding-box searches.
     * 
     * @see com.flickr4java.flickr.photos.SearchParameters#setAccuracy(int)
     */
    public static final int ACCURACY_STREET = 16;

    /**
     * @see com.flickr4java.flickr.photos.PhotosInterface#setSafetyLevel(String, String, Boolean)
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getSafetyLevel()
     * @see com.flickr4java.flickr.uploader.UploadMetaData#setSafetyLevel(String)
     * @see com.flickr4java.flickr.photos.SearchParameters#setSafeSearch(String)
     */
    public static final String SAFETYLEVEL_SAFE = ""1"";

    /**
     * @see com.flickr4java.flickr.photos.PhotosInterface#setSafetyLevel(String, String, Boolean)
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getSafetyLevel()
     * @see com.flickr4java.flickr.uploader.UploadMetaData#setSafetyLevel(String)
     * @see com.flickr4java.flickr.photos.SearchParameters#setSafeSearch(String)
     */
    public static final String SAFETYLEVEL_MODERATE = ""2"";

    /**
     * @see com.flickr4java.flickr.photos.PhotosInterface#setSafetyLevel(String, String, Boolean)
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getSafetyLevel()
     * @see com.flickr4java.flickr.uploader.UploadMetaData#setSafetyLevel(String)
     * @see com.flickr4java.flickr.photos.SearchParameters#setSafeSearch(String)
     */
    public static final String SAFETYLEVEL_RESTRICTED = ""3"";

    /**
     * @see com.flickr4java.flickr.photosets.PhotosetsInterface#getPhotos(String, Set, int, int, int)
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getPrivacy()
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getGeoPerms()
     */
    public static final int PRIVACY_LEVEL_NO_FILTER = 0;

    /**
     * @see com.flickr4java.flickr.photosets.PhotosetsInterface#getPhotos(String, Set, int, int, int)
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getPrivacy()
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getGeoPerms()
     */
    public static final int PRIVACY_LEVEL_PUBLIC = 1;

    /**
     * @see com.flickr4java.flickr.photosets.PhotosetsInterface#getPhotos(String, Set, int, int, int)
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getPrivacy()
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getGeoPerms()
     */
    public static final int PRIVACY_LEVEL_FRIENDS = 2;

    /**
     * @see com.flickr4java.flickr.photosets.PhotosetsInterface#getPhotos(String, Set, int, int, int)
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getPrivacy()
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getGeoPerms()
     */
    public static final int PRIVACY_LEVEL_FAMILY = 3;

    /**
     * @see com.flickr4java.flickr.photosets.PhotosetsInterface#getPhotos(String, Set, int, int, int)
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getPrivacy()
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getGeoPerms()
     */
    public static final int PRIVACY_LEVEL_FRIENDS_FAMILY = 4;

    /**
     * @see com.flickr4java.flickr.photosets.PhotosetsInterface#getPhotos(String, Set, int, int, int)
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getPrivacy()
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getGeoPerms()
     */
    public static final int PRIVACY_LEVEL_PRIVATE = 5;

    /**
     * Construct a new Flickr gateway instance.
     * 
     * @param apiKey
     *            The API key, must be non-null
     * @param sharedSecret
     * @param transport
     */
    public Flickr(String apiKey, String sharedSecret, Transport transport) {
        setApiKey(apiKey);
        setSharedSecret(sharedSecret);
        setTransport(transport);
    }

    /**
     * Get the API key.
     * 
     * @return The API key
     */
    @Override
    public String getApiKey() {
        return apiKey;
    }

    /**
     * Set the API key to use which must not be null.
     * 
     * @param apiKey
     *            The API key which cannot be null
     */
    @Override
    public void setApiKey(String apiKey) {
        if (apiKey == null) {
            throw new IllegalArgumentException(""API key must not be null"");
        }
        this.apiKey = apiKey;
    }

    @Override
    public void setAuth(Auth auth) {
        this.auth = auth;
    }

    /**
     * Get the Auth-object.
     * 
     * @return The Auth-object
     */
    @Override
    public Auth getAuth() {
        return auth;
    }

    /**
     * Get the Shared-Secret.
     * 
     * @return The Shared-Secret
     */
    @Override
    public String getSharedSecret() {
        return sharedSecret;
    }

    /**
     * Set the Shared-Secret to use which must not be null.
     * 
     * @param sharedSecret
     *            The Shared-Secret which cannot be null
     */
    @Override
    public void setSharedSecret(String sharedSecret) {
        if (sharedSecret == null) {
            throw new IllegalArgumentException(""Shared-Secret must not be null"");
        }
        this.sharedSecret = sharedSecret;
    }

    /**
     * Get the Transport interface.
     * 
     * @return The Tranport interface
     */
    @Override
    public Transport getTransport() {
        return transport;
    }

    /**
     * Set the Transport which must not be null.
     * 
     * @param transport
     */
    @Override
    public void setTransport(Transport transport) {
        if (transport == null) {
            throw new IllegalArgumentException(""Transport must not be null"");
        }
        this.transport = transport;
    }

    /**
     * Get the AuthInterface.
     * 
     * @return The AuthInterface
     */
    @Override
    public AuthInterface getAuthInterface() {
        if (authInterface == null) {
            authInterface = new AuthInterface(apiKey, sharedSecret, transport);
        }
        return authInterface;
    }

    /**
     * Get the ActivityInterface.
     * 
     * @return The ActivityInterface
     */
    @Override
    public ActivityInterface getActivityInterface() {
        if (activityInterface == null) {
            activityInterface = new ActivityInterface(apiKey, sharedSecret, transport);
        }
        return activityInterface;
    }

    @Override
    public synchronized BlogsInterface getBlogsInterface() {
        if (blogsInterface == null) {
            blogsInterface = new BlogsInterface(apiKey, sharedSecret, transport);
        }
        return blogsInterface;
    }

    @Override
    public CommentsInterface getCommentsInterface() {
        if (commentsInterface == null) {
            commentsInterface = new CommentsInterface(apiKey, sharedSecret, transport);
        }
        return commentsInterface;
    }

    @Override
    public CommonsInterface getCommonsInterface() {
        if (commonsInterface == null) {
            commonsInterface = new CommonsInterface(apiKey, sharedSecret, transport);
        }
        return commonsInterface;
    }

    @Override
    public ContactsInterface getContactsInterface() {
        if (contactsInterface == null) {
            contactsInterface = new ContactsInterface(apiKey, sharedSecret, transport);
        }
        return contactsInterface;
    }

    @Override
    public FavoritesInterface getFavoritesInterface() {
        if (favoritesInterface == null) {
            favoritesInterface = new FavoritesInterface(apiKey, sharedSecret, transport);
        }
        return favoritesInterface;
    }

    @Override
    public GeoInterface getGeoInterface() {
        if (geoInterface == null) {
            geoInterface = new GeoInterface(apiKey, sharedSecret, transport);
        }
        return geoInterface;
    }

    @Override
    public GroupsInterface getGroupsInterface() {
        if (groupsInterface == null) {
            groupsInterface = new GroupsInterface(apiKey, sharedSecret, transport);
        }
        return groupsInterface;
    }

    /**
     * @return the interface to the flickr.interestingness methods
     */
    @Override
    public synchronized InterestingnessInterface getInterestingnessInterface() {
        if (interestingnessInterface == null) {
            interestingnessInterface = new InterestingnessInterface(apiKey, sharedSecret, transport);
        }
        return interestingnessInterface;
    }

    @Override
    public LicensesInterface getLicensesInterface() {
        if (licensesInterface == null) {
            licensesInterface = new LicensesInterface(apiKey, sharedSecret, transport);
        }
        return licensesInterface;
    }

    @Override
    public MachinetagsInterface getMachinetagsInterface() {
        if (machinetagsInterface == null) {
            machinetagsInterface = new MachinetagsInterface(apiKey, sharedSecret, transport);
        }
        return machinetagsInterface;
    }

    @Override
    public MembersInterface getMembersInterface() {
        if (membersInterface == null) {
            membersInterface = new MembersInterface(apiKey, sharedSecret, transport);
        }
        return membersInterface;
    }

    @Override
    public NotesInterface getNotesInterface() {
        if (notesInterface == null) {
            notesInterface = new NotesInterface(apiKey, sharedSecret, transport);
        }
        return notesInterface;
    }

    @Override
    public PandaInterface getPandaInterface() {
        if (pandaInterface == null) {
            pandaInterface = new PandaInterface(apiKey, sharedSecret, transport);
        }
        return pandaInterface;
    }

    @Override
    public PoolsInterface getPoolsInterface() {
        if (poolsInterface == null) {
            poolsInterface = new PoolsInterface(apiKey, sharedSecret, transport);
        }
        return poolsInterface;
    }

    @Override
    public PeopleInterface getPeopleInterface() {
        if (peopleInterface == null) {
            peopleInterface = new PeopleInterface(apiKey, sharedSecret, transport);
        }
        return peopleInterface;
    }

    @Override
    public PhotosInterface getPhotosInterface() {
        if (photosInterface == null) {
            photosInterface = new PhotosInterface(apiKey, sharedSecret, transport);
        }
        return photosInterface;
    }

    @Override
    public PhotosetsCommentsInterface getPhotosetsCommentsInterface() {
        if (photosetsCommentsInterface == null) {
            photosetsCommentsInterface = new PhotosetsCommentsInterface(apiKey, sharedSecret, transport);
        }
        return photosetsCommentsInterface;
    }

    @Override
    public PhotosetsInterface getPhotosetsInterface() {
        if (photosetsInterface == null) {
            photosetsInterface = new PhotosetsInterface(apiKey, sharedSecret, transport);
        }
        return photosetsInterface;
    }

    @Override
    public CollectionsInterface getCollectionsInterface() {
        if (collectionsInterface == null) {
            collectionsInterface = new CollectionsInterface(apiKey, sharedSecret, transport);
        }
        return collectionsInterface;
    }

    @Override
    public PlacesInterface getPlacesInterface() {
        if (placesInterface == null) {
            placesInterface = new PlacesInterface(apiKey, sharedSecret, transport);
        }
        return placesInterface;
    }

    @Override
    public PrefsInterface getPrefsInterface() {
        if (prefsInterface == null) {
            prefsInterface = new PrefsInterface(apiKey, sharedSecret, transport);
        }
        return prefsInterface;
    }

    @Override
    public ReflectionInterface getReflectionInterface() {
        if (reflectionInterface == null) {
            reflectionInterface = new ReflectionInterface(apiKey, sharedSecret, transport);
        }
        return reflectionInterface;
    }

    /**
     * Get the TagsInterface for working with Flickr Tags.
     * 
     * @return The TagsInterface
     */
    @Override
    public TagsInterface getTagsInterface() {
        if (tagsInterface == null) {
            tagsInterface = new TagsInterface(apiKey, sharedSecret, transport);
        }
        return tagsInterface;
    }

    @Override
    public TestInterface getTestInterface() {
        if (testInterface == null) {
            testInterface = new TestInterface(apiKey, sharedSecret, transport);
        }
        return testInterface;
    }

    @Override
    public TransformInterface getTransformInterface() {
        if (transformInterface == null) {
            transformInterface = new TransformInterface(apiKey, sharedSecret, transport);
        }
        return transformInterface;
    }

    @Override
    public UploadInterface getUploadInterface() {
        if (uploadInterface == null) {
            uploadInterface = new UploadInterface(apiKey, sharedSecret, transport);
        }
        return uploadInterface;
    }

    @Override
    public Uploader getUploader() {
        if (uploader == null) {
            uploader = new Uploader(apiKey, sharedSecret);
        }
        return uploader;
    }

    @Override
    public UrlsInterface getUrlsInterface() {
        if (urlsInterface == null) {
            urlsInterface = new UrlsInterface(apiKey, sharedSecret, transport);
        }
        return urlsInterface;
    }

    @Override
    public GalleriesInterface getGalleriesInterface() {
        if (galleriesInterface == null) {
            galleriesInterface = new GalleriesInterface(apiKey, sharedSecret, transport);
        }
        return galleriesInterface;
    }

    @Override
    public StatsInterface getStatsInterface() {
        if (statsInterface == null) {
            statsInterface = new StatsInterface(apiKey, sharedSecret, transport);
        }
        return statsInterface;
    }

    @Override
    public CamerasInterface getCamerasInterface() {
        if (cameraInterface == null) {
            cameraInterface = new CamerasInterface(apiKey, sharedSecret, transport);
        }
        return cameraInterface;
    }

    /**
     * Get the SuggestionsInterface.
     * 
     * @return The SuggestionsInterface
     */
    @Override
    public SuggestionsInterface getSuggestionsInterface() {
        if (suggestionsInterface == null) {
            suggestionsInterface = new SuggestionsInterface(apiKey, sharedSecret, transport);
        }
        return suggestionsInterface;
    }

    /**
     * Get the GroupDiscussInterface.
     * 
     * @return The GroupDiscussInterface
     */

    @Override
    public GroupDiscussInterface getDiscussionInterface() {
        if (discussionInterface == null) {
            discussionInterface = new GroupDiscussInterface(apiKey, sharedSecret, transport);
        }
        return discussionInterface;
    }

}
","package com.flickr4java.flickr; public class Flickr implements IFlickr { public static final String DEFAULT_HOST = ""api.flickr.com""; public static final String API_KEY = ""api_key""; public static boolean debugStream = false; public static boolean debugRequest = false; private String apiKey; private String sharedSecret; private Transport transport; private Auth auth; private AuthInterface authInterface; private ActivityInterface activityInterface; private BlogsInterface blogsInterface; private CommentsInterface commentsInterface; private CommonsInterface commonsInterface; private ContactsInterface contactsInterface; private FavoritesInterface favoritesInterface; private GeoInterface geoInterface; private GroupsInterface groupsInterface; private InterestingnessInterface interestingnessInterface; private LicensesInterface licensesInterface; private MembersInterface membersInterface; private MachinetagsInterface machinetagsInterface; private NotesInterface notesInterface; private PandaInterface pandaInterface; private PoolsInterface poolsInterface; private PeopleInterface peopleInterface; private PhotosInterface photosInterface; private PhotosetsCommentsInterface photosetsCommentsInterface; private PhotosetsInterface photosetsInterface; private CollectionsInterface collectionsInterface; private PlacesInterface placesInterface; private PrefsInterface prefsInterface; private ReflectionInterface reflectionInterface; private TagsInterface tagsInterface; private TestInterface testInterface; private TransformInterface transformInterface; private UploadInterface uploadInterface; private Uploader uploader; private UrlsInterface urlsInterface; private GalleriesInterface galleriesInterface; private StatsInterface statsInterface; private CamerasInterface cameraInterface; private SuggestionsInterface suggestionsInterface; private GroupDiscussInterface discussionInterface; public static final String CONTENTTYPE_PHOTO = ""1""; public static final String CONTENTTYPE_SCREENSHOT = ""2""; public static final String CONTENTTYPE_OTHER = ""3""; public static final int ACCURACY_WORLD = 1; public static final int ACCURACY_COUNTRY = 3; public static final int ACCURACY_REGION = 6; public static final int ACCURACY_CITY = 11; public static final int ACCURACY_STREET = 16; public static final String SAFETYLEVEL_SAFE = ""1""; public static final String SAFETYLEVEL_MODERATE = ""2""; public static final String SAFETYLEVEL_RESTRICTED = ""3""; public static final int PRIVACY_LEVEL_NO_FILTER = 0; public static final int PRIVACY_LEVEL_PUBLIC = 1; public static final int PRIVACY_LEVEL_FRIENDS = 2; public static final int PRIVACY_LEVEL_FAMILY = 3; public static final int PRIVACY_LEVEL_FRIENDS_FAMILY = 4; public static final int PRIVACY_LEVEL_PRIVATE = 5; public Flickr(String apiKey, String sharedSecret, Transport transport) { setApiKey(apiKey); setSharedSecret(sharedSecret); setTransport(transport); } @Override
    public String getApiKey() { return apiKey; } @Override
    public void setApiKey(String apiKey) { if (apiKey == null) { throw new IllegalArgumentException(""API key must not be null""); } this.apiKey = apiKey; } @Override
    public void setAuth(Auth auth) { this.auth = auth; } @Override
    public Auth getAuth() { return auth; } @Override
    public String getSharedSecret() { return sharedSecret; } @Override
    public void setSharedSecret(String sharedSecret) { if (sharedSecret == null) { throw new IllegalArgumentException(""Shared-Secret must not be null""); } this.sharedSecret = sharedSecret; } @Override
    public Transport getTransport() { return transport; } @Override
    public void setTransport(Transport transport) { if (transport == null) { throw new IllegalArgumentException(""Transport must not be null""); } this.transport = transport; } @Override
    public AuthInterface getAuthInterface() { if (authInterface == null) { authInterface = new AuthInterface(apiKey, sharedSecret, transport); } return authInterface; } @Override
    public ActivityInterface getActivityInterface() { if (activityInterface == null) { activityInterface = new ActivityInterface(apiKey, sharedSecret, transport); } return activityInterface; } @Override
    public synchronized BlogsInterface getBlogsInterface() { if (blogsInterface == null) { blogsInterface = new BlogsInterface(apiKey, sharedSecret, transport); } return blogsInterface; } @Override
    public CommentsInterface getCommentsInterface() { if (commentsInterface == null) { commentsInterface = new CommentsInterface(apiKey, sharedSecret, transport); } return commentsInterface; } @Override
    public CommonsInterface getCommonsInterface() { if (commonsInterface == null) { commonsInterface = new CommonsInterface(apiKey, sharedSecret, transport); } return commonsInterface; } @Override
    public ContactsInterface getContactsInterface() { if (contactsInterface == null) { contactsInterface = new ContactsInterface(apiKey, sharedSecret, transport); } return contactsInterface; } @Override
    public FavoritesInterface getFavoritesInterface() { if (favoritesInterface == null) { favoritesInterface = new FavoritesInterface(apiKey, sharedSecret, transport); } return favoritesInterface; } @Override
    public GeoInterface getGeoInterface() { if (geoInterface == null) { geoInterface = new GeoInterface(apiKey, sharedSecret, transport); } return geoInterface; } @Override
    public GroupsInterface getGroupsInterface() { if (groupsInterface == null) { groupsInterface = new GroupsInterface(apiKey, sharedSecret, transport); } return groupsInterface; } @Override
    public synchronized InterestingnessInterface getInterestingnessInterface() { if (interestingnessInterface == null) { interestingnessInterface = new InterestingnessInterface(apiKey, sharedSecret, transport); } return interestingnessInterface; } @Override
    public LicensesInterface getLicensesInterface() { if (licensesInterface == null) { licensesInterface = new LicensesInterface(apiKey, sharedSecret, transport); } return licensesInterface; } @Override
    public MachinetagsInterface getMachinetagsInterface() { if (machinetagsInterface == null) { machinetagsInterface = new MachinetagsInterface(apiKey, sharedSecret, transport); } return machinetagsInterface; } @Override
    public MembersInterface getMembersInterface() { if (membersInterface == null) { membersInterface = new MembersInterface(apiKey, sharedSecret, transport); } return membersInterface; } @Override
    public NotesInterface getNotesInterface() { if (notesInterface == null) { notesInterface = new NotesInterface(apiKey, sharedSecret, transport); } return notesInterface; } @Override
    public PandaInterface getPandaInterface() { if (pandaInterface == null) { pandaInterface = new PandaInterface(apiKey, sharedSecret, transport); } return pandaInterface; } @Override
    public PoolsInterface getPoolsInterface() { if (poolsInterface == null) { poolsInterface = new PoolsInterface(apiKey, sharedSecret, transport); } return poolsInterface; } @Override
    public PeopleInterface getPeopleInterface() { if (peopleInterface == null) { peopleInterface = new PeopleInterface(apiKey, sharedSecret, transport); } return peopleInterface; } @Override
    public PhotosInterface getPhotosInterface() { if (photosInterface == null) { photosInterface = new PhotosInterface(apiKey, sharedSecret, transport); } return photosInterface; } @Override
    public PhotosetsCommentsInterface getPhotosetsCommentsInterface() { if (photosetsCommentsInterface == null) { photosetsCommentsInterface = new PhotosetsCommentsInterface(apiKey, sharedSecret, transport); } return photosetsCommentsInterface; } @Override
    public PhotosetsInterface getPhotosetsInterface() { if (photosetsInterface == null) { photosetsInterface = new PhotosetsInterface(apiKey, sharedSecret, transport); } return photosetsInterface; } @Override
    public CollectionsInterface getCollectionsInterface() { if (collectionsInterface == null) { collectionsInterface = new CollectionsInterface(apiKey, sharedSecret, transport); } return collectionsInterface; } @Override
    public PlacesInterface getPlacesInterface() { if (placesInterface == null) { placesInterface = new PlacesInterface(apiKey, sharedSecret, transport); } return placesInterface; } @Override
    public PrefsInterface getPrefsInterface() { if (prefsInterface == null) { prefsInterface = new PrefsInterface(apiKey, sharedSecret, transport); } return prefsInterface; } @Override
    public ReflectionInterface getReflectionInterface() { if (reflectionInterface == null) { reflectionInterface = new ReflectionInterface(apiKey, sharedSecret, transport); } return reflectionInterface; } @Override
    public TagsInterface getTagsInterface() { if (tagsInterface == null) { tagsInterface = new TagsInterface(apiKey, sharedSecret, transport); } return tagsInterface; } @Override
    public TestInterface getTestInterface() { if (testInterface == null) { testInterface = new TestInterface(apiKey, sharedSecret, transport); } return testInterface; } @Override
    public TransformInterface getTransformInterface() { if (transformInterface == null) { transformInterface = new TransformInterface(apiKey, sharedSecret, transport); } return transformInterface; } @Override
    public UploadInterface getUploadInterface() { if (uploadInterface == null) { uploadInterface = new UploadInterface(apiKey, sharedSecret, transport); } return uploadInterface; } @Override
    public Uploader getUploader() { if (uploader == null) { uploader = new Uploader(apiKey, sharedSecret); } return uploader; } @Override
    public UrlsInterface getUrlsInterface() { if (urlsInterface == null) { urlsInterface = new UrlsInterface(apiKey, sharedSecret, transport); } return urlsInterface; } @Override
    public GalleriesInterface getGalleriesInterface() { if (galleriesInterface == null) { galleriesInterface = new GalleriesInterface(apiKey, sharedSecret, transport); } return galleriesInterface; } @Override
    public StatsInterface getStatsInterface() { if (statsInterface == null) { statsInterface = new StatsInterface(apiKey, sharedSecret, transport); } return statsInterface; } @Override
    public CamerasInterface getCamerasInterface() { if (cameraInterface == null) { cameraInterface = new CamerasInterface(apiKey, sharedSecret, transport); } return cameraInterface; } @Override
    public SuggestionsInterface getSuggestionsInterface() { if (suggestionsInterface == null) { suggestionsInterface = new SuggestionsInterface(apiKey, sharedSecret, transport); } return suggestionsInterface; } @Override
    public GroupDiscussInterface getDiscussionInterface() { if (discussionInterface == null) { discussionInterface = new GroupDiscussInterface(apiKey, sharedSecret, transport); } return discussionInterface; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr; public class Flickr implements IFlickr { public static final String DEFAULT_HOST = ""api.flickr.com""; public static final String API_KEY = ""api_key""; public static boolean debugStream = false; public static boolean debugRequest = false; private String apiKey; private String sharedSecret; private Transport transport; private Auth auth; private AuthInterface authInterface; private ActivityInterface activityInterface; private BlogsInterface blogsInterface; private CommentsInterface commentsInterface; private CommonsInterface commonsInterface; private ContactsInterface contactsInterface; private FavoritesInterface favoritesInterface; private GeoInterface geoInterface; private GroupsInterface groupsInterface; private InterestingnessInterface interestingnessInterface; private LicensesInterface licensesInterface; private MembersInterface membersInterface; private MachinetagsInterface machinetagsInterface; private NotesInterface notesInterface; private PandaInterface pandaInterface; private PoolsInterface poolsInterface; private PeopleInterface peopleInterface; private PhotosInterface photosInterface; private PhotosetsCommentsInterface photosetsCommentsInterface; private PhotosetsInterface photosetsInterface; private CollectionsInterface collectionsInterface; private PlacesInterface placesInterface; private PrefsInterface prefsInterface; private ReflectionInterface reflectionInterface; private TagsInterface tagsInterface; private TestInterface testInterface; private TransformInterface transformInterface; private UploadInterface uploadInterface; private Uploader uploader; private UrlsInterface urlsInterface; private GalleriesInterface galleriesInterface; private StatsInterface statsInterface; private CamerasInterface cameraInterface; private SuggestionsInterface suggestionsInterface; private GroupDiscussInterface discussionInterface; public static final String CONTENTTYPE_PHOTO = ""1""; public static final String CONTENTTYPE_SCREENSHOT = ""2""; public static final String CONTENTTYPE_OTHER = ""3""; public static final int ACCURACY_WORLD = 1; public static final int ACCURACY_COUNTRY = 3; public static final int ACCURACY_REGION = 6; public static final int ACCURACY_CITY = 11; public static final int ACCURACY_STREET = 16; public static final String SAFETYLEVEL_SAFE = ""1""; public static final String SAFETYLEVEL_MODERATE = ""2""; public static final String SAFETYLEVEL_RESTRICTED = ""3""; public static final int PRIVACY_LEVEL_NO_FILTER = 0; public static final int PRIVACY_LEVEL_PUBLIC = 1; public static final int PRIVACY_LEVEL_FRIENDS = 2; public static final int PRIVACY_LEVEL_FAMILY = 3; public static final int PRIVACY_LEVEL_FRIENDS_FAMILY = 4; public static final int PRIVACY_LEVEL_PRIVATE = 5; public Flickr(String apiKey, String sharedSecret, Transport transport) { setApiKey(apiKey); setSharedSecret(sharedSecret); setTransport(transport); } @Override
    public String getApiKey() { return apiKey; } @Override
    public void setApiKey(String apiKey) { if (apiKey == null) { throw new IllegalArgumentException(""API key must not be null""); } this.apiKey = apiKey; } @Override
    public void setAuth(Auth auth) { this.auth = auth; } @Override
    public Auth getAuth() { return auth; } @Override
    public String getSharedSecret() { return sharedSecret; } @Override
    public void setSharedSecret(String sharedSecret) { if (sharedSecret == null) { throw new IllegalArgumentException(""Shared-Secret must not be null""); } this.sharedSecret = sharedSecret; } @Override
    public Transport getTransport() { return transport; } @Override
    public void setTransport(Transport transport) { if (transport == null) { throw new IllegalArgumentException(""Transport must not be null""); } this.transport = transport; } @Override
    public AuthInterface getAuthInterface() { if (authInterface == null) { authInterface = new AuthInterface(apiKey, sharedSecret, transport); } return authInterface; } @Override
    public ActivityInterface getActivityInterface() { if (activityInterface == null) { activityInterface = new ActivityInterface(apiKey, sharedSecret, transport); } return activityInterface; } @Override
    public synchronized BlogsInterface getBlogsInterface() { if (blogsInterface == null) { blogsInterface = new BlogsInterface(apiKey, sharedSecret, transport); } return blogsInterface; } @Override
    public CommentsInterface getCommentsInterface() { if (commentsInterface == null) { commentsInterface = new CommentsInterface(apiKey, sharedSecret, transport); } return commentsInterface; } @Override
    public CommonsInterface getCommonsInterface() { if (commonsInterface == null) { commonsInterface = new CommonsInterface(apiKey, sharedSecret, transport); } return commonsInterface; } @Override
    public ContactsInterface getContactsInterface() { if (contactsInterface == null) { contactsInterface = new ContactsInterface(apiKey, sharedSecret, transport); } return contactsInterface; } @Override
    public FavoritesInterface getFavoritesInterface() { if (favoritesInterface == null) { favoritesInterface = new FavoritesInterface(apiKey, sharedSecret, transport); } return favoritesInterface; } @Override
    public GeoInterface getGeoInterface() { if (geoInterface == null) { geoInterface = new GeoInterface(apiKey, sharedSecret, transport); } return geoInterface; } @Override
    public GroupsInterface getGroupsInterface() { if (groupsInterface == null) { groupsInterface = new GroupsInterface(apiKey, sharedSecret, transport); } return groupsInterface; } @Override
    public synchronized InterestingnessInterface getInterestingnessInterface() { if (interestingnessInterface == null) { interestingnessInterface = new InterestingnessInterface(apiKey, sharedSecret, transport); } return interestingnessInterface; } @Override
    public LicensesInterface getLicensesInterface() { if (licensesInterface == null) { licensesInterface = new LicensesInterface(apiKey, sharedSecret, transport); } return licensesInterface; } @Override
    public MachinetagsInterface getMachinetagsInterface() { if (machinetagsInterface == null) { machinetagsInterface = new MachinetagsInterface(apiKey, sharedSecret, transport); } return machinetagsInterface; } @Override
    public MembersInterface getMembersInterface() { if (membersInterface == null) { membersInterface = new MembersInterface(apiKey, sharedSecret, transport); } return membersInterface; } @Override
    public NotesInterface getNotesInterface() { if (notesInterface == null) { notesInterface = new NotesInterface(apiKey, sharedSecret, transport); } return notesInterface; } @Override
    public PandaInterface getPandaInterface() { if (pandaInterface == null) { pandaInterface = new PandaInterface(apiKey, sharedSecret, transport); } return pandaInterface; } @Override
    public PoolsInterface getPoolsInterface() { if (poolsInterface == null) { poolsInterface = new PoolsInterface(apiKey, sharedSecret, transport); } return poolsInterface; } @Override
    public PeopleInterface getPeopleInterface() { if (peopleInterface == null) { peopleInterface = new PeopleInterface(apiKey, sharedSecret, transport); } return peopleInterface; } @Override
    public PhotosInterface getPhotosInterface() { if (photosInterface == null) { photosInterface = new PhotosInterface(apiKey, sharedSecret, transport); } return photosInterface; } @Override
    public PhotosetsCommentsInterface getPhotosetsCommentsInterface() { if (photosetsCommentsInterface == null) { photosetsCommentsInterface = new PhotosetsCommentsInterface(apiKey, sharedSecret, transport); } return photosetsCommentsInterface; } @Override
    public PhotosetsInterface getPhotosetsInterface() { if (photosetsInterface == null) { photosetsInterface = new PhotosetsInterface(apiKey, sharedSecret, transport); } return photosetsInterface; } @Override
    public CollectionsInterface getCollectionsInterface() { if (collectionsInterface == null) { collectionsInterface = new CollectionsInterface(apiKey, sharedSecret, transport); } return collectionsInterface; } @Override
    public PlacesInterface getPlacesInterface() { if (placesInterface == null) { placesInterface = new PlacesInterface(apiKey, sharedSecret, transport); } return placesInterface; } @Override
    public PrefsInterface getPrefsInterface() { if (prefsInterface == null) { prefsInterface = new PrefsInterface(apiKey, sharedSecret, transport); } return prefsInterface; } @Override
    public ReflectionInterface getReflectionInterface() { if (reflectionInterface == null) { reflectionInterface = new ReflectionInterface(apiKey, sharedSecret, transport); } return reflectionInterface; } @Override
    public TagsInterface getTagsInterface() { if (tagsInterface == null) { tagsInterface = new TagsInterface(apiKey, sharedSecret, transport); } return tagsInterface; } @Override
    public TestInterface getTestInterface() { if (testInterface == null) { testInterface = new TestInterface(apiKey, sharedSecret, transport); } return testInterface; } @Override
    public TransformInterface getTransformInterface() { if (transformInterface == null) { transformInterface = new TransformInterface(apiKey, sharedSecret, transport); } return transformInterface; } @Override
    public UploadInterface getUploadInterface() { if (uploadInterface == null) { uploadInterface = new UploadInterface(apiKey, sharedSecret, transport); } return uploadInterface; } @Override
    public Uploader getUploader() { if (uploader == null) { uploader = new Uploader(apiKey, sharedSecret); } return uploader; } @Override
    public UrlsInterface getUrlsInterface() { if (urlsInterface == null) { urlsInterface = new UrlsInterface(apiKey, sharedSecret, transport); } return urlsInterface; } @Override
    public GalleriesInterface getGalleriesInterface() { if (galleriesInterface == null) { galleriesInterface = new GalleriesInterface(apiKey, sharedSecret, transport); } return galleriesInterface; } @Override
    public StatsInterface getStatsInterface() { if (statsInterface == null) { statsInterface = new StatsInterface(apiKey, sharedSecret, transport); } return statsInterface; } @Override
    public CamerasInterface getCamerasInterface() { if (cameraInterface == null) { cameraInterface = new CamerasInterface(apiKey, sharedSecret, transport); } return cameraInterface; } @Override
    public SuggestionsInterface getSuggestionsInterface() { if (suggestionsInterface == null) { suggestionsInterface = new SuggestionsInterface(apiKey, sharedSecret, transport); } return suggestionsInterface; } @Override
    public GroupDiscussInterface getDiscussionInterface() { if (discussionInterface == null) { discussionInterface = new GroupDiscussInterface(apiKey, sharedSecret, transport); } return discussionInterface; } } "," package com.flickr4java.flickr; 
import com.flickr4java.flickr.activity.ActivityInterface; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.auth.AuthInterface; import com.flickr4java.flickr.blogs.BlogsInterface; import com.flickr4java.flickr.cameras.CamerasInterface; import com.flickr4java.flickr.collections.CollectionsInterface; import com.flickr4java.flickr.commons.CommonsInterface; import com.flickr4java.flickr.contacts.ContactsInterface; import com.flickr4java.flickr.favorites.FavoritesInterface; import com.flickr4java.flickr.galleries.GalleriesInterface; import com.flickr4java.flickr.groups.GroupsInterface; import com.flickr4java.flickr.groups.discuss.GroupDiscussInterface; import com.flickr4java.flickr.groups.members.MembersInterface; import com.flickr4java.flickr.groups.pools.PoolsInterface; import com.flickr4java.flickr.interestingness.InterestingnessInterface; import com.flickr4java.flickr.machinetags.MachinetagsInterface; import com.flickr4java.flickr.panda.PandaInterface; import com.flickr4java.flickr.people.PeopleInterface; import com.flickr4java.flickr.photos.PhotosInterface; import com.flickr4java.flickr.photos.comments.CommentsInterface; import com.flickr4java.flickr.photos.geo.GeoInterface; import com.flickr4java.flickr.photos.licenses.LicensesInterface; import com.flickr4java.flickr.photos.notes.NotesInterface; import com.flickr4java.flickr.photos.suggestions.SuggestionsInterface; import com.flickr4java.flickr.photos.transform.TransformInterface; import com.flickr4java.flickr.photos.upload.UploadInterface; import com.flickr4java.flickr.photosets.PhotosetsInterface; import com.flickr4java.flickr.photosets.comments.PhotosetsCommentsInterface; import com.flickr4java.flickr.places.PlacesInterface; import com.flickr4java.flickr.prefs.PrefsInterface; import com.flickr4java.flickr.reflection.ReflectionInterface; import com.flickr4java.flickr.stats.StatsInterface; import com.flickr4java.flickr.tags.TagsInterface; import com.flickr4java.flickr.test.TestInterface; import com.flickr4java.flickr.uploader.Uploader; import com.flickr4java.flickr.urls.UrlsInterface; 
import java.util.Set;  /**
 * Main entry point for the Flickr4Java API. This class is used to acquire Interface classes which wrap the Flickr API.
 * <p>
 * 
 * If you registered API keys, you find them with the shared secret at your <a href=""http://www.flickr.com/services/api/registered_keys.gne"">list of API
 * keys</a>
 * <p>
 * 
 * The user who authenticates himself, can manage this permissions at <a href=""http://www.flickr.com/services/auth/list.gne"">his list of Third-party
 * applications</a> (You / Your account / Extending Flickr / Account Links / edit).
 * 
 * @author Anthony Eden
 * @version $Id: Flickr.java,v 1.45 2009/06/23 21:51:25 x-mago Exp $
 */ public class Flickr implements IFlickr {  /**
     * The default endpoint host.
     */ public static final String DEFAULT_HOST = ""api.flickr.com"";  /**
     * The key used when the API key is stored for passing to the Transport methods.
     */ public static final String API_KEY = ""api_key"";  /**
     * Set to true to enable response debugging (print the response stream)
     */ public static boolean debugStream = false;  /**
     * Set to true to enable request debugging (print the request stream, used for ""post"")
     */ public static boolean debugRequest = false;  private String apiKey;  private String sharedSecret;  private Transport transport;  private Auth auth;  private AuthInterface authInterface;  private ActivityInterface activityInterface;  private BlogsInterface blogsInterface;  private CommentsInterface commentsInterface;  private CommonsInterface commonsInterface;  private ContactsInterface contactsInterface;  private FavoritesInterface favoritesInterface;  private GeoInterface geoInterface;  private GroupsInterface groupsInterface;  private InterestingnessInterface interestingnessInterface;  private LicensesInterface licensesInterface;  private MembersInterface membersInterface;  private MachinetagsInterface machinetagsInterface;  private NotesInterface notesInterface;  private PandaInterface pandaInterface;  private PoolsInterface poolsInterface;  private PeopleInterface peopleInterface;  private PhotosInterface photosInterface;  private PhotosetsCommentsInterface photosetsCommentsInterface;  private PhotosetsInterface photosetsInterface;  private CollectionsInterface collectionsInterface;  private PlacesInterface placesInterface;  private PrefsInterface prefsInterface;  private ReflectionInterface reflectionInterface;  private TagsInterface tagsInterface;  private TestInterface testInterface;  private TransformInterface transformInterface;  private UploadInterface uploadInterface;  private Uploader uploader;  private UrlsInterface urlsInterface;  private GalleriesInterface galleriesInterface;  private StatsInterface statsInterface;  private CamerasInterface cameraInterface;  private SuggestionsInterface suggestionsInterface;  private GroupDiscussInterface discussionInterface;  /**
     * @see com.flickr4java.flickr.photos.PhotosInterface#setContentType(String, String)
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getContentType()
     * @see com.flickr4java.flickr.uploader.UploadMetaData#setContentType(String)
     */ public static final String CONTENTTYPE_PHOTO = ""1"";  /**
     * @see com.flickr4java.flickr.photos.PhotosInterface#setContentType(String, String)
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getContentType()
     * @see com.flickr4java.flickr.uploader.UploadMetaData#setContentType(String)
     */ public static final String CONTENTTYPE_SCREENSHOT = ""2"";  /**
     * @see com.flickr4java.flickr.photos.PhotosInterface#setContentType(String, String)
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getContentType()
     * @see com.flickr4java.flickr.uploader.UploadMetaData#setContentType(String)
     */ public static final String CONTENTTYPE_OTHER = ""3"";  /**
     * The lowest accuracy for bounding-box searches.
     * 
     * @see com.flickr4java.flickr.photos.SearchParameters#setAccuracy(int)
     */ public static final int ACCURACY_WORLD = 1;  /**
     * @see com.flickr4java.flickr.photos.SearchParameters#setAccuracy(int)
     */ public static final int ACCURACY_COUNTRY = 3;  /**
     * @see com.flickr4java.flickr.photos.SearchParameters#setAccuracy(int)
     */ public static final int ACCURACY_REGION = 6;  /**
     * @see com.flickr4java.flickr.photos.SearchParameters#setAccuracy(int)
     */ public static final int ACCURACY_CITY = 11;  /**
     * The highest accuracy for bounding-box searches.
     * 
     * @see com.flickr4java.flickr.photos.SearchParameters#setAccuracy(int)
     */ public static final int ACCURACY_STREET = 16;  /**
     * @see com.flickr4java.flickr.photos.PhotosInterface#setSafetyLevel(String, String, Boolean)
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getSafetyLevel()
     * @see com.flickr4java.flickr.uploader.UploadMetaData#setSafetyLevel(String)
     * @see com.flickr4java.flickr.photos.SearchParameters#setSafeSearch(String)
     */ public static final String SAFETYLEVEL_SAFE = ""1"";  /**
     * @see com.flickr4java.flickr.photos.PhotosInterface#setSafetyLevel(String, String, Boolean)
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getSafetyLevel()
     * @see com.flickr4java.flickr.uploader.UploadMetaData#setSafetyLevel(String)
     * @see com.flickr4java.flickr.photos.SearchParameters#setSafeSearch(String)
     */ public static final String SAFETYLEVEL_MODERATE = ""2"";  /**
     * @see com.flickr4java.flickr.photos.PhotosInterface#setSafetyLevel(String, String, Boolean)
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getSafetyLevel()
     * @see com.flickr4java.flickr.uploader.UploadMetaData#setSafetyLevel(String)
     * @see com.flickr4java.flickr.photos.SearchParameters#setSafeSearch(String)
     */ public static final String SAFETYLEVEL_RESTRICTED = ""3"";  /**
     * @see com.flickr4java.flickr.photosets.PhotosetsInterface#getPhotos(String, Set, int, int, int)
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getPrivacy()
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getGeoPerms()
     */ public static final int PRIVACY_LEVEL_NO_FILTER = 0;  /**
     * @see com.flickr4java.flickr.photosets.PhotosetsInterface#getPhotos(String, Set, int, int, int)
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getPrivacy()
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getGeoPerms()
     */ public static final int PRIVACY_LEVEL_PUBLIC = 1;  /**
     * @see com.flickr4java.flickr.photosets.PhotosetsInterface#getPhotos(String, Set, int, int, int)
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getPrivacy()
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getGeoPerms()
     */ public static final int PRIVACY_LEVEL_FRIENDS = 2;  /**
     * @see com.flickr4java.flickr.photosets.PhotosetsInterface#getPhotos(String, Set, int, int, int)
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getPrivacy()
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getGeoPerms()
     */ public static final int PRIVACY_LEVEL_FAMILY = 3;  /**
     * @see com.flickr4java.flickr.photosets.PhotosetsInterface#getPhotos(String, Set, int, int, int)
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getPrivacy()
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getGeoPerms()
     */ public static final int PRIVACY_LEVEL_FRIENDS_FAMILY = 4;  /**
     * @see com.flickr4java.flickr.photosets.PhotosetsInterface#getPhotos(String, Set, int, int, int)
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getPrivacy()
     * @see com.flickr4java.flickr.prefs.PrefsInterface#getGeoPerms()
     */ public static final int PRIVACY_LEVEL_PRIVATE = 5;  /**
     * Construct a new Flickr gateway instance.
     * 
     * @param apiKey
     *            The API key, must be non-null
     * @param sharedSecret
     * @param transport
     */ public Flickr(String apiKey, String sharedSecret, Transport transport) { setApiKey(apiKey); setSharedSecret(sharedSecret); setTransport(transport); }  /**
     * Get the API key.
     * 
     * @return The API key
     */ @Override
    public String getApiKey() { return apiKey; }  /**
     * Set the API key to use which must not be null.
     * 
     * @param apiKey
     *            The API key which cannot be null
     */ @Override
    public void setApiKey(String apiKey) { if (apiKey == null) { throw new IllegalArgumentException(""API key must not be null""); } this.apiKey = apiKey; }  @Override
    public void setAuth(Auth auth) { this.auth = auth; }  /**
     * Get the Auth-object.
     * 
     * @return The Auth-object
     */ @Override
    public Auth getAuth() { return auth; }  /**
     * Get the Shared-Secret.
     * 
     * @return The Shared-Secret
     */ @Override
    public String getSharedSecret() { return sharedSecret; }  /**
     * Set the Shared-Secret to use which must not be null.
     * 
     * @param sharedSecret
     *            The Shared-Secret which cannot be null
     */ @Override
    public void setSharedSecret(String sharedSecret) { if (sharedSecret == null) { throw new IllegalArgumentException(""Shared-Secret must not be null""); } this.sharedSecret = sharedSecret; }  /**
     * Get the Transport interface.
     * 
     * @return The Tranport interface
     */ @Override
    public Transport getTransport() { return transport; }  /**
     * Set the Transport which must not be null.
     * 
     * @param transport
     */ @Override
    public void setTransport(Transport transport) { if (transport == null) { throw new IllegalArgumentException(""Transport must not be null""); } this.transport = transport; }  /**
     * Get the AuthInterface.
     * 
     * @return The AuthInterface
     */ @Override
    public AuthInterface getAuthInterface() { if (authInterface == null) { authInterface = new AuthInterface(apiKey, sharedSecret, transport); } return authInterface; }  /**
     * Get the ActivityInterface.
     * 
     * @return The ActivityInterface
     */ @Override
    public ActivityInterface getActivityInterface() { if (activityInterface == null) { activityInterface = new ActivityInterface(apiKey, sharedSecret, transport); } return activityInterface; }  @Override
    public synchronized BlogsInterface getBlogsInterface() { if (blogsInterface == null) { blogsInterface = new BlogsInterface(apiKey, sharedSecret, transport); } return blogsInterface; }  @Override
    public CommentsInterface getCommentsInterface() { if (commentsInterface == null) { commentsInterface = new CommentsInterface(apiKey, sharedSecret, transport); } return commentsInterface; }  @Override
    public CommonsInterface getCommonsInterface() { if (commonsInterface == null) { commonsInterface = new CommonsInterface(apiKey, sharedSecret, transport); } return commonsInterface; }  @Override
    public ContactsInterface getContactsInterface() { if (contactsInterface == null) { contactsInterface = new ContactsInterface(apiKey, sharedSecret, transport); } return contactsInterface; }  @Override
    public FavoritesInterface getFavoritesInterface() { if (favoritesInterface == null) { favoritesInterface = new FavoritesInterface(apiKey, sharedSecret, transport); } return favoritesInterface; }  @Override
    public GeoInterface getGeoInterface() { if (geoInterface == null) { geoInterface = new GeoInterface(apiKey, sharedSecret, transport); } return geoInterface; }  @Override
    public GroupsInterface getGroupsInterface() { if (groupsInterface == null) { groupsInterface = new GroupsInterface(apiKey, sharedSecret, transport); } return groupsInterface; }  /**
     * @return the interface to the flickr.interestingness methods
     */ @Override
    public synchronized InterestingnessInterface getInterestingnessInterface() { if (interestingnessInterface == null) { interestingnessInterface = new InterestingnessInterface(apiKey, sharedSecret, transport); } return interestingnessInterface; }  @Override
    public LicensesInterface getLicensesInterface() { if (licensesInterface == null) { licensesInterface = new LicensesInterface(apiKey, sharedSecret, transport); } return licensesInterface; }  @Override
    public MachinetagsInterface getMachinetagsInterface() { if (machinetagsInterface == null) { machinetagsInterface = new MachinetagsInterface(apiKey, sharedSecret, transport); } return machinetagsInterface; }  @Override
    public MembersInterface getMembersInterface() { if (membersInterface == null) { membersInterface = new MembersInterface(apiKey, sharedSecret, transport); } return membersInterface; }  @Override
    public NotesInterface getNotesInterface() { if (notesInterface == null) { notesInterface = new NotesInterface(apiKey, sharedSecret, transport); } return notesInterface; }  @Override
    public PandaInterface getPandaInterface() { if (pandaInterface == null) { pandaInterface = new PandaInterface(apiKey, sharedSecret, transport); } return pandaInterface; }  @Override
    public PoolsInterface getPoolsInterface() { if (poolsInterface == null) { poolsInterface = new PoolsInterface(apiKey, sharedSecret, transport); } return poolsInterface; }  @Override
    public PeopleInterface getPeopleInterface() { if (peopleInterface == null) { peopleInterface = new PeopleInterface(apiKey, sharedSecret, transport); } return peopleInterface; }  @Override
    public PhotosInterface getPhotosInterface() { if (photosInterface == null) { photosInterface = new PhotosInterface(apiKey, sharedSecret, transport); } return photosInterface; }  @Override
    public PhotosetsCommentsInterface getPhotosetsCommentsInterface() { if (photosetsCommentsInterface == null) { photosetsCommentsInterface = new PhotosetsCommentsInterface(apiKey, sharedSecret, transport); } return photosetsCommentsInterface; }  @Override
    public PhotosetsInterface getPhotosetsInterface() { if (photosetsInterface == null) { photosetsInterface = new PhotosetsInterface(apiKey, sharedSecret, transport); } return photosetsInterface; }  @Override
    public CollectionsInterface getCollectionsInterface() { if (collectionsInterface == null) { collectionsInterface = new CollectionsInterface(apiKey, sharedSecret, transport); } return collectionsInterface; }  @Override
    public PlacesInterface getPlacesInterface() { if (placesInterface == null) { placesInterface = new PlacesInterface(apiKey, sharedSecret, transport); } return placesInterface; }  @Override
    public PrefsInterface getPrefsInterface() { if (prefsInterface == null) { prefsInterface = new PrefsInterface(apiKey, sharedSecret, transport); } return prefsInterface; }  @Override
    public ReflectionInterface getReflectionInterface() { if (reflectionInterface == null) { reflectionInterface = new ReflectionInterface(apiKey, sharedSecret, transport); } return reflectionInterface; }  /**
     * Get the TagsInterface for working with Flickr Tags.
     * 
     * @return The TagsInterface
     */ @Override
    public TagsInterface getTagsInterface() { if (tagsInterface == null) { tagsInterface = new TagsInterface(apiKey, sharedSecret, transport); } return tagsInterface; }  @Override
    public TestInterface getTestInterface() { if (testInterface == null) { testInterface = new TestInterface(apiKey, sharedSecret, transport); } return testInterface; }  @Override
    public TransformInterface getTransformInterface() { if (transformInterface == null) { transformInterface = new TransformInterface(apiKey, sharedSecret, transport); } return transformInterface; }  @Override
    public UploadInterface getUploadInterface() { if (uploadInterface == null) { uploadInterface = new UploadInterface(apiKey, sharedSecret, transport); } return uploadInterface; }  @Override
    public Uploader getUploader() { if (uploader == null) { uploader = new Uploader(apiKey, sharedSecret); } return uploader; }  @Override
    public UrlsInterface getUrlsInterface() { if (urlsInterface == null) { urlsInterface = new UrlsInterface(apiKey, sharedSecret, transport); } return urlsInterface; }  @Override
    public GalleriesInterface getGalleriesInterface() { if (galleriesInterface == null) { galleriesInterface = new GalleriesInterface(apiKey, sharedSecret, transport); } return galleriesInterface; }  @Override
    public StatsInterface getStatsInterface() { if (statsInterface == null) { statsInterface = new StatsInterface(apiKey, sharedSecret, transport); } return statsInterface; }  @Override
    public CamerasInterface getCamerasInterface() { if (cameraInterface == null) { cameraInterface = new CamerasInterface(apiKey, sharedSecret, transport); } return cameraInterface; }  /**
     * Get the SuggestionsInterface.
     * 
     * @return The SuggestionsInterface
     */ @Override
    public SuggestionsInterface getSuggestionsInterface() { if (suggestionsInterface == null) { suggestionsInterface = new SuggestionsInterface(apiKey, sharedSecret, transport); } return suggestionsInterface; }  /**
     * Get the GroupDiscussInterface.
     * 
     * @return The GroupDiscussInterface
     */  @Override
    public GroupDiscussInterface getDiscussionInterface() { if (discussionInterface == null) { discussionInterface = new GroupDiscussInterface(apiKey, sharedSecret, transport); } return discussionInterface; }  }  "
src/main/java/com/flickr4java/flickr/FlickrException.java,"
package com.flickr4java.flickr;

/**
 * Exception which wraps a Flickr error.
 * 
 * @author Anthony Eden
 */
public class FlickrException extends Exception {

    private static final long serialVersionUID = 7958091410349084831L;

    private String errorCode;

    private String errorMessage;

    public FlickrException(String errorMessage) {

        super(errorMessage);
    }

    public FlickrException(String errorMessage, Throwable rootCause) {

        super(errorMessage, rootCause);
    }

    public FlickrException(Throwable rootCause) {

        super(rootCause);
    }

    public FlickrException(String errorCode, String errorMessage) {
        super(errorCode + "": "" + errorMessage);
        this.errorCode = errorCode;
        this.errorMessage = errorMessage;
    }

    public String getErrorCode() {
        return errorCode;
    }

    public String getErrorMessage() {
        return errorMessage;
    }

}
","package com.flickr4java.flickr; public class FlickrException extends Exception { private static final long serialVersionUID = 7958091410349084831L; private String errorCode; private String errorMessage; public FlickrException(String errorMessage) { super(errorMessage); } public FlickrException(String errorMessage, Throwable rootCause) { super(errorMessage, rootCause); } public FlickrException(Throwable rootCause) { super(rootCause); } public FlickrException(String errorCode, String errorMessage) { super(errorCode + "": "" + errorMessage); this.errorCode = errorCode; this.errorMessage = errorMessage; } public String getErrorCode() { return errorCode; } public String getErrorMessage() { return errorMessage; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr; public class FlickrException extends Exception { private static final long serialVersionUID = 7958091410349084831L; private String errorCode; private String errorMessage; public FlickrException(String errorMessage) { super(errorMessage); } public FlickrException(String errorMessage, Throwable rootCause) { super(errorMessage, rootCause); } public FlickrException(Throwable rootCause) { super(rootCause); } public FlickrException(String errorCode, String errorMessage) { super(errorCode + "": "" + errorMessage); this.errorCode = errorCode; this.errorMessage = errorMessage; } public String getErrorCode() { return errorCode; } public String getErrorMessage() { return errorMessage; } } "," package com.flickr4java.flickr;  /**
 * Exception which wraps a Flickr error.
 * 
 * @author Anthony Eden
 */ public class FlickrException extends Exception {  private static final long serialVersionUID = 7958091410349084831L;  private String errorCode;  private String errorMessage;  public FlickrException(String errorMessage) {  super(errorMessage); }  public FlickrException(String errorMessage, Throwable rootCause) {  super(errorMessage, rootCause); }  public FlickrException(Throwable rootCause) {  super(rootCause); }  public FlickrException(String errorCode, String errorMessage) { super(errorCode + "": "" + errorMessage); this.errorCode = errorCode; this.errorMessage = errorMessage; }  public String getErrorCode() { return errorCode; }  public String getErrorMessage() { return errorMessage; }  }  "
src/main/java/com/flickr4java/flickr/FlickrRuntimeException.java,"package com.flickr4java.flickr;

/**
 * {@link RuntimeException} wrapper for the various XML or IO Exceptions thrown.
 * 
 * @author Darren Greaves
 * @version $Id$ Copyright (c) 2012 Darren Greaves.
 */
public class FlickrRuntimeException extends RuntimeException {

    private static final long serialVersionUID = 1303207981175254196L;

    public FlickrRuntimeException() {
    }

    public FlickrRuntimeException(String message) {
        super(message);
    }

    public FlickrRuntimeException(Throwable rootCause) {
        super(rootCause);
    }

    public FlickrRuntimeException(String message, Throwable rootCause) {
        super(message, rootCause);
    }
}
","package com.flickr4java.flickr; public class FlickrRuntimeException extends RuntimeException { private static final long serialVersionUID = 1303207981175254196L; public FlickrRuntimeException() { } public FlickrRuntimeException(String message) { super(message); } public FlickrRuntimeException(Throwable rootCause) { super(rootCause); } public FlickrRuntimeException(String message, Throwable rootCause) { super(message, rootCause); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr; public class FlickrRuntimeException extends RuntimeException { private static final long serialVersionUID = 1303207981175254196L; public FlickrRuntimeException() { } public FlickrRuntimeException(String message) { super(message); } public FlickrRuntimeException(Throwable rootCause) { super(rootCause); } public FlickrRuntimeException(String message, Throwable rootCause) { super(message, rootCause); } } ","package com.flickr4java.flickr;  /**
 * {@link RuntimeException} wrapper for the various XML or IO Exceptions thrown.
 * 
 * @author Darren Greaves
 * @version $Id$ Copyright (c) 2012 Darren Greaves.
 */ public class FlickrRuntimeException extends RuntimeException {  private static final long serialVersionUID = 1303207981175254196L;  public FlickrRuntimeException() { }  public FlickrRuntimeException(String message) { super(message); }  public FlickrRuntimeException(Throwable rootCause) { super(rootCause); }  public FlickrRuntimeException(String message, Throwable rootCause) { super(message, rootCause); } }  "
src/main/java/com/flickr4java/flickr/IFlickr.java,"package com.flickr4java.flickr;

import com.flickr4java.flickr.activity.ActivityInterface;
import com.flickr4java.flickr.auth.Auth;
import com.flickr4java.flickr.auth.AuthInterface;
import com.flickr4java.flickr.blogs.BlogsInterface;
import com.flickr4java.flickr.cameras.CamerasInterface;
import com.flickr4java.flickr.collections.CollectionsInterface;
import com.flickr4java.flickr.commons.CommonsInterface;
import com.flickr4java.flickr.contacts.ContactsInterface;
import com.flickr4java.flickr.favorites.FavoritesInterface;
import com.flickr4java.flickr.galleries.GalleriesInterface;
import com.flickr4java.flickr.groups.GroupsInterface;
import com.flickr4java.flickr.groups.discuss.GroupDiscussInterface;
import com.flickr4java.flickr.groups.members.MembersInterface;
import com.flickr4java.flickr.groups.pools.PoolsInterface;
import com.flickr4java.flickr.interestingness.InterestingnessInterface;
import com.flickr4java.flickr.machinetags.MachinetagsInterface;
import com.flickr4java.flickr.panda.PandaInterface;
import com.flickr4java.flickr.people.PeopleInterface;
import com.flickr4java.flickr.photos.PhotosInterface;
import com.flickr4java.flickr.photos.comments.CommentsInterface;
import com.flickr4java.flickr.photos.geo.GeoInterface;
import com.flickr4java.flickr.photos.licenses.LicensesInterface;
import com.flickr4java.flickr.photos.notes.NotesInterface;
import com.flickr4java.flickr.photos.suggestions.SuggestionsInterface;
import com.flickr4java.flickr.photos.transform.TransformInterface;
import com.flickr4java.flickr.photos.upload.UploadInterface;
import com.flickr4java.flickr.photosets.PhotosetsInterface;
import com.flickr4java.flickr.photosets.comments.PhotosetsCommentsInterface;
import com.flickr4java.flickr.places.PlacesInterface;
import com.flickr4java.flickr.prefs.PrefsInterface;
import com.flickr4java.flickr.reflection.ReflectionInterface;
import com.flickr4java.flickr.stats.StatsInterface;
import com.flickr4java.flickr.tags.TagsInterface;
import com.flickr4java.flickr.test.TestInterface;
import com.flickr4java.flickr.uploader.Uploader;
import com.flickr4java.flickr.urls.UrlsInterface;

public interface IFlickr {
    String getApiKey();

    void setApiKey(String apiKey);

    void setAuth(Auth auth);

    Auth getAuth();

    String getSharedSecret();

    void setSharedSecret(String sharedSecret);

    Transport getTransport();

    void setTransport(Transport transport);

    AuthInterface getAuthInterface();

    ActivityInterface getActivityInterface();

    BlogsInterface getBlogsInterface();

    CommentsInterface getCommentsInterface();

    CommonsInterface getCommonsInterface();

    ContactsInterface getContactsInterface();

    FavoritesInterface getFavoritesInterface();

    GeoInterface getGeoInterface();

    GroupsInterface getGroupsInterface();

    InterestingnessInterface getInterestingnessInterface();

    LicensesInterface getLicensesInterface();

    MachinetagsInterface getMachinetagsInterface();

    MembersInterface getMembersInterface();

    NotesInterface getNotesInterface();

    PandaInterface getPandaInterface();

    PoolsInterface getPoolsInterface();

    PeopleInterface getPeopleInterface();

    PhotosInterface getPhotosInterface();

    PhotosetsCommentsInterface getPhotosetsCommentsInterface();

    PhotosetsInterface getPhotosetsInterface();

    CollectionsInterface getCollectionsInterface();

    PlacesInterface getPlacesInterface();

    PrefsInterface getPrefsInterface();

    ReflectionInterface getReflectionInterface();

    TagsInterface getTagsInterface();

    TestInterface getTestInterface();

    TransformInterface getTransformInterface();

    UploadInterface getUploadInterface();

    Uploader getUploader();

    UrlsInterface getUrlsInterface();

    GalleriesInterface getGalleriesInterface();

    StatsInterface getStatsInterface();

    CamerasInterface getCamerasInterface();

    SuggestionsInterface getSuggestionsInterface();

    GroupDiscussInterface getDiscussionInterface();
}
",package com.flickr4java.flickr; public interface IFlickr { String getApiKey(); void setApiKey(String apiKey); void setAuth(Auth auth); Auth getAuth(); String getSharedSecret(); void setSharedSecret(String sharedSecret); Transport getTransport(); void setTransport(Transport transport); AuthInterface getAuthInterface(); ActivityInterface getActivityInterface(); BlogsInterface getBlogsInterface(); CommentsInterface getCommentsInterface(); CommonsInterface getCommonsInterface(); ContactsInterface getContactsInterface(); FavoritesInterface getFavoritesInterface(); GeoInterface getGeoInterface(); GroupsInterface getGroupsInterface(); InterestingnessInterface getInterestingnessInterface(); LicensesInterface getLicensesInterface(); MachinetagsInterface getMachinetagsInterface(); MembersInterface getMembersInterface(); NotesInterface getNotesInterface(); PandaInterface getPandaInterface(); PoolsInterface getPoolsInterface(); PeopleInterface getPeopleInterface(); PhotosInterface getPhotosInterface(); PhotosetsCommentsInterface getPhotosetsCommentsInterface(); PhotosetsInterface getPhotosetsInterface(); CollectionsInterface getCollectionsInterface(); PlacesInterface getPlacesInterface(); PrefsInterface getPrefsInterface(); ReflectionInterface getReflectionInterface(); TagsInterface getTagsInterface(); TestInterface getTestInterface(); TransformInterface getTransformInterface(); UploadInterface getUploadInterface(); Uploader getUploader(); UrlsInterface getUrlsInterface(); GalleriesInterface getGalleriesInterface(); StatsInterface getStatsInterface(); CamerasInterface getCamerasInterface(); SuggestionsInterface getSuggestionsInterface(); GroupDiscussInterface getDiscussionInterface(); },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr; public interface IFlickr { String getApiKey(); void setApiKey(String apiKey); void setAuth(Auth auth); Auth getAuth(); String getSharedSecret(); void setSharedSecret(String sharedSecret); Transport getTransport(); void setTransport(Transport transport); AuthInterface getAuthInterface(); ActivityInterface getActivityInterface(); BlogsInterface getBlogsInterface(); CommentsInterface getCommentsInterface(); CommonsInterface getCommonsInterface(); ContactsInterface getContactsInterface(); FavoritesInterface getFavoritesInterface(); GeoInterface getGeoInterface(); GroupsInterface getGroupsInterface(); InterestingnessInterface getInterestingnessInterface(); LicensesInterface getLicensesInterface(); MachinetagsInterface getMachinetagsInterface(); MembersInterface getMembersInterface(); NotesInterface getNotesInterface(); PandaInterface getPandaInterface(); PoolsInterface getPoolsInterface(); PeopleInterface getPeopleInterface(); PhotosInterface getPhotosInterface(); PhotosetsCommentsInterface getPhotosetsCommentsInterface(); PhotosetsInterface getPhotosetsInterface(); CollectionsInterface getCollectionsInterface(); PlacesInterface getPlacesInterface(); PrefsInterface getPrefsInterface(); ReflectionInterface getReflectionInterface(); TagsInterface getTagsInterface(); TestInterface getTestInterface(); TransformInterface getTransformInterface(); UploadInterface getUploadInterface(); Uploader getUploader(); UrlsInterface getUrlsInterface(); GalleriesInterface getGalleriesInterface(); StatsInterface getStatsInterface(); CamerasInterface getCamerasInterface(); SuggestionsInterface getSuggestionsInterface(); GroupDiscussInterface getDiscussionInterface(); } ,"package com.flickr4java.flickr; 
import com.flickr4java.flickr.activity.ActivityInterface; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.auth.AuthInterface; import com.flickr4java.flickr.blogs.BlogsInterface; import com.flickr4java.flickr.cameras.CamerasInterface; import com.flickr4java.flickr.collections.CollectionsInterface; import com.flickr4java.flickr.commons.CommonsInterface; import com.flickr4java.flickr.contacts.ContactsInterface; import com.flickr4java.flickr.favorites.FavoritesInterface; import com.flickr4java.flickr.galleries.GalleriesInterface; import com.flickr4java.flickr.groups.GroupsInterface; import com.flickr4java.flickr.groups.discuss.GroupDiscussInterface; import com.flickr4java.flickr.groups.members.MembersInterface; import com.flickr4java.flickr.groups.pools.PoolsInterface; import com.flickr4java.flickr.interestingness.InterestingnessInterface; import com.flickr4java.flickr.machinetags.MachinetagsInterface; import com.flickr4java.flickr.panda.PandaInterface; import com.flickr4java.flickr.people.PeopleInterface; import com.flickr4java.flickr.photos.PhotosInterface; import com.flickr4java.flickr.photos.comments.CommentsInterface; import com.flickr4java.flickr.photos.geo.GeoInterface; import com.flickr4java.flickr.photos.licenses.LicensesInterface; import com.flickr4java.flickr.photos.notes.NotesInterface; import com.flickr4java.flickr.photos.suggestions.SuggestionsInterface; import com.flickr4java.flickr.photos.transform.TransformInterface; import com.flickr4java.flickr.photos.upload.UploadInterface; import com.flickr4java.flickr.photosets.PhotosetsInterface; import com.flickr4java.flickr.photosets.comments.PhotosetsCommentsInterface; import com.flickr4java.flickr.places.PlacesInterface; import com.flickr4java.flickr.prefs.PrefsInterface; import com.flickr4java.flickr.reflection.ReflectionInterface; import com.flickr4java.flickr.stats.StatsInterface; import com.flickr4java.flickr.tags.TagsInterface; import com.flickr4java.flickr.test.TestInterface; import com.flickr4java.flickr.uploader.Uploader; import com.flickr4java.flickr.urls.UrlsInterface;  public interface IFlickr { String getApiKey();  void setApiKey(String apiKey);  void setAuth(Auth auth);  Auth getAuth();  String getSharedSecret();  void setSharedSecret(String sharedSecret);  Transport getTransport();  void setTransport(Transport transport);  AuthInterface getAuthInterface();  ActivityInterface getActivityInterface();  BlogsInterface getBlogsInterface();  CommentsInterface getCommentsInterface();  CommonsInterface getCommonsInterface();  ContactsInterface getContactsInterface();  FavoritesInterface getFavoritesInterface();  GeoInterface getGeoInterface();  GroupsInterface getGroupsInterface();  InterestingnessInterface getInterestingnessInterface();  LicensesInterface getLicensesInterface();  MachinetagsInterface getMachinetagsInterface();  MembersInterface getMembersInterface();  NotesInterface getNotesInterface();  PandaInterface getPandaInterface();  PoolsInterface getPoolsInterface();  PeopleInterface getPeopleInterface();  PhotosInterface getPhotosInterface();  PhotosetsCommentsInterface getPhotosetsCommentsInterface();  PhotosetsInterface getPhotosetsInterface();  CollectionsInterface getCollectionsInterface();  PlacesInterface getPlacesInterface();  PrefsInterface getPrefsInterface();  ReflectionInterface getReflectionInterface();  TagsInterface getTagsInterface();  TestInterface getTestInterface();  TransformInterface getTransformInterface();  UploadInterface getUploadInterface();  Uploader getUploader();  UrlsInterface getUrlsInterface();  GalleriesInterface getGalleriesInterface();  StatsInterface getStatsInterface();  CamerasInterface getCamerasInterface();  SuggestionsInterface getSuggestionsInterface();  GroupDiscussInterface getDiscussionInterface(); }  "
src/main/java/com/flickr4java/flickr/Parameter.java,"
package com.flickr4java.flickr;

/**
 * Class encapsulating a name/value parameter.
 * 
 * @author Anthony Eden
 */
public class Parameter {

    private String name;

    private Object value;

    /**
     * Construct the Parameter.
     * 
     * @param name
     *            The parameter name
     * @param value
     *            The parameter value
     */
    public Parameter(String name, Object value) {
        this.name = name;
        this.value = value;
    }

    public Parameter(String name, long value) {
        this.name = name;
        this.value = value;
    }

    public String getName() {
        return name;
    }

    public Object getValue() {
        return value;
    }

}
","package com.flickr4java.flickr; public class Parameter { private String name; private Object value; public Parameter(String name, Object value) { this.name = name; this.value = value; } public Parameter(String name, long value) { this.name = name; this.value = value; } public String getName() { return name; } public Object getValue() { return value; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr; public class Parameter { private String name; private Object value; public Parameter(String name, Object value) { this.name = name; this.value = value; } public Parameter(String name, long value) { this.name = name; this.value = value; } public String getName() { return name; } public Object getValue() { return value; } } "," package com.flickr4java.flickr;  /**
 * Class encapsulating a name/value parameter.
 * 
 * @author Anthony Eden
 */ public class Parameter {  private String name;  private Object value;  /**
     * Construct the Parameter.
     * 
     * @param name
     *            The parameter name
     * @param value
     *            The parameter value
     */ public Parameter(String name, Object value) { this.name = name; this.value = value; }  public Parameter(String name, long value) { this.name = name; this.value = value; }  public String getName() { return name; }  public Object getValue() { return value; }  }  "
src/main/java/com/flickr4java/flickr/ProxyAuthenticator.java,"package com.flickr4java.flickr;

import java.net.Authenticator;
import java.net.PasswordAuthentication;

/**
 * Used to set the credentials for proxy-authentication in {@link REST#setProxy(String, int, String, String)}.
 * 
 * @author mago
 * @version $Id: ProxyAuthenticator.java,v 1.1 2007/11/25 00:26:51 x-mago Exp $
 */
public class ProxyAuthenticator extends Authenticator {
    String userName = """";

    String passWord = """";

    public ProxyAuthenticator(String userName, String passWord) {
        this.userName = userName;
        this.passWord = passWord;
    }

    protected PasswordAuthentication getPasswordAuthentication() {
        return new PasswordAuthentication(userName, passWord.toCharArray());
    }
}
","package com.flickr4java.flickr; import java.net.Authenticator; import java.net.PasswordAuthentication; public class ProxyAuthenticator extends Authenticator { String userName = """"; String passWord = """"; public ProxyAuthenticator(String userName, String passWord) { this.userName = userName; this.passWord = passWord; } protected PasswordAuthentication getPasswordAuthentication() { return new PasswordAuthentication(userName, passWord.toCharArray()); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr; import java.net.Authenticator; import java.net.PasswordAuthentication; public class ProxyAuthenticator extends Authenticator { String userName = """"; String passWord = """"; public ProxyAuthenticator(String userName, String passWord) { this.userName = userName; this.passWord = passWord; } protected PasswordAuthentication getPasswordAuthentication() { return new PasswordAuthentication(userName, passWord.toCharArray()); } } ","package com.flickr4java.flickr;  import java.net.Authenticator; import java.net.PasswordAuthentication;  /**
 * Used to set the credentials for proxy-authentication in {@link REST#setProxy(String, int, String, String)}.
 * 
 * @author mago
 * @version $Id: ProxyAuthenticator.java,v 1.1 2007/11/25 00:26:51 x-mago Exp $
 */ public class ProxyAuthenticator extends Authenticator { String userName = """";  String passWord = """";  public ProxyAuthenticator(String userName, String passWord) { this.userName = userName; this.passWord = passWord; }  protected PasswordAuthentication getPasswordAuthentication() { return new PasswordAuthentication(userName, passWord.toCharArray()); } }  "
src/main/java/com/flickr4java/flickr/REST.java,"
package com.flickr4java.flickr;

import com.flickr4java.flickr.auth.Auth;
import com.flickr4java.flickr.uploader.Payload;
import com.flickr4java.flickr.uploader.UploadMetaData;
import com.flickr4java.flickr.util.DebugInputStream;
import com.flickr4java.flickr.util.IOUtilities;
import com.flickr4java.flickr.util.OAuthUtilities;
import com.flickr4java.flickr.util.UrlUtilities;
import com.github.scribejava.core.httpclient.multipart.FileByteArrayBodyPartPayload;
import com.github.scribejava.core.model.OAuth1AccessToken;
import com.github.scribejava.core.model.OAuthRequest;
import com.github.scribejava.core.model.Parameter;
import com.github.scribejava.core.model.Verb;
import com.github.scribejava.core.oauth.OAuth10aService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ExecutionException;

/**
 * Transport implementation using the REST interface.
 *
 * @author Anthony Eden
 * @version $Id: REST.java,v 1.26 2009/07/01 22:07:08 x-mago Exp $
 */
public class REST extends Transport {

    private static final Logger logger = LoggerFactory.getLogger(REST.class);

    private static final String PATH = ""/services/rest/"";

    /**
     * Error code from Flickr API when the service is unavailable.
     */
    private static final String FLICKR_SERVICE_UNAVAILABLE = ""105"";

    private boolean proxyAuth = false;

    private String proxyUser = """";

    private String proxyPassword = """";

    private String userAgent = ""Flickr4Java/3.x"";

    private Integer connectTimeoutMs;

    private Integer readTimeoutMs;

    /**
     * Construct a new REST transport instance.
     */
    public REST() {
        setTransportType(REST);
        setHost(API_HOST);
        setPath(PATH);
        setScheme(DEFAULT_SCHEME);
        setResponseClass(RESTResponse.class);
    }

    /**
     * Construct a new REST transport instance using the specified host endpoint.
     *
     * @param host The host endpoint
     */
    public REST(String host) {
        this();
        setHost(host);
    }

    /**
     * Construct a new REST transport instance using the specified host and port endpoint.
     *
     * @param host The host endpoint
     * @param port The port
     */
    public REST(String host, int port) {
        this();
        setHost(host);
        setPort(port);
    }

    /**
     * Set a proxy for REST-requests.
     *
     * @param proxyHost
     * @param proxyPort
     */
    public void setProxy(String proxyHost, int proxyPort) {
        System.setProperty(""http.proxySet"", ""true"");
        System.setProperty(""http.proxyHost"", proxyHost);
        System.setProperty(""http.proxyPort"", """" + proxyPort);
        System.setProperty(""https.proxyHost"", proxyHost);
        System.setProperty(""https.proxyPort"", """" + proxyPort);
    }

    /**
     * Set a proxy with authentication for REST-requests.
     *
     * @param proxyHost
     * @param proxyPort
     * @param username
     * @param password
     */
    public void setProxy(String proxyHost, int proxyPort, String username, String password) {
        setProxy(proxyHost, proxyPort);
        proxyAuth = true;
        proxyUser = username;
        proxyPassword = password;
    }

    /**
     * Override the default User-Agent header passed in requests to the Flickr API.
     * @param userAgent
     * @return
     */
    public REST setUserAgent(String userAgent) {
        this.userAgent = userAgent;
        return this;
    }

    /**
     * Invoke an HTTP GET request on a remote host. You must close the InputStream after you are done with.
     *
     * @param path       The request path
     * @param parameters The parameters (collection of Parameter objects)
     * @return The Response
     */
    @Override
    public com.flickr4java.flickr.Response get(String path, Map<String, Object> parameters, String apiKey, String sharedSecret) throws FlickrException {

        OAuthRequest request = new OAuthRequest(Verb.GET, buildUrl(path));
        for (Map.Entry<String, Object> entry : parameters.entrySet()) {
            request.addQuerystringParameter(entry.getKey(), String.valueOf(entry.getValue()));
        }

        if (proxyAuth) {
            request.addHeader(""Proxy-Authorization"", ""Basic "" + getProxyCredentials());
        }

        request.addHeader(""User-Agent"", userAgent);

        RequestContext requestContext = RequestContext.getRequestContext();
        Auth auth = requestContext.getAuth();
        OAuth10aService service = OAuthUtilities.createOAuthService(apiKey, sharedSecret, connectTimeoutMs, readTimeoutMs);
        if (auth != null) {
            OAuth1AccessToken requestToken = new OAuth1AccessToken(auth.getToken(), auth.getTokenSecret());
            service.signRequest(requestToken, request);
        } else {
            // For calls that do not require authorization e.g. flickr.people.findByUsername which could be the
            // first call if the user did not supply the user-id (i.e. nsid).
            if (!parameters.containsKey(Flickr.API_KEY)) {
                request.addQuerystringParameter(Flickr.API_KEY, apiKey);
            }
        }

        if (Flickr.debugRequest) {
            logger.debug(""GET: "" + request.getCompleteUrl());
        }

        try {
            return handleResponse(request, service);
        } catch (ReflectiveOperationException | SAXException | IOException | InterruptedException | ExecutionException | ParserConfigurationException e) {
            throw new FlickrRuntimeException(e);
        }
    }

    /**
     * Invoke an HTTP POST request on a remote host.
     *
     * @param path       The request path
     * @param parameters The parameters (collection of Parameter objects)
     * @return The Response object
     */
    @Override
    public com.flickr4java.flickr.Response post(String path, Map<String, Object> parameters, String apiKey, String sharedSecret) throws FlickrException {

        OAuthRequest request = OAuthUtilities.buildNormalPostRequest(parameters, buildUrl(path));

        request.addHeader(""User-Agent"", userAgent);

        OAuth10aService service = createAndSignRequest(apiKey, sharedSecret, request);

        try {
            return handleResponse(request, service);
        } catch (ReflectiveOperationException | InterruptedException | ExecutionException | IOException | SAXException | ParserConfigurationException e) {
            throw new FlickrRuntimeException(e);
        }
    }

    /**
     * Invoke an HTTP POST request on a remote host.
     *
     * @param path     The request path
     * @param metaData The parameters (collection of Parameter objects)
     * @param payload
     * @return The Response object
     */
    @Override
    public com.flickr4java.flickr.Response postMultiPart(String path, UploadMetaData metaData, Payload payload, String apiKey, String sharedSecret) throws FlickrException {

        Map<String, String> uploadParameters = new HashMap<>(metaData.getUploadParameters());
        OAuthRequest request = OAuthUtilities.buildMultipartRequest(uploadParameters, buildUrl(path));

        request.addHeader(""User-Agent"", userAgent);

        OAuth10aService service = createAndSignRequest(apiKey, sharedSecret, request);

        // Ensure all parameters (including oauth) are added to payload so signature matches
        uploadParameters.putAll(request.getOauthParameters());

        request.addBodyPartPayloadInMultipartPayload(new FileByteArrayBodyPartPayload(payload.getPayload(), ""photo"", metaData.getFilename()));
        uploadParameters.forEach((param, uploadPayload) -> request.addBodyPartPayloadInMultipartPayload(new FileByteArrayBodyPartPayload(uploadPayload.getBytes(), param)));

        try {
            return handleResponse(request, service);
        } catch (ReflectiveOperationException | InterruptedException | ExecutionException | IOException | SAXException | ParserConfigurationException e) {
            throw new FlickrRuntimeException(e);
        }
    }

    private OAuth10aService createAndSignRequest(String apiKey, String sharedSecret, OAuthRequest request) {
        OAuth10aService service = OAuthUtilities.createOAuthService(apiKey, sharedSecret, connectTimeoutMs, readTimeoutMs);
        OAuthUtilities.signRequest(service, request, proxyAuth ? getProxyCredentials() : null);
        return service;
    }

    private String buildUrl(String path) {
        return String.format(""%s://%s%s"", getScheme(), getHost(), path);
    }

    private Response handleResponse(OAuthRequest request, OAuth10aService service) throws InterruptedException, ExecutionException, IOException, SAXException, ParserConfigurationException, FlickrException, ReflectiveOperationException {
        com.github.scribejava.core.model.Response scribeResponse = service.execute(request);

        if (!scribeResponse.isSuccessful()) {
            throw new FlickrException(FLICKR_SERVICE_UNAVAILABLE, String.format(""Received '%s' error from Flickr with status %d"", scribeResponse.getMessage(), scribeResponse.getCode()));
        }
        String strXml = scribeResponse.getBody().trim();
        if (Flickr.debugStream) {
            logger.debug(strXml);
        }
        if (strXml.startsWith(""oauth_problem="")) {
            throw new FlickrRuntimeException(strXml);
        }

        DocumentBuilder builder = getDocumentBuilder();
        Document document = builder.parse(new InputSource(new StringReader(strXml)));
        Response f4jResponse = (Response) responseClass.getConstructor().newInstance();
        f4jResponse.parse(document);

        // Enable this method to update the test payloads
        // dumpResponseToFile(request, strXml);

        return f4jResponse;
    }

    /**
     * Invoke a non OAuth HTTP GET request on a remote host.
     * <p>
     * This is only used for the Flickr OAuth methods checkToken and getAccessToken.
     *
     * @param path       The request path
     * @param parameters The parameters
     * @return The Response
     */
    @Override
    public Response getNonOAuth(String path, Map<String, String> parameters) {
        InputStream in = null;
        try {
            URL url = UrlUtilities.buildUrl(getScheme(), getHost(), getPort(), path, parameters);
            if (Flickr.debugRequest) {
                logger.debug(""GET: "" + url);
            }
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod(""GET"");
            if (proxyAuth) {
                conn.setRequestProperty(""Proxy-Authorization"", ""Basic "" + getProxyCredentials());
            }

            conn.setRequestProperty(""User-Agent"", userAgent);

            setTimeouts(conn);
            conn.connect();

            if (Flickr.debugStream) {
                in = new DebugInputStream(conn.getInputStream(), System.out);
            } else {
                in = conn.getInputStream();
            }

            Response response;
            DocumentBuilder builder = getDocumentBuilder();
            Document document = builder.parse(in);
            response = (Response) responseClass.newInstance();
            response.parse(document);

            return response;
        } catch (IllegalAccessException | SAXException | IOException | InstantiationException | ParserConfigurationException e) {
            throw new FlickrRuntimeException(e);
        } finally {
            IOUtilities.close(in);
        }
    }

    public boolean isProxyAuth() {
        return proxyAuth;
    }

    /**
     * Generates Base64-encoded credentials from locally stored username and password.
     *
     * @return credentials
     */
    public String getProxyCredentials() {
        return new String(Base64.getEncoder().encode((proxyUser + "":"" + proxyPassword).getBytes()));
    }

    private void setTimeouts(HttpURLConnection conn) {
        if (connectTimeoutMs != null) {
            conn.setConnectTimeout(connectTimeoutMs);
        }
        if (readTimeoutMs != null) {
            conn.setReadTimeout(readTimeoutMs);
        }
    }

    public void setConnectTimeoutMs(Integer connectTimeoutMs) {
        this.connectTimeoutMs = connectTimeoutMs;
    }

    public void setReadTimeoutMs(Integer readTimeoutMs) {
        this.readTimeoutMs = readTimeoutMs;
    }

    private DocumentBuilder getDocumentBuilder() throws ParserConfigurationException {
        DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance();
        return builderFactory.newDocumentBuilder();
    }

    // Generate responses for offline tests

    private void dumpResponseToFile(OAuthRequest request, String strXml) throws IOException {
        Verb verb = request.getVerb();
        Optional<String> flickrMethod = Optional.empty();
        switch (verb) {
            case GET:
                flickrMethod = request.getQueryStringParams().getParams().stream().filter(param -> param.getKey().equals(""method"")).findFirst().map(Parameter::getValue);
                break;
            case POST:
                 flickrMethod = request.getBodyParams().getParams().stream().filter(param -> param.getKey().equals(""method"")).findFirst().map(Parameter::getValue);
                break;
        }
        if (flickrMethod.isPresent()) {
            String filename = String.format(""%s.xml"", flickrMethod.get());
            Path filePath = Paths.get(""src/test/resources/payloads/"" + verb, filename);
            Files.write(filePath, strXml.getBytes());
            logger.info(String.format(""Writing payload to file '%s'"", filePath));
        } else {
            logger.warn(""Not dumping response to file as method not found in request for URL {}"", request.getUrl());
        }
    }
}
","package com.flickr4java.flickr; public class REST extends Transport { private static final Logger logger = LoggerFactory.getLogger(REST.class); private static final String PATH = ""/services/rest/""; private static final String FLICKR_SERVICE_UNAVAILABLE = ""105""; private boolean proxyAuth = false; private String proxyUser = """"; private String proxyPassword = """"; private String userAgent = ""Flickr4Java/3.x""; private Integer connectTimeoutMs; private Integer readTimeoutMs; public REST() { setTransportType(REST); setHost(API_HOST); setPath(PATH); setScheme(DEFAULT_SCHEME); setResponseClass(RESTResponse.class); } public REST(String host) { this(); setHost(host); } public REST(String host, int port) { this(); setHost(host); setPort(port); } public void setProxy(String proxyHost, int proxyPort) { System.setProperty(""http.proxySet"", ""true""); System.setProperty(""http.proxyHost"", proxyHost); System.setProperty(""http.proxyPort"", """" + proxyPort); System.setProperty(""https.proxyHost"", proxyHost); System.setProperty(""https.proxyPort"", """" + proxyPort); } public void setProxy(String proxyHost, int proxyPort, String username, String password) { setProxy(proxyHost, proxyPort); proxyAuth = true; proxyUser = username; proxyPassword = password; } public REST setUserAgent(String userAgent) { this.userAgent = userAgent; return this; } @Override
    public com.flickr4java.flickr.Response get(String path, Map<String, Object> parameters, String apiKey, String sharedSecret) throws FlickrException { OAuthRequest request = new OAuthRequest(Verb.GET, buildUrl(path)); for (Map.Entry<String, Object> entry : parameters.entrySet()) { request.addQuerystringParameter(entry.getKey(), String.valueOf(entry.getValue())); } if (proxyAuth) { request.addHeader(""Proxy-Authorization"", ""Basic "" + getProxyCredentials()); } request.addHeader(""User-Agent"", userAgent); RequestContext requestContext = RequestContext.getRequestContext(); Auth auth = requestContext.getAuth(); OAuth10aService service = OAuthUtilities.createOAuthService(apiKey, sharedSecret, connectTimeoutMs, readTimeoutMs); if (auth != null) { OAuth1AccessToken requestToken = new OAuth1AccessToken(auth.getToken(), auth.getTokenSecret()); service.signRequest(requestToken, request); } else { if (!parameters.containsKey(Flickr.API_KEY)) { request.addQuerystringParameter(Flickr.API_KEY, apiKey); } } if (Flickr.debugRequest) { } try { return handleResponse(request, service); } catch (ReflectiveOperationException | SAXException | IOException | InterruptedException | ExecutionException | ParserConfigurationException e) { throw new FlickrRuntimeException(e); } } @Override
    public com.flickr4java.flickr.Response post(String path, Map<String, Object> parameters, String apiKey, String sharedSecret) throws FlickrException { OAuthRequest request = OAuthUtilities.buildNormalPostRequest(parameters, buildUrl(path)); request.addHeader(""User-Agent"", userAgent); OAuth10aService service = createAndSignRequest(apiKey, sharedSecret, request); try { return handleResponse(request, service); } catch (ReflectiveOperationException | InterruptedException | ExecutionException | IOException | SAXException | ParserConfigurationException e) { throw new FlickrRuntimeException(e); } } @Override
    public com.flickr4java.flickr.Response postMultiPart(String path, UploadMetaData metaData, Payload payload, String apiKey, String sharedSecret) throws FlickrException { Map<String, String> uploadParameters = new HashMap<>(metaData.getUploadParameters()); OAuthRequest request = OAuthUtilities.buildMultipartRequest(uploadParameters, buildUrl(path)); request.addHeader(""User-Agent"", userAgent); OAuth10aService service = createAndSignRequest(apiKey, sharedSecret, request); uploadParameters.putAll(request.getOauthParameters()); request.addBodyPartPayloadInMultipartPayload(new FileByteArrayBodyPartPayload(payload.getPayload(), ""photo"", metaData.getFilename())); uploadParameters.forEach((param, uploadPayload) -> request.addBodyPartPayloadInMultipartPayload(new FileByteArrayBodyPartPayload(uploadPayload.getBytes(), param))); try { return handleResponse(request, service); } catch (ReflectiveOperationException | InterruptedException | ExecutionException | IOException | SAXException | ParserConfigurationException e) { throw new FlickrRuntimeException(e); } } private OAuth10aService createAndSignRequest(String apiKey, String sharedSecret, OAuthRequest request) { OAuth10aService service = OAuthUtilities.createOAuthService(apiKey, sharedSecret, connectTimeoutMs, readTimeoutMs); OAuthUtilities.signRequest(service, request, proxyAuth ? getProxyCredentials() : null); return service; } private String buildUrl(String path) { } private Response handleResponse(OAuthRequest request, OAuth10aService service) throws InterruptedException, ExecutionException, IOException, SAXException, ParserConfigurationException, FlickrException, ReflectiveOperationException { com.github.scribejava.core.model.Response scribeResponse = service.execute(request); if (!scribeResponse.isSuccessful()) { throw new FlickrException(FLICKR_SERVICE_UNAVAILABLE, String.format(""Received '%s' error from Flickr with status %d"", scribeResponse.getMessage(), scribeResponse.getCode())); } String strXml = scribeResponse.getBody().trim(); if (Flickr.debugStream) { } if (strXml.startsWith(""oauth_problem="")) { throw new FlickrRuntimeException(strXml); } DocumentBuilder builder = getDocumentBuilder(); Document document = builder.parse(new InputSource(new StringReader(strXml))); Response f4jResponse = (Response) responseClass.getConstructor().newInstance(); f4jResponse.parse(document); return f4jResponse; } @Override
    public Response getNonOAuth(String path, Map<String, String> parameters) { InputStream in = null; try { URL url = UrlUtilities.buildUrl(getScheme(), getHost(), getPort(), path, parameters); if (Flickr.debugRequest) { } HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(""GET""); if (proxyAuth) { conn.setRequestProperty(""Proxy-Authorization"", ""Basic "" + getProxyCredentials()); } conn.setRequestProperty(""User-Agent"", userAgent); setTimeouts(conn); conn.connect(); if (Flickr.debugStream) { in = new DebugInputStream(conn.getInputStream(), System.out); } else { in = conn.getInputStream(); } Response response; DocumentBuilder builder = getDocumentBuilder(); Document document = builder.parse(in); response = (Response) responseClass.newInstance(); response.parse(document); return response; } catch (IllegalAccessException | SAXException | IOException | InstantiationException | ParserConfigurationException e) { throw new FlickrRuntimeException(e); } finally { IOUtilities.close(in); } } public boolean isProxyAuth() { return proxyAuth; } public String getProxyCredentials() { return new String(Base64.getEncoder().encode((proxyUser + "":"" + proxyPassword).getBytes())); } private void setTimeouts(HttpURLConnection conn) { if (connectTimeoutMs != null) { conn.setConnectTimeout(connectTimeoutMs); } if (readTimeoutMs != null) { conn.setReadTimeout(readTimeoutMs); } } public void setConnectTimeoutMs(Integer connectTimeoutMs) { this.connectTimeoutMs = connectTimeoutMs; } public void setReadTimeoutMs(Integer readTimeoutMs) { this.readTimeoutMs = readTimeoutMs; } private DocumentBuilder getDocumentBuilder() throws ParserConfigurationException { DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance(); return builderFactory.newDocumentBuilder(); } private void dumpResponseToFile(OAuthRequest request, String strXml) throws IOException { Verb verb = request.getVerb(); Optional<String> flickrMethod = Optional.empty(); switch (verb) { case GET:
                flickrMethod = request.getQueryStringParams().getParams().stream().filter(param -> param.getKey().equals(""method"")).findFirst().map(Parameter::getValue); break; case POST:
                 flickrMethod = request.getBodyParams().getParams().stream().filter(param -> param.getKey().equals(""method"")).findFirst().map(Parameter::getValue); break; } if (flickrMethod.isPresent()) { String filename = String.format(""%s.xml"", flickrMethod.get()); Path filePath = Paths.get(""src/test/resources/payloads/"" + verb, filename); Files.write(filePath, strXml.getBytes()); } else { logger.warn(""Not dumping response to file as method not found in request for URL { } "", request.getUrl()); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr; public class REST extends Transport { private static final Logger logger = LoggerFactory.getLogger(REST.class); private static final String PATH = ""/services/rest/""; private static final String FLICKR_SERVICE_UNAVAILABLE = ""105""; private boolean proxyAuth = false; private String proxyUser = """"; private String proxyPassword = """"; private String userAgent = ""Flickr4Java/3.x""; private Integer connectTimeoutMs; private Integer readTimeoutMs; public REST() { setTransportType(REST); setHost(API_HOST); setPath(PATH); setScheme(DEFAULT_SCHEME); setResponseClass(RESTResponse.class); } public REST(String host) { this(); setHost(host); } public REST(String host, int port) { this(); setHost(host); setPort(port); } public void setProxy(String proxyHost, int proxyPort) { System.setProperty(""http.proxySet"", ""true""); System.setProperty(""http.proxyHost"", proxyHost); System.setProperty(""http.proxyPort"", """" + proxyPort); System.setProperty(""https.proxyHost"", proxyHost); System.setProperty(""https.proxyPort"", """" + proxyPort); } public void setProxy(String proxyHost, int proxyPort, String username, String password) { setProxy(proxyHost, proxyPort); proxyAuth = true; proxyUser = username; proxyPassword = password; } public REST setUserAgent(String userAgent) { this.userAgent = userAgent; return this; } @Override
    public com.flickr4java.flickr.Response get(String path, Map<String, Object> parameters, String apiKey, String sharedSecret) throws FlickrException { OAuthRequest request = new OAuthRequest(Verb.GET, buildUrl(path)); for (Map.Entry<String, Object> entry : parameters.entrySet()) { request.addQuerystringParameter(entry.getKey(), String.valueOf(entry.getValue())); } if (proxyAuth) { request.addHeader(""Proxy-Authorization"", ""Basic "" + getProxyCredentials()); } request.addHeader(""User-Agent"", userAgent); RequestContext requestContext = RequestContext.getRequestContext(); Auth auth = requestContext.getAuth(); OAuth10aService service = OAuthUtilities.createOAuthService(apiKey, sharedSecret, connectTimeoutMs, readTimeoutMs); if (auth != null) { OAuth1AccessToken requestToken = new OAuth1AccessToken(auth.getToken(), auth.getTokenSecret()); service.signRequest(requestToken, request); } else { if (!parameters.containsKey(Flickr.API_KEY)) { request.addQuerystringParameter(Flickr.API_KEY, apiKey); } } if (Flickr.debugRequest) { <FILL_ME> <FILL_ME> } try { return handleResponse(request, service); } catch (ReflectiveOperationException | SAXException | IOException | InterruptedException | ExecutionException | ParserConfigurationException e) { throw new FlickrRuntimeException(e); } } @Override
    public com.flickr4java.flickr.Response post(String path, Map<String, Object> parameters, String apiKey, String sharedSecret) throws FlickrException { OAuthRequest request = OAuthUtilities.buildNormalPostRequest(parameters, buildUrl(path)); request.addHeader(""User-Agent"", userAgent); OAuth10aService service = createAndSignRequest(apiKey, sharedSecret, request); try { return handleResponse(request, service); } catch (ReflectiveOperationException | InterruptedException | ExecutionException | IOException | SAXException | ParserConfigurationException e) { throw new FlickrRuntimeException(e); } } @Override
    public com.flickr4java.flickr.Response postMultiPart(String path, UploadMetaData metaData, Payload payload, String apiKey, String sharedSecret) throws FlickrException { Map<String, String> uploadParameters = new HashMap<>(metaData.getUploadParameters()); OAuthRequest request = OAuthUtilities.buildMultipartRequest(uploadParameters, buildUrl(path)); request.addHeader(""User-Agent"", userAgent); OAuth10aService service = createAndSignRequest(apiKey, sharedSecret, request); uploadParameters.putAll(request.getOauthParameters()); request.addBodyPartPayloadInMultipartPayload(new FileByteArrayBodyPartPayload(payload.getPayload(), ""photo"", metaData.getFilename())); uploadParameters.forEach((param, uploadPayload) -> request.addBodyPartPayloadInMultipartPayload(new FileByteArrayBodyPartPayload(uploadPayload.getBytes(), param))); try { return handleResponse(request, service); } catch (ReflectiveOperationException | InterruptedException | ExecutionException | IOException | SAXException | ParserConfigurationException e) { throw new FlickrRuntimeException(e); } } private OAuth10aService createAndSignRequest(String apiKey, String sharedSecret, OAuthRequest request) { OAuth10aService service = OAuthUtilities.createOAuthService(apiKey, sharedSecret, connectTimeoutMs, readTimeoutMs); OAuthUtilities.signRequest(service, request, proxyAuth ? getProxyCredentials() : null); return service; } private String buildUrl(String path) { } private Response handleResponse(OAuthRequest request, OAuth10aService service) throws InterruptedException, ExecutionException, IOException, SAXException, ParserConfigurationException, FlickrException, ReflectiveOperationException { com.github.scribejava.core.model.Response scribeResponse = service.execute(request); if (!scribeResponse.isSuccessful()) { throw new FlickrException(FLICKR_SERVICE_UNAVAILABLE, String.format(""Received '%s' error from Flickr with status %d"", scribeResponse.getMessage(), scribeResponse.getCode())); } String strXml = scribeResponse.getBody().trim(); if (Flickr.debugStream) { <FILL_ME> } if (strXml.startsWith(""oauth_problem="")) { throw new FlickrRuntimeException(strXml); } DocumentBuilder builder = getDocumentBuilder(); Document document = builder.parse(new InputSource(new StringReader(strXml))); Response f4jResponse = (Response) responseClass.getConstructor().newInstance(); f4jResponse.parse(document); return f4jResponse; } @Override
    public Response getNonOAuth(String path, Map<String, String> parameters) { InputStream in = null; try { URL url = UrlUtilities.buildUrl(getScheme(), getHost(), getPort(), path, parameters); if (Flickr.debugRequest) { } HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(""GET""); if (proxyAuth) { conn.setRequestProperty(""Proxy-Authorization"", ""Basic "" + getProxyCredentials()); } conn.setRequestProperty(""User-Agent"", userAgent); setTimeouts(conn); conn.connect(); if (Flickr.debugStream) { in = new DebugInputStream(conn.getInputStream(), System.out); } else { in = conn.getInputStream(); } Response response; DocumentBuilder builder = getDocumentBuilder(); Document document = builder.parse(in); response = (Response) responseClass.newInstance(); response.parse(document); return response; } catch (IllegalAccessException | SAXException | IOException | InstantiationException | ParserConfigurationException e) { throw new FlickrRuntimeException(e); } finally { IOUtilities.close(in); } } public boolean isProxyAuth() { return proxyAuth; } public String getProxyCredentials() { return new String(Base64.getEncoder().encode((proxyUser + "":"" + proxyPassword).getBytes())); } private void setTimeouts(HttpURLConnection conn) { if (connectTimeoutMs != null) { conn.setConnectTimeout(connectTimeoutMs); } if (readTimeoutMs != null) { conn.setReadTimeout(readTimeoutMs); } } public void setConnectTimeoutMs(Integer connectTimeoutMs) { this.connectTimeoutMs = connectTimeoutMs; } public void setReadTimeoutMs(Integer readTimeoutMs) { this.readTimeoutMs = readTimeoutMs; } private DocumentBuilder getDocumentBuilder() throws ParserConfigurationException { DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance(); return builderFactory.newDocumentBuilder(); } private void dumpResponseToFile(OAuthRequest request, String strXml) throws IOException { Verb verb = request.getVerb(); Optional<String> flickrMethod = Optional.empty(); switch (verb) { case GET:
                flickrMethod = request.getQueryStringParams().getParams().stream().filter(param -> param.getKey().equals(""method"")).findFirst().map(Parameter::getValue); break; case POST:
                 flickrMethod = request.getBodyParams().getParams().stream().filter(param -> param.getKey().equals(""method"")).findFirst().map(Parameter::getValue); break; } if (flickrMethod.isPresent()) { String filename = String.format(""%s.xml"", flickrMethod.get()); Path filePath = Paths.get(""src/test/resources/payloads/"" + verb, filename); Files.write(filePath, strXml.getBytes()); <FILL_ME> } else { logger.warn(""Not dumping response to file as method not found in request for URL { } "", request.getUrl()); } } } "," package com.flickr4java.flickr; 
import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.uploader.Payload; import com.flickr4java.flickr.uploader.UploadMetaData; import com.flickr4java.flickr.util.DebugInputStream; import com.flickr4java.flickr.util.IOUtilities; import com.flickr4java.flickr.util.OAuthUtilities; import com.flickr4java.flickr.util.UrlUtilities; import com.github.scribejava.core.httpclient.multipart.FileByteArrayBodyPartPayload; import com.github.scribejava.core.model.OAuth1AccessToken; import com.github.scribejava.core.model.OAuthRequest; import com.github.scribejava.core.model.Parameter; import com.github.scribejava.core.model.Verb; import com.github.scribejava.core.oauth.OAuth10aService; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.w3c.dom.Document; import org.xml.sax.InputSource; import org.xml.sax.SAXException; 
import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import java.io.IOException; import java.io.InputStream; import java.io.StringReader; import java.net.HttpURLConnection; import java.net.URL; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.util.Base64; import java.util.HashMap; import java.util.Map; import java.util.Optional; import java.util.concurrent.ExecutionException;  /**
 * Transport implementation using the REST interface.
 *
 * @author Anthony Eden
 * @version $Id: REST.java,v 1.26 2009/07/01 22:07:08 x-mago Exp $
 */ public class REST extends Transport {  private static final Logger logger = LoggerFactory.getLogger(REST.class);  private static final String PATH = ""/services/rest/"";  /**
     * Error code from Flickr API when the service is unavailable.
     */ private static final String FLICKR_SERVICE_UNAVAILABLE = ""105"";  private boolean proxyAuth = false;  private String proxyUser = """";  private String proxyPassword = """";  private String userAgent = ""Flickr4Java/3.x"";  private Integer connectTimeoutMs;  private Integer readTimeoutMs;  /**
     * Construct a new REST transport instance.
     */ public REST() { setTransportType(REST); setHost(API_HOST); setPath(PATH); setScheme(DEFAULT_SCHEME); setResponseClass(RESTResponse.class); }  /**
     * Construct a new REST transport instance using the specified host endpoint.
     *
     * @param host The host endpoint
     */ public REST(String host) { this(); setHost(host); }  /**
     * Construct a new REST transport instance using the specified host and port endpoint.
     *
     * @param host The host endpoint
     * @param port The port
     */ public REST(String host, int port) { this(); setHost(host); setPort(port); }  /**
     * Set a proxy for REST-requests.
     *
     * @param proxyHost
     * @param proxyPort
     */ public void setProxy(String proxyHost, int proxyPort) { System.setProperty(""http.proxySet"", ""true""); System.setProperty(""http.proxyHost"", proxyHost); System.setProperty(""http.proxyPort"", """" + proxyPort); System.setProperty(""https.proxyHost"", proxyHost); System.setProperty(""https.proxyPort"", """" + proxyPort); }  /**
     * Set a proxy with authentication for REST-requests.
     *
     * @param proxyHost
     * @param proxyPort
     * @param username
     * @param password
     */ public void setProxy(String proxyHost, int proxyPort, String username, String password) { setProxy(proxyHost, proxyPort); proxyAuth = true; proxyUser = username; proxyPassword = password; }  /**
     * Override the default User-Agent header passed in requests to the Flickr API.
     * @param userAgent
     * @return
     */ public REST setUserAgent(String userAgent) { this.userAgent = userAgent; return this; }  /**
     * Invoke an HTTP GET request on a remote host. You must close the InputStream after you are done with.
     *
     * @param path       The request path
     * @param parameters The parameters (collection of Parameter objects)
     * @return The Response
     */ @Override
    public com.flickr4java.flickr.Response get(String path, Map<String, Object> parameters, String apiKey, String sharedSecret) throws FlickrException {  OAuthRequest request = new OAuthRequest(Verb.GET, buildUrl(path)); for (Map.Entry<String, Object> entry : parameters.entrySet()) { request.addQuerystringParameter(entry.getKey(), String.valueOf(entry.getValue())); }  if (proxyAuth) { request.addHeader(""Proxy-Authorization"", ""Basic "" + getProxyCredentials()); }  request.addHeader(""User-Agent"", userAgent);  RequestContext requestContext = RequestContext.getRequestContext(); Auth auth = requestContext.getAuth(); OAuth10aService service = OAuthUtilities.createOAuthService(apiKey, sharedSecret, connectTimeoutMs, readTimeoutMs); if (auth != null) { OAuth1AccessToken requestToken = new OAuth1AccessToken(auth.getToken(), auth.getTokenSecret()); service.signRequest(requestToken, request); } else { // For calls that do not require authorization e.g. flickr.people.findByUsername which could be the // first call if the user did not supply the user-id (i.e. nsid). if (!parameters.containsKey(Flickr.API_KEY)) { request.addQuerystringParameter(Flickr.API_KEY, apiKey); } }  if (Flickr.debugRequest) { <FILL_ME> <FILL_ME> }  try { return handleResponse(request, service); } catch (ReflectiveOperationException | SAXException | IOException | InterruptedException | ExecutionException | ParserConfigurationException e) { throw new FlickrRuntimeException(e); } }  /**
     * Invoke an HTTP POST request on a remote host.
     *
     * @param path       The request path
     * @param parameters The parameters (collection of Parameter objects)
     * @return The Response object
     */ @Override
    public com.flickr4java.flickr.Response post(String path, Map<String, Object> parameters, String apiKey, String sharedSecret) throws FlickrException {  OAuthRequest request = OAuthUtilities.buildNormalPostRequest(parameters, buildUrl(path));  request.addHeader(""User-Agent"", userAgent);  OAuth10aService service = createAndSignRequest(apiKey, sharedSecret, request);  try { return handleResponse(request, service); } catch (ReflectiveOperationException | InterruptedException | ExecutionException | IOException | SAXException | ParserConfigurationException e) { throw new FlickrRuntimeException(e); } }  /**
     * Invoke an HTTP POST request on a remote host.
     *
     * @param path     The request path
     * @param metaData The parameters (collection of Parameter objects)
     * @param payload
     * @return The Response object
     */ @Override
    public com.flickr4java.flickr.Response postMultiPart(String path, UploadMetaData metaData, Payload payload, String apiKey, String sharedSecret) throws FlickrException {  Map<String, String> uploadParameters = new HashMap<>(metaData.getUploadParameters()); OAuthRequest request = OAuthUtilities.buildMultipartRequest(uploadParameters, buildUrl(path));  request.addHeader(""User-Agent"", userAgent);  OAuth10aService service = createAndSignRequest(apiKey, sharedSecret, request);  // Ensure all parameters (including oauth) are added to payload so signature matches uploadParameters.putAll(request.getOauthParameters());  request.addBodyPartPayloadInMultipartPayload(new FileByteArrayBodyPartPayload(payload.getPayload(), ""photo"", metaData.getFilename())); uploadParameters.forEach((param, uploadPayload) -> request.addBodyPartPayloadInMultipartPayload(new FileByteArrayBodyPartPayload(uploadPayload.getBytes(), param)));  try { return handleResponse(request, service); } catch (ReflectiveOperationException | InterruptedException | ExecutionException | IOException | SAXException | ParserConfigurationException e) { throw new FlickrRuntimeException(e); } }  private OAuth10aService createAndSignRequest(String apiKey, String sharedSecret, OAuthRequest request) { OAuth10aService service = OAuthUtilities.createOAuthService(apiKey, sharedSecret, connectTimeoutMs, readTimeoutMs); OAuthUtilities.signRequest(service, request, proxyAuth ? getProxyCredentials() : null); return service; }  private String buildUrl(String path) { //%s%s"", getScheme(), getHost(), path); }  private Response handleResponse(OAuthRequest request, OAuth10aService service) throws InterruptedException, ExecutionException, IOException, SAXException, ParserConfigurationException, FlickrException, ReflectiveOperationException { com.github.scribejava.core.model.Response scribeResponse = service.execute(request);  if (!scribeResponse.isSuccessful()) { throw new FlickrException(FLICKR_SERVICE_UNAVAILABLE, String.format(""Received '%s' error from Flickr with status %d"", scribeResponse.getMessage(), scribeResponse.getCode())); } String strXml = scribeResponse.getBody().trim(); if (Flickr.debugStream) { <FILL_ME> } if (strXml.startsWith(""oauth_problem="")) { throw new FlickrRuntimeException(strXml); }  DocumentBuilder builder = getDocumentBuilder(); Document document = builder.parse(new InputSource(new StringReader(strXml))); Response f4jResponse = (Response) responseClass.getConstructor().newInstance(); f4jResponse.parse(document);  // Enable this method to update the test payloads // dumpResponseToFile(request, strXml);  return f4jResponse; }  /**
     * Invoke a non OAuth HTTP GET request on a remote host.
     * <p>
     * This is only used for the Flickr OAuth methods checkToken and getAccessToken.
     *
     * @param path       The request path
     * @param parameters The parameters
     * @return The Response
     */ @Override
    public Response getNonOAuth(String path, Map<String, String> parameters) { InputStream in = null; try { URL url = UrlUtilities.buildUrl(getScheme(), getHost(), getPort(), path, parameters); if (Flickr.debugRequest) { } HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(""GET""); if (proxyAuth) { conn.setRequestProperty(""Proxy-Authorization"", ""Basic "" + getProxyCredentials()); }  conn.setRequestProperty(""User-Agent"", userAgent);  setTimeouts(conn); conn.connect();  if (Flickr.debugStream) { in = new DebugInputStream(conn.getInputStream(), System.out); } else { in = conn.getInputStream(); }  Response response; DocumentBuilder builder = getDocumentBuilder(); Document document = builder.parse(in); response = (Response) responseClass.newInstance(); response.parse(document);  return response; } catch (IllegalAccessException | SAXException | IOException | InstantiationException | ParserConfigurationException e) { throw new FlickrRuntimeException(e); } finally { IOUtilities.close(in); } }  public boolean isProxyAuth() { return proxyAuth; }  /**
     * Generates Base64-encoded credentials from locally stored username and password.
     *
     * @return credentials
     */ public String getProxyCredentials() { return new String(Base64.getEncoder().encode((proxyUser + "":"" + proxyPassword).getBytes())); }  private void setTimeouts(HttpURLConnection conn) { if (connectTimeoutMs != null) { conn.setConnectTimeout(connectTimeoutMs); } if (readTimeoutMs != null) { conn.setReadTimeout(readTimeoutMs); } }  public void setConnectTimeoutMs(Integer connectTimeoutMs) { this.connectTimeoutMs = connectTimeoutMs; }  public void setReadTimeoutMs(Integer readTimeoutMs) { this.readTimeoutMs = readTimeoutMs; }  private DocumentBuilder getDocumentBuilder() throws ParserConfigurationException { DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance(); return builderFactory.newDocumentBuilder(); }  // Generate responses for offline tests  private void dumpResponseToFile(OAuthRequest request, String strXml) throws IOException { Verb verb = request.getVerb(); Optional<String> flickrMethod = Optional.empty(); switch (verb) { case GET:
                flickrMethod = request.getQueryStringParams().getParams().stream().filter(param -> param.getKey().equals(""method"")).findFirst().map(Parameter::getValue); break; case POST:
                 flickrMethod = request.getBodyParams().getParams().stream().filter(param -> param.getKey().equals(""method"")).findFirst().map(Parameter::getValue); break; } if (flickrMethod.isPresent()) { String filename = String.format(""%s.xml"", flickrMethod.get()); Path filePath = Paths.get(""src/test/resources/payloads/"" + verb, filename); Files.write(filePath, strXml.getBytes()); <FILL_ME> } else { logger.warn(""Not dumping response to file as method not found in request for URL { } "", request.getUrl()); } } }  "
src/main/java/com/flickr4java/flickr/RESTResponse.java,"
package com.flickr4java.flickr;

import com.flickr4java.flickr.util.XMLUtilities;

import org.w3c.dom.Document;
import org.w3c.dom.Element;

import java.util.Collection;
import java.util.List;

/**
 * Flickr Response object.
 * 
 * @author Anthony Eden
 */
public class RESTResponse implements Response {

    private String stat;

    private List<Element> payload;

    private String errorCode;

    private String errorMessage;

    public void parse(Document document) {
        Element rspElement = document.getDocumentElement();
        rspElement.normalize();
        stat = rspElement.getAttribute(""stat"");
        if (""ok"".equals(stat)) {
            // TODO: Verify that the payload is always a single XML node
            payload = (List<Element>) XMLUtilities.getChildElements(rspElement);
        } else if (""fail"".equals(stat)) {
            Element errElement = (Element) rspElement.getElementsByTagName(""err"").item(0);
            errorCode = errElement.getAttribute(""code"");
            errorMessage = errElement.getAttribute(""msg"");
        }
    }

    public String getStat() {
        return stat;
    }

    public Element getPayload() {
        if (payload.isEmpty()) {
            throw new RuntimeException(""REST response payload has no elements"");
        }
        return payload.get(0);
    }

    public Collection<Element> getPayloadCollection() {
        return payload;
    }

    public boolean isError() {
        return errorCode != null;
    }

    public String getErrorCode() {
        return errorCode;
    }

    public String getErrorMessage() {
        return errorMessage;
    }

}
","package com.flickr4java.flickr; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Document; import org.w3c.dom.Element; import java.util.Collection; import java.util.List; public class RESTResponse implements Response { private String stat; private List<Element> payload; private String errorCode; private String errorMessage; public void parse(Document document) { Element rspElement = document.getDocumentElement(); rspElement.normalize(); stat = rspElement.getAttribute(""stat""); if (""ok"".equals(stat)) { payload = (List<Element>) XMLUtilities.getChildElements(rspElement); } else if (""fail"".equals(stat)) { Element errElement = (Element) rspElement.getElementsByTagName(""err"").item(0); errorCode = errElement.getAttribute(""code""); errorMessage = errElement.getAttribute(""msg""); } } public String getStat() { return stat; } public Element getPayload() { if (payload.isEmpty()) { throw new RuntimeException(""REST response payload has no elements""); } return payload.get(0); } public Collection<Element> getPayloadCollection() { return payload; } public boolean isError() { return errorCode != null; } public String getErrorCode() { return errorCode; } public String getErrorMessage() { return errorMessage; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Document; import org.w3c.dom.Element; import java.util.Collection; import java.util.List; public class RESTResponse implements Response { private String stat; private List<Element> payload; private String errorCode; private String errorMessage; public void parse(Document document) { Element rspElement = document.getDocumentElement(); rspElement.normalize(); stat = rspElement.getAttribute(""stat""); if (""ok"".equals(stat)) { payload = (List<Element>) XMLUtilities.getChildElements(rspElement); } else if (""fail"".equals(stat)) { Element errElement = (Element) rspElement.getElementsByTagName(""err"").item(0); errorCode = errElement.getAttribute(""code""); errorMessage = errElement.getAttribute(""msg""); } } public String getStat() { return stat; } public Element getPayload() { if (payload.isEmpty()) { throw new RuntimeException(""REST response payload has no elements""); } return payload.get(0); } public Collection<Element> getPayloadCollection() { return payload; } public boolean isError() { return errorCode != null; } public String getErrorCode() { return errorCode; } public String getErrorMessage() { return errorMessage; } } "," package com.flickr4java.flickr;  import com.flickr4java.flickr.util.XMLUtilities;  import org.w3c.dom.Document; import org.w3c.dom.Element;  import java.util.Collection; import java.util.List;  /**
 * Flickr Response object.
 * 
 * @author Anthony Eden
 */ public class RESTResponse implements Response {  private String stat;  private List<Element> payload;  private String errorCode;  private String errorMessage;  public void parse(Document document) { Element rspElement = document.getDocumentElement(); rspElement.normalize(); stat = rspElement.getAttribute(""stat""); if (""ok"".equals(stat)) { // TODO: Verify that the payload is always a single XML node payload = (List<Element>) XMLUtilities.getChildElements(rspElement); } else if (""fail"".equals(stat)) { Element errElement = (Element) rspElement.getElementsByTagName(""err"").item(0); errorCode = errElement.getAttribute(""code""); errorMessage = errElement.getAttribute(""msg""); } }  public String getStat() { return stat; }  public Element getPayload() { if (payload.isEmpty()) { throw new RuntimeException(""REST response payload has no elements""); } return payload.get(0); }  public Collection<Element> getPayloadCollection() { return payload; }  public boolean isError() { return errorCode != null; }  public String getErrorCode() { return errorCode; }  public String getErrorMessage() { return errorMessage; }  }  "
src/main/java/com/flickr4java/flickr/RequestContext.java,"

package com.flickr4java.flickr;

import com.flickr4java.flickr.auth.Auth;

import java.util.ArrayList;
import java.util.List;

/**
 * A thread local variable used to hold contextual information used in requests. To get an instance of this class use RequestContext.getRequestContext(). The
 * method will return a RequestContext object which is only usable within the current thread.
 * 
 * @author Anthony Eden
 */
public class RequestContext {

    private static RequestContextThreadLocal threadLocal = new RequestContextThreadLocal();

    private Auth auth;

    private String sharedSecret;

    private List<String> extras;

    /**
     * Get the RequestContext instance for the current Thread.
     * 
     * @return The RequestContext
     */
    public static RequestContext getRequestContext() {
        return threadLocal.get();
    }

    public Auth getAuth() {
        return auth;
    }

    public void setAuth(Auth auth) {
        this.auth = auth;
    }

    /**
     * Get a shared secret which is used for any calls which require signing.
     * 
     * @deprecated Get the secret from {@link Flickr#getSharedSecret()}.
     * @return The shared secret
     */
    @Deprecated
    public String getSharedSecret() {
        return sharedSecret;
    }

    /**
     * Set the shared secret which is used for any calls which require signing.
     * 
     * @deprecated Set the secret in {@link Flickr#setSharedSecret(String)}.
     * @param sharedSecret
     *            The shared secret
     */
    @Deprecated
    public void setSharedSecret(String sharedSecret) {
        this.sharedSecret = sharedSecret;
    }

    /**
     * Get the List of extra return values requested.
     * 
     * @return List of extra return values requested
     */
    public List<String> getExtras() {
        if (extras == null) {
            extras = new ArrayList<String>();
        }
        return extras;
    }

    public void setExtras(List<String> extras) {
        this.extras = extras;
    }

    private static class RequestContextThreadLocal extends ThreadLocal<RequestContext> {

        @Override
        protected RequestContext initialValue() {
            return new RequestContext();
        }

    }

}
","package com.flickr4java.flickr; import com.flickr4java.flickr.auth.Auth; import java.util.ArrayList; import java.util.List; public class RequestContext { private static RequestContextThreadLocal threadLocal = new RequestContextThreadLocal(); private Auth auth; private String sharedSecret; private List<String> extras; public static RequestContext getRequestContext() { return threadLocal.get(); } public Auth getAuth() { return auth; } public void setAuth(Auth auth) { this.auth = auth; } @Deprecated
    public String getSharedSecret() { return sharedSecret; } @Deprecated
    public void setSharedSecret(String sharedSecret) { this.sharedSecret = sharedSecret; } public List<String> getExtras() { if (extras == null) { extras = new ArrayList<String>(); } return extras; } public void setExtras(List<String> extras) { this.extras = extras; } private static class RequestContextThreadLocal extends ThreadLocal<RequestContext> { @Override
        protected RequestContext initialValue() { return new RequestContext(); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr; import com.flickr4java.flickr.auth.Auth; import java.util.ArrayList; import java.util.List; public class RequestContext { private static RequestContextThreadLocal threadLocal = new RequestContextThreadLocal(); private Auth auth; private String sharedSecret; private List<String> extras; public static RequestContext getRequestContext() { return threadLocal.get(); } public Auth getAuth() { return auth; } public void setAuth(Auth auth) { this.auth = auth; } @Deprecated
    public String getSharedSecret() { return sharedSecret; } @Deprecated
    public void setSharedSecret(String sharedSecret) { this.sharedSecret = sharedSecret; } public List<String> getExtras() { if (extras == null) { extras = new ArrayList<String>(); } return extras; } public void setExtras(List<String> extras) { this.extras = extras; } private static class RequestContextThreadLocal extends ThreadLocal<RequestContext> { @Override
        protected RequestContext initialValue() { return new RequestContext(); } } } ","
 package com.flickr4java.flickr;  import com.flickr4java.flickr.auth.Auth;  import java.util.ArrayList; import java.util.List;  /**
 * A thread local variable used to hold contextual information used in requests. To get an instance of this class use RequestContext.getRequestContext(). The
 * method will return a RequestContext object which is only usable within the current thread.
 * 
 * @author Anthony Eden
 */ public class RequestContext {  private static RequestContextThreadLocal threadLocal = new RequestContextThreadLocal();  private Auth auth;  private String sharedSecret;  private List<String> extras;  /**
     * Get the RequestContext instance for the current Thread.
     * 
     * @return The RequestContext
     */ public static RequestContext getRequestContext() { return threadLocal.get(); }  public Auth getAuth() { return auth; }  public void setAuth(Auth auth) { this.auth = auth; }  /**
     * Get a shared secret which is used for any calls which require signing.
     * 
     * @deprecated Get the secret from {@link Flickr#getSharedSecret()}.
     * @return The shared secret
     */ @Deprecated
    public String getSharedSecret() { return sharedSecret; }  /**
     * Set the shared secret which is used for any calls which require signing.
     * 
     * @deprecated Set the secret in {@link Flickr#setSharedSecret(String)}.
     * @param sharedSecret
     *            The shared secret
     */ @Deprecated
    public void setSharedSecret(String sharedSecret) { this.sharedSecret = sharedSecret; }  /**
     * Get the List of extra return values requested.
     * 
     * @return List of extra return values requested
     */ public List<String> getExtras() { if (extras == null) { extras = new ArrayList<String>(); } return extras; }  public void setExtras(List<String> extras) { this.extras = extras; }  private static class RequestContextThreadLocal extends ThreadLocal<RequestContext> {  @Override
        protected RequestContext initialValue() { return new RequestContext(); }  }  }  "
src/main/java/com/flickr4java/flickr/Response.java,"

package com.flickr4java.flickr;

import org.w3c.dom.Document;
import org.w3c.dom.Element;

import java.util.Collection;

/**
 * @author Anthony Eden
 */
public interface Response {

    void parse(Document document);

    boolean isError();

    String getErrorCode();

    String getErrorMessage();

    Element getPayload();

    Collection<Element> getPayloadCollection();
}
",package com.flickr4java.flickr; import org.w3c.dom.Document; import org.w3c.dom.Element; import java.util.Collection; public interface Response { void parse(Document document); boolean isError(); String getErrorCode(); String getErrorMessage(); Element getPayload(); Collection<Element> getPayloadCollection(); },0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr; import org.w3c.dom.Document; import org.w3c.dom.Element; import java.util.Collection; public interface Response { void parse(Document document); boolean isError(); String getErrorCode(); String getErrorMessage(); Element getPayload(); Collection<Element> getPayloadCollection(); } ,"
 package com.flickr4java.flickr;  import org.w3c.dom.Document; import org.w3c.dom.Element;  import java.util.Collection;  /**
 * @author Anthony Eden
 */ public interface Response {  void parse(Document document);  boolean isError();  String getErrorCode();  String getErrorMessage();  Element getPayload();  Collection<Element> getPayloadCollection(); }  "
src/main/java/com/flickr4java/flickr/SearchResultList.java,"

package com.flickr4java.flickr;

import java.util.ArrayList;

/**
 * Search result list with additional meta data.
 * 
 * @author Anthony Eden
 * @version $Id: SearchResultList.java,v 1.3 2007/07/20 19:06:27 x-mago Exp $
 */
public class SearchResultList<E> extends ArrayList<E> {

    private static final long serialVersionUID = -7962319033867024935L;

    private int page;

    private int pages;

    private int perPage;

    private int total;

    public int getPage() {
        return page;
    }

    public void setPage(int page) {
        this.page = page;
    }

    public void setPage(String page) {
        if (page != null && page.length() != 0) {
            setPage(Integer.parseInt(page));
        }
    }

    public int getPages() {
        return pages;
    }

    public void setPages(int pages) {
        this.pages = pages;
    }

    public void setPages(String pages) {
        if (pages != null && pages.length() != 0) {
            setPages(Integer.parseInt(pages));
        }
    }

    public int getPerPage() {
        return perPage;
    }

    public void setPerPage(int perPage) {
        this.perPage = perPage;
    }

    public void setPerPage(String perPage) {
        if (perPage != null && perPage.length() != 0) {
            setPerPage(Integer.parseInt(perPage));
        }
    }

    public int getTotal() {
        return total;
    }

    public void setTotal(int total) {
        this.total = total;
    }

    public void setTotal(String total) {
        if (total != null && total.length() != 0) {
            setTotal(Integer.parseInt(total));
        }
    }

}
",package com.flickr4java.flickr; import java.util.ArrayList; public class SearchResultList<E> extends ArrayList<E> { private static final long serialVersionUID = -7962319033867024935L; private int page; private int pages; private int perPage; private int total; public int getPage() { return page; } public void setPage(int page) { this.page = page; } public void setPage(String page) { if (page != null && page.length() != 0) { setPage(Integer.parseInt(page)); } } public int getPages() { return pages; } public void setPages(int pages) { this.pages = pages; } public void setPages(String pages) { if (pages != null && pages.length() != 0) { setPages(Integer.parseInt(pages)); } } public int getPerPage() { return perPage; } public void setPerPage(int perPage) { this.perPage = perPage; } public void setPerPage(String perPage) { if (perPage != null && perPage.length() != 0) { setPerPage(Integer.parseInt(perPage)); } } public int getTotal() { return total; } public void setTotal(int total) { this.total = total; } public void setTotal(String total) { if (total != null && total.length() != 0) { setTotal(Integer.parseInt(total)); } } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr; import java.util.ArrayList; public class SearchResultList<E> extends ArrayList<E> { private static final long serialVersionUID = -7962319033867024935L; private int page; private int pages; private int perPage; private int total; public int getPage() { return page; } public void setPage(int page) { this.page = page; } public void setPage(String page) { if (page != null && page.length() != 0) { setPage(Integer.parseInt(page)); } } public int getPages() { return pages; } public void setPages(int pages) { this.pages = pages; } public void setPages(String pages) { if (pages != null && pages.length() != 0) { setPages(Integer.parseInt(pages)); } } public int getPerPage() { return perPage; } public void setPerPage(int perPage) { this.perPage = perPage; } public void setPerPage(String perPage) { if (perPage != null && perPage.length() != 0) { setPerPage(Integer.parseInt(perPage)); } } public int getTotal() { return total; } public void setTotal(int total) { this.total = total; } public void setTotal(String total) { if (total != null && total.length() != 0) { setTotal(Integer.parseInt(total)); } } } ,"
 package com.flickr4java.flickr;  import java.util.ArrayList;  /**
 * Search result list with additional meta data.
 * 
 * @author Anthony Eden
 * @version $Id: SearchResultList.java,v 1.3 2007/07/20 19:06:27 x-mago Exp $
 */ public class SearchResultList<E> extends ArrayList<E> {  private static final long serialVersionUID = -7962319033867024935L;  private int page;  private int pages;  private int perPage;  private int total;  public int getPage() { return page; }  public void setPage(int page) { this.page = page; }  public void setPage(String page) { if (page != null && page.length() != 0) { setPage(Integer.parseInt(page)); } }  public int getPages() { return pages; }  public void setPages(int pages) { this.pages = pages; }  public void setPages(String pages) { if (pages != null && pages.length() != 0) { setPages(Integer.parseInt(pages)); } }  public int getPerPage() { return perPage; }  public void setPerPage(int perPage) { this.perPage = perPage; }  public void setPerPage(String perPage) { if (perPage != null && perPage.length() != 0) { setPerPage(Integer.parseInt(perPage)); } }  public int getTotal() { return total; }  public void setTotal(int total) { this.total = total; }  public void setTotal(String total) { if (total != null && total.length() != 0) { setTotal(Integer.parseInt(total)); } }  }  "
src/main/java/com/flickr4java/flickr/Transport.java,"
package com.flickr4java.flickr;

import com.flickr4java.flickr.uploader.Payload;
import com.flickr4java.flickr.uploader.UploadMetaData;

import java.util.Map;

/**
 * The abstract Transport class provides a common interface for transporting requests to the Flickr servers.
 * Flickr offers several transport methods including REST, SOAP and XML-RPC.
 * Flickr4Java currently implements the REST transport.
 * 
 * @author Matt Ray
 * @author Anthony Eden
 */
public abstract class Transport {

    public static final String REST = ""REST"";

    protected static final String API_HOST = ""api.flickr.com"";

    /**
     * Host is different for upload, need to set it from Uploader.java.
     */
    public static final String UPLOAD_API_HOST = ""up.flickr.com"";

    protected static final String DEFAULT_SCHEME = ""https"";
    
    private String transportType;

    protected Class<?> responseClass;

    private String path;

    private String host;

    private int port = 443;
    
    private String scheme;

    public String getHost() {
        return host;
    }

    public void setHost(String host) {
        this.host = host;
    }

    public int getPort() {
        return port;
    }

    public void setPort(int port) {
        this.port = port;
    }

    public String getTransportType() {
        return transportType;
    }

    public void setTransportType(String transport) {
        this.transportType = transport;
    }

    public String getPath() {
        return path;
    }

    public void setPath(String path) {
        this.path = path;
    }

    public String getScheme() {
        return scheme;
    }

    public void setScheme(String scheme) {
        this.scheme = scheme;
    }

    /**
     * Invoke an HTTP GET request on a remote host. You must close the InputStream after you are done with.
     * 
     * @param path
     *            The request path
     * @param parameters
     *            The parameters (collection of Parameter objects)
     * @param apiKey
     * @param sharedSecret
     * @return The Response
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public abstract Response get(String path, Map<String, Object> parameters, String apiKey, String sharedSecret) throws FlickrException;

    /**
     * Invoke an HTTP POST request on a remote host.
     * 
     * @param path
     *            The request path
     * @param parameters
     *            The parameters (List of Parameter objects)
     * @param apiKey
     * @param sharedSecret
     * @return The Response object
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public abstract Response post(String path, Map<String, Object> parameters, String apiKey, String sharedSecret) throws FlickrException;

    /**
     * Invoke an HTTP POST multipart request on a remote host.
     *
     * @param path
     *            The request path
     * @param parameters
     *            The parameters (List of Parameter objects)
     * @param payload
     * @param apiKey
     * @param sharedSecret
     * @return The Response object
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public abstract Response postMultiPart(String path, UploadMetaData parameters, Payload payload, String apiKey, String sharedSecret) throws FlickrException;

    /**
     * Invoke a non OAuth HTTP GET request on a remote host.
     * 
     * This is only used for the Flickr OAuth methods checkToken and getAccessToken.
     * 
     * @param path
     *            The request path
     * @param parameters
     *            The parameters
     * @return The Response
     * @throws FlickrRuntimeException
     */
    public abstract Response getNonOAuth(String path, Map<String, String> parameters) throws FlickrRuntimeException;

    public void setResponseClass(Class<?> responseClass) {
        if (responseClass == null) {
            throw new IllegalArgumentException(""The response Class cannot be null"");
        }
        this.responseClass = responseClass;
    }
}
","package com.flickr4java.flickr; import com.flickr4java.flickr.uploader.Payload; import com.flickr4java.flickr.uploader.UploadMetaData; import java.util.Map; public abstract class Transport { public static final String REST = ""REST""; protected static final String API_HOST = ""api.flickr.com""; public static final String UPLOAD_API_HOST = ""up.flickr.com""; protected static final String DEFAULT_SCHEME = ""https""; private String transportType; protected Class<?> responseClass; private String path; private String host; private int port = 443; private String scheme; public String getHost() { return host; } public void setHost(String host) { this.host = host; } public int getPort() { return port; } public void setPort(int port) { this.port = port; } public String getTransportType() { return transportType; } public void setTransportType(String transport) { this.transportType = transport; } public String getPath() { return path; } public void setPath(String path) { this.path = path; } public String getScheme() { return scheme; } public void setScheme(String scheme) { this.scheme = scheme; } public abstract Response get(String path, Map<String, Object> parameters, String apiKey, String sharedSecret) throws FlickrException; public abstract Response post(String path, Map<String, Object> parameters, String apiKey, String sharedSecret) throws FlickrException; public abstract Response postMultiPart(String path, UploadMetaData parameters, Payload payload, String apiKey, String sharedSecret) throws FlickrException; public abstract Response getNonOAuth(String path, Map<String, String> parameters) throws FlickrRuntimeException; public void setResponseClass(Class<?> responseClass) { if (responseClass == null) { throw new IllegalArgumentException(""The response Class cannot be null""); } this.responseClass = responseClass; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr; import com.flickr4java.flickr.uploader.Payload; import com.flickr4java.flickr.uploader.UploadMetaData; import java.util.Map; public abstract class Transport { public static final String REST = ""REST""; protected static final String API_HOST = ""api.flickr.com""; public static final String UPLOAD_API_HOST = ""up.flickr.com""; protected static final String DEFAULT_SCHEME = ""https""; private String transportType; protected Class<?> responseClass; private String path; private String host; private int port = 443; private String scheme; public String getHost() { return host; } public void setHost(String host) { this.host = host; } public int getPort() { return port; } public void setPort(int port) { this.port = port; } public String getTransportType() { return transportType; } public void setTransportType(String transport) { this.transportType = transport; } public String getPath() { return path; } public void setPath(String path) { this.path = path; } public String getScheme() { return scheme; } public void setScheme(String scheme) { this.scheme = scheme; } public abstract Response get(String path, Map<String, Object> parameters, String apiKey, String sharedSecret) throws FlickrException; public abstract Response post(String path, Map<String, Object> parameters, String apiKey, String sharedSecret) throws FlickrException; public abstract Response postMultiPart(String path, UploadMetaData parameters, Payload payload, String apiKey, String sharedSecret) throws FlickrException; public abstract Response getNonOAuth(String path, Map<String, String> parameters) throws FlickrRuntimeException; public void setResponseClass(Class<?> responseClass) { if (responseClass == null) { throw new IllegalArgumentException(""The response Class cannot be null""); } this.responseClass = responseClass; } } "," package com.flickr4java.flickr;  import com.flickr4java.flickr.uploader.Payload; import com.flickr4java.flickr.uploader.UploadMetaData;  import java.util.Map;  /**
 * The abstract Transport class provides a common interface for transporting requests to the Flickr servers.
 * Flickr offers several transport methods including REST, SOAP and XML-RPC.
 * Flickr4Java currently implements the REST transport.
 * 
 * @author Matt Ray
 * @author Anthony Eden
 */ public abstract class Transport {  public static final String REST = ""REST"";  protected static final String API_HOST = ""api.flickr.com"";  /**
     * Host is different for upload, need to set it from Uploader.java.
     */ public static final String UPLOAD_API_HOST = ""up.flickr.com"";  protected static final String DEFAULT_SCHEME = ""https"";      private String transportType;  protected Class<?> responseClass;  private String path;  private String host;  private int port = 443;      private String scheme;  public String getHost() { return host; }  public void setHost(String host) { this.host = host; }  public int getPort() { return port; }  public void setPort(int port) { this.port = port; }  public String getTransportType() { return transportType; }  public void setTransportType(String transport) { this.transportType = transport; }  public String getPath() { return path; }  public void setPath(String path) { this.path = path; }  public String getScheme() { return scheme; }  public void setScheme(String scheme) { this.scheme = scheme; }  /**
     * Invoke an HTTP GET request on a remote host. You must close the InputStream after you are done with.
     * 
     * @param path
     *            The request path
     * @param parameters
     *            The parameters (collection of Parameter objects)
     * @param apiKey
     * @param sharedSecret
     * @return The Response
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public abstract Response get(String path, Map<String, Object> parameters, String apiKey, String sharedSecret) throws FlickrException;  /**
     * Invoke an HTTP POST request on a remote host.
     * 
     * @param path
     *            The request path
     * @param parameters
     *            The parameters (List of Parameter objects)
     * @param apiKey
     * @param sharedSecret
     * @return The Response object
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public abstract Response post(String path, Map<String, Object> parameters, String apiKey, String sharedSecret) throws FlickrException;  /**
     * Invoke an HTTP POST multipart request on a remote host.
     *
     * @param path
     *            The request path
     * @param parameters
     *            The parameters (List of Parameter objects)
     * @param payload
     * @param apiKey
     * @param sharedSecret
     * @return The Response object
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public abstract Response postMultiPart(String path, UploadMetaData parameters, Payload payload, String apiKey, String sharedSecret) throws FlickrException;  /**
     * Invoke a non OAuth HTTP GET request on a remote host.
     * 
     * This is only used for the Flickr OAuth methods checkToken and getAccessToken.
     * 
     * @param path
     *            The request path
     * @param parameters
     *            The parameters
     * @return The Response
     * @throws FlickrRuntimeException
     */ public abstract Response getNonOAuth(String path, Map<String, String> parameters) throws FlickrRuntimeException;  public void setResponseClass(Class<?> responseClass) { if (responseClass == null) { throw new IllegalArgumentException(""The response Class cannot be null""); } this.responseClass = responseClass; } }  "
src/main/java/com/flickr4java/flickr/activity/ActivityInterface.java,"package com.flickr4java.flickr.activity;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.util.XMLUtilities;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

/**
 * Gather activity information belonging to the calling user.
 * 
 * @author Martin Goebel
 * @version $Id: ActivityInterface.java,v 1.4 2008/01/28 23:01:45 x-mago Exp $
 */
public class ActivityInterface {

    public static final String METHOD_USER_COMMENTS = ""flickr.activity.userComments"";

    public static final String METHOD_USER_PHOTOS = ""flickr.activity.userPhotos"";

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transportAPI;

    public ActivityInterface(String apiKey, String sharedSecret, Transport transport) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transport;
    }

    /**
     * Returns a list of recent activity on photos commented on by the calling user.<br>
     * Flickr says: Do not poll this method more than once an hour.
     * 
     * @param perPage
     * @param page
     * @return ItemList
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public ItemList<Item> userComments(int perPage, int page) throws FlickrException {
        ItemList<Item> items = new ItemList<Item>();
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_USER_COMMENTS);

        if (perPage > 0) {
            parameters.put(""per_page"", """" + perPage);
        }

        if (page > 0) {
            parameters.put(""page"", """" + page);
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element itemList = response.getPayload();
        NodeList itemElements = itemList.getElementsByTagName(""item"");
        items.setPage(itemList.getAttribute(""page""));
        items.setPages(itemList.getAttribute(""pages""));
        items.setPerPage(itemList.getAttribute(""perpage""));
        items.setTotal(itemList.getAttribute(""total""));

        for (int i = 0; i < itemElements.getLength(); i++) {
            Element itemElement = (Element) itemElements.item(i);
            items.add(createItem(itemElement));
        }

        return items;
    }

    /**
     * Returns a list of recent activity on photos belonging to the calling user.<br>
     * Flickr says: Do not poll this method more than once an hour.
     * 
     * @param perPage
     * @param page
     * @param timeframe
     * @return ItemList
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public ItemList<Item> userPhotos(int perPage, int page, String timeframe) throws FlickrException {
        ItemList<Item> items = new ItemList<Item>();
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_USER_PHOTOS);

        if (perPage > 0) {
            parameters.put(""per_page"", """" + perPage);
        }

        if (page > 0) {
            parameters.put(""page"", """" + page);
        }

        if (timeframe != null) {
            if (checkTimeframeArg(timeframe)) {
                parameters.put(""timeframe"", timeframe);
            } else {
                throw new FlickrException(""0"", ""Timeframe-argument to getUserPhotos() not valid"");
            }
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element itemList = response.getPayload();
        NodeList itemElements = itemList.getElementsByTagName(""item"");
        items.setPage(itemList.getAttribute(""page""));
        items.setPages(itemList.getAttribute(""pages""));
        items.setPerPage(itemList.getAttribute(""perpage""));
        items.setTotal(itemList.getAttribute(""total""));

        for (int i = 0; i < itemElements.getLength(); i++) {
            Element itemElement = (Element) itemElements.item(i);
            items.add(createItem(itemElement));
        }

        return items;
    }

    private Item createItem(Element itemElement) {
        Item item = new Item();
        item.setId(itemElement.getAttribute(""id""));
        item.setSecret(itemElement.getAttribute(""secret""));
        item.setType(itemElement.getAttribute(""type""));
        item.setTitle(XMLUtilities.getChildValue(itemElement, ""title""));
        item.setFarm(itemElement.getAttribute(""farm""));
        item.setServer(itemElement.getAttribute(""server""));
        // userComments
        try {
            item.setComments(XMLUtilities.getIntAttribute(itemElement, ""comments""));
            item.setNotes(XMLUtilities.getIntAttribute(itemElement, ""notes""));
        } catch (Exception e) {
        }
        // userPhotos
        try {
            item.setCommentsOld(XMLUtilities.getIntAttribute(itemElement, ""commentsold""));
            item.setCommentsNew(XMLUtilities.getIntAttribute(itemElement, ""commentsnew""));
            item.setNotesOld(XMLUtilities.getIntAttribute(itemElement, ""notesold""));
            item.setNotesNew(XMLUtilities.getIntAttribute(itemElement, ""notesnew""));
        } catch (Exception e) {
        }
        item.setViews(XMLUtilities.getIntAttribute(itemElement, ""views""));
        item.setFaves(XMLUtilities.getIntAttribute(itemElement, ""faves""));
        item.setMore(XMLUtilities.getIntAttribute(itemElement, ""more""));

        try {
            Element activityElement = (Element) itemElement.getElementsByTagName(""activity"").item(0);
            List<Event> events = new ArrayList<Event>();
            NodeList eventNodes = activityElement.getElementsByTagName(""event"");
            for (int i = 0; i < eventNodes.getLength(); i++) {
                Element eventElement = (Element) eventNodes.item(i);
                Event event = new Event();
                event.setType(eventElement.getAttribute(""type""));
                if (event.getType().equals(""comment"")) {
                    event.setId(eventElement.getAttribute(""commentid""));
                } else if (event.getType().equals(""note"")) {
                    event.setId(eventElement.getAttribute(""noteid""));
                } else if (event.getType().equals(""fave"")) {
                    // has no id
                }
                event.setUser(eventElement.getAttribute(""user""));
                event.setUsername(eventElement.getAttribute(""username""));
                event.setDateadded(eventElement.getAttribute(""dateadded""));
                event.setValue(XMLUtilities.getValue(eventElement));
                events.add(event);
            }
            item.setEvents(events);
        } catch (NullPointerException e) {
            // nop
        }
        return item;
    }

    /**
     * Checks for a valid timeframe-argument.<br>
     * Expects either days, or hours. Like: 2d or 4h.
     * 
     * @param timeframe
     * @return boolean
     */
    public boolean checkTimeframeArg(String timeframe) {
        if (Pattern.compile(""\\d*(d|h)"", Pattern.CASE_INSENSITIVE).matcher(timeframe).matches()) {
            return true;
        } else {
            return false;
        }
    }
}
","package com.flickr4java.flickr.activity; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.regex.Pattern; public class ActivityInterface { public static final String METHOD_USER_COMMENTS = ""flickr.activity.userComments""; public static final String METHOD_USER_PHOTOS = ""flickr.activity.userPhotos""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public ActivityInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transport; } public ItemList<Item> userComments(int perPage, int page) throws FlickrException { ItemList<Item> items = new ItemList<Item>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_USER_COMMENTS); if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element itemList = response.getPayload(); NodeList itemElements = itemList.getElementsByTagName(""item""); items.setPage(itemList.getAttribute(""page"")); items.setPages(itemList.getAttribute(""pages"")); items.setPerPage(itemList.getAttribute(""perpage"")); items.setTotal(itemList.getAttribute(""total"")); for (int i = 0; i < itemElements.getLength(); i++) { Element itemElement = (Element) itemElements.item(i); items.add(createItem(itemElement)); } return items; } public ItemList<Item> userPhotos(int perPage, int page, String timeframe) throws FlickrException { ItemList<Item> items = new ItemList<Item>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_USER_PHOTOS); if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } if (timeframe != null) { if (checkTimeframeArg(timeframe)) { parameters.put(""timeframe"", timeframe); } else { throw new FlickrException(""0"", ""Timeframe-argument to getUserPhotos() not valid""); } } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element itemList = response.getPayload(); NodeList itemElements = itemList.getElementsByTagName(""item""); items.setPage(itemList.getAttribute(""page"")); items.setPages(itemList.getAttribute(""pages"")); items.setPerPage(itemList.getAttribute(""perpage"")); items.setTotal(itemList.getAttribute(""total"")); for (int i = 0; i < itemElements.getLength(); i++) { Element itemElement = (Element) itemElements.item(i); items.add(createItem(itemElement)); } return items; } private Item createItem(Element itemElement) { Item item = new Item(); item.setId(itemElement.getAttribute(""id"")); item.setSecret(itemElement.getAttribute(""secret"")); item.setType(itemElement.getAttribute(""type"")); item.setTitle(XMLUtilities.getChildValue(itemElement, ""title"")); item.setFarm(itemElement.getAttribute(""farm"")); item.setServer(itemElement.getAttribute(""server"")); try { item.setComments(XMLUtilities.getIntAttribute(itemElement, ""comments"")); item.setNotes(XMLUtilities.getIntAttribute(itemElement, ""notes"")); } catch (Exception e) { } try { item.setCommentsOld(XMLUtilities.getIntAttribute(itemElement, ""commentsold"")); item.setCommentsNew(XMLUtilities.getIntAttribute(itemElement, ""commentsnew"")); item.setNotesOld(XMLUtilities.getIntAttribute(itemElement, ""notesold"")); item.setNotesNew(XMLUtilities.getIntAttribute(itemElement, ""notesnew"")); } catch (Exception e) { } item.setViews(XMLUtilities.getIntAttribute(itemElement, ""views"")); item.setFaves(XMLUtilities.getIntAttribute(itemElement, ""faves"")); item.setMore(XMLUtilities.getIntAttribute(itemElement, ""more"")); try { Element activityElement = (Element) itemElement.getElementsByTagName(""activity"").item(0); List<Event> events = new ArrayList<Event>(); NodeList eventNodes = activityElement.getElementsByTagName(""event""); for (int i = 0; i < eventNodes.getLength(); i++) { Element eventElement = (Element) eventNodes.item(i); Event event = new Event(); event.setType(eventElement.getAttribute(""type"")); if (event.getType().equals(""comment"")) { event.setId(eventElement.getAttribute(""commentid"")); } else if (event.getType().equals(""note"")) { event.setId(eventElement.getAttribute(""noteid"")); } else if (event.getType().equals(""fave"")) { } event.setUser(eventElement.getAttribute(""user"")); event.setUsername(eventElement.getAttribute(""username"")); event.setDateadded(eventElement.getAttribute(""dateadded"")); event.setValue(XMLUtilities.getValue(eventElement)); events.add(event); } item.setEvents(events); } catch (NullPointerException e) { } return item; } public boolean checkTimeframeArg(String timeframe) { if (Pattern.compile(""\\d*(d|h)"", Pattern.CASE_INSENSITIVE).matcher(timeframe).matches()) { return true; } else { return false; } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.activity; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.regex.Pattern; public class ActivityInterface { public static final String METHOD_USER_COMMENTS = ""flickr.activity.userComments""; public static final String METHOD_USER_PHOTOS = ""flickr.activity.userPhotos""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public ActivityInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transport; } public ItemList<Item> userComments(int perPage, int page) throws FlickrException { ItemList<Item> items = new ItemList<Item>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_USER_COMMENTS); if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element itemList = response.getPayload(); NodeList itemElements = itemList.getElementsByTagName(""item""); items.setPage(itemList.getAttribute(""page"")); items.setPages(itemList.getAttribute(""pages"")); items.setPerPage(itemList.getAttribute(""perpage"")); items.setTotal(itemList.getAttribute(""total"")); for (int i = 0; i < itemElements.getLength(); i++) { Element itemElement = (Element) itemElements.item(i); items.add(createItem(itemElement)); } return items; } public ItemList<Item> userPhotos(int perPage, int page, String timeframe) throws FlickrException { ItemList<Item> items = new ItemList<Item>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_USER_PHOTOS); if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } if (timeframe != null) { if (checkTimeframeArg(timeframe)) { parameters.put(""timeframe"", timeframe); } else { throw new FlickrException(""0"", ""Timeframe-argument to getUserPhotos() not valid""); } } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element itemList = response.getPayload(); NodeList itemElements = itemList.getElementsByTagName(""item""); items.setPage(itemList.getAttribute(""page"")); items.setPages(itemList.getAttribute(""pages"")); items.setPerPage(itemList.getAttribute(""perpage"")); items.setTotal(itemList.getAttribute(""total"")); for (int i = 0; i < itemElements.getLength(); i++) { Element itemElement = (Element) itemElements.item(i); items.add(createItem(itemElement)); } return items; } private Item createItem(Element itemElement) { Item item = new Item(); item.setId(itemElement.getAttribute(""id"")); item.setSecret(itemElement.getAttribute(""secret"")); item.setType(itemElement.getAttribute(""type"")); item.setTitle(XMLUtilities.getChildValue(itemElement, ""title"")); item.setFarm(itemElement.getAttribute(""farm"")); item.setServer(itemElement.getAttribute(""server"")); try { item.setComments(XMLUtilities.getIntAttribute(itemElement, ""comments"")); item.setNotes(XMLUtilities.getIntAttribute(itemElement, ""notes"")); } catch (Exception e) { } try { item.setCommentsOld(XMLUtilities.getIntAttribute(itemElement, ""commentsold"")); item.setCommentsNew(XMLUtilities.getIntAttribute(itemElement, ""commentsnew"")); item.setNotesOld(XMLUtilities.getIntAttribute(itemElement, ""notesold"")); item.setNotesNew(XMLUtilities.getIntAttribute(itemElement, ""notesnew"")); } catch (Exception e) { } item.setViews(XMLUtilities.getIntAttribute(itemElement, ""views"")); item.setFaves(XMLUtilities.getIntAttribute(itemElement, ""faves"")); item.setMore(XMLUtilities.getIntAttribute(itemElement, ""more"")); try { Element activityElement = (Element) itemElement.getElementsByTagName(""activity"").item(0); List<Event> events = new ArrayList<Event>(); NodeList eventNodes = activityElement.getElementsByTagName(""event""); for (int i = 0; i < eventNodes.getLength(); i++) { Element eventElement = (Element) eventNodes.item(i); Event event = new Event(); event.setType(eventElement.getAttribute(""type"")); if (event.getType().equals(""comment"")) { event.setId(eventElement.getAttribute(""commentid"")); } else if (event.getType().equals(""note"")) { event.setId(eventElement.getAttribute(""noteid"")); } else if (event.getType().equals(""fave"")) { } event.setUser(eventElement.getAttribute(""user"")); event.setUsername(eventElement.getAttribute(""username"")); event.setDateadded(eventElement.getAttribute(""dateadded"")); event.setValue(XMLUtilities.getValue(eventElement)); events.add(event); } item.setEvents(events); } catch (NullPointerException e) { } return item; } public boolean checkTimeframeArg(String timeframe) { if (Pattern.compile(""\\d*(d|h)"", Pattern.CASE_INSENSITIVE).matcher(timeframe).matches()) { return true; } else { return false; } } } ","package com.flickr4java.flickr.activity;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.XMLUtilities;  import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.regex.Pattern;  /**
 * Gather activity information belonging to the calling user.
 * 
 * @author Martin Goebel
 * @version $Id: ActivityInterface.java,v 1.4 2008/01/28 23:01:45 x-mago Exp $
 */ public class ActivityInterface {  public static final String METHOD_USER_COMMENTS = ""flickr.activity.userComments"";  public static final String METHOD_USER_PHOTOS = ""flickr.activity.userPhotos"";  private final String apiKey;  private final String sharedSecret;  private final Transport transportAPI;  public ActivityInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transport; }  /**
     * Returns a list of recent activity on photos commented on by the calling user.<br>
     * Flickr says: Do not poll this method more than once an hour.
     * 
     * @param perPage
     * @param page
     * @return ItemList
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public ItemList<Item> userComments(int perPage, int page) throws FlickrException { ItemList<Item> items = new ItemList<Item>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_USER_COMMENTS);  if (perPage > 0) { parameters.put(""per_page"", """" + perPage); }  if (page > 0) { parameters.put(""page"", """" + page); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element itemList = response.getPayload(); NodeList itemElements = itemList.getElementsByTagName(""item""); items.setPage(itemList.getAttribute(""page"")); items.setPages(itemList.getAttribute(""pages"")); items.setPerPage(itemList.getAttribute(""perpage"")); items.setTotal(itemList.getAttribute(""total""));  for (int i = 0; i < itemElements.getLength(); i++) { Element itemElement = (Element) itemElements.item(i); items.add(createItem(itemElement)); }  return items; }  /**
     * Returns a list of recent activity on photos belonging to the calling user.<br>
     * Flickr says: Do not poll this method more than once an hour.
     * 
     * @param perPage
     * @param page
     * @param timeframe
     * @return ItemList
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public ItemList<Item> userPhotos(int perPage, int page, String timeframe) throws FlickrException { ItemList<Item> items = new ItemList<Item>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_USER_PHOTOS);  if (perPage > 0) { parameters.put(""per_page"", """" + perPage); }  if (page > 0) { parameters.put(""page"", """" + page); }  if (timeframe != null) { if (checkTimeframeArg(timeframe)) { parameters.put(""timeframe"", timeframe); } else { throw new FlickrException(""0"", ""Timeframe-argument to getUserPhotos() not valid""); } }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element itemList = response.getPayload(); NodeList itemElements = itemList.getElementsByTagName(""item""); items.setPage(itemList.getAttribute(""page"")); items.setPages(itemList.getAttribute(""pages"")); items.setPerPage(itemList.getAttribute(""perpage"")); items.setTotal(itemList.getAttribute(""total""));  for (int i = 0; i < itemElements.getLength(); i++) { Element itemElement = (Element) itemElements.item(i); items.add(createItem(itemElement)); }  return items; }  private Item createItem(Element itemElement) { Item item = new Item(); item.setId(itemElement.getAttribute(""id"")); item.setSecret(itemElement.getAttribute(""secret"")); item.setType(itemElement.getAttribute(""type"")); item.setTitle(XMLUtilities.getChildValue(itemElement, ""title"")); item.setFarm(itemElement.getAttribute(""farm"")); item.setServer(itemElement.getAttribute(""server"")); // userComments try { item.setComments(XMLUtilities.getIntAttribute(itemElement, ""comments"")); item.setNotes(XMLUtilities.getIntAttribute(itemElement, ""notes"")); } catch (Exception e) { } // userPhotos try { item.setCommentsOld(XMLUtilities.getIntAttribute(itemElement, ""commentsold"")); item.setCommentsNew(XMLUtilities.getIntAttribute(itemElement, ""commentsnew"")); item.setNotesOld(XMLUtilities.getIntAttribute(itemElement, ""notesold"")); item.setNotesNew(XMLUtilities.getIntAttribute(itemElement, ""notesnew"")); } catch (Exception e) { } item.setViews(XMLUtilities.getIntAttribute(itemElement, ""views"")); item.setFaves(XMLUtilities.getIntAttribute(itemElement, ""faves"")); item.setMore(XMLUtilities.getIntAttribute(itemElement, ""more""));  try { Element activityElement = (Element) itemElement.getElementsByTagName(""activity"").item(0); List<Event> events = new ArrayList<Event>(); NodeList eventNodes = activityElement.getElementsByTagName(""event""); for (int i = 0; i < eventNodes.getLength(); i++) { Element eventElement = (Element) eventNodes.item(i); Event event = new Event(); event.setType(eventElement.getAttribute(""type"")); if (event.getType().equals(""comment"")) { event.setId(eventElement.getAttribute(""commentid"")); } else if (event.getType().equals(""note"")) { event.setId(eventElement.getAttribute(""noteid"")); } else if (event.getType().equals(""fave"")) { // has no id } event.setUser(eventElement.getAttribute(""user"")); event.setUsername(eventElement.getAttribute(""username"")); event.setDateadded(eventElement.getAttribute(""dateadded"")); event.setValue(XMLUtilities.getValue(eventElement)); events.add(event); } item.setEvents(events); } catch (NullPointerException e) { // nop } return item; }  /**
     * Checks for a valid timeframe-argument.<br>
     * Expects either days, or hours. Like: 2d or 4h.
     * 
     * @param timeframe
     * @return boolean
     */ public boolean checkTimeframeArg(String timeframe) { if (Pattern.compile(""\\d*(d|h)"", Pattern.CASE_INSENSITIVE).matcher(timeframe).matches()) { return true; } else { return false; } } }  "
src/main/java/com/flickr4java/flickr/activity/Event.java,"package com.flickr4java.flickr.activity;

import java.util.Date;

/**
 * Activity-Event. It's type is either 'note' or 'comment', or 'fave'. id is set only, if the type of the Event is 'note' or 'comment'.
 * 
 * @see com.flickr4java.flickr.activity.Item
 * @author mago
 * @version $Id: Event.java,v 1.2 2007/07/22 16:18:20 x-mago Exp $
 */
public class Event {
    private String id;

    private String type;

    private String user;

    private String username;

    private String value;

    private Date dateadded;

    public Event() {
    }

    public Date getDateadded() {
        return dateadded;
    }

    public void setDateadded(Date dateadded) {
        this.dateadded = dateadded;
    }

    public void setDateadded(String dateAdded) {
        if (dateAdded == null || """".equals(dateAdded))
            return;
        setDateadded(new Date(Long.parseLong(dateAdded) * (long) 1000));
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public String getUser() {
        return user;
    }

    public void setUser(String user) {
        this.user = user;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

}
","package com.flickr4java.flickr.activity; import java.util.Date; public class Event { private String id; private String type; private String user; private String username; private String value; private Date dateadded; public Event() { } public Date getDateadded() { return dateadded; } public void setDateadded(Date dateadded) { this.dateadded = dateadded; } public void setDateadded(String dateAdded) { if (dateAdded == null || """".equals(dateAdded))
            return; setDateadded(new Date(Long.parseLong(dateAdded) * (long) 1000)); } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getType() { return type; } public void setType(String type) { this.type = type; } public String getUser() { return user; } public void setUser(String user) { this.user = user; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getValue() { return value; } public void setValue(String value) { this.value = value; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.activity; import java.util.Date; public class Event { private String id; private String type; private String user; private String username; private String value; private Date dateadded; public Event() { } public Date getDateadded() { return dateadded; } public void setDateadded(Date dateadded) { this.dateadded = dateadded; } public void setDateadded(String dateAdded) { if (dateAdded == null || """".equals(dateAdded))
            return; setDateadded(new Date(Long.parseLong(dateAdded) * (long) 1000)); } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getType() { return type; } public void setType(String type) { this.type = type; } public String getUser() { return user; } public void setUser(String user) { this.user = user; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getValue() { return value; } public void setValue(String value) { this.value = value; } } ","package com.flickr4java.flickr.activity;  import java.util.Date;  /**
 * Activity-Event. It's type is either 'note' or 'comment', or 'fave'. id is set only, if the type of the Event is 'note' or 'comment'.
 * 
 * @see com.flickr4java.flickr.activity.Item
 * @author mago
 * @version $Id: Event.java,v 1.2 2007/07/22 16:18:20 x-mago Exp $
 */ public class Event { private String id;  private String type;  private String user;  private String username;  private String value;  private Date dateadded;  public Event() { }  public Date getDateadded() { return dateadded; }  public void setDateadded(Date dateadded) { this.dateadded = dateadded; }  public void setDateadded(String dateAdded) { if (dateAdded == null || """".equals(dateAdded))
            return; setDateadded(new Date(Long.parseLong(dateAdded) * (long) 1000)); }  public String getId() { return id; }  public void setId(String id) { this.id = id; }  public String getType() { return type; }  public void setType(String type) { this.type = type; }  public String getUser() { return user; }  public void setUser(String user) { this.user = user; }  public String getUsername() { return username; }  public void setUsername(String username) { this.username = username; }  public String getValue() { return value; }  public void setValue(String value) { this.value = value; }  }  "
src/main/java/com/flickr4java/flickr/activity/Item.java,"package com.flickr4java.flickr.activity;

import java.util.Collection;

/**
 * Item with activity can be of type 'photo' or 'photoset'. It contains a list of Event.
 * 
 * @see com.flickr4java.flickr.activity.Event
 * @author mago
 * @version $Id: Item.java,v 1.2 2007/07/22 16:18:20 x-mago Exp $
 */
public class Item {
    private String type;

    private String id;

    private String title;

    private String owner;

    private String secret;

    private String server;

    private String farm;

    // userComments
    private int comments = 0;

    private int notes = 0;

    // userPhotos
    private int commentsOld = 0;

    private int commentsNew = 0;

    private int notesOld = 0;

    private int notesNew = 0;

    private int views = 0;

    private int faves = 0;

    private int more = 0;

    private Collection<Event> events;

    public Item() {
    }

    public String getFarm() {
        return farm;
    }

    public void setFarm(String farm) {
        this.farm = farm;
    }

    public int getFaves() {
        return faves;
    }

    public void setFaves(int faves) {
        this.faves = faves;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public int getMore() {
        return more;
    }

    public void setMore(int more) {
        this.more = more;
    }

    public String getOwner() {
        return owner;
    }

    public void setOwner(String owner) {
        this.owner = owner;
    }

    public String getSecret() {
        return secret;
    }

    public void setSecret(String secret) {
        this.secret = secret;
    }

    public String getServer() {
        return server;
    }

    public void setServer(String server) {
        this.server = server;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public int getViews() {
        return views;
    }

    public void setViews(int views) {
        this.views = views;
    }

    public Collection<Event> getEvents() {
        return events;
    }

    public void setEvents(Collection<Event> events) {
        this.events = events;
    }

    /**
     * Available if delivered by ActivityInterface.userComments()
     * 
     * @return number of comments
     */
    public int getComments() {
        return comments;
    }

    public void setComments(int comments) {
        this.comments = comments;
    }

    /**
     * Available if delivered by ActivityInterface.userComments()
     * 
     * @return number of notes
     */
    public int getNotes() {
        return notes;
    }

    public void setNotes(int notes) {
        this.notes = notes;
    }

    /**
     * Available if delivered by ActivityInterface.userPhotos()
     * 
     * @return number of new comments
     */
    public int getCommentsNew() {
        return commentsNew;
    }

    public void setCommentsNew(int commentsNew) {
        this.commentsNew = commentsNew;
    }

    /**
     * Available if delivered by ActivityInterface.userPhotos()
     * 
     * @return number of old comments
     */
    public int getCommentsOld() {
        return commentsOld;
    }

    public void setCommentsOld(int commentsOld) {
        this.commentsOld = commentsOld;
    }

    /**
     * Available if delivered by ActivityInterface.userPhotos()
     * 
     * @return number of new notes
     */
    public int getNotesNew() {
        return notesNew;
    }

    public void setNotesNew(int notesNew) {
        this.notesNew = notesNew;
    }

    /**
     * Available if delivered by ActivityInterface.userPhotos()
     * 
     * @return number of old notes
     */
    public int getNotesOld() {
        return notesOld;
    }

    public void setNotesOld(int notesOld) {
        this.notesOld = notesOld;
    }

}
",package com.flickr4java.flickr.activity; import java.util.Collection; public class Item { private String type; private String id; private String title; private String owner; private String secret; private String server; private String farm; private int comments = 0; private int notes = 0; private int commentsOld = 0; private int commentsNew = 0; private int notesOld = 0; private int notesNew = 0; private int views = 0; private int faves = 0; private int more = 0; private Collection<Event> events; public Item() { } public String getFarm() { return farm; } public void setFarm(String farm) { this.farm = farm; } public int getFaves() { return faves; } public void setFaves(int faves) { this.faves = faves; } public String getId() { return id; } public void setId(String id) { this.id = id; } public int getMore() { return more; } public void setMore(int more) { this.more = more; } public String getOwner() { return owner; } public void setOwner(String owner) { this.owner = owner; } public String getSecret() { return secret; } public void setSecret(String secret) { this.secret = secret; } public String getServer() { return server; } public void setServer(String server) { this.server = server; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getType() { return type; } public void setType(String type) { this.type = type; } public int getViews() { return views; } public void setViews(int views) { this.views = views; } public Collection<Event> getEvents() { return events; } public void setEvents(Collection<Event> events) { this.events = events; } public int getComments() { return comments; } public void setComments(int comments) { this.comments = comments; } public int getNotes() { return notes; } public void setNotes(int notes) { this.notes = notes; } public int getCommentsNew() { return commentsNew; } public void setCommentsNew(int commentsNew) { this.commentsNew = commentsNew; } public int getCommentsOld() { return commentsOld; } public void setCommentsOld(int commentsOld) { this.commentsOld = commentsOld; } public int getNotesNew() { return notesNew; } public void setNotesNew(int notesNew) { this.notesNew = notesNew; } public int getNotesOld() { return notesOld; } public void setNotesOld(int notesOld) { this.notesOld = notesOld; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.activity; import java.util.Collection; public class Item { private String type; private String id; private String title; private String owner; private String secret; private String server; private String farm; private int comments = 0; private int notes = 0; private int commentsOld = 0; private int commentsNew = 0; private int notesOld = 0; private int notesNew = 0; private int views = 0; private int faves = 0; private int more = 0; private Collection<Event> events; public Item() { } public String getFarm() { return farm; } public void setFarm(String farm) { this.farm = farm; } public int getFaves() { return faves; } public void setFaves(int faves) { this.faves = faves; } public String getId() { return id; } public void setId(String id) { this.id = id; } public int getMore() { return more; } public void setMore(int more) { this.more = more; } public String getOwner() { return owner; } public void setOwner(String owner) { this.owner = owner; } public String getSecret() { return secret; } public void setSecret(String secret) { this.secret = secret; } public String getServer() { return server; } public void setServer(String server) { this.server = server; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getType() { return type; } public void setType(String type) { this.type = type; } public int getViews() { return views; } public void setViews(int views) { this.views = views; } public Collection<Event> getEvents() { return events; } public void setEvents(Collection<Event> events) { this.events = events; } public int getComments() { return comments; } public void setComments(int comments) { this.comments = comments; } public int getNotes() { return notes; } public void setNotes(int notes) { this.notes = notes; } public int getCommentsNew() { return commentsNew; } public void setCommentsNew(int commentsNew) { this.commentsNew = commentsNew; } public int getCommentsOld() { return commentsOld; } public void setCommentsOld(int commentsOld) { this.commentsOld = commentsOld; } public int getNotesNew() { return notesNew; } public void setNotesNew(int notesNew) { this.notesNew = notesNew; } public int getNotesOld() { return notesOld; } public void setNotesOld(int notesOld) { this.notesOld = notesOld; } } ,"package com.flickr4java.flickr.activity;  import java.util.Collection;  /**
 * Item with activity can be of type 'photo' or 'photoset'. It contains a list of Event.
 * 
 * @see com.flickr4java.flickr.activity.Event
 * @author mago
 * @version $Id: Item.java,v 1.2 2007/07/22 16:18:20 x-mago Exp $
 */ public class Item { private String type;  private String id;  private String title;  private String owner;  private String secret;  private String server;  private String farm;  // userComments private int comments = 0;  private int notes = 0;  // userPhotos private int commentsOld = 0;  private int commentsNew = 0;  private int notesOld = 0;  private int notesNew = 0;  private int views = 0;  private int faves = 0;  private int more = 0;  private Collection<Event> events;  public Item() { }  public String getFarm() { return farm; }  public void setFarm(String farm) { this.farm = farm; }  public int getFaves() { return faves; }  public void setFaves(int faves) { this.faves = faves; }  public String getId() { return id; }  public void setId(String id) { this.id = id; }  public int getMore() { return more; }  public void setMore(int more) { this.more = more; }  public String getOwner() { return owner; }  public void setOwner(String owner) { this.owner = owner; }  public String getSecret() { return secret; }  public void setSecret(String secret) { this.secret = secret; }  public String getServer() { return server; }  public void setServer(String server) { this.server = server; }  public String getTitle() { return title; }  public void setTitle(String title) { this.title = title; }  public String getType() { return type; }  public void setType(String type) { this.type = type; }  public int getViews() { return views; }  public void setViews(int views) { this.views = views; }  public Collection<Event> getEvents() { return events; }  public void setEvents(Collection<Event> events) { this.events = events; }  /**
     * Available if delivered by ActivityInterface.userComments()
     * 
     * @return number of comments
     */ public int getComments() { return comments; }  public void setComments(int comments) { this.comments = comments; }  /**
     * Available if delivered by ActivityInterface.userComments()
     * 
     * @return number of notes
     */ public int getNotes() { return notes; }  public void setNotes(int notes) { this.notes = notes; }  /**
     * Available if delivered by ActivityInterface.userPhotos()
     * 
     * @return number of new comments
     */ public int getCommentsNew() { return commentsNew; }  public void setCommentsNew(int commentsNew) { this.commentsNew = commentsNew; }  /**
     * Available if delivered by ActivityInterface.userPhotos()
     * 
     * @return number of old comments
     */ public int getCommentsOld() { return commentsOld; }  public void setCommentsOld(int commentsOld) { this.commentsOld = commentsOld; }  /**
     * Available if delivered by ActivityInterface.userPhotos()
     * 
     * @return number of new notes
     */ public int getNotesNew() { return notesNew; }  public void setNotesNew(int notesNew) { this.notesNew = notesNew; }  /**
     * Available if delivered by ActivityInterface.userPhotos()
     * 
     * @return number of old notes
     */ public int getNotesOld() { return notesOld; }  public void setNotesOld(int notesOld) { this.notesOld = notesOld; }  }  "
src/main/java/com/flickr4java/flickr/activity/ItemList.java,"package com.flickr4java.flickr.activity;

import com.flickr4java.flickr.SearchResultList;

public class ItemList<E> extends SearchResultList<Item> {

    private static final long serialVersionUID = 7330819045487912618L;

    public ItemList() {
    }

}
",package com.flickr4java.flickr.activity; import com.flickr4java.flickr.SearchResultList; public class ItemList<E> extends SearchResultList<Item> { private static final long serialVersionUID = 7330819045487912618L; public ItemList() { } },0 0 0 0 0 0 0 0,package com.flickr4java.flickr.activity; import com.flickr4java.flickr.SearchResultList; public class ItemList<E> extends SearchResultList<Item> { private static final long serialVersionUID = 7330819045487912618L; public ItemList() { } } ,package com.flickr4java.flickr.activity;  import com.flickr4java.flickr.SearchResultList;  public class ItemList<E> extends SearchResultList<Item> {  private static final long serialVersionUID = 7330819045487912618L;  public ItemList() { }  }  
src/main/java/com/flickr4java/flickr/auth/Auth.java,"

package com.flickr4java.flickr.auth;

import com.flickr4java.flickr.people.User;

import java.io.Serializable;

/**
 * @author Anthony Eden
 */
public class Auth implements Serializable {

    private static final long serialVersionUID = -2254618470673679663L;

    private String token;

    private String tokenSecret;

    private Permission permission;

    private User user;

    public Auth() {

    }

    public Auth(Permission permission, User user) {

        super();
        this.permission = permission;
        this.user = user;
    }

    /**
     * @return the tokenSecret
     */
    public String getTokenSecret() {
        return tokenSecret;
    }

    /**
     * @param tokenSecret
     *            the tokenSecret to set
     */
    public void setTokenSecret(String tokenSecret) {
        this.tokenSecret = tokenSecret;
    }

    public String getToken() {
        return token;
    }

    public void setToken(String token) {
        this.token = token;
    }

    public Permission getPermission() {
        return permission;
    }

    public void setPermission(Permission permission) {
        this.permission = permission;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

}
","package com.flickr4java.flickr.auth; import com.flickr4java.flickr.people.User; import java.io.Serializable; public class Auth implements Serializable { private static final long serialVersionUID = -2254618470673679663L; private String token; private String tokenSecret; private Permission permission; private User user; public Auth() { } public Auth(Permission permission, User user) { super(); this.permission = permission; this.user = user; } public String getTokenSecret() { return tokenSecret; } public void setTokenSecret(String tokenSecret) { this.tokenSecret = tokenSecret; } public String getToken() { return token; } public void setToken(String token) { this.token = token; } public Permission getPermission() { return permission; } public void setPermission(Permission permission) { this.permission = permission; } public User getUser() { return user; } public void setUser(User user) { this.user = user; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.auth; import com.flickr4java.flickr.people.User; import java.io.Serializable; public class Auth implements Serializable { private static final long serialVersionUID = -2254618470673679663L; private String token; private String tokenSecret; private Permission permission; private User user; public Auth() { } public Auth(Permission permission, User user) { super(); this.permission = permission; this.user = user; } public String getTokenSecret() { return tokenSecret; } public void setTokenSecret(String tokenSecret) { this.tokenSecret = tokenSecret; } public String getToken() { return token; } public void setToken(String token) { this.token = token; } public Permission getPermission() { return permission; } public void setPermission(Permission permission) { this.permission = permission; } public User getUser() { return user; } public void setUser(User user) { this.user = user; } } ","
 package com.flickr4java.flickr.auth;  import com.flickr4java.flickr.people.User;  import java.io.Serializable;  /**
 * @author Anthony Eden
 */ public class Auth implements Serializable {  private static final long serialVersionUID = -2254618470673679663L;  private String token;  private String tokenSecret;  private Permission permission;  private User user;  public Auth() {  }  public Auth(Permission permission, User user) {  super(); this.permission = permission; this.user = user; }  /**
     * @return the tokenSecret
     */ public String getTokenSecret() { return tokenSecret; }  /**
     * @param tokenSecret
     *            the tokenSecret to set
     */ public void setTokenSecret(String tokenSecret) { this.tokenSecret = tokenSecret; }  public String getToken() { return token; }  public void setToken(String token) { this.token = token; }  public Permission getPermission() { return permission; }  public void setPermission(Permission permission) { this.permission = permission; }  public User getUser() { return user; }  public void setUser(User user) { this.user = user; }  }  "
src/main/java/com/flickr4java/flickr/auth/AuthInterface.java,"

package com.flickr4java.flickr.auth;

import com.flickr4java.flickr.Flickr;
import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.FlickrRuntimeException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.people.User;
import com.flickr4java.flickr.util.ByteUtilities;
import com.flickr4java.flickr.util.XMLUtilities;
import com.github.scribejava.apis.FlickrApi;
import com.github.scribejava.core.builder.ServiceBuilder;
import com.github.scribejava.core.exceptions.OAuthException;
import com.github.scribejava.core.model.OAuth1RequestToken;
import com.github.scribejava.core.model.OAuth1Token;
import com.github.scribejava.core.oauth.OAuth10aService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Element;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Map;
import java.util.TreeMap;
import java.util.concurrent.ExecutionException;

/**
 * Authentication interface.
 * 
 * @author Anthony Eden
 */
public class AuthInterface {

    /**
     * The ""callback url"" passed to Flickr if not specified by caller.
     */
    private static final String OUT_OF_BOUND_AUTH_METHOD = ""oob"";

    private static final String METHOD_CHECK_TOKEN = ""flickr.auth.oauth.checkToken"";

    private static final String METHOD_EXCHANGE_TOKEN = ""flickr.auth.oauth.getAccessToken"";

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transportAPI;

    private final static Logger logger = LoggerFactory.getLogger(AuthInterface.class);

    private int maxGetTokenRetries = 3;

    /**
     * Construct the AuthInterface.
     * 
     * @param apiKey
     *            The API key
     * @param transport
     *            The Transport interface
     */
    public AuthInterface(String apiKey, String sharedSecret, Transport transport) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transport;
    }

    /**
     * Get the OAuth request token - this is step one of authorization.
     * 
     * @return the {@link OAuth1RequestToken}, store this for when the user returns from the Flickr website.
     */
    public OAuth1RequestToken getRequestToken() {

        return getRequestToken(null);
    }

    /**
     * Get the OAuth request token - this is step one of authorization.
     * 
     * @param callbackUrl
     *            optional callback URL - required for web auth flow, will be set to ""oob"" if not specified.
     * @return the {@link OAuth1RequestToken}, store this for when the user returns from the Flickr website.
     */
    public OAuth1RequestToken getRequestToken(String callbackUrl) {
        String callback = (callbackUrl != null) ? callbackUrl : OUT_OF_BOUND_AUTH_METHOD;

        OAuth10aService service = new ServiceBuilder(apiKey)
                .apiSecret(sharedSecret)
                .callback(callback)
                .build(FlickrApi.instance());

        try {
            return service.getRequestToken();
        } catch (IOException | InterruptedException | ExecutionException e) {
            throw new FlickrRuntimeException(e);
        }
    }

    /**
     * Get the auth URL, this is step two of authorization.
     * 
     * @param oAuthRequestToken
     *            the token from a {@link AuthInterface#getRequestToken} call.
     */
    public String getAuthorizationUrl(OAuth1RequestToken oAuthRequestToken, Permission permission) {

        OAuth10aService service = new ServiceBuilder(apiKey)
                .apiSecret(sharedSecret)
                .build(FlickrApi.instance());
        String authorizationUrl = service.getAuthorizationUrl(oAuthRequestToken);
        return String.format(""%s&perms=%s"", authorizationUrl, permission.toString());
    }

    /**
     * Trade the request token for an access token, this is step three of authorization.
     *  @param oAuthRequestToken
     *            this is the token returned by the {@link AuthInterface#getRequestToken} call.
     * @param verifier
     */
    @SuppressWarnings(""boxing"")
    public OAuth1Token getAccessToken(OAuth1RequestToken oAuthRequestToken, String verifier) {
        OAuth10aService service = new ServiceBuilder(apiKey)
                .apiSecret(sharedSecret)
                .build(FlickrApi.instance());

        // Flickr seems to return invalid token sometimes so retry a few times.
        // See http://www.flickr.com/groups/api/discuss/72157628028927244/
        OAuth1Token accessToken = null;
        boolean success = false;
        for (int i = 0; i < maxGetTokenRetries && !success; i++) {
            try {
                accessToken = service.getAccessToken(oAuthRequestToken, verifier);
                success = true;
            } catch (OAuthException | IOException | InterruptedException | ExecutionException e) {
                if (i == maxGetTokenRetries - 1) {
                    logger.error(String.format(""OAuthService.getAccessToken failing after %d tries, re-throwing exception"", i), e);
                    throw new FlickrRuntimeException(e);
                } else {
                    logger.warn(String.format(""OAuthService.getAccessToken failed, try number %d: %s"", i, e.getMessage()));
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException ie) {
                        // Do nothing
                    }
                }
            }
        }

        return accessToken;
    }

    /**
     * Returns the credentials attached to an OAuth authentication token.
     * 
     * @param accessToken
     *            The authentication token
     * @return The Auth object
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Auth checkToken(OAuth1Token accessToken) throws FlickrException {
        return checkToken(accessToken.getToken(), accessToken.getTokenSecret());
    }

    /**
     * 
     * @param authToken
     *            The authentication token
     * @param tokenSecret
     * @return The Auth object
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see ""http://www.flickr.com/services/api/flickr.auth.oauth.checkToken.html""
     */
    public Auth checkToken(String authToken, String tokenSecret) throws FlickrException {

        // Use TreeMap so keys are automatically sorted alphabetically
        Map<String, String> parameters = new TreeMap<String, String>();
        parameters.put(""method"", METHOD_CHECK_TOKEN);
        parameters.put(""oauth_token"", authToken);
        parameters.put(Flickr.API_KEY, apiKey);
        // This method call must be signed using Flickr (not OAuth) style signing
        parameters.put(""api_sig"", getSignature(sharedSecret, parameters));

        Response response = transportAPI.getNonOAuth(transportAPI.getPath(), parameters);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Auth auth = constructAuth(response, authToken, tokenSecret);
        return auth;
    }

    /**
     * Exchange an auth token from the old Authentication API, to an OAuth access token.
     * 
     * Calling this method will delete the auth token used to make the request.
     * 
     * @param authToken
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see ""http://www.flickr.com/services/api/flickr.auth.oauth.getAccessToken.html""
     */
    public OAuth1RequestToken exchangeAuthToken(String authToken) throws FlickrException {

        // Use TreeMap so keys are automatically sorted alphabetically
        Map<String, String> parameters = new TreeMap<String, String>();
        parameters.put(""method"", METHOD_EXCHANGE_TOKEN);
        parameters.put(Flickr.API_KEY, apiKey);
        // This method call must be signed using Flickr (not OAuth) style signing
        parameters.put(""api_sig"", getSignature(sharedSecret, parameters));

        Response response = transportAPI.getNonOAuth(transportAPI.getPath(), parameters);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        OAuth1RequestToken accessToken = constructToken(response);

        return accessToken;
    }

    /**
     * 
     * @param response
     * @param tokenSecret
     * @param authToken
     */
    private Auth constructAuth(Response response, String authToken, String tokenSecret) {
        Auth auth = new Auth();
        Element authElement = response.getPayload();
        auth.setToken(authToken);
        auth.setTokenSecret(tokenSecret);
        auth.setPermission(Permission.fromString(XMLUtilities.getChildValue(authElement, ""perms"")));

        Element userElement = XMLUtilities.getChild(authElement, ""user"");
        User user = new User();
        user.setId(userElement.getAttribute(""nsid""));
        user.setUsername(userElement.getAttribute(""username""));
        user.setRealName(userElement.getAttribute(""fullname""));
        auth.setUser(user);
        return auth;
    }

    /**
     * Construct a Access Token from a Flickr Response.
     * 
     * @param response
     */
    private OAuth1RequestToken constructToken(Response response) {
        Element authElement = response.getPayload();
        String oauthToken = XMLUtilities.getChildValue(authElement, ""oauth_token"");
        String oauthTokenSecret = XMLUtilities.getChildValue(authElement, ""oauth_token_secret"");

        OAuth1RequestToken token = new OAuth1RequestToken(oauthToken, oauthTokenSecret);
        return token;
    }

    /**
     * Get a signature for a list of parameters using the given shared secret.
     * 
     * @param sharedSecret
     *            The shared secret
     * @param params
     *            The parameters
     * @return The signature String
     */
    private String getSignature(String sharedSecret, Map<String, String> params) {
        StringBuffer buffer = new StringBuffer();
        buffer.append(sharedSecret);
        for (Map.Entry<String, String> entry : params.entrySet()) {
            buffer.append(entry.getKey());
            buffer.append(entry.getValue());
        }

        try {
            MessageDigest md = MessageDigest.getInstance(""MD5"");
            return ByteUtilities.toHexString(md.digest(buffer.toString().getBytes(""UTF-8"")));
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        } catch (UnsupportedEncodingException u) {
            throw new RuntimeException(u);
        }
    }

    public void setMaxGetTokenRetries(int maxGetTokenRetries) {

        this.maxGetTokenRetries = maxGetTokenRetries;
    }
}
","package com.flickr4java.flickr.auth; import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.FlickrRuntimeException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.util.ByteUtilities; import com.flickr4java.flickr.util.XMLUtilities; import com.github.scribejava.apis.FlickrApi; import com.github.scribejava.core.builder.ServiceBuilder; import com.github.scribejava.core.exceptions.OAuthException; import com.github.scribejava.core.model.OAuth1RequestToken; import com.github.scribejava.core.model.OAuth1Token; import com.github.scribejava.core.oauth.OAuth10aService; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.w3c.dom.Element; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.Map; import java.util.TreeMap; import java.util.concurrent.ExecutionException; public class AuthInterface { private static final String OUT_OF_BOUND_AUTH_METHOD = ""oob""; private static final String METHOD_CHECK_TOKEN = ""flickr.auth.oauth.checkToken""; private static final String METHOD_EXCHANGE_TOKEN = ""flickr.auth.oauth.getAccessToken""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; private final static Logger logger = LoggerFactory.getLogger(AuthInterface.class); private int maxGetTokenRetries = 3; public AuthInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transport; } public OAuth1RequestToken getRequestToken() { return getRequestToken(null); } public OAuth1RequestToken getRequestToken(String callbackUrl) { String callback = (callbackUrl != null) ? callbackUrl : OUT_OF_BOUND_AUTH_METHOD; OAuth10aService service = new ServiceBuilder(apiKey)
                .apiSecret(sharedSecret)
                .callback(callback)
                .build(FlickrApi.instance()); try { return service.getRequestToken(); } catch (IOException | InterruptedException | ExecutionException e) { throw new FlickrRuntimeException(e); } } public String getAuthorizationUrl(OAuth1RequestToken oAuthRequestToken, Permission permission) { OAuth10aService service = new ServiceBuilder(apiKey)
                .apiSecret(sharedSecret)
                .build(FlickrApi.instance()); String authorizationUrl = service.getAuthorizationUrl(oAuthRequestToken); return String.format(""%s&perms=%s"", authorizationUrl, permission.toString()); } @SuppressWarnings(""boxing"")
    public OAuth1Token getAccessToken(OAuth1RequestToken oAuthRequestToken, String verifier) { OAuth10aService service = new ServiceBuilder(apiKey)
                .apiSecret(sharedSecret)
                .build(FlickrApi.instance()); OAuth1Token accessToken = null; boolean success = false; for (int i = 0; i < maxGetTokenRetries && !success; i++) { try { accessToken = service.getAccessToken(oAuthRequestToken, verifier); success = true; } catch (OAuthException | IOException | InterruptedException | ExecutionException e) { if (i == maxGetTokenRetries - 1) { throw new FlickrRuntimeException(e); } else { try { Thread.sleep(500); } catch (InterruptedException ie) { } } } } return accessToken; } public Auth checkToken(OAuth1Token accessToken) throws FlickrException { return checkToken(accessToken.getToken(), accessToken.getTokenSecret()); } public Auth checkToken(String authToken, String tokenSecret) throws FlickrException { Map<String, String> parameters = new TreeMap<String, String>(); parameters.put(""method"", METHOD_CHECK_TOKEN); parameters.put(""oauth_token"", authToken); parameters.put(Flickr.API_KEY, apiKey); parameters.put(""api_sig"", getSignature(sharedSecret, parameters)); Response response = transportAPI.getNonOAuth(transportAPI.getPath(), parameters); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Auth auth = constructAuth(response, authToken, tokenSecret); return auth; } public OAuth1RequestToken exchangeAuthToken(String authToken) throws FlickrException { Map<String, String> parameters = new TreeMap<String, String>(); parameters.put(""method"", METHOD_EXCHANGE_TOKEN); parameters.put(Flickr.API_KEY, apiKey); parameters.put(""api_sig"", getSignature(sharedSecret, parameters)); Response response = transportAPI.getNonOAuth(transportAPI.getPath(), parameters); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } OAuth1RequestToken accessToken = constructToken(response); return accessToken; } private Auth constructAuth(Response response, String authToken, String tokenSecret) { Auth auth = new Auth(); Element authElement = response.getPayload(); auth.setToken(authToken); auth.setTokenSecret(tokenSecret); auth.setPermission(Permission.fromString(XMLUtilities.getChildValue(authElement, ""perms""))); Element userElement = XMLUtilities.getChild(authElement, ""user""); User user = new User(); user.setId(userElement.getAttribute(""nsid"")); user.setUsername(userElement.getAttribute(""username"")); user.setRealName(userElement.getAttribute(""fullname"")); auth.setUser(user); return auth; } private OAuth1RequestToken constructToken(Response response) { Element authElement = response.getPayload(); String oauthToken = XMLUtilities.getChildValue(authElement, ""oauth_token""); String oauthTokenSecret = XMLUtilities.getChildValue(authElement, ""oauth_token_secret""); OAuth1RequestToken token = new OAuth1RequestToken(oauthToken, oauthTokenSecret); return token; } private String getSignature(String sharedSecret, Map<String, String> params) { StringBuffer buffer = new StringBuffer(); buffer.append(sharedSecret); for (Map.Entry<String, String> entry : params.entrySet()) { buffer.append(entry.getKey()); buffer.append(entry.getValue()); } try { MessageDigest md = MessageDigest.getInstance(""MD5""); return ByteUtilities.toHexString(md.digest(buffer.toString().getBytes(""UTF-8""))); } catch (NoSuchAlgorithmException e) { throw new RuntimeException(e); } catch (UnsupportedEncodingException u) { throw new RuntimeException(u); } } public void setMaxGetTokenRetries(int maxGetTokenRetries) { this.maxGetTokenRetries = maxGetTokenRetries; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.auth; import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.FlickrRuntimeException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.util.ByteUtilities; import com.flickr4java.flickr.util.XMLUtilities; import com.github.scribejava.apis.FlickrApi; import com.github.scribejava.core.builder.ServiceBuilder; import com.github.scribejava.core.exceptions.OAuthException; import com.github.scribejava.core.model.OAuth1RequestToken; import com.github.scribejava.core.model.OAuth1Token; import com.github.scribejava.core.oauth.OAuth10aService; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.w3c.dom.Element; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.Map; import java.util.TreeMap; import java.util.concurrent.ExecutionException; public class AuthInterface { private static final String OUT_OF_BOUND_AUTH_METHOD = ""oob""; private static final String METHOD_CHECK_TOKEN = ""flickr.auth.oauth.checkToken""; private static final String METHOD_EXCHANGE_TOKEN = ""flickr.auth.oauth.getAccessToken""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; private final static Logger logger = LoggerFactory.getLogger(AuthInterface.class); private int maxGetTokenRetries = 3; public AuthInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transport; } public OAuth1RequestToken getRequestToken() { return getRequestToken(null); } public OAuth1RequestToken getRequestToken(String callbackUrl) { String callback = (callbackUrl != null) ? callbackUrl : OUT_OF_BOUND_AUTH_METHOD; OAuth10aService service = new ServiceBuilder(apiKey)
                .apiSecret(sharedSecret)
                .callback(callback)
                .build(FlickrApi.instance()); try { return service.getRequestToken(); } catch (IOException | InterruptedException | ExecutionException e) { throw new FlickrRuntimeException(e); } } public String getAuthorizationUrl(OAuth1RequestToken oAuthRequestToken, Permission permission) { OAuth10aService service = new ServiceBuilder(apiKey)
                .apiSecret(sharedSecret)
                .build(FlickrApi.instance()); String authorizationUrl = service.getAuthorizationUrl(oAuthRequestToken); return String.format(""%s&perms=%s"", authorizationUrl, permission.toString()); } @SuppressWarnings(""boxing"")
    public OAuth1Token getAccessToken(OAuth1RequestToken oAuthRequestToken, String verifier) { OAuth10aService service = new ServiceBuilder(apiKey)
                .apiSecret(sharedSecret)
                .build(FlickrApi.instance()); OAuth1Token accessToken = null; boolean success = false; for (int i = 0; i < maxGetTokenRetries && !success; i++) { try { accessToken = service.getAccessToken(oAuthRequestToken, verifier); success = true; } catch (OAuthException | IOException | InterruptedException | ExecutionException e) { if (i == maxGetTokenRetries - 1) { <FILL_ME> throw new FlickrRuntimeException(e); } else { <FILL_ME> try { Thread.sleep(500); } catch (InterruptedException ie) { } } } } return accessToken; } public Auth checkToken(OAuth1Token accessToken) throws FlickrException { return checkToken(accessToken.getToken(), accessToken.getTokenSecret()); } public Auth checkToken(String authToken, String tokenSecret) throws FlickrException { Map<String, String> parameters = new TreeMap<String, String>(); parameters.put(""method"", METHOD_CHECK_TOKEN); parameters.put(""oauth_token"", authToken); parameters.put(Flickr.API_KEY, apiKey); parameters.put(""api_sig"", getSignature(sharedSecret, parameters)); Response response = transportAPI.getNonOAuth(transportAPI.getPath(), parameters); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Auth auth = constructAuth(response, authToken, tokenSecret); return auth; } public OAuth1RequestToken exchangeAuthToken(String authToken) throws FlickrException { Map<String, String> parameters = new TreeMap<String, String>(); parameters.put(""method"", METHOD_EXCHANGE_TOKEN); parameters.put(Flickr.API_KEY, apiKey); parameters.put(""api_sig"", getSignature(sharedSecret, parameters)); Response response = transportAPI.getNonOAuth(transportAPI.getPath(), parameters); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } OAuth1RequestToken accessToken = constructToken(response); return accessToken; } private Auth constructAuth(Response response, String authToken, String tokenSecret) { Auth auth = new Auth(); Element authElement = response.getPayload(); auth.setToken(authToken); auth.setTokenSecret(tokenSecret); auth.setPermission(Permission.fromString(XMLUtilities.getChildValue(authElement, ""perms""))); Element userElement = XMLUtilities.getChild(authElement, ""user""); User user = new User(); user.setId(userElement.getAttribute(""nsid"")); user.setUsername(userElement.getAttribute(""username"")); user.setRealName(userElement.getAttribute(""fullname"")); auth.setUser(user); return auth; } private OAuth1RequestToken constructToken(Response response) { Element authElement = response.getPayload(); String oauthToken = XMLUtilities.getChildValue(authElement, ""oauth_token""); String oauthTokenSecret = XMLUtilities.getChildValue(authElement, ""oauth_token_secret""); OAuth1RequestToken token = new OAuth1RequestToken(oauthToken, oauthTokenSecret); return token; } private String getSignature(String sharedSecret, Map<String, String> params) { StringBuffer buffer = new StringBuffer(); buffer.append(sharedSecret); for (Map.Entry<String, String> entry : params.entrySet()) { buffer.append(entry.getKey()); buffer.append(entry.getValue()); } try { MessageDigest md = MessageDigest.getInstance(""MD5""); return ByteUtilities.toHexString(md.digest(buffer.toString().getBytes(""UTF-8""))); } catch (NoSuchAlgorithmException e) { throw new RuntimeException(e); } catch (UnsupportedEncodingException u) { throw new RuntimeException(u); } } public void setMaxGetTokenRetries(int maxGetTokenRetries) { this.maxGetTokenRetries = maxGetTokenRetries; } } ","
 package com.flickr4java.flickr.auth;  import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.FlickrRuntimeException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.util.ByteUtilities; import com.flickr4java.flickr.util.XMLUtilities; import com.github.scribejava.apis.FlickrApi; import com.github.scribejava.core.builder.ServiceBuilder; import com.github.scribejava.core.exceptions.OAuthException; import com.github.scribejava.core.model.OAuth1RequestToken; import com.github.scribejava.core.model.OAuth1Token; import com.github.scribejava.core.oauth.OAuth10aService; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.w3c.dom.Element;  import java.io.IOException; import java.io.UnsupportedEncodingException; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.Map; import java.util.TreeMap; import java.util.concurrent.ExecutionException;  /**
 * Authentication interface.
 * 
 * @author Anthony Eden
 */ public class AuthInterface {  /**
     * The ""callback url"" passed to Flickr if not specified by caller.
     */ private static final String OUT_OF_BOUND_AUTH_METHOD = ""oob"";  private static final String METHOD_CHECK_TOKEN = ""flickr.auth.oauth.checkToken"";  private static final String METHOD_EXCHANGE_TOKEN = ""flickr.auth.oauth.getAccessToken"";  private final String apiKey;  private final String sharedSecret;  private final Transport transportAPI;  private final static Logger logger = LoggerFactory.getLogger(AuthInterface.class);  private int maxGetTokenRetries = 3;  /**
     * Construct the AuthInterface.
     * 
     * @param apiKey
     *            The API key
     * @param transport
     *            The Transport interface
     */ public AuthInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transport; }  /**
     * Get the OAuth request token - this is step one of authorization.
     * 
     * @return the {@link OAuth1RequestToken}, store this for when the user returns from the Flickr website.
     */ public OAuth1RequestToken getRequestToken() {  return getRequestToken(null); }  /**
     * Get the OAuth request token - this is step one of authorization.
     * 
     * @param callbackUrl
     *            optional callback URL - required for web auth flow, will be set to ""oob"" if not specified.
     * @return the {@link OAuth1RequestToken}, store this for when the user returns from the Flickr website.
     */ public OAuth1RequestToken getRequestToken(String callbackUrl) { String callback = (callbackUrl != null) ? callbackUrl : OUT_OF_BOUND_AUTH_METHOD;  OAuth10aService service = new ServiceBuilder(apiKey)
                .apiSecret(sharedSecret)
                .callback(callback)
                .build(FlickrApi.instance());  try { return service.getRequestToken(); } catch (IOException | InterruptedException | ExecutionException e) { throw new FlickrRuntimeException(e); } }  /**
     * Get the auth URL, this is step two of authorization.
     * 
     * @param oAuthRequestToken
     *            the token from a {@link AuthInterface#getRequestToken} call.
     */ public String getAuthorizationUrl(OAuth1RequestToken oAuthRequestToken, Permission permission) {  OAuth10aService service = new ServiceBuilder(apiKey)
                .apiSecret(sharedSecret)
                .build(FlickrApi.instance()); String authorizationUrl = service.getAuthorizationUrl(oAuthRequestToken); return String.format(""%s&perms=%s"", authorizationUrl, permission.toString()); }  /**
     * Trade the request token for an access token, this is step three of authorization.
     *  @param oAuthRequestToken
     *            this is the token returned by the {@link AuthInterface#getRequestToken} call.
     * @param verifier
     */ @SuppressWarnings(""boxing"")
    public OAuth1Token getAccessToken(OAuth1RequestToken oAuthRequestToken, String verifier) { OAuth10aService service = new ServiceBuilder(apiKey)
                .apiSecret(sharedSecret)
                .build(FlickrApi.instance());  // Flickr seems to return invalid token sometimes so retry a few times. // See http://www.flickr.com/groups/api/discuss/72157628028927244/ OAuth1Token accessToken = null; boolean success = false; for (int i = 0; i < maxGetTokenRetries && !success; i++) { try { accessToken = service.getAccessToken(oAuthRequestToken, verifier); success = true; } catch (OAuthException | IOException | InterruptedException | ExecutionException e) { if (i == maxGetTokenRetries - 1) { <FILL_ME> throw new FlickrRuntimeException(e); } else { <FILL_ME> try { Thread.sleep(500); } catch (InterruptedException ie) { // Do nothing } } } }  return accessToken; }  /**
     * Returns the credentials attached to an OAuth authentication token.
     * 
     * @param accessToken
     *            The authentication token
     * @return The Auth object
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Auth checkToken(OAuth1Token accessToken) throws FlickrException { return checkToken(accessToken.getToken(), accessToken.getTokenSecret()); }  /**
     * 
     * @param authToken
     *            The authentication token
     * @param tokenSecret
     * @return The Auth object
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see ""http://www.flickr.com/services/api/flickr.auth.oauth.checkToken.html""
     */ public Auth checkToken(String authToken, String tokenSecret) throws FlickrException {  // Use TreeMap so keys are automatically sorted alphabetically Map<String, String> parameters = new TreeMap<String, String>(); parameters.put(""method"", METHOD_CHECK_TOKEN); parameters.put(""oauth_token"", authToken); parameters.put(Flickr.API_KEY, apiKey); // This method call must be signed using Flickr (not OAuth) style signing parameters.put(""api_sig"", getSignature(sharedSecret, parameters));  Response response = transportAPI.getNonOAuth(transportAPI.getPath(), parameters); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Auth auth = constructAuth(response, authToken, tokenSecret); return auth; }  /**
     * Exchange an auth token from the old Authentication API, to an OAuth access token.
     * 
     * Calling this method will delete the auth token used to make the request.
     * 
     * @param authToken
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see ""http://www.flickr.com/services/api/flickr.auth.oauth.getAccessToken.html""
     */ public OAuth1RequestToken exchangeAuthToken(String authToken) throws FlickrException {  // Use TreeMap so keys are automatically sorted alphabetically Map<String, String> parameters = new TreeMap<String, String>(); parameters.put(""method"", METHOD_EXCHANGE_TOKEN); parameters.put(Flickr.API_KEY, apiKey); // This method call must be signed using Flickr (not OAuth) style signing parameters.put(""api_sig"", getSignature(sharedSecret, parameters));  Response response = transportAPI.getNonOAuth(transportAPI.getPath(), parameters); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  OAuth1RequestToken accessToken = constructToken(response);  return accessToken; }  /**
     * 
     * @param response
     * @param tokenSecret
     * @param authToken
     */ private Auth constructAuth(Response response, String authToken, String tokenSecret) { Auth auth = new Auth(); Element authElement = response.getPayload(); auth.setToken(authToken); auth.setTokenSecret(tokenSecret); auth.setPermission(Permission.fromString(XMLUtilities.getChildValue(authElement, ""perms"")));  Element userElement = XMLUtilities.getChild(authElement, ""user""); User user = new User(); user.setId(userElement.getAttribute(""nsid"")); user.setUsername(userElement.getAttribute(""username"")); user.setRealName(userElement.getAttribute(""fullname"")); auth.setUser(user); return auth; }  /**
     * Construct a Access Token from a Flickr Response.
     * 
     * @param response
     */ private OAuth1RequestToken constructToken(Response response) { Element authElement = response.getPayload(); String oauthToken = XMLUtilities.getChildValue(authElement, ""oauth_token""); String oauthTokenSecret = XMLUtilities.getChildValue(authElement, ""oauth_token_secret"");  OAuth1RequestToken token = new OAuth1RequestToken(oauthToken, oauthTokenSecret); return token; }  /**
     * Get a signature for a list of parameters using the given shared secret.
     * 
     * @param sharedSecret
     *            The shared secret
     * @param params
     *            The parameters
     * @return The signature String
     */ private String getSignature(String sharedSecret, Map<String, String> params) { StringBuffer buffer = new StringBuffer(); buffer.append(sharedSecret); for (Map.Entry<String, String> entry : params.entrySet()) { buffer.append(entry.getKey()); buffer.append(entry.getValue()); }  try { MessageDigest md = MessageDigest.getInstance(""MD5""); return ByteUtilities.toHexString(md.digest(buffer.toString().getBytes(""UTF-8""))); } catch (NoSuchAlgorithmException e) { throw new RuntimeException(e); } catch (UnsupportedEncodingException u) { throw new RuntimeException(u); } }  public void setMaxGetTokenRetries(int maxGetTokenRetries) {  this.maxGetTokenRetries = maxGetTokenRetries; } }  "
src/main/java/com/flickr4java/flickr/auth/Permission.java,"

package com.flickr4java.flickr.auth;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;

/**
 * Enum class for Permissions defined for auth results.
 * 
 * @author Anthony Eden
 * 
 *         TODO Make into a proper enum.
 */
public class Permission implements Serializable {

    /**
     * 
     */
    private static final long serialVersionUID = -5384461370301078353L;

    /**
     * Type value for no permissions If no permissions are requested, the application will only display public photos.
     */
    public static final int NONE_TYPE = 0;

    /**
     * Type value for Read Permission. You will be able to see all your photos via the application. (This includes your private photos.)
     */
    public static final int READ_TYPE = 1;

    /**
     * Type value for Write Permission (and Read). You will be able to see all your photos, upload new photos, and add, edit or delete photo metadata (titles,
     * descriptions, tags, etc.).
     */
    public static final int WRITE_TYPE = 2;

    /**
     * Type value for Delete Permission (and Write, Read). You are able to delete Flickr photos via the application.
     */
    public static final int DELETE_TYPE = 3;

    /**
     * No permissions. If no permissions are requested, the application will only display public photos.
     */
    public static final Permission NONE = new Permission(NONE_TYPE);

    /**
     * Read Permission. You will be able to see all your photos via the application. (This includes your private photos.)
     */
    public static final Permission READ = new Permission(READ_TYPE);

    /**
     * Write (and Read). You will be able to see all your photos, upload new photos, and add, edit or delete photo metadata (titles, descriptions, tags, etc.).
     */
    public static final Permission WRITE = new Permission(WRITE_TYPE);

    /**
     * Delete (and Write, Read). You are able to delete Flickr photos via the application.
     */
    public static final Permission DELETE = new Permission(DELETE_TYPE);

    private static final Map<String, Permission> stringToPermissionMap = new HashMap<String, Permission>();
    static {
        stringToPermissionMap.put(""none"", NONE);
        stringToPermissionMap.put(""read"", READ);
        stringToPermissionMap.put(""write"", WRITE);
        stringToPermissionMap.put(""delete"", DELETE);
    }

    private final int type;

    private Permission(int type) {
        this.type = type;
    }

    public int getType() {
        return type;
    }

    /**
     * Convert the permission String to a Permission object.
     * 
     * @param permission
     *            The permission String
     * @return The Permission object
     */
    public static Permission fromString(String permission) {
        return (Permission) stringToPermissionMap.get(permission.toLowerCase());
    }

    @Override
    public String toString() {
        switch (type) {
        case NONE_TYPE:
            return ""none"";
        case READ_TYPE:
            return ""read"";
        case WRITE_TYPE:
            return ""write"";
        case DELETE_TYPE:
            return ""delete"";
        default:
            throw new IllegalStateException(""Unsupported type: "" + type);
        }
    }

}
","package com.flickr4java.flickr.auth; import java.io.Serializable; import java.util.HashMap; import java.util.Map; public class Permission implements Serializable { private static final long serialVersionUID = -5384461370301078353L; public static final int NONE_TYPE = 0; public static final int READ_TYPE = 1; public static final int WRITE_TYPE = 2; public static final int DELETE_TYPE = 3; public static final Permission NONE = new Permission(NONE_TYPE); public static final Permission READ = new Permission(READ_TYPE); public static final Permission WRITE = new Permission(WRITE_TYPE); public static final Permission DELETE = new Permission(DELETE_TYPE); private static final Map<String, Permission> stringToPermissionMap = new HashMap<String, Permission>(); static { stringToPermissionMap.put(""none"", NONE); stringToPermissionMap.put(""read"", READ); stringToPermissionMap.put(""write"", WRITE); stringToPermissionMap.put(""delete"", DELETE); } private final int type; private Permission(int type) { this.type = type; } public int getType() { return type; } public static Permission fromString(String permission) { return (Permission) stringToPermissionMap.get(permission.toLowerCase()); } @Override
    public String toString() { switch (type) { case NONE_TYPE:
            return ""none""; case READ_TYPE:
            return ""read""; case WRITE_TYPE:
            return ""write""; case DELETE_TYPE:
            return ""delete""; default:
            throw new IllegalStateException(""Unsupported type: "" + type); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.auth; import java.io.Serializable; import java.util.HashMap; import java.util.Map; public class Permission implements Serializable { private static final long serialVersionUID = -5384461370301078353L; public static final int NONE_TYPE = 0; public static final int READ_TYPE = 1; public static final int WRITE_TYPE = 2; public static final int DELETE_TYPE = 3; public static final Permission NONE = new Permission(NONE_TYPE); public static final Permission READ = new Permission(READ_TYPE); public static final Permission WRITE = new Permission(WRITE_TYPE); public static final Permission DELETE = new Permission(DELETE_TYPE); private static final Map<String, Permission> stringToPermissionMap = new HashMap<String, Permission>(); static { stringToPermissionMap.put(""none"", NONE); stringToPermissionMap.put(""read"", READ); stringToPermissionMap.put(""write"", WRITE); stringToPermissionMap.put(""delete"", DELETE); } private final int type; private Permission(int type) { this.type = type; } public int getType() { return type; } public static Permission fromString(String permission) { return (Permission) stringToPermissionMap.get(permission.toLowerCase()); } @Override
    public String toString() { switch (type) { case NONE_TYPE:
            return ""none""; case READ_TYPE:
            return ""read""; case WRITE_TYPE:
            return ""write""; case DELETE_TYPE:
            return ""delete""; default:
            throw new IllegalStateException(""Unsupported type: "" + type); } } } ","
 package com.flickr4java.flickr.auth;  import java.io.Serializable; import java.util.HashMap; import java.util.Map;  /**
 * Enum class for Permissions defined for auth results.
 * 
 * @author Anthony Eden
 * 
 *         TODO Make into a proper enum.
 */ public class Permission implements Serializable {  /**
     * 
     */ private static final long serialVersionUID = -5384461370301078353L;  /**
     * Type value for no permissions If no permissions are requested, the application will only display public photos.
     */ public static final int NONE_TYPE = 0;  /**
     * Type value for Read Permission. You will be able to see all your photos via the application. (This includes your private photos.)
     */ public static final int READ_TYPE = 1;  /**
     * Type value for Write Permission (and Read). You will be able to see all your photos, upload new photos, and add, edit or delete photo metadata (titles,
     * descriptions, tags, etc.).
     */ public static final int WRITE_TYPE = 2;  /**
     * Type value for Delete Permission (and Write, Read). You are able to delete Flickr photos via the application.
     */ public static final int DELETE_TYPE = 3;  /**
     * No permissions. If no permissions are requested, the application will only display public photos.
     */ public static final Permission NONE = new Permission(NONE_TYPE);  /**
     * Read Permission. You will be able to see all your photos via the application. (This includes your private photos.)
     */ public static final Permission READ = new Permission(READ_TYPE);  /**
     * Write (and Read). You will be able to see all your photos, upload new photos, and add, edit or delete photo metadata (titles, descriptions, tags, etc.).
     */ public static final Permission WRITE = new Permission(WRITE_TYPE);  /**
     * Delete (and Write, Read). You are able to delete Flickr photos via the application.
     */ public static final Permission DELETE = new Permission(DELETE_TYPE);  private static final Map<String, Permission> stringToPermissionMap = new HashMap<String, Permission>(); static { stringToPermissionMap.put(""none"", NONE); stringToPermissionMap.put(""read"", READ); stringToPermissionMap.put(""write"", WRITE); stringToPermissionMap.put(""delete"", DELETE); }  private final int type;  private Permission(int type) { this.type = type; }  public int getType() { return type; }  /**
     * Convert the permission String to a Permission object.
     * 
     * @param permission
     *            The permission String
     * @return The Permission object
     */ public static Permission fromString(String permission) { return (Permission) stringToPermissionMap.get(permission.toLowerCase()); }  @Override
    public String toString() { switch (type) { case NONE_TYPE:
            return ""none""; case READ_TYPE:
            return ""read""; case WRITE_TYPE:
            return ""write""; case DELETE_TYPE:
            return ""delete""; default:
            throw new IllegalStateException(""Unsupported type: "" + type); } }  }  "
src/main/java/com/flickr4java/flickr/blogs/Blog.java,"
package com.flickr4java.flickr.blogs;

import java.math.BigDecimal;

/**
 * Class representing a Flickr blog configuration.
 * 
 * @author Anthony Eden
 */
public class Blog {

    private BigDecimal id;

    private String name;

    private boolean needPassword;

    private String url;

    public Blog() {

    }

    public BigDecimal getId() {
        return id;
    }

    public void setId(BigDecimal id) {
        this.id = id;
    }

    public void setId(String id) {
        if (id != null) {
            setId(new BigDecimal(id));
        }
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public boolean isNeedPassword() {
        return needPassword;
    }

    public void setNeedPassword(boolean needPassword) {
        this.needPassword = needPassword;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

}
",package com.flickr4java.flickr.blogs; import java.math.BigDecimal; public class Blog { private BigDecimal id; private String name; private boolean needPassword; private String url; public Blog() { } public BigDecimal getId() { return id; } public void setId(BigDecimal id) { this.id = id; } public void setId(String id) { if (id != null) { setId(new BigDecimal(id)); } } public String getName() { return name; } public void setName(String name) { this.name = name; } public boolean isNeedPassword() { return needPassword; } public void setNeedPassword(boolean needPassword) { this.needPassword = needPassword; } public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.blogs; import java.math.BigDecimal; public class Blog { private BigDecimal id; private String name; private boolean needPassword; private String url; public Blog() { } public BigDecimal getId() { return id; } public void setId(BigDecimal id) { this.id = id; } public void setId(String id) { if (id != null) { setId(new BigDecimal(id)); } } public String getName() { return name; } public void setName(String name) { this.name = name; } public boolean isNeedPassword() { return needPassword; } public void setNeedPassword(boolean needPassword) { this.needPassword = needPassword; } public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } } ," package com.flickr4java.flickr.blogs;  import java.math.BigDecimal;  /**
 * Class representing a Flickr blog configuration.
 * 
 * @author Anthony Eden
 */ public class Blog {  private BigDecimal id;  private String name;  private boolean needPassword;  private String url;  public Blog() {  }  public BigDecimal getId() { return id; }  public void setId(BigDecimal id) { this.id = id; }  public void setId(String id) { if (id != null) { setId(new BigDecimal(id)); } }  public String getName() { return name; }  public void setName(String name) { this.name = name; }  public boolean isNeedPassword() { return needPassword; }  public void setNeedPassword(boolean needPassword) { this.needPassword = needPassword; }  public String getUrl() { return url; }  public void setUrl(String url) { this.url = url; }  }  "
src/main/java/com/flickr4java/flickr/blogs/BlogsInterface.java,"
package com.flickr4java.flickr.blogs;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.util.XMLUtilities;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Interface for working with Flickr blog configurations.
 * 
 * @author Anthony Eden
 * @version $Id: BlogsInterface.java,v 1.14 2009/07/11 20:30:27 x-mago Exp $
 */
public class BlogsInterface {

    private static final String METHOD_GET_SERVICES = ""flickr.blogs.getServices"";

    private static final String METHOD_GET_LIST = ""flickr.blogs.getList"";

    private static final String METHOD_POST_PHOTO = ""flickr.blogs.postPhoto"";

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transportAPI;

    public BlogsInterface(String apiKey, String sharedSecret, Transport transport) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transport;
    }

    /**
     * Return a list of Flickr supported blogging services.
     * 
     * This method does not require authentication.
     * 
     * @return List of Services
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Collection<Service> getServices() throws FlickrException {
        List<Service> list = new ArrayList<Service>();
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_SERVICES);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element servicesElement = response.getPayload();
        NodeList serviceNodes = servicesElement.getElementsByTagName(""service"");
        for (int i = 0; i < serviceNodes.getLength(); i++) {
            Element serviceElement = (Element) serviceNodes.item(i);
            Service srv = new Service();
            srv.setId(serviceElement.getAttribute(""id""));
            srv.setName(XMLUtilities.getValue(serviceElement));
            list.add(srv);
        }
        return list;
    }

    /**
     * Post the specified photo to a blog. Note that the Photo.title and Photo.description are used for the blog entry title and body respectively.
     * 
     * @param photo
     *            The photo metadata
     * @param blogId
     *            The blog ID
     * @param blogPassword
     *            The blog password
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void postPhoto(Photo photo, String blogId, String blogPassword) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_POST_PHOTO);

        parameters.put(""blog_id"", blogId);
        parameters.put(""photo_id"", photo.getId());
        parameters.put(""title"", photo.getTitle());
        parameters.put(""description"", photo.getDescription());
        if (blogPassword != null) {
            parameters.put(""blog_password"", blogPassword);
        }

        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Post the specified photo to a blog.
     * 
     * @param photo
     *            The photo metadata
     * @param blogId
     *            The blog ID
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void postPhoto(Photo photo, String blogId) throws FlickrException {
        postPhoto(photo, blogId, null);
    }

    /**
     * Get the collection of configured blogs for the calling user.
     * 
     * @return The Collection of configured blogs
     */
    public Collection<Blog> getList() throws FlickrException {
        List<Blog> blogs = new ArrayList<Blog>();

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_LIST);

        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element blogsElement = response.getPayload();
        NodeList blogNodes = blogsElement.getElementsByTagName(""blog"");
        for (int i = 0; i < blogNodes.getLength(); i++) {
            Element blogElement = (Element) blogNodes.item(i);
            Blog blog = new Blog();
            blog.setId(blogElement.getAttribute(""id""));
            blog.setName(blogElement.getAttribute(""name""));
            blog.setNeedPassword(""1"".equals(blogElement.getAttribute(""needspassword"")));
            blog.setUrl(blogElement.getAttribute(""url""));
            blogs.add(blog);
        }
        return blogs;
    }
}
","package com.flickr4java.flickr.blogs; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.List; import java.util.Map; public class BlogsInterface { private static final String METHOD_GET_SERVICES = ""flickr.blogs.getServices""; private static final String METHOD_GET_LIST = ""flickr.blogs.getList""; private static final String METHOD_POST_PHOTO = ""flickr.blogs.postPhoto""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public BlogsInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transport; } public Collection<Service> getServices() throws FlickrException { List<Service> list = new ArrayList<Service>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_SERVICES); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element servicesElement = response.getPayload(); NodeList serviceNodes = servicesElement.getElementsByTagName(""service""); for (int i = 0; i < serviceNodes.getLength(); i++) { Element serviceElement = (Element) serviceNodes.item(i); Service srv = new Service(); srv.setId(serviceElement.getAttribute(""id"")); srv.setName(XMLUtilities.getValue(serviceElement)); list.add(srv); } return list; } public void postPhoto(Photo photo, String blogId, String blogPassword) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_POST_PHOTO); parameters.put(""blog_id"", blogId); parameters.put(""photo_id"", photo.getId()); parameters.put(""title"", photo.getTitle()); parameters.put(""description"", photo.getDescription()); if (blogPassword != null) { parameters.put(""blog_password"", blogPassword); } Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void postPhoto(Photo photo, String blogId) throws FlickrException { postPhoto(photo, blogId, null); } public Collection<Blog> getList() throws FlickrException { List<Blog> blogs = new ArrayList<Blog>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element blogsElement = response.getPayload(); NodeList blogNodes = blogsElement.getElementsByTagName(""blog""); for (int i = 0; i < blogNodes.getLength(); i++) { Element blogElement = (Element) blogNodes.item(i); Blog blog = new Blog(); blog.setId(blogElement.getAttribute(""id"")); blog.setName(blogElement.getAttribute(""name"")); blog.setNeedPassword(""1"".equals(blogElement.getAttribute(""needspassword""))); blog.setUrl(blogElement.getAttribute(""url"")); blogs.add(blog); } return blogs; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.blogs; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.List; import java.util.Map; public class BlogsInterface { private static final String METHOD_GET_SERVICES = ""flickr.blogs.getServices""; private static final String METHOD_GET_LIST = ""flickr.blogs.getList""; private static final String METHOD_POST_PHOTO = ""flickr.blogs.postPhoto""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public BlogsInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transport; } public Collection<Service> getServices() throws FlickrException { List<Service> list = new ArrayList<Service>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_SERVICES); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element servicesElement = response.getPayload(); NodeList serviceNodes = servicesElement.getElementsByTagName(""service""); for (int i = 0; i < serviceNodes.getLength(); i++) { Element serviceElement = (Element) serviceNodes.item(i); Service srv = new Service(); srv.setId(serviceElement.getAttribute(""id"")); srv.setName(XMLUtilities.getValue(serviceElement)); list.add(srv); } return list; } public void postPhoto(Photo photo, String blogId, String blogPassword) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_POST_PHOTO); parameters.put(""blog_id"", blogId); parameters.put(""photo_id"", photo.getId()); parameters.put(""title"", photo.getTitle()); parameters.put(""description"", photo.getDescription()); if (blogPassword != null) { parameters.put(""blog_password"", blogPassword); } Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void postPhoto(Photo photo, String blogId) throws FlickrException { postPhoto(photo, blogId, null); } public Collection<Blog> getList() throws FlickrException { List<Blog> blogs = new ArrayList<Blog>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element blogsElement = response.getPayload(); NodeList blogNodes = blogsElement.getElementsByTagName(""blog""); for (int i = 0; i < blogNodes.getLength(); i++) { Element blogElement = (Element) blogNodes.item(i); Blog blog = new Blog(); blog.setId(blogElement.getAttribute(""id"")); blog.setName(blogElement.getAttribute(""name"")); blog.setNeedPassword(""1"".equals(blogElement.getAttribute(""needspassword""))); blog.setUrl(blogElement.getAttribute(""url"")); blogs.add(blog); } return blogs; } } "," package com.flickr4java.flickr.blogs;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.util.XMLUtilities;  import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.List; import java.util.Map;  /**
 * Interface for working with Flickr blog configurations.
 * 
 * @author Anthony Eden
 * @version $Id: BlogsInterface.java,v 1.14 2009/07/11 20:30:27 x-mago Exp $
 */ public class BlogsInterface {  private static final String METHOD_GET_SERVICES = ""flickr.blogs.getServices"";  private static final String METHOD_GET_LIST = ""flickr.blogs.getList"";  private static final String METHOD_POST_PHOTO = ""flickr.blogs.postPhoto"";  private final String apiKey;  private final String sharedSecret;  private final Transport transportAPI;  public BlogsInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transport; }  /**
     * Return a list of Flickr supported blogging services.
     * 
     * This method does not require authentication.
     * 
     * @return List of Services
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Collection<Service> getServices() throws FlickrException { List<Service> list = new ArrayList<Service>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_SERVICES);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element servicesElement = response.getPayload(); NodeList serviceNodes = servicesElement.getElementsByTagName(""service""); for (int i = 0; i < serviceNodes.getLength(); i++) { Element serviceElement = (Element) serviceNodes.item(i); Service srv = new Service(); srv.setId(serviceElement.getAttribute(""id"")); srv.setName(XMLUtilities.getValue(serviceElement)); list.add(srv); } return list; }  /**
     * Post the specified photo to a blog. Note that the Photo.title and Photo.description are used for the blog entry title and body respectively.
     * 
     * @param photo
     *            The photo metadata
     * @param blogId
     *            The blog ID
     * @param blogPassword
     *            The blog password
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void postPhoto(Photo photo, String blogId, String blogPassword) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_POST_PHOTO);  parameters.put(""blog_id"", blogId); parameters.put(""photo_id"", photo.getId()); parameters.put(""title"", photo.getTitle()); parameters.put(""description"", photo.getDescription()); if (blogPassword != null) { parameters.put(""blog_password"", blogPassword); }  Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Post the specified photo to a blog.
     * 
     * @param photo
     *            The photo metadata
     * @param blogId
     *            The blog ID
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void postPhoto(Photo photo, String blogId) throws FlickrException { postPhoto(photo, blogId, null); }  /**
     * Get the collection of configured blogs for the calling user.
     * 
     * @return The Collection of configured blogs
     */ public Collection<Blog> getList() throws FlickrException { List<Blog> blogs = new ArrayList<Blog>();  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST);  Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element blogsElement = response.getPayload(); NodeList blogNodes = blogsElement.getElementsByTagName(""blog""); for (int i = 0; i < blogNodes.getLength(); i++) { Element blogElement = (Element) blogNodes.item(i); Blog blog = new Blog(); blog.setId(blogElement.getAttribute(""id"")); blog.setName(blogElement.getAttribute(""name"")); blog.setNeedPassword(""1"".equals(blogElement.getAttribute(""needspassword""))); blog.setUrl(blogElement.getAttribute(""url"")); blogs.add(blog); } return blogs; } }  "
src/main/java/com/flickr4java/flickr/blogs/Service.java,"package com.flickr4java.flickr.blogs;

/**
 * 
 * @author mago
 * @version $Id: Service.java,v 1.2 2009/07/12 22:43:07 x-mago Exp $
 */
public class Service {

    private String id;

    private String name;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

}
",package com.flickr4java.flickr.blogs; public class Service { private String id; private String name; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.blogs; public class Service { private String id; private String name; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } ,"package com.flickr4java.flickr.blogs;  /**
 * 
 * @author mago
 * @version $Id: Service.java,v 1.2 2009/07/12 22:43:07 x-mago Exp $
 */ public class Service {  private String id;  private String name;  public String getId() { return id; }  public void setId(String id) { this.id = id; }  public String getName() { return name; }  public void setName(String name) { this.name = name; }  }  "
src/main/java/com/flickr4java/flickr/cameras/Brand.java,"package com.flickr4java.flickr.cameras;

public class Brand {

    private String id;

    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }
}
",package com.flickr4java.flickr.cameras; public class Brand { private String id; private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getId() { return id; } public void setId(String id) { this.id = id; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.cameras; public class Brand { private String id; private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getId() { return id; } public void setId(String id) { this.id = id; } } ,package com.flickr4java.flickr.cameras;  public class Brand {  private String id;  private String name;  public String getName() { return name; }  public void setName(String name) { this.name = name; }  public String getId() { return id; }  public void setId(String id) { this.id = id; } }  
src/main/java/com/flickr4java/flickr/cameras/Camera.java,"package com.flickr4java.flickr.cameras;

public class Camera {

    private String id;

    private Details details;

    private String smallImage;

    private String largeImage;

    private String name;

    public String getSmallImage() {
        return smallImage;
    }

    public void setSmallImage(String smallImage) {
        this.smallImage = smallImage;
    }

    public String getLargeImage() {
        return largeImage;
    }

    public void setLargeImage(String largeImage) {
        this.largeImage = largeImage;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public Details getDetails() {
        return details;
    }

    public void setDetails(Details details) {
        this.details = details;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

}
",package com.flickr4java.flickr.cameras; public class Camera { private String id; private Details details; private String smallImage; private String largeImage; private String name; public String getSmallImage() { return smallImage; } public void setSmallImage(String smallImage) { this.smallImage = smallImage; } public String getLargeImage() { return largeImage; } public void setLargeImage(String largeImage) { this.largeImage = largeImage; } public String getId() { return id; } public void setId(String id) { this.id = id; } public Details getDetails() { return details; } public void setDetails(Details details) { this.details = details; } public String getName() { return name; } public void setName(String name) { this.name = name; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.cameras; public class Camera { private String id; private Details details; private String smallImage; private String largeImage; private String name; public String getSmallImage() { return smallImage; } public void setSmallImage(String smallImage) { this.smallImage = smallImage; } public String getLargeImage() { return largeImage; } public void setLargeImage(String largeImage) { this.largeImage = largeImage; } public String getId() { return id; } public void setId(String id) { this.id = id; } public Details getDetails() { return details; } public void setDetails(Details details) { this.details = details; } public String getName() { return name; } public void setName(String name) { this.name = name; } } ,package com.flickr4java.flickr.cameras;  public class Camera {  private String id;  private Details details;  private String smallImage;  private String largeImage;  private String name;  public String getSmallImage() { return smallImage; }  public void setSmallImage(String smallImage) { this.smallImage = smallImage; }  public String getLargeImage() { return largeImage; }  public void setLargeImage(String largeImage) { this.largeImage = largeImage; }  public String getId() { return id; }  public void setId(String id) { this.id = id; }  public Details getDetails() { return details; }  public void setDetails(Details details) { this.details = details; }  public String getName() { return name; }  public void setName(String name) { this.name = name; }  }  
src/main/java/com/flickr4java/flickr/cameras/CamerasInterface.java,"/**
 * @author acaplan
 */
package com.flickr4java.flickr.cameras;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.util.XMLUtilities;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Interface for flickr.collections.* methods.
 * 
 * @author callmeal
 * @version $Id$ Copyright (c) 2012 allanc
 */
public class CamerasInterface {
    private static final String METHOD_GET_BRANDS = ""flickr.cameras.getBrands"";

    private static final String METHOD_GET_BRAND_MODELS = ""flickr.cameras.getBrandModels"";

    /**
     * Logger.
     */
    @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(CamerasInterface.class);

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transportAPI;

    public CamerasInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transportAPI;
    }

    /**
     * Returns all the brands of cameras that Flickr knows about.
     * 
     * This method does not require authentication.
     * 
     * 
     * @return List of Brands
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public List<Brand> getBrands() throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_BRANDS);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        List<Brand> lst = new ArrayList<Brand>();
        Element mElement = response.getPayload();
        NodeList brandElements = mElement.getElementsByTagName(""brand"");
        for (int i = 0; i < brandElements.getLength(); i++) {
            Element brandElement = (Element) brandElements.item(i);
            Brand brand = new Brand();
            brand.setId(brandElement.getAttribute(""id""));
            brand.setName(brandElement.getAttribute(""name""));
            lst.add(brand);
        }

        return lst;
    }

    /**
     * Returns all the brands of cameras that Flickr knows about.
     * 
     * This method does not require authentication.
     * 
     * 
     * @return List of Brands
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public List<Camera> getBrandModels(String strBrand) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_BRAND_MODELS);
        parameters.put(""brand"", strBrand);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        List<Camera> lst = new ArrayList<Camera>();
        Element mElement = response.getPayload();
        NodeList cameraElements = mElement.getElementsByTagName(""camera"");
        for (int i = 0; i < cameraElements.getLength(); i++) {
            Element cameraElement = (Element) cameraElements.item(i);
            Camera cam = new Camera();
            cam.setId(cameraElement.getAttribute(""id""));
            cam.setName(XMLUtilities.getChildValue(cameraElement, ""name""));

            NodeList detailsNodes = cameraElement.getElementsByTagName(""details"");
            int n = detailsNodes.getLength();
            if (n == 1) {
                Element detailElement = (Element) detailsNodes.item(0);
                Details detail = new Details();
                cam.setDetails(detail);
                detail.setMegapixels(XMLUtilities.getChildValue(detailElement, ""megapixels""));
                detail.setZoom(XMLUtilities.getChildValue(detailElement, ""zoom""));
                detail.setLcdSize(XMLUtilities.getChildValue(detailElement, ""lcd_screen_size""));
                detail.setStorageType(XMLUtilities.getChildValue(detailElement, ""memory_type""));
            }

            NodeList imageNodes = cameraElement.getElementsByTagName(""images"");
            n = imageNodes.getLength();
            if (n == 1) {
                Element imageElement = (Element) imageNodes.item(0);
                cam.setSmallImage(XMLUtilities.getChildValue(imageElement, ""small""));
                cam.setLargeImage(XMLUtilities.getChildValue(imageElement, ""large""));
            }

            lst.add(cam);
        }

        return lst;
    }

}
","package com.flickr4java.flickr.cameras; public class CamerasInterface { private static final String METHOD_GET_BRANDS = ""flickr.cameras.getBrands""; private static final String METHOD_GET_BRAND_MODELS = ""flickr.cameras.getBrandModels""; @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(CamerasInterface.class); private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public CamerasInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public List<Brand> getBrands() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_BRANDS); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } List<Brand> lst = new ArrayList<Brand>(); Element mElement = response.getPayload(); NodeList brandElements = mElement.getElementsByTagName(""brand""); for (int i = 0; i < brandElements.getLength(); i++) { Element brandElement = (Element) brandElements.item(i); Brand brand = new Brand(); brand.setId(brandElement.getAttribute(""id"")); brand.setName(brandElement.getAttribute(""name"")); lst.add(brand); } return lst; } public List<Camera> getBrandModels(String strBrand) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_BRAND_MODELS); parameters.put(""brand"", strBrand); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } List<Camera> lst = new ArrayList<Camera>(); Element mElement = response.getPayload(); NodeList cameraElements = mElement.getElementsByTagName(""camera""); for (int i = 0; i < cameraElements.getLength(); i++) { Element cameraElement = (Element) cameraElements.item(i); Camera cam = new Camera(); cam.setId(cameraElement.getAttribute(""id"")); cam.setName(XMLUtilities.getChildValue(cameraElement, ""name"")); NodeList detailsNodes = cameraElement.getElementsByTagName(""details""); int n = detailsNodes.getLength(); if (n == 1) { Element detailElement = (Element) detailsNodes.item(0); Details detail = new Details(); cam.setDetails(detail); detail.setMegapixels(XMLUtilities.getChildValue(detailElement, ""megapixels"")); detail.setZoom(XMLUtilities.getChildValue(detailElement, ""zoom"")); detail.setLcdSize(XMLUtilities.getChildValue(detailElement, ""lcd_screen_size"")); detail.setStorageType(XMLUtilities.getChildValue(detailElement, ""memory_type"")); } NodeList imageNodes = cameraElement.getElementsByTagName(""images""); n = imageNodes.getLength(); if (n == 1) { Element imageElement = (Element) imageNodes.item(0); cam.setSmallImage(XMLUtilities.getChildValue(imageElement, ""small"")); cam.setLargeImage(XMLUtilities.getChildValue(imageElement, ""large"")); } lst.add(cam); } return lst; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.cameras; public class CamerasInterface { private static final String METHOD_GET_BRANDS = ""flickr.cameras.getBrands""; private static final String METHOD_GET_BRAND_MODELS = ""flickr.cameras.getBrandModels""; @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(CamerasInterface.class); private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public CamerasInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public List<Brand> getBrands() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_BRANDS); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } List<Brand> lst = new ArrayList<Brand>(); Element mElement = response.getPayload(); NodeList brandElements = mElement.getElementsByTagName(""brand""); for (int i = 0; i < brandElements.getLength(); i++) { Element brandElement = (Element) brandElements.item(i); Brand brand = new Brand(); brand.setId(brandElement.getAttribute(""id"")); brand.setName(brandElement.getAttribute(""name"")); lst.add(brand); } return lst; } public List<Camera> getBrandModels(String strBrand) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_BRAND_MODELS); parameters.put(""brand"", strBrand); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } List<Camera> lst = new ArrayList<Camera>(); Element mElement = response.getPayload(); NodeList cameraElements = mElement.getElementsByTagName(""camera""); for (int i = 0; i < cameraElements.getLength(); i++) { Element cameraElement = (Element) cameraElements.item(i); Camera cam = new Camera(); cam.setId(cameraElement.getAttribute(""id"")); cam.setName(XMLUtilities.getChildValue(cameraElement, ""name"")); NodeList detailsNodes = cameraElement.getElementsByTagName(""details""); int n = detailsNodes.getLength(); if (n == 1) { Element detailElement = (Element) detailsNodes.item(0); Details detail = new Details(); cam.setDetails(detail); detail.setMegapixels(XMLUtilities.getChildValue(detailElement, ""megapixels"")); detail.setZoom(XMLUtilities.getChildValue(detailElement, ""zoom"")); detail.setLcdSize(XMLUtilities.getChildValue(detailElement, ""lcd_screen_size"")); detail.setStorageType(XMLUtilities.getChildValue(detailElement, ""memory_type"")); } NodeList imageNodes = cameraElement.getElementsByTagName(""images""); n = imageNodes.getLength(); if (n == 1) { Element imageElement = (Element) imageNodes.item(0); cam.setSmallImage(XMLUtilities.getChildValue(imageElement, ""small"")); cam.setLargeImage(XMLUtilities.getChildValue(imageElement, ""large"")); } lst.add(cam); } return lst; } } ","/**
 * @author acaplan
 */ package com.flickr4java.flickr.cameras; 
import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.XMLUtilities; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.w3c.dom.Element; import org.w3c.dom.NodeList; 
import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map;  /**
 * Interface for flickr.collections.* methods.
 * 
 * @author callmeal
 * @version $Id$ Copyright (c) 2012 allanc
 */ public class CamerasInterface { private static final String METHOD_GET_BRANDS = ""flickr.cameras.getBrands"";  private static final String METHOD_GET_BRAND_MODELS = ""flickr.cameras.getBrandModels"";  /**
     * Logger.
     */ @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(CamerasInterface.class);  private final String apiKey;  private final String sharedSecret;  private final Transport transportAPI;  public CamerasInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; }  /**
     * Returns all the brands of cameras that Flickr knows about.
     * 
     * This method does not require authentication.
     * 
     * 
     * @return List of Brands
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public List<Brand> getBrands() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_BRANDS);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  List<Brand> lst = new ArrayList<Brand>(); Element mElement = response.getPayload(); NodeList brandElements = mElement.getElementsByTagName(""brand""); for (int i = 0; i < brandElements.getLength(); i++) { Element brandElement = (Element) brandElements.item(i); Brand brand = new Brand(); brand.setId(brandElement.getAttribute(""id"")); brand.setName(brandElement.getAttribute(""name"")); lst.add(brand); }  return lst; }  /**
     * Returns all the brands of cameras that Flickr knows about.
     * 
     * This method does not require authentication.
     * 
     * 
     * @return List of Brands
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public List<Camera> getBrandModels(String strBrand) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_BRAND_MODELS); parameters.put(""brand"", strBrand);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  List<Camera> lst = new ArrayList<Camera>(); Element mElement = response.getPayload(); NodeList cameraElements = mElement.getElementsByTagName(""camera""); for (int i = 0; i < cameraElements.getLength(); i++) { Element cameraElement = (Element) cameraElements.item(i); Camera cam = new Camera(); cam.setId(cameraElement.getAttribute(""id"")); cam.setName(XMLUtilities.getChildValue(cameraElement, ""name""));  NodeList detailsNodes = cameraElement.getElementsByTagName(""details""); int n = detailsNodes.getLength(); if (n == 1) { Element detailElement = (Element) detailsNodes.item(0); Details detail = new Details(); cam.setDetails(detail); detail.setMegapixels(XMLUtilities.getChildValue(detailElement, ""megapixels"")); detail.setZoom(XMLUtilities.getChildValue(detailElement, ""zoom"")); detail.setLcdSize(XMLUtilities.getChildValue(detailElement, ""lcd_screen_size"")); detail.setStorageType(XMLUtilities.getChildValue(detailElement, ""memory_type"")); }  NodeList imageNodes = cameraElement.getElementsByTagName(""images""); n = imageNodes.getLength(); if (n == 1) { Element imageElement = (Element) imageNodes.item(0); cam.setSmallImage(XMLUtilities.getChildValue(imageElement, ""small"")); cam.setLargeImage(XMLUtilities.getChildValue(imageElement, ""large"")); }  lst.add(cam); }  return lst; }  }  "
src/main/java/com/flickr4java/flickr/cameras/Details.java,"package com.flickr4java.flickr.cameras;

public class Details {
    private String megapixels;

    private String zoom;

    private String lcdSize;

    private String storageType;

    public String getMegapixels() {
        return megapixels;
    }

    public void setMegapixels(String megapixels) {
        this.megapixels = megapixels;
    }

    public String getZoom() {
        return zoom;
    }

    public void setZoom(String zoom) {
        this.zoom = zoom;
    }

    public String getLcdSize() {
        return lcdSize;
    }

    public void setLcdSize(String lcdSize) {
        this.lcdSize = lcdSize;
    }

    public String getStorageType() {
        return storageType;
    }

    public void setStorageType(String storageType) {
        this.storageType = storageType;
    }
}
",package com.flickr4java.flickr.cameras; public class Details { private String megapixels; private String zoom; private String lcdSize; private String storageType; public String getMegapixels() { return megapixels; } public void setMegapixels(String megapixels) { this.megapixels = megapixels; } public String getZoom() { return zoom; } public void setZoom(String zoom) { this.zoom = zoom; } public String getLcdSize() { return lcdSize; } public void setLcdSize(String lcdSize) { this.lcdSize = lcdSize; } public String getStorageType() { return storageType; } public void setStorageType(String storageType) { this.storageType = storageType; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.cameras; public class Details { private String megapixels; private String zoom; private String lcdSize; private String storageType; public String getMegapixels() { return megapixels; } public void setMegapixels(String megapixels) { this.megapixels = megapixels; } public String getZoom() { return zoom; } public void setZoom(String zoom) { this.zoom = zoom; } public String getLcdSize() { return lcdSize; } public void setLcdSize(String lcdSize) { this.lcdSize = lcdSize; } public String getStorageType() { return storageType; } public void setStorageType(String storageType) { this.storageType = storageType; } } ,package com.flickr4java.flickr.cameras;  public class Details { private String megapixels;  private String zoom;  private String lcdSize;  private String storageType;  public String getMegapixels() { return megapixels; }  public void setMegapixels(String megapixels) { this.megapixels = megapixels; }  public String getZoom() { return zoom; }  public void setZoom(String zoom) { this.zoom = zoom; }  public String getLcdSize() { return lcdSize; }  public void setLcdSize(String lcdSize) { this.lcdSize = lcdSize; }  public String getStorageType() { return storageType; }  public void setStorageType(String storageType) { this.storageType = storageType; } }  
src/main/java/com/flickr4java/flickr/collections/Collection.java,"package com.flickr4java.flickr.collections;

import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photosets.Photoset;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * As returned by calls to flickr.collections.* methods.
 * 
 * @author Darren Greaves
 * @version $Id$ Copyright (c) 2012 Darren Greaves.
 */
public class Collection {

    /**
     * Logger.
     */
    @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(Collection.class);

    private String id;

    private String title;

    private String description;

    private int childCount;

    private Date dateCreated;

    private String iconLarge;

    private String iconSmall;

    private String server;

    private String secret;

    private List<Collection> collections;

    private List<Photoset> photosets;

    private List<Photo> photos;

    public Collection() {

        photos = new ArrayList<Photo>();
        photosets = new ArrayList<Photoset>();
        collections = new ArrayList<Collection>();
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public int getChildCount() {
        return childCount;
    }

    public void setChildCount(int childCount) {
        this.childCount = childCount;
    }

    public void setChildCount(String childCount) {
        if (childCount != null && childCount.length() > 0) {
            setChildCount(Integer.parseInt(childCount));
        }
    }

    public Date getDateCreated() {
        return dateCreated;
    }

    public void setDateCreated(Date dateCreated) {
        this.dateCreated = dateCreated;
    }

    public void setDateCreated(long dateCreatedLong) {
        setDateCreated(new Date(dateCreatedLong));
    }

    public void setDateCreated(String dateCreatedString) {
        if (dateCreatedString != null && dateCreatedString.length() > 0) {
            setDateCreated(Long.parseLong(dateCreatedString) * 1000);
        }
    }

    public String getIconLarge() {
        return iconLarge;
    }

    public void setIconLarge(String iconLarge) {
        this.iconLarge = iconLarge;
    }

    public String getIconSmall() {
        return iconSmall;
    }

    public void setIconSmall(String iconSmall) {
        this.iconSmall = iconSmall;
    }

    public String getServer() {
        return server;
    }

    public void setServer(String server) {
        this.server = server;
    }

    public String getSecret() {
        return secret;
    }

    public void setSecret(String secret) {
        this.secret = secret;
    }

    public List<Photo> getPhotos() {
        return photos;
    }

    public void setPhotos(List<Photo> photos) {
        this.photos = photos;
    }

    public List<Collection> getCollections() {
        return collections;
    }

    public void setCollections(List<Collection> collections) {
        this.collections = collections;
    }

    public List<Photoset> getPhotosets() {
        return photosets;
    }

    public void setPhotosets(List<Photoset> photosets) {
        this.photosets = photosets;
    }

    public void addPhoto(Photo photo) {
        photos.add(photo);
    }

    public void addPhotoset(Photoset photoset) {
        photosets.add(photoset);
    }

    public void addCollection(Collection collection) {
        collections.add(collection);
    }

    @Override
    public String toString() {
        return String.format(""%s (%s)"", title, id);
    }
}
","package com.flickr4java.flickr.collections; public class Collection { @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(Collection.class); private String id; private String title; private String description; private int childCount; private Date dateCreated; private String iconLarge; private String iconSmall; private String server; private String secret; private List<Collection> collections; private List<Photoset> photosets; private List<Photo> photos; public Collection() { photos = new ArrayList<Photo>(); photosets = new ArrayList<Photoset>(); collections = new ArrayList<Collection>(); } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public int getChildCount() { return childCount; } public void setChildCount(int childCount) { this.childCount = childCount; } public void setChildCount(String childCount) { if (childCount != null && childCount.length() > 0) { setChildCount(Integer.parseInt(childCount)); } } public Date getDateCreated() { return dateCreated; } public void setDateCreated(Date dateCreated) { this.dateCreated = dateCreated; } public void setDateCreated(long dateCreatedLong) { setDateCreated(new Date(dateCreatedLong)); } public void setDateCreated(String dateCreatedString) { if (dateCreatedString != null && dateCreatedString.length() > 0) { setDateCreated(Long.parseLong(dateCreatedString) * 1000); } } public String getIconLarge() { return iconLarge; } public void setIconLarge(String iconLarge) { this.iconLarge = iconLarge; } public String getIconSmall() { return iconSmall; } public void setIconSmall(String iconSmall) { this.iconSmall = iconSmall; } public String getServer() { return server; } public void setServer(String server) { this.server = server; } public String getSecret() { return secret; } public void setSecret(String secret) { this.secret = secret; } public List<Photo> getPhotos() { return photos; } public void setPhotos(List<Photo> photos) { this.photos = photos; } public List<Collection> getCollections() { return collections; } public void setCollections(List<Collection> collections) { this.collections = collections; } public List<Photoset> getPhotosets() { return photosets; } public void setPhotosets(List<Photoset> photosets) { this.photosets = photosets; } public void addPhoto(Photo photo) { photos.add(photo); } public void addPhotoset(Photoset photoset) { photosets.add(photoset); } public void addCollection(Collection collection) { collections.add(collection); } @Override
    public String toString() { return String.format(""%s (%s)"", title, id); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.collections; public class Collection { @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(Collection.class); private String id; private String title; private String description; private int childCount; private Date dateCreated; private String iconLarge; private String iconSmall; private String server; private String secret; private List<Collection> collections; private List<Photoset> photosets; private List<Photo> photos; public Collection() { photos = new ArrayList<Photo>(); photosets = new ArrayList<Photoset>(); collections = new ArrayList<Collection>(); } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public int getChildCount() { return childCount; } public void setChildCount(int childCount) { this.childCount = childCount; } public void setChildCount(String childCount) { if (childCount != null && childCount.length() > 0) { setChildCount(Integer.parseInt(childCount)); } } public Date getDateCreated() { return dateCreated; } public void setDateCreated(Date dateCreated) { this.dateCreated = dateCreated; } public void setDateCreated(long dateCreatedLong) { setDateCreated(new Date(dateCreatedLong)); } public void setDateCreated(String dateCreatedString) { if (dateCreatedString != null && dateCreatedString.length() > 0) { setDateCreated(Long.parseLong(dateCreatedString) * 1000); } } public String getIconLarge() { return iconLarge; } public void setIconLarge(String iconLarge) { this.iconLarge = iconLarge; } public String getIconSmall() { return iconSmall; } public void setIconSmall(String iconSmall) { this.iconSmall = iconSmall; } public String getServer() { return server; } public void setServer(String server) { this.server = server; } public String getSecret() { return secret; } public void setSecret(String secret) { this.secret = secret; } public List<Photo> getPhotos() { return photos; } public void setPhotos(List<Photo> photos) { this.photos = photos; } public List<Collection> getCollections() { return collections; } public void setCollections(List<Collection> collections) { this.collections = collections; } public List<Photoset> getPhotosets() { return photosets; } public void setPhotosets(List<Photoset> photosets) { this.photosets = photosets; } public void addPhoto(Photo photo) { photos.add(photo); } public void addPhotoset(Photoset photoset) { photosets.add(photoset); } public void addCollection(Collection collection) { collections.add(collection); } @Override
    public String toString() { return String.format(""%s (%s)"", title, id); } } ","package com.flickr4java.flickr.collections; 
import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photosets.Photoset; import org.slf4j.Logger; import org.slf4j.LoggerFactory; 
import java.util.ArrayList; import java.util.Date; import java.util.List;  /**
 * As returned by calls to flickr.collections.* methods.
 * 
 * @author Darren Greaves
 * @version $Id$ Copyright (c) 2012 Darren Greaves.
 */ public class Collection {  /**
     * Logger.
     */ @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(Collection.class);  private String id;  private String title;  private String description;  private int childCount;  private Date dateCreated;  private String iconLarge;  private String iconSmall;  private String server;  private String secret;  private List<Collection> collections;  private List<Photoset> photosets;  private List<Photo> photos;  public Collection() {  photos = new ArrayList<Photo>(); photosets = new ArrayList<Photoset>(); collections = new ArrayList<Collection>(); }  public String getId() { return id; }  public void setId(String id) { this.id = id; }  public String getTitle() { return title; }  public void setTitle(String title) { this.title = title; }  public String getDescription() { return description; }  public void setDescription(String description) { this.description = description; }  public int getChildCount() { return childCount; }  public void setChildCount(int childCount) { this.childCount = childCount; }  public void setChildCount(String childCount) { if (childCount != null && childCount.length() > 0) { setChildCount(Integer.parseInt(childCount)); } }  public Date getDateCreated() { return dateCreated; }  public void setDateCreated(Date dateCreated) { this.dateCreated = dateCreated; }  public void setDateCreated(long dateCreatedLong) { setDateCreated(new Date(dateCreatedLong)); }  public void setDateCreated(String dateCreatedString) { if (dateCreatedString != null && dateCreatedString.length() > 0) { setDateCreated(Long.parseLong(dateCreatedString) * 1000); } }  public String getIconLarge() { return iconLarge; }  public void setIconLarge(String iconLarge) { this.iconLarge = iconLarge; }  public String getIconSmall() { return iconSmall; }  public void setIconSmall(String iconSmall) { this.iconSmall = iconSmall; }  public String getServer() { return server; }  public void setServer(String server) { this.server = server; }  public String getSecret() { return secret; }  public void setSecret(String secret) { this.secret = secret; }  public List<Photo> getPhotos() { return photos; }  public void setPhotos(List<Photo> photos) { this.photos = photos; }  public List<Collection> getCollections() { return collections; }  public void setCollections(List<Collection> collections) { this.collections = collections; }  public List<Photoset> getPhotosets() { return photosets; }  public void setPhotosets(List<Photoset> photosets) { this.photosets = photosets; }  public void addPhoto(Photo photo) { photos.add(photo); }  public void addPhotoset(Photoset photoset) { photosets.add(photoset); }  public void addCollection(Collection collection) { collections.add(collection); }  @Override
    public String toString() { return String.format(""%s (%s)"", title, id); } }  "
src/main/java/com/flickr4java/flickr/collections/CollectionsInterface.java,"package com.flickr4java.flickr.collections;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.photos.PhotoUtils;
import com.flickr4java.flickr.photosets.Photoset;
import com.flickr4java.flickr.util.XMLUtilities;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Interface for flickr.collections.* methods.
 * 
 * @author Darren Greaves
 * @version $Id$ Copyright (c) 2012 Darren Greaves.
 */
public class CollectionsInterface {

    private static final String METHOD_GET_INFO = ""flickr.collections.getInfo"";

    private static final String METHOD_GET_TREE = ""flickr.collections.getTree"";

    /**
     * Logger.
     */
    @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(CollectionsInterface.class);

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transportAPI;

    public CollectionsInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transportAPI;
    }

    /**
     * Retrieves info on the given Flickr {@link Collection} (of {@link Photoset}s).
     * 
     * This method requires authentication.
     * 
     * @param collectionId
     *            the id of the collection (from the getTree call, not from the collection URL).
     * 
     * @return the given Collection
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Collection getInfo(String collectionId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_INFO);
        parameters.put(""collection_id"", collectionId);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Collection collection = parseCollection(response.getPayload());

        return collection;
    }

    /**
     * Retrieves a list of the current Commons institutions.
     * 
     * This method does not require authentication.
     * 
     * @param collectionId
     *            the id of the collection (optional - returns all if not specified).
     * @param userId
     *            the user id of the collection owner (optional - defaults to calling user).
     * 
     * @return List of Institution
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public List<Collection> getTree(String collectionId, String userId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_TREE);
        if (collectionId != null) {
            parameters.put(""collection_id"", collectionId);
        }
        if (userId != null) {
            parameters.put(""user_id"", userId);
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        List<Collection> collections = new ArrayList<Collection>();
        Element mElement = response.getPayload();

        NodeList collectionElements = mElement.getElementsByTagName(""collection"");
        for (int i = 0; i < collectionElements.getLength(); i++) {
            Element element = (Element) collectionElements.item(i);
            collections.add(parseTreeCollection(element));
        }
        return collections;
    }

    /**
     * Parse the XML for a collection as returned by getInfo call.
     * 
     * @param collectionElement
     * @return
     */
    private Collection parseCollection(Element collectionElement) {

        Collection collection = new Collection();
        collection.setId(collectionElement.getAttribute(""id""));
        collection.setServer(collectionElement.getAttribute(""server""));
        collection.setSecret(collectionElement.getAttribute(""secret""));
        collection.setChildCount(collectionElement.getAttribute(""child_count""));
        collection.setIconLarge(collectionElement.getAttribute(""iconlarge""));
        collection.setIconSmall(collectionElement.getAttribute(""iconsmall""));
        collection.setDateCreated(collectionElement.getAttribute(""datecreate""));
        collection.setTitle(XMLUtilities.getChildValue(collectionElement, ""title""));
        collection.setDescription(XMLUtilities.getChildValue(collectionElement, ""description""));

        Element iconPhotos = XMLUtilities.getChild(collectionElement, ""iconphotos"");
        if (iconPhotos != null) {
            NodeList photoElements = iconPhotos.getElementsByTagName(""photo"");
            for (int i = 0; i < photoElements.getLength(); i++) {
                Element photoElement = (Element) photoElements.item(i);
                collection.addPhoto(PhotoUtils.createPhoto(photoElement));
            }
        }

        return collection;
    }

    /**
     * Parse the XML for a collection as returned by getTree call.
     * 
     * @param collectionElement
     * @return
     */
    private Collection parseTreeCollection(Element collectionElement) {

        Collection collection = new Collection();
        parseCommonFields(collectionElement, collection);
        collection.setTitle(collectionElement.getAttribute(""title""));
        collection.setDescription(collectionElement.getAttribute(""description""));

        // Collections can contain either sets or collections (but not both)
        NodeList childCollectionElements = collectionElement.getElementsByTagName(""collection"");
        for (int i = 0; i < childCollectionElements.getLength(); i++) {
            Element childCollectionElement = (Element) childCollectionElements.item(i);
            collection.addCollection(parseTreeCollection(childCollectionElement));
        }

        NodeList childPhotosetElements = collectionElement.getElementsByTagName(""set"");
        for (int i = 0; i < childPhotosetElements.getLength(); i++) {
            Element childPhotosetElement = (Element) childPhotosetElements.item(i);
            collection.addPhotoset(createPhotoset(childPhotosetElement));
        }

        return collection;
    }

    /**
     * 
     * @param childPhotosetElement
     * @return
     */
    private Photoset createPhotoset(Element childPhotosetElement) {
        Photoset photoset = new Photoset();
        photoset.setId(childPhotosetElement.getAttribute(""id""));
        photoset.setTitle(childPhotosetElement.getAttribute(""title""));
        photoset.setDescription(childPhotosetElement.getAttribute(""description""));
        return photoset;
    }

    /**
     * 
     * @param collectionElement
     * @param collection
     */
    private void parseCommonFields(Element collectionElement, Collection collection) {
        collection.setId(collectionElement.getAttribute(""id""));
        collection.setIconLarge(collectionElement.getAttribute(""iconlarge""));
        collection.setIconSmall(collectionElement.getAttribute(""iconsmall""));
    }
}
","package com.flickr4java.flickr.collections; public class CollectionsInterface { private static final String METHOD_GET_INFO = ""flickr.collections.getInfo""; private static final String METHOD_GET_TREE = ""flickr.collections.getTree""; @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(CollectionsInterface.class); private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public CollectionsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public Collection getInfo(String collectionId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO); parameters.put(""collection_id"", collectionId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Collection collection = parseCollection(response.getPayload()); return collection; } public List<Collection> getTree(String collectionId, String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_TREE); if (collectionId != null) { parameters.put(""collection_id"", collectionId); } if (userId != null) { parameters.put(""user_id"", userId); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } List<Collection> collections = new ArrayList<Collection>(); Element mElement = response.getPayload(); NodeList collectionElements = mElement.getElementsByTagName(""collection""); for (int i = 0; i < collectionElements.getLength(); i++) { Element element = (Element) collectionElements.item(i); collections.add(parseTreeCollection(element)); } return collections; } private Collection parseCollection(Element collectionElement) { Collection collection = new Collection(); collection.setId(collectionElement.getAttribute(""id"")); collection.setServer(collectionElement.getAttribute(""server"")); collection.setSecret(collectionElement.getAttribute(""secret"")); collection.setChildCount(collectionElement.getAttribute(""child_count"")); collection.setIconLarge(collectionElement.getAttribute(""iconlarge"")); collection.setIconSmall(collectionElement.getAttribute(""iconsmall"")); collection.setDateCreated(collectionElement.getAttribute(""datecreate"")); collection.setTitle(XMLUtilities.getChildValue(collectionElement, ""title"")); collection.setDescription(XMLUtilities.getChildValue(collectionElement, ""description"")); Element iconPhotos = XMLUtilities.getChild(collectionElement, ""iconphotos""); if (iconPhotos != null) { NodeList photoElements = iconPhotos.getElementsByTagName(""photo""); for (int i = 0; i < photoElements.getLength(); i++) { Element photoElement = (Element) photoElements.item(i); collection.addPhoto(PhotoUtils.createPhoto(photoElement)); } } return collection; } private Collection parseTreeCollection(Element collectionElement) { Collection collection = new Collection(); parseCommonFields(collectionElement, collection); collection.setTitle(collectionElement.getAttribute(""title"")); collection.setDescription(collectionElement.getAttribute(""description"")); NodeList childCollectionElements = collectionElement.getElementsByTagName(""collection""); for (int i = 0; i < childCollectionElements.getLength(); i++) { Element childCollectionElement = (Element) childCollectionElements.item(i); collection.addCollection(parseTreeCollection(childCollectionElement)); } NodeList childPhotosetElements = collectionElement.getElementsByTagName(""set""); for (int i = 0; i < childPhotosetElements.getLength(); i++) { Element childPhotosetElement = (Element) childPhotosetElements.item(i); collection.addPhotoset(createPhotoset(childPhotosetElement)); } return collection; } private Photoset createPhotoset(Element childPhotosetElement) { Photoset photoset = new Photoset(); photoset.setId(childPhotosetElement.getAttribute(""id"")); photoset.setTitle(childPhotosetElement.getAttribute(""title"")); photoset.setDescription(childPhotosetElement.getAttribute(""description"")); return photoset; } private void parseCommonFields(Element collectionElement, Collection collection) { collection.setId(collectionElement.getAttribute(""id"")); collection.setIconLarge(collectionElement.getAttribute(""iconlarge"")); collection.setIconSmall(collectionElement.getAttribute(""iconsmall"")); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.collections; public class CollectionsInterface { private static final String METHOD_GET_INFO = ""flickr.collections.getInfo""; private static final String METHOD_GET_TREE = ""flickr.collections.getTree""; @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(CollectionsInterface.class); private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public CollectionsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public Collection getInfo(String collectionId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO); parameters.put(""collection_id"", collectionId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Collection collection = parseCollection(response.getPayload()); return collection; } public List<Collection> getTree(String collectionId, String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_TREE); if (collectionId != null) { parameters.put(""collection_id"", collectionId); } if (userId != null) { parameters.put(""user_id"", userId); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } List<Collection> collections = new ArrayList<Collection>(); Element mElement = response.getPayload(); NodeList collectionElements = mElement.getElementsByTagName(""collection""); for (int i = 0; i < collectionElements.getLength(); i++) { Element element = (Element) collectionElements.item(i); collections.add(parseTreeCollection(element)); } return collections; } private Collection parseCollection(Element collectionElement) { Collection collection = new Collection(); collection.setId(collectionElement.getAttribute(""id"")); collection.setServer(collectionElement.getAttribute(""server"")); collection.setSecret(collectionElement.getAttribute(""secret"")); collection.setChildCount(collectionElement.getAttribute(""child_count"")); collection.setIconLarge(collectionElement.getAttribute(""iconlarge"")); collection.setIconSmall(collectionElement.getAttribute(""iconsmall"")); collection.setDateCreated(collectionElement.getAttribute(""datecreate"")); collection.setTitle(XMLUtilities.getChildValue(collectionElement, ""title"")); collection.setDescription(XMLUtilities.getChildValue(collectionElement, ""description"")); Element iconPhotos = XMLUtilities.getChild(collectionElement, ""iconphotos""); if (iconPhotos != null) { NodeList photoElements = iconPhotos.getElementsByTagName(""photo""); for (int i = 0; i < photoElements.getLength(); i++) { Element photoElement = (Element) photoElements.item(i); collection.addPhoto(PhotoUtils.createPhoto(photoElement)); } } return collection; } private Collection parseTreeCollection(Element collectionElement) { Collection collection = new Collection(); parseCommonFields(collectionElement, collection); collection.setTitle(collectionElement.getAttribute(""title"")); collection.setDescription(collectionElement.getAttribute(""description"")); NodeList childCollectionElements = collectionElement.getElementsByTagName(""collection""); for (int i = 0; i < childCollectionElements.getLength(); i++) { Element childCollectionElement = (Element) childCollectionElements.item(i); collection.addCollection(parseTreeCollection(childCollectionElement)); } NodeList childPhotosetElements = collectionElement.getElementsByTagName(""set""); for (int i = 0; i < childPhotosetElements.getLength(); i++) { Element childPhotosetElement = (Element) childPhotosetElements.item(i); collection.addPhotoset(createPhotoset(childPhotosetElement)); } return collection; } private Photoset createPhotoset(Element childPhotosetElement) { Photoset photoset = new Photoset(); photoset.setId(childPhotosetElement.getAttribute(""id"")); photoset.setTitle(childPhotosetElement.getAttribute(""title"")); photoset.setDescription(childPhotosetElement.getAttribute(""description"")); return photoset; } private void parseCommonFields(Element collectionElement, Collection collection) { collection.setId(collectionElement.getAttribute(""id"")); collection.setIconLarge(collectionElement.getAttribute(""iconlarge"")); collection.setIconSmall(collectionElement.getAttribute(""iconsmall"")); } } ","package com.flickr4java.flickr.collections; 
import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.photosets.Photoset; import com.flickr4java.flickr.util.XMLUtilities; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.w3c.dom.Element; import org.w3c.dom.NodeList; 
import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map;  /**
 * Interface for flickr.collections.* methods.
 * 
 * @author Darren Greaves
 * @version $Id$ Copyright (c) 2012 Darren Greaves.
 */ public class CollectionsInterface {  private static final String METHOD_GET_INFO = ""flickr.collections.getInfo"";  private static final String METHOD_GET_TREE = ""flickr.collections.getTree"";  /**
     * Logger.
     */ @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(CollectionsInterface.class);  private final String apiKey;  private final String sharedSecret;  private final Transport transportAPI;  public CollectionsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; }  /**
     * Retrieves info on the given Flickr {@link Collection} (of {@link Photoset}s).
     * 
     * This method requires authentication.
     * 
     * @param collectionId
     *            the id of the collection (from the getTree call, not from the collection URL).
     * 
     * @return the given Collection
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Collection getInfo(String collectionId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO); parameters.put(""collection_id"", collectionId);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Collection collection = parseCollection(response.getPayload());  return collection; }  /**
     * Retrieves a list of the current Commons institutions.
     * 
     * This method does not require authentication.
     * 
     * @param collectionId
     *            the id of the collection (optional - returns all if not specified).
     * @param userId
     *            the user id of the collection owner (optional - defaults to calling user).
     * 
     * @return List of Institution
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public List<Collection> getTree(String collectionId, String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_TREE); if (collectionId != null) { parameters.put(""collection_id"", collectionId); } if (userId != null) { parameters.put(""user_id"", userId); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  List<Collection> collections = new ArrayList<Collection>(); Element mElement = response.getPayload();  NodeList collectionElements = mElement.getElementsByTagName(""collection""); for (int i = 0; i < collectionElements.getLength(); i++) { Element element = (Element) collectionElements.item(i); collections.add(parseTreeCollection(element)); } return collections; }  /**
     * Parse the XML for a collection as returned by getInfo call.
     * 
     * @param collectionElement
     * @return
     */ private Collection parseCollection(Element collectionElement) {  Collection collection = new Collection(); collection.setId(collectionElement.getAttribute(""id"")); collection.setServer(collectionElement.getAttribute(""server"")); collection.setSecret(collectionElement.getAttribute(""secret"")); collection.setChildCount(collectionElement.getAttribute(""child_count"")); collection.setIconLarge(collectionElement.getAttribute(""iconlarge"")); collection.setIconSmall(collectionElement.getAttribute(""iconsmall"")); collection.setDateCreated(collectionElement.getAttribute(""datecreate"")); collection.setTitle(XMLUtilities.getChildValue(collectionElement, ""title"")); collection.setDescription(XMLUtilities.getChildValue(collectionElement, ""description""));  Element iconPhotos = XMLUtilities.getChild(collectionElement, ""iconphotos""); if (iconPhotos != null) { NodeList photoElements = iconPhotos.getElementsByTagName(""photo""); for (int i = 0; i < photoElements.getLength(); i++) { Element photoElement = (Element) photoElements.item(i); collection.addPhoto(PhotoUtils.createPhoto(photoElement)); } }  return collection; }  /**
     * Parse the XML for a collection as returned by getTree call.
     * 
     * @param collectionElement
     * @return
     */ private Collection parseTreeCollection(Element collectionElement) {  Collection collection = new Collection(); parseCommonFields(collectionElement, collection); collection.setTitle(collectionElement.getAttribute(""title"")); collection.setDescription(collectionElement.getAttribute(""description""));  // Collections can contain either sets or collections (but not both) NodeList childCollectionElements = collectionElement.getElementsByTagName(""collection""); for (int i = 0; i < childCollectionElements.getLength(); i++) { Element childCollectionElement = (Element) childCollectionElements.item(i); collection.addCollection(parseTreeCollection(childCollectionElement)); }  NodeList childPhotosetElements = collectionElement.getElementsByTagName(""set""); for (int i = 0; i < childPhotosetElements.getLength(); i++) { Element childPhotosetElement = (Element) childPhotosetElements.item(i); collection.addPhotoset(createPhotoset(childPhotosetElement)); }  return collection; }  /**
     * 
     * @param childPhotosetElement
     * @return
     */ private Photoset createPhotoset(Element childPhotosetElement) { Photoset photoset = new Photoset(); photoset.setId(childPhotosetElement.getAttribute(""id"")); photoset.setTitle(childPhotosetElement.getAttribute(""title"")); photoset.setDescription(childPhotosetElement.getAttribute(""description"")); return photoset; }  /**
     * 
     * @param collectionElement
     * @param collection
     */ private void parseCommonFields(Element collectionElement, Collection collection) { collection.setId(collectionElement.getAttribute(""id"")); collection.setIconLarge(collectionElement.getAttribute(""iconlarge"")); collection.setIconSmall(collectionElement.getAttribute(""iconsmall"")); } }  "
src/main/java/com/flickr4java/flickr/commons/CommonsInterface.java,"package com.flickr4java.flickr.commons;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.util.XMLUtilities;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

/**
 * 
 * @author mago
 * @version $Id: CommonsInterface.java,v 1.2 2009/07/11 20:30:27 x-mago Exp $
 */
public class CommonsInterface {
    public static final String METHOD_GET_INSTITUTIONS = ""flickr.commons.getInstitutions"";

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transportAPI;

    public CommonsInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transportAPI;
    }

    /**
     * Retrieves a list of the current Commons institutions.
     * 
     * This method does not require authentication.
     * 
     * @return List of Institution
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public ArrayList<Institution> getInstitutions() throws FlickrException {
        ArrayList<Institution> institutions = new ArrayList<Institution>();
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_INSTITUTIONS);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element mElement = response.getPayload();

        NodeList mNodes = mElement.getElementsByTagName(""institution"");
        for (int i = 0; i < mNodes.getLength(); i++) {
            Element element = (Element) mNodes.item(i);
            institutions.add(parseInstitution(element));
        }
        return institutions;
    }

    private Institution parseInstitution(Element mElement) {
        Institution inst = new Institution();
        inst.setId(mElement.getAttribute(""nsid""));
        inst.setDateLaunch(mElement.getAttribute(""date_launch""));
        inst.setName(XMLUtilities.getChildValue(mElement, ""name""));
        NodeList urlNodes = mElement.getElementsByTagName(""url"");
        for (int i = 0; i < urlNodes.getLength(); i++) {
            Element urlElement = (Element) urlNodes.item(i);
            if (urlElement.getAttribute(""type"").equals(""site"")) {
                inst.setSiteUrl(XMLUtilities.getValue(urlElement));
            } else if (urlElement.getAttribute(""type"").equals(""license"")) {
                inst.setLicenseUrl(XMLUtilities.getValue(urlElement));
            } else if (urlElement.getAttribute(""type"").equals(""flickr"")) {
                inst.setFlickrUrl(XMLUtilities.getValue(urlElement));
            }
        }
        return inst;
    }
}
","package com.flickr4java.flickr.commons; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.ArrayList; import java.util.HashMap; import java.util.Map; public class CommonsInterface { public static final String METHOD_GET_INSTITUTIONS = ""flickr.commons.getInstitutions""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public CommonsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public ArrayList<Institution> getInstitutions() throws FlickrException { ArrayList<Institution> institutions = new ArrayList<Institution>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INSTITUTIONS); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element mElement = response.getPayload(); NodeList mNodes = mElement.getElementsByTagName(""institution""); for (int i = 0; i < mNodes.getLength(); i++) { Element element = (Element) mNodes.item(i); institutions.add(parseInstitution(element)); } return institutions; } private Institution parseInstitution(Element mElement) { Institution inst = new Institution(); inst.setId(mElement.getAttribute(""nsid"")); inst.setDateLaunch(mElement.getAttribute(""date_launch"")); inst.setName(XMLUtilities.getChildValue(mElement, ""name"")); NodeList urlNodes = mElement.getElementsByTagName(""url""); for (int i = 0; i < urlNodes.getLength(); i++) { Element urlElement = (Element) urlNodes.item(i); if (urlElement.getAttribute(""type"").equals(""site"")) { inst.setSiteUrl(XMLUtilities.getValue(urlElement)); } else if (urlElement.getAttribute(""type"").equals(""license"")) { inst.setLicenseUrl(XMLUtilities.getValue(urlElement)); } else if (urlElement.getAttribute(""type"").equals(""flickr"")) { inst.setFlickrUrl(XMLUtilities.getValue(urlElement)); } } return inst; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.commons; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.ArrayList; import java.util.HashMap; import java.util.Map; public class CommonsInterface { public static final String METHOD_GET_INSTITUTIONS = ""flickr.commons.getInstitutions""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public CommonsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public ArrayList<Institution> getInstitutions() throws FlickrException { ArrayList<Institution> institutions = new ArrayList<Institution>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INSTITUTIONS); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element mElement = response.getPayload(); NodeList mNodes = mElement.getElementsByTagName(""institution""); for (int i = 0; i < mNodes.getLength(); i++) { Element element = (Element) mNodes.item(i); institutions.add(parseInstitution(element)); } return institutions; } private Institution parseInstitution(Element mElement) { Institution inst = new Institution(); inst.setId(mElement.getAttribute(""nsid"")); inst.setDateLaunch(mElement.getAttribute(""date_launch"")); inst.setName(XMLUtilities.getChildValue(mElement, ""name"")); NodeList urlNodes = mElement.getElementsByTagName(""url""); for (int i = 0; i < urlNodes.getLength(); i++) { Element urlElement = (Element) urlNodes.item(i); if (urlElement.getAttribute(""type"").equals(""site"")) { inst.setSiteUrl(XMLUtilities.getValue(urlElement)); } else if (urlElement.getAttribute(""type"").equals(""license"")) { inst.setLicenseUrl(XMLUtilities.getValue(urlElement)); } else if (urlElement.getAttribute(""type"").equals(""flickr"")) { inst.setFlickrUrl(XMLUtilities.getValue(urlElement)); } } return inst; } } ","package com.flickr4java.flickr.commons;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.XMLUtilities;  import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import java.util.ArrayList; import java.util.HashMap; import java.util.Map;  /**
 * 
 * @author mago
 * @version $Id: CommonsInterface.java,v 1.2 2009/07/11 20:30:27 x-mago Exp $
 */ public class CommonsInterface { public static final String METHOD_GET_INSTITUTIONS = ""flickr.commons.getInstitutions"";  private final String apiKey;  private final String sharedSecret;  private final Transport transportAPI;  public CommonsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; }  /**
     * Retrieves a list of the current Commons institutions.
     * 
     * This method does not require authentication.
     * 
     * @return List of Institution
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public ArrayList<Institution> getInstitutions() throws FlickrException { ArrayList<Institution> institutions = new ArrayList<Institution>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INSTITUTIONS);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element mElement = response.getPayload();  NodeList mNodes = mElement.getElementsByTagName(""institution""); for (int i = 0; i < mNodes.getLength(); i++) { Element element = (Element) mNodes.item(i); institutions.add(parseInstitution(element)); } return institutions; }  private Institution parseInstitution(Element mElement) { Institution inst = new Institution(); inst.setId(mElement.getAttribute(""nsid"")); inst.setDateLaunch(mElement.getAttribute(""date_launch"")); inst.setName(XMLUtilities.getChildValue(mElement, ""name"")); NodeList urlNodes = mElement.getElementsByTagName(""url""); for (int i = 0; i < urlNodes.getLength(); i++) { Element urlElement = (Element) urlNodes.item(i); if (urlElement.getAttribute(""type"").equals(""site"")) { inst.setSiteUrl(XMLUtilities.getValue(urlElement)); } else if (urlElement.getAttribute(""type"").equals(""license"")) { inst.setLicenseUrl(XMLUtilities.getValue(urlElement)); } else if (urlElement.getAttribute(""type"").equals(""flickr"")) { inst.setFlickrUrl(XMLUtilities.getValue(urlElement)); } } return inst; } }  "
src/main/java/com/flickr4java/flickr/commons/Institution.java,"package com.flickr4java.flickr.commons;

import java.util.Date;

/**
 * A commons institution.
 * 
 * @author mago
 * @version $Id: Institution.java,v 1.2 2009/07/12 22:43:07 x-mago Exp $
 */
public class Institution {

    private String id;

    private String name;

    private Date dateLaunch;

    private String siteUrl;

    private String licenseUrl;

    private String flickrUrl;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Date getDateLaunch() {
        return dateLaunch;
    }

    public void setDateLaunch(Date dateLaunch) {
        this.dateLaunch = dateLaunch;
    }

    public void setDateLaunch(long date) {
        setDateLaunch(new Date(date));
    }

    public void setDateLaunch(String date) {
        if (date == null || """".equals(date))
            return;
        setDateLaunch(Long.parseLong(date) * 1000);
    }

    public String getSiteUrl() {
        return siteUrl;
    }

    public void setSiteUrl(String siteUrl) {
        this.siteUrl = siteUrl;
    }

    public String getLicenseUrl() {
        return licenseUrl;
    }

    public void setLicenseUrl(String licenseUrl) {
        this.licenseUrl = licenseUrl;
    }

    public String getFlickrUrl() {
        return flickrUrl;
    }

    public void setFlickrUrl(String flickrUrl) {
        this.flickrUrl = flickrUrl;
    }

    @Override
    public String toString() {
        return String.format(""Institution [name=%s]"", name);
    }

}
","package com.flickr4java.flickr.commons; import java.util.Date; public class Institution { private String id; private String name; private Date dateLaunch; private String siteUrl; private String licenseUrl; private String flickrUrl; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Date getDateLaunch() { return dateLaunch; } public void setDateLaunch(Date dateLaunch) { this.dateLaunch = dateLaunch; } public void setDateLaunch(long date) { setDateLaunch(new Date(date)); } public void setDateLaunch(String date) { if (date == null || """".equals(date))
            return; setDateLaunch(Long.parseLong(date) * 1000); } public String getSiteUrl() { return siteUrl; } public void setSiteUrl(String siteUrl) { this.siteUrl = siteUrl; } public String getLicenseUrl() { return licenseUrl; } public void setLicenseUrl(String licenseUrl) { this.licenseUrl = licenseUrl; } public String getFlickrUrl() { return flickrUrl; } public void setFlickrUrl(String flickrUrl) { this.flickrUrl = flickrUrl; } @Override
    public String toString() { return String.format(""Institution [name=%s]"", name); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.commons; import java.util.Date; public class Institution { private String id; private String name; private Date dateLaunch; private String siteUrl; private String licenseUrl; private String flickrUrl; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Date getDateLaunch() { return dateLaunch; } public void setDateLaunch(Date dateLaunch) { this.dateLaunch = dateLaunch; } public void setDateLaunch(long date) { setDateLaunch(new Date(date)); } public void setDateLaunch(String date) { if (date == null || """".equals(date))
            return; setDateLaunch(Long.parseLong(date) * 1000); } public String getSiteUrl() { return siteUrl; } public void setSiteUrl(String siteUrl) { this.siteUrl = siteUrl; } public String getLicenseUrl() { return licenseUrl; } public void setLicenseUrl(String licenseUrl) { this.licenseUrl = licenseUrl; } public String getFlickrUrl() { return flickrUrl; } public void setFlickrUrl(String flickrUrl) { this.flickrUrl = flickrUrl; } @Override
    public String toString() { return String.format(""Institution [name=%s]"", name); } } ","package com.flickr4java.flickr.commons;  import java.util.Date;  /**
 * A commons institution.
 * 
 * @author mago
 * @version $Id: Institution.java,v 1.2 2009/07/12 22:43:07 x-mago Exp $
 */ public class Institution {  private String id;  private String name;  private Date dateLaunch;  private String siteUrl;  private String licenseUrl;  private String flickrUrl;  public String getId() { return id; }  public void setId(String id) { this.id = id; }  public String getName() { return name; }  public void setName(String name) { this.name = name; }  public Date getDateLaunch() { return dateLaunch; }  public void setDateLaunch(Date dateLaunch) { this.dateLaunch = dateLaunch; }  public void setDateLaunch(long date) { setDateLaunch(new Date(date)); }  public void setDateLaunch(String date) { if (date == null || """".equals(date))
            return; setDateLaunch(Long.parseLong(date) * 1000); }  public String getSiteUrl() { return siteUrl; }  public void setSiteUrl(String siteUrl) { this.siteUrl = siteUrl; }  public String getLicenseUrl() { return licenseUrl; }  public void setLicenseUrl(String licenseUrl) { this.licenseUrl = licenseUrl; }  public String getFlickrUrl() { return flickrUrl; }  public void setFlickrUrl(String flickrUrl) { this.flickrUrl = flickrUrl; }  @Override
    public String toString() { return String.format(""Institution [name=%s]"", name); }  }  "
src/main/java/com/flickr4java/flickr/contacts/Contact.java,"
package com.flickr4java.flickr.contacts;

import com.flickr4java.flickr.util.BuddyIconable;
import com.flickr4java.flickr.util.UrlUtilities;

/**
 * Class representing a Flickr contact.
 * 
 * @author Anthony Eden
 * @version $Id: Contact.java,v 1.5 2009/07/12 22:43:07 x-mago Exp $
 */
public class Contact implements BuddyIconable {

    private String id;

    private String username;

    private String realName;

    private boolean friend;

    private boolean family;

    private boolean ignored;

    private OnlineStatus online;

    private String awayMessage;

    private int iconFarm;

    private int iconServer;

    private String pathAlias;

    public Contact() {

    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getRealName() {
        return realName;
    }

    public void setRealName(String realName) {
        this.realName = realName;
    }

    public boolean isFriend() {
        return friend;
    }

    public void setFriend(boolean friend) {
        this.friend = friend;
    }

    public boolean isFamily() {
        return family;
    }

    public void setFamily(boolean family) {
        this.family = family;
    }

    public boolean isIgnored() {
        return ignored;
    }

    public void setIgnored(boolean ignored) {
        this.ignored = ignored;
    }

    public OnlineStatus getOnline() {
        return online;
    }

    public void setOnline(OnlineStatus online) {
        this.online = online;
    }

    /**
     * Get the contact's away message. This method may return null if the contact online status is not 'away'.
     * 
     * @return The away message or null
     */
    public String getAwayMessage() {
        return awayMessage;
    }

    public void setAwayMessage(String awayMessage) {
        this.awayMessage = awayMessage;
    }

    /**
     * Construct the BuddyIconUrl.
     * <p>
     * If none available, return the <a href=""http://www.flickr.com/images/buddyicon.jpg"">default</a>, or an URL assembled from farm, iconserver and nsid.
     * 
     * @see <a href=""http://flickr.com/services/api/misc.buddyicons.html"">Flickr Documentation</a>
     * @return The BuddyIconUrl
     * @deprecated use {@link #getSecureBuddyIconUrl() }
     */
    @Deprecated
    public String getBuddyIconUrl() {
        return UrlUtilities.createBuddyIconUrl(iconFarm, iconServer, id);
    }

    /**
     * Construct the BuddyIconUrl using {@code https} scheme.
     * <p>
     * If none available, return the <a href=""https://www.flickr.com/images/buddyicon.jpg"">default</a>, or an URL assembled from farm, iconserver and nsid.
     * 
     * @see <a href=""http://flickr.com/services/api/misc.buddyicons.html"">Flickr Documentation</a>
     * @return The BuddyIconUrl
     */
    public String getSecureBuddyIconUrl() {
        return UrlUtilities.createSecureBuddyIconUrl(iconFarm, iconServer, id);
    }

    public int getIconFarm() {
        return iconFarm;
    }

    public void setIconFarm(int iconFarm) {
        this.iconFarm = iconFarm;
    }

    public void setIconFarm(String iconFarm) {
        setIconFarm(Integer.parseInt(iconFarm));
    }

    public int getIconServer() {
        return iconServer;
    }

    public void setIconServer(int iconServer) {
        this.iconServer = iconServer;
    }

    public void setIconServer(String iconServer) {
        setIconServer(Integer.parseInt(iconServer));
    }

    /**
     * Get the contact's path alias, which may appear instead of nsid in urls published by Flickr. For example feeds have urls of the form
     * .../photos/${NSID_OR_PATHALIAS}/${PHOTO_ID} and .../people/${NSID_OR_PATHALIAS}. This allows clients to look up a {@link Contact} given such a url. (Note
     * that <code>&lt;author&gt;</code> elements in feeds have a <code>&lt;flickr:nsid&gt;</code> child which could be used instead of the lookup this method
     * enables.)
     * 
     * @return the path alias, or null
     */
    public String getPathAlias() {
        return pathAlias;
    }

    public void setPathAlias(String pathAlias) {
        this.pathAlias = pathAlias;
    }
}
","package com.flickr4java.flickr.contacts; import com.flickr4java.flickr.util.BuddyIconable; import com.flickr4java.flickr.util.UrlUtilities; public class Contact implements BuddyIconable { private String id; private String username; private String realName; private boolean friend; private boolean family; private boolean ignored; private OnlineStatus online; private String awayMessage; private int iconFarm; private int iconServer; private String pathAlias; public Contact() { } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getRealName() { return realName; } public void setRealName(String realName) { this.realName = realName; } public boolean isFriend() { return friend; } public void setFriend(boolean friend) { this.friend = friend; } public boolean isFamily() { return family; } public void setFamily(boolean family) { this.family = family; } public boolean isIgnored() { return ignored; } public void setIgnored(boolean ignored) { this.ignored = ignored; } public OnlineStatus getOnline() { return online; } public void setOnline(OnlineStatus online) { this.online = online; } public String getAwayMessage() { return awayMessage; } public void setAwayMessage(String awayMessage) { this.awayMessage = awayMessage; } @Deprecated
    public String getBuddyIconUrl() { return UrlUtilities.createBuddyIconUrl(iconFarm, iconServer, id); } public String getSecureBuddyIconUrl() { return UrlUtilities.createSecureBuddyIconUrl(iconFarm, iconServer, id); } public int getIconFarm() { return iconFarm; } public void setIconFarm(int iconFarm) { this.iconFarm = iconFarm; } public void setIconFarm(String iconFarm) { setIconFarm(Integer.parseInt(iconFarm)); } public int getIconServer() { return iconServer; } public void setIconServer(int iconServer) { this.iconServer = iconServer; } public void setIconServer(String iconServer) { setIconServer(Integer.parseInt(iconServer)); } public String getPathAlias() { return pathAlias; } public void setPathAlias(String pathAlias) { this.pathAlias = pathAlias; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.contacts; import com.flickr4java.flickr.util.BuddyIconable; import com.flickr4java.flickr.util.UrlUtilities; public class Contact implements BuddyIconable { private String id; private String username; private String realName; private boolean friend; private boolean family; private boolean ignored; private OnlineStatus online; private String awayMessage; private int iconFarm; private int iconServer; private String pathAlias; public Contact() { } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getRealName() { return realName; } public void setRealName(String realName) { this.realName = realName; } public boolean isFriend() { return friend; } public void setFriend(boolean friend) { this.friend = friend; } public boolean isFamily() { return family; } public void setFamily(boolean family) { this.family = family; } public boolean isIgnored() { return ignored; } public void setIgnored(boolean ignored) { this.ignored = ignored; } public OnlineStatus getOnline() { return online; } public void setOnline(OnlineStatus online) { this.online = online; } public String getAwayMessage() { return awayMessage; } public void setAwayMessage(String awayMessage) { this.awayMessage = awayMessage; } @Deprecated
    public String getBuddyIconUrl() { return UrlUtilities.createBuddyIconUrl(iconFarm, iconServer, id); } public String getSecureBuddyIconUrl() { return UrlUtilities.createSecureBuddyIconUrl(iconFarm, iconServer, id); } public int getIconFarm() { return iconFarm; } public void setIconFarm(int iconFarm) { this.iconFarm = iconFarm; } public void setIconFarm(String iconFarm) { setIconFarm(Integer.parseInt(iconFarm)); } public int getIconServer() { return iconServer; } public void setIconServer(int iconServer) { this.iconServer = iconServer; } public void setIconServer(String iconServer) { setIconServer(Integer.parseInt(iconServer)); } public String getPathAlias() { return pathAlias; } public void setPathAlias(String pathAlias) { this.pathAlias = pathAlias; } } "," package com.flickr4java.flickr.contacts;  import com.flickr4java.flickr.util.BuddyIconable; import com.flickr4java.flickr.util.UrlUtilities;  /**
 * Class representing a Flickr contact.
 * 
 * @author Anthony Eden
 * @version $Id: Contact.java,v 1.5 2009/07/12 22:43:07 x-mago Exp $
 */ public class Contact implements BuddyIconable {  private String id;  private String username;  private String realName;  private boolean friend;  private boolean family;  private boolean ignored;  private OnlineStatus online;  private String awayMessage;  private int iconFarm;  private int iconServer;  private String pathAlias;  public Contact() {  }  public String getId() { return id; }  public void setId(String id) { this.id = id; }  public String getUsername() { return username; }  public void setUsername(String username) { this.username = username; }  public String getRealName() { return realName; }  public void setRealName(String realName) { this.realName = realName; }  public boolean isFriend() { return friend; }  public void setFriend(boolean friend) { this.friend = friend; }  public boolean isFamily() { return family; }  public void setFamily(boolean family) { this.family = family; }  public boolean isIgnored() { return ignored; }  public void setIgnored(boolean ignored) { this.ignored = ignored; }  public OnlineStatus getOnline() { return online; }  public void setOnline(OnlineStatus online) { this.online = online; }  /**
     * Get the contact's away message. This method may return null if the contact online status is not 'away'.
     * 
     * @return The away message or null
     */ public String getAwayMessage() { return awayMessage; }  public void setAwayMessage(String awayMessage) { this.awayMessage = awayMessage; }  /**
     * Construct the BuddyIconUrl.
     * <p>
     * If none available, return the <a href=""http://www.flickr.com/images/buddyicon.jpg"">default</a>, or an URL assembled from farm, iconserver and nsid.
     * 
     * @see <a href=""http://flickr.com/services/api/misc.buddyicons.html"">Flickr Documentation</a>
     * @return The BuddyIconUrl
     * @deprecated use {@link #getSecureBuddyIconUrl() }
     */ @Deprecated
    public String getBuddyIconUrl() { return UrlUtilities.createBuddyIconUrl(iconFarm, iconServer, id); }  /**
     * Construct the BuddyIconUrl using {@code https} scheme.
     * <p>
     * If none available, return the <a href=""https://www.flickr.com/images/buddyicon.jpg"">default</a>, or an URL assembled from farm, iconserver and nsid.
     * 
     * @see <a href=""http://flickr.com/services/api/misc.buddyicons.html"">Flickr Documentation</a>
     * @return The BuddyIconUrl
     */ public String getSecureBuddyIconUrl() { return UrlUtilities.createSecureBuddyIconUrl(iconFarm, iconServer, id); }  public int getIconFarm() { return iconFarm; }  public void setIconFarm(int iconFarm) { this.iconFarm = iconFarm; }  public void setIconFarm(String iconFarm) { setIconFarm(Integer.parseInt(iconFarm)); }  public int getIconServer() { return iconServer; }  public void setIconServer(int iconServer) { this.iconServer = iconServer; }  public void setIconServer(String iconServer) { setIconServer(Integer.parseInt(iconServer)); }  /**
     * Get the contact's path alias, which may appear instead of nsid in urls published by Flickr. For example feeds have urls of the form
     * .../photos/${NSID_OR_PATHALIAS}/${PHOTO_ID} and .../people/${NSID_OR_PATHALIAS}. This allows clients to look up a {@link Contact} given such a url. (Note
     * that <code>&lt;author&gt;</code> elements in feeds have a <code>&lt;flickr:nsid&gt;</code> child which could be used instead of the lookup this method
     * enables.)
     * 
     * @return the path alias, or null
     */ public String getPathAlias() { return pathAlias; }  public void setPathAlias(String pathAlias) { this.pathAlias = pathAlias; } }  "
src/main/java/com/flickr4java/flickr/contacts/ContactList.java,"package com.flickr4java.flickr.contacts;

import com.flickr4java.flickr.SearchResultList;


public class ContactList<E> extends SearchResultList<Contact> {

    // (avoid compiler warning)
    private static final long serialVersionUID = -4735611134085303463L;

}
",package com.flickr4java.flickr.contacts; import com.flickr4java.flickr.SearchResultList; public class ContactList<E> extends SearchResultList<Contact> { private static final long serialVersionUID = -4735611134085303463L; },0 0 0 0 0 0,package com.flickr4java.flickr.contacts; import com.flickr4java.flickr.SearchResultList; public class ContactList<E> extends SearchResultList<Contact> { private static final long serialVersionUID = -4735611134085303463L; } ,"package com.flickr4java.flickr.contacts;  import com.flickr4java.flickr.SearchResultList; 
 public class ContactList<E> extends SearchResultList<Contact> {  // (avoid compiler warning) private static final long serialVersionUID = -4735611134085303463L;  }  "
src/main/java/com/flickr4java/flickr/contacts/ContactsInterface.java,"
package com.flickr4java.flickr.contacts;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.util.XMLUtilities;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Interface for working with Flickr contacts.
 * 
 * @author Anthony Eden
 * @version $Id: ContactsInterface.java,v 1.18 2009/07/11 20:30:27 x-mago Exp $
 */
public class ContactsInterface {

    private static final String METHOD_GET_LIST = ""flickr.contacts.getList"";

    private static final String METHOD_GET_LIST_RECENTLY_UPLOADED = ""flickr.contacts.getListRecentlyUploaded"";

    private static final String METHOD_GET_PUBLIC_LIST = ""flickr.contacts.getPublicList"";

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transportAPI;

    public ContactsInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transportAPI;
    }

    /**
     * Get the collection of contacts for the calling user.
     * 
     * @return The Collection of Contact objects
     */
    public Collection<Contact> getList() throws FlickrException {
    	 ContactList<Contact> contacts = new ContactList<Contact>();
        
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_LIST);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element contactsElement = response.getPayload();
        contacts.setPage(contactsElement.getAttribute(""page""));
        contacts.setPages(contactsElement.getAttribute(""pages""));
        contacts.setPerPage(contactsElement.getAttribute(""perpage""));
        contacts.setTotal(contactsElement.getAttribute(""total""));
        NodeList contactNodes = contactsElement.getElementsByTagName(""contact"");
        for (int i = 0; i < contactNodes.getLength(); i++) {
            Element contactElement = (Element) contactNodes.item(i);
            Contact contact = new Contact();
            contact.setId(contactElement.getAttribute(""nsid""));
            contact.setUsername(contactElement.getAttribute(""username""));
            contact.setRealName(contactElement.getAttribute(""realname""));
            contact.setFriend(""1"".equals(contactElement.getAttribute(""friend"")));
            contact.setFamily(""1"".equals(contactElement.getAttribute(""family"")));
            contact.setIgnored(""1"".equals(contactElement.getAttribute(""ignored"")));
            String lPathAlias = contactElement.getAttribute(""path_alias"");
            contact.setPathAlias(lPathAlias == null || """".equals(lPathAlias) ? null : lPathAlias);
            contact.setOnline(OnlineStatus.fromType(contactElement.getAttribute(""online"")));
            contact.setIconFarm(contactElement.getAttribute(""iconfarm""));
            contact.setIconServer(contactElement.getAttribute(""iconserver""));
            if (contact.getOnline() == OnlineStatus.AWAY) {
                contactElement.normalize();
                contact.setAwayMessage(XMLUtilities.getValue(contactElement));
            }
            contacts.add(contact);
        }
        return contacts;
    }

    /**
     * Return a list of contacts for a user who have recently uploaded photos along with the total count of photos uploaded.
     * 
     * @param lastUpload
     *            Limits the resultset to contacts that have uploaded photos since this date. The date should be in the form of a Unix timestamp. The default,
     *            and maximum, offset is (1) hour. (Optional, can be null)
     * @param filter
     *            Limit the result set to all contacts or only those who are friends or family.<br>
     *            Valid options are: <b>ff</b> -&gt; friends and family, <b>all</b> -&gt; all your contacts. (Optional, can be null)
     * 
     * @return List of Contacts
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Collection<Contact> getListRecentlyUploaded(Date lastUpload, String filter) throws FlickrException {
        List<Contact> contacts = new ArrayList<Contact>();

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_LIST_RECENTLY_UPLOADED);

        if (lastUpload != null) {
            parameters.put(""date_lastupload"", String.valueOf(lastUpload.getTime() / 1000L));
        }
        if (filter != null) {
            parameters.put(""filter"", filter);
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element contactsElement = response.getPayload();
        NodeList contactNodes = contactsElement.getElementsByTagName(""contact"");
        for (int i = 0; i < contactNodes.getLength(); i++) {
            Element contactElement = (Element) contactNodes.item(i);
            Contact contact = new Contact();
            contact.setId(contactElement.getAttribute(""nsid""));
            contact.setUsername(contactElement.getAttribute(""username""));
            contact.setRealName(contactElement.getAttribute(""realname""));
            contact.setFriend(""1"".equals(contactElement.getAttribute(""friend"")));
            contact.setFamily(""1"".equals(contactElement.getAttribute(""family"")));
            contact.setIgnored(""1"".equals(contactElement.getAttribute(""ignored"")));
            contact.setOnline(OnlineStatus.fromType(contactElement.getAttribute(""online"")));
            contact.setIconFarm(contactElement.getAttribute(""iconfarm""));
            contact.setIconServer(contactElement.getAttribute(""iconserver""));
            if (contact.getOnline() == OnlineStatus.AWAY) {
                contactElement.normalize();
                contact.setAwayMessage(XMLUtilities.getValue(contactElement));
            }
            contacts.add(contact);
        }
        return contacts;
    }

    /**
     * Get the collection of public contacts for the specified user ID.
     * 
     * This method does not require authentication.
     * 
     * @param userId
     *            The user ID
     * @return The Collection of Contact objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Collection<Contact> getPublicList(String userId) throws FlickrException {
        List<Contact> contacts = new ArrayList<Contact>();

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_PUBLIC_LIST);
        parameters.put(""user_id"", userId);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element contactsElement = response.getPayload();
        NodeList contactNodes = contactsElement.getElementsByTagName(""contact"");
        for (int i = 0; i < contactNodes.getLength(); i++) {
            Element contactElement = (Element) contactNodes.item(i);
            Contact contact = new Contact();
            contact.setId(contactElement.getAttribute(""nsid""));
            contact.setUsername(contactElement.getAttribute(""username""));
            contact.setIgnored(""1"".equals(contactElement.getAttribute(""ignored"")));
            contact.setOnline(OnlineStatus.fromType(contactElement.getAttribute(""online"")));
            contact.setIconFarm(contactElement.getAttribute(""iconfarm""));
            contact.setIconServer(contactElement.getAttribute(""iconserver""));
            if (contact.getOnline() == OnlineStatus.AWAY) {
                contactElement.normalize();
                contact.setAwayMessage(XMLUtilities.getValue(contactElement));
            }
            contacts.add(contact);
        }
        return contacts;
    }

}
","package com.flickr4java.flickr.contacts; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.ArrayList; import java.util.Collection; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map; public class ContactsInterface { private static final String METHOD_GET_LIST = ""flickr.contacts.getList""; private static final String METHOD_GET_LIST_RECENTLY_UPLOADED = ""flickr.contacts.getListRecentlyUploaded""; private static final String METHOD_GET_PUBLIC_LIST = ""flickr.contacts.getPublicList""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public ContactsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public Collection<Contact> getList() throws FlickrException { ContactList<Contact> contacts = new ContactList<Contact>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element contactsElement = response.getPayload(); contacts.setPage(contactsElement.getAttribute(""page"")); contacts.setPages(contactsElement.getAttribute(""pages"")); contacts.setPerPage(contactsElement.getAttribute(""perpage"")); contacts.setTotal(contactsElement.getAttribute(""total"")); NodeList contactNodes = contactsElement.getElementsByTagName(""contact""); for (int i = 0; i < contactNodes.getLength(); i++) { Element contactElement = (Element) contactNodes.item(i); Contact contact = new Contact(); contact.setId(contactElement.getAttribute(""nsid"")); contact.setUsername(contactElement.getAttribute(""username"")); contact.setRealName(contactElement.getAttribute(""realname"")); contact.setFriend(""1"".equals(contactElement.getAttribute(""friend""))); contact.setFamily(""1"".equals(contactElement.getAttribute(""family""))); contact.setIgnored(""1"".equals(contactElement.getAttribute(""ignored""))); String lPathAlias = contactElement.getAttribute(""path_alias""); contact.setPathAlias(lPathAlias == null || """".equals(lPathAlias) ? null : lPathAlias); contact.setOnline(OnlineStatus.fromType(contactElement.getAttribute(""online""))); contact.setIconFarm(contactElement.getAttribute(""iconfarm"")); contact.setIconServer(contactElement.getAttribute(""iconserver"")); if (contact.getOnline() == OnlineStatus.AWAY) { contactElement.normalize(); contact.setAwayMessage(XMLUtilities.getValue(contactElement)); } contacts.add(contact); } return contacts; } public Collection<Contact> getListRecentlyUploaded(Date lastUpload, String filter) throws FlickrException { List<Contact> contacts = new ArrayList<Contact>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST_RECENTLY_UPLOADED); if (lastUpload != null) { parameters.put(""date_lastupload"", String.valueOf(lastUpload.getTime() / 1000L)); } if (filter != null) { parameters.put(""filter"", filter); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element contactsElement = response.getPayload(); NodeList contactNodes = contactsElement.getElementsByTagName(""contact""); for (int i = 0; i < contactNodes.getLength(); i++) { Element contactElement = (Element) contactNodes.item(i); Contact contact = new Contact(); contact.setId(contactElement.getAttribute(""nsid"")); contact.setUsername(contactElement.getAttribute(""username"")); contact.setRealName(contactElement.getAttribute(""realname"")); contact.setFriend(""1"".equals(contactElement.getAttribute(""friend""))); contact.setFamily(""1"".equals(contactElement.getAttribute(""family""))); contact.setIgnored(""1"".equals(contactElement.getAttribute(""ignored""))); contact.setOnline(OnlineStatus.fromType(contactElement.getAttribute(""online""))); contact.setIconFarm(contactElement.getAttribute(""iconfarm"")); contact.setIconServer(contactElement.getAttribute(""iconserver"")); if (contact.getOnline() == OnlineStatus.AWAY) { contactElement.normalize(); contact.setAwayMessage(XMLUtilities.getValue(contactElement)); } contacts.add(contact); } return contacts; } public Collection<Contact> getPublicList(String userId) throws FlickrException { List<Contact> contacts = new ArrayList<Contact>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PUBLIC_LIST); parameters.put(""user_id"", userId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element contactsElement = response.getPayload(); NodeList contactNodes = contactsElement.getElementsByTagName(""contact""); for (int i = 0; i < contactNodes.getLength(); i++) { Element contactElement = (Element) contactNodes.item(i); Contact contact = new Contact(); contact.setId(contactElement.getAttribute(""nsid"")); contact.setUsername(contactElement.getAttribute(""username"")); contact.setIgnored(""1"".equals(contactElement.getAttribute(""ignored""))); contact.setOnline(OnlineStatus.fromType(contactElement.getAttribute(""online""))); contact.setIconFarm(contactElement.getAttribute(""iconfarm"")); contact.setIconServer(contactElement.getAttribute(""iconserver"")); if (contact.getOnline() == OnlineStatus.AWAY) { contactElement.normalize(); contact.setAwayMessage(XMLUtilities.getValue(contactElement)); } contacts.add(contact); } return contacts; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.contacts; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.ArrayList; import java.util.Collection; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map; public class ContactsInterface { private static final String METHOD_GET_LIST = ""flickr.contacts.getList""; private static final String METHOD_GET_LIST_RECENTLY_UPLOADED = ""flickr.contacts.getListRecentlyUploaded""; private static final String METHOD_GET_PUBLIC_LIST = ""flickr.contacts.getPublicList""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public ContactsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public Collection<Contact> getList() throws FlickrException { ContactList<Contact> contacts = new ContactList<Contact>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element contactsElement = response.getPayload(); contacts.setPage(contactsElement.getAttribute(""page"")); contacts.setPages(contactsElement.getAttribute(""pages"")); contacts.setPerPage(contactsElement.getAttribute(""perpage"")); contacts.setTotal(contactsElement.getAttribute(""total"")); NodeList contactNodes = contactsElement.getElementsByTagName(""contact""); for (int i = 0; i < contactNodes.getLength(); i++) { Element contactElement = (Element) contactNodes.item(i); Contact contact = new Contact(); contact.setId(contactElement.getAttribute(""nsid"")); contact.setUsername(contactElement.getAttribute(""username"")); contact.setRealName(contactElement.getAttribute(""realname"")); contact.setFriend(""1"".equals(contactElement.getAttribute(""friend""))); contact.setFamily(""1"".equals(contactElement.getAttribute(""family""))); contact.setIgnored(""1"".equals(contactElement.getAttribute(""ignored""))); String lPathAlias = contactElement.getAttribute(""path_alias""); contact.setPathAlias(lPathAlias == null || """".equals(lPathAlias) ? null : lPathAlias); contact.setOnline(OnlineStatus.fromType(contactElement.getAttribute(""online""))); contact.setIconFarm(contactElement.getAttribute(""iconfarm"")); contact.setIconServer(contactElement.getAttribute(""iconserver"")); if (contact.getOnline() == OnlineStatus.AWAY) { contactElement.normalize(); contact.setAwayMessage(XMLUtilities.getValue(contactElement)); } contacts.add(contact); } return contacts; } public Collection<Contact> getListRecentlyUploaded(Date lastUpload, String filter) throws FlickrException { List<Contact> contacts = new ArrayList<Contact>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST_RECENTLY_UPLOADED); if (lastUpload != null) { parameters.put(""date_lastupload"", String.valueOf(lastUpload.getTime() / 1000L)); } if (filter != null) { parameters.put(""filter"", filter); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element contactsElement = response.getPayload(); NodeList contactNodes = contactsElement.getElementsByTagName(""contact""); for (int i = 0; i < contactNodes.getLength(); i++) { Element contactElement = (Element) contactNodes.item(i); Contact contact = new Contact(); contact.setId(contactElement.getAttribute(""nsid"")); contact.setUsername(contactElement.getAttribute(""username"")); contact.setRealName(contactElement.getAttribute(""realname"")); contact.setFriend(""1"".equals(contactElement.getAttribute(""friend""))); contact.setFamily(""1"".equals(contactElement.getAttribute(""family""))); contact.setIgnored(""1"".equals(contactElement.getAttribute(""ignored""))); contact.setOnline(OnlineStatus.fromType(contactElement.getAttribute(""online""))); contact.setIconFarm(contactElement.getAttribute(""iconfarm"")); contact.setIconServer(contactElement.getAttribute(""iconserver"")); if (contact.getOnline() == OnlineStatus.AWAY) { contactElement.normalize(); contact.setAwayMessage(XMLUtilities.getValue(contactElement)); } contacts.add(contact); } return contacts; } public Collection<Contact> getPublicList(String userId) throws FlickrException { List<Contact> contacts = new ArrayList<Contact>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PUBLIC_LIST); parameters.put(""user_id"", userId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element contactsElement = response.getPayload(); NodeList contactNodes = contactsElement.getElementsByTagName(""contact""); for (int i = 0; i < contactNodes.getLength(); i++) { Element contactElement = (Element) contactNodes.item(i); Contact contact = new Contact(); contact.setId(contactElement.getAttribute(""nsid"")); contact.setUsername(contactElement.getAttribute(""username"")); contact.setIgnored(""1"".equals(contactElement.getAttribute(""ignored""))); contact.setOnline(OnlineStatus.fromType(contactElement.getAttribute(""online""))); contact.setIconFarm(contactElement.getAttribute(""iconfarm"")); contact.setIconServer(contactElement.getAttribute(""iconserver"")); if (contact.getOnline() == OnlineStatus.AWAY) { contactElement.normalize(); contact.setAwayMessage(XMLUtilities.getValue(contactElement)); } contacts.add(contact); } return contacts; } } "," package com.flickr4java.flickr.contacts;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.XMLUtilities;  import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import java.util.ArrayList; import java.util.Collection; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map;  /**
 * Interface for working with Flickr contacts.
 * 
 * @author Anthony Eden
 * @version $Id: ContactsInterface.java,v 1.18 2009/07/11 20:30:27 x-mago Exp $
 */ public class ContactsInterface {  private static final String METHOD_GET_LIST = ""flickr.contacts.getList"";  private static final String METHOD_GET_LIST_RECENTLY_UPLOADED = ""flickr.contacts.getListRecentlyUploaded"";  private static final String METHOD_GET_PUBLIC_LIST = ""flickr.contacts.getPublicList"";  private final String apiKey;  private final String sharedSecret;  private final Transport transportAPI;  public ContactsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; }  /**
     * Get the collection of contacts for the calling user.
     * 
     * @return The Collection of Contact objects
     */ public Collection<Contact> getList() throws FlickrException { ContactList<Contact> contacts = new ContactList<Contact>();          Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element contactsElement = response.getPayload(); contacts.setPage(contactsElement.getAttribute(""page"")); contacts.setPages(contactsElement.getAttribute(""pages"")); contacts.setPerPage(contactsElement.getAttribute(""perpage"")); contacts.setTotal(contactsElement.getAttribute(""total"")); NodeList contactNodes = contactsElement.getElementsByTagName(""contact""); for (int i = 0; i < contactNodes.getLength(); i++) { Element contactElement = (Element) contactNodes.item(i); Contact contact = new Contact(); contact.setId(contactElement.getAttribute(""nsid"")); contact.setUsername(contactElement.getAttribute(""username"")); contact.setRealName(contactElement.getAttribute(""realname"")); contact.setFriend(""1"".equals(contactElement.getAttribute(""friend""))); contact.setFamily(""1"".equals(contactElement.getAttribute(""family""))); contact.setIgnored(""1"".equals(contactElement.getAttribute(""ignored""))); String lPathAlias = contactElement.getAttribute(""path_alias""); contact.setPathAlias(lPathAlias == null || """".equals(lPathAlias) ? null : lPathAlias); contact.setOnline(OnlineStatus.fromType(contactElement.getAttribute(""online""))); contact.setIconFarm(contactElement.getAttribute(""iconfarm"")); contact.setIconServer(contactElement.getAttribute(""iconserver"")); if (contact.getOnline() == OnlineStatus.AWAY) { contactElement.normalize(); contact.setAwayMessage(XMLUtilities.getValue(contactElement)); } contacts.add(contact); } return contacts; }  /**
     * Return a list of contacts for a user who have recently uploaded photos along with the total count of photos uploaded.
     * 
     * @param lastUpload
     *            Limits the resultset to contacts that have uploaded photos since this date. The date should be in the form of a Unix timestamp. The default,
     *            and maximum, offset is (1) hour. (Optional, can be null)
     * @param filter
     *            Limit the result set to all contacts or only those who are friends or family.<br>
     *            Valid options are: <b>ff</b> -&gt; friends and family, <b>all</b> -&gt; all your contacts. (Optional, can be null)
     * 
     * @return List of Contacts
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Collection<Contact> getListRecentlyUploaded(Date lastUpload, String filter) throws FlickrException { List<Contact> contacts = new ArrayList<Contact>();  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST_RECENTLY_UPLOADED);  if (lastUpload != null) { parameters.put(""date_lastupload"", String.valueOf(lastUpload.getTime() / 1000L)); } if (filter != null) { parameters.put(""filter"", filter); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element contactsElement = response.getPayload(); NodeList contactNodes = contactsElement.getElementsByTagName(""contact""); for (int i = 0; i < contactNodes.getLength(); i++) { Element contactElement = (Element) contactNodes.item(i); Contact contact = new Contact(); contact.setId(contactElement.getAttribute(""nsid"")); contact.setUsername(contactElement.getAttribute(""username"")); contact.setRealName(contactElement.getAttribute(""realname"")); contact.setFriend(""1"".equals(contactElement.getAttribute(""friend""))); contact.setFamily(""1"".equals(contactElement.getAttribute(""family""))); contact.setIgnored(""1"".equals(contactElement.getAttribute(""ignored""))); contact.setOnline(OnlineStatus.fromType(contactElement.getAttribute(""online""))); contact.setIconFarm(contactElement.getAttribute(""iconfarm"")); contact.setIconServer(contactElement.getAttribute(""iconserver"")); if (contact.getOnline() == OnlineStatus.AWAY) { contactElement.normalize(); contact.setAwayMessage(XMLUtilities.getValue(contactElement)); } contacts.add(contact); } return contacts; }  /**
     * Get the collection of public contacts for the specified user ID.
     * 
     * This method does not require authentication.
     * 
     * @param userId
     *            The user ID
     * @return The Collection of Contact objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Collection<Contact> getPublicList(String userId) throws FlickrException { List<Contact> contacts = new ArrayList<Contact>();  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PUBLIC_LIST); parameters.put(""user_id"", userId);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element contactsElement = response.getPayload(); NodeList contactNodes = contactsElement.getElementsByTagName(""contact""); for (int i = 0; i < contactNodes.getLength(); i++) { Element contactElement = (Element) contactNodes.item(i); Contact contact = new Contact(); contact.setId(contactElement.getAttribute(""nsid"")); contact.setUsername(contactElement.getAttribute(""username"")); contact.setIgnored(""1"".equals(contactElement.getAttribute(""ignored""))); contact.setOnline(OnlineStatus.fromType(contactElement.getAttribute(""online""))); contact.setIconFarm(contactElement.getAttribute(""iconfarm"")); contact.setIconServer(contactElement.getAttribute(""iconserver"")); if (contact.getOnline() == OnlineStatus.AWAY) { contactElement.normalize(); contact.setAwayMessage(XMLUtilities.getValue(contactElement)); } contacts.add(contact); } return contacts; }  }  "
src/main/java/com/flickr4java/flickr/contacts/OnlineStatus.java,"
package com.flickr4java.flickr.contacts;

import java.io.Serializable;

import static com.flickr4java.flickr.contacts.OnlineStatus.OnlineStatusType.AWAY_TYPE;
import static com.flickr4java.flickr.contacts.OnlineStatus.OnlineStatusType.OFFLINE_TYPE;
import static com.flickr4java.flickr.contacts.OnlineStatus.OnlineStatusType.ONLINE_TYPE;
import static com.flickr4java.flickr.contacts.OnlineStatus.OnlineStatusType.UNKNOWN_TYPE;

/**
 * Class representing the various types of online statuses.
 *
 * @author Anthony Eden
 */
public enum OnlineStatus implements Serializable {

    OFFLINE(OFFLINE_TYPE),
    AWAY(AWAY_TYPE),
    ONLINE(ONLINE_TYPE),
    UNKNOWN(UNKNOWN_TYPE);

    private static final long serialVersionUID = 12L;

    private final int type;

    private OnlineStatus(int type) {
        this.type = type;
    }

    /**
     * Get the int value for the online status. This method is useful in switch statements.
     *
     * @return The int value for the online status
     */
    public int getType() {
        return type;
    }

    /**
     * Get an OnlineStatus object for a given int value.
     *
     * @param type The int value
     * @return The OnlineStatus object
     */
    public static OnlineStatus fromType(int type) {
        switch (type) {
            case OFFLINE_TYPE:
                return OFFLINE;
            case AWAY_TYPE:
                return AWAY;
            case ONLINE_TYPE:
                return ONLINE;
            case UNKNOWN_TYPE:
                return UNKNOWN;
            default:
                throw new IllegalArgumentException(""Unsupported online type: "" + type);
        }
    }

    /**
     * Get the OnlineStatus value for a given int represented as a String
     *
     * @param type The int represented as a String
     * @return The OnlineStatus object
     */
    public static OnlineStatus fromType(String type) {
        if (type == null || """".equals(type)) {
            return UNKNOWN;
        } else {
            return fromType(Integer.parseInt(type));
        }
    }

    static class OnlineStatusType {
        static final int OFFLINE_TYPE = 0;
        static final int AWAY_TYPE = 1;
        static final int ONLINE_TYPE = 2;
        static final int UNKNOWN_TYPE = 100;
    }
}
","package com.flickr4java.flickr.contacts; import java.io.Serializable; import static com.flickr4java.flickr.contacts.OnlineStatus.OnlineStatusType.AWAY_TYPE; import static com.flickr4java.flickr.contacts.OnlineStatus.OnlineStatusType.OFFLINE_TYPE; import static com.flickr4java.flickr.contacts.OnlineStatus.OnlineStatusType.ONLINE_TYPE; import static com.flickr4java.flickr.contacts.OnlineStatus.OnlineStatusType.UNKNOWN_TYPE; public enum OnlineStatus implements Serializable { OFFLINE(OFFLINE_TYPE),
    AWAY(AWAY_TYPE),
    ONLINE(ONLINE_TYPE),
    UNKNOWN(UNKNOWN_TYPE); private static final long serialVersionUID = 12L; private final int type; private OnlineStatus(int type) { this.type = type; } public int getType() { return type; } public static OnlineStatus fromType(int type) { switch (type) { case OFFLINE_TYPE:
                return OFFLINE; case AWAY_TYPE:
                return AWAY; case ONLINE_TYPE:
                return ONLINE; case UNKNOWN_TYPE:
                return UNKNOWN; default:
                throw new IllegalArgumentException(""Unsupported online type: "" + type); } } public static OnlineStatus fromType(String type) { if (type == null || """".equals(type)) { return UNKNOWN; } else { return fromType(Integer.parseInt(type)); } } static class OnlineStatusType { static final int OFFLINE_TYPE = 0; static final int AWAY_TYPE = 1; static final int ONLINE_TYPE = 2; static final int UNKNOWN_TYPE = 100; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.contacts; import java.io.Serializable; import static com.flickr4java.flickr.contacts.OnlineStatus.OnlineStatusType.AWAY_TYPE; import static com.flickr4java.flickr.contacts.OnlineStatus.OnlineStatusType.OFFLINE_TYPE; import static com.flickr4java.flickr.contacts.OnlineStatus.OnlineStatusType.ONLINE_TYPE; import static com.flickr4java.flickr.contacts.OnlineStatus.OnlineStatusType.UNKNOWN_TYPE; public enum OnlineStatus implements Serializable { OFFLINE(OFFLINE_TYPE),
    AWAY(AWAY_TYPE),
    ONLINE(ONLINE_TYPE),
    UNKNOWN(UNKNOWN_TYPE); private static final long serialVersionUID = 12L; private final int type; private OnlineStatus(int type) { this.type = type; } public int getType() { return type; } public static OnlineStatus fromType(int type) { switch (type) { case OFFLINE_TYPE:
                return OFFLINE; case AWAY_TYPE:
                return AWAY; case ONLINE_TYPE:
                return ONLINE; case UNKNOWN_TYPE:
                return UNKNOWN; default:
                throw new IllegalArgumentException(""Unsupported online type: "" + type); } } public static OnlineStatus fromType(String type) { if (type == null || """".equals(type)) { return UNKNOWN; } else { return fromType(Integer.parseInt(type)); } } static class OnlineStatusType { static final int OFFLINE_TYPE = 0; static final int AWAY_TYPE = 1; static final int ONLINE_TYPE = 2; static final int UNKNOWN_TYPE = 100; } } "," package com.flickr4java.flickr.contacts;  import java.io.Serializable;  import static com.flickr4java.flickr.contacts.OnlineStatus.OnlineStatusType.AWAY_TYPE; import static com.flickr4java.flickr.contacts.OnlineStatus.OnlineStatusType.OFFLINE_TYPE; import static com.flickr4java.flickr.contacts.OnlineStatus.OnlineStatusType.ONLINE_TYPE; import static com.flickr4java.flickr.contacts.OnlineStatus.OnlineStatusType.UNKNOWN_TYPE;  /**
 * Class representing the various types of online statuses.
 *
 * @author Anthony Eden
 */ public enum OnlineStatus implements Serializable {  OFFLINE(OFFLINE_TYPE),
    AWAY(AWAY_TYPE),
    ONLINE(ONLINE_TYPE),
    UNKNOWN(UNKNOWN_TYPE);  private static final long serialVersionUID = 12L;  private final int type;  private OnlineStatus(int type) { this.type = type; }  /**
     * Get the int value for the online status. This method is useful in switch statements.
     *
     * @return The int value for the online status
     */ public int getType() { return type; }  /**
     * Get an OnlineStatus object for a given int value.
     *
     * @param type The int value
     * @return The OnlineStatus object
     */ public static OnlineStatus fromType(int type) { switch (type) { case OFFLINE_TYPE:
                return OFFLINE; case AWAY_TYPE:
                return AWAY; case ONLINE_TYPE:
                return ONLINE; case UNKNOWN_TYPE:
                return UNKNOWN; default:
                throw new IllegalArgumentException(""Unsupported online type: "" + type); } }  /**
     * Get the OnlineStatus value for a given int represented as a String
     *
     * @param type The int represented as a String
     * @return The OnlineStatus object
     */ public static OnlineStatus fromType(String type) { if (type == null || """".equals(type)) { return UNKNOWN; } else { return fromType(Integer.parseInt(type)); } }  static class OnlineStatusType { static final int OFFLINE_TYPE = 0; static final int AWAY_TYPE = 1; static final int ONLINE_TYPE = 2; static final int UNKNOWN_TYPE = 100; } }  "
src/main/java/com/flickr4java/flickr/favorites/FavoritesInterface.java,"
package com.flickr4java.flickr.favorites;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoContext;
import com.flickr4java.flickr.photos.PhotoList;
import com.flickr4java.flickr.photos.PhotoUtils;
import com.flickr4java.flickr.util.StringUtilities;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * Interface for working with Flickr favorites.
 * 
 * @author Anthony Eden
 * @version $Id: FavoritesInterface.java,v 1.17 2009/07/11 20:30:27 x-mago Exp $
 */
public class FavoritesInterface {

    private static final Logger logger = LoggerFactory.getLogger(FavoritesInterface.class);

    public static final String METHOD_ADD = ""flickr.favorites.add"";

    public static final String METHOD_GET_LIST = ""flickr.favorites.getList"";

    public static final String METHOD_GET_PUBLIC_LIST = ""flickr.favorites.getPublicList"";

    public static final String METHOD_REMOVE = ""flickr.favorites.remove"";

    public static final String METHOD_GET_CONTEXT = ""flickr.favorites.getContext"";

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transportAPI;

    public FavoritesInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transportAPI;
    }

    /**
     * Add a photo to the user's favorites.
     * 
     * @param photoId
     *            The photo ID
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void add(String photoId) throws  FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_ADD);
        parameters.put(""photo_id"", photoId);

        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Get the collection of favorites for the calling user or the specified user ID.
     * 
     * @param userId
     *            The optional user ID. Null value will be ignored.
     * @param perPage
     *            The optional per page value. Values {@code <= 0} will be ignored.
     * @param page
     *            The page to view. Values {@code <= 0} will be ignored.
     * @param extras
     *            a Set Strings representing extra parameters to send
     * @return The Collection of Photo objects
     * @see com.flickr4java.flickr.photos.Extras
     */
    public PhotoList<Photo> getList(String userId, int perPage, int page, Set<String> extras) throws  FlickrException {
        PhotoList<Photo> photos = new PhotoList<Photo>();

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_LIST);

        if (userId != null) {
            parameters.put(""user_id"", userId);
        }
        if (extras != null) {
            parameters.put(""extras"", StringUtilities.join(extras, "",""));
        }
        if (perPage > 0) {
            parameters.put(""per_page"", String.valueOf(perPage));
        }
        if (page > 0) {
            parameters.put(""page"", String.valueOf(page));
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element photosElement = response.getPayload();
        photos.setPage(photosElement.getAttribute(""page""));
        photos.setPages(photosElement.getAttribute(""pages""));
        photos.setPerPage(photosElement.getAttribute(""perpage""));
        photos.setTotal(photosElement.getAttribute(""total""));
        NodeList photoNodes = photosElement.getElementsByTagName(""photo"");
        for (int i = 0; i < photoNodes.getLength(); i++) {
            Element photoElement = (Element) photoNodes.item(i);
            photos.add(PhotoUtils.createPhoto(photoElement));
        }
        return photos;
    }

    /**
     * Get the specified user IDs public contacts.
     * 
     * This method does not require authentication.
     * 
     * @param userId
     *            The user ID
     * @param perPage
     *            The optional per page value. Values {@code <= 0} will be ignored.
     * @param page
     *            The optional page to view. Values {@code <= 0} will be ignored
     * @param extras
     *            A Set of extra parameters to send
     * @return A Collection of Photo objects
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see com.flickr4java.flickr.photos.Extras
     */
    public PhotoList<Photo> getPublicList(String userId, int perPage, int page, Set<String> extras) throws FlickrException {
        PhotoList<Photo> photos = new PhotoList<Photo>();

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_PUBLIC_LIST);

        parameters.put(""user_id"", userId);

        if (extras != null) {
            parameters.put(""extras"", StringUtilities.join(extras, "",""));
        }
        if (perPage > 0) {
            parameters.put(""per_page"", String.valueOf(perPage));
        }
        if (page > 0) {
            parameters.put(""page"", String.valueOf(page));
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element photosElement = response.getPayload();
        photos.setPage(photosElement.getAttribute(""page""));
        photos.setPages(photosElement.getAttribute(""pages""));
        photos.setPerPage(photosElement.getAttribute(""perpage""));
        photos.setTotal(photosElement.getAttribute(""total""));
        NodeList photoNodes = photosElement.getElementsByTagName(""photo"");
        for (int i = 0; i < photoNodes.getLength(); i++) {
            Element photoElement = (Element) photoNodes.item(i);
            photos.add(PhotoUtils.createPhoto(photoElement));
        }
        return photos;
    }

    /**
     * Remove the specified photo from the user's favorites.
     * 
     * @param photoId
     *            The photo id
     */
    public void remove(String photoId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_REMOVE);

        parameters.put(""photo_id"", photoId);

        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Returns next and previous favorites for a photo in a user's favorites
     * 
     * @param photoId
     *            The photo id
     * @param userId
     *            The user's ID
     * @see <a href=""http://www.flickr.com/services/api/flickr.favorites.getContext.html"">flickr.favorites.getContext</a>
     */
    public PhotoContext getContext(String photoId, String userId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_CONTEXT);

        parameters.put(""photo_id"", photoId);
        parameters.put(""user_id"", userId);

        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Collection<Element> payload = response.getPayloadCollection();
        PhotoContext photoContext = new PhotoContext();
        for (Element element : payload) {
            String elementName = element.getTagName();
            if (elementName.equals(""prevphoto"")) {
                Photo photo = new Photo();
                photo.setId(element.getAttribute(""id""));
                photoContext.setPreviousPhoto(photo);
            } else if (elementName.equals(""nextphoto"")) {
                Photo photo = new Photo();
                photo.setId(element.getAttribute(""id""));
                photoContext.setNextPhoto(photo);
            } else {
                if (logger.isInfoEnabled()) {
                    logger.info(""unsupported element name: "" + elementName);
                }
            }
        }
        return photoContext;
    }

}
","package com.flickr4java.flickr.favorites; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoContext; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.util.StringUtilities; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.Collection; import java.util.HashMap; import java.util.Map; import java.util.Set; public class FavoritesInterface { private static final Logger logger = LoggerFactory.getLogger(FavoritesInterface.class); public static final String METHOD_ADD = ""flickr.favorites.add""; public static final String METHOD_GET_LIST = ""flickr.favorites.getList""; public static final String METHOD_GET_PUBLIC_LIST = ""flickr.favorites.getPublicList""; public static final String METHOD_REMOVE = ""flickr.favorites.remove""; public static final String METHOD_GET_CONTEXT = ""flickr.favorites.getContext""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public FavoritesInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public void add(String photoId) throws  FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD); parameters.put(""photo_id"", photoId); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public PhotoList<Photo> getList(String userId, int perPage, int page, Set<String> extras) throws  FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); if (userId != null) { parameters.put(""user_id"", userId); } if (extras != null) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } public PhotoList<Photo> getPublicList(String userId, int perPage, int page, Set<String> extras) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PUBLIC_LIST); parameters.put(""user_id"", userId); if (extras != null) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } public void remove(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REMOVE); parameters.put(""photo_id"", photoId); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public PhotoContext getContext(String photoId, String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CONTEXT); parameters.put(""photo_id"", photoId); parameters.put(""user_id"", userId); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Collection<Element> payload = response.getPayloadCollection(); PhotoContext photoContext = new PhotoContext(); for (Element element : payload) { String elementName = element.getTagName(); if (elementName.equals(""prevphoto"")) { Photo photo = new Photo(); photo.setId(element.getAttribute(""id"")); photoContext.setPreviousPhoto(photo); } else if (elementName.equals(""nextphoto"")) { Photo photo = new Photo(); photo.setId(element.getAttribute(""id"")); photoContext.setNextPhoto(photo); } else { if (logger.isInfoEnabled()) { } } } return photoContext; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0,"package com.flickr4java.flickr.favorites; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoContext; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.util.StringUtilities; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.Collection; import java.util.HashMap; import java.util.Map; import java.util.Set; public class FavoritesInterface { private static final Logger logger = LoggerFactory.getLogger(FavoritesInterface.class); public static final String METHOD_ADD = ""flickr.favorites.add""; public static final String METHOD_GET_LIST = ""flickr.favorites.getList""; public static final String METHOD_GET_PUBLIC_LIST = ""flickr.favorites.getPublicList""; public static final String METHOD_REMOVE = ""flickr.favorites.remove""; public static final String METHOD_GET_CONTEXT = ""flickr.favorites.getContext""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public FavoritesInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public void add(String photoId) throws  FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD); parameters.put(""photo_id"", photoId); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public PhotoList<Photo> getList(String userId, int perPage, int page, Set<String> extras) throws  FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); if (userId != null) { parameters.put(""user_id"", userId); } if (extras != null) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } public PhotoList<Photo> getPublicList(String userId, int perPage, int page, Set<String> extras) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PUBLIC_LIST); parameters.put(""user_id"", userId); if (extras != null) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } public void remove(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REMOVE); parameters.put(""photo_id"", photoId); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public PhotoContext getContext(String photoId, String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CONTEXT); parameters.put(""photo_id"", photoId); parameters.put(""user_id"", userId); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Collection<Element> payload = response.getPayloadCollection(); PhotoContext photoContext = new PhotoContext(); for (Element element : payload) { String elementName = element.getTagName(); if (elementName.equals(""prevphoto"")) { Photo photo = new Photo(); photo.setId(element.getAttribute(""id"")); photoContext.setPreviousPhoto(photo); } else if (elementName.equals(""nextphoto"")) { Photo photo = new Photo(); photo.setId(element.getAttribute(""id"")); photoContext.setNextPhoto(photo); } else { if (logger.isInfoEnabled()) { <FILL_ME> } } } return photoContext; } } "," package com.flickr4java.flickr.favorites;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoContext; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.util.StringUtilities; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import java.util.Collection; import java.util.HashMap; import java.util.Map; import java.util.Set;  /**
 * Interface for working with Flickr favorites.
 * 
 * @author Anthony Eden
 * @version $Id: FavoritesInterface.java,v 1.17 2009/07/11 20:30:27 x-mago Exp $
 */ public class FavoritesInterface {  private static final Logger logger = LoggerFactory.getLogger(FavoritesInterface.class);  public static final String METHOD_ADD = ""flickr.favorites.add"";  public static final String METHOD_GET_LIST = ""flickr.favorites.getList"";  public static final String METHOD_GET_PUBLIC_LIST = ""flickr.favorites.getPublicList"";  public static final String METHOD_REMOVE = ""flickr.favorites.remove"";  public static final String METHOD_GET_CONTEXT = ""flickr.favorites.getContext"";  private final String apiKey;  private final String sharedSecret;  private final Transport transportAPI;  public FavoritesInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; }  /**
     * Add a photo to the user's favorites.
     * 
     * @param photoId
     *            The photo ID
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void add(String photoId) throws  FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD); parameters.put(""photo_id"", photoId);  Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Get the collection of favorites for the calling user or the specified user ID.
     * 
     * @param userId
     *            The optional user ID. Null value will be ignored.
     * @param perPage
     *            The optional per page value. Values {@code <= 0} will be ignored.
     * @param page
     *            The page to view. Values {@code <= 0} will be ignored.
     * @param extras
     *            a Set Strings representing extra parameters to send
     * @return The Collection of Photo objects
     * @see com.flickr4java.flickr.photos.Extras
     */ public PhotoList<Photo> getList(String userId, int perPage, int page, Set<String> extras) throws  FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>();  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST);  if (userId != null) { parameters.put(""user_id"", userId); } if (extras != null) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; }  /**
     * Get the specified user IDs public contacts.
     * 
     * This method does not require authentication.
     * 
     * @param userId
     *            The user ID
     * @param perPage
     *            The optional per page value. Values {@code <= 0} will be ignored.
     * @param page
     *            The optional page to view. Values {@code <= 0} will be ignored
     * @param extras
     *            A Set of extra parameters to send
     * @return A Collection of Photo objects
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see com.flickr4java.flickr.photos.Extras
     */ public PhotoList<Photo> getPublicList(String userId, int perPage, int page, Set<String> extras) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>();  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PUBLIC_LIST);  parameters.put(""user_id"", userId);  if (extras != null) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; }  /**
     * Remove the specified photo from the user's favorites.
     * 
     * @param photoId
     *            The photo id
     */ public void remove(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REMOVE);  parameters.put(""photo_id"", photoId);  Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Returns next and previous favorites for a photo in a user's favorites
     * 
     * @param photoId
     *            The photo id
     * @param userId
     *            The user's ID
     * @see <a href=""http://www.flickr.com/services/api/flickr.favorites.getContext.html"">flickr.favorites.getContext</a>
     */ public PhotoContext getContext(String photoId, String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CONTEXT);  parameters.put(""photo_id"", photoId); parameters.put(""user_id"", userId);  Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Collection<Element> payload = response.getPayloadCollection(); PhotoContext photoContext = new PhotoContext(); for (Element element : payload) { String elementName = element.getTagName(); if (elementName.equals(""prevphoto"")) { Photo photo = new Photo(); photo.setId(element.getAttribute(""id"")); photoContext.setPreviousPhoto(photo); } else if (elementName.equals(""nextphoto"")) { Photo photo = new Photo(); photo.setId(element.getAttribute(""id"")); photoContext.setNextPhoto(photo); } else { if (logger.isInfoEnabled()) { <FILL_ME> } } } return photoContext; }  }  "
src/main/java/com/flickr4java/flickr/galleries/GalleriesInterface.java,"/**
 * @author acaplan
 */
package com.flickr4java.flickr.galleries;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.people.User;
import com.flickr4java.flickr.photos.Extras;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoList;
import com.flickr4java.flickr.util.XMLUtilities;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * @author acaplan
 * 
 */
public class GalleriesInterface {

    public static final String METHOD_ADD_PHOTO = ""flickr.galleries.addPhoto"";

    public static final String METHOD_CREATE = ""flickr.galleries.create"";

    public static final String METHOD_EDIT_META = ""flickr.galleries.editMeta"";

    public static final String METHOD_EDIT_PHOTO = ""flickr.galleries.editPhoto"";

    public static final String METHOD_EDIT_PHOTOS = ""flickr.galleries.editPhotos"";

    public static final String METHOD_GET_INFO = ""flickr.galleries.getInfo"";

    public static final String METHOD_GET_LIST = ""flickr.galleries.getList"";

    public static final String METHOD_GET_LIST_FOR_PHOTO = ""flickr.galleries.getListForPhoto"";

    public static final String METHOD_GET_PHOTOS = ""flickr.galleries.getPhotos"";

    private String apiKey;

    private String sharedSecret;

    private Transport transport;

    /**
     * Construct a GalleriesInterface.
     * 
     * @param apiKey
     *            The API key
     * @param transportAPI
     *            The Transport interface
     */
    public GalleriesInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transport = transportAPI;
    }

    /**
     * Return the list of galleries created by a user. Sorted from newest to oldest.
     * 
     * @param userId
     *            The user you want to check for
     * @param perPage
     *            Number of galleries per page
     * @param page
     *            The page number
     * @return gallery
     * @throws FlickrException if there was a problem connecting to Flickr
     * 
     * @see <a href=""https://www.flickr.com/services/api/flickr.galleries.getList.html"">flickr.galleries.getList</a>
     */
    public List<Gallery> getList(String userId, int perPage, int page) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_LIST);
        parameters.put(""user_id"", userId);
        if (perPage > 0) {
            parameters.put(""per_page"", String.valueOf(perPage));
        }
        if (page > 0) {
            parameters.put(""page"", String.valueOf(page));
        }

        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element element = response.getPayload();
        GalleryList<Gallery> galleries = new GalleryList<Gallery>();
        galleries.setPage(element.getAttribute(""page""));
        galleries.setPages(element.getAttribute(""pages""));
        galleries.setPerPage(element.getAttribute(""per_page""));
        galleries.setTotal(element.getAttribute(""total""));

        NodeList galleryNodes = element.getElementsByTagName(""gallery"");
        for (int i = 0; i < galleryNodes.getLength(); i++) {
            Element galleryElement = (Element) galleryNodes.item(i);
            Gallery gallery = new Gallery();
            gallery.setId(galleryElement.getAttribute(""id""));
            gallery.setUrl(galleryElement.getAttribute(""url""));

            User owner = new User();
            owner.setId(galleryElement.getAttribute(""owner""));
            gallery.setOwner(owner);
            gallery.setCreateDate(galleryElement.getAttribute(""date_create""));
            gallery.setUpdateDate(galleryElement.getAttribute(""date_update""));
            gallery.setPrimaryPhotoId(galleryElement.getAttribute(""primary_photo_id""));
            gallery.setPrimaryPhotoServer(galleryElement.getAttribute(""primary_photo_server""));
            gallery.setPrimaryPhotoFarm(galleryElement.getAttribute(""primary_photo_farm""));
            gallery.setPrimaryPhotoSecret(galleryElement.getAttribute(""primary_photo_secret""));
            gallery.setPhotoCount(galleryElement.getAttribute(""count_photos""));
            gallery.setVideoCount(galleryElement.getAttribute(""count_videos""));

            galleries.add(gallery);
        }
        return galleries;
    }

    public void addPhoto(String strGalleryId, String photoId, String strComment) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_ADD_PHOTO);
        parameters.put(""gallery_id"", strGalleryId);
        parameters.put(""photo_id"", photoId);
        parameters.put(""comment"", strComment);

        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    public void editMeta(String strGalleryId, String strTitle, String strDescription) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_EDIT_META);
        parameters.put(""title"", strTitle);
        parameters.put(""description"", strDescription);

        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    public void editPhoto(String strGalleryId, String strPhotoId, String strComment) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_EDIT_PHOTO);
        parameters.put(""gallery_id"", strGalleryId);
        parameters.put(""photo_id"", strPhotoId);
        parameters.put(""comment"", strComment);

        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    public void editPhotos(String strGalleryId, String strPrimaryPhotoId, String strPhotoIds) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_EDIT_PHOTOS);
        parameters.put(""gallery_id"", strGalleryId);
        parameters.put(""primary_photo_id"", strPrimaryPhotoId);
        parameters.put(""photo_ids"", strPhotoIds);

        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    public Gallery getInfo(String strGalleryId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_INFO);
        parameters.put(""gallery_id"", strGalleryId);

        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element galleryElement = response.getPayload();
        Gallery gallery = new Gallery();
        gallery.setId(galleryElement.getAttribute(""id""));
        gallery.setUrl(galleryElement.getAttribute(""url""));

        User owner = new User();
        owner.setId(galleryElement.getAttribute(""owner""));
        gallery.setOwner(owner);
        gallery.setCreateDate(galleryElement.getAttribute(""date_create""));
        gallery.setUpdateDate(galleryElement.getAttribute(""date_update""));
        gallery.setPrimaryPhotoId(galleryElement.getAttribute(""primary_photo_id""));
        gallery.setPrimaryPhotoServer(galleryElement.getAttribute(""primary_photo_server""));
        gallery.setPrimaryPhotoFarm(galleryElement.getAttribute(""primary_photo_farm""));
        gallery.setPrimaryPhotoSecret(galleryElement.getAttribute(""primary_photo_secret""));
        gallery.setPhotoCount(galleryElement.getAttribute(""count_photos""));
        gallery.setVideoCount(galleryElement.getAttribute(""count_videos""));

        gallery.setTitle(XMLUtilities.getChildValue(galleryElement, ""title""));
        gallery.setDesc(XMLUtilities.getChildValue(galleryElement, ""description""));
        return gallery;
    }

    /**
     * 
     * @param strTitle
     * @param strDescription
     * @param primaryPhotoId
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Gallery create(String strTitle, String strDescription, String primaryPhotoId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_CREATE);
        parameters.put(""title"", strTitle);
        parameters.put(""description"", strDescription);
        if (primaryPhotoId != null) {
            parameters.put(""primary_photo_id "", primaryPhotoId);
        }

        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element element = response.getPayload();
        NodeList galleryNodes = element.getElementsByTagName(""gallery"");
        Element galleryElement = (Element) galleryNodes.item(0);
        Gallery gallery = new Gallery();
        gallery.setId(galleryElement.getAttribute(""id""));
        gallery.setUrl(galleryElement.getAttribute(""url""));
        gallery.setTitle(strTitle);
        gallery.setDesc(strDescription);
        return gallery;
    }

    /**
     * Get the photos for the specified gallery
     * 
     * This method does not require authentication.
     * 
     * @param galleryId
     *            The group ID
     * @param extras
     *            Set of extra-attributes to include (may be null)
     * @param perPage
     *            The number of photos per page (0 to ignore)
     * @param page
     *            The page offset (0 to ignore)
     * @return A Collection of Photo objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PhotoList<Photo> getPhotos(String galleryId, Set<String> extras, int perPage, int page) throws FlickrException {
        PhotoList<Photo> photos = new PhotoList<Photo>();

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_PHOTOS);

        parameters.put(""gallery_id"", galleryId);

        if (extras != null) {
            StringBuffer sb = new StringBuffer();
            Iterator<String> it = extras.iterator();
            for (int i = 0; it.hasNext(); i++) {
                if (i > 0) {
                    sb.append("","");
                }
                sb.append(it.next());
            }
            parameters.put(Extras.KEY_EXTRAS, sb.toString());
        }

        if (perPage > 0) {
            parameters.put(""per_page"", String.valueOf(perPage));
        }
        if (page > 0) {
            parameters.put(""page"", String.valueOf(page));
        }

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element photosElement = response.getPayload();
        photos.setPage(photosElement.getAttribute(""page""));
        photos.setPages(photosElement.getAttribute(""pages""));
        photos.setPerPage(photosElement.getAttribute(""perpage""));
        photos.setTotal(photosElement.getAttribute(""total""));

        NodeList photoNodes = photosElement.getElementsByTagName(""photo"");
        for (int i = 0; i < photoNodes.getLength(); i++) {
            Element photoElement = (Element) photoNodes.item(i);
            Photo photo = new Photo();
            photo.setId(photoElement.getAttribute(""id""));
            photo.setSecret(photoElement.getAttribute(""secret""));

            User owner = new User();
            owner.setId(photoElement.getAttribute(""owner""));
            photo.setOwner(owner);
            photo.setUrl(""https://flickr.com/photos/"" + owner.getId() + ""/"" + photo.getId());
            photo.setServer(photoElement.getAttribute(""server""));
            photo.setFarm(photoElement.getAttribute(""farm""));
            photo.setTitle(photoElement.getAttribute(""title""));
            photo.setPublicFlag(""1"".equals(photoElement.getAttribute(""ispublic"")));
            photo.setFriendFlag(""1"".equals(photoElement.getAttribute(""isfriend"")));
            photo.setFamilyFlag(""1"".equals(photoElement.getAttribute(""isfamily"")));
            photo.setPrimary(""1"".equals(photoElement.getAttribute(""is_primary"")));
            photo.setComments(photoElement.getAttribute(""has_comment""));
            photos.add(photo);
        }

        return photos;
    }

    /**
     * 
     * This method does not require authentication.
     * 
     * @param photoId
     *            The photo ID
     * @param perPage
     *            The number of photos per page (0 to ignore)
     * @param page
     *            The page offset (0 to ignore)
     * @return A Collection of Photo objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PhotoList<Photo> getListForPhoto(String photoId, int perPage, int page) throws FlickrException {
        PhotoList<Photo> photos = new PhotoList<Photo>();

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_LIST_FOR_PHOTO);

        parameters.put(""photo_id"", photoId);

        if (perPage > 0) {
            parameters.put(""per_page"", String.valueOf(perPage));
        }
        if (page > 0) {
            parameters.put(""page"", String.valueOf(page));
        }

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element photosElement = response.getPayload();
        photos.setPage(photosElement.getAttribute(""page""));
        photos.setPages(photosElement.getAttribute(""pages""));
        photos.setPerPage(photosElement.getAttribute(""perpage""));
        photos.setTotal(photosElement.getAttribute(""total""));

        NodeList photoNodes = photosElement.getElementsByTagName(""photo"");
        for (int i = 0; i < photoNodes.getLength(); i++) {
            Element photoElement = (Element) photoNodes.item(i);
            Photo photo = new Photo();
            photo.setId(photoElement.getAttribute(""id""));
            photo.setSecret(photoElement.getAttribute(""secret""));

            User owner = new User();
            owner.setId(photoElement.getAttribute(""owner""));
            photo.setOwner(owner);
            photo.setUrl(""https://flickr.com/photos/"" + owner.getId() + ""/"" + photo.getId());
            photo.setServer(photoElement.getAttribute(""server""));
            photo.setFarm(photoElement.getAttribute(""farm""));
            photo.setTitle(photoElement.getAttribute(""title""));
            photo.setPublicFlag(""1"".equals(photoElement.getAttribute(""ispublic"")));
            photo.setFriendFlag(""1"".equals(photoElement.getAttribute(""isfriend"")));
            photo.setFamilyFlag(""1"".equals(photoElement.getAttribute(""isfamily"")));
            photo.setPrimary(""1"".equals(photoElement.getAttribute(""is_primary"")));
            photo.setComments(photoElement.getAttribute(""has_comment""));
            photos.add(photo);
        }

        return photos;
    }
}
","package com.flickr4java.flickr.galleries; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.photos.Extras; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; public class GalleriesInterface { public static final String METHOD_ADD_PHOTO = ""flickr.galleries.addPhoto""; public static final String METHOD_CREATE = ""flickr.galleries.create""; public static final String METHOD_EDIT_META = ""flickr.galleries.editMeta""; public static final String METHOD_EDIT_PHOTO = ""flickr.galleries.editPhoto""; public static final String METHOD_EDIT_PHOTOS = ""flickr.galleries.editPhotos""; public static final String METHOD_GET_INFO = ""flickr.galleries.getInfo""; public static final String METHOD_GET_LIST = ""flickr.galleries.getList""; public static final String METHOD_GET_LIST_FOR_PHOTO = ""flickr.galleries.getListForPhoto""; public static final String METHOD_GET_PHOTOS = ""flickr.galleries.getPhotos""; private String apiKey; private String sharedSecret; private Transport transport; public GalleriesInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transport = transportAPI; } public List<Gallery> getList(String userId, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); parameters.put(""user_id"", userId); if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); } Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element element = response.getPayload(); GalleryList<Gallery> galleries = new GalleryList<Gallery>(); galleries.setPage(element.getAttribute(""page"")); galleries.setPages(element.getAttribute(""pages"")); galleries.setPerPage(element.getAttribute(""per_page"")); galleries.setTotal(element.getAttribute(""total"")); NodeList galleryNodes = element.getElementsByTagName(""gallery""); for (int i = 0; i < galleryNodes.getLength(); i++) { Element galleryElement = (Element) galleryNodes.item(i); Gallery gallery = new Gallery(); gallery.setId(galleryElement.getAttribute(""id"")); gallery.setUrl(galleryElement.getAttribute(""url"")); User owner = new User(); owner.setId(galleryElement.getAttribute(""owner"")); gallery.setOwner(owner); gallery.setCreateDate(galleryElement.getAttribute(""date_create"")); gallery.setUpdateDate(galleryElement.getAttribute(""date_update"")); gallery.setPrimaryPhotoId(galleryElement.getAttribute(""primary_photo_id"")); gallery.setPrimaryPhotoServer(galleryElement.getAttribute(""primary_photo_server"")); gallery.setPrimaryPhotoFarm(galleryElement.getAttribute(""primary_photo_farm"")); gallery.setPrimaryPhotoSecret(galleryElement.getAttribute(""primary_photo_secret"")); gallery.setPhotoCount(galleryElement.getAttribute(""count_photos"")); gallery.setVideoCount(galleryElement.getAttribute(""count_videos"")); galleries.add(gallery); } return galleries; } public void addPhoto(String strGalleryId, String photoId, String strComment) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD_PHOTO); parameters.put(""gallery_id"", strGalleryId); parameters.put(""photo_id"", photoId); parameters.put(""comment"", strComment); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void editMeta(String strGalleryId, String strTitle, String strDescription) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT_META); parameters.put(""title"", strTitle); parameters.put(""description"", strDescription); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void editPhoto(String strGalleryId, String strPhotoId, String strComment) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT_PHOTO); parameters.put(""gallery_id"", strGalleryId); parameters.put(""photo_id"", strPhotoId); parameters.put(""comment"", strComment); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void editPhotos(String strGalleryId, String strPrimaryPhotoId, String strPhotoIds) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT_PHOTOS); parameters.put(""gallery_id"", strGalleryId); parameters.put(""primary_photo_id"", strPrimaryPhotoId); parameters.put(""photo_ids"", strPhotoIds); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public Gallery getInfo(String strGalleryId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO); parameters.put(""gallery_id"", strGalleryId); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element galleryElement = response.getPayload(); Gallery gallery = new Gallery(); gallery.setId(galleryElement.getAttribute(""id"")); gallery.setUrl(galleryElement.getAttribute(""url"")); User owner = new User(); owner.setId(galleryElement.getAttribute(""owner"")); gallery.setOwner(owner); gallery.setCreateDate(galleryElement.getAttribute(""date_create"")); gallery.setUpdateDate(galleryElement.getAttribute(""date_update"")); gallery.setPrimaryPhotoId(galleryElement.getAttribute(""primary_photo_id"")); gallery.setPrimaryPhotoServer(galleryElement.getAttribute(""primary_photo_server"")); gallery.setPrimaryPhotoFarm(galleryElement.getAttribute(""primary_photo_farm"")); gallery.setPrimaryPhotoSecret(galleryElement.getAttribute(""primary_photo_secret"")); gallery.setPhotoCount(galleryElement.getAttribute(""count_photos"")); gallery.setVideoCount(galleryElement.getAttribute(""count_videos"")); gallery.setTitle(XMLUtilities.getChildValue(galleryElement, ""title"")); gallery.setDesc(XMLUtilities.getChildValue(galleryElement, ""description"")); return gallery; } public Gallery create(String strTitle, String strDescription, String primaryPhotoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_CREATE); parameters.put(""title"", strTitle); parameters.put(""description"", strDescription); if (primaryPhotoId != null) { parameters.put(""primary_photo_id "", primaryPhotoId); } Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element element = response.getPayload(); NodeList galleryNodes = element.getElementsByTagName(""gallery""); Element galleryElement = (Element) galleryNodes.item(0); Gallery gallery = new Gallery(); gallery.setId(galleryElement.getAttribute(""id"")); gallery.setUrl(galleryElement.getAttribute(""url"")); gallery.setTitle(strTitle); gallery.setDesc(strDescription); return gallery; } public PhotoList<Photo> getPhotos(String galleryId, Set<String> extras, int perPage, int page) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PHOTOS); parameters.put(""gallery_id"", galleryId); if (extras != null) { StringBuffer sb = new StringBuffer(); Iterator<String> it = extras.iterator(); for (int i = 0; it.hasNext(); i++) { if (i > 0) { sb.append("",""); } sb.append(it.next()); } parameters.put(Extras.KEY_EXTRAS, sb.toString()); } if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); Photo photo = new Photo(); photo.setId(photoElement.getAttribute(""id"")); photo.setSecret(photoElement.getAttribute(""secret"")); User owner = new User(); owner.setId(photoElement.getAttribute(""owner"")); photo.setOwner(owner); photo.setServer(photoElement.getAttribute(""server"")); photo.setFarm(photoElement.getAttribute(""farm"")); photo.setTitle(photoElement.getAttribute(""title"")); photo.setPublicFlag(""1"".equals(photoElement.getAttribute(""ispublic""))); photo.setFriendFlag(""1"".equals(photoElement.getAttribute(""isfriend""))); photo.setFamilyFlag(""1"".equals(photoElement.getAttribute(""isfamily""))); photo.setPrimary(""1"".equals(photoElement.getAttribute(""is_primary""))); photo.setComments(photoElement.getAttribute(""has_comment"")); photos.add(photo); } return photos; } public PhotoList<Photo> getListForPhoto(String photoId, int perPage, int page) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST_FOR_PHOTO); parameters.put(""photo_id"", photoId); if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); Photo photo = new Photo(); photo.setId(photoElement.getAttribute(""id"")); photo.setSecret(photoElement.getAttribute(""secret"")); User owner = new User(); owner.setId(photoElement.getAttribute(""owner"")); photo.setOwner(owner); photo.setServer(photoElement.getAttribute(""server"")); photo.setFarm(photoElement.getAttribute(""farm"")); photo.setTitle(photoElement.getAttribute(""title"")); photo.setPublicFlag(""1"".equals(photoElement.getAttribute(""ispublic""))); photo.setFriendFlag(""1"".equals(photoElement.getAttribute(""isfriend""))); photo.setFamilyFlag(""1"".equals(photoElement.getAttribute(""isfamily""))); photo.setPrimary(""1"".equals(photoElement.getAttribute(""is_primary""))); photo.setComments(photoElement.getAttribute(""has_comment"")); photos.add(photo); } return photos; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.galleries; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.photos.Extras; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; public class GalleriesInterface { public static final String METHOD_ADD_PHOTO = ""flickr.galleries.addPhoto""; public static final String METHOD_CREATE = ""flickr.galleries.create""; public static final String METHOD_EDIT_META = ""flickr.galleries.editMeta""; public static final String METHOD_EDIT_PHOTO = ""flickr.galleries.editPhoto""; public static final String METHOD_EDIT_PHOTOS = ""flickr.galleries.editPhotos""; public static final String METHOD_GET_INFO = ""flickr.galleries.getInfo""; public static final String METHOD_GET_LIST = ""flickr.galleries.getList""; public static final String METHOD_GET_LIST_FOR_PHOTO = ""flickr.galleries.getListForPhoto""; public static final String METHOD_GET_PHOTOS = ""flickr.galleries.getPhotos""; private String apiKey; private String sharedSecret; private Transport transport; public GalleriesInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transport = transportAPI; } public List<Gallery> getList(String userId, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); parameters.put(""user_id"", userId); if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); } Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element element = response.getPayload(); GalleryList<Gallery> galleries = new GalleryList<Gallery>(); galleries.setPage(element.getAttribute(""page"")); galleries.setPages(element.getAttribute(""pages"")); galleries.setPerPage(element.getAttribute(""per_page"")); galleries.setTotal(element.getAttribute(""total"")); NodeList galleryNodes = element.getElementsByTagName(""gallery""); for (int i = 0; i < galleryNodes.getLength(); i++) { Element galleryElement = (Element) galleryNodes.item(i); Gallery gallery = new Gallery(); gallery.setId(galleryElement.getAttribute(""id"")); gallery.setUrl(galleryElement.getAttribute(""url"")); User owner = new User(); owner.setId(galleryElement.getAttribute(""owner"")); gallery.setOwner(owner); gallery.setCreateDate(galleryElement.getAttribute(""date_create"")); gallery.setUpdateDate(galleryElement.getAttribute(""date_update"")); gallery.setPrimaryPhotoId(galleryElement.getAttribute(""primary_photo_id"")); gallery.setPrimaryPhotoServer(galleryElement.getAttribute(""primary_photo_server"")); gallery.setPrimaryPhotoFarm(galleryElement.getAttribute(""primary_photo_farm"")); gallery.setPrimaryPhotoSecret(galleryElement.getAttribute(""primary_photo_secret"")); gallery.setPhotoCount(galleryElement.getAttribute(""count_photos"")); gallery.setVideoCount(galleryElement.getAttribute(""count_videos"")); galleries.add(gallery); } return galleries; } public void addPhoto(String strGalleryId, String photoId, String strComment) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD_PHOTO); parameters.put(""gallery_id"", strGalleryId); parameters.put(""photo_id"", photoId); parameters.put(""comment"", strComment); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void editMeta(String strGalleryId, String strTitle, String strDescription) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT_META); parameters.put(""title"", strTitle); parameters.put(""description"", strDescription); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void editPhoto(String strGalleryId, String strPhotoId, String strComment) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT_PHOTO); parameters.put(""gallery_id"", strGalleryId); parameters.put(""photo_id"", strPhotoId); parameters.put(""comment"", strComment); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void editPhotos(String strGalleryId, String strPrimaryPhotoId, String strPhotoIds) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT_PHOTOS); parameters.put(""gallery_id"", strGalleryId); parameters.put(""primary_photo_id"", strPrimaryPhotoId); parameters.put(""photo_ids"", strPhotoIds); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public Gallery getInfo(String strGalleryId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO); parameters.put(""gallery_id"", strGalleryId); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element galleryElement = response.getPayload(); Gallery gallery = new Gallery(); gallery.setId(galleryElement.getAttribute(""id"")); gallery.setUrl(galleryElement.getAttribute(""url"")); User owner = new User(); owner.setId(galleryElement.getAttribute(""owner"")); gallery.setOwner(owner); gallery.setCreateDate(galleryElement.getAttribute(""date_create"")); gallery.setUpdateDate(galleryElement.getAttribute(""date_update"")); gallery.setPrimaryPhotoId(galleryElement.getAttribute(""primary_photo_id"")); gallery.setPrimaryPhotoServer(galleryElement.getAttribute(""primary_photo_server"")); gallery.setPrimaryPhotoFarm(galleryElement.getAttribute(""primary_photo_farm"")); gallery.setPrimaryPhotoSecret(galleryElement.getAttribute(""primary_photo_secret"")); gallery.setPhotoCount(galleryElement.getAttribute(""count_photos"")); gallery.setVideoCount(galleryElement.getAttribute(""count_videos"")); gallery.setTitle(XMLUtilities.getChildValue(galleryElement, ""title"")); gallery.setDesc(XMLUtilities.getChildValue(galleryElement, ""description"")); return gallery; } public Gallery create(String strTitle, String strDescription, String primaryPhotoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_CREATE); parameters.put(""title"", strTitle); parameters.put(""description"", strDescription); if (primaryPhotoId != null) { parameters.put(""primary_photo_id "", primaryPhotoId); } Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element element = response.getPayload(); NodeList galleryNodes = element.getElementsByTagName(""gallery""); Element galleryElement = (Element) galleryNodes.item(0); Gallery gallery = new Gallery(); gallery.setId(galleryElement.getAttribute(""id"")); gallery.setUrl(galleryElement.getAttribute(""url"")); gallery.setTitle(strTitle); gallery.setDesc(strDescription); return gallery; } public PhotoList<Photo> getPhotos(String galleryId, Set<String> extras, int perPage, int page) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PHOTOS); parameters.put(""gallery_id"", galleryId); if (extras != null) { StringBuffer sb = new StringBuffer(); Iterator<String> it = extras.iterator(); for (int i = 0; it.hasNext(); i++) { if (i > 0) { sb.append("",""); } sb.append(it.next()); } parameters.put(Extras.KEY_EXTRAS, sb.toString()); } if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); Photo photo = new Photo(); photo.setId(photoElement.getAttribute(""id"")); photo.setSecret(photoElement.getAttribute(""secret"")); User owner = new User(); owner.setId(photoElement.getAttribute(""owner"")); photo.setOwner(owner); photo.setServer(photoElement.getAttribute(""server"")); photo.setFarm(photoElement.getAttribute(""farm"")); photo.setTitle(photoElement.getAttribute(""title"")); photo.setPublicFlag(""1"".equals(photoElement.getAttribute(""ispublic""))); photo.setFriendFlag(""1"".equals(photoElement.getAttribute(""isfriend""))); photo.setFamilyFlag(""1"".equals(photoElement.getAttribute(""isfamily""))); photo.setPrimary(""1"".equals(photoElement.getAttribute(""is_primary""))); photo.setComments(photoElement.getAttribute(""has_comment"")); photos.add(photo); } return photos; } public PhotoList<Photo> getListForPhoto(String photoId, int perPage, int page) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST_FOR_PHOTO); parameters.put(""photo_id"", photoId); if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); Photo photo = new Photo(); photo.setId(photoElement.getAttribute(""id"")); photo.setSecret(photoElement.getAttribute(""secret"")); User owner = new User(); owner.setId(photoElement.getAttribute(""owner"")); photo.setOwner(owner); photo.setServer(photoElement.getAttribute(""server"")); photo.setFarm(photoElement.getAttribute(""farm"")); photo.setTitle(photoElement.getAttribute(""title"")); photo.setPublicFlag(""1"".equals(photoElement.getAttribute(""ispublic""))); photo.setFriendFlag(""1"".equals(photoElement.getAttribute(""isfriend""))); photo.setFamilyFlag(""1"".equals(photoElement.getAttribute(""isfamily""))); photo.setPrimary(""1"".equals(photoElement.getAttribute(""is_primary""))); photo.setComments(photoElement.getAttribute(""has_comment"")); photos.add(photo); } return photos; } } ","/**
 * @author acaplan
 */ package com.flickr4java.flickr.galleries;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.photos.Extras; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.util.XMLUtilities;  import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set;  /**
 * @author acaplan
 * 
 */ public class GalleriesInterface {  public static final String METHOD_ADD_PHOTO = ""flickr.galleries.addPhoto"";  public static final String METHOD_CREATE = ""flickr.galleries.create"";  public static final String METHOD_EDIT_META = ""flickr.galleries.editMeta"";  public static final String METHOD_EDIT_PHOTO = ""flickr.galleries.editPhoto"";  public static final String METHOD_EDIT_PHOTOS = ""flickr.galleries.editPhotos"";  public static final String METHOD_GET_INFO = ""flickr.galleries.getInfo"";  public static final String METHOD_GET_LIST = ""flickr.galleries.getList"";  public static final String METHOD_GET_LIST_FOR_PHOTO = ""flickr.galleries.getListForPhoto"";  public static final String METHOD_GET_PHOTOS = ""flickr.galleries.getPhotos"";  private String apiKey;  private String sharedSecret;  private Transport transport;  /**
     * Construct a GalleriesInterface.
     * 
     * @param apiKey
     *            The API key
     * @param transportAPI
     *            The Transport interface
     */ public GalleriesInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transport = transportAPI; }  /**
     * Return the list of galleries created by a user. Sorted from newest to oldest.
     * 
     * @param userId
     *            The user you want to check for
     * @param perPage
     *            Number of galleries per page
     * @param page
     *            The page number
     * @return gallery
     * @throws FlickrException if there was a problem connecting to Flickr
     * 
     * @see <a href=""https://www.flickr.com/services/api/flickr.galleries.getList.html"">flickr.galleries.getList</a>
     */ public List<Gallery> getList(String userId, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); parameters.put(""user_id"", userId); if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); }  Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element element = response.getPayload(); GalleryList<Gallery> galleries = new GalleryList<Gallery>(); galleries.setPage(element.getAttribute(""page"")); galleries.setPages(element.getAttribute(""pages"")); galleries.setPerPage(element.getAttribute(""per_page"")); galleries.setTotal(element.getAttribute(""total""));  NodeList galleryNodes = element.getElementsByTagName(""gallery""); for (int i = 0; i < galleryNodes.getLength(); i++) { Element galleryElement = (Element) galleryNodes.item(i); Gallery gallery = new Gallery(); gallery.setId(galleryElement.getAttribute(""id"")); gallery.setUrl(galleryElement.getAttribute(""url""));  User owner = new User(); owner.setId(galleryElement.getAttribute(""owner"")); gallery.setOwner(owner); gallery.setCreateDate(galleryElement.getAttribute(""date_create"")); gallery.setUpdateDate(galleryElement.getAttribute(""date_update"")); gallery.setPrimaryPhotoId(galleryElement.getAttribute(""primary_photo_id"")); gallery.setPrimaryPhotoServer(galleryElement.getAttribute(""primary_photo_server"")); gallery.setPrimaryPhotoFarm(galleryElement.getAttribute(""primary_photo_farm"")); gallery.setPrimaryPhotoSecret(galleryElement.getAttribute(""primary_photo_secret"")); gallery.setPhotoCount(galleryElement.getAttribute(""count_photos"")); gallery.setVideoCount(galleryElement.getAttribute(""count_videos""));  galleries.add(gallery); } return galleries; }  public void addPhoto(String strGalleryId, String photoId, String strComment) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD_PHOTO); parameters.put(""gallery_id"", strGalleryId); parameters.put(""photo_id"", photoId); parameters.put(""comment"", strComment);  Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  public void editMeta(String strGalleryId, String strTitle, String strDescription) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT_META); parameters.put(""title"", strTitle); parameters.put(""description"", strDescription);  Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  public void editPhoto(String strGalleryId, String strPhotoId, String strComment) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT_PHOTO); parameters.put(""gallery_id"", strGalleryId); parameters.put(""photo_id"", strPhotoId); parameters.put(""comment"", strComment);  Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  public void editPhotos(String strGalleryId, String strPrimaryPhotoId, String strPhotoIds) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT_PHOTOS); parameters.put(""gallery_id"", strGalleryId); parameters.put(""primary_photo_id"", strPrimaryPhotoId); parameters.put(""photo_ids"", strPhotoIds);  Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  public Gallery getInfo(String strGalleryId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO); parameters.put(""gallery_id"", strGalleryId);  Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element galleryElement = response.getPayload(); Gallery gallery = new Gallery(); gallery.setId(galleryElement.getAttribute(""id"")); gallery.setUrl(galleryElement.getAttribute(""url""));  User owner = new User(); owner.setId(galleryElement.getAttribute(""owner"")); gallery.setOwner(owner); gallery.setCreateDate(galleryElement.getAttribute(""date_create"")); gallery.setUpdateDate(galleryElement.getAttribute(""date_update"")); gallery.setPrimaryPhotoId(galleryElement.getAttribute(""primary_photo_id"")); gallery.setPrimaryPhotoServer(galleryElement.getAttribute(""primary_photo_server"")); gallery.setPrimaryPhotoFarm(galleryElement.getAttribute(""primary_photo_farm"")); gallery.setPrimaryPhotoSecret(galleryElement.getAttribute(""primary_photo_secret"")); gallery.setPhotoCount(galleryElement.getAttribute(""count_photos"")); gallery.setVideoCount(galleryElement.getAttribute(""count_videos""));  gallery.setTitle(XMLUtilities.getChildValue(galleryElement, ""title"")); gallery.setDesc(XMLUtilities.getChildValue(galleryElement, ""description"")); return gallery; }  /**
     * 
     * @param strTitle
     * @param strDescription
     * @param primaryPhotoId
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Gallery create(String strTitle, String strDescription, String primaryPhotoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_CREATE); parameters.put(""title"", strTitle); parameters.put(""description"", strDescription); if (primaryPhotoId != null) { parameters.put(""primary_photo_id "", primaryPhotoId); }  Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element element = response.getPayload(); NodeList galleryNodes = element.getElementsByTagName(""gallery""); Element galleryElement = (Element) galleryNodes.item(0); Gallery gallery = new Gallery(); gallery.setId(galleryElement.getAttribute(""id"")); gallery.setUrl(galleryElement.getAttribute(""url"")); gallery.setTitle(strTitle); gallery.setDesc(strDescription); return gallery; }  /**
     * Get the photos for the specified gallery
     * 
     * This method does not require authentication.
     * 
     * @param galleryId
     *            The group ID
     * @param extras
     *            Set of extra-attributes to include (may be null)
     * @param perPage
     *            The number of photos per page (0 to ignore)
     * @param page
     *            The page offset (0 to ignore)
     * @return A Collection of Photo objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PhotoList<Photo> getPhotos(String galleryId, Set<String> extras, int perPage, int page) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>();  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PHOTOS);  parameters.put(""gallery_id"", galleryId);  if (extras != null) { StringBuffer sb = new StringBuffer(); Iterator<String> it = extras.iterator(); for (int i = 0; it.hasNext(); i++) { if (i > 0) { sb.append("",""); } sb.append(it.next()); } parameters.put(Extras.KEY_EXTRAS, sb.toString()); }  if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); }  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total""));  NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); Photo photo = new Photo(); photo.setId(photoElement.getAttribute(""id"")); photo.setSecret(photoElement.getAttribute(""secret""));  User owner = new User(); owner.setId(photoElement.getAttribute(""owner"")); photo.setOwner(owner); //flickr.com/photos/"" + owner.getId() + ""/"" + photo.getId()); photo.setServer(photoElement.getAttribute(""server"")); photo.setFarm(photoElement.getAttribute(""farm"")); photo.setTitle(photoElement.getAttribute(""title"")); photo.setPublicFlag(""1"".equals(photoElement.getAttribute(""ispublic""))); photo.setFriendFlag(""1"".equals(photoElement.getAttribute(""isfriend""))); photo.setFamilyFlag(""1"".equals(photoElement.getAttribute(""isfamily""))); photo.setPrimary(""1"".equals(photoElement.getAttribute(""is_primary""))); photo.setComments(photoElement.getAttribute(""has_comment"")); photos.add(photo); }  return photos; }  /**
     * 
     * This method does not require authentication.
     * 
     * @param photoId
     *            The photo ID
     * @param perPage
     *            The number of photos per page (0 to ignore)
     * @param page
     *            The page offset (0 to ignore)
     * @return A Collection of Photo objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PhotoList<Photo> getListForPhoto(String photoId, int perPage, int page) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>();  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST_FOR_PHOTO);  parameters.put(""photo_id"", photoId);  if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); }  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total""));  NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); Photo photo = new Photo(); photo.setId(photoElement.getAttribute(""id"")); photo.setSecret(photoElement.getAttribute(""secret""));  User owner = new User(); owner.setId(photoElement.getAttribute(""owner"")); photo.setOwner(owner); //flickr.com/photos/"" + owner.getId() + ""/"" + photo.getId()); photo.setServer(photoElement.getAttribute(""server"")); photo.setFarm(photoElement.getAttribute(""farm"")); photo.setTitle(photoElement.getAttribute(""title"")); photo.setPublicFlag(""1"".equals(photoElement.getAttribute(""ispublic""))); photo.setFriendFlag(""1"".equals(photoElement.getAttribute(""isfriend""))); photo.setFamilyFlag(""1"".equals(photoElement.getAttribute(""isfamily""))); photo.setPrimary(""1"".equals(photoElement.getAttribute(""is_primary""))); photo.setComments(photoElement.getAttribute(""has_comment"")); photos.add(photo); }  return photos; } }  "
src/main/java/com/flickr4java/flickr/galleries/Gallery.java,"/**
 * @author acaplan
 */
package com.flickr4java.flickr.galleries;

import com.flickr4java.flickr.people.User;

/**
 * @author acaplan
 * 
 */
public class Gallery {

    private String strCreateDate;

    private String strUpdateDate;

    private String strPrimaryPhotoId;

    private String strPrimaryPhotoServer;

    private String strPrimaryPhotoFarm;

    private String strPrimaryPhotoSecret;

    private String strPhotoCount;

    private String strVideoCount;

    private String strTitle;

    private String strDesc;

    private String strUrl;

    private User owner;

    private String id;

    public Gallery() {
    }

    /**
     * @return the strTitle
     */
    public String getTitle() {
        return strTitle;
    }

    /**
     * @param strTitle
     *            the strTitle to set
     */
    public void setTitle(String strTitle) {
        this.strTitle = strTitle;
    }

    /**
     * @return the strDesc
     */
    public String getDesc() {
        return strDesc;
    }

    /**
     * @param strDesc
     *            the strDesc to set
     */
    public void setDesc(String strDesc) {
        this.strDesc = strDesc;
    }

    /**
     * @return the strUrl
     */
    public String getUrl() {
        return strUrl;
    }

    /**
     * @param strUrl
     *            the strUrl to set
     */
    public void setUrl(String strUrl) {
        this.strUrl = strUrl;
    }

    /**
     * @return the strCreateDate
     */
    public String getCreateDate() {
        return strCreateDate;
    }

    /**
     * @param strCreateDate
     *            the strCreateDate to set
     */
    public void setCreateDate(String strCreateDate) {
        this.strCreateDate = strCreateDate;
    }

    /**
     * @return the strUpdateDate
     */
    public String getUpdateDate() {
        return strUpdateDate;
    }

    /**
     * @param strUpdateDate
     *            the strUpdateDate to set
     */
    public void setUpdateDate(String strUpdateDate) {
        this.strUpdateDate = strUpdateDate;
    }

    /**
     * @return the strPrimaryPhotoId
     */
    public String getPrimaryPhotoId() {
        return strPrimaryPhotoId;
    }

    /**
     * @param strPrimaryPhotoId
     *            the strPrimaryPhotoId to set
     */
    public void setPrimaryPhotoId(String strPrimaryPhotoId) {
        this.strPrimaryPhotoId = strPrimaryPhotoId;
    }

    /**
     * @return the strPrimaryPhotoServer
     */
    public String getPrimaryPhotoServer() {
        return strPrimaryPhotoServer;
    }

    /**
     * @param strPrimaryPhotoServer
     *            the strPrimaryPhotoServer to set
     */
    public void setPrimaryPhotoServer(String strPrimaryPhotoServer) {
        this.strPrimaryPhotoServer = strPrimaryPhotoServer;
    }

    /**
     * @return the strPrimaryPhotoFarm
     */
    public String getPrimaryPhotoFarm() {
        return strPrimaryPhotoFarm;
    }

    /**
     * @param strPrimaryPhotoFarm
     *            the strPrimaryPhotoFarm to set
     */
    public void setPrimaryPhotoFarm(String strPrimaryPhotoFarm) {
        this.strPrimaryPhotoFarm = strPrimaryPhotoFarm;
    }

    /**
     * @return the strPrimaryPhotoSecret
     */
    public String getPrimaryPhotoSecret() {
        return strPrimaryPhotoSecret;
    }

    /**
     * @param strPrimaryPhotoSecret
     *            the strPrimaryPhotoSecret to set
     */
    public void setPrimaryPhotoSecret(String strPrimaryPhotoSecret) {
        this.strPrimaryPhotoSecret = strPrimaryPhotoSecret;
    }

    /**
     * @return the strPhotoCount
     */
    public String getPhotoCount() {
        return strPhotoCount;
    }

    /**
     * @param strPhotoCount
     *            the strPhotoCount to set
     */
    public void setPhotoCount(String strPhotoCount) {
        this.strPhotoCount = strPhotoCount;
    }

    /**
     * @return the strVideoCount
     */
    public String getVideoCount() {
        return strVideoCount;
    }

    /**
     * @param strVideoCount
     *            the strVideoCount to set
     */
    public void setVideoCount(String strVideoCount) {
        this.strVideoCount = strVideoCount;
    }

    /**
     * @param owner
     */
    public void setOwner(User owner) {
        this.owner = owner;
    }

    public User getOwner() {
        return this.owner;
    }

    /**
     * @return the id
     */
    public String getId() {
        return id;
    }

    /**
     * @param id
     *            the id to set
     */
    public void setId(String id) {
        this.id = id;
    }

}
",package com.flickr4java.flickr.galleries; import com.flickr4java.flickr.people.User; public class Gallery { private String strCreateDate; private String strUpdateDate; private String strPrimaryPhotoId; private String strPrimaryPhotoServer; private String strPrimaryPhotoFarm; private String strPrimaryPhotoSecret; private String strPhotoCount; private String strVideoCount; private String strTitle; private String strDesc; private String strUrl; private User owner; private String id; public Gallery() { } public String getTitle() { return strTitle; } public void setTitle(String strTitle) { this.strTitle = strTitle; } public String getDesc() { return strDesc; } public void setDesc(String strDesc) { this.strDesc = strDesc; } public String getUrl() { return strUrl; } public void setUrl(String strUrl) { this.strUrl = strUrl; } public String getCreateDate() { return strCreateDate; } public void setCreateDate(String strCreateDate) { this.strCreateDate = strCreateDate; } public String getUpdateDate() { return strUpdateDate; } public void setUpdateDate(String strUpdateDate) { this.strUpdateDate = strUpdateDate; } public String getPrimaryPhotoId() { return strPrimaryPhotoId; } public void setPrimaryPhotoId(String strPrimaryPhotoId) { this.strPrimaryPhotoId = strPrimaryPhotoId; } public String getPrimaryPhotoServer() { return strPrimaryPhotoServer; } public void setPrimaryPhotoServer(String strPrimaryPhotoServer) { this.strPrimaryPhotoServer = strPrimaryPhotoServer; } public String getPrimaryPhotoFarm() { return strPrimaryPhotoFarm; } public void setPrimaryPhotoFarm(String strPrimaryPhotoFarm) { this.strPrimaryPhotoFarm = strPrimaryPhotoFarm; } public String getPrimaryPhotoSecret() { return strPrimaryPhotoSecret; } public void setPrimaryPhotoSecret(String strPrimaryPhotoSecret) { this.strPrimaryPhotoSecret = strPrimaryPhotoSecret; } public String getPhotoCount() { return strPhotoCount; } public void setPhotoCount(String strPhotoCount) { this.strPhotoCount = strPhotoCount; } public String getVideoCount() { return strVideoCount; } public void setVideoCount(String strVideoCount) { this.strVideoCount = strVideoCount; } public void setOwner(User owner) { this.owner = owner; } public User getOwner() { return this.owner; } public String getId() { return id; } public void setId(String id) { this.id = id; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.galleries; import com.flickr4java.flickr.people.User; public class Gallery { private String strCreateDate; private String strUpdateDate; private String strPrimaryPhotoId; private String strPrimaryPhotoServer; private String strPrimaryPhotoFarm; private String strPrimaryPhotoSecret; private String strPhotoCount; private String strVideoCount; private String strTitle; private String strDesc; private String strUrl; private User owner; private String id; public Gallery() { } public String getTitle() { return strTitle; } public void setTitle(String strTitle) { this.strTitle = strTitle; } public String getDesc() { return strDesc; } public void setDesc(String strDesc) { this.strDesc = strDesc; } public String getUrl() { return strUrl; } public void setUrl(String strUrl) { this.strUrl = strUrl; } public String getCreateDate() { return strCreateDate; } public void setCreateDate(String strCreateDate) { this.strCreateDate = strCreateDate; } public String getUpdateDate() { return strUpdateDate; } public void setUpdateDate(String strUpdateDate) { this.strUpdateDate = strUpdateDate; } public String getPrimaryPhotoId() { return strPrimaryPhotoId; } public void setPrimaryPhotoId(String strPrimaryPhotoId) { this.strPrimaryPhotoId = strPrimaryPhotoId; } public String getPrimaryPhotoServer() { return strPrimaryPhotoServer; } public void setPrimaryPhotoServer(String strPrimaryPhotoServer) { this.strPrimaryPhotoServer = strPrimaryPhotoServer; } public String getPrimaryPhotoFarm() { return strPrimaryPhotoFarm; } public void setPrimaryPhotoFarm(String strPrimaryPhotoFarm) { this.strPrimaryPhotoFarm = strPrimaryPhotoFarm; } public String getPrimaryPhotoSecret() { return strPrimaryPhotoSecret; } public void setPrimaryPhotoSecret(String strPrimaryPhotoSecret) { this.strPrimaryPhotoSecret = strPrimaryPhotoSecret; } public String getPhotoCount() { return strPhotoCount; } public void setPhotoCount(String strPhotoCount) { this.strPhotoCount = strPhotoCount; } public String getVideoCount() { return strVideoCount; } public void setVideoCount(String strVideoCount) { this.strVideoCount = strVideoCount; } public void setOwner(User owner) { this.owner = owner; } public User getOwner() { return this.owner; } public String getId() { return id; } public void setId(String id) { this.id = id; } } ,"/**
 * @author acaplan
 */ package com.flickr4java.flickr.galleries;  import com.flickr4java.flickr.people.User;  /**
 * @author acaplan
 * 
 */ public class Gallery {  private String strCreateDate;  private String strUpdateDate;  private String strPrimaryPhotoId;  private String strPrimaryPhotoServer;  private String strPrimaryPhotoFarm;  private String strPrimaryPhotoSecret;  private String strPhotoCount;  private String strVideoCount;  private String strTitle;  private String strDesc;  private String strUrl;  private User owner;  private String id;  public Gallery() { }  /**
     * @return the strTitle
     */ public String getTitle() { return strTitle; }  /**
     * @param strTitle
     *            the strTitle to set
     */ public void setTitle(String strTitle) { this.strTitle = strTitle; }  /**
     * @return the strDesc
     */ public String getDesc() { return strDesc; }  /**
     * @param strDesc
     *            the strDesc to set
     */ public void setDesc(String strDesc) { this.strDesc = strDesc; }  /**
     * @return the strUrl
     */ public String getUrl() { return strUrl; }  /**
     * @param strUrl
     *            the strUrl to set
     */ public void setUrl(String strUrl) { this.strUrl = strUrl; }  /**
     * @return the strCreateDate
     */ public String getCreateDate() { return strCreateDate; }  /**
     * @param strCreateDate
     *            the strCreateDate to set
     */ public void setCreateDate(String strCreateDate) { this.strCreateDate = strCreateDate; }  /**
     * @return the strUpdateDate
     */ public String getUpdateDate() { return strUpdateDate; }  /**
     * @param strUpdateDate
     *            the strUpdateDate to set
     */ public void setUpdateDate(String strUpdateDate) { this.strUpdateDate = strUpdateDate; }  /**
     * @return the strPrimaryPhotoId
     */ public String getPrimaryPhotoId() { return strPrimaryPhotoId; }  /**
     * @param strPrimaryPhotoId
     *            the strPrimaryPhotoId to set
     */ public void setPrimaryPhotoId(String strPrimaryPhotoId) { this.strPrimaryPhotoId = strPrimaryPhotoId; }  /**
     * @return the strPrimaryPhotoServer
     */ public String getPrimaryPhotoServer() { return strPrimaryPhotoServer; }  /**
     * @param strPrimaryPhotoServer
     *            the strPrimaryPhotoServer to set
     */ public void setPrimaryPhotoServer(String strPrimaryPhotoServer) { this.strPrimaryPhotoServer = strPrimaryPhotoServer; }  /**
     * @return the strPrimaryPhotoFarm
     */ public String getPrimaryPhotoFarm() { return strPrimaryPhotoFarm; }  /**
     * @param strPrimaryPhotoFarm
     *            the strPrimaryPhotoFarm to set
     */ public void setPrimaryPhotoFarm(String strPrimaryPhotoFarm) { this.strPrimaryPhotoFarm = strPrimaryPhotoFarm; }  /**
     * @return the strPrimaryPhotoSecret
     */ public String getPrimaryPhotoSecret() { return strPrimaryPhotoSecret; }  /**
     * @param strPrimaryPhotoSecret
     *            the strPrimaryPhotoSecret to set
     */ public void setPrimaryPhotoSecret(String strPrimaryPhotoSecret) { this.strPrimaryPhotoSecret = strPrimaryPhotoSecret; }  /**
     * @return the strPhotoCount
     */ public String getPhotoCount() { return strPhotoCount; }  /**
     * @param strPhotoCount
     *            the strPhotoCount to set
     */ public void setPhotoCount(String strPhotoCount) { this.strPhotoCount = strPhotoCount; }  /**
     * @return the strVideoCount
     */ public String getVideoCount() { return strVideoCount; }  /**
     * @param strVideoCount
     *            the strVideoCount to set
     */ public void setVideoCount(String strVideoCount) { this.strVideoCount = strVideoCount; }  /**
     * @param owner
     */ public void setOwner(User owner) { this.owner = owner; }  public User getOwner() { return this.owner; }  /**
     * @return the id
     */ public String getId() { return id; }  /**
     * @param id
     *            the id to set
     */ public void setId(String id) { this.id = id; }  }  "
src/main/java/com/flickr4java/flickr/galleries/GalleryList.java,"package com.flickr4java.flickr.galleries;

import com.flickr4java.flickr.SearchResultList;

/**
 * @author acaplan
 * 
 */
public class GalleryList<T> extends SearchResultList<Gallery> {

    private static final long serialVersionUID = 8615256591460951313L;

}
",package com.flickr4java.flickr.galleries; import com.flickr4java.flickr.SearchResultList; public class GalleryList<T> extends SearchResultList<Gallery> { private static final long serialVersionUID = 8615256591460951313L; },0 0 0 0 0 0,package com.flickr4java.flickr.galleries; import com.flickr4java.flickr.SearchResultList; public class GalleryList<T> extends SearchResultList<Gallery> { private static final long serialVersionUID = 8615256591460951313L; } ,"package com.flickr4java.flickr.galleries;  import com.flickr4java.flickr.SearchResultList;  /**
 * @author acaplan
 * 
 */ public class GalleryList<T> extends SearchResultList<Gallery> {  private static final long serialVersionUID = 8615256591460951313L;  }  "
src/main/java/com/flickr4java/flickr/groups/Blast.java,"package com.flickr4java.flickr.groups;

public class Blast {

		private String dateBlastAdded;

	    private String userId;

	    private String blast;

	    /**
	     * Unix timestamp formatted date
	     * 
	     * @return date blast was added
	     */
	    public String getDateBlastAdded() {
	        return dateBlastAdded;
	    }

	    public void setDateBlastAdded(String dateBlastAdded) {
	        this.dateBlastAdded = dateBlastAdded;
	    }

	    /**
	     * Blaster's user_id
	     * 
	     * @return user_id
	     */
	    public String getUserId() {
	        return userId;
	    }

	    public void setUserId(String userId) {
	        this.userId = userId;
	    }

	    /**
	     * Text of the blast
	     * 
	     * @return blast text
	     */
	    public String getBlast() {
	        return blast;
	    }

	    public void setBlast(String blast) {
	        this.blast = blast;
	    }
	
}
",package com.flickr4java.flickr.groups; public class Blast { private String dateBlastAdded; private String userId; private String blast; public String getDateBlastAdded() { return dateBlastAdded; } public void setDateBlastAdded(String dateBlastAdded) { this.dateBlastAdded = dateBlastAdded; } public String getUserId() { return userId; } public void setUserId(String userId) { this.userId = userId; } public String getBlast() { return blast; } public void setBlast(String blast) { this.blast = blast; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.groups; public class Blast { private String dateBlastAdded; private String userId; private String blast; public String getDateBlastAdded() { return dateBlastAdded; } public void setDateBlastAdded(String dateBlastAdded) { this.dateBlastAdded = dateBlastAdded; } public String getUserId() { return userId; } public void setUserId(String userId) { this.userId = userId; } public String getBlast() { return blast; } public void setBlast(String blast) { this.blast = blast; } } ,"package com.flickr4java.flickr.groups;  public class Blast {  private String dateBlastAdded;  private String userId;  private String blast;  /**
	     * Unix timestamp formatted date
	     * 
	     * @return date blast was added
	     */ public String getDateBlastAdded() { return dateBlastAdded; }  public void setDateBlastAdded(String dateBlastAdded) { this.dateBlastAdded = dateBlastAdded; }  /**
	     * Blaster's user_id
	     * 
	     * @return user_id
	     */ public String getUserId() { return userId; }  public void setUserId(String userId) { this.userId = userId; }  /**
	     * Text of the blast
	     * 
	     * @return blast text
	     */ public String getBlast() { return blast; }  public void setBlast(String blast) { this.blast = blast; } 	 }  "
src/main/java/com/flickr4java/flickr/groups/Category.java,"
package com.flickr4java.flickr.groups;

import java.util.Collection;

/**
 * Class representing a group Category.
 * 
 * @author Anthony Eden
 */
public class Category {

    private String name;

    private String path;

    private String pathIds;

    private Collection<Subcategory> subcategories;

    private Collection<Group> groups;

    public Category() {

    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPath() {
        return path;
    }

    public void setPath(String path) {
        this.path = path;
    }

    public String getPathIds() {
        return pathIds;
    }

    public void setPathIds(String pathIds) {
        this.pathIds = pathIds;
    }

    public Collection<Subcategory> getSubcategories() {
        return subcategories;
    }

    public void setSubcategories(Collection<Subcategory> subcategories) {
        this.subcategories = subcategories;
    }

    public Collection<Group> getGroups() {
        return groups;
    }

    public void setGroups(Collection<Group> groups) {
        this.groups = groups;
    }

}
",package com.flickr4java.flickr.groups; import java.util.Collection; public class Category { private String name; private String path; private String pathIds; private Collection<Subcategory> subcategories; private Collection<Group> groups; public Category() { } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPath() { return path; } public void setPath(String path) { this.path = path; } public String getPathIds() { return pathIds; } public void setPathIds(String pathIds) { this.pathIds = pathIds; } public Collection<Subcategory> getSubcategories() { return subcategories; } public void setSubcategories(Collection<Subcategory> subcategories) { this.subcategories = subcategories; } public Collection<Group> getGroups() { return groups; } public void setGroups(Collection<Group> groups) { this.groups = groups; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.groups; import java.util.Collection; public class Category { private String name; private String path; private String pathIds; private Collection<Subcategory> subcategories; private Collection<Group> groups; public Category() { } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPath() { return path; } public void setPath(String path) { this.path = path; } public String getPathIds() { return pathIds; } public void setPathIds(String pathIds) { this.pathIds = pathIds; } public Collection<Subcategory> getSubcategories() { return subcategories; } public void setSubcategories(Collection<Subcategory> subcategories) { this.subcategories = subcategories; } public Collection<Group> getGroups() { return groups; } public void setGroups(Collection<Group> groups) { this.groups = groups; } } ," package com.flickr4java.flickr.groups;  import java.util.Collection;  /**
 * Class representing a group Category.
 * 
 * @author Anthony Eden
 */ public class Category {  private String name;  private String path;  private String pathIds;  private Collection<Subcategory> subcategories;  private Collection<Group> groups;  public Category() {  }  public String getName() { return name; }  public void setName(String name) { this.name = name; }  public String getPath() { return path; }  public void setPath(String path) { this.path = path; }  public String getPathIds() { return pathIds; }  public void setPathIds(String pathIds) { this.pathIds = pathIds; }  public Collection<Subcategory> getSubcategories() { return subcategories; }  public void setSubcategories(Collection<Subcategory> subcategories) { this.subcategories = subcategories; }  public Collection<Group> getGroups() { return groups; }  public void setGroups(Collection<Group> groups) { this.groups = groups; }  }  "
src/main/java/com/flickr4java/flickr/groups/Group.java,"
package com.flickr4java.flickr.groups;

import com.flickr4java.flickr.util.BuddyIconable;
import com.flickr4java.flickr.util.UrlUtilities;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Class representing a Flickr Group.
 * 
 * @author Anthony Eden
 */
public class Group implements BuddyIconable {

    private static Logger _log = LoggerFactory.getLogger(Group.class);

    private String id;

    private String name;

    private int members;

    private int poolCount;

    private int topicCount;

    private String privacy;

    private int iconFarm;

    private int iconServer;

    private String description;

    private Throttle throttle;

    private Blast blast;

    private Restriction restriction;

    private String lang;

    private boolean poolModerated;

    private boolean invitationOnly;

    // the following seem not to exist anymore
    private int online;

    private String chatId;

    private int inChat;

    private boolean admin;

    private int photoCount;

    private boolean eighteenPlus;

    public Group() {

    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getMembers() {
        return members;
    }

    public void setMembers(int members) {
        this.members = members;
    }

    public void setMembers(String members) {
        try {
            if (members != null)
                setMembers(Integer.parseInt(members));
        } catch (NumberFormatException nfe) {
            setMembers(0);
            _log.trace(""Group.setMembers(String) encountered a number format exception.  members set to 0"");
        }
    }

    public int getPoolCount() {
        return poolCount;
    }

    public void setPoolCount(int poolCount) {
        this.poolCount = poolCount;
    }

    public void setPoolCount(String poolCount) {
        try {
            if (poolCount != null)
                setPoolCount(Integer.parseInt(poolCount));
        } catch (NumberFormatException nfe) {
            setPoolCount(0);
            _log.trace(""Group.setPoolCount(String) encountered a number format exception.  poolCount set to 0"");
        }
    }

    public int getTopicCount() {
        return topicCount;
    }

    public void setTopicCount(int topicCount) {
        this.topicCount = topicCount;
    }

    public void setTopicCount(String topicCount) {
        try {
            if (topicCount != null)
                setTopicCount(Integer.parseInt(topicCount));
        } catch (NumberFormatException nfe) {
            setPoolCount(0);
            _log.trace(""Group.setTopicCount(String) encountered a number format exception.  topicCount set to 0"");
        }
    }

    /**
     * @deprecated
     * @return the online-state
     */
    @Deprecated
    public int getOnline() {
        return online;
    }

    /**
     * @deprecated
     * @param online
     */
    @Deprecated
    public void setOnline(int online) {
        this.online = online;
    }

    /**
     * @deprecated
     * @param online
     */
    @Deprecated
    public void setOnline(String online) {
        try {
            if (online != null)
                setOnline(Integer.parseInt(online));
        } catch (NumberFormatException nfe) {
            setOnline(0);
            _log.trace(""Group.setOnline(String) encountered a number format exception.  online set to 0"");
        }
    }

    /**
     * @deprecated
     * @return chatId
     */
    @Deprecated
    public String getChatId() {
        return chatId;
    }

    /**
     * @deprecated
     * @param chatId
     */
    @Deprecated
    public void setChatId(String chatId) {
        this.chatId = chatId;
    }

    /**
     * @deprecated
     * @return the number of users in chat
     */
    @Deprecated
    public int getInChat() {
        return inChat;
    }

    /**
     * @deprecated
     * @param inChat
     */
    @Deprecated
    public void setInChat(int inChat) {
        this.inChat = inChat;
    }

    /**
     * @deprecated
     * @param inChat
     */
    @Deprecated
    public void setInChat(String inChat) {
        try {
            if (inChat != null)
                setInChat(Integer.parseInt(inChat));
        } catch (NumberFormatException nfe) {
            setInChat(0);
            _log.trace(""Group.setInChat(String) encountered a number format exception.  InChat set to 0"");
        }
    }

    public String getPrivacy() {
        return privacy;
    }

    public void setPrivacy(String privacy) {
        this.privacy = privacy;
    }

    public boolean isAdmin() {
        return admin;
    }

    public void setAdmin(boolean admin) {
        this.admin = admin;
    }

    public int getPhotoCount() {
        return photoCount;
    }

    /**
     * 
     * @param photoCount
     */
    public void setPhotoCount(int photoCount) {
        this.photoCount = photoCount;
    }

    /**
     * 
     * @param photoCount
     */
    public void setPhotoCount(String photoCount) {
        if (photoCount != null) {
            try {
                setPhotoCount(Integer.parseInt(photoCount));
            } catch (NumberFormatException nfe) {
                setPhotoCount(0);
                _log.trace(""Group.setPhotoCount(String) encountered a number format exception.  PhotoCount set to 0"");
            }
        }
    }

    /**
     * @deprecated
     * @return boolean
     */
    @Deprecated
    public boolean isEighteenPlus() {
        return eighteenPlus;
    }

    /**
     * @deprecated
     * @param eighteenPlus
     */
    @Deprecated
    public void setEighteenPlus(boolean eighteenPlus) {
        this.eighteenPlus = eighteenPlus;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getLang() {
        return lang;
    }

    public void setLang(String lang) {
        this.lang = lang;
    }

    public boolean isPoolModerated() {
        return poolModerated;
    }

    public void setPoolModerated(boolean poolModerated) {
        this.poolModerated = poolModerated;
    }

    @Override
    public int getIconFarm() {
        return iconFarm;
    }

    @Override
    public void setIconFarm(int iconFarm) {
        this.iconFarm = iconFarm;
    }

    @Override
    public void setIconFarm(String iconFarm) {
        if (iconFarm != null) {
            setIconFarm(Integer.parseInt(iconFarm));
        }
    }

    @Override
    public int getIconServer() {
        return iconServer;
    }

    @Override
    public void setIconServer(int iconServer) {
        this.iconServer = iconServer;
    }

    @Override
    public void setIconServer(String iconServer) {
        if (iconServer != null) {
            setIconServer(Integer.parseInt(iconServer));
        }
    }

    /**
     * Construct the BuddyIconUrl.
     * <p>
     * If none available, return the <a href=""http://www.flickr.com/images/buddyicon.jpg"">default</a>, or an URL assembled from farm, iconserver and nsid.
     * 
     * @see <a href=""http://flickr.com/services/api/misc.buddyicons.html"">Flickr Documentation</a>
     * @return The BuddyIconUrl
     * @deprecated use {@link #getSecureBuddyIconUrl() }
     */
    @Override
    @Deprecated
    public String getBuddyIconUrl() {
        return UrlUtilities.createBuddyIconUrl(iconFarm, iconServer, id);
    }

    /**
     * Construct the BuddyIconUrl using {@code https} scheme.
     * <p>
     * If none available, return the <a href=""https://www.flickr.com/images/buddyicon.jpg"">default</a>, or an URL assembled from farm, iconserver and nsid.
     * 
     * @see <a href=""http://flickr.com/services/api/misc.buddyicons.html"">Flickr Documentation</a>
     * @return The BuddyIconUrl
     */
    public String getSecureBuddyIconUrl() {
        return UrlUtilities.createSecureBuddyIconUrl(iconFarm, iconServer, id);
    }

    public Throttle getThrottle() {
        return throttle;
    }

    public void setThrottle(Throttle throttle) {
        this.throttle = throttle;
    }

    public Blast getBlast() {
        return blast;
    }

    public void setBlast(Blast blast) {
        this.blast = blast;
    }

    public Restriction getRestriction() {
        return restriction;
    }

    public void setRestriction(Restriction restriction) {
        this.restriction = restriction;
    }

    /**
     * @return the invitationOnly
     */
    public boolean isInvitationOnly() {
        return invitationOnly;
    }

    /**
     * @param invitationOnly
     *            the invitationOnly to set
     */
    public void setInvitationOnly(boolean invitationOnly) {
        this.invitationOnly = invitationOnly;
    }

}
","package com.flickr4java.flickr.groups; import com.flickr4java.flickr.util.BuddyIconable; import com.flickr4java.flickr.util.UrlUtilities; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class Group implements BuddyIconable { private static Logger _log = LoggerFactory.getLogger(Group.class); private String id; private String name; private int members; private int poolCount; private int topicCount; private String privacy; private int iconFarm; private int iconServer; private String description; private Throttle throttle; private Blast blast; private Restriction restriction; private String lang; private boolean poolModerated; private boolean invitationOnly; private int online; private String chatId; private int inChat; private boolean admin; private int photoCount; private boolean eighteenPlus; public Group() { } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getMembers() { return members; } public void setMembers(int members) { this.members = members; } public void setMembers(String members) { try { if (members != null)
                setMembers(Integer.parseInt(members)); } catch (NumberFormatException nfe) { setMembers(0); } } public int getPoolCount() { return poolCount; } public void setPoolCount(int poolCount) { this.poolCount = poolCount; } public void setPoolCount(String poolCount) { try { if (poolCount != null)
                setPoolCount(Integer.parseInt(poolCount)); } catch (NumberFormatException nfe) { setPoolCount(0); } } public int getTopicCount() { return topicCount; } public void setTopicCount(int topicCount) { this.topicCount = topicCount; } public void setTopicCount(String topicCount) { try { if (topicCount != null)
                setTopicCount(Integer.parseInt(topicCount)); } catch (NumberFormatException nfe) { setPoolCount(0); } } @Deprecated
    public int getOnline() { return online; } @Deprecated
    public void setOnline(int online) { this.online = online; } @Deprecated
    public void setOnline(String online) { try { if (online != null)
                setOnline(Integer.parseInt(online)); } catch (NumberFormatException nfe) { setOnline(0); } } @Deprecated
    public String getChatId() { return chatId; } @Deprecated
    public void setChatId(String chatId) { this.chatId = chatId; } @Deprecated
    public int getInChat() { return inChat; } @Deprecated
    public void setInChat(int inChat) { this.inChat = inChat; } @Deprecated
    public void setInChat(String inChat) { try { if (inChat != null)
                setInChat(Integer.parseInt(inChat)); } catch (NumberFormatException nfe) { setInChat(0); } } public String getPrivacy() { return privacy; } public void setPrivacy(String privacy) { this.privacy = privacy; } public boolean isAdmin() { return admin; } public void setAdmin(boolean admin) { this.admin = admin; } public int getPhotoCount() { return photoCount; } public void setPhotoCount(int photoCount) { this.photoCount = photoCount; } public void setPhotoCount(String photoCount) { if (photoCount != null) { try { setPhotoCount(Integer.parseInt(photoCount)); } catch (NumberFormatException nfe) { setPhotoCount(0); } } } @Deprecated
    public boolean isEighteenPlus() { return eighteenPlus; } @Deprecated
    public void setEighteenPlus(boolean eighteenPlus) { this.eighteenPlus = eighteenPlus; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public String getLang() { return lang; } public void setLang(String lang) { this.lang = lang; } public boolean isPoolModerated() { return poolModerated; } public void setPoolModerated(boolean poolModerated) { this.poolModerated = poolModerated; } @Override
    public int getIconFarm() { return iconFarm; } @Override
    public void setIconFarm(int iconFarm) { this.iconFarm = iconFarm; } @Override
    public void setIconFarm(String iconFarm) { if (iconFarm != null) { setIconFarm(Integer.parseInt(iconFarm)); } } @Override
    public int getIconServer() { return iconServer; } @Override
    public void setIconServer(int iconServer) { this.iconServer = iconServer; } @Override
    public void setIconServer(String iconServer) { if (iconServer != null) { setIconServer(Integer.parseInt(iconServer)); } } @Override
    @Deprecated
    public String getBuddyIconUrl() { return UrlUtilities.createBuddyIconUrl(iconFarm, iconServer, id); } public String getSecureBuddyIconUrl() { return UrlUtilities.createSecureBuddyIconUrl(iconFarm, iconServer, id); } public Throttle getThrottle() { return throttle; } public void setThrottle(Throttle throttle) { this.throttle = throttle; } public Blast getBlast() { return blast; } public void setBlast(Blast blast) { this.blast = blast; } public Restriction getRestriction() { return restriction; } public void setRestriction(Restriction restriction) { this.restriction = restriction; } public boolean isInvitationOnly() { return invitationOnly; } public void setInvitationOnly(boolean invitationOnly) { this.invitationOnly = invitationOnly; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.groups; import com.flickr4java.flickr.util.BuddyIconable; import com.flickr4java.flickr.util.UrlUtilities; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class Group implements BuddyIconable { private static Logger _log = LoggerFactory.getLogger(Group.class); private String id; private String name; private int members; private int poolCount; private int topicCount; private String privacy; private int iconFarm; private int iconServer; private String description; private Throttle throttle; private Blast blast; private Restriction restriction; private String lang; private boolean poolModerated; private boolean invitationOnly; private int online; private String chatId; private int inChat; private boolean admin; private int photoCount; private boolean eighteenPlus; public Group() { } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getMembers() { return members; } public void setMembers(int members) { this.members = members; } public void setMembers(String members) { try { if (members != null)
                setMembers(Integer.parseInt(members)); } catch (NumberFormatException nfe) { setMembers(0); <FILL_ME> } } public int getPoolCount() { return poolCount; } public void setPoolCount(int poolCount) { this.poolCount = poolCount; } public void setPoolCount(String poolCount) { try { if (poolCount != null)
                setPoolCount(Integer.parseInt(poolCount)); } catch (NumberFormatException nfe) { setPoolCount(0); <FILL_ME> <FILL_ME> } } public int getTopicCount() { return topicCount; } public void setTopicCount(int topicCount) { this.topicCount = topicCount; } public void setTopicCount(String topicCount) { try { if (topicCount != null)
                setTopicCount(Integer.parseInt(topicCount)); } catch (NumberFormatException nfe) { setPoolCount(0); } } @Deprecated
    public int getOnline() { return online; } @Deprecated
    public void setOnline(int online) { this.online = online; } @Deprecated
    public void setOnline(String online) { try { if (online != null)
                setOnline(Integer.parseInt(online)); } catch (NumberFormatException nfe) { setOnline(0); <FILL_ME> } } @Deprecated
    public String getChatId() { return chatId; } @Deprecated
    public void setChatId(String chatId) { this.chatId = chatId; } @Deprecated
    public int getInChat() { return inChat; } @Deprecated
    public void setInChat(int inChat) { this.inChat = inChat; } @Deprecated
    public void setInChat(String inChat) { try { if (inChat != null)
                setInChat(Integer.parseInt(inChat)); } catch (NumberFormatException nfe) { setInChat(0); <FILL_ME> } } public String getPrivacy() { return privacy; } public void setPrivacy(String privacy) { this.privacy = privacy; } public boolean isAdmin() { return admin; } public void setAdmin(boolean admin) { this.admin = admin; } public int getPhotoCount() { return photoCount; } public void setPhotoCount(int photoCount) { this.photoCount = photoCount; } public void setPhotoCount(String photoCount) { if (photoCount != null) { try { setPhotoCount(Integer.parseInt(photoCount)); } catch (NumberFormatException nfe) { setPhotoCount(0); <FILL_ME> } } } @Deprecated
    public boolean isEighteenPlus() { return eighteenPlus; } @Deprecated
    public void setEighteenPlus(boolean eighteenPlus) { this.eighteenPlus = eighteenPlus; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public String getLang() { return lang; } public void setLang(String lang) { this.lang = lang; } public boolean isPoolModerated() { return poolModerated; } public void setPoolModerated(boolean poolModerated) { this.poolModerated = poolModerated; } @Override
    public int getIconFarm() { return iconFarm; } @Override
    public void setIconFarm(int iconFarm) { this.iconFarm = iconFarm; } @Override
    public void setIconFarm(String iconFarm) { if (iconFarm != null) { setIconFarm(Integer.parseInt(iconFarm)); } } @Override
    public int getIconServer() { return iconServer; } @Override
    public void setIconServer(int iconServer) { this.iconServer = iconServer; } @Override
    public void setIconServer(String iconServer) { if (iconServer != null) { setIconServer(Integer.parseInt(iconServer)); } } @Override
    @Deprecated
    public String getBuddyIconUrl() { return UrlUtilities.createBuddyIconUrl(iconFarm, iconServer, id); } public String getSecureBuddyIconUrl() { return UrlUtilities.createSecureBuddyIconUrl(iconFarm, iconServer, id); } public Throttle getThrottle() { return throttle; } public void setThrottle(Throttle throttle) { this.throttle = throttle; } public Blast getBlast() { return blast; } public void setBlast(Blast blast) { this.blast = blast; } public Restriction getRestriction() { return restriction; } public void setRestriction(Restriction restriction) { this.restriction = restriction; } public boolean isInvitationOnly() { return invitationOnly; } public void setInvitationOnly(boolean invitationOnly) { this.invitationOnly = invitationOnly; } } "," package com.flickr4java.flickr.groups;  import com.flickr4java.flickr.util.BuddyIconable; import com.flickr4java.flickr.util.UrlUtilities; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  /**
 * Class representing a Flickr Group.
 * 
 * @author Anthony Eden
 */ public class Group implements BuddyIconable {  private static Logger _log = LoggerFactory.getLogger(Group.class);  private String id;  private String name;  private int members;  private int poolCount;  private int topicCount;  private String privacy;  private int iconFarm;  private int iconServer;  private String description;  private Throttle throttle;  private Blast blast;  private Restriction restriction;  private String lang;  private boolean poolModerated;  private boolean invitationOnly;  // the following seem not to exist anymore private int online;  private String chatId;  private int inChat;  private boolean admin;  private int photoCount;  private boolean eighteenPlus;  public Group() {  }  public String getId() { return id; }  public void setId(String id) { this.id = id; }  public String getName() { return name; }  public void setName(String name) { this.name = name; }  public int getMembers() { return members; }  public void setMembers(int members) { this.members = members; }  public void setMembers(String members) { try { if (members != null)
                setMembers(Integer.parseInt(members)); } catch (NumberFormatException nfe) { setMembers(0); <FILL_ME> } }  public int getPoolCount() { return poolCount; }  public void setPoolCount(int poolCount) { this.poolCount = poolCount; }  public void setPoolCount(String poolCount) { try { if (poolCount != null)
                setPoolCount(Integer.parseInt(poolCount)); } catch (NumberFormatException nfe) { setPoolCount(0); <FILL_ME> <FILL_ME> } }  public int getTopicCount() { return topicCount; }  public void setTopicCount(int topicCount) { this.topicCount = topicCount; }  public void setTopicCount(String topicCount) { try { if (topicCount != null)
                setTopicCount(Integer.parseInt(topicCount)); } catch (NumberFormatException nfe) { setPoolCount(0); } }  /**
     * @deprecated
     * @return the online-state
     */ @Deprecated
    public int getOnline() { return online; }  /**
     * @deprecated
     * @param online
     */ @Deprecated
    public void setOnline(int online) { this.online = online; }  /**
     * @deprecated
     * @param online
     */ @Deprecated
    public void setOnline(String online) { try { if (online != null)
                setOnline(Integer.parseInt(online)); } catch (NumberFormatException nfe) { setOnline(0); <FILL_ME> } }  /**
     * @deprecated
     * @return chatId
     */ @Deprecated
    public String getChatId() { return chatId; }  /**
     * @deprecated
     * @param chatId
     */ @Deprecated
    public void setChatId(String chatId) { this.chatId = chatId; }  /**
     * @deprecated
     * @return the number of users in chat
     */ @Deprecated
    public int getInChat() { return inChat; }  /**
     * @deprecated
     * @param inChat
     */ @Deprecated
    public void setInChat(int inChat) { this.inChat = inChat; }  /**
     * @deprecated
     * @param inChat
     */ @Deprecated
    public void setInChat(String inChat) { try { if (inChat != null)
                setInChat(Integer.parseInt(inChat)); } catch (NumberFormatException nfe) { setInChat(0); <FILL_ME> } }  public String getPrivacy() { return privacy; }  public void setPrivacy(String privacy) { this.privacy = privacy; }  public boolean isAdmin() { return admin; }  public void setAdmin(boolean admin) { this.admin = admin; }  public int getPhotoCount() { return photoCount; }  /**
     * 
     * @param photoCount
     */ public void setPhotoCount(int photoCount) { this.photoCount = photoCount; }  /**
     * 
     * @param photoCount
     */ public void setPhotoCount(String photoCount) { if (photoCount != null) { try { setPhotoCount(Integer.parseInt(photoCount)); } catch (NumberFormatException nfe) { setPhotoCount(0); <FILL_ME> } } }  /**
     * @deprecated
     * @return boolean
     */ @Deprecated
    public boolean isEighteenPlus() { return eighteenPlus; }  /**
     * @deprecated
     * @param eighteenPlus
     */ @Deprecated
    public void setEighteenPlus(boolean eighteenPlus) { this.eighteenPlus = eighteenPlus; }  public String getDescription() { return description; }  public void setDescription(String description) { this.description = description; }  public String getLang() { return lang; }  public void setLang(String lang) { this.lang = lang; }  public boolean isPoolModerated() { return poolModerated; }  public void setPoolModerated(boolean poolModerated) { this.poolModerated = poolModerated; }  @Override
    public int getIconFarm() { return iconFarm; }  @Override
    public void setIconFarm(int iconFarm) { this.iconFarm = iconFarm; }  @Override
    public void setIconFarm(String iconFarm) { if (iconFarm != null) { setIconFarm(Integer.parseInt(iconFarm)); } }  @Override
    public int getIconServer() { return iconServer; }  @Override
    public void setIconServer(int iconServer) { this.iconServer = iconServer; }  @Override
    public void setIconServer(String iconServer) { if (iconServer != null) { setIconServer(Integer.parseInt(iconServer)); } }  /**
     * Construct the BuddyIconUrl.
     * <p>
     * If none available, return the <a href=""http://www.flickr.com/images/buddyicon.jpg"">default</a>, or an URL assembled from farm, iconserver and nsid.
     * 
     * @see <a href=""http://flickr.com/services/api/misc.buddyicons.html"">Flickr Documentation</a>
     * @return The BuddyIconUrl
     * @deprecated use {@link #getSecureBuddyIconUrl() }
     */ @Override
    @Deprecated
    public String getBuddyIconUrl() { return UrlUtilities.createBuddyIconUrl(iconFarm, iconServer, id); }  /**
     * Construct the BuddyIconUrl using {@code https} scheme.
     * <p>
     * If none available, return the <a href=""https://www.flickr.com/images/buddyicon.jpg"">default</a>, or an URL assembled from farm, iconserver and nsid.
     * 
     * @see <a href=""http://flickr.com/services/api/misc.buddyicons.html"">Flickr Documentation</a>
     * @return The BuddyIconUrl
     */ public String getSecureBuddyIconUrl() { return UrlUtilities.createSecureBuddyIconUrl(iconFarm, iconServer, id); }  public Throttle getThrottle() { return throttle; }  public void setThrottle(Throttle throttle) { this.throttle = throttle; }  public Blast getBlast() { return blast; }  public void setBlast(Blast blast) { this.blast = blast; }  public Restriction getRestriction() { return restriction; }  public void setRestriction(Restriction restriction) { this.restriction = restriction; }  /**
     * @return the invitationOnly
     */ public boolean isInvitationOnly() { return invitationOnly; }  /**
     * @param invitationOnly
     *            the invitationOnly to set
     */ public void setInvitationOnly(boolean invitationOnly) { this.invitationOnly = invitationOnly; }  }  "
src/main/java/com/flickr4java/flickr/groups/GroupList.java,"package com.flickr4java.flickr.groups;

import com.flickr4java.flickr.SearchResultList;

public class GroupList<E> extends SearchResultList<Group> {
    private static final long serialVersionUID = 3344960036515265775L;

}
",package com.flickr4java.flickr.groups; import com.flickr4java.flickr.SearchResultList; public class GroupList<E> extends SearchResultList<Group> { private static final long serialVersionUID = 3344960036515265775L; },0 0 0 0 0 0,package com.flickr4java.flickr.groups; import com.flickr4java.flickr.SearchResultList; public class GroupList<E> extends SearchResultList<Group> { private static final long serialVersionUID = 3344960036515265775L; } ,package com.flickr4java.flickr.groups;  import com.flickr4java.flickr.SearchResultList;  public class GroupList<E> extends SearchResultList<Group> { private static final long serialVersionUID = 3344960036515265775L;  }  
src/main/java/com/flickr4java/flickr/groups/GroupsInterface.java,"
package com.flickr4java.flickr.groups;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.util.XMLUtilities;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Interface for working with Flickr Groups.
 * 
 * @author Anthony Eden
 * @version $Id: GroupsInterface.java,v 1.19 2009/07/11 20:30:27 x-mago Exp $
 */
public class GroupsInterface {

    private static Logger _log = LoggerFactory.getLogger(GroupsInterface.class);

    public static final String METHOD_BROWSE = ""flickr.groups.browse"";

    public static final String METHOD_GET_ACTIVE_LIST = ""flickr.groups.getActiveList"";

    public static final String METHOD_GET_INFO = ""flickr.groups.getInfo"";

    public static final String METHOD_SEARCH = ""flickr.groups.search"";

    public static final String METHOD_JOIN = ""flickr.groups.join"";

    public static final String METHOD_JOIN_REQUEST = ""flickr.groups.joinRequest"";

    public static final String METHOD_LEAVE = ""flickr.groups.leave"";

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transportAPI;

    public GroupsInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transportAPI;
    }

    /**
     * Browse groups for the given category ID. If a null value is passed for the category then the root category is used.
     * 
     * @param catId
     *            The optional category id. Null value will be ignored.
     * @return The Collection of Photo objects
     * @throws FlickrException if there was a problem connecting to Flickr
     * @deprecated Flickr returns just empty results
     */
    @Deprecated
    public Category browse(String catId) throws FlickrException {
        List<Subcategory> subcategories = new ArrayList<Subcategory>();
        List<Group> groups = new ArrayList<Group>();

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_BROWSE);

        if (catId != null) {
            parameters.put(""cat_id"", catId);
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element categoryElement = response.getPayload();

        Category category = new Category();
        category.setName(categoryElement.getAttribute(""name""));
        category.setPath(categoryElement.getAttribute(""path""));
        category.setPathIds(categoryElement.getAttribute(""pathids""));

        NodeList subcatNodes = categoryElement.getElementsByTagName(""subcat"");
        for (int i = 0; i < subcatNodes.getLength(); i++) {
            Element node = (Element) subcatNodes.item(i);
            Subcategory subcategory = new Subcategory();
            subcategory.setId(Integer.parseInt(node.getAttribute(""id"")));
            subcategory.setName(node.getAttribute(""name""));
            subcategory.setCount(Integer.parseInt(node.getAttribute(""count"")));

            subcategories.add(subcategory);
        }

        NodeList groupNodes = categoryElement.getElementsByTagName(""group"");
        for (int i = 0; i < groupNodes.getLength(); i++) {
            Element node = (Element) groupNodes.item(i);
            Group group = new Group();
            group.setId(node.getAttribute(""nsid""));
            group.setName(node.getAttribute(""name""));
            group.setMembers(node.getAttribute(""members""));

            groups.add(group);
        }

        category.setGroups(groups);
        category.setSubcategories(subcategories);

        return category;
    }

    /**
     * Get the info for a specified group.
     * 
     * This method does not require authentication.
     * 
     * @param groupId
     *            The group id
     * @return The Group object
     */
    public Group getInfo(String groupId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_INFO);
        parameters.put(""group_id"", groupId);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element groupElement = response.getPayload();
        Group group = new Group();
        group.setId(groupElement.getAttribute(""id""));
        group.setIconFarm(groupElement.getAttribute(""iconfarm""));
        group.setIconServer(groupElement.getAttribute(""iconserver""));
        group.setLang(groupElement.getAttribute(""lang""));
        group.setPoolModerated(groupElement.getAttribute(""ispoolmoderated"").equals(""0"") ? false : true);

        group.setName(XMLUtilities.getChildValue(groupElement, ""name""));
        group.setDescription(XMLUtilities.getChildValue(groupElement, ""description""));
        group.setMembers(XMLUtilities.getChildValue(groupElement, ""members""));
        group.setPrivacy(XMLUtilities.getChildValue(groupElement, ""privacy""));
        group.setPoolCount(XMLUtilities.getChildValue(groupElement, ""pool_count""));
        group.setTopicCount(XMLUtilities.getChildValue(groupElement, ""topic_count""));

        NodeList throttleNodes = groupElement.getElementsByTagName(""throttle"");
        int n = throttleNodes.getLength();
        if (n == 1) {
            Element throttleElement = (Element) throttleNodes.item(0);
            Throttle throttle = new Throttle();
            group.setThrottle(throttle);
            throttle.setMode(throttleElement.getAttribute(""mode""));
            String countStr = throttleElement.getAttribute(""count"");
            String remainingStr = throttleElement.getAttribute(""remaining"");
            if (countStr != null && countStr.length() > 0) {
                throttle.setCount(Integer.parseInt(countStr));
            }
            if (remainingStr != null && remainingStr.length() > 0) {
                throttle.setRemaining(Integer.parseInt(remainingStr));
            }
        } else if (n > 1) {
            _log.warn(""WARNING: more than one throttle element in group"");
        }

        NodeList restrictionNodes = groupElement.getElementsByTagName(""restrictions"");
        n = restrictionNodes.getLength();
        if (n == 1) {
            Element restrictionElement = (Element) restrictionNodes.item(0);
            Restriction restriction = new Restriction();
            group.setRestriction(restriction);
            restriction.setIsPhotosOk(""1"".equals(restrictionElement.getAttribute(""photos_ok"")));
            restriction.setIsVideosOk(""1"".equals(restrictionElement.getAttribute(""videos_ok"")));
            restriction.setIsImagesOk(""1"".equals(restrictionElement.getAttribute(""images_ok"")));
            restriction.setIsScreensOk(""1"".equals(restrictionElement.getAttribute(""screens_ok"")));
            restriction.setIsArtOk(""1"".equals(restrictionElement.getAttribute(""art_ok"")));
            restriction.setIsSafeOk(""1"".equals(restrictionElement.getAttribute(""safe_ok"")));
            restriction.setIsModerateOk(""1"".equals(restrictionElement.getAttribute(""moderate_ok"")));
            restriction.setIsRestrictedOk(""1"".equals(restrictionElement.getAttribute(""restricted_ok"")));
            restriction.setIsHasGeo(""1"".equals(restrictionElement.getAttribute(""has_geo"")));
        } else if (n > 1) {
            _log.warn(""WARNING: more than one throttle element in group"");
        }
        NodeList blastNodes = groupElement.getElementsByTagName(""blast"");
        n = blastNodes.getLength();
        if (n == 1) {
            Element blastElement = (Element) blastNodes.item(0);
            Blast blast = new Blast();
            group.setBlast(blast);
            blast.setUserId(blastElement.getAttribute(""user_id""));
            blast.setDateBlastAdded(blastElement.getAttribute(""date_blast_added""));
            blast.setBlast(XMLUtilities.getChildValue(groupElement, ""blast""));
        } else if (n > 1) {
            _log.warn(""WARNING: more than one throttle element in group"");
        }

        return group;
    }

    /**
     * Search for groups. 18+ groups will only be returned for authenticated calls where the authenticated user is over 18. This method does not require
     * authentication.
     * 
     * @param text
     *            The text to search for.
     * @param perPage
     *            Number of groups to return per page. If this argument is 0, it defaults to 100. The maximum allowed value is 500.
     * @param page
     *            The page of results to return. If this argument is 0, it defaults to 1.
     * @return A GroupList Object. Only the fields <em>id</em>, <em>name</em> and <em>eighteenplus</em> in the Groups will be set.
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Collection<Group> search(String text, int perPage, int page) throws FlickrException {
        GroupList<Group> groupList = new GroupList<Group>();
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_SEARCH);

        parameters.put(""text"", text);

        if (perPage > 0) {
            parameters.put(""per_page"", String.valueOf(perPage));
        }
        if (page > 0) {
            parameters.put(""page"", String.valueOf(page));
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element groupsElement = response.getPayload();
        NodeList groupNodes = groupsElement.getElementsByTagName(""group"");
        groupList.setPage(XMLUtilities.getIntAttribute(groupsElement, ""page""));
        groupList.setPages(XMLUtilities.getIntAttribute(groupsElement, ""pages""));
        groupList.setPerPage(XMLUtilities.getIntAttribute(groupsElement, ""perpage""));
        groupList.setTotal(XMLUtilities.getIntAttribute(groupsElement, ""total""));
        for (int i = 0; i < groupNodes.getLength(); i++) {
            Element groupElement = (Element) groupNodes.item(i);
            Group group = new Group();
            group.setId(groupElement.getAttribute(""nsid""));
            group.setName(groupElement.getAttribute(""name""));
            groupList.add(group);
        }
        return groupList;
    }

    /**
     * Join a group as a public member.
     * 
     * Note: if a group has rules - the client must display the rules to the user and the user must accept them prior to joining the group. The acceptRules
     * parameter indicates that the user has accepted those rules.
     * 
     * @param groupId
     *            - the id of the group to join
     * @param acceptRules
     *            - if a group has rules, true indicates the user has accepted the rules
     * 
     * @see <a href=""http://www.flickr.com/services/api/flickr.groups.join.html"">flickr.groups.join</a>
     */
    public void join(String groupId, Boolean acceptRules) throws FlickrException {

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_JOIN);
        parameters.put(""group_id"", groupId);
        if (acceptRules != null) {
            parameters.put(""accept_rules"", acceptRules);
        }

        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Request to join a group.
     * 
     * Note: if a group has rules, the client must display the rules to the user and the user must accept them (which is indicated by passing a true value to
     * acceptRules) prior to making the join request.
     * 
     * @param groupId
     *            - groupId parameter
     * @param message
     *            - (required) message to group administrator
     * @param acceptRules
     *            - (required) parameter indicating user has accepted groups rules
     */
    public void joinRequest(String groupId, String message, boolean acceptRules) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_JOIN_REQUEST);
        parameters.put(""group_id"", groupId);
        parameters.put(""message"", message);
        parameters.put(""accept_rules"", acceptRules);

        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Leave a group.
     * 
     * @see <a href=""http://www.flickr.com/services/api/flickr.groups.leave.html"">lickr.groups.leave</a> for a description of the various behaviors possible
     *      when a user leaves a group.
     * 
     * @param groupId
     *            - the id of the group to leave
     * @param deletePhotos
     *            - delete photos by this user from group
     */
    public void leave(String groupId, Boolean deletePhotos) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_LEAVE);
        parameters.put(""group_id"", groupId);
        parameters.put(""delete_photos"", deletePhotos);

        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }
}
","package com.flickr4java.flickr.groups; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.XMLUtilities; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.List; import java.util.Map; public class GroupsInterface { private static Logger _log = LoggerFactory.getLogger(GroupsInterface.class); public static final String METHOD_BROWSE = ""flickr.groups.browse""; public static final String METHOD_GET_ACTIVE_LIST = ""flickr.groups.getActiveList""; public static final String METHOD_GET_INFO = ""flickr.groups.getInfo""; public static final String METHOD_SEARCH = ""flickr.groups.search""; public static final String METHOD_JOIN = ""flickr.groups.join""; public static final String METHOD_JOIN_REQUEST = ""flickr.groups.joinRequest""; public static final String METHOD_LEAVE = ""flickr.groups.leave""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public GroupsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } @Deprecated
    public Category browse(String catId) throws FlickrException { List<Subcategory> subcategories = new ArrayList<Subcategory>(); List<Group> groups = new ArrayList<Group>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_BROWSE); if (catId != null) { parameters.put(""cat_id"", catId); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element categoryElement = response.getPayload(); Category category = new Category(); category.setName(categoryElement.getAttribute(""name"")); category.setPath(categoryElement.getAttribute(""path"")); category.setPathIds(categoryElement.getAttribute(""pathids"")); NodeList subcatNodes = categoryElement.getElementsByTagName(""subcat""); for (int i = 0; i < subcatNodes.getLength(); i++) { Element node = (Element) subcatNodes.item(i); Subcategory subcategory = new Subcategory(); subcategory.setId(Integer.parseInt(node.getAttribute(""id""))); subcategory.setName(node.getAttribute(""name"")); subcategory.setCount(Integer.parseInt(node.getAttribute(""count""))); subcategories.add(subcategory); } NodeList groupNodes = categoryElement.getElementsByTagName(""group""); for (int i = 0; i < groupNodes.getLength(); i++) { Element node = (Element) groupNodes.item(i); Group group = new Group(); group.setId(node.getAttribute(""nsid"")); group.setName(node.getAttribute(""name"")); group.setMembers(node.getAttribute(""members"")); groups.add(group); } category.setGroups(groups); category.setSubcategories(subcategories); return category; } public Group getInfo(String groupId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO); parameters.put(""group_id"", groupId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element groupElement = response.getPayload(); Group group = new Group(); group.setId(groupElement.getAttribute(""id"")); group.setIconFarm(groupElement.getAttribute(""iconfarm"")); group.setIconServer(groupElement.getAttribute(""iconserver"")); group.setLang(groupElement.getAttribute(""lang"")); group.setPoolModerated(groupElement.getAttribute(""ispoolmoderated"").equals(""0"") ? false : true); group.setName(XMLUtilities.getChildValue(groupElement, ""name"")); group.setDescription(XMLUtilities.getChildValue(groupElement, ""description"")); group.setMembers(XMLUtilities.getChildValue(groupElement, ""members"")); group.setPrivacy(XMLUtilities.getChildValue(groupElement, ""privacy"")); group.setPoolCount(XMLUtilities.getChildValue(groupElement, ""pool_count"")); group.setTopicCount(XMLUtilities.getChildValue(groupElement, ""topic_count"")); NodeList throttleNodes = groupElement.getElementsByTagName(""throttle""); int n = throttleNodes.getLength(); if (n == 1) { Element throttleElement = (Element) throttleNodes.item(0); Throttle throttle = new Throttle(); group.setThrottle(throttle); throttle.setMode(throttleElement.getAttribute(""mode"")); String countStr = throttleElement.getAttribute(""count""); String remainingStr = throttleElement.getAttribute(""remaining""); if (countStr != null && countStr.length() > 0) { throttle.setCount(Integer.parseInt(countStr)); } if (remainingStr != null && remainingStr.length() > 0) { throttle.setRemaining(Integer.parseInt(remainingStr)); } } else if (n > 1) { } NodeList restrictionNodes = groupElement.getElementsByTagName(""restrictions""); n = restrictionNodes.getLength(); if (n == 1) { Element restrictionElement = (Element) restrictionNodes.item(0); Restriction restriction = new Restriction(); group.setRestriction(restriction); restriction.setIsPhotosOk(""1"".equals(restrictionElement.getAttribute(""photos_ok""))); restriction.setIsVideosOk(""1"".equals(restrictionElement.getAttribute(""videos_ok""))); restriction.setIsImagesOk(""1"".equals(restrictionElement.getAttribute(""images_ok""))); restriction.setIsScreensOk(""1"".equals(restrictionElement.getAttribute(""screens_ok""))); restriction.setIsArtOk(""1"".equals(restrictionElement.getAttribute(""art_ok""))); restriction.setIsSafeOk(""1"".equals(restrictionElement.getAttribute(""safe_ok""))); restriction.setIsModerateOk(""1"".equals(restrictionElement.getAttribute(""moderate_ok""))); restriction.setIsRestrictedOk(""1"".equals(restrictionElement.getAttribute(""restricted_ok""))); restriction.setIsHasGeo(""1"".equals(restrictionElement.getAttribute(""has_geo""))); } else if (n > 1) { } NodeList blastNodes = groupElement.getElementsByTagName(""blast""); n = blastNodes.getLength(); if (n == 1) { Element blastElement = (Element) blastNodes.item(0); Blast blast = new Blast(); group.setBlast(blast); blast.setUserId(blastElement.getAttribute(""user_id"")); blast.setDateBlastAdded(blastElement.getAttribute(""date_blast_added"")); blast.setBlast(XMLUtilities.getChildValue(groupElement, ""blast"")); } else if (n > 1) { } return group; } public Collection<Group> search(String text, int perPage, int page) throws FlickrException { GroupList<Group> groupList = new GroupList<Group>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SEARCH); parameters.put(""text"", text); if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element groupsElement = response.getPayload(); NodeList groupNodes = groupsElement.getElementsByTagName(""group""); groupList.setPage(XMLUtilities.getIntAttribute(groupsElement, ""page"")); groupList.setPages(XMLUtilities.getIntAttribute(groupsElement, ""pages"")); groupList.setPerPage(XMLUtilities.getIntAttribute(groupsElement, ""perpage"")); groupList.setTotal(XMLUtilities.getIntAttribute(groupsElement, ""total"")); for (int i = 0; i < groupNodes.getLength(); i++) { Element groupElement = (Element) groupNodes.item(i); Group group = new Group(); group.setId(groupElement.getAttribute(""nsid"")); group.setName(groupElement.getAttribute(""name"")); groupList.add(group); } return groupList; } public void join(String groupId, Boolean acceptRules) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_JOIN); parameters.put(""group_id"", groupId); if (acceptRules != null) { parameters.put(""accept_rules"", acceptRules); } Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void joinRequest(String groupId, String message, boolean acceptRules) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_JOIN_REQUEST); parameters.put(""group_id"", groupId); parameters.put(""message"", message); parameters.put(""accept_rules"", acceptRules); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void leave(String groupId, Boolean deletePhotos) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_LEAVE); parameters.put(""group_id"", groupId); parameters.put(""delete_photos"", deletePhotos); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.groups; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.XMLUtilities; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.List; import java.util.Map; public class GroupsInterface { private static Logger _log = LoggerFactory.getLogger(GroupsInterface.class); public static final String METHOD_BROWSE = ""flickr.groups.browse""; public static final String METHOD_GET_ACTIVE_LIST = ""flickr.groups.getActiveList""; public static final String METHOD_GET_INFO = ""flickr.groups.getInfo""; public static final String METHOD_SEARCH = ""flickr.groups.search""; public static final String METHOD_JOIN = ""flickr.groups.join""; public static final String METHOD_JOIN_REQUEST = ""flickr.groups.joinRequest""; public static final String METHOD_LEAVE = ""flickr.groups.leave""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public GroupsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } @Deprecated
    public Category browse(String catId) throws FlickrException { List<Subcategory> subcategories = new ArrayList<Subcategory>(); List<Group> groups = new ArrayList<Group>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_BROWSE); if (catId != null) { parameters.put(""cat_id"", catId); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element categoryElement = response.getPayload(); Category category = new Category(); category.setName(categoryElement.getAttribute(""name"")); category.setPath(categoryElement.getAttribute(""path"")); category.setPathIds(categoryElement.getAttribute(""pathids"")); NodeList subcatNodes = categoryElement.getElementsByTagName(""subcat""); for (int i = 0; i < subcatNodes.getLength(); i++) { Element node = (Element) subcatNodes.item(i); Subcategory subcategory = new Subcategory(); subcategory.setId(Integer.parseInt(node.getAttribute(""id""))); subcategory.setName(node.getAttribute(""name"")); subcategory.setCount(Integer.parseInt(node.getAttribute(""count""))); subcategories.add(subcategory); } NodeList groupNodes = categoryElement.getElementsByTagName(""group""); for (int i = 0; i < groupNodes.getLength(); i++) { Element node = (Element) groupNodes.item(i); Group group = new Group(); group.setId(node.getAttribute(""nsid"")); group.setName(node.getAttribute(""name"")); group.setMembers(node.getAttribute(""members"")); groups.add(group); } category.setGroups(groups); category.setSubcategories(subcategories); return category; } public Group getInfo(String groupId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO); parameters.put(""group_id"", groupId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element groupElement = response.getPayload(); Group group = new Group(); group.setId(groupElement.getAttribute(""id"")); group.setIconFarm(groupElement.getAttribute(""iconfarm"")); group.setIconServer(groupElement.getAttribute(""iconserver"")); group.setLang(groupElement.getAttribute(""lang"")); group.setPoolModerated(groupElement.getAttribute(""ispoolmoderated"").equals(""0"") ? false : true); group.setName(XMLUtilities.getChildValue(groupElement, ""name"")); group.setDescription(XMLUtilities.getChildValue(groupElement, ""description"")); group.setMembers(XMLUtilities.getChildValue(groupElement, ""members"")); group.setPrivacy(XMLUtilities.getChildValue(groupElement, ""privacy"")); group.setPoolCount(XMLUtilities.getChildValue(groupElement, ""pool_count"")); group.setTopicCount(XMLUtilities.getChildValue(groupElement, ""topic_count"")); NodeList throttleNodes = groupElement.getElementsByTagName(""throttle""); int n = throttleNodes.getLength(); if (n == 1) { Element throttleElement = (Element) throttleNodes.item(0); Throttle throttle = new Throttle(); group.setThrottle(throttle); throttle.setMode(throttleElement.getAttribute(""mode"")); String countStr = throttleElement.getAttribute(""count""); String remainingStr = throttleElement.getAttribute(""remaining""); if (countStr != null && countStr.length() > 0) { throttle.setCount(Integer.parseInt(countStr)); } if (remainingStr != null && remainingStr.length() > 0) { throttle.setRemaining(Integer.parseInt(remainingStr)); } } else if (n > 1) { <FILL_ME> <FILL_ME> <FILL_ME> } NodeList restrictionNodes = groupElement.getElementsByTagName(""restrictions""); n = restrictionNodes.getLength(); if (n == 1) { Element restrictionElement = (Element) restrictionNodes.item(0); Restriction restriction = new Restriction(); group.setRestriction(restriction); restriction.setIsPhotosOk(""1"".equals(restrictionElement.getAttribute(""photos_ok""))); restriction.setIsVideosOk(""1"".equals(restrictionElement.getAttribute(""videos_ok""))); restriction.setIsImagesOk(""1"".equals(restrictionElement.getAttribute(""images_ok""))); restriction.setIsScreensOk(""1"".equals(restrictionElement.getAttribute(""screens_ok""))); restriction.setIsArtOk(""1"".equals(restrictionElement.getAttribute(""art_ok""))); restriction.setIsSafeOk(""1"".equals(restrictionElement.getAttribute(""safe_ok""))); restriction.setIsModerateOk(""1"".equals(restrictionElement.getAttribute(""moderate_ok""))); restriction.setIsRestrictedOk(""1"".equals(restrictionElement.getAttribute(""restricted_ok""))); restriction.setIsHasGeo(""1"".equals(restrictionElement.getAttribute(""has_geo""))); } else if (n > 1) { } NodeList blastNodes = groupElement.getElementsByTagName(""blast""); n = blastNodes.getLength(); if (n == 1) { Element blastElement = (Element) blastNodes.item(0); Blast blast = new Blast(); group.setBlast(blast); blast.setUserId(blastElement.getAttribute(""user_id"")); blast.setDateBlastAdded(blastElement.getAttribute(""date_blast_added"")); blast.setBlast(XMLUtilities.getChildValue(groupElement, ""blast"")); } else if (n > 1) { } return group; } public Collection<Group> search(String text, int perPage, int page) throws FlickrException { GroupList<Group> groupList = new GroupList<Group>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SEARCH); parameters.put(""text"", text); if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element groupsElement = response.getPayload(); NodeList groupNodes = groupsElement.getElementsByTagName(""group""); groupList.setPage(XMLUtilities.getIntAttribute(groupsElement, ""page"")); groupList.setPages(XMLUtilities.getIntAttribute(groupsElement, ""pages"")); groupList.setPerPage(XMLUtilities.getIntAttribute(groupsElement, ""perpage"")); groupList.setTotal(XMLUtilities.getIntAttribute(groupsElement, ""total"")); for (int i = 0; i < groupNodes.getLength(); i++) { Element groupElement = (Element) groupNodes.item(i); Group group = new Group(); group.setId(groupElement.getAttribute(""nsid"")); group.setName(groupElement.getAttribute(""name"")); groupList.add(group); } return groupList; } public void join(String groupId, Boolean acceptRules) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_JOIN); parameters.put(""group_id"", groupId); if (acceptRules != null) { parameters.put(""accept_rules"", acceptRules); } Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void joinRequest(String groupId, String message, boolean acceptRules) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_JOIN_REQUEST); parameters.put(""group_id"", groupId); parameters.put(""message"", message); parameters.put(""accept_rules"", acceptRules); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void leave(String groupId, Boolean deletePhotos) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_LEAVE); parameters.put(""group_id"", groupId); parameters.put(""delete_photos"", deletePhotos); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } } "," package com.flickr4java.flickr.groups;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.XMLUtilities; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.List; import java.util.Map;  /**
 * Interface for working with Flickr Groups.
 * 
 * @author Anthony Eden
 * @version $Id: GroupsInterface.java,v 1.19 2009/07/11 20:30:27 x-mago Exp $
 */ public class GroupsInterface {  private static Logger _log = LoggerFactory.getLogger(GroupsInterface.class);  public static final String METHOD_BROWSE = ""flickr.groups.browse"";  public static final String METHOD_GET_ACTIVE_LIST = ""flickr.groups.getActiveList"";  public static final String METHOD_GET_INFO = ""flickr.groups.getInfo"";  public static final String METHOD_SEARCH = ""flickr.groups.search"";  public static final String METHOD_JOIN = ""flickr.groups.join"";  public static final String METHOD_JOIN_REQUEST = ""flickr.groups.joinRequest"";  public static final String METHOD_LEAVE = ""flickr.groups.leave"";  private final String apiKey;  private final String sharedSecret;  private final Transport transportAPI;  public GroupsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; }  /**
     * Browse groups for the given category ID. If a null value is passed for the category then the root category is used.
     * 
     * @param catId
     *            The optional category id. Null value will be ignored.
     * @return The Collection of Photo objects
     * @throws FlickrException if there was a problem connecting to Flickr
     * @deprecated Flickr returns just empty results
     */ @Deprecated
    public Category browse(String catId) throws FlickrException { List<Subcategory> subcategories = new ArrayList<Subcategory>(); List<Group> groups = new ArrayList<Group>();  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_BROWSE);  if (catId != null) { parameters.put(""cat_id"", catId); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element categoryElement = response.getPayload();  Category category = new Category(); category.setName(categoryElement.getAttribute(""name"")); category.setPath(categoryElement.getAttribute(""path"")); category.setPathIds(categoryElement.getAttribute(""pathids""));  NodeList subcatNodes = categoryElement.getElementsByTagName(""subcat""); for (int i = 0; i < subcatNodes.getLength(); i++) { Element node = (Element) subcatNodes.item(i); Subcategory subcategory = new Subcategory(); subcategory.setId(Integer.parseInt(node.getAttribute(""id""))); subcategory.setName(node.getAttribute(""name"")); subcategory.setCount(Integer.parseInt(node.getAttribute(""count"")));  subcategories.add(subcategory); }  NodeList groupNodes = categoryElement.getElementsByTagName(""group""); for (int i = 0; i < groupNodes.getLength(); i++) { Element node = (Element) groupNodes.item(i); Group group = new Group(); group.setId(node.getAttribute(""nsid"")); group.setName(node.getAttribute(""name"")); group.setMembers(node.getAttribute(""members""));  groups.add(group); }  category.setGroups(groups); category.setSubcategories(subcategories);  return category; }  /**
     * Get the info for a specified group.
     * 
     * This method does not require authentication.
     * 
     * @param groupId
     *            The group id
     * @return The Group object
     */ public Group getInfo(String groupId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO); parameters.put(""group_id"", groupId);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element groupElement = response.getPayload(); Group group = new Group(); group.setId(groupElement.getAttribute(""id"")); group.setIconFarm(groupElement.getAttribute(""iconfarm"")); group.setIconServer(groupElement.getAttribute(""iconserver"")); group.setLang(groupElement.getAttribute(""lang"")); group.setPoolModerated(groupElement.getAttribute(""ispoolmoderated"").equals(""0"") ? false : true);  group.setName(XMLUtilities.getChildValue(groupElement, ""name"")); group.setDescription(XMLUtilities.getChildValue(groupElement, ""description"")); group.setMembers(XMLUtilities.getChildValue(groupElement, ""members"")); group.setPrivacy(XMLUtilities.getChildValue(groupElement, ""privacy"")); group.setPoolCount(XMLUtilities.getChildValue(groupElement, ""pool_count"")); group.setTopicCount(XMLUtilities.getChildValue(groupElement, ""topic_count""));  NodeList throttleNodes = groupElement.getElementsByTagName(""throttle""); int n = throttleNodes.getLength(); if (n == 1) { Element throttleElement = (Element) throttleNodes.item(0); Throttle throttle = new Throttle(); group.setThrottle(throttle); throttle.setMode(throttleElement.getAttribute(""mode"")); String countStr = throttleElement.getAttribute(""count""); String remainingStr = throttleElement.getAttribute(""remaining""); if (countStr != null && countStr.length() > 0) { throttle.setCount(Integer.parseInt(countStr)); } if (remainingStr != null && remainingStr.length() > 0) { throttle.setRemaining(Integer.parseInt(remainingStr)); } } else if (n > 1) { <FILL_ME> <FILL_ME> <FILL_ME> }  NodeList restrictionNodes = groupElement.getElementsByTagName(""restrictions""); n = restrictionNodes.getLength(); if (n == 1) { Element restrictionElement = (Element) restrictionNodes.item(0); Restriction restriction = new Restriction(); group.setRestriction(restriction); restriction.setIsPhotosOk(""1"".equals(restrictionElement.getAttribute(""photos_ok""))); restriction.setIsVideosOk(""1"".equals(restrictionElement.getAttribute(""videos_ok""))); restriction.setIsImagesOk(""1"".equals(restrictionElement.getAttribute(""images_ok""))); restriction.setIsScreensOk(""1"".equals(restrictionElement.getAttribute(""screens_ok""))); restriction.setIsArtOk(""1"".equals(restrictionElement.getAttribute(""art_ok""))); restriction.setIsSafeOk(""1"".equals(restrictionElement.getAttribute(""safe_ok""))); restriction.setIsModerateOk(""1"".equals(restrictionElement.getAttribute(""moderate_ok""))); restriction.setIsRestrictedOk(""1"".equals(restrictionElement.getAttribute(""restricted_ok""))); restriction.setIsHasGeo(""1"".equals(restrictionElement.getAttribute(""has_geo""))); } else if (n > 1) { } NodeList blastNodes = groupElement.getElementsByTagName(""blast""); n = blastNodes.getLength(); if (n == 1) { Element blastElement = (Element) blastNodes.item(0); Blast blast = new Blast(); group.setBlast(blast); blast.setUserId(blastElement.getAttribute(""user_id"")); blast.setDateBlastAdded(blastElement.getAttribute(""date_blast_added"")); blast.setBlast(XMLUtilities.getChildValue(groupElement, ""blast"")); } else if (n > 1) { }  return group; }  /**
     * Search for groups. 18+ groups will only be returned for authenticated calls where the authenticated user is over 18. This method does not require
     * authentication.
     * 
     * @param text
     *            The text to search for.
     * @param perPage
     *            Number of groups to return per page. If this argument is 0, it defaults to 100. The maximum allowed value is 500.
     * @param page
     *            The page of results to return. If this argument is 0, it defaults to 1.
     * @return A GroupList Object. Only the fields <em>id</em>, <em>name</em> and <em>eighteenplus</em> in the Groups will be set.
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Collection<Group> search(String text, int perPage, int page) throws FlickrException { GroupList<Group> groupList = new GroupList<Group>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SEARCH);  parameters.put(""text"", text);  if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element groupsElement = response.getPayload(); NodeList groupNodes = groupsElement.getElementsByTagName(""group""); groupList.setPage(XMLUtilities.getIntAttribute(groupsElement, ""page"")); groupList.setPages(XMLUtilities.getIntAttribute(groupsElement, ""pages"")); groupList.setPerPage(XMLUtilities.getIntAttribute(groupsElement, ""perpage"")); groupList.setTotal(XMLUtilities.getIntAttribute(groupsElement, ""total"")); for (int i = 0; i < groupNodes.getLength(); i++) { Element groupElement = (Element) groupNodes.item(i); Group group = new Group(); group.setId(groupElement.getAttribute(""nsid"")); group.setName(groupElement.getAttribute(""name"")); groupList.add(group); } return groupList; }  /**
     * Join a group as a public member.
     * 
     * Note: if a group has rules - the client must display the rules to the user and the user must accept them prior to joining the group. The acceptRules
     * parameter indicates that the user has accepted those rules.
     * 
     * @param groupId
     *            - the id of the group to join
     * @param acceptRules
     *            - if a group has rules, true indicates the user has accepted the rules
     * 
     * @see <a href=""http://www.flickr.com/services/api/flickr.groups.join.html"">flickr.groups.join</a>
     */ public void join(String groupId, Boolean acceptRules) throws FlickrException {  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_JOIN); parameters.put(""group_id"", groupId); if (acceptRules != null) { parameters.put(""accept_rules"", acceptRules); }  Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Request to join a group.
     * 
     * Note: if a group has rules, the client must display the rules to the user and the user must accept them (which is indicated by passing a true value to
     * acceptRules) prior to making the join request.
     * 
     * @param groupId
     *            - groupId parameter
     * @param message
     *            - (required) message to group administrator
     * @param acceptRules
     *            - (required) parameter indicating user has accepted groups rules
     */ public void joinRequest(String groupId, String message, boolean acceptRules) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_JOIN_REQUEST); parameters.put(""group_id"", groupId); parameters.put(""message"", message); parameters.put(""accept_rules"", acceptRules);  Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Leave a group.
     * 
     * @see <a href=""http://www.flickr.com/services/api/flickr.groups.leave.html"">lickr.groups.leave</a> for a description of the various behaviors possible
     *      when a user leaves a group.
     * 
     * @param groupId
     *            - the id of the group to leave
     * @param deletePhotos
     *            - delete photos by this user from group
     */ public void leave(String groupId, Boolean deletePhotos) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_LEAVE); parameters.put(""group_id"", groupId); parameters.put(""delete_photos"", deletePhotos);  Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } }  "
src/main/java/com/flickr4java/flickr/groups/Restriction.java,"package com.flickr4java.flickr.groups;

public class Restriction {

	    private Boolean photosOk;

	    private Boolean videosOk;
	    
	    private Boolean imagesOk;

	    private Boolean screensOk;
	    
	    private Boolean artOk;
	    
	    private Boolean safeOk;
	    
	    private Boolean moderateOk;
	    
	    private Boolean restrictedOk;
	    
	    private Boolean hasGeo;

	    /**
	     * 
	     *
	     * @return Are Photos allowed in the group
	     */
	    public Boolean isPhotosOk() {
	        return photosOk;
	    }
	    
	    public void setIsPhotosOk(Boolean value) {
	    	this.photosOk = value;
	    }

	    /**
	     * 
	     * 
	     * @return  Are Videos allowed in the group
	     */
	    public Boolean isVideosOk() {
	        return videosOk;
	    }
	    
	    public void setIsVideosOk(Boolean value) {
	    	this.videosOk = value;
	    	
	    }

	    /**
	     * 
	     * 
	     * @return  Are Images allowed in the group
	     */
	    public Boolean isImagesOk() {
	        return imagesOk;
	    }
	    
	    public void setIsImagesOk(Boolean value) {
	    	this.imagesOk = value;
	    }
	    /**
	     * 
	     * @return Are Screens allowed in the group
	     */
	    public Boolean isScreensOk() {
	        return screensOk;
	    }
	    
	    public void setIsScreensOk(Boolean value) {
	    	this.screensOk = value;
	    }

	    /**
	     * 
	     * @return Are art allowed in the group
	     */
	    public Boolean isArtOk() {
	        return artOk;
	    }
	    
	    public void setIsArtOk(Boolean value) {
	    	this.artOk = value;
	    }

	    /**
	     * 
	     * @return Are Safe rated images allowed in the group
	     */
	    public Boolean isSafeOk() {
	        return safeOk;
	    }
	    
	    public void setIsSafeOk(Boolean value) {
	    	this.safeOk = value;
	    }
	    /**
	     * 
	     * @return Are Moderate rated images allowed in the group
	     */
	    public Boolean isModerateOk() {
	        return moderateOk;
	    }
	    
	    public void setIsModerateOk(Boolean value) {
	    	this.moderateOk = value;
	    }

	    /**
	     * 
	     * @return Are Restricted rated images allowed in the group
	     */
	    public Boolean isRestrictedOk() {
	        return restrictedOk;
	    }
	    
	    public void setIsRestrictedOk(Boolean value) {
	    	this.restrictedOk = value;
	    }

	    /**
	     * 
	     * @return Are Geo-tagged images allowed in the group
	     */
	    public Boolean isHasGeo() {
	        return hasGeo;
	    }
	    
	    public void setIsHasGeo(Boolean value) {
	    	this.hasGeo = value;
	    }
	    

}
",package com.flickr4java.flickr.groups; public class Restriction { private Boolean photosOk; private Boolean videosOk; private Boolean imagesOk; private Boolean screensOk; private Boolean artOk; private Boolean safeOk; private Boolean moderateOk; private Boolean restrictedOk; private Boolean hasGeo; public Boolean isPhotosOk() { return photosOk; } public void setIsPhotosOk(Boolean value) { this.photosOk = value; } public Boolean isVideosOk() { return videosOk; } public void setIsVideosOk(Boolean value) { this.videosOk = value; } public Boolean isImagesOk() { return imagesOk; } public void setIsImagesOk(Boolean value) { this.imagesOk = value; } public Boolean isScreensOk() { return screensOk; } public void setIsScreensOk(Boolean value) { this.screensOk = value; } public Boolean isArtOk() { return artOk; } public void setIsArtOk(Boolean value) { this.artOk = value; } public Boolean isSafeOk() { return safeOk; } public void setIsSafeOk(Boolean value) { this.safeOk = value; } public Boolean isModerateOk() { return moderateOk; } public void setIsModerateOk(Boolean value) { this.moderateOk = value; } public Boolean isRestrictedOk() { return restrictedOk; } public void setIsRestrictedOk(Boolean value) { this.restrictedOk = value; } public Boolean isHasGeo() { return hasGeo; } public void setIsHasGeo(Boolean value) { this.hasGeo = value; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.groups; public class Restriction { private Boolean photosOk; private Boolean videosOk; private Boolean imagesOk; private Boolean screensOk; private Boolean artOk; private Boolean safeOk; private Boolean moderateOk; private Boolean restrictedOk; private Boolean hasGeo; public Boolean isPhotosOk() { return photosOk; } public void setIsPhotosOk(Boolean value) { this.photosOk = value; } public Boolean isVideosOk() { return videosOk; } public void setIsVideosOk(Boolean value) { this.videosOk = value; } public Boolean isImagesOk() { return imagesOk; } public void setIsImagesOk(Boolean value) { this.imagesOk = value; } public Boolean isScreensOk() { return screensOk; } public void setIsScreensOk(Boolean value) { this.screensOk = value; } public Boolean isArtOk() { return artOk; } public void setIsArtOk(Boolean value) { this.artOk = value; } public Boolean isSafeOk() { return safeOk; } public void setIsSafeOk(Boolean value) { this.safeOk = value; } public Boolean isModerateOk() { return moderateOk; } public void setIsModerateOk(Boolean value) { this.moderateOk = value; } public Boolean isRestrictedOk() { return restrictedOk; } public void setIsRestrictedOk(Boolean value) { this.restrictedOk = value; } public Boolean isHasGeo() { return hasGeo; } public void setIsHasGeo(Boolean value) { this.hasGeo = value; } } ,"package com.flickr4java.flickr.groups;  public class Restriction {  private Boolean photosOk;  private Boolean videosOk; 	     private Boolean imagesOk;  private Boolean screensOk; 	     private Boolean artOk; 	     private Boolean safeOk; 	     private Boolean moderateOk; 	     private Boolean restrictedOk; 	     private Boolean hasGeo;  /**
	     * 
	     *
	     * @return Are Photos allowed in the group
	     */ public Boolean isPhotosOk() { return photosOk; } 	     public void setIsPhotosOk(Boolean value) { this.photosOk = value; }  /**
	     * 
	     * 
	     * @return  Are Videos allowed in the group
	     */ public Boolean isVideosOk() { return videosOk; } 	     public void setIsVideosOk(Boolean value) { this.videosOk = value; 	    	 }  /**
	     * 
	     * 
	     * @return  Are Images allowed in the group
	     */ public Boolean isImagesOk() { return imagesOk; } 	     public void setIsImagesOk(Boolean value) { this.imagesOk = value; } /**
	     * 
	     * @return Are Screens allowed in the group
	     */ public Boolean isScreensOk() { return screensOk; } 	     public void setIsScreensOk(Boolean value) { this.screensOk = value; }  /**
	     * 
	     * @return Are art allowed in the group
	     */ public Boolean isArtOk() { return artOk; } 	     public void setIsArtOk(Boolean value) { this.artOk = value; }  /**
	     * 
	     * @return Are Safe rated images allowed in the group
	     */ public Boolean isSafeOk() { return safeOk; } 	     public void setIsSafeOk(Boolean value) { this.safeOk = value; } /**
	     * 
	     * @return Are Moderate rated images allowed in the group
	     */ public Boolean isModerateOk() { return moderateOk; } 	     public void setIsModerateOk(Boolean value) { this.moderateOk = value; }  /**
	     * 
	     * @return Are Restricted rated images allowed in the group
	     */ public Boolean isRestrictedOk() { return restrictedOk; } 	     public void setIsRestrictedOk(Boolean value) { this.restrictedOk = value; }  /**
	     * 
	     * @return Are Geo-tagged images allowed in the group
	     */ public Boolean isHasGeo() { return hasGeo; } 	     public void setIsHasGeo(Boolean value) { this.hasGeo = value; } 	    
 }  "
src/main/java/com/flickr4java/flickr/groups/Subcategory.java,"
package com.flickr4java.flickr.groups;

/**
 * Class representing a subcategory.
 * 
 * @author Anthony Eden
 */
public class Subcategory {

    private int id;

    private String name;

    private int count;

    public Subcategory() {

    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getCount() {
        return count;
    }

    public void setCount(int count) {
        this.count = count;
    }

}
",package com.flickr4java.flickr.groups; public class Subcategory { private int id; private String name; private int count; public Subcategory() { } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getCount() { return count; } public void setCount(int count) { this.count = count; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.groups; public class Subcategory { private int id; private String name; private int count; public Subcategory() { } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getCount() { return count; } public void setCount(int count) { this.count = count; } } ," package com.flickr4java.flickr.groups;  /**
 * Class representing a subcategory.
 * 
 * @author Anthony Eden
 */ public class Subcategory {  private int id;  private String name;  private int count;  public Subcategory() {  }  public int getId() { return id; }  public void setId(int id) { this.id = id; }  public String getName() { return name; }  public void setName(String name) { this.name = name; }  public int getCount() { return count; }  public void setCount(int count) { this.count = count; }  }  "
src/main/java/com/flickr4java/flickr/groups/Throttle.java,"package com.flickr4java.flickr.groups;

/**
 * Throttle - Limit the abilitiy to add Photos to a group on a per user per post basis. ""No more than X in Y days"".
 * 
 * @author Anthony Eden
 * @version $Id: Throttle.java,v 1.3 2009/07/12 22:43:07 x-mago Exp $
 */
public class Throttle {

    private int count;

    private String mode;

    private int remaining;

    /**
     * Posts are limited to this number of Photos.
     * 
     * @return mx number of posts allowed
     */
    public int getCount() {
        return count;
    }

    public void setCount(int count) {
        this.count = count;
    }

    /**
     * Throttle mode - day, month or none.
     * 
     * @return mode
     */
    public String getMode() {
        return mode;
    }

    public void setMode(String mode) {
        this.mode = mode;
    }

    /**
     * Number of remaining Photos to add.<br>
     * (lokks, like not longer available)
     * 
     * @return units
     */
    public int getRemaining() {
        return remaining;
    }

    public void setRemaining(int remaining) {
        this.remaining = remaining;
    }
}
",package com.flickr4java.flickr.groups; public class Throttle { private int count; private String mode; private int remaining; public int getCount() { return count; } public void setCount(int count) { this.count = count; } public String getMode() { return mode; } public void setMode(String mode) { this.mode = mode; } public int getRemaining() { return remaining; } public void setRemaining(int remaining) { this.remaining = remaining; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.groups; public class Throttle { private int count; private String mode; private int remaining; public int getCount() { return count; } public void setCount(int count) { this.count = count; } public String getMode() { return mode; } public void setMode(String mode) { this.mode = mode; } public int getRemaining() { return remaining; } public void setRemaining(int remaining) { this.remaining = remaining; } } ,"package com.flickr4java.flickr.groups;  /**
 * Throttle - Limit the abilitiy to add Photos to a group on a per user per post basis. ""No more than X in Y days"".
 * 
 * @author Anthony Eden
 * @version $Id: Throttle.java,v 1.3 2009/07/12 22:43:07 x-mago Exp $
 */ public class Throttle {  private int count;  private String mode;  private int remaining;  /**
     * Posts are limited to this number of Photos.
     * 
     * @return mx number of posts allowed
     */ public int getCount() { return count; }  public void setCount(int count) { this.count = count; }  /**
     * Throttle mode - day, month or none.
     * 
     * @return mode
     */ public String getMode() { return mode; }  public void setMode(String mode) { this.mode = mode; }  /**
     * Number of remaining Photos to add.<br>
     * (lokks, like not longer available)
     * 
     * @return units
     */ public int getRemaining() { return remaining; }  public void setRemaining(int remaining) { this.remaining = remaining; } }  "
src/main/java/com/flickr4java/flickr/interestingness/InterestingnessInterface.java,"/*
 *-------------------------------------------------------
 * (c) 2006 Das B&uuml;ro am Draht GmbH - All Rights reserved
 *-------------------------------------------------------
 */
package com.flickr4java.flickr.interestingness;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.photos.Extras;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoList;
import com.flickr4java.flickr.photos.PhotoUtils;
import com.flickr4java.flickr.util.StringUtilities;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * 
 * @author till
 * @version $Id: InterestingnessInterface.java,v 1.9 2009/07/11 20:30:27 x-mago Exp $
 */
public class InterestingnessInterface {

    public static final String METHOD_GET_LIST = ""flickr.interestingness.getList"";

    private static final String KEY_METHOD = ""method"";

    private static final String KEY_DATE = ""date"";

    private static final String KEY_EXTRAS = ""extras"";

    private static final String KEY_PER_PAGE = ""per_page"";

    private static final String KEY_PAGE = ""page"";

    private static final ThreadLocal<SimpleDateFormat> DATE_FORMATS = new ThreadLocal<SimpleDateFormat>() {
        @Override
        protected synchronized SimpleDateFormat initialValue() {
            return new SimpleDateFormat(""yyyy-MM-dd"");
        }
    };

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transportAPI;

    public InterestingnessInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transportAPI;
    }

    /**
     * Returns the list of interesting photos for the most recent day or a user-specified date.
     * 
     * This method does not require authentication.
     * 
     * @param date
     * @param extras
     *            A set of Strings controlling the extra information to fetch for each returned record. Currently supported fields are: license, date_upload,
     *            date_taken, owner_name, icon_server, original_format, last_update, geo. Set to null or an empty set to not specify any extras.
     * @param perPage
     *            The number of photos to show per page
     * @param page
     *            The page offset
     * @return PhotoList
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see com.flickr4java.flickr.photos.Extras
     */
    public PhotoList<Photo> getList(String date, Set<String> extras, int perPage, int page) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        PhotoList<Photo> photos = new PhotoList<Photo>();

        parameters.put(KEY_METHOD, METHOD_GET_LIST);

        if (date != null) {
            parameters.put(KEY_DATE, date);
        }

        if (extras != null) {
            parameters.put(KEY_EXTRAS, StringUtilities.join(extras, "",""));
        }

        if (perPage > 0) {
            parameters.put(KEY_PER_PAGE, String.valueOf(perPage));
        }
        if (page > 0) {
            parameters.put(KEY_PAGE, String.valueOf(page));
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element photosElement = response.getPayload();
        photos.setPage(photosElement.getAttribute(""page""));
        photos.setPages(photosElement.getAttribute(""pages""));
        photos.setPerPage(photosElement.getAttribute(""perpage""));
        photos.setTotal(photosElement.getAttribute(""total""));

        NodeList photoNodes = photosElement.getElementsByTagName(""photo"");
        for (int i = 0; i < photoNodes.getLength(); i++) {
            Element photoElement = (Element) photoNodes.item(i);
            Photo photo = PhotoUtils.createPhoto(photoElement);
            photos.add(photo);
        }
        return photos;
    }

    /**
     * 
     * @param date
     * @param extras
     * @param perPage
     * @param page
     * @return PhotoList
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see com.flickr4java.flickr.photos.Extras
     */
    public PhotoList<Photo> getList(Date date, Set<String> extras, int perPage, int page) throws FlickrException {
        String dateString = null;
        if (date != null) {
            DateFormat df = DATE_FORMATS.get();
            dateString = df.format(date);
        }
        return getList(dateString, extras, perPage, page);
    }

    /**
     * convenience method to get the list of all 500 most recent photos in flickr explore with all known extra attributes.
     * 
     * @return a List of Photos
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PhotoList<Photo> getList() throws FlickrException {
        return getList((String) null, Extras.ALL_EXTRAS, 500, 1);
    }

}
","package com.flickr4java.flickr.interestingness; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.Extras; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.util.StringUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.Date; import java.util.HashMap; import java.util.Map; import java.util.Set; public class InterestingnessInterface { public static final String METHOD_GET_LIST = ""flickr.interestingness.getList""; private static final String KEY_METHOD = ""method""; private static final String KEY_DATE = ""date""; private static final String KEY_EXTRAS = ""extras""; private static final String KEY_PER_PAGE = ""per_page""; private static final String KEY_PAGE = ""page""; private static final ThreadLocal<SimpleDateFormat> DATE_FORMATS = new ThreadLocal<SimpleDateFormat>() { @Override
        protected synchronized SimpleDateFormat initialValue() { return new SimpleDateFormat(""yyyy-MM-dd""); } } ; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public InterestingnessInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public PhotoList<Photo> getList(String date, Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PhotoList<Photo> photos = new PhotoList<Photo>(); parameters.put(KEY_METHOD, METHOD_GET_LIST); if (date != null) { parameters.put(KEY_DATE, date); } if (extras != null) { parameters.put(KEY_EXTRAS, StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(KEY_PER_PAGE, String.valueOf(perPage)); } if (page > 0) { parameters.put(KEY_PAGE, String.valueOf(page)); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); Photo photo = PhotoUtils.createPhoto(photoElement); photos.add(photo); } return photos; } public PhotoList<Photo> getList(Date date, Set<String> extras, int perPage, int page) throws FlickrException { String dateString = null; if (date != null) { DateFormat df = DATE_FORMATS.get(); dateString = df.format(date); } return getList(dateString, extras, perPage, page); } public PhotoList<Photo> getList() throws FlickrException { return getList((String) null, Extras.ALL_EXTRAS, 500, 1); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.interestingness; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.Extras; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.util.StringUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.Date; import java.util.HashMap; import java.util.Map; import java.util.Set; public class InterestingnessInterface { public static final String METHOD_GET_LIST = ""flickr.interestingness.getList""; private static final String KEY_METHOD = ""method""; private static final String KEY_DATE = ""date""; private static final String KEY_EXTRAS = ""extras""; private static final String KEY_PER_PAGE = ""per_page""; private static final String KEY_PAGE = ""page""; private static final ThreadLocal<SimpleDateFormat> DATE_FORMATS = new ThreadLocal<SimpleDateFormat>() { @Override
        protected synchronized SimpleDateFormat initialValue() { return new SimpleDateFormat(""yyyy-MM-dd""); } } ; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public InterestingnessInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public PhotoList<Photo> getList(String date, Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PhotoList<Photo> photos = new PhotoList<Photo>(); parameters.put(KEY_METHOD, METHOD_GET_LIST); if (date != null) { parameters.put(KEY_DATE, date); } if (extras != null) { parameters.put(KEY_EXTRAS, StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(KEY_PER_PAGE, String.valueOf(perPage)); } if (page > 0) { parameters.put(KEY_PAGE, String.valueOf(page)); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); Photo photo = PhotoUtils.createPhoto(photoElement); photos.add(photo); } return photos; } public PhotoList<Photo> getList(Date date, Set<String> extras, int perPage, int page) throws FlickrException { String dateString = null; if (date != null) { DateFormat df = DATE_FORMATS.get(); dateString = df.format(date); } return getList(dateString, extras, perPage, page); } public PhotoList<Photo> getList() throws FlickrException { return getList((String) null, Extras.ALL_EXTRAS, 500, 1); } } ","/*
 *-------------------------------------------------------
 * (c) 2006 Das B&uuml;ro am Draht GmbH - All Rights reserved
 *-------------------------------------------------------
 */ package com.flickr4java.flickr.interestingness;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.Extras; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.util.StringUtilities;  import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.Date; import java.util.HashMap; import java.util.Map; import java.util.Set;  /**
 * 
 * @author till
 * @version $Id: InterestingnessInterface.java,v 1.9 2009/07/11 20:30:27 x-mago Exp $
 */ public class InterestingnessInterface {  public static final String METHOD_GET_LIST = ""flickr.interestingness.getList"";  private static final String KEY_METHOD = ""method"";  private static final String KEY_DATE = ""date"";  private static final String KEY_EXTRAS = ""extras"";  private static final String KEY_PER_PAGE = ""per_page"";  private static final String KEY_PAGE = ""page"";  private static final ThreadLocal<SimpleDateFormat> DATE_FORMATS = new ThreadLocal<SimpleDateFormat>() { @Override
        protected synchronized SimpleDateFormat initialValue() { return new SimpleDateFormat(""yyyy-MM-dd""); } } ;  private final String apiKey;  private final String sharedSecret;  private final Transport transportAPI;  public InterestingnessInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; }  /**
     * Returns the list of interesting photos for the most recent day or a user-specified date.
     * 
     * This method does not require authentication.
     * 
     * @param date
     * @param extras
     *            A set of Strings controlling the extra information to fetch for each returned record. Currently supported fields are: license, date_upload,
     *            date_taken, owner_name, icon_server, original_format, last_update, geo. Set to null or an empty set to not specify any extras.
     * @param perPage
     *            The number of photos to show per page
     * @param page
     *            The page offset
     * @return PhotoList
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see com.flickr4java.flickr.photos.Extras
     */ public PhotoList<Photo> getList(String date, Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PhotoList<Photo> photos = new PhotoList<Photo>();  parameters.put(KEY_METHOD, METHOD_GET_LIST);  if (date != null) { parameters.put(KEY_DATE, date); }  if (extras != null) { parameters.put(KEY_EXTRAS, StringUtilities.join(extras, "","")); }  if (perPage > 0) { parameters.put(KEY_PER_PAGE, String.valueOf(perPage)); } if (page > 0) { parameters.put(KEY_PAGE, String.valueOf(page)); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total""));  NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); Photo photo = PhotoUtils.createPhoto(photoElement); photos.add(photo); } return photos; }  /**
     * 
     * @param date
     * @param extras
     * @param perPage
     * @param page
     * @return PhotoList
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see com.flickr4java.flickr.photos.Extras
     */ public PhotoList<Photo> getList(Date date, Set<String> extras, int perPage, int page) throws FlickrException { String dateString = null; if (date != null) { DateFormat df = DATE_FORMATS.get(); dateString = df.format(date); } return getList(dateString, extras, perPage, page); }  /**
     * convenience method to get the list of all 500 most recent photos in flickr explore with all known extra attributes.
     * 
     * @return a List of Photos
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PhotoList<Photo> getList() throws FlickrException { return getList((String) null, Extras.ALL_EXTRAS, 500, 1); }  }  "
src/main/java/com/flickr4java/flickr/machinetags/MachinetagsInterface.java,"package com.flickr4java.flickr.machinetags;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.util.XMLUtilities;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

/**
 * A more precise way to tag and to search photos.
 * 
 * <h3>What are machine tags?</h3>
 * 
 * Machine tags are tags that use a special syntax to define extra information about a tag.<br>
 * 
 * Machine tags have a namespace, a predicate and a value. The namespace defines a class or a facet that a tag belongs to ('geo', 'flickr', etc.) The predicate
 * is name of the property for a namespace ('latitude', 'user', etc.) The value is, well, the value.<br>
 * 
 * Like tags, there are no rules for machine tags beyond the syntax to specify the parts of a machine tag. For example, you could tag a photo with:
 * <p>
 * 
 * <ul>
 * <li>flickr:user=straup</li>
 * <li>flora:tree=coniferous</li>
 * <li>medium:paint=oil</li>
 * <li>geo:quartier=""plateau mont royal""</li>
 * <li>geo:neighbourhood=geo:quartier</li>
 * </ul>
 * 
 * Flickr has already used machine tags, informally, on a couple of occasions:
 * 
 * <ul>
 * <li>When we launched Maps, we provided a way for people who had ""geotagged"" their photos to import their location data. This was done using the ""geo:lat=...""
 * and ""geo:lon=..."" tags.</li>
 * 
 * <li>When a user tags an event with an upcoming ID (for example : ""upcoming:event=81334"") we display a link back to the upcoming.org site. A similar example
 * is the excellent ""Flickr Upcoming Event"" greasemonkey script:
 * <p>
 * 
 * <a href=""https://web.archive.org/web/20131103192452/http://userscripts.org/scripts/show/5464"">Flickr Upcoming Event</a>
 * <p>
 * 
 * Dan Catt wrote a very good piece about machine tags - he called them ""triple tags"" - last year:
 * <p>
 * 
 * <a href=""https://web.archive.org/web/20080617093009/http://geobloggers.com:80/archives/2006/01/11/advanced-tagging-and-tripletags/"">Advanced Tagging and TripleTags</a>
 * <p>
 * 
 * Update : Dan's gone and written another excellent piece about all of this stuff now that we've launched machine tags:
 * 
 * <a href=""https://web.archive.org/web/20080621114435/http://geobloggers.com/archives/2007/01/24/offtopic-ish-flickr-ramps-up-triple-tag-support/"">Flickr Ramps up Triple Tag (Machine Tags) Support</a>
 * </li>
 * </ul>
 * <p>
 * 
 * <h3>What is the spec for machine tags?</h3>
 * 
 * Machine tags are divided in to three parts:
 * 
 * <ol>
 * <li>A ""namespace"":
 * <p>
 * 
 * Namespaces MUST begin with any character between a - z; remaining characters MAY be a - z, 0 - 9 and underbars. Namespaces are case-insensitive.</li>
 * 
 * <li>A ""predicate"":
 * <p>
 * 
 * Predicates MUST begin with any character between a - z; remaining characters MAY be a - z, 0 - 9 and underbars. Namespaces are case-insensitive.</li>
 * 
 * <li>A ""value"":
 * <p>
 * 
 * Values MAY contain any characters that a ""plain vanilla"" tags use. Values may also contain spaces but, like regular tags, they need to wrapped in quotes.</li>
 * </ol>
 * 
 * Namespace and predicates are separated by a colon : "":""
 * <p>
 * 
 * Predicates and values are separated by an equals symbol : ""=""
 * <p>
 * 
 * For example:
 * <p>
 * 
 * <ul>
 * <li>flickr:user=straup</li>
 * <li>geo:locality=""san francisco""</li>
 * </ul>
 * <p>
 * 
 * <h3>Why can't I use non-ASCII characters for namespaces and predicates?</h3>
 * 
 * Simple steps, first.
 * <p>
 * 
 * <h3>Can I define another machine tag as the value of a machine tag?</h3>
 * 
 * Sure, but it will not be processed as a machine tag itself.
 * 
 * <h3>How do I add machine tags?</h3>
 * 
 * By adding tags! No, really.
 * 
 * Machine tags are added *exactly* the same as any other tag whether it is done through the website or the API.
 * 
 * When the Flickr supercomputer processes your tags, we take a moment to check whether it is a machine tag. If it is we leverage the powerful Do What I Mean
 * engine to, well, do what you mean.
 * 
 * <h3>How do I query machine tags?</h3>
 * 
 * Via the API!
 * <p>
 * 
 * Specifically, using the ""machinetags"" parameter in the 'flickr.photos.search' method. Like tags, you can specify multiple machine tags as a comma separated
 * list.
 * 
 * 
 * <h3>Can I query the various part of a machine tag?</h3>
 * 
 * Yes. Aside from passing in a fully formed machine tag, there is a special syntax for searching on specific properties :
 * 
 * <ul>
 * <li>Find photos using the 'dc' namespace:
 * <p>
 * 
 * {""machine_tags"" =&gt; ""dc:""}</li>
 * 
 * <li>Find photos with a title in the 'dc' namespace:
 * <p>
 * 
 * {""machine_tags"" =&gt; ""dc:title=""}</li>
 * 
 * <li>Find photos titled ""mr. camera"" in the 'dc' namespace:
 * <p>
 * 
 * {""machine_tags"" =&gt; ""dc:title=\""mr. camera\""}</li>
 * 
 * <li>Find photos whose value is ""mr. camera"":
 * <p>
 * 
 * {""machine_tags"" =&gt; ""*:*=\""mr. camera\""""}</li>
 * 
 * <li>Find photos that have a title, in any namespace:
 * <p>
 * 
 * {""machine_tags"" =&gt; ""*:title=""}</li>
 * 
 * <li>Find photos that have a title, in any namespace, whose value is ""mr. camera"":
 * <p>
 * 
 * {""machine_tags"" =&gt; ""*:title=\""mr. camera\""""}</li>
 * 
 * <li>Find photos, in the 'dc' namespace whose value is ""mr. camera"":
 * <p>
 * 
 * {""machine_tags"" =&gt; ""dc:*=\""mr. camera\""""}</li>
 * </ul>
 * 
 * <h3>Is there a limit to the number of machine tags I can query?</h3>
 * 
 * Yes. The limit depends on the tag mode (ALL or ANY) that you are querying with. ""ALL"" (AND) queries are limited to (16) machine tags. ""ANY"" (OR) queries are
 * limited to (8).
 * 
 * <h3>Can I do range queries on machine tags?</h3>
 * 
 * No. Not yet, anyway.
 * <p>
 * 
 * It is a hard problem for reasons far too dull to get in to here. It's on the list.
 * 
 * <h3>Are machine tag namespaces reserved?</h3>
 * 
 * No. Anyone can use a namespace for anything they want.
 * <p>
 * 
 * If you are concerned about colliding namespaces you should consider adding an additional machine tag to define your namespace. For example:
 * <p>
 * 
 * <pre>
 * dc:subject=tags
 * xmlns:dc=http://purl.org/dc/elements/1.1/
 * </pre>
 * 
 * Like tags, in general, we expect (hope?) that the community will develop its own standards by consensus over time.
 * 
 * <h3>What about all the machine tags that are already in the Flickr database?</h3>
 * 
 * At the moment, they are still treated as plain old tags.
 * <p>
 * 
 * We have plans to go back and re-import them as machine tags but for now, only new tags will be processed as machine tags.
 * <p>
 * 
 * In the meantime, if you re-save a machine from the 'edit this tag' page it will be re-imported as a machine tag.
 * 
 * <h3>Is the predicate *really* a predicate?</h3>
 * 
 * You are in a dark cave. In the corner is a fire and a man making bunny shadows on the wall with his hands. Whether or not it's really a 'predicate' depends
 * on how much time you spend on the semantic-web mailing list. ;-)
 * <p>
 * 
 * It's close enough to being a predicate that it makes for a good short-hand.
 * 
 * <h3>Wait, aren't machine tags just RDF?</h3>
 * 
 * No, machine tags are not RDF; they could play RDF on television, though.
 * <p>
 * 
 * See also:
 * 
 * <a href=""https://web.archive.org/web/20110716015005/http://weblog.scifihifi.com/2005/08/05/meta-tags-the-poor-mans-rdf/"">Meta Tags: The Poor Man’s RDF?</a>
 * 
 * <h3>Huh, what is RDF?</h3>
 * 
 * RDF Describes Flickr. That's really all you need to know about RDF.
 * 
 * @author mago
 * @version $Id: MachinetagsInterface.java,v 1.3 2009/07/11 20:30:27 x-mago Exp $
 * @see <a href=""http://code.flickr.com/blog/2008/07/18/wildcard-machine-tag-urls/"">http://code.flickr.com/blog/2008/07/18/wildcard-machine-tag-urls/</a>
 * @see <a
 *      href=""http://code.flickr.com/blog/2008/08/28/machine-tags-lastfm-and-rocknroll/"">http://code.flickr.com/blog/2008/08/28/machine-tags-lastfm-and-rocknroll/</a>
 * @see <a href=""http://blech.vox.com/library/post/flickr-exif-machine-tags.html"">http://blech.vox.com/library/post/flickr-exif-machine-tags.html</a>
 * @see <a href=""http://husk.org/code/machine-tag-browser.html"">machine-tag-browser</a>
 */
public class MachinetagsInterface {
    private static final String METHOD_GET_NAMESPACES = ""flickr.machinetags.getNamespaces"";

    private static final String METHOD_GET_PAIRS = ""flickr.machinetags.getPairs"";

    private static final String METHOD_GET_PREDICATES = ""flickr.machinetags.getPredicates"";

    private static final String METHOD_GET_VALUES = ""flickr.machinetags.getValues"";

    private static final String METHOD_GET_RECENTVALUES = ""flickr.machinetags.getRecentValues"";

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transportAPI;

    public MachinetagsInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transportAPI;
    }

    /**
     * Return a list of unique namespaces, optionally limited by a given predicate, in alphabetical order.
     * 
     * This method does not require authentication.
     * 
     * @param predicate
     * @param perPage
     * @param page
     * @return NamespacesList
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public NamespacesList<Namespace> getNamespaces(String predicate, int perPage, int page) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        NamespacesList<Namespace> nsList = new NamespacesList<Namespace>();
        parameters.put(""method"", METHOD_GET_NAMESPACES);

        if (predicate != null) {
            parameters.put(""predicate"", predicate);
        }
        if (perPage > 0) {
            parameters.put(""per_page"", """" + perPage);
        }
        if (page > 0) {
            parameters.put(""page"", """" + page);
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element nsElement = response.getPayload();
        NodeList nsNodes = nsElement.getElementsByTagName(""namespace"");
        nsList.setPage(""1"");
        nsList.setPages(""1"");
        nsList.setPerPage("""" + nsNodes.getLength());
        nsList.setTotal("""" + nsNodes.getLength());
        for (int i = 0; i < nsNodes.getLength(); i++) {
            Element element = (Element) nsNodes.item(i);
            nsList.add(parseNamespace(element));
        }
        return nsList;
    }

    /**
     * Return a list of unique namespace and predicate pairs, optionally limited by predicate or namespace, in alphabetical order.
     * 
     * This method does not require authentication.
     * 
     * @param namespace
     *            optional, can be null
     * @param predicate
     *            optional, can be null
     * @param perPage
     *            The number of photos to show per page
     * @param page
     *            The page offset
     * @return NamespacesList containing Pair-objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public NamespacesList<Pair> getPairs(String namespace, String predicate, int perPage, int page) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        NamespacesList<Pair> nsList = new NamespacesList<Pair>();
        parameters.put(""method"", METHOD_GET_PAIRS);

        if (namespace != null) {
            parameters.put(""namespace"", namespace);
        }
        if (predicate != null) {
            parameters.put(""predicate"", predicate);
        }
        if (perPage > 0) {
            parameters.put(""per_page"", """" + perPage);
        }
        if (page > 0) {
            parameters.put(""page"", """" + page);
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element nsElement = response.getPayload();
        NodeList nsNodes = nsElement.getElementsByTagName(""pair"");
        nsList.setPage(nsElement.getAttribute(""page""));
        nsList.setPages(nsElement.getAttribute(""pages""));
        nsList.setPerPage(nsElement.getAttribute(""perPage""));
        nsList.setTotal("""" + nsNodes.getLength());
        for (int i = 0; i < nsNodes.getLength(); i++) {
            Element element = (Element) nsNodes.item(i);
            nsList.add(parsePair(element));
        }
        return nsList;
    }

    /**
     * Return a list of unique predicates, optionally limited by a given namespace.
     * 
     * This method does not require authentication.
     * 
     * @param namespace
     *            The namespace that all values should be restricted to.
     * @param perPage
     *            The number of photos to show per page
     * @param page
     *            The page offset
     * @return NamespacesList containing Predicate
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public NamespacesList<Predicate> getPredicates(String namespace, int perPage, int page) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        NamespacesList<Predicate> nsList = new NamespacesList<Predicate>();
        parameters.put(""method"", METHOD_GET_PREDICATES);

        if (namespace != null) {
            parameters.put(""namespace"", namespace);
        }
        if (perPage > 0) {
            parameters.put(""per_page"", """" + perPage);
        }
        if (page > 0) {
            parameters.put(""page"", """" + page);
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element nsElement = response.getPayload();
        NodeList nsNodes = nsElement.getElementsByTagName(""predicate"");
        nsList.setPage(nsElement.getAttribute(""page""));
        nsList.setPages(nsElement.getAttribute(""pages""));
        nsList.setPerPage(nsElement.getAttribute(""perPage""));
        nsList.setTotal("""" + nsNodes.getLength());
        for (int i = 0; i < nsNodes.getLength(); i++) {
            Element element = (Element) nsNodes.item(i);
            nsList.add(parsePredicate(element));
        }
        return nsList;
    }

    /**
     * Return a list of unique values for a namespace and predicate.
     * 
     * This method does not require authentication.
     * 
     * @param namespace
     *            The namespace that all values should be restricted to.
     * @param predicate
     *            The predicate that all values should be restricted to.
     * @param perPage
     *            The number of photos to show per page
     * @param page
     *            The page offset
     * @return NamespacesList
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public NamespacesList<Value> getValues(String namespace, String predicate, int perPage, int page) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        NamespacesList<Value> valuesList = new NamespacesList<Value>();
        parameters.put(""method"", METHOD_GET_VALUES);

        if (namespace != null) {
            parameters.put(""namespace"", namespace);
        }
        if (predicate != null) {
            parameters.put(""predicate"", predicate);
        }
        if (perPage > 0) {
            parameters.put(""per_page"", """" + perPage);
        }
        if (page > 0) {
            parameters.put(""page"", """" + page);
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element nsElement = response.getPayload();
        NodeList nsNodes = nsElement.getElementsByTagName(""value"");
        valuesList.setPage(nsElement.getAttribute(""page""));
        valuesList.setPages(nsElement.getAttribute(""pages""));
        valuesList.setPerPage(nsElement.getAttribute(""perPage""));
        valuesList.setTotal("""" + nsNodes.getLength());
        for (int i = 0; i < nsNodes.getLength(); i++) {
            Element element = (Element) nsNodes.item(i);
            Value value = parseValue(element);
            value.setNamespace(namespace);
            value.setPredicate(predicate);
            valuesList.add(value);
        }
        return valuesList;
    }

    /**
     * Fetch recently used (or created) machine tags values.
     * 
     * This method does not require authentication.
     * 
     * @param namespace
     *            The namespace that all values should be restricted to.
     * @param predicate
     *            The predicate that all values should be restricted to.
     * @param addedSince
     *            Only return machine tags values that have been added since this Date.
     * @return NamespacesList
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public NamespacesList<Value> getRecentValues(String namespace, String predicate, Date addedSince) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        NamespacesList<Value> valuesList = new NamespacesList<Value>();
        parameters.put(""method"", METHOD_GET_RECENTVALUES);

        if (namespace != null) {
            parameters.put(""namespace"", namespace);
        }
        if (predicate != null) {
            parameters.put(""predicate"", predicate);
        }
        if (addedSince != null) {
            parameters.put(""added_since"", Long.toString(addedSince.getTime() / 1000L));
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element nsElement = response.getPayload();
        NodeList nsNodes = nsElement.getElementsByTagName(""value"");
        valuesList.setPage(nsElement.getAttribute(""page""));
        valuesList.setPages(nsElement.getAttribute(""pages""));
        valuesList.setPerPage(nsElement.getAttribute(""perPage""));
        valuesList.setTotal("""" + nsNodes.getLength());
        for (int i = 0; i < nsNodes.getLength(); i++) {
            Element element = (Element) nsNodes.item(i);
            valuesList.add(parseValue(element));
        }
        return valuesList;
    }

    private Value parseValue(Element nsElement) {
        Value value = new Value();
        value.setUsage(nsElement.getAttribute(""usage""));
        value.setNamespace(nsElement.getAttribute(""namespace""));
        value.setPredicate(nsElement.getAttribute(""predicate""));
        value.setFirstAdded(nsElement.getAttribute(""first_added""));
        value.setLastAdded(nsElement.getAttribute(""last_added""));
        value.setValue(XMLUtilities.getValue(nsElement));
        return value;
    }

    private Predicate parsePredicate(Element nsElement) {
        Predicate predicate = new Predicate();
        predicate.setUsage(nsElement.getAttribute(""usage""));
        predicate.setNamespaces(nsElement.getAttribute(""namespaces""));
        predicate.setValue(XMLUtilities.getValue(nsElement));
        return predicate;
    }

    private Namespace parseNamespace(Element nsElement) {
        Namespace ns = new Namespace();
        ns.setUsage(nsElement.getAttribute(""usage""));
        ns.setPredicates(nsElement.getAttribute(""predicates""));
        ns.setValue(XMLUtilities.getValue(nsElement));
        return ns;
    }

    private Pair parsePair(Element nsElement) {
        Pair pair = new Pair();
        pair.setUsage(nsElement.getAttribute(""usage""));
        pair.setNamespace(nsElement.getAttribute(""namespace""));
        pair.setPredicate(nsElement.getAttribute(""predicate""));
        return pair;
    }
}
","package com.flickr4java.flickr.machinetags; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.Date; import java.util.HashMap; import java.util.Map; public class MachinetagsInterface { private static final String METHOD_GET_NAMESPACES = ""flickr.machinetags.getNamespaces""; private static final String METHOD_GET_PAIRS = ""flickr.machinetags.getPairs""; private static final String METHOD_GET_PREDICATES = ""flickr.machinetags.getPredicates""; private static final String METHOD_GET_VALUES = ""flickr.machinetags.getValues""; private static final String METHOD_GET_RECENTVALUES = ""flickr.machinetags.getRecentValues""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public MachinetagsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public NamespacesList<Namespace> getNamespaces(String predicate, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); NamespacesList<Namespace> nsList = new NamespacesList<Namespace>(); parameters.put(""method"", METHOD_GET_NAMESPACES); if (predicate != null) { parameters.put(""predicate"", predicate); } if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element nsElement = response.getPayload(); NodeList nsNodes = nsElement.getElementsByTagName(""namespace""); nsList.setPage(""1""); nsList.setPages(""1""); nsList.setPerPage("""" + nsNodes.getLength()); nsList.setTotal("""" + nsNodes.getLength()); for (int i = 0; i < nsNodes.getLength(); i++) { Element element = (Element) nsNodes.item(i); nsList.add(parseNamespace(element)); } return nsList; } public NamespacesList<Pair> getPairs(String namespace, String predicate, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); NamespacesList<Pair> nsList = new NamespacesList<Pair>(); parameters.put(""method"", METHOD_GET_PAIRS); if (namespace != null) { parameters.put(""namespace"", namespace); } if (predicate != null) { parameters.put(""predicate"", predicate); } if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element nsElement = response.getPayload(); NodeList nsNodes = nsElement.getElementsByTagName(""pair""); nsList.setPage(nsElement.getAttribute(""page"")); nsList.setPages(nsElement.getAttribute(""pages"")); nsList.setPerPage(nsElement.getAttribute(""perPage"")); nsList.setTotal("""" + nsNodes.getLength()); for (int i = 0; i < nsNodes.getLength(); i++) { Element element = (Element) nsNodes.item(i); nsList.add(parsePair(element)); } return nsList; } public NamespacesList<Predicate> getPredicates(String namespace, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); NamespacesList<Predicate> nsList = new NamespacesList<Predicate>(); parameters.put(""method"", METHOD_GET_PREDICATES); if (namespace != null) { parameters.put(""namespace"", namespace); } if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element nsElement = response.getPayload(); NodeList nsNodes = nsElement.getElementsByTagName(""predicate""); nsList.setPage(nsElement.getAttribute(""page"")); nsList.setPages(nsElement.getAttribute(""pages"")); nsList.setPerPage(nsElement.getAttribute(""perPage"")); nsList.setTotal("""" + nsNodes.getLength()); for (int i = 0; i < nsNodes.getLength(); i++) { Element element = (Element) nsNodes.item(i); nsList.add(parsePredicate(element)); } return nsList; } public NamespacesList<Value> getValues(String namespace, String predicate, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); NamespacesList<Value> valuesList = new NamespacesList<Value>(); parameters.put(""method"", METHOD_GET_VALUES); if (namespace != null) { parameters.put(""namespace"", namespace); } if (predicate != null) { parameters.put(""predicate"", predicate); } if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element nsElement = response.getPayload(); NodeList nsNodes = nsElement.getElementsByTagName(""value""); valuesList.setPage(nsElement.getAttribute(""page"")); valuesList.setPages(nsElement.getAttribute(""pages"")); valuesList.setPerPage(nsElement.getAttribute(""perPage"")); valuesList.setTotal("""" + nsNodes.getLength()); for (int i = 0; i < nsNodes.getLength(); i++) { Element element = (Element) nsNodes.item(i); Value value = parseValue(element); value.setNamespace(namespace); value.setPredicate(predicate); valuesList.add(value); } return valuesList; } public NamespacesList<Value> getRecentValues(String namespace, String predicate, Date addedSince) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); NamespacesList<Value> valuesList = new NamespacesList<Value>(); parameters.put(""method"", METHOD_GET_RECENTVALUES); if (namespace != null) { parameters.put(""namespace"", namespace); } if (predicate != null) { parameters.put(""predicate"", predicate); } if (addedSince != null) { parameters.put(""added_since"", Long.toString(addedSince.getTime() / 1000L)); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element nsElement = response.getPayload(); NodeList nsNodes = nsElement.getElementsByTagName(""value""); valuesList.setPage(nsElement.getAttribute(""page"")); valuesList.setPages(nsElement.getAttribute(""pages"")); valuesList.setPerPage(nsElement.getAttribute(""perPage"")); valuesList.setTotal("""" + nsNodes.getLength()); for (int i = 0; i < nsNodes.getLength(); i++) { Element element = (Element) nsNodes.item(i); valuesList.add(parseValue(element)); } return valuesList; } private Value parseValue(Element nsElement) { Value value = new Value(); value.setUsage(nsElement.getAttribute(""usage"")); value.setNamespace(nsElement.getAttribute(""namespace"")); value.setPredicate(nsElement.getAttribute(""predicate"")); value.setFirstAdded(nsElement.getAttribute(""first_added"")); value.setLastAdded(nsElement.getAttribute(""last_added"")); value.setValue(XMLUtilities.getValue(nsElement)); return value; } private Predicate parsePredicate(Element nsElement) { Predicate predicate = new Predicate(); predicate.setUsage(nsElement.getAttribute(""usage"")); predicate.setNamespaces(nsElement.getAttribute(""namespaces"")); predicate.setValue(XMLUtilities.getValue(nsElement)); return predicate; } private Namespace parseNamespace(Element nsElement) { Namespace ns = new Namespace(); ns.setUsage(nsElement.getAttribute(""usage"")); ns.setPredicates(nsElement.getAttribute(""predicates"")); ns.setValue(XMLUtilities.getValue(nsElement)); return ns; } private Pair parsePair(Element nsElement) { Pair pair = new Pair(); pair.setUsage(nsElement.getAttribute(""usage"")); pair.setNamespace(nsElement.getAttribute(""namespace"")); pair.setPredicate(nsElement.getAttribute(""predicate"")); return pair; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.machinetags; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.Date; import java.util.HashMap; import java.util.Map; public class MachinetagsInterface { private static final String METHOD_GET_NAMESPACES = ""flickr.machinetags.getNamespaces""; private static final String METHOD_GET_PAIRS = ""flickr.machinetags.getPairs""; private static final String METHOD_GET_PREDICATES = ""flickr.machinetags.getPredicates""; private static final String METHOD_GET_VALUES = ""flickr.machinetags.getValues""; private static final String METHOD_GET_RECENTVALUES = ""flickr.machinetags.getRecentValues""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public MachinetagsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public NamespacesList<Namespace> getNamespaces(String predicate, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); NamespacesList<Namespace> nsList = new NamespacesList<Namespace>(); parameters.put(""method"", METHOD_GET_NAMESPACES); if (predicate != null) { parameters.put(""predicate"", predicate); } if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element nsElement = response.getPayload(); NodeList nsNodes = nsElement.getElementsByTagName(""namespace""); nsList.setPage(""1""); nsList.setPages(""1""); nsList.setPerPage("""" + nsNodes.getLength()); nsList.setTotal("""" + nsNodes.getLength()); for (int i = 0; i < nsNodes.getLength(); i++) { Element element = (Element) nsNodes.item(i); nsList.add(parseNamespace(element)); } return nsList; } public NamespacesList<Pair> getPairs(String namespace, String predicate, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); NamespacesList<Pair> nsList = new NamespacesList<Pair>(); parameters.put(""method"", METHOD_GET_PAIRS); if (namespace != null) { parameters.put(""namespace"", namespace); } if (predicate != null) { parameters.put(""predicate"", predicate); } if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element nsElement = response.getPayload(); NodeList nsNodes = nsElement.getElementsByTagName(""pair""); nsList.setPage(nsElement.getAttribute(""page"")); nsList.setPages(nsElement.getAttribute(""pages"")); nsList.setPerPage(nsElement.getAttribute(""perPage"")); nsList.setTotal("""" + nsNodes.getLength()); for (int i = 0; i < nsNodes.getLength(); i++) { Element element = (Element) nsNodes.item(i); nsList.add(parsePair(element)); } return nsList; } public NamespacesList<Predicate> getPredicates(String namespace, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); NamespacesList<Predicate> nsList = new NamespacesList<Predicate>(); parameters.put(""method"", METHOD_GET_PREDICATES); if (namespace != null) { parameters.put(""namespace"", namespace); } if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element nsElement = response.getPayload(); NodeList nsNodes = nsElement.getElementsByTagName(""predicate""); nsList.setPage(nsElement.getAttribute(""page"")); nsList.setPages(nsElement.getAttribute(""pages"")); nsList.setPerPage(nsElement.getAttribute(""perPage"")); nsList.setTotal("""" + nsNodes.getLength()); for (int i = 0; i < nsNodes.getLength(); i++) { Element element = (Element) nsNodes.item(i); nsList.add(parsePredicate(element)); } return nsList; } public NamespacesList<Value> getValues(String namespace, String predicate, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); NamespacesList<Value> valuesList = new NamespacesList<Value>(); parameters.put(""method"", METHOD_GET_VALUES); if (namespace != null) { parameters.put(""namespace"", namespace); } if (predicate != null) { parameters.put(""predicate"", predicate); } if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element nsElement = response.getPayload(); NodeList nsNodes = nsElement.getElementsByTagName(""value""); valuesList.setPage(nsElement.getAttribute(""page"")); valuesList.setPages(nsElement.getAttribute(""pages"")); valuesList.setPerPage(nsElement.getAttribute(""perPage"")); valuesList.setTotal("""" + nsNodes.getLength()); for (int i = 0; i < nsNodes.getLength(); i++) { Element element = (Element) nsNodes.item(i); Value value = parseValue(element); value.setNamespace(namespace); value.setPredicate(predicate); valuesList.add(value); } return valuesList; } public NamespacesList<Value> getRecentValues(String namespace, String predicate, Date addedSince) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); NamespacesList<Value> valuesList = new NamespacesList<Value>(); parameters.put(""method"", METHOD_GET_RECENTVALUES); if (namespace != null) { parameters.put(""namespace"", namespace); } if (predicate != null) { parameters.put(""predicate"", predicate); } if (addedSince != null) { parameters.put(""added_since"", Long.toString(addedSince.getTime() / 1000L)); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element nsElement = response.getPayload(); NodeList nsNodes = nsElement.getElementsByTagName(""value""); valuesList.setPage(nsElement.getAttribute(""page"")); valuesList.setPages(nsElement.getAttribute(""pages"")); valuesList.setPerPage(nsElement.getAttribute(""perPage"")); valuesList.setTotal("""" + nsNodes.getLength()); for (int i = 0; i < nsNodes.getLength(); i++) { Element element = (Element) nsNodes.item(i); valuesList.add(parseValue(element)); } return valuesList; } private Value parseValue(Element nsElement) { Value value = new Value(); value.setUsage(nsElement.getAttribute(""usage"")); value.setNamespace(nsElement.getAttribute(""namespace"")); value.setPredicate(nsElement.getAttribute(""predicate"")); value.setFirstAdded(nsElement.getAttribute(""first_added"")); value.setLastAdded(nsElement.getAttribute(""last_added"")); value.setValue(XMLUtilities.getValue(nsElement)); return value; } private Predicate parsePredicate(Element nsElement) { Predicate predicate = new Predicate(); predicate.setUsage(nsElement.getAttribute(""usage"")); predicate.setNamespaces(nsElement.getAttribute(""namespaces"")); predicate.setValue(XMLUtilities.getValue(nsElement)); return predicate; } private Namespace parseNamespace(Element nsElement) { Namespace ns = new Namespace(); ns.setUsage(nsElement.getAttribute(""usage"")); ns.setPredicates(nsElement.getAttribute(""predicates"")); ns.setValue(XMLUtilities.getValue(nsElement)); return ns; } private Pair parsePair(Element nsElement) { Pair pair = new Pair(); pair.setUsage(nsElement.getAttribute(""usage"")); pair.setNamespace(nsElement.getAttribute(""namespace"")); pair.setPredicate(nsElement.getAttribute(""predicate"")); return pair; } } ","package com.flickr4java.flickr.machinetags;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.XMLUtilities;  import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import java.util.Date; import java.util.HashMap; import java.util.Map;  /**
 * A more precise way to tag and to search photos.
 * 
 * <h3>What are machine tags?</h3>
 * 
 * Machine tags are tags that use a special syntax to define extra information about a tag.<br>
 * 
 * Machine tags have a namespace, a predicate and a value. The namespace defines a class or a facet that a tag belongs to ('geo', 'flickr', etc.) The predicate
 * is name of the property for a namespace ('latitude', 'user', etc.) The value is, well, the value.<br>
 * 
 * Like tags, there are no rules for machine tags beyond the syntax to specify the parts of a machine tag. For example, you could tag a photo with:
 * <p>
 * 
 * <ul>
 * <li>flickr:user=straup</li>
 * <li>flora:tree=coniferous</li>
 * <li>medium:paint=oil</li>
 * <li>geo:quartier=""plateau mont royal""</li>
 * <li>geo:neighbourhood=geo:quartier</li>
 * </ul>
 * 
 * Flickr has already used machine tags, informally, on a couple of occasions:
 * 
 * <ul>
 * <li>When we launched Maps, we provided a way for people who had ""geotagged"" their photos to import their location data. This was done using the ""geo:lat=...""
 * and ""geo:lon=..."" tags.</li>
 * 
 * <li>When a user tags an event with an upcoming ID (for example : ""upcoming:event=81334"") we display a link back to the upcoming.org site. A similar example
 * is the excellent ""Flickr Upcoming Event"" greasemonkey script:
 * <p>
 * 
 * <a href=""https://web.archive.org/web/20131103192452/http://userscripts.org/scripts/show/5464"">Flickr Upcoming Event</a>
 * <p>
 * 
 * Dan Catt wrote a very good piece about machine tags - he called them ""triple tags"" - last year:
 * <p>
 * 
 * <a href=""https://web.archive.org/web/20080617093009/http://geobloggers.com:80/archives/2006/01/11/advanced-tagging-and-tripletags/"">Advanced Tagging and TripleTags</a>
 * <p>
 * 
 * Update : Dan's gone and written another excellent piece about all of this stuff now that we've launched machine tags:
 * 
 * <a href=""https://web.archive.org/web/20080621114435/http://geobloggers.com/archives/2007/01/24/offtopic-ish-flickr-ramps-up-triple-tag-support/"">Flickr Ramps up Triple Tag (Machine Tags) Support</a>
 * </li>
 * </ul>
 * <p>
 * 
 * <h3>What is the spec for machine tags?</h3>
 * 
 * Machine tags are divided in to three parts:
 * 
 * <ol>
 * <li>A ""namespace"":
 * <p>
 * 
 * Namespaces MUST begin with any character between a - z; remaining characters MAY be a - z, 0 - 9 and underbars. Namespaces are case-insensitive.</li>
 * 
 * <li>A ""predicate"":
 * <p>
 * 
 * Predicates MUST begin with any character between a - z; remaining characters MAY be a - z, 0 - 9 and underbars. Namespaces are case-insensitive.</li>
 * 
 * <li>A ""value"":
 * <p>
 * 
 * Values MAY contain any characters that a ""plain vanilla"" tags use. Values may also contain spaces but, like regular tags, they need to wrapped in quotes.</li>
 * </ol>
 * 
 * Namespace and predicates are separated by a colon : "":""
 * <p>
 * 
 * Predicates and values are separated by an equals symbol : ""=""
 * <p>
 * 
 * For example:
 * <p>
 * 
 * <ul>
 * <li>flickr:user=straup</li>
 * <li>geo:locality=""san francisco""</li>
 * </ul>
 * <p>
 * 
 * <h3>Why can't I use non-ASCII characters for namespaces and predicates?</h3>
 * 
 * Simple steps, first.
 * <p>
 * 
 * <h3>Can I define another machine tag as the value of a machine tag?</h3>
 * 
 * Sure, but it will not be processed as a machine tag itself.
 * 
 * <h3>How do I add machine tags?</h3>
 * 
 * By adding tags! No, really.
 * 
 * Machine tags are added *exactly* the same as any other tag whether it is done through the website or the API.
 * 
 * When the Flickr supercomputer processes your tags, we take a moment to check whether it is a machine tag. If it is we leverage the powerful Do What I Mean
 * engine to, well, do what you mean.
 * 
 * <h3>How do I query machine tags?</h3>
 * 
 * Via the API!
 * <p>
 * 
 * Specifically, using the ""machinetags"" parameter in the 'flickr.photos.search' method. Like tags, you can specify multiple machine tags as a comma separated
 * list.
 * 
 * 
 * <h3>Can I query the various part of a machine tag?</h3>
 * 
 * Yes. Aside from passing in a fully formed machine tag, there is a special syntax for searching on specific properties :
 * 
 * <ul>
 * <li>Find photos using the 'dc' namespace:
 * <p>
 * 
 * {""machine_tags"" =&gt; ""dc:""}</li>
 * 
 * <li>Find photos with a title in the 'dc' namespace:
 * <p>
 * 
 * {""machine_tags"" =&gt; ""dc:title=""}</li>
 * 
 * <li>Find photos titled ""mr. camera"" in the 'dc' namespace:
 * <p>
 * 
 * {""machine_tags"" =&gt; ""dc:title=\""mr. camera\""}</li>
 * 
 * <li>Find photos whose value is ""mr. camera"":
 * <p>
 * 
 * {""machine_tags"" =&gt; ""*:*=\""mr. camera\""""}</li>
 * 
 * <li>Find photos that have a title, in any namespace:
 * <p>
 * 
 * {""machine_tags"" =&gt; ""*:title=""}</li>
 * 
 * <li>Find photos that have a title, in any namespace, whose value is ""mr. camera"":
 * <p>
 * 
 * {""machine_tags"" =&gt; ""*:title=\""mr. camera\""""}</li>
 * 
 * <li>Find photos, in the 'dc' namespace whose value is ""mr. camera"":
 * <p>
 * 
 * {""machine_tags"" =&gt; ""dc:*=\""mr. camera\""""}</li>
 * </ul>
 * 
 * <h3>Is there a limit to the number of machine tags I can query?</h3>
 * 
 * Yes. The limit depends on the tag mode (ALL or ANY) that you are querying with. ""ALL"" (AND) queries are limited to (16) machine tags. ""ANY"" (OR) queries are
 * limited to (8).
 * 
 * <h3>Can I do range queries on machine tags?</h3>
 * 
 * No. Not yet, anyway.
 * <p>
 * 
 * It is a hard problem for reasons far too dull to get in to here. It's on the list.
 * 
 * <h3>Are machine tag namespaces reserved?</h3>
 * 
 * No. Anyone can use a namespace for anything they want.
 * <p>
 * 
 * If you are concerned about colliding namespaces you should consider adding an additional machine tag to define your namespace. For example:
 * <p>
 * 
 * <pre>
 * dc:subject=tags
 * xmlns:dc=http://purl.org/dc/elements/1.1/
 * </pre>
 * 
 * Like tags, in general, we expect (hope?) that the community will develop its own standards by consensus over time.
 * 
 * <h3>What about all the machine tags that are already in the Flickr database?</h3>
 * 
 * At the moment, they are still treated as plain old tags.
 * <p>
 * 
 * We have plans to go back and re-import them as machine tags but for now, only new tags will be processed as machine tags.
 * <p>
 * 
 * In the meantime, if you re-save a machine from the 'edit this tag' page it will be re-imported as a machine tag.
 * 
 * <h3>Is the predicate *really* a predicate?</h3>
 * 
 * You are in a dark cave. In the corner is a fire and a man making bunny shadows on the wall with his hands. Whether or not it's really a 'predicate' depends
 * on how much time you spend on the semantic-web mailing list. ;-)
 * <p>
 * 
 * It's close enough to being a predicate that it makes for a good short-hand.
 * 
 * <h3>Wait, aren't machine tags just RDF?</h3>
 * 
 * No, machine tags are not RDF; they could play RDF on television, though.
 * <p>
 * 
 * See also:
 * 
 * <a href=""https://web.archive.org/web/20110716015005/http://weblog.scifihifi.com/2005/08/05/meta-tags-the-poor-mans-rdf/"">Meta Tags: The Poor Man’s RDF?</a>
 * 
 * <h3>Huh, what is RDF?</h3>
 * 
 * RDF Describes Flickr. That's really all you need to know about RDF.
 * 
 * @author mago
 * @version $Id: MachinetagsInterface.java,v 1.3 2009/07/11 20:30:27 x-mago Exp $
 * @see <a href=""http://code.flickr.com/blog/2008/07/18/wildcard-machine-tag-urls/"">http://code.flickr.com/blog/2008/07/18/wildcard-machine-tag-urls/</a>
 * @see <a
 *      href=""http://code.flickr.com/blog/2008/08/28/machine-tags-lastfm-and-rocknroll/"">http://code.flickr.com/blog/2008/08/28/machine-tags-lastfm-and-rocknroll/</a>
 * @see <a href=""http://blech.vox.com/library/post/flickr-exif-machine-tags.html"">http://blech.vox.com/library/post/flickr-exif-machine-tags.html</a>
 * @see <a href=""http://husk.org/code/machine-tag-browser.html"">machine-tag-browser</a>
 */ public class MachinetagsInterface { private static final String METHOD_GET_NAMESPACES = ""flickr.machinetags.getNamespaces"";  private static final String METHOD_GET_PAIRS = ""flickr.machinetags.getPairs"";  private static final String METHOD_GET_PREDICATES = ""flickr.machinetags.getPredicates"";  private static final String METHOD_GET_VALUES = ""flickr.machinetags.getValues"";  private static final String METHOD_GET_RECENTVALUES = ""flickr.machinetags.getRecentValues"";  private final String apiKey;  private final String sharedSecret;  private final Transport transportAPI;  public MachinetagsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; }  /**
     * Return a list of unique namespaces, optionally limited by a given predicate, in alphabetical order.
     * 
     * This method does not require authentication.
     * 
     * @param predicate
     * @param perPage
     * @param page
     * @return NamespacesList
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public NamespacesList<Namespace> getNamespaces(String predicate, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); NamespacesList<Namespace> nsList = new NamespacesList<Namespace>(); parameters.put(""method"", METHOD_GET_NAMESPACES);  if (predicate != null) { parameters.put(""predicate"", predicate); } if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element nsElement = response.getPayload(); NodeList nsNodes = nsElement.getElementsByTagName(""namespace""); nsList.setPage(""1""); nsList.setPages(""1""); nsList.setPerPage("""" + nsNodes.getLength()); nsList.setTotal("""" + nsNodes.getLength()); for (int i = 0; i < nsNodes.getLength(); i++) { Element element = (Element) nsNodes.item(i); nsList.add(parseNamespace(element)); } return nsList; }  /**
     * Return a list of unique namespace and predicate pairs, optionally limited by predicate or namespace, in alphabetical order.
     * 
     * This method does not require authentication.
     * 
     * @param namespace
     *            optional, can be null
     * @param predicate
     *            optional, can be null
     * @param perPage
     *            The number of photos to show per page
     * @param page
     *            The page offset
     * @return NamespacesList containing Pair-objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public NamespacesList<Pair> getPairs(String namespace, String predicate, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); NamespacesList<Pair> nsList = new NamespacesList<Pair>(); parameters.put(""method"", METHOD_GET_PAIRS);  if (namespace != null) { parameters.put(""namespace"", namespace); } if (predicate != null) { parameters.put(""predicate"", predicate); } if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element nsElement = response.getPayload(); NodeList nsNodes = nsElement.getElementsByTagName(""pair""); nsList.setPage(nsElement.getAttribute(""page"")); nsList.setPages(nsElement.getAttribute(""pages"")); nsList.setPerPage(nsElement.getAttribute(""perPage"")); nsList.setTotal("""" + nsNodes.getLength()); for (int i = 0; i < nsNodes.getLength(); i++) { Element element = (Element) nsNodes.item(i); nsList.add(parsePair(element)); } return nsList; }  /**
     * Return a list of unique predicates, optionally limited by a given namespace.
     * 
     * This method does not require authentication.
     * 
     * @param namespace
     *            The namespace that all values should be restricted to.
     * @param perPage
     *            The number of photos to show per page
     * @param page
     *            The page offset
     * @return NamespacesList containing Predicate
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public NamespacesList<Predicate> getPredicates(String namespace, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); NamespacesList<Predicate> nsList = new NamespacesList<Predicate>(); parameters.put(""method"", METHOD_GET_PREDICATES);  if (namespace != null) { parameters.put(""namespace"", namespace); } if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element nsElement = response.getPayload(); NodeList nsNodes = nsElement.getElementsByTagName(""predicate""); nsList.setPage(nsElement.getAttribute(""page"")); nsList.setPages(nsElement.getAttribute(""pages"")); nsList.setPerPage(nsElement.getAttribute(""perPage"")); nsList.setTotal("""" + nsNodes.getLength()); for (int i = 0; i < nsNodes.getLength(); i++) { Element element = (Element) nsNodes.item(i); nsList.add(parsePredicate(element)); } return nsList; }  /**
     * Return a list of unique values for a namespace and predicate.
     * 
     * This method does not require authentication.
     * 
     * @param namespace
     *            The namespace that all values should be restricted to.
     * @param predicate
     *            The predicate that all values should be restricted to.
     * @param perPage
     *            The number of photos to show per page
     * @param page
     *            The page offset
     * @return NamespacesList
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public NamespacesList<Value> getValues(String namespace, String predicate, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); NamespacesList<Value> valuesList = new NamespacesList<Value>(); parameters.put(""method"", METHOD_GET_VALUES);  if (namespace != null) { parameters.put(""namespace"", namespace); } if (predicate != null) { parameters.put(""predicate"", predicate); } if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element nsElement = response.getPayload(); NodeList nsNodes = nsElement.getElementsByTagName(""value""); valuesList.setPage(nsElement.getAttribute(""page"")); valuesList.setPages(nsElement.getAttribute(""pages"")); valuesList.setPerPage(nsElement.getAttribute(""perPage"")); valuesList.setTotal("""" + nsNodes.getLength()); for (int i = 0; i < nsNodes.getLength(); i++) { Element element = (Element) nsNodes.item(i); Value value = parseValue(element); value.setNamespace(namespace); value.setPredicate(predicate); valuesList.add(value); } return valuesList; }  /**
     * Fetch recently used (or created) machine tags values.
     * 
     * This method does not require authentication.
     * 
     * @param namespace
     *            The namespace that all values should be restricted to.
     * @param predicate
     *            The predicate that all values should be restricted to.
     * @param addedSince
     *            Only return machine tags values that have been added since this Date.
     * @return NamespacesList
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public NamespacesList<Value> getRecentValues(String namespace, String predicate, Date addedSince) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); NamespacesList<Value> valuesList = new NamespacesList<Value>(); parameters.put(""method"", METHOD_GET_RECENTVALUES);  if (namespace != null) { parameters.put(""namespace"", namespace); } if (predicate != null) { parameters.put(""predicate"", predicate); } if (addedSince != null) { parameters.put(""added_since"", Long.toString(addedSince.getTime() / 1000L)); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element nsElement = response.getPayload(); NodeList nsNodes = nsElement.getElementsByTagName(""value""); valuesList.setPage(nsElement.getAttribute(""page"")); valuesList.setPages(nsElement.getAttribute(""pages"")); valuesList.setPerPage(nsElement.getAttribute(""perPage"")); valuesList.setTotal("""" + nsNodes.getLength()); for (int i = 0; i < nsNodes.getLength(); i++) { Element element = (Element) nsNodes.item(i); valuesList.add(parseValue(element)); } return valuesList; }  private Value parseValue(Element nsElement) { Value value = new Value(); value.setUsage(nsElement.getAttribute(""usage"")); value.setNamespace(nsElement.getAttribute(""namespace"")); value.setPredicate(nsElement.getAttribute(""predicate"")); value.setFirstAdded(nsElement.getAttribute(""first_added"")); value.setLastAdded(nsElement.getAttribute(""last_added"")); value.setValue(XMLUtilities.getValue(nsElement)); return value; }  private Predicate parsePredicate(Element nsElement) { Predicate predicate = new Predicate(); predicate.setUsage(nsElement.getAttribute(""usage"")); predicate.setNamespaces(nsElement.getAttribute(""namespaces"")); predicate.setValue(XMLUtilities.getValue(nsElement)); return predicate; }  private Namespace parseNamespace(Element nsElement) { Namespace ns = new Namespace(); ns.setUsage(nsElement.getAttribute(""usage"")); ns.setPredicates(nsElement.getAttribute(""predicates"")); ns.setValue(XMLUtilities.getValue(nsElement)); return ns; }  private Pair parsePair(Element nsElement) { Pair pair = new Pair(); pair.setUsage(nsElement.getAttribute(""usage"")); pair.setNamespace(nsElement.getAttribute(""namespace"")); pair.setPredicate(nsElement.getAttribute(""predicate"")); return pair; } }  "
src/main/java/com/flickr4java/flickr/machinetags/Namespace.java,"package com.flickr4java.flickr.machinetags;

/**
 * 
 * @author mago
 * @version $Id: Namespace.java,v 1.2 2009/07/12 22:43:07 x-mago Exp $
 */
public class Namespace {

    private int usage;

    private int predicates;

    private String value;

    public Namespace() {
    }

    public int getUsage() {
        return usage;
    }

    public void setUsage(String usage) {
        try {
            setUsage(Integer.parseInt(usage));
        } catch (NumberFormatException e) {
        }
    }

    public void setUsage(int usage) {
        this.usage = usage;
    }

    /**
     * Count of distinct predicates a namespace has.
     * 
     * @return Number of predicates
     */
    public int getPredicates() {
        return predicates;
    }

    public void setPredicates(String predicates) {
        try {
            setPredicates(Integer.parseInt(predicates));
        } catch (NumberFormatException e) {
        }
    }

    public void setPredicates(int predicates) {
        this.predicates = predicates;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }
}
",package com.flickr4java.flickr.machinetags; public class Namespace { private int usage; private int predicates; private String value; public Namespace() { } public int getUsage() { return usage; } public void setUsage(String usage) { try { setUsage(Integer.parseInt(usage)); } catch (NumberFormatException e) { } } public void setUsage(int usage) { this.usage = usage; } public int getPredicates() { return predicates; } public void setPredicates(String predicates) { try { setPredicates(Integer.parseInt(predicates)); } catch (NumberFormatException e) { } } public void setPredicates(int predicates) { this.predicates = predicates; } public String getValue() { return value; } public void setValue(String value) { this.value = value; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.machinetags; public class Namespace { private int usage; private int predicates; private String value; public Namespace() { } public int getUsage() { return usage; } public void setUsage(String usage) { try { setUsage(Integer.parseInt(usage)); } catch (NumberFormatException e) { } } public void setUsage(int usage) { this.usage = usage; } public int getPredicates() { return predicates; } public void setPredicates(String predicates) { try { setPredicates(Integer.parseInt(predicates)); } catch (NumberFormatException e) { } } public void setPredicates(int predicates) { this.predicates = predicates; } public String getValue() { return value; } public void setValue(String value) { this.value = value; } } ,"package com.flickr4java.flickr.machinetags;  /**
 * 
 * @author mago
 * @version $Id: Namespace.java,v 1.2 2009/07/12 22:43:07 x-mago Exp $
 */ public class Namespace {  private int usage;  private int predicates;  private String value;  public Namespace() { }  public int getUsage() { return usage; }  public void setUsage(String usage) { try { setUsage(Integer.parseInt(usage)); } catch (NumberFormatException e) { } }  public void setUsage(int usage) { this.usage = usage; }  /**
     * Count of distinct predicates a namespace has.
     * 
     * @return Number of predicates
     */ public int getPredicates() { return predicates; }  public void setPredicates(String predicates) { try { setPredicates(Integer.parseInt(predicates)); } catch (NumberFormatException e) { } }  public void setPredicates(int predicates) { this.predicates = predicates; }  public String getValue() { return value; }  public void setValue(String value) { this.value = value; } }  "
src/main/java/com/flickr4java/flickr/machinetags/NamespacesList.java,"package com.flickr4java.flickr.machinetags;

import com.flickr4java.flickr.SearchResultList;

/**
 * 
 * @author mago
 * @version $Id: NamespacesList.java,v 1.2 2009/07/12 22:43:07 x-mago Exp $
 */
public class NamespacesList<E> extends SearchResultList<E> {
    private static final long serialVersionUID = 12L;
}
",package com.flickr4java.flickr.machinetags; import com.flickr4java.flickr.SearchResultList; public class NamespacesList<E> extends SearchResultList<E> { private static final long serialVersionUID = 12L; },0 0 0 0 0 0,package com.flickr4java.flickr.machinetags; import com.flickr4java.flickr.SearchResultList; public class NamespacesList<E> extends SearchResultList<E> { private static final long serialVersionUID = 12L; } ,"package com.flickr4java.flickr.machinetags;  import com.flickr4java.flickr.SearchResultList;  /**
 * 
 * @author mago
 * @version $Id: NamespacesList.java,v 1.2 2009/07/12 22:43:07 x-mago Exp $
 */ public class NamespacesList<E> extends SearchResultList<E> { private static final long serialVersionUID = 12L; }  "
src/main/java/com/flickr4java/flickr/machinetags/Pair.java,"package com.flickr4java.flickr.machinetags;

/**
 * 
 * @author mago
 * @version $Id: Pair.java,v 1.2 2009/07/12 22:43:07 x-mago Exp $
 */
public class Pair {

    String namespace;

    String predicate;

    int usage;

    public String getNamespace() {
        return namespace;
    }

    public void setNamespace(String namespace) {
        this.namespace = namespace;
    }

    public String getPredicate() {
        return predicate;
    }

    public void setPredicate(String predicate) {
        this.predicate = predicate;
    }

    public int getUsage() {
        return usage;
    }

    public void setUsage(String predicates) {
        try {
            setUsage(Integer.parseInt(predicates));
        } catch (NumberFormatException e) {
        }
    }

    public void setUsage(int usage) {
        this.usage = usage;
    }

    public String getValue() {
        return namespace + "":"" + predicate;
    }
}
","package com.flickr4java.flickr.machinetags; public class Pair { String namespace; String predicate; int usage; public String getNamespace() { return namespace; } public void setNamespace(String namespace) { this.namespace = namespace; } public String getPredicate() { return predicate; } public void setPredicate(String predicate) { this.predicate = predicate; } public int getUsage() { return usage; } public void setUsage(String predicates) { try { setUsage(Integer.parseInt(predicates)); } catch (NumberFormatException e) { } } public void setUsage(int usage) { this.usage = usage; } public String getValue() { return namespace + "":"" + predicate; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.machinetags; public class Pair { String namespace; String predicate; int usage; public String getNamespace() { return namespace; } public void setNamespace(String namespace) { this.namespace = namespace; } public String getPredicate() { return predicate; } public void setPredicate(String predicate) { this.predicate = predicate; } public int getUsage() { return usage; } public void setUsage(String predicates) { try { setUsage(Integer.parseInt(predicates)); } catch (NumberFormatException e) { } } public void setUsage(int usage) { this.usage = usage; } public String getValue() { return namespace + "":"" + predicate; } } ","package com.flickr4java.flickr.machinetags;  /**
 * 
 * @author mago
 * @version $Id: Pair.java,v 1.2 2009/07/12 22:43:07 x-mago Exp $
 */ public class Pair {  String namespace;  String predicate;  int usage;  public String getNamespace() { return namespace; }  public void setNamespace(String namespace) { this.namespace = namespace; }  public String getPredicate() { return predicate; }  public void setPredicate(String predicate) { this.predicate = predicate; }  public int getUsage() { return usage; }  public void setUsage(String predicates) { try { setUsage(Integer.parseInt(predicates)); } catch (NumberFormatException e) { } }  public void setUsage(int usage) { this.usage = usage; }  public String getValue() { return namespace + "":"" + predicate; } }  "
src/main/java/com/flickr4java/flickr/machinetags/Predicate.java,"package com.flickr4java.flickr.machinetags;

/**
 * 
 * @author mago
 * @version $Id: Predicate.java,v 1.2 2009/07/12 22:43:07 x-mago Exp $
 */
public class Predicate {

    int usage;

    int namespaces;

    String value;

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public int getUsage() {
        return usage;
    }

    public void setUsage(String predicates) {
        try {
            setUsage(Integer.parseInt(predicates));
        } catch (NumberFormatException e) {
        }
    }

    public void setUsage(int usage) {
        this.usage = usage;
    }

    public int getNamespaces() {
        return namespaces;
    }

    public void setNamespaces(String namespaces) {
        try {
            setNamespaces(Integer.parseInt(namespaces));
        } catch (NumberFormatException e) {
        }
    }

    public void setNamespaces(int namespaces) {
        this.namespaces = namespaces;
    }

}
",package com.flickr4java.flickr.machinetags; public class Predicate { int usage; int namespaces; String value; public String getValue() { return value; } public void setValue(String value) { this.value = value; } public int getUsage() { return usage; } public void setUsage(String predicates) { try { setUsage(Integer.parseInt(predicates)); } catch (NumberFormatException e) { } } public void setUsage(int usage) { this.usage = usage; } public int getNamespaces() { return namespaces; } public void setNamespaces(String namespaces) { try { setNamespaces(Integer.parseInt(namespaces)); } catch (NumberFormatException e) { } } public void setNamespaces(int namespaces) { this.namespaces = namespaces; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.machinetags; public class Predicate { int usage; int namespaces; String value; public String getValue() { return value; } public void setValue(String value) { this.value = value; } public int getUsage() { return usage; } public void setUsage(String predicates) { try { setUsage(Integer.parseInt(predicates)); } catch (NumberFormatException e) { } } public void setUsage(int usage) { this.usage = usage; } public int getNamespaces() { return namespaces; } public void setNamespaces(String namespaces) { try { setNamespaces(Integer.parseInt(namespaces)); } catch (NumberFormatException e) { } } public void setNamespaces(int namespaces) { this.namespaces = namespaces; } } ,"package com.flickr4java.flickr.machinetags;  /**
 * 
 * @author mago
 * @version $Id: Predicate.java,v 1.2 2009/07/12 22:43:07 x-mago Exp $
 */ public class Predicate {  int usage;  int namespaces;  String value;  public String getValue() { return value; }  public void setValue(String value) { this.value = value; }  public int getUsage() { return usage; }  public void setUsage(String predicates) { try { setUsage(Integer.parseInt(predicates)); } catch (NumberFormatException e) { } }  public void setUsage(int usage) { this.usage = usage; }  public int getNamespaces() { return namespaces; }  public void setNamespaces(String namespaces) { try { setNamespaces(Integer.parseInt(namespaces)); } catch (NumberFormatException e) { } }  public void setNamespaces(int namespaces) { this.namespaces = namespaces; }  }  "
src/main/java/com/flickr4java/flickr/machinetags/Value.java,"package com.flickr4java.flickr.machinetags;

import java.util.Date;

/**
 * 
 * @author mago
 * @version $Id: Value.java,v 1.3 2009/07/12 22:43:07 x-mago Exp $
 */
public class Value {

    String value;

    int usage;

    String namespace;

    String predicate;

    Date firstAdded;

    Date lastAdded;

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public int getUsage() {
        return usage;
    }

    public String getNamespace() {
        return namespace;
    }

    public void setNamespace(String namespace) {
        this.namespace = namespace;
    }

    public String getPredicate() {
        return predicate;
    }

    public void setPredicate(String predicate) {
        this.predicate = predicate;
    }

    public void setFirstAdded(Date date) {
        firstAdded = date;
    }

    public void setFirstAdded(long datePosted) {
        setFirstAdded(new Date(datePosted));
    }

    public void setFirstAdded(String timestamp) {
        if (timestamp == null || """".equals(timestamp))
            return;
        setFirstAdded(Long.parseLong(timestamp) * 1000);
    }

    public void setLastAdded(Date date) {
        lastAdded = date;
    }

    public void setLastAdded(long date) {
        setLastAdded(new Date(date));
    }

    public void setLastAdded(String timestamp) {
        if (timestamp == null || """".equals(timestamp))
            return;
        setLastAdded(Long.parseLong(timestamp) * 1000);
    }

    public void setUsage(String predicates) {
        try {
            setUsage(Integer.parseInt(predicates));
        } catch (NumberFormatException e) {
        }
    }

    public void setUsage(int usage) {
        this.usage = usage;
    }

    @Override
    public String toString() {

        return String.format(""%s:%s=%s"", namespace, predicate, value);
    }
}
","package com.flickr4java.flickr.machinetags; import java.util.Date; public class Value { String value; int usage; String namespace; String predicate; Date firstAdded; Date lastAdded; public String getValue() { return value; } public void setValue(String value) { this.value = value; } public int getUsage() { return usage; } public String getNamespace() { return namespace; } public void setNamespace(String namespace) { this.namespace = namespace; } public String getPredicate() { return predicate; } public void setPredicate(String predicate) { this.predicate = predicate; } public void setFirstAdded(Date date) { firstAdded = date; } public void setFirstAdded(long datePosted) { setFirstAdded(new Date(datePosted)); } public void setFirstAdded(String timestamp) { if (timestamp == null || """".equals(timestamp))
            return; setFirstAdded(Long.parseLong(timestamp) * 1000); } public void setLastAdded(Date date) { lastAdded = date; } public void setLastAdded(long date) { setLastAdded(new Date(date)); } public void setLastAdded(String timestamp) { if (timestamp == null || """".equals(timestamp))
            return; setLastAdded(Long.parseLong(timestamp) * 1000); } public void setUsage(String predicates) { try { setUsage(Integer.parseInt(predicates)); } catch (NumberFormatException e) { } } public void setUsage(int usage) { this.usage = usage; } @Override
    public String toString() { return String.format(""%s:%s=%s"", namespace, predicate, value); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.machinetags; import java.util.Date; public class Value { String value; int usage; String namespace; String predicate; Date firstAdded; Date lastAdded; public String getValue() { return value; } public void setValue(String value) { this.value = value; } public int getUsage() { return usage; } public String getNamespace() { return namespace; } public void setNamespace(String namespace) { this.namespace = namespace; } public String getPredicate() { return predicate; } public void setPredicate(String predicate) { this.predicate = predicate; } public void setFirstAdded(Date date) { firstAdded = date; } public void setFirstAdded(long datePosted) { setFirstAdded(new Date(datePosted)); } public void setFirstAdded(String timestamp) { if (timestamp == null || """".equals(timestamp))
            return; setFirstAdded(Long.parseLong(timestamp) * 1000); } public void setLastAdded(Date date) { lastAdded = date; } public void setLastAdded(long date) { setLastAdded(new Date(date)); } public void setLastAdded(String timestamp) { if (timestamp == null || """".equals(timestamp))
            return; setLastAdded(Long.parseLong(timestamp) * 1000); } public void setUsage(String predicates) { try { setUsage(Integer.parseInt(predicates)); } catch (NumberFormatException e) { } } public void setUsage(int usage) { this.usage = usage; } @Override
    public String toString() { return String.format(""%s:%s=%s"", namespace, predicate, value); } } ","package com.flickr4java.flickr.machinetags;  import java.util.Date;  /**
 * 
 * @author mago
 * @version $Id: Value.java,v 1.3 2009/07/12 22:43:07 x-mago Exp $
 */ public class Value {  String value;  int usage;  String namespace;  String predicate;  Date firstAdded;  Date lastAdded;  public String getValue() { return value; }  public void setValue(String value) { this.value = value; }  public int getUsage() { return usage; }  public String getNamespace() { return namespace; }  public void setNamespace(String namespace) { this.namespace = namespace; }  public String getPredicate() { return predicate; }  public void setPredicate(String predicate) { this.predicate = predicate; }  public void setFirstAdded(Date date) { firstAdded = date; }  public void setFirstAdded(long datePosted) { setFirstAdded(new Date(datePosted)); }  public void setFirstAdded(String timestamp) { if (timestamp == null || """".equals(timestamp))
            return; setFirstAdded(Long.parseLong(timestamp) * 1000); }  public void setLastAdded(Date date) { lastAdded = date; }  public void setLastAdded(long date) { setLastAdded(new Date(date)); }  public void setLastAdded(String timestamp) { if (timestamp == null || """".equals(timestamp))
            return; setLastAdded(Long.parseLong(timestamp) * 1000); }  public void setUsage(String predicates) { try { setUsage(Integer.parseInt(predicates)); } catch (NumberFormatException e) { } }  public void setUsage(int usage) { this.usage = usage; }  @Override
    public String toString() {  return String.format(""%s:%s=%s"", namespace, predicate, value); } }  "
src/main/java/com/flickr4java/flickr/panda/Panda.java,"package com.flickr4java.flickr.panda;

/**
 * Holds the name of a panda.
 * 
 * @author mago
 * @version $Id: Panda.java,v 1.3 2009/07/12 22:43:07 x-mago Exp $
 * @see com.flickr4java.flickr.panda.PandaInterface#getPhotos(Panda, java.util.Set, int, int)
 */
public class Panda {

    String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
",package com.flickr4java.flickr.panda; public class Panda { String name; public String getName() { return name; } public void setName(String name) { this.name = name; } },0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.panda; public class Panda { String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } ,"package com.flickr4java.flickr.panda;  /**
 * Holds the name of a panda.
 * 
 * @author mago
 * @version $Id: Panda.java,v 1.3 2009/07/12 22:43:07 x-mago Exp $
 * @see com.flickr4java.flickr.panda.PandaInterface#getPhotos(Panda, java.util.Set, int, int)
 */ public class Panda {  String name;  public String getName() { return name; }  public void setName(String name) { this.name = name; } }  "
src/main/java/com/flickr4java/flickr/panda/PandaInterface.java,"package com.flickr4java.flickr.panda;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoList;
import com.flickr4java.flickr.photos.PhotoUtils;
import com.flickr4java.flickr.util.StringUtilities;
import com.flickr4java.flickr.util.XMLUtilities;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * Flickr Panda.
 * 
 * @author mago
 * @version $Id: PandaInterface.java,v 1.3 2009/07/11 20:30:27 x-mago Exp $
 * @see <a href=""http://www.flickr.com/explore/panda"">Flickr Panda</a>
 */
public class PandaInterface {
    private static final String METHOD_GET_PHOTOS = ""flickr.panda.getPhotos"";

    private static final String METHOD_GET_LIST = ""flickr.panda.getList"";

    private String apiKey;

    private String sharedSecret;

    private Transport transportAPI;

    public PandaInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transportAPI;
    }

    /**
     * Return a list of Flickr pandas, from whom you can request photos using the
     * {@link com.flickr4java.flickr.panda.PandaInterface#getPhotos(Panda, Set, int, int)} API method.
     * 
     * This method does not require authentication.
     * 
     * @return A list of pandas
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public ArrayList<Panda> getList() throws FlickrException {
        ArrayList<Panda> pandas = new ArrayList<Panda>();
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_LIST);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element pandaElement = response.getPayload();
        NodeList pandaNodes = pandaElement.getElementsByTagName(""panda"");
        for (int i = 0; i < pandaNodes.getLength(); i++) {
            pandaElement = (Element) pandaNodes.item(i);
            Panda panda = new Panda();
            panda.setName(XMLUtilities.getValue(pandaElement));
            pandas.add(panda);
        }
        return pandas;
    }

    /**
     * Ask the Flickr Pandas for a list of recent public (and ""safe"") photos.
     * 
     * This method does not require authentication.
     * 
     * @param panda
     *            The panda to ask for photos from.
     * @param extras
     *            A set of Strings controlling the extra information to fetch for each returned record. {@link com.flickr4java.flickr.photos.Extras#ALL_EXTRAS}
     * @param perPage
     *            The number of photos to show per page
     * @param page
     *            The page offset
     * @return A PhotoList
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see com.flickr4java.flickr.photos.Extras
     */
    public PhotoList<Photo> getPhotos(Panda panda, Set<String> extras, int perPage, int page) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_PHOTOS);

        parameters.put(""panda_name"", panda.getName());

        if (extras != null && !extras.isEmpty()) {
            parameters.put(""extras"", StringUtilities.join(extras, "",""));
        }
        if (perPage > 0) {
            parameters.put(""per_page"", Integer.toString(perPage));
        }
        if (page > 0) {
            parameters.put(""page"", Integer.toString(page));
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element photosElement = response.getPayload();
        PhotoList<Photo> photos = PhotoUtils.createPhotoList(photosElement);
        return photos;
    }
}
","package com.flickr4java.flickr.panda; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.util.StringUtilities; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.ArrayList; import java.util.HashMap; import java.util.Map; import java.util.Set; public class PandaInterface { private static final String METHOD_GET_PHOTOS = ""flickr.panda.getPhotos""; private static final String METHOD_GET_LIST = ""flickr.panda.getList""; private String apiKey; private String sharedSecret; private Transport transportAPI; public PandaInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public ArrayList<Panda> getList() throws FlickrException { ArrayList<Panda> pandas = new ArrayList<Panda>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element pandaElement = response.getPayload(); NodeList pandaNodes = pandaElement.getElementsByTagName(""panda""); for (int i = 0; i < pandaNodes.getLength(); i++) { pandaElement = (Element) pandaNodes.item(i); Panda panda = new Panda(); panda.setName(XMLUtilities.getValue(pandaElement)); pandas.add(panda); } return pandas; } public PhotoList<Photo> getPhotos(Panda panda, Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PHOTOS); parameters.put(""panda_name"", panda.getName()); if (extras != null && !extras.isEmpty()) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); PhotoList<Photo> photos = PhotoUtils.createPhotoList(photosElement); return photos; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.panda; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.util.StringUtilities; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.ArrayList; import java.util.HashMap; import java.util.Map; import java.util.Set; public class PandaInterface { private static final String METHOD_GET_PHOTOS = ""flickr.panda.getPhotos""; private static final String METHOD_GET_LIST = ""flickr.panda.getList""; private String apiKey; private String sharedSecret; private Transport transportAPI; public PandaInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public ArrayList<Panda> getList() throws FlickrException { ArrayList<Panda> pandas = new ArrayList<Panda>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element pandaElement = response.getPayload(); NodeList pandaNodes = pandaElement.getElementsByTagName(""panda""); for (int i = 0; i < pandaNodes.getLength(); i++) { pandaElement = (Element) pandaNodes.item(i); Panda panda = new Panda(); panda.setName(XMLUtilities.getValue(pandaElement)); pandas.add(panda); } return pandas; } public PhotoList<Photo> getPhotos(Panda panda, Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PHOTOS); parameters.put(""panda_name"", panda.getName()); if (extras != null && !extras.isEmpty()) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); PhotoList<Photo> photos = PhotoUtils.createPhotoList(photosElement); return photos; } } ","package com.flickr4java.flickr.panda;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.util.StringUtilities; import com.flickr4java.flickr.util.XMLUtilities;  import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import java.util.ArrayList; import java.util.HashMap; import java.util.Map; import java.util.Set;  /**
 * Flickr Panda.
 * 
 * @author mago
 * @version $Id: PandaInterface.java,v 1.3 2009/07/11 20:30:27 x-mago Exp $
 * @see <a href=""http://www.flickr.com/explore/panda"">Flickr Panda</a>
 */ public class PandaInterface { private static final String METHOD_GET_PHOTOS = ""flickr.panda.getPhotos"";  private static final String METHOD_GET_LIST = ""flickr.panda.getList"";  private String apiKey;  private String sharedSecret;  private Transport transportAPI;  public PandaInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; }  /**
     * Return a list of Flickr pandas, from whom you can request photos using the
     * {@link com.flickr4java.flickr.panda.PandaInterface#getPhotos(Panda, Set, int, int)} API method.
     * 
     * This method does not require authentication.
     * 
     * @return A list of pandas
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public ArrayList<Panda> getList() throws FlickrException { ArrayList<Panda> pandas = new ArrayList<Panda>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element pandaElement = response.getPayload(); NodeList pandaNodes = pandaElement.getElementsByTagName(""panda""); for (int i = 0; i < pandaNodes.getLength(); i++) { pandaElement = (Element) pandaNodes.item(i); Panda panda = new Panda(); panda.setName(XMLUtilities.getValue(pandaElement)); pandas.add(panda); } return pandas; }  /**
     * Ask the Flickr Pandas for a list of recent public (and ""safe"") photos.
     * 
     * This method does not require authentication.
     * 
     * @param panda
     *            The panda to ask for photos from.
     * @param extras
     *            A set of Strings controlling the extra information to fetch for each returned record. {@link com.flickr4java.flickr.photos.Extras#ALL_EXTRAS}
     * @param perPage
     *            The number of photos to show per page
     * @param page
     *            The page offset
     * @return A PhotoList
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see com.flickr4java.flickr.photos.Extras
     */ public PhotoList<Photo> getPhotos(Panda panda, Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PHOTOS);  parameters.put(""panda_name"", panda.getName());  if (extras != null && !extras.isEmpty()) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); PhotoList<Photo> photos = PhotoUtils.createPhotoList(photosElement); return photos; } }  "
src/main/java/com/flickr4java/flickr/people/PeopleInterface.java,"
package com.flickr4java.flickr.people;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.groups.Group;
import com.flickr4java.flickr.groups.GroupList;
import com.flickr4java.flickr.photos.Extras;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoList;
import com.flickr4java.flickr.photos.PhotoUtils;
import com.flickr4java.flickr.util.StringUtilities;
import com.flickr4java.flickr.util.XMLUtilities;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Interface for finding Flickr users.
 * 
 * @author Anthony Eden
 * @version $Id: PeopleInterface.java,v 1.28 2010/09/12 20:13:57 x-mago Exp $
 */
public class PeopleInterface {

    public static final String METHOD_FIND_BY_EMAIL = ""flickr.people.findByEmail"";

    public static final String METHOD_FIND_BY_USERNAME = ""flickr.people.findByUsername"";

    public static final String METHOD_GET_INFO = ""flickr.people.getInfo"";

    public static final String METHOD_GET_ONLINE_LIST = ""flickr.people.getOnlineList"";

    public static final String METHOD_GET_PUBLIC_GROUPS = ""flickr.people.getPublicGroups"";

    public static final String METHOD_GET_PUBLIC_PHOTOS = ""flickr.people.getPublicPhotos"";

    public static final String METHOD_GET_UPLOAD_STATUS = ""flickr.people.getUploadStatus"";

    public static final String METHOD_GET_PHOTOS = ""flickr.people.getPhotos"";

    public static final String METHOD_GET_PHOTOS_OF = ""flickr.people.getPhotosOf"";

    public static final String METHOD_GET_GROUPS = ""flickr.people.getGroups"";

    public static final String METHOD_GET_LIMITS = ""flickr.people.getLimits"";

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transportAPI;

    public PeopleInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transportAPI;
    }

    /**
     * Find the user by their email address.
     * 
     * This method does not require authentication.
     * 
     * @param email
     *            The email address
     * @return The User
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public User findByEmail(String email) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_FIND_BY_EMAIL);

        parameters.put(""find_email"", email);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element userElement = response.getPayload();
        User user = new User();
        user.setId(userElement.getAttribute(""nsid""));
        user.setUsername(XMLUtilities.getChildValue(userElement, ""username""));
        return user;
    }

    /**
     * Find a User by the username.
     * 
     * This method does not require authentication.
     * 
     * @param username
     *            The username
     * @return The User object
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public User findByUsername(String username) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_FIND_BY_USERNAME);

        parameters.put(""username"", username);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element userElement = response.getPayload();
        User user = new User();
        user.setId(userElement.getAttribute(""nsid""));
        user.setUsername(XMLUtilities.getChildValue(userElement, ""username""));
        return user;
    }

    /**
     * Get info about the specified user.
     * 
     * This method does not require authentication.
     * 
     * @param userId
     *            The user ID
     * @return The User object
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public User getInfo(String userId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_INFO);

        parameters.put(""user_id"", userId);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element userElement = response.getPayload();
        User user = new User();
        user.setId(userElement.getAttribute(""nsid""));
        user.setAdmin(""1"".equals(userElement.getAttribute(""isadmin"")));
        user.setPro(""1"".equals(userElement.getAttribute(""ispro"")));
        user.setIconFarm(userElement.getAttribute(""iconfarm""));
        user.setIconServer(userElement.getAttribute(""iconserver""));
        user.setRevContact(""1"".equals(userElement.getAttribute(""revcontact"")));
        user.setRevFriend(""1"".equals(userElement.getAttribute(""revfriend"")));
        user.setRevFamily(""1"".equals(userElement.getAttribute(""revfamily"")));
        String lPathAlias = userElement.getAttribute(""path_alias"");
        user.setPathAlias(lPathAlias == null || """".equals(lPathAlias) ? null : lPathAlias);
        user.setUsername(XMLUtilities.getChildValue(userElement, ""username""));
        user.setDescription(XMLUtilities.getChildValue(userElement, ""description""));
        user.setGender(XMLUtilities.getChildValue(userElement, ""gender""));
        user.setIgnored(""1"".equals(XMLUtilities.getChildValue(userElement, ""ignored"")));
        user.setContact(""1"".equals(XMLUtilities.getChildValue(userElement, ""contact"")));
        user.setFriend(""1"".equals(XMLUtilities.getChildValue(userElement, ""friend"")));
        user.setFamily(""1"".equals(XMLUtilities.getChildValue(userElement, ""family"")));
        user.setRealName(XMLUtilities.getChildValue(userElement, ""realname""));
        user.setLocation(XMLUtilities.getChildValue(userElement, ""location""));
        user.setMbox_sha1sum(XMLUtilities.getChildValue(userElement, ""mbox_sha1sum""));
        user.setPhotosurl(XMLUtilities.getChildValue(userElement, ""photosurl""));
        user.setProfileurl(XMLUtilities.getChildValue(userElement, ""profileurl""));
        user.setMobileurl(XMLUtilities.getChildValue(userElement, ""mobileurl""));

        Element photosElement = XMLUtilities.getChild(userElement, ""photos"");
        user.setPhotosFirstDate(XMLUtilities.getChildValue(photosElement, ""firstdate""));
        user.setPhotosFirstDateTaken(XMLUtilities.getChildValue(photosElement, ""firstdatetaken""));
        user.setPhotosCount(XMLUtilities.getChildValue(photosElement, ""count""));

        NodeList tzNodes = userElement.getElementsByTagName(""timezone"");
        for (int i = 0; i < tzNodes.getLength(); i++) {
            Element tzElement = (Element) tzNodes.item(i);
            TimeZone tz = new TimeZone();
            user.setTimeZone(tz);
            tz.setLabel(tzElement.getAttribute(""label""));
            tz.setTimeZoneId(tzElement.getAttribute(""timezone_id""));
            tz.setOffset(tzElement.getAttribute(""offset""));
        }

        return user;
    }

    /**
     * Get a collection of public groups for the user.
     * 
     * The groups will contain only the members nsid, name, admin and eighteenplus. If you want the whole group-information, you have to call
     * {@link com.flickr4java.flickr.groups.GroupsInterface#getInfo(String)}.
     * 
     * This method does not require authentication.
     * 
     * @param userId
     *            The user ID
     * @return The public groups
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Collection<Group> getPublicGroups(String userId) throws FlickrException {
        List<Group> groups = new ArrayList<Group>();

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_PUBLIC_GROUPS);

        parameters.put(""user_id"", userId);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element groupsElement = response.getPayload();
        NodeList groupNodes = groupsElement.getElementsByTagName(""group"");
        for (int i = 0; i < groupNodes.getLength(); i++) {
            Element groupElement = (Element) groupNodes.item(i);
            Group group = new Group();
            group.setId(groupElement.getAttribute(""nsid""));
            group.setName(groupElement.getAttribute(""name""));
            group.setAdmin(""1"".equals(groupElement.getAttribute(""admin"")));
            group.setEighteenPlus(groupElement.getAttribute(""eighteenplus"").equals(""0"") ? false : true);
            groups.add(group);
        }
        return groups;
    }

    public PhotoList<Photo> getPublicPhotos(String userId, int perPage, int page) throws FlickrException {
        return getPublicPhotos(userId, Extras.MIN_EXTRAS, perPage, page);
    }

    /**
     * Get a collection of public photos for the specified user ID.
     * 
     * This method does not require authentication.
     * 
     * @see com.flickr4java.flickr.photos.Extras
     * @param userId
     *            The User ID
     * @param extras
     *            Set of extra-attributes to include (may be null)
     * @param perPage
     *            The number of photos per page
     * @param page
     *            The page offset
     * @return The PhotoList collection
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PhotoList<Photo> getPublicPhotos(String userId, Set<String> extras, int perPage, int page) throws FlickrException {
        PhotoList<Photo> photos = new PhotoList<Photo>();

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_PUBLIC_PHOTOS);

        parameters.put(""user_id"", userId);

        if (perPage > 0) {
            parameters.put(""per_page"", """" + perPage);
        }
        if (page > 0) {
            parameters.put(""page"", """" + page);
        }

        if (extras != null) {
            parameters.put(Extras.KEY_EXTRAS, StringUtilities.join(extras, "",""));
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element photosElement = response.getPayload();
        photos.setPage(photosElement.getAttribute(""page""));
        photos.setPages(photosElement.getAttribute(""pages""));
        photos.setPerPage(photosElement.getAttribute(""perpage""));
        photos.setTotal(photosElement.getAttribute(""total""));

        NodeList photoNodes = photosElement.getElementsByTagName(""photo"");
        for (int i = 0; i < photoNodes.getLength(); i++) {
            Element photoElement = (Element) photoNodes.item(i);
            photos.add(PhotoUtils.createPhoto(photoElement));
        }
        return photos;
    }

    /**
     * Get upload status for the currently authenticated user.
     * 
     * Requires authentication with 'read' permission using the new authentication API.
     * 
     * @return A User object with upload status data fields filled
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public User getUploadStatus() throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_UPLOAD_STATUS);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element userElement = response.getPayload();
        User user = new User();
        user.setId(userElement.getAttribute(""id""));
        user.setPro(""1"".equals(userElement.getAttribute(""ispro"")));
        user.setUsername(XMLUtilities.getChildValue(userElement, ""username""));

        Element bandwidthElement = XMLUtilities.getChild(userElement, ""bandwidth"");
        user.setBandwidthMax(bandwidthElement.getAttribute(""max""));
        user.setBandwidthUsed(bandwidthElement.getAttribute(""used""));
        user.setIsBandwidthUnlimited(""1"".equals(bandwidthElement.getAttribute(""unlimited"")));

        Element filesizeElement = XMLUtilities.getChild(userElement, ""filesize"");
        user.setFilesizeMax(filesizeElement.getAttribute(""max""));

        Element setsElement = XMLUtilities.getChild(userElement, ""sets"");
        user.setSetsCreated(setsElement.getAttribute(""created""));
        user.setSetsRemaining(setsElement.getAttribute(""remaining""));

        Element videosElement = XMLUtilities.getChild(userElement, ""videos"");
        user.setVideosUploaded(videosElement.getAttribute(""uploaded""));
        user.setVideosRemaining(videosElement.getAttribute(""remaining""));

        Element videoSizeElement = XMLUtilities.getChild(userElement, ""videosize"");
        user.setVideoSizeMax(videoSizeElement.getAttribute(""maxbytes""));

        return user;
    }

    public PhotoList<Photo> getPhotos(String userId, String safeSearch, Date minUploadDate, Date maxUploadDate, Date minTakenDate, Date maxTakenDate,
            String contentType, String privacyFilter, Set<String> extras, int perPage, int page) throws FlickrException {

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_PHOTOS);

        parameters.put(""user_id"", userId);
        if (safeSearch != null) {
            parameters.put(""safe_search"", safeSearch);
        }
        if (minUploadDate != null) {
            parameters.put(""min_upload_date"", minUploadDate);
        }
        if (maxUploadDate != null) {
            parameters.put(""max_upload_date"", maxUploadDate);
        }
        if (minTakenDate != null) {
            parameters.put(""min_taken_date"", minTakenDate);
        }
        if (maxTakenDate != null) {
            parameters.put(""max_taken_date"", maxTakenDate);
        }
        if (contentType != null) {
            parameters.put(""content_type"", contentType);
        }
        if (privacyFilter != null) {
            parameters.put(""privacy_filter"", privacyFilter);
        }
        if (perPage > 0) {
            parameters.put(""per_page"", """" + perPage);
        }
        if (page > 0) {
            parameters.put(""page"", """" + page);
        }
        if (extras != null) {
            parameters.put(Extras.KEY_EXTRAS, StringUtilities.join(extras, "",""));
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element photosElement = response.getPayload();
        PhotoList<Photo> photos = new PhotoList<Photo>();
        photos.setPage(photosElement.getAttribute(""page""));
        photos.setPages(photosElement.getAttribute(""pages""));
        photos.setPerPage(photosElement.getAttribute(""perpage""));
        photos.setTotal(photosElement.getAttribute(""total""));

        NodeList photoNodes = photosElement.getElementsByTagName(""photo"");
        for (int i = 0; i < photoNodes.getLength(); i++) {
            Element photoElement = (Element) photoNodes.item(i);
            photos.add(PhotoUtils.createPhoto(photoElement));
        }
        return photos;
    }

    public PhotoList<Photo> getPhotosOf(String userId, String ownerId, Set<String> extras, int perPage, int page) throws FlickrException {

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_PHOTOS_OF);

        parameters.put(""user_id"", userId);
        if (ownerId != null) {
            parameters.put(""owner_id"", ownerId);
        }
        if (extras != null) {
            parameters.put(Extras.KEY_EXTRAS, StringUtilities.join(extras, "",""));
        }
        if (perPage > 0) {
            parameters.put(""per_page"", """" + perPage);
        }
        if (page > 0) {
            parameters.put(""page"", """" + page);
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element photosElement = response.getPayload();
        PhotoList<Photo> photos = new PhotoList<Photo>();
        photos.setPage(photosElement.getAttribute(""page""));
        photos.setPerPage(photosElement.getAttribute(""perpage""));

        NodeList photoNodes = photosElement.getElementsByTagName(""photo"");
        for (int i = 0; i < photoNodes.getLength(); i++) {
            Element photoElement = (Element) photoNodes.item(i);
            Photo photo = new Photo();
            photo.setId(photoElement.getAttribute(""id""));
            photo.setSecret(photoElement.getAttribute(""secret""));

            User owner = new User();
            owner.setId(photoElement.getAttribute(""owner""));
            photo.setOwner(owner);
            photo.setUrl(""https://flickr.com/photos/"" + owner.getId() + ""/"" + photo.getId());
            photo.setServer(photoElement.getAttribute(""server""));
            photo.setTitle(photoElement.getAttribute(""title""));
            photo.setPublicFlag(""1"".equals(photoElement.getAttribute(""ispublic"")));
            photo.setFriendFlag(""1"".equals(photoElement.getAttribute(""isfriend"")));
            photo.setFamilyFlag(""1"".equals(photoElement.getAttribute(""isfamily"")));
            photos.add(photo);
        }
        return photos;
    }

    /**
     * Add the given person to the photo. Optionally, send in co-ordinates
     * 
     * @param photoId
     * @param userId
     * @param bounds
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void add(String photoId, String userId, Rectangle bounds) throws FlickrException {

        // Delegating this to photos.people.PeopleInterface - Naming standard would be to use PeopleInterface but having 2 the same name can cause issues
        com.flickr4java.flickr.photos.people.PeopleInterface pi = new com.flickr4java.flickr.photos.people.PeopleInterface(apiKey, sharedSecret, transportAPI);
        pi.add(photoId, userId, bounds);
    }

    /**
     * Delete the person from the photo
     * 
     * @param photoId
     * @param userId
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void delete(String photoId, String userId) throws FlickrException {

        // Delegating this to photos.people.PeopleInterface - Naming standard would be to use PeopleInterface but having 2 the same name can cause issues
        com.flickr4java.flickr.photos.people.PeopleInterface pi = new com.flickr4java.flickr.photos.people.PeopleInterface(apiKey, sharedSecret, transportAPI);
        pi.delete(photoId, userId);
    }

    /**
     * Delete the co-ordinates that the user is shown in
     * 
     * @param photoId
     * @param userId
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void deleteCoords(String photoId, String userId) throws FlickrException {

        // Delegating this to photos.people.PeopleInterface - Naming standard would be to use PeopleInterface but having 2 the same name can cause issues
        com.flickr4java.flickr.photos.people.PeopleInterface pi = new com.flickr4java.flickr.photos.people.PeopleInterface(apiKey, sharedSecret, transportAPI);
        pi.deleteCoords(photoId, userId);
    }

    /**
     * Edit the co-ordinates that the user shows in
     * 
     * @param photoId
     * @param userId
     * @param bounds
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void editCoords(String photoId, String userId, Rectangle bounds) throws FlickrException {

        // Delegating this to photos.people.PeopleInterface - Naming standard would be to use PeopleInterface but having 2 the same name can cause issues
        com.flickr4java.flickr.photos.people.PeopleInterface pi = new com.flickr4java.flickr.photos.people.PeopleInterface(apiKey, sharedSecret, transportAPI);
        pi.editCoords(photoId, userId, bounds);
    }

    /**
     * Get a list of people in a given photo.
     * 
     * @param photoId
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PersonTagList<PersonTag> getList(String photoId) throws FlickrException {

        // Delegating this to photos.people.PeopleInterface - Naming standard would be to use PeopleInterface but having 2 the same name can cause issues
        com.flickr4java.flickr.photos.people.PeopleInterface pi = new com.flickr4java.flickr.photos.people.PeopleInterface(apiKey, sharedSecret, transportAPI);
        return pi.getList(photoId);
    }

    /**
     * 
     * @param userId
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public GroupList<Group> getGroups(String userId) throws FlickrException {

        GroupList<Group> groupList = new GroupList<Group>();
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_GROUPS);
        parameters.put(""user_id"", userId);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element groupsElement = response.getPayload();
        NodeList groupNodes = groupsElement.getElementsByTagName(""group"");
        groupList.setPage(XMLUtilities.getIntAttribute(groupsElement, ""page""));
        groupList.setPages(XMLUtilities.getIntAttribute(groupsElement, ""pages""));
        groupList.setPerPage(XMLUtilities.getIntAttribute(groupsElement, ""perpage""));
        groupList.setTotal(XMLUtilities.getIntAttribute(groupsElement, ""total""));
        for (int i = 0; i < groupNodes.getLength(); i++) {
            Element groupElement = (Element) groupNodes.item(i);
            Group group = new Group();
            group.setId(groupElement.getAttribute(""nsid""));
            group.setName(groupElement.getAttribute(""name""));
            group.setAdmin(""1"".equals(groupElement.getAttribute(""admin"")));
            group.setEighteenPlus(""1"".equals(groupElement.getAttribute(""eighteenplus"")));
            group.setInvitationOnly(""1"".equals(groupElement.getAttribute(""invitation_only"")));
            group.setMembers(groupElement.getAttribute(""members""));
            group.setPhotoCount(groupElement.getAttribute(""pool_count""));
            groupList.add(group);
        }
        return groupList;

    }

    /**
     * Get's the user's current upload limits, User object only contains user_id
     * 
     * @return Media Limits
     */

    public User getLimits() throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_LIMITS);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element userElement = response.getPayload();
        User user = new User();
        user.setId(userElement.getAttribute(""nsid""));
        NodeList photoNodes = userElement.getElementsByTagName(""photos"");
        for (int i = 0; i < photoNodes.getLength(); i++) {
            Element plElement = (Element) photoNodes.item(i);
            PhotoLimits pl = new PhotoLimits();
            user.setPhotoLimits(pl);
            pl.setMaxDisplay(plElement.getAttribute(""maxdisplaypx""));
            pl.setMaxUpload(plElement.getAttribute(""maxupload""));
        }
        NodeList videoNodes = userElement.getElementsByTagName(""videos"");
        for (int i = 0; i < videoNodes.getLength(); i++) {
            Element vlElement = (Element) videoNodes.item(i);
            VideoLimits vl = new VideoLimits();
            user.setPhotoLimits(vl);
            vl.setMaxDuration(vlElement.getAttribute(""maxduration""));
            vl.setMaxUpload(vlElement.getAttribute(""maxupload""));
        }
        return user;
    }

}
","package com.flickr4java.flickr.people; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.groups.Group; import com.flickr4java.flickr.groups.GroupList; import com.flickr4java.flickr.photos.Extras; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.util.StringUtilities; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.awt.Rectangle; import java.util.ArrayList; import java.util.Collection; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Set; public class PeopleInterface { public static final String METHOD_FIND_BY_EMAIL = ""flickr.people.findByEmail""; public static final String METHOD_FIND_BY_USERNAME = ""flickr.people.findByUsername""; public static final String METHOD_GET_INFO = ""flickr.people.getInfo""; public static final String METHOD_GET_ONLINE_LIST = ""flickr.people.getOnlineList""; public static final String METHOD_GET_PUBLIC_GROUPS = ""flickr.people.getPublicGroups""; public static final String METHOD_GET_PUBLIC_PHOTOS = ""flickr.people.getPublicPhotos""; public static final String METHOD_GET_UPLOAD_STATUS = ""flickr.people.getUploadStatus""; public static final String METHOD_GET_PHOTOS = ""flickr.people.getPhotos""; public static final String METHOD_GET_PHOTOS_OF = ""flickr.people.getPhotosOf""; public static final String METHOD_GET_GROUPS = ""flickr.people.getGroups""; public static final String METHOD_GET_LIMITS = ""flickr.people.getLimits""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public PeopleInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public User findByEmail(String email) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_FIND_BY_EMAIL); parameters.put(""find_email"", email); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element userElement = response.getPayload(); User user = new User(); user.setId(userElement.getAttribute(""nsid"")); user.setUsername(XMLUtilities.getChildValue(userElement, ""username"")); return user; } public User findByUsername(String username) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_FIND_BY_USERNAME); parameters.put(""username"", username); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element userElement = response.getPayload(); User user = new User(); user.setId(userElement.getAttribute(""nsid"")); user.setUsername(XMLUtilities.getChildValue(userElement, ""username"")); return user; } public User getInfo(String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO); parameters.put(""user_id"", userId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element userElement = response.getPayload(); User user = new User(); user.setId(userElement.getAttribute(""nsid"")); user.setAdmin(""1"".equals(userElement.getAttribute(""isadmin""))); user.setPro(""1"".equals(userElement.getAttribute(""ispro""))); user.setIconFarm(userElement.getAttribute(""iconfarm"")); user.setIconServer(userElement.getAttribute(""iconserver"")); user.setRevContact(""1"".equals(userElement.getAttribute(""revcontact""))); user.setRevFriend(""1"".equals(userElement.getAttribute(""revfriend""))); user.setRevFamily(""1"".equals(userElement.getAttribute(""revfamily""))); String lPathAlias = userElement.getAttribute(""path_alias""); user.setPathAlias(lPathAlias == null || """".equals(lPathAlias) ? null : lPathAlias); user.setUsername(XMLUtilities.getChildValue(userElement, ""username"")); user.setDescription(XMLUtilities.getChildValue(userElement, ""description"")); user.setGender(XMLUtilities.getChildValue(userElement, ""gender"")); user.setIgnored(""1"".equals(XMLUtilities.getChildValue(userElement, ""ignored""))); user.setContact(""1"".equals(XMLUtilities.getChildValue(userElement, ""contact""))); user.setFriend(""1"".equals(XMLUtilities.getChildValue(userElement, ""friend""))); user.setFamily(""1"".equals(XMLUtilities.getChildValue(userElement, ""family""))); user.setRealName(XMLUtilities.getChildValue(userElement, ""realname"")); user.setLocation(XMLUtilities.getChildValue(userElement, ""location"")); user.setMbox_sha1sum(XMLUtilities.getChildValue(userElement, ""mbox_sha1sum"")); user.setPhotosurl(XMLUtilities.getChildValue(userElement, ""photosurl"")); user.setProfileurl(XMLUtilities.getChildValue(userElement, ""profileurl"")); user.setMobileurl(XMLUtilities.getChildValue(userElement, ""mobileurl"")); Element photosElement = XMLUtilities.getChild(userElement, ""photos""); user.setPhotosFirstDate(XMLUtilities.getChildValue(photosElement, ""firstdate"")); user.setPhotosFirstDateTaken(XMLUtilities.getChildValue(photosElement, ""firstdatetaken"")); user.setPhotosCount(XMLUtilities.getChildValue(photosElement, ""count"")); NodeList tzNodes = userElement.getElementsByTagName(""timezone""); for (int i = 0; i < tzNodes.getLength(); i++) { Element tzElement = (Element) tzNodes.item(i); TimeZone tz = new TimeZone(); user.setTimeZone(tz); tz.setLabel(tzElement.getAttribute(""label"")); tz.setTimeZoneId(tzElement.getAttribute(""timezone_id"")); tz.setOffset(tzElement.getAttribute(""offset"")); } return user; } public Collection<Group> getPublicGroups(String userId) throws FlickrException { List<Group> groups = new ArrayList<Group>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PUBLIC_GROUPS); parameters.put(""user_id"", userId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element groupsElement = response.getPayload(); NodeList groupNodes = groupsElement.getElementsByTagName(""group""); for (int i = 0; i < groupNodes.getLength(); i++) { Element groupElement = (Element) groupNodes.item(i); Group group = new Group(); group.setId(groupElement.getAttribute(""nsid"")); group.setName(groupElement.getAttribute(""name"")); group.setAdmin(""1"".equals(groupElement.getAttribute(""admin""))); group.setEighteenPlus(groupElement.getAttribute(""eighteenplus"").equals(""0"") ? false : true); groups.add(group); } return groups; } public PhotoList<Photo> getPublicPhotos(String userId, int perPage, int page) throws FlickrException { return getPublicPhotos(userId, Extras.MIN_EXTRAS, perPage, page); } public PhotoList<Photo> getPublicPhotos(String userId, Set<String> extras, int perPage, int page) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PUBLIC_PHOTOS); parameters.put(""user_id"", userId); if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } if (extras != null) { parameters.put(Extras.KEY_EXTRAS, StringUtilities.join(extras, "","")); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } public User getUploadStatus() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_UPLOAD_STATUS); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element userElement = response.getPayload(); User user = new User(); user.setId(userElement.getAttribute(""id"")); user.setPro(""1"".equals(userElement.getAttribute(""ispro""))); user.setUsername(XMLUtilities.getChildValue(userElement, ""username"")); Element bandwidthElement = XMLUtilities.getChild(userElement, ""bandwidth""); user.setBandwidthMax(bandwidthElement.getAttribute(""max"")); user.setBandwidthUsed(bandwidthElement.getAttribute(""used"")); user.setIsBandwidthUnlimited(""1"".equals(bandwidthElement.getAttribute(""unlimited""))); Element filesizeElement = XMLUtilities.getChild(userElement, ""filesize""); user.setFilesizeMax(filesizeElement.getAttribute(""max"")); Element setsElement = XMLUtilities.getChild(userElement, ""sets""); user.setSetsCreated(setsElement.getAttribute(""created"")); user.setSetsRemaining(setsElement.getAttribute(""remaining"")); Element videosElement = XMLUtilities.getChild(userElement, ""videos""); user.setVideosUploaded(videosElement.getAttribute(""uploaded"")); user.setVideosRemaining(videosElement.getAttribute(""remaining"")); Element videoSizeElement = XMLUtilities.getChild(userElement, ""videosize""); user.setVideoSizeMax(videoSizeElement.getAttribute(""maxbytes"")); return user; } public PhotoList<Photo> getPhotos(String userId, String safeSearch, Date minUploadDate, Date maxUploadDate, Date minTakenDate, Date maxTakenDate,
            String contentType, String privacyFilter, Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PHOTOS); parameters.put(""user_id"", userId); if (safeSearch != null) { parameters.put(""safe_search"", safeSearch); } if (minUploadDate != null) { parameters.put(""min_upload_date"", minUploadDate); } if (maxUploadDate != null) { parameters.put(""max_upload_date"", maxUploadDate); } if (minTakenDate != null) { parameters.put(""min_taken_date"", minTakenDate); } if (maxTakenDate != null) { parameters.put(""max_taken_date"", maxTakenDate); } if (contentType != null) { parameters.put(""content_type"", contentType); } if (privacyFilter != null) { parameters.put(""privacy_filter"", privacyFilter); } if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } if (extras != null) { parameters.put(Extras.KEY_EXTRAS, StringUtilities.join(extras, "","")); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); PhotoList<Photo> photos = new PhotoList<Photo>(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } public PhotoList<Photo> getPhotosOf(String userId, String ownerId, Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PHOTOS_OF); parameters.put(""user_id"", userId); if (ownerId != null) { parameters.put(""owner_id"", ownerId); } if (extras != null) { parameters.put(Extras.KEY_EXTRAS, StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); PhotoList<Photo> photos = new PhotoList<Photo>(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); Photo photo = new Photo(); photo.setId(photoElement.getAttribute(""id"")); photo.setSecret(photoElement.getAttribute(""secret"")); User owner = new User(); owner.setId(photoElement.getAttribute(""owner"")); photo.setOwner(owner); photo.setServer(photoElement.getAttribute(""server"")); photo.setTitle(photoElement.getAttribute(""title"")); photo.setPublicFlag(""1"".equals(photoElement.getAttribute(""ispublic""))); photo.setFriendFlag(""1"".equals(photoElement.getAttribute(""isfriend""))); photo.setFamilyFlag(""1"".equals(photoElement.getAttribute(""isfamily""))); photos.add(photo); } return photos; } public void add(String photoId, String userId, Rectangle bounds) throws FlickrException { com.flickr4java.flickr.photos.people.PeopleInterface pi = new com.flickr4java.flickr.photos.people.PeopleInterface(apiKey, sharedSecret, transportAPI); pi.add(photoId, userId, bounds); } public void delete(String photoId, String userId) throws FlickrException { com.flickr4java.flickr.photos.people.PeopleInterface pi = new com.flickr4java.flickr.photos.people.PeopleInterface(apiKey, sharedSecret, transportAPI); pi.delete(photoId, userId); } public void deleteCoords(String photoId, String userId) throws FlickrException { com.flickr4java.flickr.photos.people.PeopleInterface pi = new com.flickr4java.flickr.photos.people.PeopleInterface(apiKey, sharedSecret, transportAPI); pi.deleteCoords(photoId, userId); } public void editCoords(String photoId, String userId, Rectangle bounds) throws FlickrException { com.flickr4java.flickr.photos.people.PeopleInterface pi = new com.flickr4java.flickr.photos.people.PeopleInterface(apiKey, sharedSecret, transportAPI); pi.editCoords(photoId, userId, bounds); } public PersonTagList<PersonTag> getList(String photoId) throws FlickrException { com.flickr4java.flickr.photos.people.PeopleInterface pi = new com.flickr4java.flickr.photos.people.PeopleInterface(apiKey, sharedSecret, transportAPI); return pi.getList(photoId); } public GroupList<Group> getGroups(String userId) throws FlickrException { GroupList<Group> groupList = new GroupList<Group>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_GROUPS); parameters.put(""user_id"", userId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element groupsElement = response.getPayload(); NodeList groupNodes = groupsElement.getElementsByTagName(""group""); groupList.setPage(XMLUtilities.getIntAttribute(groupsElement, ""page"")); groupList.setPages(XMLUtilities.getIntAttribute(groupsElement, ""pages"")); groupList.setPerPage(XMLUtilities.getIntAttribute(groupsElement, ""perpage"")); groupList.setTotal(XMLUtilities.getIntAttribute(groupsElement, ""total"")); for (int i = 0; i < groupNodes.getLength(); i++) { Element groupElement = (Element) groupNodes.item(i); Group group = new Group(); group.setId(groupElement.getAttribute(""nsid"")); group.setName(groupElement.getAttribute(""name"")); group.setAdmin(""1"".equals(groupElement.getAttribute(""admin""))); group.setEighteenPlus(""1"".equals(groupElement.getAttribute(""eighteenplus""))); group.setInvitationOnly(""1"".equals(groupElement.getAttribute(""invitation_only""))); group.setMembers(groupElement.getAttribute(""members"")); group.setPhotoCount(groupElement.getAttribute(""pool_count"")); groupList.add(group); } return groupList; } public User getLimits() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIMITS); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element userElement = response.getPayload(); User user = new User(); user.setId(userElement.getAttribute(""nsid"")); NodeList photoNodes = userElement.getElementsByTagName(""photos""); for (int i = 0; i < photoNodes.getLength(); i++) { Element plElement = (Element) photoNodes.item(i); PhotoLimits pl = new PhotoLimits(); user.setPhotoLimits(pl); pl.setMaxDisplay(plElement.getAttribute(""maxdisplaypx"")); pl.setMaxUpload(plElement.getAttribute(""maxupload"")); } NodeList videoNodes = userElement.getElementsByTagName(""videos""); for (int i = 0; i < videoNodes.getLength(); i++) { Element vlElement = (Element) videoNodes.item(i); VideoLimits vl = new VideoLimits(); user.setPhotoLimits(vl); vl.setMaxDuration(vlElement.getAttribute(""maxduration"")); vl.setMaxUpload(vlElement.getAttribute(""maxupload"")); } return user; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.people; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.groups.Group; import com.flickr4java.flickr.groups.GroupList; import com.flickr4java.flickr.photos.Extras; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.util.StringUtilities; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.awt.Rectangle; import java.util.ArrayList; import java.util.Collection; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Set; public class PeopleInterface { public static final String METHOD_FIND_BY_EMAIL = ""flickr.people.findByEmail""; public static final String METHOD_FIND_BY_USERNAME = ""flickr.people.findByUsername""; public static final String METHOD_GET_INFO = ""flickr.people.getInfo""; public static final String METHOD_GET_ONLINE_LIST = ""flickr.people.getOnlineList""; public static final String METHOD_GET_PUBLIC_GROUPS = ""flickr.people.getPublicGroups""; public static final String METHOD_GET_PUBLIC_PHOTOS = ""flickr.people.getPublicPhotos""; public static final String METHOD_GET_UPLOAD_STATUS = ""flickr.people.getUploadStatus""; public static final String METHOD_GET_PHOTOS = ""flickr.people.getPhotos""; public static final String METHOD_GET_PHOTOS_OF = ""flickr.people.getPhotosOf""; public static final String METHOD_GET_GROUPS = ""flickr.people.getGroups""; public static final String METHOD_GET_LIMITS = ""flickr.people.getLimits""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public PeopleInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public User findByEmail(String email) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_FIND_BY_EMAIL); parameters.put(""find_email"", email); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element userElement = response.getPayload(); User user = new User(); user.setId(userElement.getAttribute(""nsid"")); user.setUsername(XMLUtilities.getChildValue(userElement, ""username"")); return user; } public User findByUsername(String username) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_FIND_BY_USERNAME); parameters.put(""username"", username); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element userElement = response.getPayload(); User user = new User(); user.setId(userElement.getAttribute(""nsid"")); user.setUsername(XMLUtilities.getChildValue(userElement, ""username"")); return user; } public User getInfo(String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO); parameters.put(""user_id"", userId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element userElement = response.getPayload(); User user = new User(); user.setId(userElement.getAttribute(""nsid"")); user.setAdmin(""1"".equals(userElement.getAttribute(""isadmin""))); user.setPro(""1"".equals(userElement.getAttribute(""ispro""))); user.setIconFarm(userElement.getAttribute(""iconfarm"")); user.setIconServer(userElement.getAttribute(""iconserver"")); user.setRevContact(""1"".equals(userElement.getAttribute(""revcontact""))); user.setRevFriend(""1"".equals(userElement.getAttribute(""revfriend""))); user.setRevFamily(""1"".equals(userElement.getAttribute(""revfamily""))); String lPathAlias = userElement.getAttribute(""path_alias""); user.setPathAlias(lPathAlias == null || """".equals(lPathAlias) ? null : lPathAlias); user.setUsername(XMLUtilities.getChildValue(userElement, ""username"")); user.setDescription(XMLUtilities.getChildValue(userElement, ""description"")); user.setGender(XMLUtilities.getChildValue(userElement, ""gender"")); user.setIgnored(""1"".equals(XMLUtilities.getChildValue(userElement, ""ignored""))); user.setContact(""1"".equals(XMLUtilities.getChildValue(userElement, ""contact""))); user.setFriend(""1"".equals(XMLUtilities.getChildValue(userElement, ""friend""))); user.setFamily(""1"".equals(XMLUtilities.getChildValue(userElement, ""family""))); user.setRealName(XMLUtilities.getChildValue(userElement, ""realname"")); user.setLocation(XMLUtilities.getChildValue(userElement, ""location"")); user.setMbox_sha1sum(XMLUtilities.getChildValue(userElement, ""mbox_sha1sum"")); user.setPhotosurl(XMLUtilities.getChildValue(userElement, ""photosurl"")); user.setProfileurl(XMLUtilities.getChildValue(userElement, ""profileurl"")); user.setMobileurl(XMLUtilities.getChildValue(userElement, ""mobileurl"")); Element photosElement = XMLUtilities.getChild(userElement, ""photos""); user.setPhotosFirstDate(XMLUtilities.getChildValue(photosElement, ""firstdate"")); user.setPhotosFirstDateTaken(XMLUtilities.getChildValue(photosElement, ""firstdatetaken"")); user.setPhotosCount(XMLUtilities.getChildValue(photosElement, ""count"")); NodeList tzNodes = userElement.getElementsByTagName(""timezone""); for (int i = 0; i < tzNodes.getLength(); i++) { Element tzElement = (Element) tzNodes.item(i); TimeZone tz = new TimeZone(); user.setTimeZone(tz); tz.setLabel(tzElement.getAttribute(""label"")); tz.setTimeZoneId(tzElement.getAttribute(""timezone_id"")); tz.setOffset(tzElement.getAttribute(""offset"")); } return user; } public Collection<Group> getPublicGroups(String userId) throws FlickrException { List<Group> groups = new ArrayList<Group>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PUBLIC_GROUPS); parameters.put(""user_id"", userId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element groupsElement = response.getPayload(); NodeList groupNodes = groupsElement.getElementsByTagName(""group""); for (int i = 0; i < groupNodes.getLength(); i++) { Element groupElement = (Element) groupNodes.item(i); Group group = new Group(); group.setId(groupElement.getAttribute(""nsid"")); group.setName(groupElement.getAttribute(""name"")); group.setAdmin(""1"".equals(groupElement.getAttribute(""admin""))); group.setEighteenPlus(groupElement.getAttribute(""eighteenplus"").equals(""0"") ? false : true); groups.add(group); } return groups; } public PhotoList<Photo> getPublicPhotos(String userId, int perPage, int page) throws FlickrException { return getPublicPhotos(userId, Extras.MIN_EXTRAS, perPage, page); } public PhotoList<Photo> getPublicPhotos(String userId, Set<String> extras, int perPage, int page) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PUBLIC_PHOTOS); parameters.put(""user_id"", userId); if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } if (extras != null) { parameters.put(Extras.KEY_EXTRAS, StringUtilities.join(extras, "","")); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } public User getUploadStatus() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_UPLOAD_STATUS); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element userElement = response.getPayload(); User user = new User(); user.setId(userElement.getAttribute(""id"")); user.setPro(""1"".equals(userElement.getAttribute(""ispro""))); user.setUsername(XMLUtilities.getChildValue(userElement, ""username"")); Element bandwidthElement = XMLUtilities.getChild(userElement, ""bandwidth""); user.setBandwidthMax(bandwidthElement.getAttribute(""max"")); user.setBandwidthUsed(bandwidthElement.getAttribute(""used"")); user.setIsBandwidthUnlimited(""1"".equals(bandwidthElement.getAttribute(""unlimited""))); Element filesizeElement = XMLUtilities.getChild(userElement, ""filesize""); user.setFilesizeMax(filesizeElement.getAttribute(""max"")); Element setsElement = XMLUtilities.getChild(userElement, ""sets""); user.setSetsCreated(setsElement.getAttribute(""created"")); user.setSetsRemaining(setsElement.getAttribute(""remaining"")); Element videosElement = XMLUtilities.getChild(userElement, ""videos""); user.setVideosUploaded(videosElement.getAttribute(""uploaded"")); user.setVideosRemaining(videosElement.getAttribute(""remaining"")); Element videoSizeElement = XMLUtilities.getChild(userElement, ""videosize""); user.setVideoSizeMax(videoSizeElement.getAttribute(""maxbytes"")); return user; } public PhotoList<Photo> getPhotos(String userId, String safeSearch, Date minUploadDate, Date maxUploadDate, Date minTakenDate, Date maxTakenDate,
            String contentType, String privacyFilter, Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PHOTOS); parameters.put(""user_id"", userId); if (safeSearch != null) { parameters.put(""safe_search"", safeSearch); } if (minUploadDate != null) { parameters.put(""min_upload_date"", minUploadDate); } if (maxUploadDate != null) { parameters.put(""max_upload_date"", maxUploadDate); } if (minTakenDate != null) { parameters.put(""min_taken_date"", minTakenDate); } if (maxTakenDate != null) { parameters.put(""max_taken_date"", maxTakenDate); } if (contentType != null) { parameters.put(""content_type"", contentType); } if (privacyFilter != null) { parameters.put(""privacy_filter"", privacyFilter); } if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } if (extras != null) { parameters.put(Extras.KEY_EXTRAS, StringUtilities.join(extras, "","")); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); PhotoList<Photo> photos = new PhotoList<Photo>(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } public PhotoList<Photo> getPhotosOf(String userId, String ownerId, Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PHOTOS_OF); parameters.put(""user_id"", userId); if (ownerId != null) { parameters.put(""owner_id"", ownerId); } if (extras != null) { parameters.put(Extras.KEY_EXTRAS, StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); PhotoList<Photo> photos = new PhotoList<Photo>(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); Photo photo = new Photo(); photo.setId(photoElement.getAttribute(""id"")); photo.setSecret(photoElement.getAttribute(""secret"")); User owner = new User(); owner.setId(photoElement.getAttribute(""owner"")); photo.setOwner(owner); photo.setServer(photoElement.getAttribute(""server"")); photo.setTitle(photoElement.getAttribute(""title"")); photo.setPublicFlag(""1"".equals(photoElement.getAttribute(""ispublic""))); photo.setFriendFlag(""1"".equals(photoElement.getAttribute(""isfriend""))); photo.setFamilyFlag(""1"".equals(photoElement.getAttribute(""isfamily""))); photos.add(photo); } return photos; } public void add(String photoId, String userId, Rectangle bounds) throws FlickrException { com.flickr4java.flickr.photos.people.PeopleInterface pi = new com.flickr4java.flickr.photos.people.PeopleInterface(apiKey, sharedSecret, transportAPI); pi.add(photoId, userId, bounds); } public void delete(String photoId, String userId) throws FlickrException { com.flickr4java.flickr.photos.people.PeopleInterface pi = new com.flickr4java.flickr.photos.people.PeopleInterface(apiKey, sharedSecret, transportAPI); pi.delete(photoId, userId); } public void deleteCoords(String photoId, String userId) throws FlickrException { com.flickr4java.flickr.photos.people.PeopleInterface pi = new com.flickr4java.flickr.photos.people.PeopleInterface(apiKey, sharedSecret, transportAPI); pi.deleteCoords(photoId, userId); } public void editCoords(String photoId, String userId, Rectangle bounds) throws FlickrException { com.flickr4java.flickr.photos.people.PeopleInterface pi = new com.flickr4java.flickr.photos.people.PeopleInterface(apiKey, sharedSecret, transportAPI); pi.editCoords(photoId, userId, bounds); } public PersonTagList<PersonTag> getList(String photoId) throws FlickrException { com.flickr4java.flickr.photos.people.PeopleInterface pi = new com.flickr4java.flickr.photos.people.PeopleInterface(apiKey, sharedSecret, transportAPI); return pi.getList(photoId); } public GroupList<Group> getGroups(String userId) throws FlickrException { GroupList<Group> groupList = new GroupList<Group>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_GROUPS); parameters.put(""user_id"", userId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element groupsElement = response.getPayload(); NodeList groupNodes = groupsElement.getElementsByTagName(""group""); groupList.setPage(XMLUtilities.getIntAttribute(groupsElement, ""page"")); groupList.setPages(XMLUtilities.getIntAttribute(groupsElement, ""pages"")); groupList.setPerPage(XMLUtilities.getIntAttribute(groupsElement, ""perpage"")); groupList.setTotal(XMLUtilities.getIntAttribute(groupsElement, ""total"")); for (int i = 0; i < groupNodes.getLength(); i++) { Element groupElement = (Element) groupNodes.item(i); Group group = new Group(); group.setId(groupElement.getAttribute(""nsid"")); group.setName(groupElement.getAttribute(""name"")); group.setAdmin(""1"".equals(groupElement.getAttribute(""admin""))); group.setEighteenPlus(""1"".equals(groupElement.getAttribute(""eighteenplus""))); group.setInvitationOnly(""1"".equals(groupElement.getAttribute(""invitation_only""))); group.setMembers(groupElement.getAttribute(""members"")); group.setPhotoCount(groupElement.getAttribute(""pool_count"")); groupList.add(group); } return groupList; } public User getLimits() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIMITS); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element userElement = response.getPayload(); User user = new User(); user.setId(userElement.getAttribute(""nsid"")); NodeList photoNodes = userElement.getElementsByTagName(""photos""); for (int i = 0; i < photoNodes.getLength(); i++) { Element plElement = (Element) photoNodes.item(i); PhotoLimits pl = new PhotoLimits(); user.setPhotoLimits(pl); pl.setMaxDisplay(plElement.getAttribute(""maxdisplaypx"")); pl.setMaxUpload(plElement.getAttribute(""maxupload"")); } NodeList videoNodes = userElement.getElementsByTagName(""videos""); for (int i = 0; i < videoNodes.getLength(); i++) { Element vlElement = (Element) videoNodes.item(i); VideoLimits vl = new VideoLimits(); user.setPhotoLimits(vl); vl.setMaxDuration(vlElement.getAttribute(""maxduration"")); vl.setMaxUpload(vlElement.getAttribute(""maxupload"")); } return user; } } "," package com.flickr4java.flickr.people;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.groups.Group; import com.flickr4java.flickr.groups.GroupList; import com.flickr4java.flickr.photos.Extras; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.util.StringUtilities; import com.flickr4java.flickr.util.XMLUtilities;  import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import java.awt.Rectangle; import java.util.ArrayList; import java.util.Collection; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Set;  /**
 * Interface for finding Flickr users.
 * 
 * @author Anthony Eden
 * @version $Id: PeopleInterface.java,v 1.28 2010/09/12 20:13:57 x-mago Exp $
 */ public class PeopleInterface {  public static final String METHOD_FIND_BY_EMAIL = ""flickr.people.findByEmail"";  public static final String METHOD_FIND_BY_USERNAME = ""flickr.people.findByUsername"";  public static final String METHOD_GET_INFO = ""flickr.people.getInfo"";  public static final String METHOD_GET_ONLINE_LIST = ""flickr.people.getOnlineList"";  public static final String METHOD_GET_PUBLIC_GROUPS = ""flickr.people.getPublicGroups"";  public static final String METHOD_GET_PUBLIC_PHOTOS = ""flickr.people.getPublicPhotos"";  public static final String METHOD_GET_UPLOAD_STATUS = ""flickr.people.getUploadStatus"";  public static final String METHOD_GET_PHOTOS = ""flickr.people.getPhotos"";  public static final String METHOD_GET_PHOTOS_OF = ""flickr.people.getPhotosOf"";  public static final String METHOD_GET_GROUPS = ""flickr.people.getGroups"";  public static final String METHOD_GET_LIMITS = ""flickr.people.getLimits"";  private final String apiKey;  private final String sharedSecret;  private final Transport transportAPI;  public PeopleInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; }  /**
     * Find the user by their email address.
     * 
     * This method does not require authentication.
     * 
     * @param email
     *            The email address
     * @return The User
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public User findByEmail(String email) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_FIND_BY_EMAIL);  parameters.put(""find_email"", email);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element userElement = response.getPayload(); User user = new User(); user.setId(userElement.getAttribute(""nsid"")); user.setUsername(XMLUtilities.getChildValue(userElement, ""username"")); return user; }  /**
     * Find a User by the username.
     * 
     * This method does not require authentication.
     * 
     * @param username
     *            The username
     * @return The User object
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public User findByUsername(String username) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_FIND_BY_USERNAME);  parameters.put(""username"", username);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element userElement = response.getPayload(); User user = new User(); user.setId(userElement.getAttribute(""nsid"")); user.setUsername(XMLUtilities.getChildValue(userElement, ""username"")); return user; }  /**
     * Get info about the specified user.
     * 
     * This method does not require authentication.
     * 
     * @param userId
     *            The user ID
     * @return The User object
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public User getInfo(String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO);  parameters.put(""user_id"", userId);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element userElement = response.getPayload(); User user = new User(); user.setId(userElement.getAttribute(""nsid"")); user.setAdmin(""1"".equals(userElement.getAttribute(""isadmin""))); user.setPro(""1"".equals(userElement.getAttribute(""ispro""))); user.setIconFarm(userElement.getAttribute(""iconfarm"")); user.setIconServer(userElement.getAttribute(""iconserver"")); user.setRevContact(""1"".equals(userElement.getAttribute(""revcontact""))); user.setRevFriend(""1"".equals(userElement.getAttribute(""revfriend""))); user.setRevFamily(""1"".equals(userElement.getAttribute(""revfamily""))); String lPathAlias = userElement.getAttribute(""path_alias""); user.setPathAlias(lPathAlias == null || """".equals(lPathAlias) ? null : lPathAlias); user.setUsername(XMLUtilities.getChildValue(userElement, ""username"")); user.setDescription(XMLUtilities.getChildValue(userElement, ""description"")); user.setGender(XMLUtilities.getChildValue(userElement, ""gender"")); user.setIgnored(""1"".equals(XMLUtilities.getChildValue(userElement, ""ignored""))); user.setContact(""1"".equals(XMLUtilities.getChildValue(userElement, ""contact""))); user.setFriend(""1"".equals(XMLUtilities.getChildValue(userElement, ""friend""))); user.setFamily(""1"".equals(XMLUtilities.getChildValue(userElement, ""family""))); user.setRealName(XMLUtilities.getChildValue(userElement, ""realname"")); user.setLocation(XMLUtilities.getChildValue(userElement, ""location"")); user.setMbox_sha1sum(XMLUtilities.getChildValue(userElement, ""mbox_sha1sum"")); user.setPhotosurl(XMLUtilities.getChildValue(userElement, ""photosurl"")); user.setProfileurl(XMLUtilities.getChildValue(userElement, ""profileurl"")); user.setMobileurl(XMLUtilities.getChildValue(userElement, ""mobileurl""));  Element photosElement = XMLUtilities.getChild(userElement, ""photos""); user.setPhotosFirstDate(XMLUtilities.getChildValue(photosElement, ""firstdate"")); user.setPhotosFirstDateTaken(XMLUtilities.getChildValue(photosElement, ""firstdatetaken"")); user.setPhotosCount(XMLUtilities.getChildValue(photosElement, ""count""));  NodeList tzNodes = userElement.getElementsByTagName(""timezone""); for (int i = 0; i < tzNodes.getLength(); i++) { Element tzElement = (Element) tzNodes.item(i); TimeZone tz = new TimeZone(); user.setTimeZone(tz); tz.setLabel(tzElement.getAttribute(""label"")); tz.setTimeZoneId(tzElement.getAttribute(""timezone_id"")); tz.setOffset(tzElement.getAttribute(""offset"")); }  return user; }  /**
     * Get a collection of public groups for the user.
     * 
     * The groups will contain only the members nsid, name, admin and eighteenplus. If you want the whole group-information, you have to call
     * {@link com.flickr4java.flickr.groups.GroupsInterface#getInfo(String)}.
     * 
     * This method does not require authentication.
     * 
     * @param userId
     *            The user ID
     * @return The public groups
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Collection<Group> getPublicGroups(String userId) throws FlickrException { List<Group> groups = new ArrayList<Group>();  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PUBLIC_GROUPS);  parameters.put(""user_id"", userId);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element groupsElement = response.getPayload(); NodeList groupNodes = groupsElement.getElementsByTagName(""group""); for (int i = 0; i < groupNodes.getLength(); i++) { Element groupElement = (Element) groupNodes.item(i); Group group = new Group(); group.setId(groupElement.getAttribute(""nsid"")); group.setName(groupElement.getAttribute(""name"")); group.setAdmin(""1"".equals(groupElement.getAttribute(""admin""))); group.setEighteenPlus(groupElement.getAttribute(""eighteenplus"").equals(""0"") ? false : true); groups.add(group); } return groups; }  public PhotoList<Photo> getPublicPhotos(String userId, int perPage, int page) throws FlickrException { return getPublicPhotos(userId, Extras.MIN_EXTRAS, perPage, page); }  /**
     * Get a collection of public photos for the specified user ID.
     * 
     * This method does not require authentication.
     * 
     * @see com.flickr4java.flickr.photos.Extras
     * @param userId
     *            The User ID
     * @param extras
     *            Set of extra-attributes to include (may be null)
     * @param perPage
     *            The number of photos per page
     * @param page
     *            The page offset
     * @return The PhotoList collection
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PhotoList<Photo> getPublicPhotos(String userId, Set<String> extras, int perPage, int page) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>();  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PUBLIC_PHOTOS);  parameters.put(""user_id"", userId);  if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); }  if (extras != null) { parameters.put(Extras.KEY_EXTRAS, StringUtilities.join(extras, "","")); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total""));  NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; }  /**
     * Get upload status for the currently authenticated user.
     * 
     * Requires authentication with 'read' permission using the new authentication API.
     * 
     * @return A User object with upload status data fields filled
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public User getUploadStatus() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_UPLOAD_STATUS);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element userElement = response.getPayload(); User user = new User(); user.setId(userElement.getAttribute(""id"")); user.setPro(""1"".equals(userElement.getAttribute(""ispro""))); user.setUsername(XMLUtilities.getChildValue(userElement, ""username""));  Element bandwidthElement = XMLUtilities.getChild(userElement, ""bandwidth""); user.setBandwidthMax(bandwidthElement.getAttribute(""max"")); user.setBandwidthUsed(bandwidthElement.getAttribute(""used"")); user.setIsBandwidthUnlimited(""1"".equals(bandwidthElement.getAttribute(""unlimited"")));  Element filesizeElement = XMLUtilities.getChild(userElement, ""filesize""); user.setFilesizeMax(filesizeElement.getAttribute(""max""));  Element setsElement = XMLUtilities.getChild(userElement, ""sets""); user.setSetsCreated(setsElement.getAttribute(""created"")); user.setSetsRemaining(setsElement.getAttribute(""remaining""));  Element videosElement = XMLUtilities.getChild(userElement, ""videos""); user.setVideosUploaded(videosElement.getAttribute(""uploaded"")); user.setVideosRemaining(videosElement.getAttribute(""remaining""));  Element videoSizeElement = XMLUtilities.getChild(userElement, ""videosize""); user.setVideoSizeMax(videoSizeElement.getAttribute(""maxbytes""));  return user; }  public PhotoList<Photo> getPhotos(String userId, String safeSearch, Date minUploadDate, Date maxUploadDate, Date minTakenDate, Date maxTakenDate,
            String contentType, String privacyFilter, Set<String> extras, int perPage, int page) throws FlickrException {  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PHOTOS);  parameters.put(""user_id"", userId); if (safeSearch != null) { parameters.put(""safe_search"", safeSearch); } if (minUploadDate != null) { parameters.put(""min_upload_date"", minUploadDate); } if (maxUploadDate != null) { parameters.put(""max_upload_date"", maxUploadDate); } if (minTakenDate != null) { parameters.put(""min_taken_date"", minTakenDate); } if (maxTakenDate != null) { parameters.put(""max_taken_date"", maxTakenDate); } if (contentType != null) { parameters.put(""content_type"", contentType); } if (privacyFilter != null) { parameters.put(""privacy_filter"", privacyFilter); } if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } if (extras != null) { parameters.put(Extras.KEY_EXTRAS, StringUtilities.join(extras, "","")); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element photosElement = response.getPayload(); PhotoList<Photo> photos = new PhotoList<Photo>(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total""));  NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; }  public PhotoList<Photo> getPhotosOf(String userId, String ownerId, Set<String> extras, int perPage, int page) throws FlickrException {  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PHOTOS_OF);  parameters.put(""user_id"", userId); if (ownerId != null) { parameters.put(""owner_id"", ownerId); } if (extras != null) { parameters.put(Extras.KEY_EXTRAS, StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element photosElement = response.getPayload(); PhotoList<Photo> photos = new PhotoList<Photo>(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPerPage(photosElement.getAttribute(""perpage""));  NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); Photo photo = new Photo(); photo.setId(photoElement.getAttribute(""id"")); photo.setSecret(photoElement.getAttribute(""secret""));  User owner = new User(); owner.setId(photoElement.getAttribute(""owner"")); photo.setOwner(owner); //flickr.com/photos/"" + owner.getId() + ""/"" + photo.getId()); photo.setServer(photoElement.getAttribute(""server"")); photo.setTitle(photoElement.getAttribute(""title"")); photo.setPublicFlag(""1"".equals(photoElement.getAttribute(""ispublic""))); photo.setFriendFlag(""1"".equals(photoElement.getAttribute(""isfriend""))); photo.setFamilyFlag(""1"".equals(photoElement.getAttribute(""isfamily""))); photos.add(photo); } return photos; }  /**
     * Add the given person to the photo. Optionally, send in co-ordinates
     * 
     * @param photoId
     * @param userId
     * @param bounds
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void add(String photoId, String userId, Rectangle bounds) throws FlickrException {  // Delegating this to photos.people.PeopleInterface - Naming standard would be to use PeopleInterface but having 2 the same name can cause issues com.flickr4java.flickr.photos.people.PeopleInterface pi = new com.flickr4java.flickr.photos.people.PeopleInterface(apiKey, sharedSecret, transportAPI); pi.add(photoId, userId, bounds); }  /**
     * Delete the person from the photo
     * 
     * @param photoId
     * @param userId
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void delete(String photoId, String userId) throws FlickrException {  // Delegating this to photos.people.PeopleInterface - Naming standard would be to use PeopleInterface but having 2 the same name can cause issues com.flickr4java.flickr.photos.people.PeopleInterface pi = new com.flickr4java.flickr.photos.people.PeopleInterface(apiKey, sharedSecret, transportAPI); pi.delete(photoId, userId); }  /**
     * Delete the co-ordinates that the user is shown in
     * 
     * @param photoId
     * @param userId
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void deleteCoords(String photoId, String userId) throws FlickrException {  // Delegating this to photos.people.PeopleInterface - Naming standard would be to use PeopleInterface but having 2 the same name can cause issues com.flickr4java.flickr.photos.people.PeopleInterface pi = new com.flickr4java.flickr.photos.people.PeopleInterface(apiKey, sharedSecret, transportAPI); pi.deleteCoords(photoId, userId); }  /**
     * Edit the co-ordinates that the user shows in
     * 
     * @param photoId
     * @param userId
     * @param bounds
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void editCoords(String photoId, String userId, Rectangle bounds) throws FlickrException {  // Delegating this to photos.people.PeopleInterface - Naming standard would be to use PeopleInterface but having 2 the same name can cause issues com.flickr4java.flickr.photos.people.PeopleInterface pi = new com.flickr4java.flickr.photos.people.PeopleInterface(apiKey, sharedSecret, transportAPI); pi.editCoords(photoId, userId, bounds); }  /**
     * Get a list of people in a given photo.
     * 
     * @param photoId
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PersonTagList<PersonTag> getList(String photoId) throws FlickrException {  // Delegating this to photos.people.PeopleInterface - Naming standard would be to use PeopleInterface but having 2 the same name can cause issues com.flickr4java.flickr.photos.people.PeopleInterface pi = new com.flickr4java.flickr.photos.people.PeopleInterface(apiKey, sharedSecret, transportAPI); return pi.getList(photoId); }  /**
     * 
     * @param userId
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public GroupList<Group> getGroups(String userId) throws FlickrException {  GroupList<Group> groupList = new GroupList<Group>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_GROUPS); parameters.put(""user_id"", userId);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element groupsElement = response.getPayload(); NodeList groupNodes = groupsElement.getElementsByTagName(""group""); groupList.setPage(XMLUtilities.getIntAttribute(groupsElement, ""page"")); groupList.setPages(XMLUtilities.getIntAttribute(groupsElement, ""pages"")); groupList.setPerPage(XMLUtilities.getIntAttribute(groupsElement, ""perpage"")); groupList.setTotal(XMLUtilities.getIntAttribute(groupsElement, ""total"")); for (int i = 0; i < groupNodes.getLength(); i++) { Element groupElement = (Element) groupNodes.item(i); Group group = new Group(); group.setId(groupElement.getAttribute(""nsid"")); group.setName(groupElement.getAttribute(""name"")); group.setAdmin(""1"".equals(groupElement.getAttribute(""admin""))); group.setEighteenPlus(""1"".equals(groupElement.getAttribute(""eighteenplus""))); group.setInvitationOnly(""1"".equals(groupElement.getAttribute(""invitation_only""))); group.setMembers(groupElement.getAttribute(""members"")); group.setPhotoCount(groupElement.getAttribute(""pool_count"")); groupList.add(group); } return groupList;  }  /**
     * Get's the user's current upload limits, User object only contains user_id
     * 
     * @return Media Limits
     */  public User getLimits() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIMITS);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element userElement = response.getPayload(); User user = new User(); user.setId(userElement.getAttribute(""nsid"")); NodeList photoNodes = userElement.getElementsByTagName(""photos""); for (int i = 0; i < photoNodes.getLength(); i++) { Element plElement = (Element) photoNodes.item(i); PhotoLimits pl = new PhotoLimits(); user.setPhotoLimits(pl); pl.setMaxDisplay(plElement.getAttribute(""maxdisplaypx"")); pl.setMaxUpload(plElement.getAttribute(""maxupload"")); } NodeList videoNodes = userElement.getElementsByTagName(""videos""); for (int i = 0; i < videoNodes.getLength(); i++) { Element vlElement = (Element) videoNodes.item(i); VideoLimits vl = new VideoLimits(); user.setPhotoLimits(vl); vl.setMaxDuration(vlElement.getAttribute(""maxduration"")); vl.setMaxUpload(vlElement.getAttribute(""maxupload"")); } return user; }  }  "
src/main/java/com/flickr4java/flickr/people/PersonTag.java,"package com.flickr4java.flickr.people;

public class PersonTag {
	
	private String id;

	private String username;
	
	private String realName;
	
    private int iconFarm;

    private int iconServer;
    
    private String pathAlias;
	
	private String addedById;
	    
    private int x;
    
    private int y;
    
    private int w;
    
    private int h;

	public String getId() {
		return id;
	}

	public void setId(String id) {
		this.id = id;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getRealName() {
		return realName;
	}

	public void setRealName(String realName) {
		this.realName = realName;
	}

	public int getIconFarm() {
		return iconFarm;
	}

	public void setIconFarm(int iconFarm) {
		this.iconFarm = iconFarm;
	}

	public int getIconServer() {
		return iconServer;
	}

	public void setIconServer(int iconServer) {
		this.iconServer = iconServer;
	}
	
	/**
	 * @return the user_id of the user who added the person
	 */
	public String getAddedById() {
		return addedById;
	}

	/**
	 * @param addedById the user_id who added the person
	 */
	public void setAddedById(String addedById) {
		this.addedById = addedById;
	}

	/**
	 * @return the x coordinate of the bounding box around the person
	 */
	public int getX() {
		return x;
	}

	/**
	 * @param x the x to set the coordinate of the bounding box around the person
	 */
	public void setX(int x) {
		this.x = x;
	}

	/**
	 * @return the y coordinate of the bounding box around the person
	 */
	public int getY() {
		return y;
	}

	/**
	 * @param y the y to set the coordinate of the bounding box around the person
	 */
	public void setY(int y) {
		this.y = y;
	}

	/**
	 * @return the w coordinate of the bounding box around the person
	 */
	public int getW() {
		return w;
	}

	/**
	 * @param w the w to set the coordinate of the bounding box around the person
	 */
	public void setW(int w) {
		this.w = w;
	}

	/**
	 * @return the h coordinate of the bounding box around the person
	 */
	public int getH() {
		return h;
	}

	/**
	 * @param h the h to set the coordinate of the bounding box around the person
	 */
	public void setH(int h) {
		this.h = h;
	}

	public String getPathAlias() {
		return pathAlias;
	}

	public void setPathAlias(String pathAlias) {
		this.pathAlias = pathAlias;
	}

}
",package com.flickr4java.flickr.people; public class PersonTag { private String id; private String username; private String realName; private int iconFarm; private int iconServer; private String pathAlias; private String addedById; private int x; private int y; private int w; private int h; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getRealName() { return realName; } public void setRealName(String realName) { this.realName = realName; } public int getIconFarm() { return iconFarm; } public void setIconFarm(int iconFarm) { this.iconFarm = iconFarm; } public int getIconServer() { return iconServer; } public void setIconServer(int iconServer) { this.iconServer = iconServer; } public String getAddedById() { return addedById; } public void setAddedById(String addedById) { this.addedById = addedById; } public int getX() { return x; } public void setX(int x) { this.x = x; } public int getY() { return y; } public void setY(int y) { this.y = y; } public int getW() { return w; } public void setW(int w) { this.w = w; } public int getH() { return h; } public void setH(int h) { this.h = h; } public String getPathAlias() { return pathAlias; } public void setPathAlias(String pathAlias) { this.pathAlias = pathAlias; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.people; public class PersonTag { private String id; private String username; private String realName; private int iconFarm; private int iconServer; private String pathAlias; private String addedById; private int x; private int y; private int w; private int h; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getRealName() { return realName; } public void setRealName(String realName) { this.realName = realName; } public int getIconFarm() { return iconFarm; } public void setIconFarm(int iconFarm) { this.iconFarm = iconFarm; } public int getIconServer() { return iconServer; } public void setIconServer(int iconServer) { this.iconServer = iconServer; } public String getAddedById() { return addedById; } public void setAddedById(String addedById) { this.addedById = addedById; } public int getX() { return x; } public void setX(int x) { this.x = x; } public int getY() { return y; } public void setY(int y) { this.y = y; } public int getW() { return w; } public void setW(int w) { this.w = w; } public int getH() { return h; } public void setH(int h) { this.h = h; } public String getPathAlias() { return pathAlias; } public void setPathAlias(String pathAlias) { this.pathAlias = pathAlias; } } ,"package com.flickr4java.flickr.people;  public class PersonTag { 	 private String id;  private String username; 	 private String realName; 	 private int iconFarm;  private int iconServer;      private String pathAlias; 	 private String addedById; 	     private int x;      private int y;      private int w;      private int h;  public String getId() { return id; }  public void setId(String id) { this.id = id; }  public String getUsername() { return username; }  public void setUsername(String username) { this.username = username; }  public String getRealName() { return realName; }  public void setRealName(String realName) { this.realName = realName; }  public int getIconFarm() { return iconFarm; }  public void setIconFarm(int iconFarm) { this.iconFarm = iconFarm; }  public int getIconServer() { return iconServer; }  public void setIconServer(int iconServer) { this.iconServer = iconServer; } 	 /**
	 * @return the user_id of the user who added the person
	 */ public String getAddedById() { return addedById; }  /**
	 * @param addedById the user_id who added the person
	 */ public void setAddedById(String addedById) { this.addedById = addedById; }  /**
	 * @return the x coordinate of the bounding box around the person
	 */ public int getX() { return x; }  /**
	 * @param x the x to set the coordinate of the bounding box around the person
	 */ public void setX(int x) { this.x = x; }  /**
	 * @return the y coordinate of the bounding box around the person
	 */ public int getY() { return y; }  /**
	 * @param y the y to set the coordinate of the bounding box around the person
	 */ public void setY(int y) { this.y = y; }  /**
	 * @return the w coordinate of the bounding box around the person
	 */ public int getW() { return w; }  /**
	 * @param w the w to set the coordinate of the bounding box around the person
	 */ public void setW(int w) { this.w = w; }  /**
	 * @return the h coordinate of the bounding box around the person
	 */ public int getH() { return h; }  /**
	 * @param h the h to set the coordinate of the bounding box around the person
	 */ public void setH(int h) { this.h = h; }  public String getPathAlias() { return pathAlias; }  public void setPathAlias(String pathAlias) { this.pathAlias = pathAlias; }  }  "
src/main/java/com/flickr4java/flickr/people/PersonTagList.java,"package com.flickr4java.flickr.people;

import java.util.ArrayList;

public class PersonTagList<E> extends ArrayList<PersonTag> {

	/**
	 * 
	 */
	private static final long serialVersionUID = -1841985011941978229L;
	
	private int total;
	private int height;
	private int width;
	
	public int getTotal() {
		return total;
	}
	public void setTotal(int total) {
		this.total = total;
	}
	public int getHeight() {
		return height;
	}
	public void setHeight(int height) {
		this.height = height;
	}
	public int getWidth() {
		return width;
	}
	public void setWidth(int width) {
		this.width = width;
	}
	
	

}
",package com.flickr4java.flickr.people; import java.util.ArrayList; public class PersonTagList<E> extends ArrayList<PersonTag> { private static final long serialVersionUID = -1841985011941978229L; private int total; private int height; private int width; public int getTotal() { return total; } public void setTotal(int total) { this.total = total; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.people; import java.util.ArrayList; public class PersonTagList<E> extends ArrayList<PersonTag> { private static final long serialVersionUID = -1841985011941978229L; private int total; private int height; private int width; public int getTotal() { return total; } public void setTotal(int total) { this.total = total; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } } ,"package com.flickr4java.flickr.people;  import java.util.ArrayList;  public class PersonTagList<E> extends ArrayList<PersonTag> {  /**
	 * 
	 */ private static final long serialVersionUID = -1841985011941978229L; 	 private int total; private int height; private int width; 	 public int getTotal() { return total; } public void setTotal(int total) { this.total = total; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } 	
	
 }  "
src/main/java/com/flickr4java/flickr/people/PhotoLimits.java,"package com.flickr4java.flickr.people;

public class PhotoLimits {
	

	private String maxDisplay;
	private String maxUpload;
	
	/**
     * Maximum photo display pixels
     * 
     * @return String max pixels
     */
	
	public String getMaxDisplay(){
		return maxDisplay;
	}
	
	public void setMaxDisplay(String maxDisplay){
		this.maxDisplay = maxDisplay;
	}
	
	 /**
     * Maximum photo upload
     * 
     * @return String upload capacity
     */
	
	
	public String getMaxUpload(){
		return maxUpload;
	}
	
	public void setMaxUpload(String maxUpload){
		this.maxUpload = maxUpload;
	}

}
",package com.flickr4java.flickr.people; public class PhotoLimits { private String maxDisplay; private String maxUpload; public String getMaxDisplay(){ return maxDisplay; } public void setMaxDisplay(String maxDisplay){ this.maxDisplay = maxDisplay; } public String getMaxUpload(){ return maxUpload; } public void setMaxUpload(String maxUpload){ this.maxUpload = maxUpload; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.people; public class PhotoLimits { private String maxDisplay; private String maxUpload; public String getMaxDisplay(){ return maxDisplay; } public void setMaxDisplay(String maxDisplay){ this.maxDisplay = maxDisplay; } public String getMaxUpload(){ return maxUpload; } public void setMaxUpload(String maxUpload){ this.maxUpload = maxUpload; } } ,"package com.flickr4java.flickr.people;  public class PhotoLimits { 	
 private String maxDisplay; private String maxUpload; 	 /**
     * Maximum photo display pixels
     * 
     * @return String max pixels
     */ 	 public String getMaxDisplay(){ return maxDisplay; } 	 public void setMaxDisplay(String maxDisplay){ this.maxDisplay = maxDisplay; } 	 /**
     * Maximum photo upload
     * 
     * @return String upload capacity
     */ 	
	 public String getMaxUpload(){ return maxUpload; } 	 public void setMaxUpload(String maxUpload){ this.maxUpload = maxUpload; }  }  "
src/main/java/com/flickr4java/flickr/people/TimeZone.java,"package com.flickr4java.flickr.people;

public class TimeZone {

    private String label;

    private String offset;

    private String timeZoneId;

    /**
     * Time Zone text
     * 
     * @return the label
     */
    public String getLabel() {
        return label;
    }

    public void setLabel(String label) {
        this.label = label;
    }

    /**
     * Time Zone offset
     * 
     * @return timezone offset value
     */
    public String getOffset() {
        return offset;
    }

    /**
     * @deprecated typo in method name, use {@link #getOffset()}.
     */
    @Deprecated
    public String geOffset() {
        return offset;
    }

    public void setOffset(String offset) {
        this.offset = offset;
    }

    /**
     * Time Zone id
     * 
     * @return timezone_id offset value
     */
    public String getTimeZoneId() {
        return timeZoneId;
    }

    public void setTimeZoneId(String id) {
        this.timeZoneId = id;
    }

}
","package com.flickr4java.flickr.people; public class TimeZone { private String label; private String offset; private String timeZoneId; public String getLabel() { return label; } public void setLabel(String label) { this.label = label; } public String getOffset() { return offset; } @Deprecated
    public String geOffset() { return offset; } public void setOffset(String offset) { this.offset = offset; } public String getTimeZoneId() { return timeZoneId; } public void setTimeZoneId(String id) { this.timeZoneId = id; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.people; public class TimeZone { private String label; private String offset; private String timeZoneId; public String getLabel() { return label; } public void setLabel(String label) { this.label = label; } public String getOffset() { return offset; } @Deprecated
    public String geOffset() { return offset; } public void setOffset(String offset) { this.offset = offset; } public String getTimeZoneId() { return timeZoneId; } public void setTimeZoneId(String id) { this.timeZoneId = id; } } ","package com.flickr4java.flickr.people;  public class TimeZone {  private String label;  private String offset;  private String timeZoneId;  /**
     * Time Zone text
     * 
     * @return the label
     */ public String getLabel() { return label; }  public void setLabel(String label) { this.label = label; }  /**
     * Time Zone offset
     * 
     * @return timezone offset value
     */ public String getOffset() { return offset; }  /**
     * @deprecated typo in method name, use {@link #getOffset()}.
     */ @Deprecated
    public String geOffset() { return offset; }  public void setOffset(String offset) { this.offset = offset; }  /**
     * Time Zone id
     * 
     * @return timezone_id offset value
     */ public String getTimeZoneId() { return timeZoneId; }  public void setTimeZoneId(String id) { this.timeZoneId = id; }  }  "
src/main/java/com/flickr4java/flickr/people/User.java,"
package com.flickr4java.flickr.people;

import com.flickr4java.flickr.contacts.OnlineStatus;
import com.flickr4java.flickr.util.BuddyIconable;
import com.flickr4java.flickr.util.UrlUtilities;

import java.io.Serializable;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * @author Anthony Eden
 * @version $Id: User.java,v 1.23 2010/09/12 20:13:57 x-mago Exp $
 */
public class User implements Serializable, BuddyIconable {
    private static final long serialVersionUID = 12L;

    private static final ThreadLocal<SimpleDateFormat> DATE_FORMATS = new ThreadLocal<SimpleDateFormat>() {
        @Override
        protected synchronized SimpleDateFormat initialValue() {
            return new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
        }
    };

    private String id;

    private String username;

    private String description;

    private String gender;

    private boolean ignored;

    private boolean contact;

    private boolean friend;

    private boolean family;

    private boolean admin;

    private boolean pro;

    private int iconFarm;

    private int iconServer;

    private String realName;

    private String location;

    private TimeZone timeZone;

    private Date photosFirstDate;

    private Date photosFirstDateTaken;

    private Date faveDate;

    private int photosCount;

    private OnlineStatus online;

    private String awayMessage;

    private long bandwidthMax;

    private long bandwidthUsed;

    private Boolean bandwidthUnlimited;

    private String setsCreated;

    private String setsRemaining;

    private String videosUploaded;

    private String videosRemaining;

    private String videoSizeMax;

    private long filesizeMax;

    private String mbox_sha1sum;

    private String photosurl;

    private String profileurl;

    private String mobileurl;

    private boolean revContact;

    private boolean revFriend;

    private boolean revFamily;

    private String pathAlias;

    private PhotoLimits photoLimits;

    private VideoLimits videoLimits;

    public User() {
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    /**
     * @return the description
     */
    public String getDescription() {
        return description;
    }

    /**
     * @param description
     *            the description to set
     */
    public void setDescription(String description) {
        this.description = description;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public boolean isIgnored() {
        return ignored;
    }

    public void setIgnored(boolean ignored) {
        this.ignored = ignored;
    }

    public boolean isContact() {
        return contact;
    }

    public void setContact(boolean contact) {
        this.contact = contact;
    }

    public boolean isFriend() {
        return friend;
    }

    public void setFriend(boolean friend) {
        this.friend = friend;
    }

    public boolean isFamily() {
        return family;
    }

    public void setFamily(boolean family) {
        this.family = family;
    }

    public boolean isAdmin() {
        return admin;
    }

    public void setAdmin(boolean admin) {
        this.admin = admin;
    }

    public boolean isPro() {
        return pro;
    }

    public void setPro(boolean pro) {
        this.pro = pro;
    }

    @Override
    public int getIconFarm() {
        return iconFarm;
    }

    @Override
    public void setIconFarm(int iconFarm) {
        this.iconFarm = iconFarm;
    }

    @Override
    public void setIconFarm(String iconFarm) {
        if (iconFarm != null) {
            setIconFarm(Integer.parseInt(iconFarm));
        }
    }

    @Override
    public int getIconServer() {
        return iconServer;
    }

    @Override
    public void setIconServer(int iconServer) {
        this.iconServer = iconServer;
    }

    @Override
    public void setIconServer(String iconServer) {
        if (iconServer != null) {
            setIconServer(Integer.parseInt(iconServer));
        }
    }

    public String getRealName() {
        return realName;
    }

    public void setRealName(String realName) {
        this.realName = realName;
    }

    public TimeZone getTimeZone() {
        return timeZone;
    }

    public TimeZone setTimeZone(TimeZone string) {
        return this.timeZone = string;
    }

    /**
     * Construct the BuddyIconUrl.
     * <p>
     * If none available, return the <a href=""http://www.flickr.com/images/buddyicon.jpg"">default</a>, or an URL assembled from farm, iconserver and nsid.
     * 
     * @see <a href=""http://flickr.com/services/api/misc.buddyicons.html"">Flickr Documentation</a>
     * @return The BuddyIconUrl
     * @deprecated use {@link #getSecureBuddyIconUrl() }
     */
    @Override
    @Deprecated
    public String getBuddyIconUrl() {
        return UrlUtilities.createBuddyIconUrl(iconFarm, iconServer, id);
    }

    public String getLocation() {
        return location;
    }

    /**
     * Construct the BuddyIconUrl using {@code https} scheme.
     * <p>
     * If none available, return the <a href=""https://www.flickr.com/images/buddyicon.jpg"">default</a>, or an URL assembled from farm, iconserver and nsid.
     * 
     * @see <a href=""http://flickr.com/services/api/misc.buddyicons.html"">Flickr Documentation</a>
     * @return The BuddyIconUrl
     */
    public String getSecureBuddyIconUrl() {
        return UrlUtilities.createSecureBuddyIconUrl(iconFarm, iconServer, id);
    }

    public void setLocation(String location) {
        this.location = location;
    }

    public Date getPhotosFirstDate() {
        return photosFirstDate;
    }

    public void setPhotosFirstDate(Date photosFirstDate) {
        this.photosFirstDate = photosFirstDate;
    }

    public void setPhotosFirstDate(long photosFirstDate) {
        setPhotosFirstDate(new Date(photosFirstDate));
    }

    public void setPhotosFirstDate(String photosFirstDate) {
        if (photosFirstDate != null) {
            setPhotosFirstDate(Long.parseLong(photosFirstDate) * 1000);
        }
    }

    public Date getPhotosFirstDateTaken() {
        return photosFirstDateTaken;
    }

    public void setPhotosFirstDateTaken(Date photosFirstDateTaken) {
        this.photosFirstDateTaken = photosFirstDateTaken;
    }

    public void setPhotosFirstDateTaken(String photosFirstDateTaken) {
        if (photosFirstDateTaken != null) {
            try {
                setPhotosFirstDateTaken(((DateFormat) DATE_FORMATS.get()).parse(photosFirstDateTaken));
            } catch (ParseException e) {
                throw new RuntimeException(e);
            }
        }
    }

    public void setFaveDate(String faveDate) {
        setFaveDate(Long.parseLong(faveDate) * 1000);
    }

    public void setFaveDate(long faveDate) {
        setFaveDate(new Date(faveDate));
    }

    /**
     * Date when User has faved a Photo.<br>
     * flickr.photos.getFavorites returns person-data where this Date will be set.
     * 
     * @param faveDate
     */
    public void setFaveDate(Date faveDate) {
        this.faveDate = faveDate;
    }

    /**
     * The Date, when a User has favourited a Photo.<br>
     * This value is set, when a User is created by {@link com.flickr4java.flickr.photos.PhotosInterface#getFavorites(String, int, int)}.
     * 
     * @return faveDate
     */
    public Date getFaveDate() {
        return faveDate;
    }

    public int getPhotosCount() {
        return photosCount;
    }

    public void setPhotosCount(int photosCount) {
        this.photosCount = photosCount;
    }

    public void setPhotosCount(String photosCount) {
        if (photosCount != null) {
            setPhotosCount(Integer.parseInt(photosCount));
        }
    }

    public OnlineStatus getOnline() {
        return online;
    }

    public void setOnline(OnlineStatus online) {
        this.online = online;
    }

    public String getAwayMessage() {
        return awayMessage;
    }

    public void setAwayMessage(String awayMessage) {
        this.awayMessage = awayMessage;
    }

    public long getBandwidthMax() {
        return bandwidthMax;
    }

    public void setBandwidthMax(long bandwidthMax) {
        this.bandwidthMax = bandwidthMax;
    }

    public void setBandwidthMax(String bandwidthMax) {
        if (bandwidthMax != null) {
            setBandwidthMax(Long.parseLong(bandwidthMax));
        }
    }

    public long getBandwidthUsed() {
        return bandwidthUsed;
    }

    public void setBandwidthUsed(long bandwidthUsed) {
        this.bandwidthUsed = bandwidthUsed;
    }

    public void setBandwidthUsed(String bandwidthUsed) {
        if (bandwidthUsed != null) {
            setBandwidthUsed(Long.parseLong(bandwidthUsed));
        }
    }

    public long getFilesizeMax() {
        return filesizeMax;
    }

    public void setFilesizeMax(long filesizeMax) {
        this.filesizeMax = filesizeMax;
    }

    public void setFilesizeMax(String filesizeMax) {
        if (filesizeMax != null) {
            setFilesizeMax(Long.parseLong(filesizeMax));
        }
    }

    public void setMbox_sha1sum(String mbox_sha1sum) {
        this.mbox_sha1sum = mbox_sha1sum;
    }

    public String getMbox_sha1sum() {
        return this.mbox_sha1sum;
    }

    @Override
    public boolean equals(Object obj) {
        if ((obj == null) || (obj.getClass() != this.getClass())) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        User test = (User) obj;
        return id == null ? test.id == null : id.equals(test.id);
    }

    @Override
    public int hashCode() {
        int hash = 83;
        if (id != null) {
            hash ^= id.hashCode();
        }
        return hash;
    }

    /**
     * @return the photosurl
     */
    public String getPhotosurl() {
        return photosurl;
    }

    /**
     * @param photosurl
     *            the photosurl to set
     */
    public void setPhotosurl(String photosurl) {
        this.photosurl = photosurl;
    }

    /**
     * @return the profileurl
     */
    public String getProfileurl() {
        return profileurl;
    }

    /**
     * @param profileurl
     *            the profileurl to set
     */
    public void setProfileurl(String profileurl) {
        this.profileurl = profileurl;
    }

    /**
     * @return the mobileurl
     */
    public String getMobileurl() {
        return mobileurl;
    }

    /**
     * @param mobileurl
     *            the mobileurl to set
     */
    public void setMobileurl(String mobileurl) {
        this.mobileurl = mobileurl;
    }

    public void setRevContact(boolean revContact) {
        this.revContact = revContact;
    }

    public boolean isRevContact() {
        return revContact;
    }

    public void setRevFriend(boolean revFriend) {
        this.revFriend = revFriend;
    }

    public boolean isRevFriend() {
        return revFriend;
    }

    public void setRevFamily(boolean revFamily) {
        this.revFamily = revFamily;
    }

    public boolean isRevFamily() {
        return revFamily;
    }

    /**
     * Get the user's path alias, which may appear instead of nsid in urls published by Flickr. For example feeds have urls of the form
     * .../photos/${NSID_OR_PATHALIAS}/${PHOTO_ID} and .../people/${NSID_OR_PATHALIAS}. This allows clients to look up a {@link User} given such a url. (Note that
     * <code>&lt;author&gt;</code> elements in feeds have a <code>&lt;flickr:nsid&gt;</code> child which could be used instead of the lookup this method
     * enables.)
     * 
     * @return the path alias, or null
     */
    public String getPathAlias() {
        return pathAlias;
    }

    public void setPathAlias(String pathAlias) {
        this.pathAlias = pathAlias;
    }

    /**
     * @return PhotoLimits class instance
     */
    public PhotoLimits getPhotoLimits() {
        return photoLimits;
    }

    public void setPhotoLimits(PhotoLimits photoLimits) {
        this.photoLimits = photoLimits;
    }

    /**
     * @return VideoLimits class instance
     */
    public VideoLimits getVideoLimits() {
        return videoLimits;
    }

    public void setPhotoLimits(VideoLimits videoLimits) {
        this.videoLimits = videoLimits;
    }

    public Boolean isBandwidthUnlimited() {
        return bandwidthUnlimited;
    }

    public void setIsBandwidthUnlimited(Boolean bandwidthUnlimited) {
        this.bandwidthUnlimited = bandwidthUnlimited;
    }

    public String getSetsCreated() {
        return setsCreated;
    }

    public void setSetsCreated(String setsCreated) {
        this.setsCreated = setsCreated;
    }

    public String getSetsRemaining() {
        return setsRemaining;
    }

    public void setSetsRemaining(String setsRemaining) {
        this.setsRemaining = setsRemaining;
    }

    public String getVideosUploaded() {
        return videosUploaded;
    }

    public void setVideosUploaded(String videosUploaded) {
        this.videosUploaded = videosUploaded;
    }

    public String getVideosRemaining() {
        return videosRemaining;
    }

    public void setVideosRemaining(String videosRemaining) {
        this.videosRemaining = videosRemaining;
    }

    public String getVideosSizeMax() {
        return videoSizeMax;
    }

    public void setVideoSizeMax(String videoSizeMax) {
        this.videoSizeMax = videoSizeMax;
    }

}
","package com.flickr4java.flickr.people; import com.flickr4java.flickr.contacts.OnlineStatus; import com.flickr4java.flickr.util.BuddyIconable; import com.flickr4java.flickr.util.UrlUtilities; import java.io.Serializable; import java.text.DateFormat; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class User implements Serializable, BuddyIconable { private static final long serialVersionUID = 12L; private static final ThreadLocal<SimpleDateFormat> DATE_FORMATS = new ThreadLocal<SimpleDateFormat>() { @Override
        protected synchronized SimpleDateFormat initialValue() { return new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); } } ; private String id; private String username; private String description; private String gender; private boolean ignored; private boolean contact; private boolean friend; private boolean family; private boolean admin; private boolean pro; private int iconFarm; private int iconServer; private String realName; private String location; private TimeZone timeZone; private Date photosFirstDate; private Date photosFirstDateTaken; private Date faveDate; private int photosCount; private OnlineStatus online; private String awayMessage; private long bandwidthMax; private long bandwidthUsed; private Boolean bandwidthUnlimited; private String setsCreated; private String setsRemaining; private String videosUploaded; private String videosRemaining; private String videoSizeMax; private long filesizeMax; private String mbox_sha1sum; private String photosurl; private String profileurl; private String mobileurl; private boolean revContact; private boolean revFriend; private boolean revFamily; private String pathAlias; private PhotoLimits photoLimits; private VideoLimits videoLimits; public User() { } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public String getGender() { return gender; } public void setGender(String gender) { this.gender = gender; } public boolean isIgnored() { return ignored; } public void setIgnored(boolean ignored) { this.ignored = ignored; } public boolean isContact() { return contact; } public void setContact(boolean contact) { this.contact = contact; } public boolean isFriend() { return friend; } public void setFriend(boolean friend) { this.friend = friend; } public boolean isFamily() { return family; } public void setFamily(boolean family) { this.family = family; } public boolean isAdmin() { return admin; } public void setAdmin(boolean admin) { this.admin = admin; } public boolean isPro() { return pro; } public void setPro(boolean pro) { this.pro = pro; } @Override
    public int getIconFarm() { return iconFarm; } @Override
    public void setIconFarm(int iconFarm) { this.iconFarm = iconFarm; } @Override
    public void setIconFarm(String iconFarm) { if (iconFarm != null) { setIconFarm(Integer.parseInt(iconFarm)); } } @Override
    public int getIconServer() { return iconServer; } @Override
    public void setIconServer(int iconServer) { this.iconServer = iconServer; } @Override
    public void setIconServer(String iconServer) { if (iconServer != null) { setIconServer(Integer.parseInt(iconServer)); } } public String getRealName() { return realName; } public void setRealName(String realName) { this.realName = realName; } public TimeZone getTimeZone() { return timeZone; } public TimeZone setTimeZone(TimeZone string) { return this.timeZone = string; } @Override
    @Deprecated
    public String getBuddyIconUrl() { return UrlUtilities.createBuddyIconUrl(iconFarm, iconServer, id); } public String getLocation() { return location; } public String getSecureBuddyIconUrl() { return UrlUtilities.createSecureBuddyIconUrl(iconFarm, iconServer, id); } public void setLocation(String location) { this.location = location; } public Date getPhotosFirstDate() { return photosFirstDate; } public void setPhotosFirstDate(Date photosFirstDate) { this.photosFirstDate = photosFirstDate; } public void setPhotosFirstDate(long photosFirstDate) { setPhotosFirstDate(new Date(photosFirstDate)); } public void setPhotosFirstDate(String photosFirstDate) { if (photosFirstDate != null) { setPhotosFirstDate(Long.parseLong(photosFirstDate) * 1000); } } public Date getPhotosFirstDateTaken() { return photosFirstDateTaken; } public void setPhotosFirstDateTaken(Date photosFirstDateTaken) { this.photosFirstDateTaken = photosFirstDateTaken; } public void setPhotosFirstDateTaken(String photosFirstDateTaken) { if (photosFirstDateTaken != null) { try { setPhotosFirstDateTaken(((DateFormat) DATE_FORMATS.get()).parse(photosFirstDateTaken)); } catch (ParseException e) { throw new RuntimeException(e); } } } public void setFaveDate(String faveDate) { setFaveDate(Long.parseLong(faveDate) * 1000); } public void setFaveDate(long faveDate) { setFaveDate(new Date(faveDate)); } public void setFaveDate(Date faveDate) { this.faveDate = faveDate; } public Date getFaveDate() { return faveDate; } public int getPhotosCount() { return photosCount; } public void setPhotosCount(int photosCount) { this.photosCount = photosCount; } public void setPhotosCount(String photosCount) { if (photosCount != null) { setPhotosCount(Integer.parseInt(photosCount)); } } public OnlineStatus getOnline() { return online; } public void setOnline(OnlineStatus online) { this.online = online; } public String getAwayMessage() { return awayMessage; } public void setAwayMessage(String awayMessage) { this.awayMessage = awayMessage; } public long getBandwidthMax() { return bandwidthMax; } public void setBandwidthMax(long bandwidthMax) { this.bandwidthMax = bandwidthMax; } public void setBandwidthMax(String bandwidthMax) { if (bandwidthMax != null) { setBandwidthMax(Long.parseLong(bandwidthMax)); } } public long getBandwidthUsed() { return bandwidthUsed; } public void setBandwidthUsed(long bandwidthUsed) { this.bandwidthUsed = bandwidthUsed; } public void setBandwidthUsed(String bandwidthUsed) { if (bandwidthUsed != null) { setBandwidthUsed(Long.parseLong(bandwidthUsed)); } } public long getFilesizeMax() { return filesizeMax; } public void setFilesizeMax(long filesizeMax) { this.filesizeMax = filesizeMax; } public void setFilesizeMax(String filesizeMax) { if (filesizeMax != null) { setFilesizeMax(Long.parseLong(filesizeMax)); } } public void setMbox_sha1sum(String mbox_sha1sum) { this.mbox_sha1sum = mbox_sha1sum; } public String getMbox_sha1sum() { return this.mbox_sha1sum; } @Override
    public boolean equals(Object obj) { if ((obj == null) || (obj.getClass() != this.getClass())) { return false; } if (obj == this) { return true; } User test = (User) obj; return id == null ? test.id == null : id.equals(test.id); } @Override
    public int hashCode() { int hash = 83; if (id != null) { hash ^= id.hashCode(); } return hash; } public String getPhotosurl() { return photosurl; } public void setPhotosurl(String photosurl) { this.photosurl = photosurl; } public String getProfileurl() { return profileurl; } public void setProfileurl(String profileurl) { this.profileurl = profileurl; } public String getMobileurl() { return mobileurl; } public void setMobileurl(String mobileurl) { this.mobileurl = mobileurl; } public void setRevContact(boolean revContact) { this.revContact = revContact; } public boolean isRevContact() { return revContact; } public void setRevFriend(boolean revFriend) { this.revFriend = revFriend; } public boolean isRevFriend() { return revFriend; } public void setRevFamily(boolean revFamily) { this.revFamily = revFamily; } public boolean isRevFamily() { return revFamily; } public String getPathAlias() { return pathAlias; } public void setPathAlias(String pathAlias) { this.pathAlias = pathAlias; } public PhotoLimits getPhotoLimits() { return photoLimits; } public void setPhotoLimits(PhotoLimits photoLimits) { this.photoLimits = photoLimits; } public VideoLimits getVideoLimits() { return videoLimits; } public void setPhotoLimits(VideoLimits videoLimits) { this.videoLimits = videoLimits; } public Boolean isBandwidthUnlimited() { return bandwidthUnlimited; } public void setIsBandwidthUnlimited(Boolean bandwidthUnlimited) { this.bandwidthUnlimited = bandwidthUnlimited; } public String getSetsCreated() { return setsCreated; } public void setSetsCreated(String setsCreated) { this.setsCreated = setsCreated; } public String getSetsRemaining() { return setsRemaining; } public void setSetsRemaining(String setsRemaining) { this.setsRemaining = setsRemaining; } public String getVideosUploaded() { return videosUploaded; } public void setVideosUploaded(String videosUploaded) { this.videosUploaded = videosUploaded; } public String getVideosRemaining() { return videosRemaining; } public void setVideosRemaining(String videosRemaining) { this.videosRemaining = videosRemaining; } public String getVideosSizeMax() { return videoSizeMax; } public void setVideoSizeMax(String videoSizeMax) { this.videoSizeMax = videoSizeMax; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.people; import com.flickr4java.flickr.contacts.OnlineStatus; import com.flickr4java.flickr.util.BuddyIconable; import com.flickr4java.flickr.util.UrlUtilities; import java.io.Serializable; import java.text.DateFormat; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class User implements Serializable, BuddyIconable { private static final long serialVersionUID = 12L; private static final ThreadLocal<SimpleDateFormat> DATE_FORMATS = new ThreadLocal<SimpleDateFormat>() { @Override
        protected synchronized SimpleDateFormat initialValue() { return new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); } } ; private String id; private String username; private String description; private String gender; private boolean ignored; private boolean contact; private boolean friend; private boolean family; private boolean admin; private boolean pro; private int iconFarm; private int iconServer; private String realName; private String location; private TimeZone timeZone; private Date photosFirstDate; private Date photosFirstDateTaken; private Date faveDate; private int photosCount; private OnlineStatus online; private String awayMessage; private long bandwidthMax; private long bandwidthUsed; private Boolean bandwidthUnlimited; private String setsCreated; private String setsRemaining; private String videosUploaded; private String videosRemaining; private String videoSizeMax; private long filesizeMax; private String mbox_sha1sum; private String photosurl; private String profileurl; private String mobileurl; private boolean revContact; private boolean revFriend; private boolean revFamily; private String pathAlias; private PhotoLimits photoLimits; private VideoLimits videoLimits; public User() { } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public String getGender() { return gender; } public void setGender(String gender) { this.gender = gender; } public boolean isIgnored() { return ignored; } public void setIgnored(boolean ignored) { this.ignored = ignored; } public boolean isContact() { return contact; } public void setContact(boolean contact) { this.contact = contact; } public boolean isFriend() { return friend; } public void setFriend(boolean friend) { this.friend = friend; } public boolean isFamily() { return family; } public void setFamily(boolean family) { this.family = family; } public boolean isAdmin() { return admin; } public void setAdmin(boolean admin) { this.admin = admin; } public boolean isPro() { return pro; } public void setPro(boolean pro) { this.pro = pro; } @Override
    public int getIconFarm() { return iconFarm; } @Override
    public void setIconFarm(int iconFarm) { this.iconFarm = iconFarm; } @Override
    public void setIconFarm(String iconFarm) { if (iconFarm != null) { setIconFarm(Integer.parseInt(iconFarm)); } } @Override
    public int getIconServer() { return iconServer; } @Override
    public void setIconServer(int iconServer) { this.iconServer = iconServer; } @Override
    public void setIconServer(String iconServer) { if (iconServer != null) { setIconServer(Integer.parseInt(iconServer)); } } public String getRealName() { return realName; } public void setRealName(String realName) { this.realName = realName; } public TimeZone getTimeZone() { return timeZone; } public TimeZone setTimeZone(TimeZone string) { return this.timeZone = string; } @Override
    @Deprecated
    public String getBuddyIconUrl() { return UrlUtilities.createBuddyIconUrl(iconFarm, iconServer, id); } public String getLocation() { return location; } public String getSecureBuddyIconUrl() { return UrlUtilities.createSecureBuddyIconUrl(iconFarm, iconServer, id); } public void setLocation(String location) { this.location = location; } public Date getPhotosFirstDate() { return photosFirstDate; } public void setPhotosFirstDate(Date photosFirstDate) { this.photosFirstDate = photosFirstDate; } public void setPhotosFirstDate(long photosFirstDate) { setPhotosFirstDate(new Date(photosFirstDate)); } public void setPhotosFirstDate(String photosFirstDate) { if (photosFirstDate != null) { setPhotosFirstDate(Long.parseLong(photosFirstDate) * 1000); } } public Date getPhotosFirstDateTaken() { return photosFirstDateTaken; } public void setPhotosFirstDateTaken(Date photosFirstDateTaken) { this.photosFirstDateTaken = photosFirstDateTaken; } public void setPhotosFirstDateTaken(String photosFirstDateTaken) { if (photosFirstDateTaken != null) { try { setPhotosFirstDateTaken(((DateFormat) DATE_FORMATS.get()).parse(photosFirstDateTaken)); } catch (ParseException e) { throw new RuntimeException(e); } } } public void setFaveDate(String faveDate) { setFaveDate(Long.parseLong(faveDate) * 1000); } public void setFaveDate(long faveDate) { setFaveDate(new Date(faveDate)); } public void setFaveDate(Date faveDate) { this.faveDate = faveDate; } public Date getFaveDate() { return faveDate; } public int getPhotosCount() { return photosCount; } public void setPhotosCount(int photosCount) { this.photosCount = photosCount; } public void setPhotosCount(String photosCount) { if (photosCount != null) { setPhotosCount(Integer.parseInt(photosCount)); } } public OnlineStatus getOnline() { return online; } public void setOnline(OnlineStatus online) { this.online = online; } public String getAwayMessage() { return awayMessage; } public void setAwayMessage(String awayMessage) { this.awayMessage = awayMessage; } public long getBandwidthMax() { return bandwidthMax; } public void setBandwidthMax(long bandwidthMax) { this.bandwidthMax = bandwidthMax; } public void setBandwidthMax(String bandwidthMax) { if (bandwidthMax != null) { setBandwidthMax(Long.parseLong(bandwidthMax)); } } public long getBandwidthUsed() { return bandwidthUsed; } public void setBandwidthUsed(long bandwidthUsed) { this.bandwidthUsed = bandwidthUsed; } public void setBandwidthUsed(String bandwidthUsed) { if (bandwidthUsed != null) { setBandwidthUsed(Long.parseLong(bandwidthUsed)); } } public long getFilesizeMax() { return filesizeMax; } public void setFilesizeMax(long filesizeMax) { this.filesizeMax = filesizeMax; } public void setFilesizeMax(String filesizeMax) { if (filesizeMax != null) { setFilesizeMax(Long.parseLong(filesizeMax)); } } public void setMbox_sha1sum(String mbox_sha1sum) { this.mbox_sha1sum = mbox_sha1sum; } public String getMbox_sha1sum() { return this.mbox_sha1sum; } @Override
    public boolean equals(Object obj) { if ((obj == null) || (obj.getClass() != this.getClass())) { return false; } if (obj == this) { return true; } User test = (User) obj; return id == null ? test.id == null : id.equals(test.id); } @Override
    public int hashCode() { int hash = 83; if (id != null) { hash ^= id.hashCode(); } return hash; } public String getPhotosurl() { return photosurl; } public void setPhotosurl(String photosurl) { this.photosurl = photosurl; } public String getProfileurl() { return profileurl; } public void setProfileurl(String profileurl) { this.profileurl = profileurl; } public String getMobileurl() { return mobileurl; } public void setMobileurl(String mobileurl) { this.mobileurl = mobileurl; } public void setRevContact(boolean revContact) { this.revContact = revContact; } public boolean isRevContact() { return revContact; } public void setRevFriend(boolean revFriend) { this.revFriend = revFriend; } public boolean isRevFriend() { return revFriend; } public void setRevFamily(boolean revFamily) { this.revFamily = revFamily; } public boolean isRevFamily() { return revFamily; } public String getPathAlias() { return pathAlias; } public void setPathAlias(String pathAlias) { this.pathAlias = pathAlias; } public PhotoLimits getPhotoLimits() { return photoLimits; } public void setPhotoLimits(PhotoLimits photoLimits) { this.photoLimits = photoLimits; } public VideoLimits getVideoLimits() { return videoLimits; } public void setPhotoLimits(VideoLimits videoLimits) { this.videoLimits = videoLimits; } public Boolean isBandwidthUnlimited() { return bandwidthUnlimited; } public void setIsBandwidthUnlimited(Boolean bandwidthUnlimited) { this.bandwidthUnlimited = bandwidthUnlimited; } public String getSetsCreated() { return setsCreated; } public void setSetsCreated(String setsCreated) { this.setsCreated = setsCreated; } public String getSetsRemaining() { return setsRemaining; } public void setSetsRemaining(String setsRemaining) { this.setsRemaining = setsRemaining; } public String getVideosUploaded() { return videosUploaded; } public void setVideosUploaded(String videosUploaded) { this.videosUploaded = videosUploaded; } public String getVideosRemaining() { return videosRemaining; } public void setVideosRemaining(String videosRemaining) { this.videosRemaining = videosRemaining; } public String getVideosSizeMax() { return videoSizeMax; } public void setVideoSizeMax(String videoSizeMax) { this.videoSizeMax = videoSizeMax; } } "," package com.flickr4java.flickr.people;  import com.flickr4java.flickr.contacts.OnlineStatus; import com.flickr4java.flickr.util.BuddyIconable; import com.flickr4java.flickr.util.UrlUtilities;  import java.io.Serializable; import java.text.DateFormat; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date;  /**
 * @author Anthony Eden
 * @version $Id: User.java,v 1.23 2010/09/12 20:13:57 x-mago Exp $
 */ public class User implements Serializable, BuddyIconable { private static final long serialVersionUID = 12L;  private static final ThreadLocal<SimpleDateFormat> DATE_FORMATS = new ThreadLocal<SimpleDateFormat>() { @Override
        protected synchronized SimpleDateFormat initialValue() { return new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); } } ;  private String id;  private String username;  private String description;  private String gender;  private boolean ignored;  private boolean contact;  private boolean friend;  private boolean family;  private boolean admin;  private boolean pro;  private int iconFarm;  private int iconServer;  private String realName;  private String location;  private TimeZone timeZone;  private Date photosFirstDate;  private Date photosFirstDateTaken;  private Date faveDate;  private int photosCount;  private OnlineStatus online;  private String awayMessage;  private long bandwidthMax;  private long bandwidthUsed;  private Boolean bandwidthUnlimited;  private String setsCreated;  private String setsRemaining;  private String videosUploaded;  private String videosRemaining;  private String videoSizeMax;  private long filesizeMax;  private String mbox_sha1sum;  private String photosurl;  private String profileurl;  private String mobileurl;  private boolean revContact;  private boolean revFriend;  private boolean revFamily;  private String pathAlias;  private PhotoLimits photoLimits;  private VideoLimits videoLimits;  public User() { }  public String getId() { return id; }  public void setId(String id) { this.id = id; }  public String getUsername() { return username; }  public void setUsername(String username) { this.username = username; }  /**
     * @return the description
     */ public String getDescription() { return description; }  /**
     * @param description
     *            the description to set
     */ public void setDescription(String description) { this.description = description; }  public String getGender() { return gender; }  public void setGender(String gender) { this.gender = gender; }  public boolean isIgnored() { return ignored; }  public void setIgnored(boolean ignored) { this.ignored = ignored; }  public boolean isContact() { return contact; }  public void setContact(boolean contact) { this.contact = contact; }  public boolean isFriend() { return friend; }  public void setFriend(boolean friend) { this.friend = friend; }  public boolean isFamily() { return family; }  public void setFamily(boolean family) { this.family = family; }  public boolean isAdmin() { return admin; }  public void setAdmin(boolean admin) { this.admin = admin; }  public boolean isPro() { return pro; }  public void setPro(boolean pro) { this.pro = pro; }  @Override
    public int getIconFarm() { return iconFarm; }  @Override
    public void setIconFarm(int iconFarm) { this.iconFarm = iconFarm; }  @Override
    public void setIconFarm(String iconFarm) { if (iconFarm != null) { setIconFarm(Integer.parseInt(iconFarm)); } }  @Override
    public int getIconServer() { return iconServer; }  @Override
    public void setIconServer(int iconServer) { this.iconServer = iconServer; }  @Override
    public void setIconServer(String iconServer) { if (iconServer != null) { setIconServer(Integer.parseInt(iconServer)); } }  public String getRealName() { return realName; }  public void setRealName(String realName) { this.realName = realName; }  public TimeZone getTimeZone() { return timeZone; }  public TimeZone setTimeZone(TimeZone string) { return this.timeZone = string; }  /**
     * Construct the BuddyIconUrl.
     * <p>
     * If none available, return the <a href=""http://www.flickr.com/images/buddyicon.jpg"">default</a>, or an URL assembled from farm, iconserver and nsid.
     * 
     * @see <a href=""http://flickr.com/services/api/misc.buddyicons.html"">Flickr Documentation</a>
     * @return The BuddyIconUrl
     * @deprecated use {@link #getSecureBuddyIconUrl() }
     */ @Override
    @Deprecated
    public String getBuddyIconUrl() { return UrlUtilities.createBuddyIconUrl(iconFarm, iconServer, id); }  public String getLocation() { return location; }  /**
     * Construct the BuddyIconUrl using {@code https} scheme.
     * <p>
     * If none available, return the <a href=""https://www.flickr.com/images/buddyicon.jpg"">default</a>, or an URL assembled from farm, iconserver and nsid.
     * 
     * @see <a href=""http://flickr.com/services/api/misc.buddyicons.html"">Flickr Documentation</a>
     * @return The BuddyIconUrl
     */ public String getSecureBuddyIconUrl() { return UrlUtilities.createSecureBuddyIconUrl(iconFarm, iconServer, id); }  public void setLocation(String location) { this.location = location; }  public Date getPhotosFirstDate() { return photosFirstDate; }  public void setPhotosFirstDate(Date photosFirstDate) { this.photosFirstDate = photosFirstDate; }  public void setPhotosFirstDate(long photosFirstDate) { setPhotosFirstDate(new Date(photosFirstDate)); }  public void setPhotosFirstDate(String photosFirstDate) { if (photosFirstDate != null) { setPhotosFirstDate(Long.parseLong(photosFirstDate) * 1000); } }  public Date getPhotosFirstDateTaken() { return photosFirstDateTaken; }  public void setPhotosFirstDateTaken(Date photosFirstDateTaken) { this.photosFirstDateTaken = photosFirstDateTaken; }  public void setPhotosFirstDateTaken(String photosFirstDateTaken) { if (photosFirstDateTaken != null) { try { setPhotosFirstDateTaken(((DateFormat) DATE_FORMATS.get()).parse(photosFirstDateTaken)); } catch (ParseException e) { throw new RuntimeException(e); } } }  public void setFaveDate(String faveDate) { setFaveDate(Long.parseLong(faveDate) * 1000); }  public void setFaveDate(long faveDate) { setFaveDate(new Date(faveDate)); }  /**
     * Date when User has faved a Photo.<br>
     * flickr.photos.getFavorites returns person-data where this Date will be set.
     * 
     * @param faveDate
     */ public void setFaveDate(Date faveDate) { this.faveDate = faveDate; }  /**
     * The Date, when a User has favourited a Photo.<br>
     * This value is set, when a User is created by {@link com.flickr4java.flickr.photos.PhotosInterface#getFavorites(String, int, int)}.
     * 
     * @return faveDate
     */ public Date getFaveDate() { return faveDate; }  public int getPhotosCount() { return photosCount; }  public void setPhotosCount(int photosCount) { this.photosCount = photosCount; }  public void setPhotosCount(String photosCount) { if (photosCount != null) { setPhotosCount(Integer.parseInt(photosCount)); } }  public OnlineStatus getOnline() { return online; }  public void setOnline(OnlineStatus online) { this.online = online; }  public String getAwayMessage() { return awayMessage; }  public void setAwayMessage(String awayMessage) { this.awayMessage = awayMessage; }  public long getBandwidthMax() { return bandwidthMax; }  public void setBandwidthMax(long bandwidthMax) { this.bandwidthMax = bandwidthMax; }  public void setBandwidthMax(String bandwidthMax) { if (bandwidthMax != null) { setBandwidthMax(Long.parseLong(bandwidthMax)); } }  public long getBandwidthUsed() { return bandwidthUsed; }  public void setBandwidthUsed(long bandwidthUsed) { this.bandwidthUsed = bandwidthUsed; }  public void setBandwidthUsed(String bandwidthUsed) { if (bandwidthUsed != null) { setBandwidthUsed(Long.parseLong(bandwidthUsed)); } }  public long getFilesizeMax() { return filesizeMax; }  public void setFilesizeMax(long filesizeMax) { this.filesizeMax = filesizeMax; }  public void setFilesizeMax(String filesizeMax) { if (filesizeMax != null) { setFilesizeMax(Long.parseLong(filesizeMax)); } }  public void setMbox_sha1sum(String mbox_sha1sum) { this.mbox_sha1sum = mbox_sha1sum; }  public String getMbox_sha1sum() { return this.mbox_sha1sum; }  @Override
    public boolean equals(Object obj) { if ((obj == null) || (obj.getClass() != this.getClass())) { return false; } if (obj == this) { return true; } User test = (User) obj; return id == null ? test.id == null : id.equals(test.id); }  @Override
    public int hashCode() { int hash = 83; if (id != null) { hash ^= id.hashCode(); } return hash; }  /**
     * @return the photosurl
     */ public String getPhotosurl() { return photosurl; }  /**
     * @param photosurl
     *            the photosurl to set
     */ public void setPhotosurl(String photosurl) { this.photosurl = photosurl; }  /**
     * @return the profileurl
     */ public String getProfileurl() { return profileurl; }  /**
     * @param profileurl
     *            the profileurl to set
     */ public void setProfileurl(String profileurl) { this.profileurl = profileurl; }  /**
     * @return the mobileurl
     */ public String getMobileurl() { return mobileurl; }  /**
     * @param mobileurl
     *            the mobileurl to set
     */ public void setMobileurl(String mobileurl) { this.mobileurl = mobileurl; }  public void setRevContact(boolean revContact) { this.revContact = revContact; }  public boolean isRevContact() { return revContact; }  public void setRevFriend(boolean revFriend) { this.revFriend = revFriend; }  public boolean isRevFriend() { return revFriend; }  public void setRevFamily(boolean revFamily) { this.revFamily = revFamily; }  public boolean isRevFamily() { return revFamily; }  /**
     * Get the user's path alias, which may appear instead of nsid in urls published by Flickr. For example feeds have urls of the form
     * .../photos/${NSID_OR_PATHALIAS}/${PHOTO_ID} and .../people/${NSID_OR_PATHALIAS}. This allows clients to look up a {@link User} given such a url. (Note that
     * <code>&lt;author&gt;</code> elements in feeds have a <code>&lt;flickr:nsid&gt;</code> child which could be used instead of the lookup this method
     * enables.)
     * 
     * @return the path alias, or null
     */ public String getPathAlias() { return pathAlias; }  public void setPathAlias(String pathAlias) { this.pathAlias = pathAlias; }  /**
     * @return PhotoLimits class instance
     */ public PhotoLimits getPhotoLimits() { return photoLimits; }  public void setPhotoLimits(PhotoLimits photoLimits) { this.photoLimits = photoLimits; }  /**
     * @return VideoLimits class instance
     */ public VideoLimits getVideoLimits() { return videoLimits; }  public void setPhotoLimits(VideoLimits videoLimits) { this.videoLimits = videoLimits; }  public Boolean isBandwidthUnlimited() { return bandwidthUnlimited; }  public void setIsBandwidthUnlimited(Boolean bandwidthUnlimited) { this.bandwidthUnlimited = bandwidthUnlimited; }  public String getSetsCreated() { return setsCreated; }  public void setSetsCreated(String setsCreated) { this.setsCreated = setsCreated; }  public String getSetsRemaining() { return setsRemaining; }  public void setSetsRemaining(String setsRemaining) { this.setsRemaining = setsRemaining; }  public String getVideosUploaded() { return videosUploaded; }  public void setVideosUploaded(String videosUploaded) { this.videosUploaded = videosUploaded; }  public String getVideosRemaining() { return videosRemaining; }  public void setVideosRemaining(String videosRemaining) { this.videosRemaining = videosRemaining; }  public String getVideosSizeMax() { return videoSizeMax; }  public void setVideoSizeMax(String videoSizeMax) { this.videoSizeMax = videoSizeMax; }  }  "
src/main/java/com/flickr4java/flickr/people/UserList.java,"package com.flickr4java.flickr.people;

import com.flickr4java.flickr.SearchResultList;

/**
 * A list of users
 * 
 * @author acaplan
 */
public class UserList<E> extends SearchResultList<User> {

    private static final long serialVersionUID = -4735611134085303463L;

}
",package com.flickr4java.flickr.people; import com.flickr4java.flickr.SearchResultList; public class UserList<E> extends SearchResultList<User> { private static final long serialVersionUID = -4735611134085303463L; },0 0 0 0 0 0,package com.flickr4java.flickr.people; import com.flickr4java.flickr.SearchResultList; public class UserList<E> extends SearchResultList<User> { private static final long serialVersionUID = -4735611134085303463L; } ,"package com.flickr4java.flickr.people;  import com.flickr4java.flickr.SearchResultList;  /**
 * A list of users
 * 
 * @author acaplan
 */ public class UserList<E> extends SearchResultList<User> {  private static final long serialVersionUID = -4735611134085303463L;  }  "
src/main/java/com/flickr4java/flickr/people/VideoLimits.java,"package com.flickr4java.flickr.people;

public class VideoLimits {

	private String maxDuration;
	private String maxUpload;
	
	/**
     * Maximum photo display pixels
     * 
     * @return String max pixels
     */
	
	public String getMaxDuration(){
		return maxDuration;
	}
	
	public void setMaxDuration(String maxDuration){
		this.maxDuration = maxDuration;
	}
	
	 /**
     * Maximum photo upload
     * 
     * @return String upload capacity
     */
	
	
	public String getMaxUpload(){
		return maxUpload;
	}
	
	public void setMaxUpload(String maxUpload){
		this.maxUpload = maxUpload;
	}
	
}
",package com.flickr4java.flickr.people; public class VideoLimits { private String maxDuration; private String maxUpload; public String getMaxDuration(){ return maxDuration; } public void setMaxDuration(String maxDuration){ this.maxDuration = maxDuration; } public String getMaxUpload(){ return maxUpload; } public void setMaxUpload(String maxUpload){ this.maxUpload = maxUpload; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.people; public class VideoLimits { private String maxDuration; private String maxUpload; public String getMaxDuration(){ return maxDuration; } public void setMaxDuration(String maxDuration){ this.maxDuration = maxDuration; } public String getMaxUpload(){ return maxUpload; } public void setMaxUpload(String maxUpload){ this.maxUpload = maxUpload; } } ,"package com.flickr4java.flickr.people;  public class VideoLimits {  private String maxDuration; private String maxUpload; 	 /**
     * Maximum photo display pixels
     * 
     * @return String max pixels
     */ 	 public String getMaxDuration(){ return maxDuration; } 	 public void setMaxDuration(String maxDuration){ this.maxDuration = maxDuration; } 	 /**
     * Maximum photo upload
     * 
     * @return String upload capacity
     */ 	
	 public String getMaxUpload(){ return maxUpload; } 	 public void setMaxUpload(String maxUpload){ this.maxUpload = maxUpload; } 	 }  "
src/main/java/com/flickr4java/flickr/photos/Editability.java,"
package com.flickr4java.flickr.photos;

/**
 * @author Anthony Eden
 */
public class Editability {

    private boolean comment;

    private boolean addmeta;

    public Editability() {

    }

    public boolean isComment() {
        return comment;
    }

    public void setComment(boolean comment) {
        this.comment = comment;
    }

    public boolean isAddmeta() {
        return addmeta;
    }

    public void setAddmeta(boolean addmeta) {
        this.addmeta = addmeta;
    }

    @Override
    public boolean equals(Object obj) {
        if ((obj == null) || (obj.getClass() != this.getClass())) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        Editability test = (Editability) obj;
        return comment == test.comment && addmeta == test.addmeta;
    }

    @Override
    public int hashCode() {
        int hash = 1;
        hash += Boolean.hashCode(comment);
        hash += Boolean.hashCode(addmeta);
        return hash;
    }

}
","package com.flickr4java.flickr.photos; public class Editability { private boolean comment; private boolean addmeta; public Editability() { } public boolean isComment() { return comment; } public void setComment(boolean comment) { this.comment = comment; } public boolean isAddmeta() { return addmeta; } public void setAddmeta(boolean addmeta) { this.addmeta = addmeta; } @Override
    public boolean equals(Object obj) { if ((obj == null) || (obj.getClass() != this.getClass())) { return false; } if (obj == this) { return true; } Editability test = (Editability) obj; return comment == test.comment && addmeta == test.addmeta; } @Override
    public int hashCode() { int hash = 1; hash += Boolean.hashCode(comment); hash += Boolean.hashCode(addmeta); return hash; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.photos; public class Editability { private boolean comment; private boolean addmeta; public Editability() { } public boolean isComment() { return comment; } public void setComment(boolean comment) { this.comment = comment; } public boolean isAddmeta() { return addmeta; } public void setAddmeta(boolean addmeta) { this.addmeta = addmeta; } @Override
    public boolean equals(Object obj) { if ((obj == null) || (obj.getClass() != this.getClass())) { return false; } if (obj == this) { return true; } Editability test = (Editability) obj; return comment == test.comment && addmeta == test.addmeta; } @Override
    public int hashCode() { int hash = 1; hash += Boolean.hashCode(comment); hash += Boolean.hashCode(addmeta); return hash; } } "," package com.flickr4java.flickr.photos;  /**
 * @author Anthony Eden
 */ public class Editability {  private boolean comment;  private boolean addmeta;  public Editability() {  }  public boolean isComment() { return comment; }  public void setComment(boolean comment) { this.comment = comment; }  public boolean isAddmeta() { return addmeta; }  public void setAddmeta(boolean addmeta) { this.addmeta = addmeta; }  @Override
    public boolean equals(Object obj) { if ((obj == null) || (obj.getClass() != this.getClass())) { return false; } if (obj == this) { return true; } Editability test = (Editability) obj; return comment == test.comment && addmeta == test.addmeta; }  @Override
    public int hashCode() { int hash = 1; hash += Boolean.hashCode(comment); hash += Boolean.hashCode(addmeta); return hash; }  }  "
src/main/java/com/flickr4java/flickr/photos/Exif.java,"

package com.flickr4java.flickr.photos;

/**
 * @author Anthony Eden
 */
public class Exif {

    private String tagspace;

    private String tagspaceId;

    private String tag;

    private String label;

    private String raw;

    private String clean;

    public String getTagspace() {
        return tagspace;
    }

    public void setTagspace(String tagspace) {
        this.tagspace = tagspace;
    }

    public String getTagspaceId() {
        return tagspaceId;
    }

    public void setTagspaceId(String tagspaceId) {
        this.tagspaceId = tagspaceId;
    }

    public String getTag() {
        return tag;
    }

    public void setTag(String tag) {
        this.tag = tag;
    }

    public String getLabel() {
        return label;
    }

    public void setLabel(String label) {
        this.label = label;
    }

    public String getRaw() {
        return raw;
    }

    public void setRaw(String raw) {
        this.raw = raw;
    }

    public String getClean() {
        return clean;
    }

    public void setClean(String clean) {
        this.clean = clean;
    }

}
",package com.flickr4java.flickr.photos; public class Exif { private String tagspace; private String tagspaceId; private String tag; private String label; private String raw; private String clean; public String getTagspace() { return tagspace; } public void setTagspace(String tagspace) { this.tagspace = tagspace; } public String getTagspaceId() { return tagspaceId; } public void setTagspaceId(String tagspaceId) { this.tagspaceId = tagspaceId; } public String getTag() { return tag; } public void setTag(String tag) { this.tag = tag; } public String getLabel() { return label; } public void setLabel(String label) { this.label = label; } public String getRaw() { return raw; } public void setRaw(String raw) { this.raw = raw; } public String getClean() { return clean; } public void setClean(String clean) { this.clean = clean; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.photos; public class Exif { private String tagspace; private String tagspaceId; private String tag; private String label; private String raw; private String clean; public String getTagspace() { return tagspace; } public void setTagspace(String tagspace) { this.tagspace = tagspace; } public String getTagspaceId() { return tagspaceId; } public void setTagspaceId(String tagspaceId) { this.tagspaceId = tagspaceId; } public String getTag() { return tag; } public void setTag(String tag) { this.tag = tag; } public String getLabel() { return label; } public void setLabel(String label) { this.label = label; } public String getRaw() { return raw; } public void setRaw(String raw) { this.raw = raw; } public String getClean() { return clean; } public void setClean(String clean) { this.clean = clean; } } ,"
 package com.flickr4java.flickr.photos;  /**
 * @author Anthony Eden
 */ public class Exif {  private String tagspace;  private String tagspaceId;  private String tag;  private String label;  private String raw;  private String clean;  public String getTagspace() { return tagspace; }  public void setTagspace(String tagspace) { this.tagspace = tagspace; }  public String getTagspaceId() { return tagspaceId; }  public void setTagspaceId(String tagspaceId) { this.tagspaceId = tagspaceId; }  public String getTag() { return tag; }  public void setTag(String tag) { this.tag = tag; }  public String getLabel() { return label; }  public void setLabel(String label) { this.label = label; }  public String getRaw() { return raw; }  public void setRaw(String raw) { this.raw = raw; }  public String getClean() { return clean; }  public void setClean(String clean) { this.clean = clean; }  }  "
src/main/java/com/flickr4java/flickr/photos/Extras.java,"
package com.flickr4java.flickr.photos;

import java.util.HashSet;
import java.util.Set;

/**
 * Extra-attributes for Photo-requests.
 * 
 * @author Anthony Eden
 * @version $Id: Extras.java,v 1.12 2009/07/23 20:41:03 x-mago Exp $
 */
public class Extras {

    public static final String KEY_EXTRAS = ""extras"";

    public static final String LICENSE = ""license"";

    public static final String DATE_UPLOAD = ""date_upload"";

    public static final String DATE_TAKEN = ""date_taken"";

    public static final String OWNER_NAME = ""owner_name"";

    public static final String ICON_SERVER = ""icon_server"";

    public static final String ORIGINAL_FORMAT = ""original_format"";

    public static final String LAST_UPDATE = ""last_update"";

    public static final String GEO = ""geo"";

    public static final String TAGS = ""tags"";

    public static final String MACHINE_TAGS = ""machine_tags"";

    public static final String O_DIMS = ""o_dims"";

    public static final String MEDIA = ""media"";

    public static final String VIEWS = ""views"";

    public static final String PATH_ALIAS = ""path_alias"";

    public static final String URL_S = ""url_s"";

    public static final String URL_SQ = ""url_sq"";

    public static final String URL_T = ""url_t"";

    public static final String URL_M = ""url_m"";

    public static final String URL_L = ""url_l"";

    public static final String URL_O = ""url_o"";

    /**
     * Set of all extra-arguments. Used for requesting lists of photos.
     * 
     * @see com.flickr4java.flickr.groups.pools.PoolsInterface#getPhotos(String, String[], Set, int, int)
     * @see com.flickr4java.flickr.panda.PandaInterface#getPhotos(com.flickr4java.flickr.panda.Panda, Set, int, int)
     * @see com.flickr4java.flickr.people.PeopleInterface#getPublicPhotos(String, Set, int, int)
     * @see com.flickr4java.flickr.photosets.PhotosetsInterface#getPhotos(String, Set, int, int, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getContactsPublicPhotos(String, Set, int, boolean, boolean, boolean)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getWithGeoData(java.util.Date, java.util.Date, java.util.Date, java.util.Date, int, String, Set, int,
     *      int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getWithoutGeoData(java.util.Date, java.util.Date, java.util.Date, java.util.Date, int, String, Set,
     *      int, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#recentlyUpdated(java.util.Date, Set, int, int)
     * @see com.flickr4java.flickr.photos.SearchParameters#setExtras(Set)
     * @see com.flickr4java.flickr.photos.geo.GeoInterface#photosForLocation(GeoData, Set, int, int)
     * @see com.flickr4java.flickr.interestingness.InterestingnessInterface#getList(java.util.Date, Set, int, int)
     * @see com.flickr4java.flickr.favorites.FavoritesInterface#getList(String, int, int, Set)
     */
    public static final Set<String> ALL_EXTRAS = new HashSet<String>();

    /**
     * Minimal Set of extra-arguments. Used by convenience-methods that request lists of photos.
     * 
     * @see com.flickr4java.flickr.groups.pools.PoolsInterface#getPhotos(String, String[], Set, int, int)
     * @see com.flickr4java.flickr.panda.PandaInterface#getPhotos(com.flickr4java.flickr.panda.Panda, Set, int, int)
     * @see com.flickr4java.flickr.people.PeopleInterface#getPublicPhotos(String, Set, int, int)
     * @see com.flickr4java.flickr.photosets.PhotosetsInterface#getPhotos(String, Set, int, int, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getContactsPublicPhotos(String, Set, int, boolean, boolean, boolean)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getWithGeoData(java.util.Date, java.util.Date, java.util.Date, java.util.Date, int, String, Set, int,
     *      int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getWithoutGeoData(java.util.Date, java.util.Date, java.util.Date, java.util.Date, int, String, Set,
     *      int, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#recentlyUpdated(java.util.Date, Set, int, int)
     * @see com.flickr4java.flickr.photos.geo.GeoInterface#photosForLocation(GeoData, Set, int, int)
     * @see com.flickr4java.flickr.interestingness.InterestingnessInterface#getList(java.util.Date, Set, int, int)
     * @see com.flickr4java.flickr.favorites.FavoritesInterface#getList(String, int, int, Set)
     */
    public static final Set<String> MIN_EXTRAS = new HashSet<String>();

    static {
        ALL_EXTRAS.add(DATE_TAKEN);
        ALL_EXTRAS.add(DATE_UPLOAD);
        ALL_EXTRAS.add(ICON_SERVER);
        ALL_EXTRAS.add(LAST_UPDATE);
        ALL_EXTRAS.add(LICENSE);
        ALL_EXTRAS.add(ORIGINAL_FORMAT);
        ALL_EXTRAS.add(OWNER_NAME);
        ALL_EXTRAS.add(GEO);
        ALL_EXTRAS.add(TAGS);
        ALL_EXTRAS.add(MACHINE_TAGS);
        ALL_EXTRAS.add(O_DIMS);
        ALL_EXTRAS.add(MEDIA);
        ALL_EXTRAS.add(VIEWS);
        ALL_EXTRAS.add(PATH_ALIAS);
        ALL_EXTRAS.add(URL_S);
        ALL_EXTRAS.add(URL_SQ);
        ALL_EXTRAS.add(URL_T);
        ALL_EXTRAS.add(URL_M);
        ALL_EXTRAS.add(URL_O);
        ALL_EXTRAS.add(URL_L);
    }

    static {
        MIN_EXTRAS.add(ORIGINAL_FORMAT);
        MIN_EXTRAS.add(OWNER_NAME);
    }

    /**
     * No-op constructor.
     */
    private Extras() {
    }

}
","package com.flickr4java.flickr.photos; import java.util.HashSet; import java.util.Set; public class Extras { public static final String KEY_EXTRAS = ""extras""; public static final String LICENSE = ""license""; public static final String DATE_UPLOAD = ""date_upload""; public static final String DATE_TAKEN = ""date_taken""; public static final String OWNER_NAME = ""owner_name""; public static final String ICON_SERVER = ""icon_server""; public static final String ORIGINAL_FORMAT = ""original_format""; public static final String LAST_UPDATE = ""last_update""; public static final String GEO = ""geo""; public static final String TAGS = ""tags""; public static final String MACHINE_TAGS = ""machine_tags""; public static final String O_DIMS = ""o_dims""; public static final String MEDIA = ""media""; public static final String VIEWS = ""views""; public static final String PATH_ALIAS = ""path_alias""; public static final String URL_S = ""url_s""; public static final String URL_SQ = ""url_sq""; public static final String URL_T = ""url_t""; public static final String URL_M = ""url_m""; public static final String URL_L = ""url_l""; public static final String URL_O = ""url_o""; public static final Set<String> ALL_EXTRAS = new HashSet<String>(); public static final Set<String> MIN_EXTRAS = new HashSet<String>(); static { ALL_EXTRAS.add(DATE_TAKEN); ALL_EXTRAS.add(DATE_UPLOAD); ALL_EXTRAS.add(ICON_SERVER); ALL_EXTRAS.add(LAST_UPDATE); ALL_EXTRAS.add(LICENSE); ALL_EXTRAS.add(ORIGINAL_FORMAT); ALL_EXTRAS.add(OWNER_NAME); ALL_EXTRAS.add(GEO); ALL_EXTRAS.add(TAGS); ALL_EXTRAS.add(MACHINE_TAGS); ALL_EXTRAS.add(O_DIMS); ALL_EXTRAS.add(MEDIA); ALL_EXTRAS.add(VIEWS); ALL_EXTRAS.add(PATH_ALIAS); ALL_EXTRAS.add(URL_S); ALL_EXTRAS.add(URL_SQ); ALL_EXTRAS.add(URL_T); ALL_EXTRAS.add(URL_M); ALL_EXTRAS.add(URL_O); ALL_EXTRAS.add(URL_L); } static { MIN_EXTRAS.add(ORIGINAL_FORMAT); MIN_EXTRAS.add(OWNER_NAME); } private Extras() { } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.photos; import java.util.HashSet; import java.util.Set; public class Extras { public static final String KEY_EXTRAS = ""extras""; public static final String LICENSE = ""license""; public static final String DATE_UPLOAD = ""date_upload""; public static final String DATE_TAKEN = ""date_taken""; public static final String OWNER_NAME = ""owner_name""; public static final String ICON_SERVER = ""icon_server""; public static final String ORIGINAL_FORMAT = ""original_format""; public static final String LAST_UPDATE = ""last_update""; public static final String GEO = ""geo""; public static final String TAGS = ""tags""; public static final String MACHINE_TAGS = ""machine_tags""; public static final String O_DIMS = ""o_dims""; public static final String MEDIA = ""media""; public static final String VIEWS = ""views""; public static final String PATH_ALIAS = ""path_alias""; public static final String URL_S = ""url_s""; public static final String URL_SQ = ""url_sq""; public static final String URL_T = ""url_t""; public static final String URL_M = ""url_m""; public static final String URL_L = ""url_l""; public static final String URL_O = ""url_o""; public static final Set<String> ALL_EXTRAS = new HashSet<String>(); public static final Set<String> MIN_EXTRAS = new HashSet<String>(); static { ALL_EXTRAS.add(DATE_TAKEN); ALL_EXTRAS.add(DATE_UPLOAD); ALL_EXTRAS.add(ICON_SERVER); ALL_EXTRAS.add(LAST_UPDATE); ALL_EXTRAS.add(LICENSE); ALL_EXTRAS.add(ORIGINAL_FORMAT); ALL_EXTRAS.add(OWNER_NAME); ALL_EXTRAS.add(GEO); ALL_EXTRAS.add(TAGS); ALL_EXTRAS.add(MACHINE_TAGS); ALL_EXTRAS.add(O_DIMS); ALL_EXTRAS.add(MEDIA); ALL_EXTRAS.add(VIEWS); ALL_EXTRAS.add(PATH_ALIAS); ALL_EXTRAS.add(URL_S); ALL_EXTRAS.add(URL_SQ); ALL_EXTRAS.add(URL_T); ALL_EXTRAS.add(URL_M); ALL_EXTRAS.add(URL_O); ALL_EXTRAS.add(URL_L); } static { MIN_EXTRAS.add(ORIGINAL_FORMAT); MIN_EXTRAS.add(OWNER_NAME); } private Extras() { } } "," package com.flickr4java.flickr.photos;  import java.util.HashSet; import java.util.Set;  /**
 * Extra-attributes for Photo-requests.
 * 
 * @author Anthony Eden
 * @version $Id: Extras.java,v 1.12 2009/07/23 20:41:03 x-mago Exp $
 */ public class Extras {  public static final String KEY_EXTRAS = ""extras"";  public static final String LICENSE = ""license"";  public static final String DATE_UPLOAD = ""date_upload"";  public static final String DATE_TAKEN = ""date_taken"";  public static final String OWNER_NAME = ""owner_name"";  public static final String ICON_SERVER = ""icon_server"";  public static final String ORIGINAL_FORMAT = ""original_format"";  public static final String LAST_UPDATE = ""last_update"";  public static final String GEO = ""geo"";  public static final String TAGS = ""tags"";  public static final String MACHINE_TAGS = ""machine_tags"";  public static final String O_DIMS = ""o_dims"";  public static final String MEDIA = ""media"";  public static final String VIEWS = ""views"";  public static final String PATH_ALIAS = ""path_alias"";  public static final String URL_S = ""url_s"";  public static final String URL_SQ = ""url_sq"";  public static final String URL_T = ""url_t"";  public static final String URL_M = ""url_m"";  public static final String URL_L = ""url_l"";  public static final String URL_O = ""url_o"";  /**
     * Set of all extra-arguments. Used for requesting lists of photos.
     * 
     * @see com.flickr4java.flickr.groups.pools.PoolsInterface#getPhotos(String, String[], Set, int, int)
     * @see com.flickr4java.flickr.panda.PandaInterface#getPhotos(com.flickr4java.flickr.panda.Panda, Set, int, int)
     * @see com.flickr4java.flickr.people.PeopleInterface#getPublicPhotos(String, Set, int, int)
     * @see com.flickr4java.flickr.photosets.PhotosetsInterface#getPhotos(String, Set, int, int, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getContactsPublicPhotos(String, Set, int, boolean, boolean, boolean)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getWithGeoData(java.util.Date, java.util.Date, java.util.Date, java.util.Date, int, String, Set, int,
     *      int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getWithoutGeoData(java.util.Date, java.util.Date, java.util.Date, java.util.Date, int, String, Set,
     *      int, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#recentlyUpdated(java.util.Date, Set, int, int)
     * @see com.flickr4java.flickr.photos.SearchParameters#setExtras(Set)
     * @see com.flickr4java.flickr.photos.geo.GeoInterface#photosForLocation(GeoData, Set, int, int)
     * @see com.flickr4java.flickr.interestingness.InterestingnessInterface#getList(java.util.Date, Set, int, int)
     * @see com.flickr4java.flickr.favorites.FavoritesInterface#getList(String, int, int, Set)
     */ public static final Set<String> ALL_EXTRAS = new HashSet<String>();  /**
     * Minimal Set of extra-arguments. Used by convenience-methods that request lists of photos.
     * 
     * @see com.flickr4java.flickr.groups.pools.PoolsInterface#getPhotos(String, String[], Set, int, int)
     * @see com.flickr4java.flickr.panda.PandaInterface#getPhotos(com.flickr4java.flickr.panda.Panda, Set, int, int)
     * @see com.flickr4java.flickr.people.PeopleInterface#getPublicPhotos(String, Set, int, int)
     * @see com.flickr4java.flickr.photosets.PhotosetsInterface#getPhotos(String, Set, int, int, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getContactsPublicPhotos(String, Set, int, boolean, boolean, boolean)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getWithGeoData(java.util.Date, java.util.Date, java.util.Date, java.util.Date, int, String, Set, int,
     *      int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getWithoutGeoData(java.util.Date, java.util.Date, java.util.Date, java.util.Date, int, String, Set,
     *      int, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#recentlyUpdated(java.util.Date, Set, int, int)
     * @see com.flickr4java.flickr.photos.geo.GeoInterface#photosForLocation(GeoData, Set, int, int)
     * @see com.flickr4java.flickr.interestingness.InterestingnessInterface#getList(java.util.Date, Set, int, int)
     * @see com.flickr4java.flickr.favorites.FavoritesInterface#getList(String, int, int, Set)
     */ public static final Set<String> MIN_EXTRAS = new HashSet<String>();  static { ALL_EXTRAS.add(DATE_TAKEN); ALL_EXTRAS.add(DATE_UPLOAD); ALL_EXTRAS.add(ICON_SERVER); ALL_EXTRAS.add(LAST_UPDATE); ALL_EXTRAS.add(LICENSE); ALL_EXTRAS.add(ORIGINAL_FORMAT); ALL_EXTRAS.add(OWNER_NAME); ALL_EXTRAS.add(GEO); ALL_EXTRAS.add(TAGS); ALL_EXTRAS.add(MACHINE_TAGS); ALL_EXTRAS.add(O_DIMS); ALL_EXTRAS.add(MEDIA); ALL_EXTRAS.add(VIEWS); ALL_EXTRAS.add(PATH_ALIAS); ALL_EXTRAS.add(URL_S); ALL_EXTRAS.add(URL_SQ); ALL_EXTRAS.add(URL_T); ALL_EXTRAS.add(URL_M); ALL_EXTRAS.add(URL_O); ALL_EXTRAS.add(URL_L); }  static { MIN_EXTRAS.add(ORIGINAL_FORMAT); MIN_EXTRAS.add(OWNER_NAME); }  /**
     * No-op constructor.
     */ private Extras() { }  }  "
src/main/java/com/flickr4java/flickr/photos/GeoData.java,"package com.flickr4java.flickr.photos;

/**
 * A geographic position.
 * 
 * @author mago
 * @version $Id: GeoData.java,v 1.4 2009/07/23 20:41:03 x-mago Exp $
 */
public class GeoData {

    private float longitude;

    private float latitude;

    private int accuracy;

    public GeoData() {
        super();
    }

    public GeoData(String longitudeStr, String latitudeStr, String accuracyStr) {
        longitude = Float.parseFloat(longitudeStr);
        latitude = Float.parseFloat(latitudeStr);
        accuracy = Integer.parseInt(accuracyStr);
    }

    public int getAccuracy() {
        return accuracy;
    }

    /**
     * Set the accuracy level.
     * <p>
     * 
     * World level is 1, Country is ~3, Region ~6, City ~11, Street ~16.
     * 
     * @param accuracy
     * @see com.flickr4java.flickr.Flickr#ACCURACY_WORLD
     * @see com.flickr4java.flickr.Flickr#ACCURACY_COUNTRY
     * @see com.flickr4java.flickr.Flickr#ACCURACY_REGION
     * @see com.flickr4java.flickr.Flickr#ACCURACY_CITY
     * @see com.flickr4java.flickr.Flickr#ACCURACY_STREET
     */
    public void setAccuracy(int accuracy) {
        this.accuracy = accuracy;
    }

    public float getLatitude() {
        return latitude;
    }

    public void setLatitude(float latitude) {
        this.latitude = latitude;
    }

    public float getLongitude() {
        return longitude;
    }

    public void setLongitude(float longitude) {
        this.longitude = longitude;
    }

    @Override
    public String toString() {
        return ""GeoData[longitude="" + longitude + "" latitude="" + latitude + "" accuracy="" + accuracy + ""]"";
    }

    @Override
    public boolean equals(Object obj) {
        if ((obj == null) || (obj.getClass() != this.getClass())) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        GeoData test = (GeoData) obj;
        return longitude == test.longitude && latitude == test.latitude && accuracy == test.accuracy;
    }

    @Override
    public int hashCode() {
        int hash = 1;
        hash += Float.hashCode(longitude);
        hash += Float.hashCode(latitude);
        hash += Integer.hashCode(accuracy);
        return hash;
    }
}
","package com.flickr4java.flickr.photos; public class GeoData { private float longitude; private float latitude; private int accuracy; public GeoData() { super(); } public GeoData(String longitudeStr, String latitudeStr, String accuracyStr) { longitude = Float.parseFloat(longitudeStr); latitude = Float.parseFloat(latitudeStr); accuracy = Integer.parseInt(accuracyStr); } public int getAccuracy() { return accuracy; } public void setAccuracy(int accuracy) { this.accuracy = accuracy; } public float getLatitude() { return latitude; } public void setLatitude(float latitude) { this.latitude = latitude; } public float getLongitude() { return longitude; } public void setLongitude(float longitude) { this.longitude = longitude; } @Override
    public String toString() { return ""GeoData[longitude="" + longitude + "" latitude="" + latitude + "" accuracy="" + accuracy + ""]""; } @Override
    public boolean equals(Object obj) { if ((obj == null) || (obj.getClass() != this.getClass())) { return false; } if (obj == this) { return true; } GeoData test = (GeoData) obj; return longitude == test.longitude && latitude == test.latitude && accuracy == test.accuracy; } @Override
    public int hashCode() { int hash = 1; hash += Float.hashCode(longitude); hash += Float.hashCode(latitude); hash += Integer.hashCode(accuracy); return hash; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.photos; public class GeoData { private float longitude; private float latitude; private int accuracy; public GeoData() { super(); } public GeoData(String longitudeStr, String latitudeStr, String accuracyStr) { longitude = Float.parseFloat(longitudeStr); latitude = Float.parseFloat(latitudeStr); accuracy = Integer.parseInt(accuracyStr); } public int getAccuracy() { return accuracy; } public void setAccuracy(int accuracy) { this.accuracy = accuracy; } public float getLatitude() { return latitude; } public void setLatitude(float latitude) { this.latitude = latitude; } public float getLongitude() { return longitude; } public void setLongitude(float longitude) { this.longitude = longitude; } @Override
    public String toString() { return ""GeoData[longitude="" + longitude + "" latitude="" + latitude + "" accuracy="" + accuracy + ""]""; } @Override
    public boolean equals(Object obj) { if ((obj == null) || (obj.getClass() != this.getClass())) { return false; } if (obj == this) { return true; } GeoData test = (GeoData) obj; return longitude == test.longitude && latitude == test.latitude && accuracy == test.accuracy; } @Override
    public int hashCode() { int hash = 1; hash += Float.hashCode(longitude); hash += Float.hashCode(latitude); hash += Integer.hashCode(accuracy); return hash; } } ","package com.flickr4java.flickr.photos;  /**
 * A geographic position.
 * 
 * @author mago
 * @version $Id: GeoData.java,v 1.4 2009/07/23 20:41:03 x-mago Exp $
 */ public class GeoData {  private float longitude;  private float latitude;  private int accuracy;  public GeoData() { super(); }  public GeoData(String longitudeStr, String latitudeStr, String accuracyStr) { longitude = Float.parseFloat(longitudeStr); latitude = Float.parseFloat(latitudeStr); accuracy = Integer.parseInt(accuracyStr); }  public int getAccuracy() { return accuracy; }  /**
     * Set the accuracy level.
     * <p>
     * 
     * World level is 1, Country is ~3, Region ~6, City ~11, Street ~16.
     * 
     * @param accuracy
     * @see com.flickr4java.flickr.Flickr#ACCURACY_WORLD
     * @see com.flickr4java.flickr.Flickr#ACCURACY_COUNTRY
     * @see com.flickr4java.flickr.Flickr#ACCURACY_REGION
     * @see com.flickr4java.flickr.Flickr#ACCURACY_CITY
     * @see com.flickr4java.flickr.Flickr#ACCURACY_STREET
     */ public void setAccuracy(int accuracy) { this.accuracy = accuracy; }  public float getLatitude() { return latitude; }  public void setLatitude(float latitude) { this.latitude = latitude; }  public float getLongitude() { return longitude; }  public void setLongitude(float longitude) { this.longitude = longitude; }  @Override
    public String toString() { return ""GeoData[longitude="" + longitude + "" latitude="" + latitude + "" accuracy="" + accuracy + ""]""; }  @Override
    public boolean equals(Object obj) { if ((obj == null) || (obj.getClass() != this.getClass())) { return false; } if (obj == this) { return true; } GeoData test = (GeoData) obj; return longitude == test.longitude && latitude == test.latitude && accuracy == test.accuracy; }  @Override
    public int hashCode() { int hash = 1; hash += Float.hashCode(longitude); hash += Float.hashCode(latitude); hash += Integer.hashCode(accuracy); return hash; } }  "
src/main/java/com/flickr4java/flickr/photos/Media.java,"/**
 * 
 */
package com.flickr4java.flickr.photos;

/**
 * For the media attribute returned for different photo sizes.
 * 
 * @author Darren Greaves
 * @see Size
 * 
 */
public enum Media {

    photo, video;
}
","package com.flickr4java.flickr.photos; public enum Media { photo, video; }",0 0 0 0 0,"package com.flickr4java.flickr.photos; public enum Media { photo, video; } ","/**
 * 
 */ package com.flickr4java.flickr.photos;  /**
 * For the media attribute returned for different photo sizes.
 * 
 * @author Darren Greaves
 * @see Size
 * 
 */ public enum Media {  photo, video; }  "
src/main/java/com/flickr4java/flickr/photos/Note.java,"
package com.flickr4java.flickr.photos;

import java.awt.Rectangle;

/**
 * @author Anthony Eden
 */
public class Note {

    private String id;

    private String author;

    private String authorName;

    private Rectangle bounds;

    private String text;

    public Note() {

    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public String getAuthorName() {
        return authorName;
    }

    public void setAuthorName(String authorName) {
        this.authorName = authorName;
    }

    public Rectangle getBounds() {
        return bounds;
    }

    public void setBounds(Rectangle bounds) {
        this.bounds = bounds;
    }

    public void setBounds(String x, String y, String w, String h) {
        int xi = Integer.parseInt(x);
        int yi = Integer.parseInt(y);
        int wi = Integer.parseInt(w);
        int hi = Integer.parseInt(h);
        setBounds(new Rectangle(xi, yi, wi, hi));
    }

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }

    @Override
    public boolean equals(Object obj) {
        if ((obj == null) || (obj.getClass() != this.getClass())) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        Note test = (Note) obj;
        // id doesn't change if you edit text (assume the same for move/resize), so test all attrs
        return areEqual(id, test.id) && areEqual(author, test.author) && areEqual(authorName, test.authorName) && areEqual(bounds, test.bounds)
                && areEqual(text, test.text);
    }

    @Override
    public int hashCode() {
        int hash = 1;
        if (id != null) {
            hash += id.hashCode();
        }
        return hash;
    }

    private boolean areEqual(Object x, Object y) {
        return x == null ? y == null : x.equals(y);
    }
}
","package com.flickr4java.flickr.photos; import java.awt.Rectangle; public class Note { private String id; private String author; private String authorName; private Rectangle bounds; private String text; public Note() { } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public String getAuthorName() { return authorName; } public void setAuthorName(String authorName) { this.authorName = authorName; } public Rectangle getBounds() { return bounds; } public void setBounds(Rectangle bounds) { this.bounds = bounds; } public void setBounds(String x, String y, String w, String h) { int xi = Integer.parseInt(x); int yi = Integer.parseInt(y); int wi = Integer.parseInt(w); int hi = Integer.parseInt(h); setBounds(new Rectangle(xi, yi, wi, hi)); } public String getText() { return text; } public void setText(String text) { this.text = text; } @Override
    public boolean equals(Object obj) { if ((obj == null) || (obj.getClass() != this.getClass())) { return false; } if (obj == this) { return true; } Note test = (Note) obj; return areEqual(id, test.id) && areEqual(author, test.author) && areEqual(authorName, test.authorName) && areEqual(bounds, test.bounds)
                && areEqual(text, test.text); } @Override
    public int hashCode() { int hash = 1; if (id != null) { hash += id.hashCode(); } return hash; } private boolean areEqual(Object x, Object y) { return x == null ? y == null : x.equals(y); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.photos; import java.awt.Rectangle; public class Note { private String id; private String author; private String authorName; private Rectangle bounds; private String text; public Note() { } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public String getAuthorName() { return authorName; } public void setAuthorName(String authorName) { this.authorName = authorName; } public Rectangle getBounds() { return bounds; } public void setBounds(Rectangle bounds) { this.bounds = bounds; } public void setBounds(String x, String y, String w, String h) { int xi = Integer.parseInt(x); int yi = Integer.parseInt(y); int wi = Integer.parseInt(w); int hi = Integer.parseInt(h); setBounds(new Rectangle(xi, yi, wi, hi)); } public String getText() { return text; } public void setText(String text) { this.text = text; } @Override
    public boolean equals(Object obj) { if ((obj == null) || (obj.getClass() != this.getClass())) { return false; } if (obj == this) { return true; } Note test = (Note) obj; return areEqual(id, test.id) && areEqual(author, test.author) && areEqual(authorName, test.authorName) && areEqual(bounds, test.bounds)
                && areEqual(text, test.text); } @Override
    public int hashCode() { int hash = 1; if (id != null) { hash += id.hashCode(); } return hash; } private boolean areEqual(Object x, Object y) { return x == null ? y == null : x.equals(y); } } "," package com.flickr4java.flickr.photos;  import java.awt.Rectangle;  /**
 * @author Anthony Eden
 */ public class Note {  private String id;  private String author;  private String authorName;  private Rectangle bounds;  private String text;  public Note() {  }  public String getId() { return id; }  public void setId(String id) { this.id = id; }  public String getAuthor() { return author; }  public void setAuthor(String author) { this.author = author; }  public String getAuthorName() { return authorName; }  public void setAuthorName(String authorName) { this.authorName = authorName; }  public Rectangle getBounds() { return bounds; }  public void setBounds(Rectangle bounds) { this.bounds = bounds; }  public void setBounds(String x, String y, String w, String h) { int xi = Integer.parseInt(x); int yi = Integer.parseInt(y); int wi = Integer.parseInt(w); int hi = Integer.parseInt(h); setBounds(new Rectangle(xi, yi, wi, hi)); }  public String getText() { return text; }  public void setText(String text) { this.text = text; }  @Override
    public boolean equals(Object obj) { if ((obj == null) || (obj.getClass() != this.getClass())) { return false; } if (obj == this) { return true; } Note test = (Note) obj; // id doesn't change if you edit text (assume the same for move/resize), so test all attrs return areEqual(id, test.id) && areEqual(author, test.author) && areEqual(authorName, test.authorName) && areEqual(bounds, test.bounds)
                && areEqual(text, test.text); }  @Override
    public int hashCode() { int hash = 1; if (id != null) { hash += id.hashCode(); } return hash; }  private boolean areEqual(Object x, Object y) { return x == null ? y == null : x.equals(y); } }  "
src/main/java/com/flickr4java/flickr/photos/Permissions.java,"
package com.flickr4java.flickr.photos;

/**
 * @author Anthony Eden
 */
public class Permissions {

    private String id;

    private boolean publicFlag;

    private boolean friendFlag;

    private boolean familyFlag;

    private int comment = 0;

    private int addmeta = 0;

    public Permissions() {

    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public boolean isPublicFlag() {
        return publicFlag;
    }

    public void setPublicFlag(boolean publicFlag) {
        this.publicFlag = publicFlag;
    }

    public boolean isFriendFlag() {
        return friendFlag;
    }

    public void setFriendFlag(boolean friendFlag) {
        this.friendFlag = friendFlag;
    }

    public boolean isFamilyFlag() {
        return familyFlag;
    }

    public void setFamilyFlag(boolean familyFlag) {
        this.familyFlag = familyFlag;
    }

    public int getComment() {
        return comment;
    }

    public void setComment(int comment) {
        this.comment = comment;
    }

    public void setComment(String comment) {
        if (comment != null) {
            setComment(Integer.parseInt(comment));
        }
    }

    public int getAddmeta() {
        return addmeta;
    }

    public void setAddmeta(int addmeta) {
        this.addmeta = addmeta;
    }

    public void setAddmeta(String addmeta) {
        if (addmeta != null) {
            setAddmeta(Integer.parseInt(addmeta));
        }
    }

    @Override
    public boolean equals(Object obj) {
        if ((obj == null) || (obj.getClass() != this.getClass())) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        Permissions test = (Permissions) obj;
        // id seems to be photo id
        if (id == null ? test.id == null : id.equals(test.id)) {
            return publicFlag == test.publicFlag && friendFlag == test.friendFlag && familyFlag == test.familyFlag && comment == test.comment
                    && addmeta == test.addmeta;
        }
        return false;
    }

    @Override
    public int hashCode() {
        int hash = 87;
        hash += id.hashCode();
        hash += Integer.hashCode(comment);
        hash += Integer.hashCode(addmeta);
        hash += Boolean.hashCode(publicFlag);
        hash += Boolean.hashCode(friendFlag);
        hash += Boolean.hashCode(familyFlag);
        return hash;
    }
}
","package com.flickr4java.flickr.photos; public class Permissions { private String id; private boolean publicFlag; private boolean friendFlag; private boolean familyFlag; private int comment = 0; private int addmeta = 0; public Permissions() { } public String getId() { return id; } public void setId(String id) { this.id = id; } public boolean isPublicFlag() { return publicFlag; } public void setPublicFlag(boolean publicFlag) { this.publicFlag = publicFlag; } public boolean isFriendFlag() { return friendFlag; } public void setFriendFlag(boolean friendFlag) { this.friendFlag = friendFlag; } public boolean isFamilyFlag() { return familyFlag; } public void setFamilyFlag(boolean familyFlag) { this.familyFlag = familyFlag; } public int getComment() { return comment; } public void setComment(int comment) { this.comment = comment; } public void setComment(String comment) { if (comment != null) { setComment(Integer.parseInt(comment)); } } public int getAddmeta() { return addmeta; } public void setAddmeta(int addmeta) { this.addmeta = addmeta; } public void setAddmeta(String addmeta) { if (addmeta != null) { setAddmeta(Integer.parseInt(addmeta)); } } @Override
    public boolean equals(Object obj) { if ((obj == null) || (obj.getClass() != this.getClass())) { return false; } if (obj == this) { return true; } Permissions test = (Permissions) obj; if (id == null ? test.id == null : id.equals(test.id)) { return publicFlag == test.publicFlag && friendFlag == test.friendFlag && familyFlag == test.familyFlag && comment == test.comment
                    && addmeta == test.addmeta; } return false; } @Override
    public int hashCode() { int hash = 87; hash += id.hashCode(); hash += Integer.hashCode(comment); hash += Integer.hashCode(addmeta); hash += Boolean.hashCode(publicFlag); hash += Boolean.hashCode(friendFlag); hash += Boolean.hashCode(familyFlag); return hash; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.photos; public class Permissions { private String id; private boolean publicFlag; private boolean friendFlag; private boolean familyFlag; private int comment = 0; private int addmeta = 0; public Permissions() { } public String getId() { return id; } public void setId(String id) { this.id = id; } public boolean isPublicFlag() { return publicFlag; } public void setPublicFlag(boolean publicFlag) { this.publicFlag = publicFlag; } public boolean isFriendFlag() { return friendFlag; } public void setFriendFlag(boolean friendFlag) { this.friendFlag = friendFlag; } public boolean isFamilyFlag() { return familyFlag; } public void setFamilyFlag(boolean familyFlag) { this.familyFlag = familyFlag; } public int getComment() { return comment; } public void setComment(int comment) { this.comment = comment; } public void setComment(String comment) { if (comment != null) { setComment(Integer.parseInt(comment)); } } public int getAddmeta() { return addmeta; } public void setAddmeta(int addmeta) { this.addmeta = addmeta; } public void setAddmeta(String addmeta) { if (addmeta != null) { setAddmeta(Integer.parseInt(addmeta)); } } @Override
    public boolean equals(Object obj) { if ((obj == null) || (obj.getClass() != this.getClass())) { return false; } if (obj == this) { return true; } Permissions test = (Permissions) obj; if (id == null ? test.id == null : id.equals(test.id)) { return publicFlag == test.publicFlag && friendFlag == test.friendFlag && familyFlag == test.familyFlag && comment == test.comment
                    && addmeta == test.addmeta; } return false; } @Override
    public int hashCode() { int hash = 87; hash += id.hashCode(); hash += Integer.hashCode(comment); hash += Integer.hashCode(addmeta); hash += Boolean.hashCode(publicFlag); hash += Boolean.hashCode(friendFlag); hash += Boolean.hashCode(familyFlag); return hash; } } "," package com.flickr4java.flickr.photos;  /**
 * @author Anthony Eden
 */ public class Permissions {  private String id;  private boolean publicFlag;  private boolean friendFlag;  private boolean familyFlag;  private int comment = 0;  private int addmeta = 0;  public Permissions() {  }  public String getId() { return id; }  public void setId(String id) { this.id = id; }  public boolean isPublicFlag() { return publicFlag; }  public void setPublicFlag(boolean publicFlag) { this.publicFlag = publicFlag; }  public boolean isFriendFlag() { return friendFlag; }  public void setFriendFlag(boolean friendFlag) { this.friendFlag = friendFlag; }  public boolean isFamilyFlag() { return familyFlag; }  public void setFamilyFlag(boolean familyFlag) { this.familyFlag = familyFlag; }  public int getComment() { return comment; }  public void setComment(int comment) { this.comment = comment; }  public void setComment(String comment) { if (comment != null) { setComment(Integer.parseInt(comment)); } }  public int getAddmeta() { return addmeta; }  public void setAddmeta(int addmeta) { this.addmeta = addmeta; }  public void setAddmeta(String addmeta) { if (addmeta != null) { setAddmeta(Integer.parseInt(addmeta)); } }  @Override
    public boolean equals(Object obj) { if ((obj == null) || (obj.getClass() != this.getClass())) { return false; } if (obj == this) { return true; } Permissions test = (Permissions) obj; // id seems to be photo id if (id == null ? test.id == null : id.equals(test.id)) { return publicFlag == test.publicFlag && friendFlag == test.friendFlag && familyFlag == test.familyFlag && comment == test.comment
                    && addmeta == test.addmeta; } return false; }  @Override
    public int hashCode() { int hash = 87; hash += id.hashCode(); hash += Integer.hashCode(comment); hash += Integer.hashCode(addmeta); hash += Boolean.hashCode(publicFlag); hash += Boolean.hashCode(friendFlag); hash += Boolean.hashCode(familyFlag); return hash; } }  "
src/main/java/com/flickr4java/flickr/photos/Photo.java,"
package com.flickr4java.flickr.photos;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.people.User;
import com.flickr4java.flickr.places.Place;
import com.flickr4java.flickr.stats.Stats;
import com.flickr4java.flickr.stats.StatsInterface;
import com.flickr4java.flickr.tags.Tag;
import com.flickr4java.flickr.util.IOUtilities;

import javax.imageio.ImageIO;

import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;

/**
 * Class representing metadata about a Flickr photo. Instances do not actually contain the photo data, however you can obtain the photo data by calling
 * {@link PhotosInterface#getImage(Photo, int)} or {@link PhotosInterface#getImageAsStream(Photo, int)}.
 * 
 * @author Anthony Eden
 * @version $Id: Photo.java,v 1.28 2009/07/23 21:49:35 x-mago Exp $
 */
public class Photo {

    private static final ThreadLocal<SimpleDateFormat> DATE_FORMATS = new ThreadLocal<SimpleDateFormat>() {
        @Override
        protected synchronized SimpleDateFormat initialValue() {
            return new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
        }
    };

    private static final String DEFAULT_ORIGINAL_IMAGE_SUFFIX = ""_o.jpg"";

    private static final String SMALL_SQUARE_IMAGE_SUFFIX = ""_s.jpg"";

    private static final String SMALL_IMAGE_SUFFIX = ""_m.jpg"";

    private static final String THUMBNAIL_IMAGE_SUFFIX = ""_t.jpg"";

    private static final String MEDIUM_IMAGE_SUFFIX = "".jpg"";

    private static final String LARGE_IMAGE_SUFFIX = ""_b.jpg"";

    private static final String LARGE_1600_IMAGE_SUFFIX = ""_h.jpg"";

    private static final String LARGE_2048_IMAGE_SUFFIX = ""_k.jpg"";

    private static final String SQUARE_LARGE_IMAGE_SUFFIX = ""_q.jpg"";

    private static final String SQUARE_320_IMAGE_SUFFIX = ""_n.jpg"";

    private static final String MEDIUM_640_IMAGE_SUFFIX = ""_z.jpg"";

    private static final String MEDIUM_800_IMAGE_SUFFIX = ""_c.jpg"";

    private Size squareSize;

    private Size smallSize;

    private Size thumbnailSize;

    private Size mediumSize;

    private Size largeSize;

    private Size large1600Size;

    private Size large2048Size;

    private Size originalSize;

    private Size squareLargeSize;

    private Size small320Size;

    private Size medium640Size;

    private Size medium800Size;

    private Size videoPlayer;

    private Size siteMP4;

    private Size videoOriginal;

    private Size mobileMP4;
    
    private Size hdMP4;
    
    private String id;

    private User owner;

    private String secret;

    private String farm;

    private String server;

    private boolean favorite;

    private String license;

    private boolean primary;

    private String title;

    private String description;

    private boolean publicFlag;

    private boolean friendFlag;

    private boolean familyFlag;

    private Date dateAdded;

    private Date datePosted;

    private Date dateTaken;

    private Date lastUpdate;

    private String takenGranularity;

    private Permissions permissions;

    private Editability editability;
    
    private Editability publicEditability;

    private int comments;

    private int views = -1;

    private int rotation;

    private Collection<Note> notes;

    private Collection<Tag> tags;

    private Collection<String> urls;

    private String iconServer;

    private String iconFarm;

    private String url;

    private GeoData geoData;

    private String originalFormat;

    private String originalSecret;

    private String placeId;

    private String media;

    private String mediaStatus;

    private String pathAlias;

    private int originalWidth;

    private int originalHeight;
    
    private PhotoUrl photoUrl;
    
    private Usage usage;
    
    private boolean hasPeople;

    private Place locality;

    private Place county;

    private Place region;

    private Place country;

    /**
     * Stats on views, comments and favorites. Only set on {@link StatsInterface#getPopularPhotos} call.
     */
    private Stats stats;

	

    public Photo() {
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public User getOwner() {
        return owner;
    }

    public void setOwner(User owner) {
        this.owner = owner;
    }

    public String getSecret() {
        return secret;
    }

    public void setSecret(String secret) {
        this.secret = secret;
    }

    public String getFarm() {
        return farm;
    }

    public void setFarm(String farm) {
        this.farm = farm;
    }

    public String getServer() {
        return server;
    }

    public void setServer(String server) {
        this.server = server;
    }

    public boolean isFavorite() {
        return favorite;
    }

    public void setFavorite(boolean favorite) {
        this.favorite = favorite;
    }

    public String getLicense() {
        return license;
    }

    public void setLicense(String license) {
        this.license = license;
    }

    public boolean isPrimary() {
        return primary;
    }

    public void setPrimary(boolean primary) {
        this.primary = primary;
    }

    public void setPrimary(String primary) {
        setPrimary(""1"".equals(primary));
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public boolean isPublicFlag() {
        return publicFlag;
    }

    public void setPublicFlag(boolean publicFlag) {
        this.publicFlag = publicFlag;
    }

    public boolean isFriendFlag() {
        return friendFlag;
    }

    public void setFriendFlag(boolean friendFlag) {
        this.friendFlag = friendFlag;
    }

    public boolean isFamilyFlag() {
        return familyFlag;
    }

    public void setFamilyFlag(boolean familyFlag) {
        this.familyFlag = familyFlag;
    }

    public Date getDateAdded() {
        return dateAdded;
    }

    public void setDateAdded(Date dateAdded) {
        this.dateAdded = dateAdded;
    }

    public void setDateAdded(long dateAdded) {
        setDateAdded(new Date(dateAdded));
    }

    public void setDateAdded(String dateAdded) {
        if (dateAdded == null || """".equals(dateAdded)) {
            return;
        }
        setDateAdded(Long.parseLong(dateAdded) * 1000);
    }

    public Date getDatePosted() {
        return datePosted;
    }

    public void setDatePosted(Date datePosted) {
        this.datePosted = datePosted;
    }

    public void setDatePosted(long datePosted) {
        setDatePosted(new Date(datePosted));
    }

    public void setDatePosted(String datePosted) {
        if (datePosted == null || """".equals(datePosted)) {
            return;
        }
        setDatePosted(Long.parseLong(datePosted) * 1000);
    }

    public Date getDateTaken() {
        return dateTaken;
    }

    public void setDateTaken(Date dateTaken) {
        this.dateTaken = dateTaken;
    }

    public void setDateTaken(String dateTaken) {
        if (dateTaken == null || """".equals(dateTaken)) {
            return;
        }
        try {
            setDateTaken(((DateFormat) DATE_FORMATS.get()).parse(dateTaken));
        } catch (ParseException e) {
            // TODO: figure out what to do with this error
            e.printStackTrace();
        }
    }

    public Date getLastUpdate() {
        return lastUpdate;
    }

    public void setLastUpdate(Date lastUpdate) {
        this.lastUpdate = lastUpdate;
    }

    public void setLastUpdate(String lastUpdateStr) {
        if (lastUpdateStr == null || """".equals(lastUpdateStr)) {
            return;
        }
        long unixTime = Long.parseLong(lastUpdateStr);
        setLastUpdate(new Date(unixTime * 1000L));
    }

    public String getTakenGranularity() {
        return takenGranularity;
    }

    public void setTakenGranularity(String takenGranularity) {
        this.takenGranularity = takenGranularity;
    }

    public Permissions getPermissions() {
        return permissions;
    }

    public void setPermissions(Permissions permissions) {
        this.permissions = permissions;
    }

    public Editability getEditability() {
        return editability;
    }

    public void setEditability(Editability editability) {
        this.editability = editability;
    }

    public int getComments() {
        return comments;
    }

    public void setComments(int comments) {
        this.comments = comments;
    }

    public void setComments(String comments) {
        if (comments != null) {
            setComments(Integer.parseInt(comments));
        }
    }

    public Collection<Note> getNotes() {
        return notes;
    }

    public void setNotes(Collection<Note> notes) {
        this.notes = notes;
    }

    public Collection<Tag> getTags() {
        return tags;
    }

    public void setTags(Collection<Tag> tags) {
        this.tags = tags;
    }

    /**
     * 
     * @return List of {@link PhotoUrl}
     */
    public Collection<String> getUrls() {
        return urls;
    }

    /**
     * 
     * @param urls
     *            List of {@link PhotoUrl}
     */
    public void setUrls(Collection<String> urls) {
        this.urls = urls;
    }

    /**
     * Sets the number of views for this Photo. For un-authenticated calls this value is not available and will be set to -1.
     * 
     * @param views
     * @deprecated attribute no longer available
     */
    @Deprecated
    public void setViews(String views) {
        if (views != null) {
            try {
                setViews(Integer.parseInt(views));
            } catch (NumberFormatException e) {
                setViews(-1);
            }
        }
    }

    /**
     * 
     * @param views
     * @deprecated attribute no longer available
     */
    @Deprecated
    public void setViews(int views) {
        this.views = views;
    }

    /**
     * Number of views. Set to -1 if the value is not available.
     * 
     * @return Number of views
     * @deprecated attribute no longer available
     */
    @Deprecated
    public int getViews() {
        return views;
    }

    /**
     * Set the degrees of rotation. Value will be set to -1, if not available.
     * 
     * @param rotation
     */
    public void setRotation(String rotation) {
        if (rotation != null) {
            try {
                setRotation(Integer.parseInt(rotation));
            } catch (NumberFormatException e) {
                setRotation(-1);
            }
        }
    }

    public void setRotation(int rotation) {
        this.rotation = rotation;
    }

    public int getRotation() {
        return rotation;
    }

    public String getIconServer() {
        return iconServer;
    }

    public void setIconServer(String iconServer) {
        this.iconServer = iconServer;
    }

    public String getIconFarm() {
        return iconFarm;
    }

    public void setIconFarm(String iconFarm) {
        this.iconFarm = iconFarm;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public GeoData getGeoData() {
        return geoData;
    }

    public void setGeoData(GeoData geoData) {
        this.geoData = geoData;
    }

    public boolean hasGeoData() {
        return geoData != null;
    }

    public String getOriginalFormat() {
        return originalFormat;
    }

    public void setOriginalFormat(String originalFormat) {
        this.originalFormat = originalFormat;
    }

    public String getOriginalSecret() {
        return originalSecret;
    }

    public void setOriginalSecret(String originalSecret) {
        this.originalSecret = originalSecret;
    }

    /**
     * @deprecated
     * @see PhotosInterface#getImage(Photo, int)
     * @return An Image
     * @throws IOException
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    @Deprecated
    public BufferedImage getOriginalImage() throws IOException, FlickrException {
        if (originalFormat != null) {
            return getOriginalImage(""_o."" + originalFormat);
        }
        return getOriginalImage(DEFAULT_ORIGINAL_IMAGE_SUFFIX);
    }

    /**
     * Get an InputStream for the original image. Callers must close the stream upon completion.
     * 
     * @deprecated
     * @see PhotosInterface#getImageAsStream(Photo, int)
     * @return The InputStream
     * @throws IOException
     */
    @Deprecated
    public InputStream getOriginalAsStream() throws IOException, FlickrException {
        if (originalFormat != null) {
            return getOriginalImageAsStream(""_o."" + originalFormat);
        }
        return getOriginalImageAsStream(DEFAULT_ORIGINAL_IMAGE_SUFFIX);
    }

    /**
     * Get the original image URL.
     * 
     * @return The original image URL
     */
    public String getOriginalUrl() throws FlickrException {
        if (originalSize == null) {
            if (originalFormat != null) {
                return getOriginalBaseImageUrl() + ""_o."" + originalFormat;
            }
            return getOriginalBaseImageUrl() + DEFAULT_ORIGINAL_IMAGE_SUFFIX;
        } else {
            return originalSize.getSource();
        }
    }

    /**
     * Get an Image object which is a 75x75 pixel square.
     * 
     * @deprecated
     * @see PhotosInterface#getImage(Photo, int)
     * @return An Image
     * @throws IOException
     */
    @Deprecated
    public BufferedImage getSmallSquareImage() throws IOException {
        return getImage(SMALL_SQUARE_IMAGE_SUFFIX);
    }

    /**
     * @deprecated
     * @see PhotosInterface#getImageAsStream(Photo, int)
     * @return The InputStream
     * @throws IOException
     */
    @Deprecated
    public InputStream getSmallSquareAsInputStream() throws IOException {
        return getImageAsStream(SMALL_SQUARE_IMAGE_SUFFIX);
    }

    public String getSmallSquareUrl() {
        if (squareSize == null) {
            return getBaseImageUrl() + SMALL_SQUARE_IMAGE_SUFFIX;
        } else {
            return squareSize.getSource();
        }
    }

    /**
     * @deprecated
     * @see PhotosInterface#getImage(Photo, int)
     * @return An Image
     * @throws IOException
     */
    @Deprecated
    public BufferedImage getThumbnailImage() throws IOException {
        return getImage(THUMBNAIL_IMAGE_SUFFIX);
    }

    /**
     * @deprecated
     * @see PhotosInterface#getImageAsStream(Photo, int)
     * @return The InputStream
     * @throws IOException
     */
    @Deprecated
    public InputStream getThumbnailAsInputStream() throws IOException {
        return getImageAsStream(THUMBNAIL_IMAGE_SUFFIX);
    }

    public String getThumbnailUrl() {
        if (thumbnailSize == null) {
            return getBaseImageUrl() + THUMBNAIL_IMAGE_SUFFIX;
        } else {
            return thumbnailSize.getSource();
        }
    }

    /**
     * @deprecated
     * @see PhotosInterface#getImage(Photo, int)
     * @return An Image
     * @throws IOException
     */
    @Deprecated
    public BufferedImage getSmallImage() throws IOException {
        return getImage(SMALL_IMAGE_SUFFIX);
    }

    /**
     * @deprecated
     * @see PhotosInterface#getImageAsStream(Photo, int)
     * @return The InputStream
     * @throws IOException
     */
    @Deprecated
    public InputStream getSmallAsInputStream() throws IOException {
        return getImageAsStream(SMALL_IMAGE_SUFFIX);
    }

    public String getSmallUrl() {
        if (smallSize == null) {
            return getBaseImageUrl() + SMALL_IMAGE_SUFFIX;
        } else {
            return smallSize.getSource();
        }
    }

    /**
     * @deprecated
     * @see PhotosInterface#getImage(Photo, int)
     * @return An Image
     * @throws IOException
     */
    @Deprecated
    public BufferedImage getMediumImage() throws IOException {
        return getImage(MEDIUM_IMAGE_SUFFIX);
    }

    /**
     * @deprecated
     * @see PhotosInterface#getImageAsStream(Photo, int)
     * @return The InputStream
     * @throws IOException
     */
    @Deprecated
    public InputStream getMediumAsStream() throws IOException {
        return getImageAsStream(MEDIUM_IMAGE_SUFFIX);
    }

    public String getMediumUrl() {
        if (mediumSize == null) {
            return getBaseImageUrl() + MEDIUM_IMAGE_SUFFIX;
        } else {
            return mediumSize.getSource();
        }
    }

    /**
     * @deprecated
     * @see PhotosInterface#getImage(Photo, int)
     * @return An Image
     * @throws IOException
     */
    @Deprecated
    public BufferedImage getLargeImage() throws IOException {
        return getImage(LARGE_IMAGE_SUFFIX);
    }

    /**
     * @deprecated
     * @see PhotosInterface#getImageAsStream(Photo, int)
     * @return The InputStream
     * @throws IOException
     */
    @Deprecated
    public InputStream getLargeAsStream() throws IOException {
        return getImageAsStream(LARGE_IMAGE_SUFFIX);
    }

    public String getLargeUrl() {
        if (largeSize == null) {
            return getBaseImageUrl() + LARGE_IMAGE_SUFFIX;
        } else {
            return largeSize.getSource();
        }
    }

    public String getLarge1600Url() {
        if (large1600Size == null) {
            return getBaseImageUrl() + LARGE_1600_IMAGE_SUFFIX;
        } else {
            return large1600Size.getSource();
        }
    }

    public String getLarge2048Url() {
        if (large2048Size == null) {
            return getBaseImageUrl() + LARGE_2048_IMAGE_SUFFIX;
        } else {
            return large2048Size.getSource();
        }
    }

    public String getSquareLargeUrl() {
        if (squareLargeSize == null) {
            return getBaseImageUrl() + SQUARE_LARGE_IMAGE_SUFFIX;
        } else {
            return squareLargeSize.getSource();
        }
    }

    public String getSmall320Url() {
        if (small320Size == null) {
            return getBaseImageUrl() + SQUARE_320_IMAGE_SUFFIX;
        } else {
            return small320Size.getSource();
        }
    }

    public String getMedium640Url() {
        if (medium640Size == null) {
            return getBaseImageUrl() + MEDIUM_640_IMAGE_SUFFIX;
        } else {
            return medium640Size.getSource();
        }
    }

    public String getMedium800Url() {
        if (medium800Size == null) {
            return getBaseImageUrl() + MEDIUM_800_IMAGE_SUFFIX;
        } else {
            return medium800Size.getSource();
        }
    }

    public String getVideoPlayerUrl() {
        if (videoPlayer == null) {
            return """";
        } else {
            return videoPlayer.getSource();
        }
    }

    public String getSiteMP4Url() {
        if (siteMP4 == null) {
            return """";
        } else {
            return siteMP4.getSource();
        }
    }

    public String getVideoOriginalUrl() {
        if (videoOriginal == null) {
            // Workaround for API limitations
            return String.format(""https://www.flickr.com/video_download.gne?id=%s&originalSecret=%s&secret=%s"", id, originalSecret, secret);
        } else {
            return videoOriginal.getSource();
        }
    }

    public String getMobileMp4Url() {
        if (mobileMP4 == null) {
            return """";
        } else {
            return mobileMP4.getSource();
        }
    }

    public String getHdMp4Url() {
        if (hdMP4 == null) {
            return """";
        } else {
            return hdMP4.getSource();
        }
    }

    /**
     * Get an image using the specified URL suffix.
     * 
     * @deprecated
     * @param suffix
     *            The URL suffix, including the .extension
     * @return The BufferedImage object
     * @throws IOException
     */
    @Deprecated
    private BufferedImage getImage(String suffix) throws IOException {
        StringBuffer buffer = getBaseImageUrl();
        buffer.append(suffix);
        return _getImage(buffer.toString());
    }

    /**
     * Get the original-image using the specified URL suffix.
     * 
     * @deprecated
     * @see PhotosInterface#getImage(Photo, int)
     * @param suffix
     *            The URL suffix, including the .extension
     * @return The BufferedImage object
     * @throws IOException
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    @Deprecated
    private BufferedImage getOriginalImage(String suffix) throws IOException, FlickrException {
        StringBuffer buffer = getOriginalBaseImageUrl();
        buffer.append(suffix);
        return _getImage(buffer.toString());
    }

    /**
     * @deprecated
     * @param urlStr
     * @return BufferedImage
     * @throws IOException
     */
    @Deprecated
    private BufferedImage _getImage(String urlStr) throws IOException {
        URL url = new URL(urlStr);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.connect();
        InputStream in = null;
        try {
            in = conn.getInputStream();
            return ImageIO.read(in);
        } finally {
            IOUtilities.close(in);
        }
    }

    /**
     * Get an image as a stream. Callers must be sure to close the stream when they are done with it.
     * 
     * @deprecated
     * @see PhotosInterface#getImageAsStream(Photo, int)
     * @param suffix
     *            The suffix
     * @return The InputStream
     * @throws IOException
     */
    @Deprecated
    private InputStream getImageAsStream(String suffix) throws IOException {
        StringBuffer buffer = getBaseImageUrl();
        buffer.append(suffix);
        return _getImageAsStream(buffer.toString());
    }

    /**
     * 
     * @deprecated
     * @see PhotosInterface#getImageAsStream(Photo, int)
     * @param suffix
     * @return InoutStream
     * @throws IOException
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    @Deprecated
    private InputStream getOriginalImageAsStream(String suffix) throws IOException, FlickrException {
        StringBuffer buffer = getOriginalBaseImageUrl();
        buffer.append(suffix);
        return _getImageAsStream(buffer.toString());
    }

    private InputStream _getImageAsStream(String urlStr) throws IOException {
        URL url = new URL(urlStr);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.connect();
        return conn.getInputStream();
    }

    private StringBuffer getBaseImageUrl() {
        StringBuffer buffer = new StringBuffer();
        buffer.append(_getBaseImageUrl());
        buffer.append(getSecret());
        return buffer;
    }

    private StringBuffer getOriginalBaseImageUrl() throws FlickrException, NullPointerException {
        StringBuffer buffer = new StringBuffer();
        buffer.append(_getBaseImageUrl());
        if (getOriginalSecret().length() > 8) {
            buffer.append(getOriginalSecret());
        } else {
            throw new FlickrException(""0"", ""OriginalUrl not available because of missing originalsecret."");
        }
        return buffer;
    }

    private StringBuffer _getBaseImageUrl() {
        StringBuffer buffer = new StringBuffer();
        buffer.append(""https://farm"");
        buffer.append(getFarm());
        buffer.append("".staticflickr.com/"");
        buffer.append(getServer());
        buffer.append(""/"");
        buffer.append(getId());
        buffer.append(""_"");
        return buffer;
    }

    /**
     * @return A placeId
     * @see com.flickr4java.flickr.places.PlacesInterface#resolvePlaceId(String)
     */
    public String getPlaceId() {
        return placeId;
    }

    public void setPlaceId(String placeId) {
        this.placeId = placeId;
    }

    public String getMedia() {
        return media;
    }

    public void setMedia(String media) {
        this.media = media;
    }

    public String getMediaStatus() {
        return mediaStatus;
    }

    public void setMediaStatus(String mediaStatus) {
        this.mediaStatus = mediaStatus;
    }

    public int getOriginalWidth() {
        return originalWidth;
    }

    public void setOriginalWidth(String originalWidth) {
        try {
            setOriginalWidth(Integer.parseInt(originalWidth));
        } catch (NumberFormatException ex) {
        }
    }

    public void setOriginalWidth(int originalWidth) {
        this.originalWidth = originalWidth;
    }

    public int getOriginalHeight() {
        return originalHeight;
    }

    public void setOriginalHeight(String originalHeight) {
        try {
            setOriginalHeight(Integer.parseInt(originalHeight));
        } catch (NumberFormatException ex) {
        }
    }

    public void setOriginalHeight(int originalHeight) {
        this.originalHeight = originalHeight;
    }

    /**
     * Set sizes to override the generated URLs of the different sizes.
     * 
     * @param sizes
     * @see com.flickr4java.flickr.photos.PhotosInterface#getSizes(String)
     */
    public void setSizes(Collection<Size> sizes) {
        for (Size size : sizes) {
            if (size.getLabel() == Size.SMALL) {
                smallSize = size;
            } else if (size.getLabel() == Size.SQUARE) {
                squareSize = size;
            } else if (size.getLabel() == Size.THUMB) {
                thumbnailSize = size;
            } else if (size.getLabel() == Size.MEDIUM) {
                mediumSize = size;
            } else if (size.getLabel() == Size.LARGE) {
                largeSize = size;
            } else if (size.getLabel() == Size.LARGE_1600) {
                large1600Size = size;
            } else if (size.getLabel() == Size.LARGE_2048) {
                large2048Size = size;
            } else if (size.getLabel() == Size.ORIGINAL) {
                originalSize = size;
            } else if (size.getLabel() == Size.SQUARE_LARGE) {
                squareLargeSize = size;
            } else if (size.getLabel() == Size.SMALL_320) {
                small320Size = size;
            } else if (size.getLabel() == Size.MEDIUM_640) {
                medium640Size = size;
            } else if (size.getLabel() == Size.MEDIUM_800) {
                medium800Size = size;
            } else if (size.getLabel() == Size.VIDEO_PLAYER) {
                videoPlayer = size;
            } else if (size.getLabel() == Size.SITE_MP4) {
                siteMP4 = size;
            } else if (size.getLabel() == Size.VIDEO_ORIGINAL) {
                videoOriginal = size;
            }
            else if (size.getLabel() == Size.MOBILE_MP4) {
            	mobileMP4 = size;
            }
            else if (size.getLabel() == Size.HD_MP4) {
            	hdMP4 = size;
            }
        }
    }

    public Collection<Size> getSizes() {
        return Arrays.asList(
                smallSize, squareSize, thumbnailSize, mediumSize,
                largeSize, large1600Size, large2048Size, originalSize,
                squareLargeSize, small320Size, medium640Size, medium800Size,
                videoPlayer, siteMP4, videoOriginal, mobileMP4, hdMP4
        );
    }

    public Size getSquareSize() {
        return squareSize;
    }

    public Size getSmallSize() {
        return smallSize;
    }

    public Size getThumbnailSize() {
        return thumbnailSize;
    }

    public Size getMediumSize() {
        return mediumSize;
    }

    public Size getLargeSize() {
        return largeSize;
    }

    public Size getLarge1600Size() {
        return large1600Size;
    }

    public Size getLarge2048Size() {
        return large2048Size;
    }

    public Size getOriginalSize() {
        return originalSize;
    }

    public Size getSquareLargeSize() {
        return squareLargeSize;
    }

    public Size getSmall320Size() {
        return small320Size;
    }

    public Size getMedium640Size() {
        return medium640Size;
    }

    public Size getMedium800Size() {
        return medium800Size;
    }

    public Size getVideoPlayerSize() {
        return videoPlayer;
    }

    public Size getSiteMP4Size() {
        return siteMP4;
    }

    public Size getVideoOriginalSize() {
        return videoOriginal;
    }

    /**
   	 * @return the mobileMP4
   	 */
   	public Size getMobileMp4() {
   		return mobileMP4;
   	}

   	/**
   	 * @param mobileMP4 the mobileMP4 to set
   	 */
   	public void setMobileMp4(Size mobileMP4) {
   		this.mobileMP4 = mobileMP4;
   	}

   	/**
   	 * @return the hdMP4
   	 */
   	public Size getHdMp4() {
   		return hdMP4;
   	}

   	/**
   	 * @param hdMP4 the hdMP4 to set
   	 */
   	public void setHdMp4(Size hdMP4) {
   		this.hdMP4 = hdMP4;
   	}

    /**
     * @return the pathAlias
     */
    public String getPathAlias() {
        return pathAlias;
    }

    /**
     * @param pathAlias
     *            the pathAlias to set
     */
    public void setPathAlias(String pathAlias) {
        this.pathAlias = pathAlias;
    }

    public Stats getStats() {
        return stats;
    }

    public void setStats(Stats stats) {
        this.stats = stats;
    }

    @Override
    public boolean equals(Object obj) {
        if ((obj == null) || (obj.getClass() != this.getClass())) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        Photo test = (Photo) obj;
        // TODO: not sure if these tests are sufficient
        return areEqual(id, test.id) && areEqual(secret, test.secret);
    }

    @Override
    public int hashCode() {
        int hash = 83;
        if (id != null) {
            hash ^= id.hashCode();
        }
        if (secret != null) {
            hash ^= secret.hashCode();
        }
        return hash;
    }

    private boolean areEqual(Object x, Object y) {
        return x == null ? y == null : x.equals(y);
    }
    
    public PhotoUrl getPhotoUrl() {
		return photoUrl;
	}

	public void setPhotoUrl(PhotoUrl photoUrl) {
		this.photoUrl = photoUrl;
		
	}
	
	public Usage getUsage() {
		return usage;
	}

	public void setUsage(Usage usage) {
		this.usage = usage;
		
	}

	public Editability getPublicEditability() {
		return publicEditability;
	}

	public void setPublicEditability(Editability publicEditability) {
		this.publicEditability = publicEditability;
	}

	public boolean isHasPeople() {
		return hasPeople;
	}

	public void setIsHasPeople(boolean hasPeople) {
		this.hasPeople = hasPeople;
	}

    public Place getLocality() {
        return locality;
    }

    public void setLocality(Place locality) {
        this.locality = locality;
    }

    public Place getCounty() {
        return county;
    }

    public void setCounty(Place county) {
        this.county = county;
    }

    public Place getRegion() {
        return region;
    }

    public void setRegion(Place region) {
        this.region = region;
    }

    public Place getCountry() {
        return country;
    }

    public void setCountry(Place country) {
        this.country = country;
    }
	
}
","package com.flickr4java.flickr.photos; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.places.Place; import com.flickr4java.flickr.stats.Stats; import com.flickr4java.flickr.stats.StatsInterface; import com.flickr4java.flickr.tags.Tag; import com.flickr4java.flickr.util.IOUtilities; import javax.imageio.ImageIO; import java.awt.image.BufferedImage; import java.io.IOException; import java.io.InputStream; import java.net.HttpURLConnection; import java.net.URL; import java.text.DateFormat; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Arrays; import java.util.Collection; import java.util.Date; public class Photo { private static final ThreadLocal<SimpleDateFormat> DATE_FORMATS = new ThreadLocal<SimpleDateFormat>() { @Override
        protected synchronized SimpleDateFormat initialValue() { return new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); } } ; private static final String DEFAULT_ORIGINAL_IMAGE_SUFFIX = ""_o.jpg""; private static final String SMALL_SQUARE_IMAGE_SUFFIX = ""_s.jpg""; private static final String SMALL_IMAGE_SUFFIX = ""_m.jpg""; private static final String THUMBNAIL_IMAGE_SUFFIX = ""_t.jpg""; private static final String MEDIUM_IMAGE_SUFFIX = "".jpg""; private static final String LARGE_IMAGE_SUFFIX = ""_b.jpg""; private static final String LARGE_1600_IMAGE_SUFFIX = ""_h.jpg""; private static final String LARGE_2048_IMAGE_SUFFIX = ""_k.jpg""; private static final String SQUARE_LARGE_IMAGE_SUFFIX = ""_q.jpg""; private static final String SQUARE_320_IMAGE_SUFFIX = ""_n.jpg""; private static final String MEDIUM_640_IMAGE_SUFFIX = ""_z.jpg""; private static final String MEDIUM_800_IMAGE_SUFFIX = ""_c.jpg""; private Size squareSize; private Size smallSize; private Size thumbnailSize; private Size mediumSize; private Size largeSize; private Size large1600Size; private Size large2048Size; private Size originalSize; private Size squareLargeSize; private Size small320Size; private Size medium640Size; private Size medium800Size; private Size videoPlayer; private Size siteMP4; private Size videoOriginal; private Size mobileMP4; private Size hdMP4; private String id; private User owner; private String secret; private String farm; private String server; private boolean favorite; private String license; private boolean primary; private String title; private String description; private boolean publicFlag; private boolean friendFlag; private boolean familyFlag; private Date dateAdded; private Date datePosted; private Date dateTaken; private Date lastUpdate; private String takenGranularity; private Permissions permissions; private Editability editability; private Editability publicEditability; private int comments; private int views = -1; private int rotation; private Collection<Note> notes; private Collection<Tag> tags; private Collection<String> urls; private String iconServer; private String iconFarm; private String url; private GeoData geoData; private String originalFormat; private String originalSecret; private String placeId; private String media; private String mediaStatus; private String pathAlias; private int originalWidth; private int originalHeight; private PhotoUrl photoUrl; private Usage usage; private boolean hasPeople; private Place locality; private Place county; private Place region; private Place country; private Stats stats; public Photo() { } public String getId() { return id; } public void setId(String id) { this.id = id; } public User getOwner() { return owner; } public void setOwner(User owner) { this.owner = owner; } public String getSecret() { return secret; } public void setSecret(String secret) { this.secret = secret; } public String getFarm() { return farm; } public void setFarm(String farm) { this.farm = farm; } public String getServer() { return server; } public void setServer(String server) { this.server = server; } public boolean isFavorite() { return favorite; } public void setFavorite(boolean favorite) { this.favorite = favorite; } public String getLicense() { return license; } public void setLicense(String license) { this.license = license; } public boolean isPrimary() { return primary; } public void setPrimary(boolean primary) { this.primary = primary; } public void setPrimary(String primary) { setPrimary(""1"".equals(primary)); } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public boolean isPublicFlag() { return publicFlag; } public void setPublicFlag(boolean publicFlag) { this.publicFlag = publicFlag; } public boolean isFriendFlag() { return friendFlag; } public void setFriendFlag(boolean friendFlag) { this.friendFlag = friendFlag; } public boolean isFamilyFlag() { return familyFlag; } public void setFamilyFlag(boolean familyFlag) { this.familyFlag = familyFlag; } public Date getDateAdded() { return dateAdded; } public void setDateAdded(Date dateAdded) { this.dateAdded = dateAdded; } public void setDateAdded(long dateAdded) { setDateAdded(new Date(dateAdded)); } public void setDateAdded(String dateAdded) { if (dateAdded == null || """".equals(dateAdded)) { return; } setDateAdded(Long.parseLong(dateAdded) * 1000); } public Date getDatePosted() { return datePosted; } public void setDatePosted(Date datePosted) { this.datePosted = datePosted; } public void setDatePosted(long datePosted) { setDatePosted(new Date(datePosted)); } public void setDatePosted(String datePosted) { if (datePosted == null || """".equals(datePosted)) { return; } setDatePosted(Long.parseLong(datePosted) * 1000); } public Date getDateTaken() { return dateTaken; } public void setDateTaken(Date dateTaken) { this.dateTaken = dateTaken; } public void setDateTaken(String dateTaken) { if (dateTaken == null || """".equals(dateTaken)) { return; } try { setDateTaken(((DateFormat) DATE_FORMATS.get()).parse(dateTaken)); } catch (ParseException e) { e.printStackTrace(); } } public Date getLastUpdate() { return lastUpdate; } public void setLastUpdate(Date lastUpdate) { this.lastUpdate = lastUpdate; } public void setLastUpdate(String lastUpdateStr) { if (lastUpdateStr == null || """".equals(lastUpdateStr)) { return; } long unixTime = Long.parseLong(lastUpdateStr); setLastUpdate(new Date(unixTime * 1000L)); } public String getTakenGranularity() { return takenGranularity; } public void setTakenGranularity(String takenGranularity) { this.takenGranularity = takenGranularity; } public Permissions getPermissions() { return permissions; } public void setPermissions(Permissions permissions) { this.permissions = permissions; } public Editability getEditability() { return editability; } public void setEditability(Editability editability) { this.editability = editability; } public int getComments() { return comments; } public void setComments(int comments) { this.comments = comments; } public void setComments(String comments) { if (comments != null) { setComments(Integer.parseInt(comments)); } } public Collection<Note> getNotes() { return notes; } public void setNotes(Collection<Note> notes) { this.notes = notes; } public Collection<Tag> getTags() { return tags; } public void setTags(Collection<Tag> tags) { this.tags = tags; } public Collection<String> getUrls() { return urls; } public void setUrls(Collection<String> urls) { this.urls = urls; } @Deprecated
    public void setViews(String views) { if (views != null) { try { setViews(Integer.parseInt(views)); } catch (NumberFormatException e) { setViews(-1); } } } @Deprecated
    public void setViews(int views) { this.views = views; } @Deprecated
    public int getViews() { return views; } public void setRotation(String rotation) { if (rotation != null) { try { setRotation(Integer.parseInt(rotation)); } catch (NumberFormatException e) { setRotation(-1); } } } public void setRotation(int rotation) { this.rotation = rotation; } public int getRotation() { return rotation; } public String getIconServer() { return iconServer; } public void setIconServer(String iconServer) { this.iconServer = iconServer; } public String getIconFarm() { return iconFarm; } public void setIconFarm(String iconFarm) { this.iconFarm = iconFarm; } public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } public GeoData getGeoData() { return geoData; } public void setGeoData(GeoData geoData) { this.geoData = geoData; } public boolean hasGeoData() { return geoData != null; } public String getOriginalFormat() { return originalFormat; } public void setOriginalFormat(String originalFormat) { this.originalFormat = originalFormat; } public String getOriginalSecret() { return originalSecret; } public void setOriginalSecret(String originalSecret) { this.originalSecret = originalSecret; } @Deprecated
    public BufferedImage getOriginalImage() throws IOException, FlickrException { if (originalFormat != null) { return getOriginalImage(""_o."" + originalFormat); } return getOriginalImage(DEFAULT_ORIGINAL_IMAGE_SUFFIX); } @Deprecated
    public InputStream getOriginalAsStream() throws IOException, FlickrException { if (originalFormat != null) { return getOriginalImageAsStream(""_o."" + originalFormat); } return getOriginalImageAsStream(DEFAULT_ORIGINAL_IMAGE_SUFFIX); } public String getOriginalUrl() throws FlickrException { if (originalSize == null) { if (originalFormat != null) { return getOriginalBaseImageUrl() + ""_o."" + originalFormat; } return getOriginalBaseImageUrl() + DEFAULT_ORIGINAL_IMAGE_SUFFIX; } else { return originalSize.getSource(); } } @Deprecated
    public BufferedImage getSmallSquareImage() throws IOException { return getImage(SMALL_SQUARE_IMAGE_SUFFIX); } @Deprecated
    public InputStream getSmallSquareAsInputStream() throws IOException { return getImageAsStream(SMALL_SQUARE_IMAGE_SUFFIX); } public String getSmallSquareUrl() { if (squareSize == null) { return getBaseImageUrl() + SMALL_SQUARE_IMAGE_SUFFIX; } else { return squareSize.getSource(); } } @Deprecated
    public BufferedImage getThumbnailImage() throws IOException { return getImage(THUMBNAIL_IMAGE_SUFFIX); } @Deprecated
    public InputStream getThumbnailAsInputStream() throws IOException { return getImageAsStream(THUMBNAIL_IMAGE_SUFFIX); } public String getThumbnailUrl() { if (thumbnailSize == null) { return getBaseImageUrl() + THUMBNAIL_IMAGE_SUFFIX; } else { return thumbnailSize.getSource(); } } @Deprecated
    public BufferedImage getSmallImage() throws IOException { return getImage(SMALL_IMAGE_SUFFIX); } @Deprecated
    public InputStream getSmallAsInputStream() throws IOException { return getImageAsStream(SMALL_IMAGE_SUFFIX); } public String getSmallUrl() { if (smallSize == null) { return getBaseImageUrl() + SMALL_IMAGE_SUFFIX; } else { return smallSize.getSource(); } } @Deprecated
    public BufferedImage getMediumImage() throws IOException { return getImage(MEDIUM_IMAGE_SUFFIX); } @Deprecated
    public InputStream getMediumAsStream() throws IOException { return getImageAsStream(MEDIUM_IMAGE_SUFFIX); } public String getMediumUrl() { if (mediumSize == null) { return getBaseImageUrl() + MEDIUM_IMAGE_SUFFIX; } else { return mediumSize.getSource(); } } @Deprecated
    public BufferedImage getLargeImage() throws IOException { return getImage(LARGE_IMAGE_SUFFIX); } @Deprecated
    public InputStream getLargeAsStream() throws IOException { return getImageAsStream(LARGE_IMAGE_SUFFIX); } public String getLargeUrl() { if (largeSize == null) { return getBaseImageUrl() + LARGE_IMAGE_SUFFIX; } else { return largeSize.getSource(); } } public String getLarge1600Url() { if (large1600Size == null) { return getBaseImageUrl() + LARGE_1600_IMAGE_SUFFIX; } else { return large1600Size.getSource(); } } public String getLarge2048Url() { if (large2048Size == null) { return getBaseImageUrl() + LARGE_2048_IMAGE_SUFFIX; } else { return large2048Size.getSource(); } } public String getSquareLargeUrl() { if (squareLargeSize == null) { return getBaseImageUrl() + SQUARE_LARGE_IMAGE_SUFFIX; } else { return squareLargeSize.getSource(); } } public String getSmall320Url() { if (small320Size == null) { return getBaseImageUrl() + SQUARE_320_IMAGE_SUFFIX; } else { return small320Size.getSource(); } } public String getMedium640Url() { if (medium640Size == null) { return getBaseImageUrl() + MEDIUM_640_IMAGE_SUFFIX; } else { return medium640Size.getSource(); } } public String getMedium800Url() { if (medium800Size == null) { return getBaseImageUrl() + MEDIUM_800_IMAGE_SUFFIX; } else { return medium800Size.getSource(); } } public String getVideoPlayerUrl() { if (videoPlayer == null) { return """"; } else { return videoPlayer.getSource(); } } public String getSiteMP4Url() { if (siteMP4 == null) { return """"; } else { return siteMP4.getSource(); } } public String getVideoOriginalUrl() { if (videoOriginal == null) { } else { return videoOriginal.getSource(); } } public String getMobileMp4Url() { if (mobileMP4 == null) { return """"; } else { return mobileMP4.getSource(); } } public String getHdMp4Url() { if (hdMP4 == null) { return """"; } else { return hdMP4.getSource(); } } @Deprecated
    private BufferedImage getImage(String suffix) throws IOException { StringBuffer buffer = getBaseImageUrl(); buffer.append(suffix); return _getImage(buffer.toString()); } @Deprecated
    private BufferedImage getOriginalImage(String suffix) throws IOException, FlickrException { StringBuffer buffer = getOriginalBaseImageUrl(); buffer.append(suffix); return _getImage(buffer.toString()); } @Deprecated
    private BufferedImage _getImage(String urlStr) throws IOException { URL url = new URL(urlStr); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.connect(); InputStream in = null; try { in = conn.getInputStream(); return ImageIO.read(in); } finally { IOUtilities.close(in); } } @Deprecated
    private InputStream getImageAsStream(String suffix) throws IOException { StringBuffer buffer = getBaseImageUrl(); buffer.append(suffix); return _getImageAsStream(buffer.toString()); } @Deprecated
    private InputStream getOriginalImageAsStream(String suffix) throws IOException, FlickrException { StringBuffer buffer = getOriginalBaseImageUrl(); buffer.append(suffix); return _getImageAsStream(buffer.toString()); } private InputStream _getImageAsStream(String urlStr) throws IOException { URL url = new URL(urlStr); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.connect(); return conn.getInputStream(); } private StringBuffer getBaseImageUrl() { StringBuffer buffer = new StringBuffer(); buffer.append(_getBaseImageUrl()); buffer.append(getSecret()); return buffer; } private StringBuffer getOriginalBaseImageUrl() throws FlickrException, NullPointerException { StringBuffer buffer = new StringBuffer(); buffer.append(_getBaseImageUrl()); if (getOriginalSecret().length() > 8) { buffer.append(getOriginalSecret()); } else { throw new FlickrException(""0"", ""OriginalUrl not available because of missing originalsecret.""); } return buffer; } private StringBuffer _getBaseImageUrl() { StringBuffer buffer = new StringBuffer(); buffer.append(getFarm()); buffer.append("".staticflickr.com/""); buffer.append(getServer()); buffer.append(""/""); buffer.append(getId()); buffer.append(""_""); return buffer; } public String getPlaceId() { return placeId; } public void setPlaceId(String placeId) { this.placeId = placeId; } public String getMedia() { return media; } public void setMedia(String media) { this.media = media; } public String getMediaStatus() { return mediaStatus; } public void setMediaStatus(String mediaStatus) { this.mediaStatus = mediaStatus; } public int getOriginalWidth() { return originalWidth; } public void setOriginalWidth(String originalWidth) { try { setOriginalWidth(Integer.parseInt(originalWidth)); } catch (NumberFormatException ex) { } } public void setOriginalWidth(int originalWidth) { this.originalWidth = originalWidth; } public int getOriginalHeight() { return originalHeight; } public void setOriginalHeight(String originalHeight) { try { setOriginalHeight(Integer.parseInt(originalHeight)); } catch (NumberFormatException ex) { } } public void setOriginalHeight(int originalHeight) { this.originalHeight = originalHeight; } public void setSizes(Collection<Size> sizes) { for (Size size : sizes) { if (size.getLabel() == Size.SMALL) { smallSize = size; } else if (size.getLabel() == Size.SQUARE) { squareSize = size; } else if (size.getLabel() == Size.THUMB) { thumbnailSize = size; } else if (size.getLabel() == Size.MEDIUM) { mediumSize = size; } else if (size.getLabel() == Size.LARGE) { largeSize = size; } else if (size.getLabel() == Size.LARGE_1600) { large1600Size = size; } else if (size.getLabel() == Size.LARGE_2048) { large2048Size = size; } else if (size.getLabel() == Size.ORIGINAL) { originalSize = size; } else if (size.getLabel() == Size.SQUARE_LARGE) { squareLargeSize = size; } else if (size.getLabel() == Size.SMALL_320) { small320Size = size; } else if (size.getLabel() == Size.MEDIUM_640) { medium640Size = size; } else if (size.getLabel() == Size.MEDIUM_800) { medium800Size = size; } else if (size.getLabel() == Size.VIDEO_PLAYER) { videoPlayer = size; } else if (size.getLabel() == Size.SITE_MP4) { siteMP4 = size; } else if (size.getLabel() == Size.VIDEO_ORIGINAL) { videoOriginal = size; } else if (size.getLabel() == Size.MOBILE_MP4) { mobileMP4 = size; } else if (size.getLabel() == Size.HD_MP4) { hdMP4 = size; } } } public Collection<Size> getSizes() { return Arrays.asList(
                smallSize, squareSize, thumbnailSize, mediumSize,
                largeSize, large1600Size, large2048Size, originalSize,
                squareLargeSize, small320Size, medium640Size, medium800Size,
                videoPlayer, siteMP4, videoOriginal, mobileMP4, hdMP4
        ); } public Size getSquareSize() { return squareSize; } public Size getSmallSize() { return smallSize; } public Size getThumbnailSize() { return thumbnailSize; } public Size getMediumSize() { return mediumSize; } public Size getLargeSize() { return largeSize; } public Size getLarge1600Size() { return large1600Size; } public Size getLarge2048Size() { return large2048Size; } public Size getOriginalSize() { return originalSize; } public Size getSquareLargeSize() { return squareLargeSize; } public Size getSmall320Size() { return small320Size; } public Size getMedium640Size() { return medium640Size; } public Size getMedium800Size() { return medium800Size; } public Size getVideoPlayerSize() { return videoPlayer; } public Size getSiteMP4Size() { return siteMP4; } public Size getVideoOriginalSize() { return videoOriginal; } public Size getMobileMp4() { return mobileMP4; } public void setMobileMp4(Size mobileMP4) { this.mobileMP4 = mobileMP4; } public Size getHdMp4() { return hdMP4; } public void setHdMp4(Size hdMP4) { this.hdMP4 = hdMP4; } public String getPathAlias() { return pathAlias; } public void setPathAlias(String pathAlias) { this.pathAlias = pathAlias; } public Stats getStats() { return stats; } public void setStats(Stats stats) { this.stats = stats; } @Override
    public boolean equals(Object obj) { if ((obj == null) || (obj.getClass() != this.getClass())) { return false; } if (obj == this) { return true; } Photo test = (Photo) obj; return areEqual(id, test.id) && areEqual(secret, test.secret); } @Override
    public int hashCode() { int hash = 83; if (id != null) { hash ^= id.hashCode(); } if (secret != null) { hash ^= secret.hashCode(); } return hash; } private boolean areEqual(Object x, Object y) { return x == null ? y == null : x.equals(y); } public PhotoUrl getPhotoUrl() { return photoUrl; } public void setPhotoUrl(PhotoUrl photoUrl) { this.photoUrl = photoUrl; } public Usage getUsage() { return usage; } public void setUsage(Usage usage) { this.usage = usage; } public Editability getPublicEditability() { return publicEditability; } public void setPublicEditability(Editability publicEditability) { this.publicEditability = publicEditability; } public boolean isHasPeople() { return hasPeople; } public void setIsHasPeople(boolean hasPeople) { this.hasPeople = hasPeople; } public Place getLocality() { return locality; } public void setLocality(Place locality) { this.locality = locality; } public Place getCounty() { return county; } public void setCounty(Place county) { this.county = county; } public Place getRegion() { return region; } public void setRegion(Place region) { this.region = region; } public Place getCountry() { return country; } public void setCountry(Place country) { this.country = country; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.photos; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.places.Place; import com.flickr4java.flickr.stats.Stats; import com.flickr4java.flickr.stats.StatsInterface; import com.flickr4java.flickr.tags.Tag; import com.flickr4java.flickr.util.IOUtilities; import javax.imageio.ImageIO; import java.awt.image.BufferedImage; import java.io.IOException; import java.io.InputStream; import java.net.HttpURLConnection; import java.net.URL; import java.text.DateFormat; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Arrays; import java.util.Collection; import java.util.Date; public class Photo { private static final ThreadLocal<SimpleDateFormat> DATE_FORMATS = new ThreadLocal<SimpleDateFormat>() { @Override
        protected synchronized SimpleDateFormat initialValue() { return new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); } } ; private static final String DEFAULT_ORIGINAL_IMAGE_SUFFIX = ""_o.jpg""; private static final String SMALL_SQUARE_IMAGE_SUFFIX = ""_s.jpg""; private static final String SMALL_IMAGE_SUFFIX = ""_m.jpg""; private static final String THUMBNAIL_IMAGE_SUFFIX = ""_t.jpg""; private static final String MEDIUM_IMAGE_SUFFIX = "".jpg""; private static final String LARGE_IMAGE_SUFFIX = ""_b.jpg""; private static final String LARGE_1600_IMAGE_SUFFIX = ""_h.jpg""; private static final String LARGE_2048_IMAGE_SUFFIX = ""_k.jpg""; private static final String SQUARE_LARGE_IMAGE_SUFFIX = ""_q.jpg""; private static final String SQUARE_320_IMAGE_SUFFIX = ""_n.jpg""; private static final String MEDIUM_640_IMAGE_SUFFIX = ""_z.jpg""; private static final String MEDIUM_800_IMAGE_SUFFIX = ""_c.jpg""; private Size squareSize; private Size smallSize; private Size thumbnailSize; private Size mediumSize; private Size largeSize; private Size large1600Size; private Size large2048Size; private Size originalSize; private Size squareLargeSize; private Size small320Size; private Size medium640Size; private Size medium800Size; private Size videoPlayer; private Size siteMP4; private Size videoOriginal; private Size mobileMP4; private Size hdMP4; private String id; private User owner; private String secret; private String farm; private String server; private boolean favorite; private String license; private boolean primary; private String title; private String description; private boolean publicFlag; private boolean friendFlag; private boolean familyFlag; private Date dateAdded; private Date datePosted; private Date dateTaken; private Date lastUpdate; private String takenGranularity; private Permissions permissions; private Editability editability; private Editability publicEditability; private int comments; private int views = -1; private int rotation; private Collection<Note> notes; private Collection<Tag> tags; private Collection<String> urls; private String iconServer; private String iconFarm; private String url; private GeoData geoData; private String originalFormat; private String originalSecret; private String placeId; private String media; private String mediaStatus; private String pathAlias; private int originalWidth; private int originalHeight; private PhotoUrl photoUrl; private Usage usage; private boolean hasPeople; private Place locality; private Place county; private Place region; private Place country; private Stats stats; public Photo() { } public String getId() { return id; } public void setId(String id) { this.id = id; } public User getOwner() { return owner; } public void setOwner(User owner) { this.owner = owner; } public String getSecret() { return secret; } public void setSecret(String secret) { this.secret = secret; } public String getFarm() { return farm; } public void setFarm(String farm) { this.farm = farm; } public String getServer() { return server; } public void setServer(String server) { this.server = server; } public boolean isFavorite() { return favorite; } public void setFavorite(boolean favorite) { this.favorite = favorite; } public String getLicense() { return license; } public void setLicense(String license) { this.license = license; } public boolean isPrimary() { return primary; } public void setPrimary(boolean primary) { this.primary = primary; } public void setPrimary(String primary) { setPrimary(""1"".equals(primary)); } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public boolean isPublicFlag() { return publicFlag; } public void setPublicFlag(boolean publicFlag) { this.publicFlag = publicFlag; } public boolean isFriendFlag() { return friendFlag; } public void setFriendFlag(boolean friendFlag) { this.friendFlag = friendFlag; } public boolean isFamilyFlag() { return familyFlag; } public void setFamilyFlag(boolean familyFlag) { this.familyFlag = familyFlag; } public Date getDateAdded() { return dateAdded; } public void setDateAdded(Date dateAdded) { this.dateAdded = dateAdded; } public void setDateAdded(long dateAdded) { setDateAdded(new Date(dateAdded)); } public void setDateAdded(String dateAdded) { if (dateAdded == null || """".equals(dateAdded)) { return; } setDateAdded(Long.parseLong(dateAdded) * 1000); } public Date getDatePosted() { return datePosted; } public void setDatePosted(Date datePosted) { this.datePosted = datePosted; } public void setDatePosted(long datePosted) { setDatePosted(new Date(datePosted)); } public void setDatePosted(String datePosted) { if (datePosted == null || """".equals(datePosted)) { return; } setDatePosted(Long.parseLong(datePosted) * 1000); } public Date getDateTaken() { return dateTaken; } public void setDateTaken(Date dateTaken) { this.dateTaken = dateTaken; } public void setDateTaken(String dateTaken) { if (dateTaken == null || """".equals(dateTaken)) { return; } try { setDateTaken(((DateFormat) DATE_FORMATS.get()).parse(dateTaken)); } catch (ParseException e) { e.printStackTrace(); } } public Date getLastUpdate() { return lastUpdate; } public void setLastUpdate(Date lastUpdate) { this.lastUpdate = lastUpdate; } public void setLastUpdate(String lastUpdateStr) { if (lastUpdateStr == null || """".equals(lastUpdateStr)) { return; } long unixTime = Long.parseLong(lastUpdateStr); setLastUpdate(new Date(unixTime * 1000L)); } public String getTakenGranularity() { return takenGranularity; } public void setTakenGranularity(String takenGranularity) { this.takenGranularity = takenGranularity; } public Permissions getPermissions() { return permissions; } public void setPermissions(Permissions permissions) { this.permissions = permissions; } public Editability getEditability() { return editability; } public void setEditability(Editability editability) { this.editability = editability; } public int getComments() { return comments; } public void setComments(int comments) { this.comments = comments; } public void setComments(String comments) { if (comments != null) { setComments(Integer.parseInt(comments)); } } public Collection<Note> getNotes() { return notes; } public void setNotes(Collection<Note> notes) { this.notes = notes; } public Collection<Tag> getTags() { return tags; } public void setTags(Collection<Tag> tags) { this.tags = tags; } public Collection<String> getUrls() { return urls; } public void setUrls(Collection<String> urls) { this.urls = urls; } @Deprecated
    public void setViews(String views) { if (views != null) { try { setViews(Integer.parseInt(views)); } catch (NumberFormatException e) { setViews(-1); } } } @Deprecated
    public void setViews(int views) { this.views = views; } @Deprecated
    public int getViews() { return views; } public void setRotation(String rotation) { if (rotation != null) { try { setRotation(Integer.parseInt(rotation)); } catch (NumberFormatException e) { setRotation(-1); } } } public void setRotation(int rotation) { this.rotation = rotation; } public int getRotation() { return rotation; } public String getIconServer() { return iconServer; } public void setIconServer(String iconServer) { this.iconServer = iconServer; } public String getIconFarm() { return iconFarm; } public void setIconFarm(String iconFarm) { this.iconFarm = iconFarm; } public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } public GeoData getGeoData() { return geoData; } public void setGeoData(GeoData geoData) { this.geoData = geoData; } public boolean hasGeoData() { return geoData != null; } public String getOriginalFormat() { return originalFormat; } public void setOriginalFormat(String originalFormat) { this.originalFormat = originalFormat; } public String getOriginalSecret() { return originalSecret; } public void setOriginalSecret(String originalSecret) { this.originalSecret = originalSecret; } @Deprecated
    public BufferedImage getOriginalImage() throws IOException, FlickrException { if (originalFormat != null) { return getOriginalImage(""_o."" + originalFormat); } return getOriginalImage(DEFAULT_ORIGINAL_IMAGE_SUFFIX); } @Deprecated
    public InputStream getOriginalAsStream() throws IOException, FlickrException { if (originalFormat != null) { return getOriginalImageAsStream(""_o."" + originalFormat); } return getOriginalImageAsStream(DEFAULT_ORIGINAL_IMAGE_SUFFIX); } public String getOriginalUrl() throws FlickrException { if (originalSize == null) { if (originalFormat != null) { return getOriginalBaseImageUrl() + ""_o."" + originalFormat; } return getOriginalBaseImageUrl() + DEFAULT_ORIGINAL_IMAGE_SUFFIX; } else { return originalSize.getSource(); } } @Deprecated
    public BufferedImage getSmallSquareImage() throws IOException { return getImage(SMALL_SQUARE_IMAGE_SUFFIX); } @Deprecated
    public InputStream getSmallSquareAsInputStream() throws IOException { return getImageAsStream(SMALL_SQUARE_IMAGE_SUFFIX); } public String getSmallSquareUrl() { if (squareSize == null) { return getBaseImageUrl() + SMALL_SQUARE_IMAGE_SUFFIX; } else { return squareSize.getSource(); } } @Deprecated
    public BufferedImage getThumbnailImage() throws IOException { return getImage(THUMBNAIL_IMAGE_SUFFIX); } @Deprecated
    public InputStream getThumbnailAsInputStream() throws IOException { return getImageAsStream(THUMBNAIL_IMAGE_SUFFIX); } public String getThumbnailUrl() { if (thumbnailSize == null) { return getBaseImageUrl() + THUMBNAIL_IMAGE_SUFFIX; } else { return thumbnailSize.getSource(); } } @Deprecated
    public BufferedImage getSmallImage() throws IOException { return getImage(SMALL_IMAGE_SUFFIX); } @Deprecated
    public InputStream getSmallAsInputStream() throws IOException { return getImageAsStream(SMALL_IMAGE_SUFFIX); } public String getSmallUrl() { if (smallSize == null) { return getBaseImageUrl() + SMALL_IMAGE_SUFFIX; } else { return smallSize.getSource(); } } @Deprecated
    public BufferedImage getMediumImage() throws IOException { return getImage(MEDIUM_IMAGE_SUFFIX); } @Deprecated
    public InputStream getMediumAsStream() throws IOException { return getImageAsStream(MEDIUM_IMAGE_SUFFIX); } public String getMediumUrl() { if (mediumSize == null) { return getBaseImageUrl() + MEDIUM_IMAGE_SUFFIX; } else { return mediumSize.getSource(); } } @Deprecated
    public BufferedImage getLargeImage() throws IOException { return getImage(LARGE_IMAGE_SUFFIX); } @Deprecated
    public InputStream getLargeAsStream() throws IOException { return getImageAsStream(LARGE_IMAGE_SUFFIX); } public String getLargeUrl() { if (largeSize == null) { return getBaseImageUrl() + LARGE_IMAGE_SUFFIX; } else { return largeSize.getSource(); } } public String getLarge1600Url() { if (large1600Size == null) { return getBaseImageUrl() + LARGE_1600_IMAGE_SUFFIX; } else { return large1600Size.getSource(); } } public String getLarge2048Url() { if (large2048Size == null) { return getBaseImageUrl() + LARGE_2048_IMAGE_SUFFIX; } else { return large2048Size.getSource(); } } public String getSquareLargeUrl() { if (squareLargeSize == null) { return getBaseImageUrl() + SQUARE_LARGE_IMAGE_SUFFIX; } else { return squareLargeSize.getSource(); } } public String getSmall320Url() { if (small320Size == null) { return getBaseImageUrl() + SQUARE_320_IMAGE_SUFFIX; } else { return small320Size.getSource(); } } public String getMedium640Url() { if (medium640Size == null) { return getBaseImageUrl() + MEDIUM_640_IMAGE_SUFFIX; } else { return medium640Size.getSource(); } } public String getMedium800Url() { if (medium800Size == null) { return getBaseImageUrl() + MEDIUM_800_IMAGE_SUFFIX; } else { return medium800Size.getSource(); } } public String getVideoPlayerUrl() { if (videoPlayer == null) { return """"; } else { return videoPlayer.getSource(); } } public String getSiteMP4Url() { if (siteMP4 == null) { return """"; } else { return siteMP4.getSource(); } } public String getVideoOriginalUrl() { if (videoOriginal == null) { } else { return videoOriginal.getSource(); } } public String getMobileMp4Url() { if (mobileMP4 == null) { return """"; } else { return mobileMP4.getSource(); } } public String getHdMp4Url() { if (hdMP4 == null) { return """"; } else { return hdMP4.getSource(); } } @Deprecated
    private BufferedImage getImage(String suffix) throws IOException { StringBuffer buffer = getBaseImageUrl(); buffer.append(suffix); return _getImage(buffer.toString()); } @Deprecated
    private BufferedImage getOriginalImage(String suffix) throws IOException, FlickrException { StringBuffer buffer = getOriginalBaseImageUrl(); buffer.append(suffix); return _getImage(buffer.toString()); } @Deprecated
    private BufferedImage _getImage(String urlStr) throws IOException { URL url = new URL(urlStr); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.connect(); InputStream in = null; try { in = conn.getInputStream(); return ImageIO.read(in); } finally { IOUtilities.close(in); } } @Deprecated
    private InputStream getImageAsStream(String suffix) throws IOException { StringBuffer buffer = getBaseImageUrl(); buffer.append(suffix); return _getImageAsStream(buffer.toString()); } @Deprecated
    private InputStream getOriginalImageAsStream(String suffix) throws IOException, FlickrException { StringBuffer buffer = getOriginalBaseImageUrl(); buffer.append(suffix); return _getImageAsStream(buffer.toString()); } private InputStream _getImageAsStream(String urlStr) throws IOException { URL url = new URL(urlStr); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.connect(); return conn.getInputStream(); } private StringBuffer getBaseImageUrl() { StringBuffer buffer = new StringBuffer(); buffer.append(_getBaseImageUrl()); buffer.append(getSecret()); return buffer; } private StringBuffer getOriginalBaseImageUrl() throws FlickrException, NullPointerException { StringBuffer buffer = new StringBuffer(); buffer.append(_getBaseImageUrl()); if (getOriginalSecret().length() > 8) { buffer.append(getOriginalSecret()); } else { throw new FlickrException(""0"", ""OriginalUrl not available because of missing originalsecret.""); } return buffer; } private StringBuffer _getBaseImageUrl() { StringBuffer buffer = new StringBuffer(); buffer.append(getFarm()); buffer.append("".staticflickr.com/""); buffer.append(getServer()); buffer.append(""/""); buffer.append(getId()); buffer.append(""_""); return buffer; } public String getPlaceId() { return placeId; } public void setPlaceId(String placeId) { this.placeId = placeId; } public String getMedia() { return media; } public void setMedia(String media) { this.media = media; } public String getMediaStatus() { return mediaStatus; } public void setMediaStatus(String mediaStatus) { this.mediaStatus = mediaStatus; } public int getOriginalWidth() { return originalWidth; } public void setOriginalWidth(String originalWidth) { try { setOriginalWidth(Integer.parseInt(originalWidth)); } catch (NumberFormatException ex) { } } public void setOriginalWidth(int originalWidth) { this.originalWidth = originalWidth; } public int getOriginalHeight() { return originalHeight; } public void setOriginalHeight(String originalHeight) { try { setOriginalHeight(Integer.parseInt(originalHeight)); } catch (NumberFormatException ex) { } } public void setOriginalHeight(int originalHeight) { this.originalHeight = originalHeight; } public void setSizes(Collection<Size> sizes) { for (Size size : sizes) { if (size.getLabel() == Size.SMALL) { smallSize = size; } else if (size.getLabel() == Size.SQUARE) { squareSize = size; } else if (size.getLabel() == Size.THUMB) { thumbnailSize = size; } else if (size.getLabel() == Size.MEDIUM) { mediumSize = size; } else if (size.getLabel() == Size.LARGE) { largeSize = size; } else if (size.getLabel() == Size.LARGE_1600) { large1600Size = size; } else if (size.getLabel() == Size.LARGE_2048) { large2048Size = size; } else if (size.getLabel() == Size.ORIGINAL) { originalSize = size; } else if (size.getLabel() == Size.SQUARE_LARGE) { squareLargeSize = size; } else if (size.getLabel() == Size.SMALL_320) { small320Size = size; } else if (size.getLabel() == Size.MEDIUM_640) { medium640Size = size; } else if (size.getLabel() == Size.MEDIUM_800) { medium800Size = size; } else if (size.getLabel() == Size.VIDEO_PLAYER) { videoPlayer = size; } else if (size.getLabel() == Size.SITE_MP4) { siteMP4 = size; } else if (size.getLabel() == Size.VIDEO_ORIGINAL) { videoOriginal = size; } else if (size.getLabel() == Size.MOBILE_MP4) { mobileMP4 = size; } else if (size.getLabel() == Size.HD_MP4) { hdMP4 = size; } } } public Collection<Size> getSizes() { return Arrays.asList(
                smallSize, squareSize, thumbnailSize, mediumSize,
                largeSize, large1600Size, large2048Size, originalSize,
                squareLargeSize, small320Size, medium640Size, medium800Size,
                videoPlayer, siteMP4, videoOriginal, mobileMP4, hdMP4
        ); } public Size getSquareSize() { return squareSize; } public Size getSmallSize() { return smallSize; } public Size getThumbnailSize() { return thumbnailSize; } public Size getMediumSize() { return mediumSize; } public Size getLargeSize() { return largeSize; } public Size getLarge1600Size() { return large1600Size; } public Size getLarge2048Size() { return large2048Size; } public Size getOriginalSize() { return originalSize; } public Size getSquareLargeSize() { return squareLargeSize; } public Size getSmall320Size() { return small320Size; } public Size getMedium640Size() { return medium640Size; } public Size getMedium800Size() { return medium800Size; } public Size getVideoPlayerSize() { return videoPlayer; } public Size getSiteMP4Size() { return siteMP4; } public Size getVideoOriginalSize() { return videoOriginal; } public Size getMobileMp4() { return mobileMP4; } public void setMobileMp4(Size mobileMP4) { this.mobileMP4 = mobileMP4; } public Size getHdMp4() { return hdMP4; } public void setHdMp4(Size hdMP4) { this.hdMP4 = hdMP4; } public String getPathAlias() { return pathAlias; } public void setPathAlias(String pathAlias) { this.pathAlias = pathAlias; } public Stats getStats() { return stats; } public void setStats(Stats stats) { this.stats = stats; } @Override
    public boolean equals(Object obj) { if ((obj == null) || (obj.getClass() != this.getClass())) { return false; } if (obj == this) { return true; } Photo test = (Photo) obj; return areEqual(id, test.id) && areEqual(secret, test.secret); } @Override
    public int hashCode() { int hash = 83; if (id != null) { hash ^= id.hashCode(); } if (secret != null) { hash ^= secret.hashCode(); } return hash; } private boolean areEqual(Object x, Object y) { return x == null ? y == null : x.equals(y); } public PhotoUrl getPhotoUrl() { return photoUrl; } public void setPhotoUrl(PhotoUrl photoUrl) { this.photoUrl = photoUrl; } public Usage getUsage() { return usage; } public void setUsage(Usage usage) { this.usage = usage; } public Editability getPublicEditability() { return publicEditability; } public void setPublicEditability(Editability publicEditability) { this.publicEditability = publicEditability; } public boolean isHasPeople() { return hasPeople; } public void setIsHasPeople(boolean hasPeople) { this.hasPeople = hasPeople; } public Place getLocality() { return locality; } public void setLocality(Place locality) { this.locality = locality; } public Place getCounty() { return county; } public void setCounty(Place county) { this.county = county; } public Place getRegion() { return region; } public void setRegion(Place region) { this.region = region; } public Place getCountry() { return country; } public void setCountry(Place country) { this.country = country; } } "," package com.flickr4java.flickr.photos;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.places.Place; import com.flickr4java.flickr.stats.Stats; import com.flickr4java.flickr.stats.StatsInterface; import com.flickr4java.flickr.tags.Tag; import com.flickr4java.flickr.util.IOUtilities;  import javax.imageio.ImageIO;  import java.awt.image.BufferedImage; import java.io.IOException; import java.io.InputStream; import java.net.HttpURLConnection; import java.net.URL; import java.text.DateFormat; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Arrays; import java.util.Collection; import java.util.Date;  /**
 * Class representing metadata about a Flickr photo. Instances do not actually contain the photo data, however you can obtain the photo data by calling
 * {@link PhotosInterface#getImage(Photo, int)} or {@link PhotosInterface#getImageAsStream(Photo, int)}.
 * 
 * @author Anthony Eden
 * @version $Id: Photo.java,v 1.28 2009/07/23 21:49:35 x-mago Exp $
 */ public class Photo {  private static final ThreadLocal<SimpleDateFormat> DATE_FORMATS = new ThreadLocal<SimpleDateFormat>() { @Override
        protected synchronized SimpleDateFormat initialValue() { return new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); } } ;  private static final String DEFAULT_ORIGINAL_IMAGE_SUFFIX = ""_o.jpg"";  private static final String SMALL_SQUARE_IMAGE_SUFFIX = ""_s.jpg"";  private static final String SMALL_IMAGE_SUFFIX = ""_m.jpg"";  private static final String THUMBNAIL_IMAGE_SUFFIX = ""_t.jpg"";  private static final String MEDIUM_IMAGE_SUFFIX = "".jpg"";  private static final String LARGE_IMAGE_SUFFIX = ""_b.jpg"";  private static final String LARGE_1600_IMAGE_SUFFIX = ""_h.jpg"";  private static final String LARGE_2048_IMAGE_SUFFIX = ""_k.jpg"";  private static final String SQUARE_LARGE_IMAGE_SUFFIX = ""_q.jpg"";  private static final String SQUARE_320_IMAGE_SUFFIX = ""_n.jpg"";  private static final String MEDIUM_640_IMAGE_SUFFIX = ""_z.jpg"";  private static final String MEDIUM_800_IMAGE_SUFFIX = ""_c.jpg"";  private Size squareSize;  private Size smallSize;  private Size thumbnailSize;  private Size mediumSize;  private Size largeSize;  private Size large1600Size;  private Size large2048Size;  private Size originalSize;  private Size squareLargeSize;  private Size small320Size;  private Size medium640Size;  private Size medium800Size;  private Size videoPlayer;  private Size siteMP4;  private Size videoOriginal;  private Size mobileMP4;      private Size hdMP4;      private String id;  private User owner;  private String secret;  private String farm;  private String server;  private boolean favorite;  private String license;  private boolean primary;  private String title;  private String description;  private boolean publicFlag;  private boolean friendFlag;  private boolean familyFlag;  private Date dateAdded;  private Date datePosted;  private Date dateTaken;  private Date lastUpdate;  private String takenGranularity;  private Permissions permissions;  private Editability editability;      private Editability publicEditability;  private int comments;  private int views = -1;  private int rotation;  private Collection<Note> notes;  private Collection<Tag> tags;  private Collection<String> urls;  private String iconServer;  private String iconFarm;  private String url;  private GeoData geoData;  private String originalFormat;  private String originalSecret;  private String placeId;  private String media;  private String mediaStatus;  private String pathAlias;  private int originalWidth;  private int originalHeight;      private PhotoUrl photoUrl;      private Usage usage;      private boolean hasPeople;  private Place locality;  private Place county;  private Place region;  private Place country;  /**
     * Stats on views, comments and favorites. Only set on {@link StatsInterface#getPopularPhotos} call.
     */ private Stats stats; 
	
 public Photo() { }  public String getId() { return id; }  public void setId(String id) { this.id = id; }  public User getOwner() { return owner; }  public void setOwner(User owner) { this.owner = owner; }  public String getSecret() { return secret; }  public void setSecret(String secret) { this.secret = secret; }  public String getFarm() { return farm; }  public void setFarm(String farm) { this.farm = farm; }  public String getServer() { return server; }  public void setServer(String server) { this.server = server; }  public boolean isFavorite() { return favorite; }  public void setFavorite(boolean favorite) { this.favorite = favorite; }  public String getLicense() { return license; }  public void setLicense(String license) { this.license = license; }  public boolean isPrimary() { return primary; }  public void setPrimary(boolean primary) { this.primary = primary; }  public void setPrimary(String primary) { setPrimary(""1"".equals(primary)); }  public String getTitle() { return title; }  public void setTitle(String title) { this.title = title; }  public String getDescription() { return description; }  public void setDescription(String description) { this.description = description; }  public boolean isPublicFlag() { return publicFlag; }  public void setPublicFlag(boolean publicFlag) { this.publicFlag = publicFlag; }  public boolean isFriendFlag() { return friendFlag; }  public void setFriendFlag(boolean friendFlag) { this.friendFlag = friendFlag; }  public boolean isFamilyFlag() { return familyFlag; }  public void setFamilyFlag(boolean familyFlag) { this.familyFlag = familyFlag; }  public Date getDateAdded() { return dateAdded; }  public void setDateAdded(Date dateAdded) { this.dateAdded = dateAdded; }  public void setDateAdded(long dateAdded) { setDateAdded(new Date(dateAdded)); }  public void setDateAdded(String dateAdded) { if (dateAdded == null || """".equals(dateAdded)) { return; } setDateAdded(Long.parseLong(dateAdded) * 1000); }  public Date getDatePosted() { return datePosted; }  public void setDatePosted(Date datePosted) { this.datePosted = datePosted; }  public void setDatePosted(long datePosted) { setDatePosted(new Date(datePosted)); }  public void setDatePosted(String datePosted) { if (datePosted == null || """".equals(datePosted)) { return; } setDatePosted(Long.parseLong(datePosted) * 1000); }  public Date getDateTaken() { return dateTaken; }  public void setDateTaken(Date dateTaken) { this.dateTaken = dateTaken; }  public void setDateTaken(String dateTaken) { if (dateTaken == null || """".equals(dateTaken)) { return; } try { setDateTaken(((DateFormat) DATE_FORMATS.get()).parse(dateTaken)); } catch (ParseException e) { // TODO: figure out what to do with this error e.printStackTrace(); } }  public Date getLastUpdate() { return lastUpdate; }  public void setLastUpdate(Date lastUpdate) { this.lastUpdate = lastUpdate; }  public void setLastUpdate(String lastUpdateStr) { if (lastUpdateStr == null || """".equals(lastUpdateStr)) { return; } long unixTime = Long.parseLong(lastUpdateStr); setLastUpdate(new Date(unixTime * 1000L)); }  public String getTakenGranularity() { return takenGranularity; }  public void setTakenGranularity(String takenGranularity) { this.takenGranularity = takenGranularity; }  public Permissions getPermissions() { return permissions; }  public void setPermissions(Permissions permissions) { this.permissions = permissions; }  public Editability getEditability() { return editability; }  public void setEditability(Editability editability) { this.editability = editability; }  public int getComments() { return comments; }  public void setComments(int comments) { this.comments = comments; }  public void setComments(String comments) { if (comments != null) { setComments(Integer.parseInt(comments)); } }  public Collection<Note> getNotes() { return notes; }  public void setNotes(Collection<Note> notes) { this.notes = notes; }  public Collection<Tag> getTags() { return tags; }  public void setTags(Collection<Tag> tags) { this.tags = tags; }  /**
     * 
     * @return List of {@link PhotoUrl}
     */ public Collection<String> getUrls() { return urls; }  /**
     * 
     * @param urls
     *            List of {@link PhotoUrl}
     */ public void setUrls(Collection<String> urls) { this.urls = urls; }  /**
     * Sets the number of views for this Photo. For un-authenticated calls this value is not available and will be set to -1.
     * 
     * @param views
     * @deprecated attribute no longer available
     */ @Deprecated
    public void setViews(String views) { if (views != null) { try { setViews(Integer.parseInt(views)); } catch (NumberFormatException e) { setViews(-1); } } }  /**
     * 
     * @param views
     * @deprecated attribute no longer available
     */ @Deprecated
    public void setViews(int views) { this.views = views; }  /**
     * Number of views. Set to -1 if the value is not available.
     * 
     * @return Number of views
     * @deprecated attribute no longer available
     */ @Deprecated
    public int getViews() { return views; }  /**
     * Set the degrees of rotation. Value will be set to -1, if not available.
     * 
     * @param rotation
     */ public void setRotation(String rotation) { if (rotation != null) { try { setRotation(Integer.parseInt(rotation)); } catch (NumberFormatException e) { setRotation(-1); } } }  public void setRotation(int rotation) { this.rotation = rotation; }  public int getRotation() { return rotation; }  public String getIconServer() { return iconServer; }  public void setIconServer(String iconServer) { this.iconServer = iconServer; }  public String getIconFarm() { return iconFarm; }  public void setIconFarm(String iconFarm) { this.iconFarm = iconFarm; }  public String getUrl() { return url; }  public void setUrl(String url) { this.url = url; }  public GeoData getGeoData() { return geoData; }  public void setGeoData(GeoData geoData) { this.geoData = geoData; }  public boolean hasGeoData() { return geoData != null; }  public String getOriginalFormat() { return originalFormat; }  public void setOriginalFormat(String originalFormat) { this.originalFormat = originalFormat; }  public String getOriginalSecret() { return originalSecret; }  public void setOriginalSecret(String originalSecret) { this.originalSecret = originalSecret; }  /**
     * @deprecated
     * @see PhotosInterface#getImage(Photo, int)
     * @return An Image
     * @throws IOException
     * @throws FlickrException if there was a problem connecting to Flickr
     */ @Deprecated
    public BufferedImage getOriginalImage() throws IOException, FlickrException { if (originalFormat != null) { return getOriginalImage(""_o."" + originalFormat); } return getOriginalImage(DEFAULT_ORIGINAL_IMAGE_SUFFIX); }  /**
     * Get an InputStream for the original image. Callers must close the stream upon completion.
     * 
     * @deprecated
     * @see PhotosInterface#getImageAsStream(Photo, int)
     * @return The InputStream
     * @throws IOException
     */ @Deprecated
    public InputStream getOriginalAsStream() throws IOException, FlickrException { if (originalFormat != null) { return getOriginalImageAsStream(""_o."" + originalFormat); } return getOriginalImageAsStream(DEFAULT_ORIGINAL_IMAGE_SUFFIX); }  /**
     * Get the original image URL.
     * 
     * @return The original image URL
     */ public String getOriginalUrl() throws FlickrException { if (originalSize == null) { if (originalFormat != null) { return getOriginalBaseImageUrl() + ""_o."" + originalFormat; } return getOriginalBaseImageUrl() + DEFAULT_ORIGINAL_IMAGE_SUFFIX; } else { return originalSize.getSource(); } }  /**
     * Get an Image object which is a 75x75 pixel square.
     * 
     * @deprecated
     * @see PhotosInterface#getImage(Photo, int)
     * @return An Image
     * @throws IOException
     */ @Deprecated
    public BufferedImage getSmallSquareImage() throws IOException { return getImage(SMALL_SQUARE_IMAGE_SUFFIX); }  /**
     * @deprecated
     * @see PhotosInterface#getImageAsStream(Photo, int)
     * @return The InputStream
     * @throws IOException
     */ @Deprecated
    public InputStream getSmallSquareAsInputStream() throws IOException { return getImageAsStream(SMALL_SQUARE_IMAGE_SUFFIX); }  public String getSmallSquareUrl() { if (squareSize == null) { return getBaseImageUrl() + SMALL_SQUARE_IMAGE_SUFFIX; } else { return squareSize.getSource(); } }  /**
     * @deprecated
     * @see PhotosInterface#getImage(Photo, int)
     * @return An Image
     * @throws IOException
     */ @Deprecated
    public BufferedImage getThumbnailImage() throws IOException { return getImage(THUMBNAIL_IMAGE_SUFFIX); }  /**
     * @deprecated
     * @see PhotosInterface#getImageAsStream(Photo, int)
     * @return The InputStream
     * @throws IOException
     */ @Deprecated
    public InputStream getThumbnailAsInputStream() throws IOException { return getImageAsStream(THUMBNAIL_IMAGE_SUFFIX); }  public String getThumbnailUrl() { if (thumbnailSize == null) { return getBaseImageUrl() + THUMBNAIL_IMAGE_SUFFIX; } else { return thumbnailSize.getSource(); } }  /**
     * @deprecated
     * @see PhotosInterface#getImage(Photo, int)
     * @return An Image
     * @throws IOException
     */ @Deprecated
    public BufferedImage getSmallImage() throws IOException { return getImage(SMALL_IMAGE_SUFFIX); }  /**
     * @deprecated
     * @see PhotosInterface#getImageAsStream(Photo, int)
     * @return The InputStream
     * @throws IOException
     */ @Deprecated
    public InputStream getSmallAsInputStream() throws IOException { return getImageAsStream(SMALL_IMAGE_SUFFIX); }  public String getSmallUrl() { if (smallSize == null) { return getBaseImageUrl() + SMALL_IMAGE_SUFFIX; } else { return smallSize.getSource(); } }  /**
     * @deprecated
     * @see PhotosInterface#getImage(Photo, int)
     * @return An Image
     * @throws IOException
     */ @Deprecated
    public BufferedImage getMediumImage() throws IOException { return getImage(MEDIUM_IMAGE_SUFFIX); }  /**
     * @deprecated
     * @see PhotosInterface#getImageAsStream(Photo, int)
     * @return The InputStream
     * @throws IOException
     */ @Deprecated
    public InputStream getMediumAsStream() throws IOException { return getImageAsStream(MEDIUM_IMAGE_SUFFIX); }  public String getMediumUrl() { if (mediumSize == null) { return getBaseImageUrl() + MEDIUM_IMAGE_SUFFIX; } else { return mediumSize.getSource(); } }  /**
     * @deprecated
     * @see PhotosInterface#getImage(Photo, int)
     * @return An Image
     * @throws IOException
     */ @Deprecated
    public BufferedImage getLargeImage() throws IOException { return getImage(LARGE_IMAGE_SUFFIX); }  /**
     * @deprecated
     * @see PhotosInterface#getImageAsStream(Photo, int)
     * @return The InputStream
     * @throws IOException
     */ @Deprecated
    public InputStream getLargeAsStream() throws IOException { return getImageAsStream(LARGE_IMAGE_SUFFIX); }  public String getLargeUrl() { if (largeSize == null) { return getBaseImageUrl() + LARGE_IMAGE_SUFFIX; } else { return largeSize.getSource(); } }  public String getLarge1600Url() { if (large1600Size == null) { return getBaseImageUrl() + LARGE_1600_IMAGE_SUFFIX; } else { return large1600Size.getSource(); } }  public String getLarge2048Url() { if (large2048Size == null) { return getBaseImageUrl() + LARGE_2048_IMAGE_SUFFIX; } else { return large2048Size.getSource(); } }  public String getSquareLargeUrl() { if (squareLargeSize == null) { return getBaseImageUrl() + SQUARE_LARGE_IMAGE_SUFFIX; } else { return squareLargeSize.getSource(); } }  public String getSmall320Url() { if (small320Size == null) { return getBaseImageUrl() + SQUARE_320_IMAGE_SUFFIX; } else { return small320Size.getSource(); } }  public String getMedium640Url() { if (medium640Size == null) { return getBaseImageUrl() + MEDIUM_640_IMAGE_SUFFIX; } else { return medium640Size.getSource(); } }  public String getMedium800Url() { if (medium800Size == null) { return getBaseImageUrl() + MEDIUM_800_IMAGE_SUFFIX; } else { return medium800Size.getSource(); } }  public String getVideoPlayerUrl() { if (videoPlayer == null) { return """"; } else { return videoPlayer.getSource(); } }  public String getSiteMP4Url() { if (siteMP4 == null) { return """"; } else { return siteMP4.getSource(); } }  public String getVideoOriginalUrl() { if (videoOriginal == null) { // Workaround for API limitations //www.flickr.com/video_download.gne?id=%s&originalSecret=%s&secret=%s"", id, originalSecret, secret); } else { return videoOriginal.getSource(); } }  public String getMobileMp4Url() { if (mobileMP4 == null) { return """"; } else { return mobileMP4.getSource(); } }  public String getHdMp4Url() { if (hdMP4 == null) { return """"; } else { return hdMP4.getSource(); } }  /**
     * Get an image using the specified URL suffix.
     * 
     * @deprecated
     * @param suffix
     *            The URL suffix, including the .extension
     * @return The BufferedImage object
     * @throws IOException
     */ @Deprecated
    private BufferedImage getImage(String suffix) throws IOException { StringBuffer buffer = getBaseImageUrl(); buffer.append(suffix); return _getImage(buffer.toString()); }  /**
     * Get the original-image using the specified URL suffix.
     * 
     * @deprecated
     * @see PhotosInterface#getImage(Photo, int)
     * @param suffix
     *            The URL suffix, including the .extension
     * @return The BufferedImage object
     * @throws IOException
     * @throws FlickrException if there was a problem connecting to Flickr
     */ @Deprecated
    private BufferedImage getOriginalImage(String suffix) throws IOException, FlickrException { StringBuffer buffer = getOriginalBaseImageUrl(); buffer.append(suffix); return _getImage(buffer.toString()); }  /**
     * @deprecated
     * @param urlStr
     * @return BufferedImage
     * @throws IOException
     */ @Deprecated
    private BufferedImage _getImage(String urlStr) throws IOException { URL url = new URL(urlStr); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.connect(); InputStream in = null; try { in = conn.getInputStream(); return ImageIO.read(in); } finally { IOUtilities.close(in); } }  /**
     * Get an image as a stream. Callers must be sure to close the stream when they are done with it.
     * 
     * @deprecated
     * @see PhotosInterface#getImageAsStream(Photo, int)
     * @param suffix
     *            The suffix
     * @return The InputStream
     * @throws IOException
     */ @Deprecated
    private InputStream getImageAsStream(String suffix) throws IOException { StringBuffer buffer = getBaseImageUrl(); buffer.append(suffix); return _getImageAsStream(buffer.toString()); }  /**
     * 
     * @deprecated
     * @see PhotosInterface#getImageAsStream(Photo, int)
     * @param suffix
     * @return InoutStream
     * @throws IOException
     * @throws FlickrException if there was a problem connecting to Flickr
     */ @Deprecated
    private InputStream getOriginalImageAsStream(String suffix) throws IOException, FlickrException { StringBuffer buffer = getOriginalBaseImageUrl(); buffer.append(suffix); return _getImageAsStream(buffer.toString()); }  private InputStream _getImageAsStream(String urlStr) throws IOException { URL url = new URL(urlStr); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.connect(); return conn.getInputStream(); }  private StringBuffer getBaseImageUrl() { StringBuffer buffer = new StringBuffer(); buffer.append(_getBaseImageUrl()); buffer.append(getSecret()); return buffer; }  private StringBuffer getOriginalBaseImageUrl() throws FlickrException, NullPointerException { StringBuffer buffer = new StringBuffer(); buffer.append(_getBaseImageUrl()); if (getOriginalSecret().length() > 8) { buffer.append(getOriginalSecret()); } else { throw new FlickrException(""0"", ""OriginalUrl not available because of missing originalsecret.""); } return buffer; }  private StringBuffer _getBaseImageUrl() { StringBuffer buffer = new StringBuffer(); //farm""); buffer.append(getFarm()); buffer.append("".staticflickr.com/""); buffer.append(getServer()); buffer.append(""/""); buffer.append(getId()); buffer.append(""_""); return buffer; }  /**
     * @return A placeId
     * @see com.flickr4java.flickr.places.PlacesInterface#resolvePlaceId(String)
     */ public String getPlaceId() { return placeId; }  public void setPlaceId(String placeId) { this.placeId = placeId; }  public String getMedia() { return media; }  public void setMedia(String media) { this.media = media; }  public String getMediaStatus() { return mediaStatus; }  public void setMediaStatus(String mediaStatus) { this.mediaStatus = mediaStatus; }  public int getOriginalWidth() { return originalWidth; }  public void setOriginalWidth(String originalWidth) { try { setOriginalWidth(Integer.parseInt(originalWidth)); } catch (NumberFormatException ex) { } }  public void setOriginalWidth(int originalWidth) { this.originalWidth = originalWidth; }  public int getOriginalHeight() { return originalHeight; }  public void setOriginalHeight(String originalHeight) { try { setOriginalHeight(Integer.parseInt(originalHeight)); } catch (NumberFormatException ex) { } }  public void setOriginalHeight(int originalHeight) { this.originalHeight = originalHeight; }  /**
     * Set sizes to override the generated URLs of the different sizes.
     * 
     * @param sizes
     * @see com.flickr4java.flickr.photos.PhotosInterface#getSizes(String)
     */ public void setSizes(Collection<Size> sizes) { for (Size size : sizes) { if (size.getLabel() == Size.SMALL) { smallSize = size; } else if (size.getLabel() == Size.SQUARE) { squareSize = size; } else if (size.getLabel() == Size.THUMB) { thumbnailSize = size; } else if (size.getLabel() == Size.MEDIUM) { mediumSize = size; } else if (size.getLabel() == Size.LARGE) { largeSize = size; } else if (size.getLabel() == Size.LARGE_1600) { large1600Size = size; } else if (size.getLabel() == Size.LARGE_2048) { large2048Size = size; } else if (size.getLabel() == Size.ORIGINAL) { originalSize = size; } else if (size.getLabel() == Size.SQUARE_LARGE) { squareLargeSize = size; } else if (size.getLabel() == Size.SMALL_320) { small320Size = size; } else if (size.getLabel() == Size.MEDIUM_640) { medium640Size = size; } else if (size.getLabel() == Size.MEDIUM_800) { medium800Size = size; } else if (size.getLabel() == Size.VIDEO_PLAYER) { videoPlayer = size; } else if (size.getLabel() == Size.SITE_MP4) { siteMP4 = size; } else if (size.getLabel() == Size.VIDEO_ORIGINAL) { videoOriginal = size; } else if (size.getLabel() == Size.MOBILE_MP4) { mobileMP4 = size; } else if (size.getLabel() == Size.HD_MP4) { hdMP4 = size; } } }  public Collection<Size> getSizes() { return Arrays.asList(
                smallSize, squareSize, thumbnailSize, mediumSize,
                largeSize, large1600Size, large2048Size, originalSize,
                squareLargeSize, small320Size, medium640Size, medium800Size,
                videoPlayer, siteMP4, videoOriginal, mobileMP4, hdMP4
        ); }  public Size getSquareSize() { return squareSize; }  public Size getSmallSize() { return smallSize; }  public Size getThumbnailSize() { return thumbnailSize; }  public Size getMediumSize() { return mediumSize; }  public Size getLargeSize() { return largeSize; }  public Size getLarge1600Size() { return large1600Size; }  public Size getLarge2048Size() { return large2048Size; }  public Size getOriginalSize() { return originalSize; }  public Size getSquareLargeSize() { return squareLargeSize; }  public Size getSmall320Size() { return small320Size; }  public Size getMedium640Size() { return medium640Size; }  public Size getMedium800Size() { return medium800Size; }  public Size getVideoPlayerSize() { return videoPlayer; }  public Size getSiteMP4Size() { return siteMP4; }  public Size getVideoOriginalSize() { return videoOriginal; }  /**
   	 * @return the mobileMP4
   	 */ public Size getMobileMp4() { return mobileMP4; }  /**
   	 * @param mobileMP4 the mobileMP4 to set
   	 */ public void setMobileMp4(Size mobileMP4) { this.mobileMP4 = mobileMP4; }  /**
   	 * @return the hdMP4
   	 */ public Size getHdMp4() { return hdMP4; }  /**
   	 * @param hdMP4 the hdMP4 to set
   	 */ public void setHdMp4(Size hdMP4) { this.hdMP4 = hdMP4; }  /**
     * @return the pathAlias
     */ public String getPathAlias() { return pathAlias; }  /**
     * @param pathAlias
     *            the pathAlias to set
     */ public void setPathAlias(String pathAlias) { this.pathAlias = pathAlias; }  public Stats getStats() { return stats; }  public void setStats(Stats stats) { this.stats = stats; }  @Override
    public boolean equals(Object obj) { if ((obj == null) || (obj.getClass() != this.getClass())) { return false; } if (obj == this) { return true; } Photo test = (Photo) obj; // TODO: not sure if these tests are sufficient return areEqual(id, test.id) && areEqual(secret, test.secret); }  @Override
    public int hashCode() { int hash = 83; if (id != null) { hash ^= id.hashCode(); } if (secret != null) { hash ^= secret.hashCode(); } return hash; }  private boolean areEqual(Object x, Object y) { return x == null ? y == null : x.equals(y); }      public PhotoUrl getPhotoUrl() { return photoUrl; }  public void setPhotoUrl(PhotoUrl photoUrl) { this.photoUrl = photoUrl; 		 } 	 public Usage getUsage() { return usage; }  public void setUsage(Usage usage) { this.usage = usage; 		 }  public Editability getPublicEditability() { return publicEditability; }  public void setPublicEditability(Editability publicEditability) { this.publicEditability = publicEditability; }  public boolean isHasPeople() { return hasPeople; }  public void setIsHasPeople(boolean hasPeople) { this.hasPeople = hasPeople; }  public Place getLocality() { return locality; }  public void setLocality(Place locality) { this.locality = locality; }  public Place getCounty() { return county; }  public void setCounty(Place county) { this.county = county; }  public Place getRegion() { return region; }  public void setRegion(Place region) { this.region = region; }  public Place getCountry() { return country; }  public void setCountry(Place country) { this.country = country; } 	 }  "
src/main/java/com/flickr4java/flickr/photos/PhotoAllContext.java,"package com.flickr4java.flickr.photos;

public class PhotoAllContext {
	
	private PhotoSetList<PhotoSet> photoSetList = new PhotoSetList<PhotoSet>();
	private PoolList<Pool> poolList = new PoolList<Pool>();
	
	public PhotoSetList<PhotoSet> getPhotoSetList() {
		return photoSetList;
	}
	public void setPhotoSetList(PhotoSetList<PhotoSet> photoSetList) {
		this.photoSetList = photoSetList;
	}
	public PoolList<Pool> getPoolList() {
		return poolList;
	}
	public void setPoolList(PoolList<Pool> poolList) {
		this.poolList = poolList;
	}

}
",package com.flickr4java.flickr.photos; public class PhotoAllContext { private PhotoSetList<PhotoSet> photoSetList = new PhotoSetList<PhotoSet>(); private PoolList<Pool> poolList = new PoolList<Pool>(); public PhotoSetList<PhotoSet> getPhotoSetList() { return photoSetList; } public void setPhotoSetList(PhotoSetList<PhotoSet> photoSetList) { this.photoSetList = photoSetList; } public PoolList<Pool> getPoolList() { return poolList; } public void setPoolList(PoolList<Pool> poolList) { this.poolList = poolList; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.photos; public class PhotoAllContext { private PhotoSetList<PhotoSet> photoSetList = new PhotoSetList<PhotoSet>(); private PoolList<Pool> poolList = new PoolList<Pool>(); public PhotoSetList<PhotoSet> getPhotoSetList() { return photoSetList; } public void setPhotoSetList(PhotoSetList<PhotoSet> photoSetList) { this.photoSetList = photoSetList; } public PoolList<Pool> getPoolList() { return poolList; } public void setPoolList(PoolList<Pool> poolList) { this.poolList = poolList; } } ,package com.flickr4java.flickr.photos;  public class PhotoAllContext { 	 private PhotoSetList<PhotoSet> photoSetList = new PhotoSetList<PhotoSet>(); private PoolList<Pool> poolList = new PoolList<Pool>(); 	 public PhotoSetList<PhotoSet> getPhotoSetList() { return photoSetList; } public void setPhotoSetList(PhotoSetList<PhotoSet> photoSetList) { this.photoSetList = photoSetList; } public PoolList<Pool> getPoolList() { return poolList; } public void setPoolList(PoolList<Pool> poolList) { this.poolList = poolList; }  }  
src/main/java/com/flickr4java/flickr/photos/PhotoContext.java,"
package com.flickr4java.flickr.photos;

/**
 * @author Anthony Eden
 */
public class PhotoContext {

    private Photo previousPhoto;

    private Photo nextPhoto;

    public PhotoContext() {

    }

    public Photo getPreviousPhoto() {
        return previousPhoto;
    }

    public void setPreviousPhoto(Photo previousPhoto) {
        this.previousPhoto = previousPhoto;
    }

    public Photo getNextPhoto() {
        return nextPhoto;
    }

    public void setNextPhoto(Photo nextPhoto) {
        this.nextPhoto = nextPhoto;
    }

}
",package com.flickr4java.flickr.photos; public class PhotoContext { private Photo previousPhoto; private Photo nextPhoto; public PhotoContext() { } public Photo getPreviousPhoto() { return previousPhoto; } public void setPreviousPhoto(Photo previousPhoto) { this.previousPhoto = previousPhoto; } public Photo getNextPhoto() { return nextPhoto; } public void setNextPhoto(Photo nextPhoto) { this.nextPhoto = nextPhoto; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.photos; public class PhotoContext { private Photo previousPhoto; private Photo nextPhoto; public PhotoContext() { } public Photo getPreviousPhoto() { return previousPhoto; } public void setPreviousPhoto(Photo previousPhoto) { this.previousPhoto = previousPhoto; } public Photo getNextPhoto() { return nextPhoto; } public void setNextPhoto(Photo nextPhoto) { this.nextPhoto = nextPhoto; } } ," package com.flickr4java.flickr.photos;  /**
 * @author Anthony Eden
 */ public class PhotoContext {  private Photo previousPhoto;  private Photo nextPhoto;  public PhotoContext() {  }  public Photo getPreviousPhoto() { return previousPhoto; }  public void setPreviousPhoto(Photo previousPhoto) { this.previousPhoto = previousPhoto; }  public Photo getNextPhoto() { return nextPhoto; }  public void setNextPhoto(Photo nextPhoto) { this.nextPhoto = nextPhoto; }  }  "
src/main/java/com/flickr4java/flickr/photos/PhotoList.java,"

package com.flickr4java.flickr.photos;

import com.flickr4java.flickr.SearchResultList;

/**
 * A list of photos with additional meta data.
 * 
 * @author Anthony Eden
 */
public class PhotoList<E> extends SearchResultList<Photo> {

    // (avoid compiler warning)
    private static final long serialVersionUID = -4735611134085303463L;

}
",package com.flickr4java.flickr.photos; import com.flickr4java.flickr.SearchResultList; public class PhotoList<E> extends SearchResultList<Photo> { private static final long serialVersionUID = -4735611134085303463L; },0 0 0 0 0 0,package com.flickr4java.flickr.photos; import com.flickr4java.flickr.SearchResultList; public class PhotoList<E> extends SearchResultList<Photo> { private static final long serialVersionUID = -4735611134085303463L; } ,"
 package com.flickr4java.flickr.photos;  import com.flickr4java.flickr.SearchResultList;  /**
 * A list of photos with additional meta data.
 * 
 * @author Anthony Eden
 */ public class PhotoList<E> extends SearchResultList<Photo> {  // (avoid compiler warning) private static final long serialVersionUID = -4735611134085303463L;  }  "
src/main/java/com/flickr4java/flickr/photos/PhotoPlace.java,"package com.flickr4java.flickr.photos;

/**
 * Represents either a photo pool or a photo set with it's id and title. Instances of this class are distinguished as set or pool by their <em>kind</em>
 * property. There are two possible kinds represented as public int constants:
 * <ul>
 * <li>SET this is a photo set</li>
 * <li>POOL this is a groups photo pool</li>
 * </ul>
 * 
 * @author till (Till Krech) flickr:extranoise
 * @version $Id: PhotoPlace.java,v 1.3 2009/07/12 22:43:07 x-mago Exp $
 */
public class PhotoPlace {
    public static final int SET = 1;

    public static final int POOL = 2;

    private String id;

    private int kind;

    private String title;

    /**
     * creates a new one.
     * 
     * @param kind
     *            either SET or POOL
     * @param id
     *            id of the pool or set
     * @param title
     *            name of the pool or set
     * @throws IllegalArgumentException
     *             if kind is invalid
     */
    public PhotoPlace(int kind, String id, String title) {
        setKind(kind);
        this.id = id;
        this.title = title;
    }

    /**
     * creates a new one where the kind may be specified as String ""set"" or ""pool""
     * 
     * @param kind
     *            either ""set"" or ""pool""
     * @param id
     *            id of the pool or set
     * @param title
     *            name of the pool or set
     * @throws IllegalArgumentException
     *             if kind is invalid
     */
    public PhotoPlace(String kind, String id, String title) {
        setKind(kind);
        this.id = id;
        this.title = title;
    }

    /**
     * @return the pool or set id
     */
    public String getId() {
        return id;
    }

    /**
     * @return what I am
     */
    public int getKind() {
        return kind;
    }

    protected void setKind(int kind) {
        this.kind = kind;
    }

    protected void setKind(String kindStr) {
        if (""pool"".equalsIgnoreCase(kindStr)) {
            setKind(POOL);
        } else if (""set"".equalsIgnoreCase(kindStr)) {
            setKind(SET);
        } else {
            throw new IllegalArgumentException(""Invalid kind ["" + kindStr + ""]"");
        }
    }

    /**
     * @return the name of the pool or set
     */
    public String getTitle() {
        return title;
    }

    /**
     * @return what I am as String
     */
    public String getKindAsString() {
        String s;
        switch (kind) {
        case SET:
            s = ""set"";
            break;
        case POOL:
            s = ""pool"";
            break;
        default:
            s = ""unknown("" + kind + "")"";
            break;
        }
        return s;
    }

    /**
     * compares this to another object. Makes is possible to put PhotPlaces into a Java Set.
     */
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        if (!(obj instanceof PhotoPlace)) {
            return false;
        }
        PhotoPlace other = (PhotoPlace) obj;
        if (other.kind != kind) {
            return false;
        }
        if (this.id != null) {
            if (!this.id.equals(other.id)) {
                return false;
            }
        } else if (other.id != null) {
            return false;
        }
        if (this.title != null) {
            if (!this.title.equals(other.title)) {
                return false;
            }
        } else if (other.title != null) {
            return false;
        }
        return true;
    }

    /**
     * primitive hashCode. Makes is possible to put PhotPlaces into a Java Set.
     */
    public int hashCode() {
        return id != null ? id.hashCode() : 0;
    }

    /**
     * returns a human readable but ugly representation of this object
     */
    public String toString() {
        return getClass().getName() + ""["" + getKindAsString() + "" id=\"""" + id + ""\"" title=\"""" + title + ""\""]"";
    }

}
","package com.flickr4java.flickr.photos; public class PhotoPlace { public static final int SET = 1; public static final int POOL = 2; private String id; private int kind; private String title; public PhotoPlace(int kind, String id, String title) { setKind(kind); this.id = id; this.title = title; } public PhotoPlace(String kind, String id, String title) { setKind(kind); this.id = id; this.title = title; } public String getId() { return id; } public int getKind() { return kind; } protected void setKind(int kind) { this.kind = kind; } protected void setKind(String kindStr) { if (""pool"".equalsIgnoreCase(kindStr)) { setKind(POOL); } else if (""set"".equalsIgnoreCase(kindStr)) { setKind(SET); } else { throw new IllegalArgumentException(""Invalid kind ["" + kindStr + ""]""); } } public String getTitle() { return title; } public String getKindAsString() { String s; switch (kind) { case SET:
            s = ""set""; break; case POOL:
            s = ""pool""; break; default:
            s = ""unknown("" + kind + "")""; break; } return s; } public boolean equals(Object obj) { if (obj == null) { return false; } if (obj == this) { return true; } if (!(obj instanceof PhotoPlace)) { return false; } PhotoPlace other = (PhotoPlace) obj; if (other.kind != kind) { return false; } if (this.id != null) { if (!this.id.equals(other.id)) { return false; } } else if (other.id != null) { return false; } if (this.title != null) { if (!this.title.equals(other.title)) { return false; } } else if (other.title != null) { return false; } return true; } public int hashCode() { return id != null ? id.hashCode() : 0; } public String toString() { return getClass().getName() + ""["" + getKindAsString() + "" id=\"""" + id + ""\"" title=\"""" + title + ""\""]""; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.photos; public class PhotoPlace { public static final int SET = 1; public static final int POOL = 2; private String id; private int kind; private String title; public PhotoPlace(int kind, String id, String title) { setKind(kind); this.id = id; this.title = title; } public PhotoPlace(String kind, String id, String title) { setKind(kind); this.id = id; this.title = title; } public String getId() { return id; } public int getKind() { return kind; } protected void setKind(int kind) { this.kind = kind; } protected void setKind(String kindStr) { if (""pool"".equalsIgnoreCase(kindStr)) { setKind(POOL); } else if (""set"".equalsIgnoreCase(kindStr)) { setKind(SET); } else { throw new IllegalArgumentException(""Invalid kind ["" + kindStr + ""]""); } } public String getTitle() { return title; } public String getKindAsString() { String s; switch (kind) { case SET:
            s = ""set""; break; case POOL:
            s = ""pool""; break; default:
            s = ""unknown("" + kind + "")""; break; } return s; } public boolean equals(Object obj) { if (obj == null) { return false; } if (obj == this) { return true; } if (!(obj instanceof PhotoPlace)) { return false; } PhotoPlace other = (PhotoPlace) obj; if (other.kind != kind) { return false; } if (this.id != null) { if (!this.id.equals(other.id)) { return false; } } else if (other.id != null) { return false; } if (this.title != null) { if (!this.title.equals(other.title)) { return false; } } else if (other.title != null) { return false; } return true; } public int hashCode() { return id != null ? id.hashCode() : 0; } public String toString() { return getClass().getName() + ""["" + getKindAsString() + "" id=\"""" + id + ""\"" title=\"""" + title + ""\""]""; } } ","package com.flickr4java.flickr.photos;  /**
 * Represents either a photo pool or a photo set with it's id and title. Instances of this class are distinguished as set or pool by their <em>kind</em>
 * property. There are two possible kinds represented as public int constants:
 * <ul>
 * <li>SET this is a photo set</li>
 * <li>POOL this is a groups photo pool</li>
 * </ul>
 * 
 * @author till (Till Krech) flickr:extranoise
 * @version $Id: PhotoPlace.java,v 1.3 2009/07/12 22:43:07 x-mago Exp $
 */ public class PhotoPlace { public static final int SET = 1;  public static final int POOL = 2;  private String id;  private int kind;  private String title;  /**
     * creates a new one.
     * 
     * @param kind
     *            either SET or POOL
     * @param id
     *            id of the pool or set
     * @param title
     *            name of the pool or set
     * @throws IllegalArgumentException
     *             if kind is invalid
     */ public PhotoPlace(int kind, String id, String title) { setKind(kind); this.id = id; this.title = title; }  /**
     * creates a new one where the kind may be specified as String ""set"" or ""pool""
     * 
     * @param kind
     *            either ""set"" or ""pool""
     * @param id
     *            id of the pool or set
     * @param title
     *            name of the pool or set
     * @throws IllegalArgumentException
     *             if kind is invalid
     */ public PhotoPlace(String kind, String id, String title) { setKind(kind); this.id = id; this.title = title; }  /**
     * @return the pool or set id
     */ public String getId() { return id; }  /**
     * @return what I am
     */ public int getKind() { return kind; }  protected void setKind(int kind) { this.kind = kind; }  protected void setKind(String kindStr) { if (""pool"".equalsIgnoreCase(kindStr)) { setKind(POOL); } else if (""set"".equalsIgnoreCase(kindStr)) { setKind(SET); } else { throw new IllegalArgumentException(""Invalid kind ["" + kindStr + ""]""); } }  /**
     * @return the name of the pool or set
     */ public String getTitle() { return title; }  /**
     * @return what I am as String
     */ public String getKindAsString() { String s; switch (kind) { case SET:
            s = ""set""; break; case POOL:
            s = ""pool""; break; default:
            s = ""unknown("" + kind + "")""; break; } return s; }  /**
     * compares this to another object. Makes is possible to put PhotPlaces into a Java Set.
     */ public boolean equals(Object obj) { if (obj == null) { return false; } if (obj == this) { return true; } if (!(obj instanceof PhotoPlace)) { return false; } PhotoPlace other = (PhotoPlace) obj; if (other.kind != kind) { return false; } if (this.id != null) { if (!this.id.equals(other.id)) { return false; } } else if (other.id != null) { return false; } if (this.title != null) { if (!this.title.equals(other.title)) { return false; } } else if (other.title != null) { return false; } return true; }  /**
     * primitive hashCode. Makes is possible to put PhotPlaces into a Java Set.
     */ public int hashCode() { return id != null ? id.hashCode() : 0; }  /**
     * returns a human readable but ugly representation of this object
     */ public String toString() { return getClass().getName() + ""["" + getKindAsString() + "" id=\"""" + id + ""\"" title=\"""" + title + ""\""]""; }  }  "
src/main/java/com/flickr4java/flickr/photos/PhotoSet.java,"package com.flickr4java.flickr.photos;

public class PhotoSet {
	
	 private String title;
	 private String id;
	 private String primary;
	 private String secret;
	 private String server;
	 private String farm;
	 private int viewCount;
	 private int commentCount;
	 private int countPhoto;
	 private int countVideo;
	 
	public String getTitle() {
		return title;
	}
	public void setTitle(String title) {
		this.title = title;
	}
	public String getId() {
		return id;
	}
	public void setId(String id) {
		this.id = id;
	}
	public String getPrimary() {
		return primary;
	}
	public void setPrimary(String primary) {
		this.primary = primary;
	}
	public String getSecret() {
		return secret;
	}
	public void setSecret(String secret) {
		this.secret = secret;
	}
	public String getServer() {
		return server;
	}
	public void setServer(String server) {
		this.server = server;
	}
	public String getFarm() {
		return farm;
	}
	public void setFarm(String farm) {
		this.farm = farm;
	}
	public int getViewCount() {
		return viewCount;
	}
	public void setViewCount(int viewCount) {
		this.viewCount = viewCount;
	}
	public int getCountPhoto() {
		return countPhoto;
	}
	public void setCountPhoto(int countPhoto) {
		this.countPhoto = countPhoto;
	}
	public int getCommentCount() {
		return commentCount;
	}
	public void setCommentCount(int commentCount) {
		this.commentCount = commentCount;
	}
	public int getCountVideo() {
		return countVideo;
	}
	public void setCountVideo(int countVideo) {
		this.countVideo = countVideo;
	}


}
",package com.flickr4java.flickr.photos; public class PhotoSet { private String title; private String id; private String primary; private String secret; private String server; private String farm; private int viewCount; private int commentCount; private int countPhoto; private int countVideo; public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getPrimary() { return primary; } public void setPrimary(String primary) { this.primary = primary; } public String getSecret() { return secret; } public void setSecret(String secret) { this.secret = secret; } public String getServer() { return server; } public void setServer(String server) { this.server = server; } public String getFarm() { return farm; } public void setFarm(String farm) { this.farm = farm; } public int getViewCount() { return viewCount; } public void setViewCount(int viewCount) { this.viewCount = viewCount; } public int getCountPhoto() { return countPhoto; } public void setCountPhoto(int countPhoto) { this.countPhoto = countPhoto; } public int getCommentCount() { return commentCount; } public void setCommentCount(int commentCount) { this.commentCount = commentCount; } public int getCountVideo() { return countVideo; } public void setCountVideo(int countVideo) { this.countVideo = countVideo; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.photos; public class PhotoSet { private String title; private String id; private String primary; private String secret; private String server; private String farm; private int viewCount; private int commentCount; private int countPhoto; private int countVideo; public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getPrimary() { return primary; } public void setPrimary(String primary) { this.primary = primary; } public String getSecret() { return secret; } public void setSecret(String secret) { this.secret = secret; } public String getServer() { return server; } public void setServer(String server) { this.server = server; } public String getFarm() { return farm; } public void setFarm(String farm) { this.farm = farm; } public int getViewCount() { return viewCount; } public void setViewCount(int viewCount) { this.viewCount = viewCount; } public int getCountPhoto() { return countPhoto; } public void setCountPhoto(int countPhoto) { this.countPhoto = countPhoto; } public int getCommentCount() { return commentCount; } public void setCommentCount(int commentCount) { this.commentCount = commentCount; } public int getCountVideo() { return countVideo; } public void setCountVideo(int countVideo) { this.countVideo = countVideo; } } ,"package com.flickr4java.flickr.photos;  public class PhotoSet { 	 private String title; private String id; private String primary; private String secret; private String server; private String farm; private int viewCount; private int commentCount; private int countPhoto; private int countVideo; 	  public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getPrimary() { return primary; } public void setPrimary(String primary) { this.primary = primary; } public String getSecret() { return secret; } public void setSecret(String secret) { this.secret = secret; } public String getServer() { return server; } public void setServer(String server) { this.server = server; } public String getFarm() { return farm; } public void setFarm(String farm) { this.farm = farm; } public int getViewCount() { return viewCount; } public void setViewCount(int viewCount) { this.viewCount = viewCount; } public int getCountPhoto() { return countPhoto; } public void setCountPhoto(int countPhoto) { this.countPhoto = countPhoto; } public int getCommentCount() { return commentCount; } public void setCommentCount(int commentCount) { this.commentCount = commentCount; } public int getCountVideo() { return countVideo; } public void setCountVideo(int countVideo) { this.countVideo = countVideo; } 
 }  "
src/main/java/com/flickr4java/flickr/photos/PhotoSetList.java,"package com.flickr4java.flickr.photos;

import java.util.ArrayList;

public class PhotoSetList<E> extends ArrayList<PhotoSet> {

	/**
	 * 
	 */
	private static final long serialVersionUID = -6749839441338939904L;
	
	

}
",package com.flickr4java.flickr.photos; import java.util.ArrayList; public class PhotoSetList<E> extends ArrayList<PhotoSet> { private static final long serialVersionUID = -6749839441338939904L; },0 0 0 0 0 0,package com.flickr4java.flickr.photos; import java.util.ArrayList; public class PhotoSetList<E> extends ArrayList<PhotoSet> { private static final long serialVersionUID = -6749839441338939904L; } ,"package com.flickr4java.flickr.photos;  import java.util.ArrayList;  public class PhotoSetList<E> extends ArrayList<PhotoSet> {  /**
	 * 
	 */ private static final long serialVersionUID = -6749839441338939904L; 	
	
 }  "
src/main/java/com/flickr4java/flickr/photos/PhotoUrl.java,"

package com.flickr4java.flickr.photos;

/**
 * @author Anthony Eden
 */
public class PhotoUrl {

    private String url;

    private String type;

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    /**
     * Possible known type is photopage.
     * 
     * @return Type of URL
     */
    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

}
",package com.flickr4java.flickr.photos; public class PhotoUrl { private String url; private String type; public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } public String getType() { return type; } public void setType(String type) { this.type = type; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.photos; public class PhotoUrl { private String url; private String type; public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } public String getType() { return type; } public void setType(String type) { this.type = type; } } ,"
 package com.flickr4java.flickr.photos;  /**
 * @author Anthony Eden
 */ public class PhotoUrl {  private String url;  private String type;  public String getUrl() { return url; }  public void setUrl(String url) { this.url = url; }  /**
     * Possible known type is photopage.
     * 
     * @return Type of URL
     */ public String getType() { return type; }  public void setType(String type) { this.type = type; }  }  "
src/main/java/com/flickr4java/flickr/photos/PhotoUtils.java,"package com.flickr4java.flickr.photos;

import com.flickr4java.flickr.people.User;
import com.flickr4java.flickr.places.Place;
import com.flickr4java.flickr.stats.Stats;
import com.flickr4java.flickr.tags.Tag;
import com.flickr4java.flickr.util.XMLUtilities;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;

import java.util.ArrayList;
import java.util.List;

/**
 * Utilitiy-methods to transfer requested XML to Photo-objects.
 * 
 * @author till, x-mago
 * @version $Id: PhotoUtils.java,v 1.20 2009/07/23 21:49:35 x-mago Exp $
 */
public final class PhotoUtils {

    private PhotoUtils() {
    }

    /**
     * Try to get an attribute value from two elements.
     * 
     * @param firstElement
     * @param secondElement
     * @return attribute value
     */
    private static String getAttribute(String name, Element firstElement, Element secondElement) {
        String val = firstElement.getAttribute(name);
        if (val.length() == 0 && secondElement != null) {
            val = secondElement.getAttribute(name);
        }
        return val;
    }

    /**
     * Transfer the Information of a photo from a DOM-object to a Photo-object.
     * 
     * @param photoElement
     * @return Photo
     */
    public static final Photo createPhoto(Element photoElement) {
        return createPhoto(photoElement, null);
    }

    /**
     * Transfer the Information of a photo from a DOM-object to a Photo-object.
     * 
     * @param photoElement
     * @param defaultElement
     * @return Photo
     */
    public static final Photo createPhoto(Element photoElement, Element defaultElement) {
        Photo photo = new Photo();
        photo.setId(photoElement.getAttribute(""id""));
        photo.setPlaceId(photoElement.getAttribute(""place_id""));
        photo.setSecret(photoElement.getAttribute(""secret""));
        photo.setServer(photoElement.getAttribute(""server""));
        photo.setFarm(photoElement.getAttribute(""farm""));
        photo.setRotation(photoElement.getAttribute(""rotation""));
        photo.setFavorite(""1"".equals(photoElement.getAttribute(""isfavorite"")));
        photo.setLicense(photoElement.getAttribute(""license""));
        photo.setOriginalFormat(photoElement.getAttribute(""originalformat""));
        photo.setOriginalSecret(photoElement.getAttribute(""originalsecret""));
        photo.setIconServer(photoElement.getAttribute(""iconserver""));
        photo.setIconFarm(photoElement.getAttribute(""iconfarm""));
        photo.setDateTaken(photoElement.getAttribute(""datetaken""));
        photo.setDatePosted(photoElement.getAttribute(""dateupload""));
        photo.setLastUpdate(photoElement.getAttribute(""lastupdate""));
        // flickr.groups.pools.getPhotos provides this value!
        photo.setDateAdded(photoElement.getAttribute(""dateadded""));
        photo.setOriginalWidth(photoElement.getAttribute(""width_o""));
        photo.setOriginalHeight(photoElement.getAttribute(""height_o""));
        photo.setMedia(photoElement.getAttribute(""media""));
        photo.setMediaStatus(photoElement.getAttribute(""media_status""));
        photo.setPathAlias(photoElement.getAttribute(""pathalias""));
        photo.setViews(photoElement.getAttribute(""views""));

        Element peopleElement = (Element) photoElement.getElementsByTagName(""people"").item(0);
        if (peopleElement != null) {
            photo.setIsHasPeople(""1"".equals(peopleElement.getAttribute(""haspeople"")));
        } else {
            photo.setIsHasPeople(false);
        }

        // If the attributes active that contain the image-urls,
        // Size-objects created from them, which are used to override
        // the Url-generation.
        List<Size> sizes = new ArrayList<Size>();
        String urlTmp = photoElement.getAttribute(""url_t"");
        if (urlTmp != null && urlTmp.startsWith(""http"")) {
            Size sizeT = new Size();
            sizeT.setLabel(Size.THUMB);
            sizeT.setSource(urlTmp);
            sizeT.setWidth(photoElement.getAttribute(""width_t""));
            sizeT.setHeight(photoElement.getAttribute(""height_t""));
            sizes.add(sizeT);
        }
        urlTmp = photoElement.getAttribute(""url_s"");
        if (urlTmp != null && urlTmp.startsWith(""http"")) {
            Size sizeT = new Size();
            sizeT.setLabel(Size.SMALL);
            sizeT.setSource(urlTmp);
            sizeT.setWidth(photoElement.getAttribute(""width_s""));
            sizeT.setHeight(photoElement.getAttribute(""height_s""));
            sizes.add(sizeT);
        }
        urlTmp = photoElement.getAttribute(""url_sq"");
        if (urlTmp != null && urlTmp.startsWith(""http"")) {
            Size sizeT = new Size();
            sizeT.setLabel(Size.SQUARE);
            sizeT.setSource(urlTmp);
            sizeT.setWidth(photoElement.getAttribute(""width_sq""));
            sizeT.setHeight(photoElement.getAttribute(""height_sq""));
            sizes.add(sizeT);
        }
        urlTmp = photoElement.getAttribute(""url_m"");
        if (urlTmp != null && urlTmp.startsWith(""http"")) {
            Size sizeT = new Size();
            sizeT.setLabel(Size.MEDIUM);
            sizeT.setSource(urlTmp);
            sizeT.setWidth(photoElement.getAttribute(""width_m""));
            sizeT.setHeight(photoElement.getAttribute(""height_m""));
            sizes.add(sizeT);
        }
        urlTmp = photoElement.getAttribute(""url_l"");
        if (urlTmp != null && urlTmp.startsWith(""http"")) {
            Size sizeT = new Size();
            sizeT.setLabel(Size.LARGE);
            sizeT.setSource(urlTmp);
            sizeT.setWidth(photoElement.getAttribute(""width_l""));
            sizeT.setHeight(photoElement.getAttribute(""height_l""));
            sizes.add(sizeT);
        }
        urlTmp = photoElement.getAttribute(""url_o"");
        if (urlTmp != null && urlTmp.startsWith(""http"")) {
            Size sizeT = new Size();
            sizeT.setLabel(Size.ORIGINAL);
            sizeT.setSource(urlTmp);
            sizeT.setWidth(photoElement.getAttribute(""width_o""));
            sizeT.setHeight(photoElement.getAttribute(""height_o""));
            sizes.add(sizeT);
        }
        urlTmp = photoElement.getAttribute(""url_q"");
        if (urlTmp != null && urlTmp.startsWith(""http"")) {
            Size sizeT = new Size();
            sizeT.setLabel(Size.SQUARE_LARGE);
            sizeT.setSource(urlTmp);
            sizeT.setWidth(photoElement.getAttribute(""width_q""));
            sizeT.setHeight(photoElement.getAttribute(""height_q""));
            sizes.add(sizeT);
        }
        urlTmp = photoElement.getAttribute(""url_n"");
        if (urlTmp != null && urlTmp.startsWith(""http"")) {
            Size sizeT = new Size();
            sizeT.setLabel(Size.SMALL_320);
            sizeT.setSource(urlTmp);
            sizeT.setWidth(photoElement.getAttribute(""width_n""));
            sizeT.setHeight(photoElement.getAttribute(""height_n""));
            sizes.add(sizeT);
        }
        urlTmp = photoElement.getAttribute(""url_z"");
        if (urlTmp != null && urlTmp.startsWith(""http"")) {
            Size sizeT = new Size();
            sizeT.setLabel(Size.MEDIUM_640);
            sizeT.setSource(urlTmp);
            sizeT.setWidth(photoElement.getAttribute(""width_z""));
            sizeT.setHeight(photoElement.getAttribute(""height_z""));
            sizes.add(sizeT);
        }
        urlTmp = photoElement.getAttribute(""url_c"");
        if (urlTmp != null && urlTmp.startsWith(""http"")) {
            Size sizeT = new Size();
            sizeT.setLabel(Size.MEDIUM_800);
            sizeT.setSource(urlTmp);
            sizeT.setWidth(photoElement.getAttribute(""width_c""));
            sizeT.setHeight(photoElement.getAttribute(""height_c""));
            sizes.add(sizeT);
        }
        urlTmp = photoElement.getAttribute(""url_h"");
        if (urlTmp != null && urlTmp.startsWith(""http"")) {
            Size sizeT = new Size();
            sizeT.setLabel(Size.LARGE_1600);
            sizeT.setSource(urlTmp);
            sizeT.setWidth(photoElement.getAttribute(""width_h""));
            sizeT.setHeight(photoElement.getAttribute(""height_h""));
            sizes.add(sizeT);
        }
        urlTmp = photoElement.getAttribute(""url_k"");
        if (urlTmp != null && urlTmp.startsWith(""http"")) {
            Size sizeT = new Size();
            sizeT.setLabel(Size.LARGE_2048);
            sizeT.setSource(urlTmp);
            sizeT.setWidth(photoElement.getAttribute(""width_k""));
            sizeT.setHeight(photoElement.getAttribute(""height_k""));
            sizes.add(sizeT);
        }
        if (sizes.size() > 0) {
            photo.setSizes(sizes);
        }

        // Searches, or other list may contain orginal_format.
        // If not choosen via extras, set jpg as default.
        try {
            if (photo.getOriginalFormat() == null || photo.getOriginalFormat().equals("""")) {
                String media = photo.getMedia();
                if (media != null && media.equals(""video""))
                    photo.setOriginalFormat(""mov""); // Currently flickr incorrectly returns original_format as jpg for movies.
                else
                    photo.setOriginalFormat(""jpg"");
            }
        } catch (NullPointerException e) {
            photo.setOriginalFormat(""jpg"");
        }

        try {
            Element ownerElement = (Element) photoElement.getElementsByTagName(""owner"").item(0);
            if (ownerElement == null) {
                User owner = new User();
                owner.setId(getAttribute(""owner"", photoElement, defaultElement));
                owner.setUsername(getAttribute(""ownername"", photoElement, defaultElement));
                photo.setOwner(owner);
                photo.setUrl(""https://flickr.com/photos/"" + owner.getId() + ""/"" + photo.getId());
            } else {
                User owner = new User();
                owner.setId(ownerElement.getAttribute(""nsid""));

                String username = ownerElement.getAttribute(""username"");
                String ownername = ownerElement.getAttribute(""ownername"");
                // try to get the username either from the ""username"" attribute or
                // from the ""ownername"" attribute
                if (username != null && !"""".equals(username)) {
                    owner.setUsername(username);
                } else if (ownername != null && !"""".equals(ownername)) {
                    owner.setUsername(ownername);
                }

                owner.setUsername(ownerElement.getAttribute(""username""));
                owner.setRealName(ownerElement.getAttribute(""realname""));
                owner.setLocation(ownerElement.getAttribute(""location""));
                photo.setOwner(owner);
                photo.setUrl(""https://flickr.com/photos/"" + owner.getId() + ""/"" + photo.getId());
            }
        } catch (IndexOutOfBoundsException e) {
            User owner = new User();
            owner.setId(photoElement.getAttribute(""owner""));
            owner.setUsername(photoElement.getAttribute(""ownername""));
            photo.setOwner(owner);
            photo.setUrl(""https://flickr.com/photos/"" + owner.getId() + ""/"" + photo.getId());
        }

        try {
            photo.setTitle(XMLUtilities.getChildValue(photoElement, ""title""));
            if (photo.getTitle() == null) {
                photo.setTitle(photoElement.getAttribute(""title""));
            }
        } catch (IndexOutOfBoundsException e) {
            photo.setTitle(photoElement.getAttribute(""title""));
        }

        try {
            photo.setDescription(XMLUtilities.getChildValue(photoElement, ""description""));
        } catch (IndexOutOfBoundsException e) {
        }

        try {
            // here the flags are set, if the photo is read by getInfo().
            Element visibilityElement = (Element) photoElement.getElementsByTagName(""visibility"").item(0);
            photo.setPublicFlag(""1"".equals(visibilityElement.getAttribute(""ispublic"")));
            photo.setFriendFlag(""1"".equals(visibilityElement.getAttribute(""isfriend"")));
            photo.setFamilyFlag(""1"".equals(visibilityElement.getAttribute(""isfamily"")));
        } catch (IndexOutOfBoundsException e) {
        } catch (NullPointerException e) {
            // these flags are set here, if photos read from a list.
            photo.setPublicFlag(""1"".equals(photoElement.getAttribute(""ispublic"")));
            photo.setFriendFlag(""1"".equals(photoElement.getAttribute(""isfriend"")));
            photo.setFamilyFlag(""1"".equals(photoElement.getAttribute(""isfamily"")));
        }

        // Parse either photo by getInfo, or from list
        try {
            Element datesElement = XMLUtilities.getChild(photoElement, ""dates"");
            photo.setDatePosted(datesElement.getAttribute(""posted""));
            photo.setDateTaken(datesElement.getAttribute(""taken""));
            photo.setTakenGranularity(datesElement.getAttribute(""takengranularity""));
            photo.setLastUpdate(datesElement.getAttribute(""lastupdate""));
        } catch (IndexOutOfBoundsException e) {
            photo.setDateTaken(photoElement.getAttribute(""datetaken""));
        } catch (NullPointerException e) {
            photo.setDateTaken(photoElement.getAttribute(""datetaken""));
        }

        try {
            Element permissionsElement = (Element) photoElement.getElementsByTagName(""permissions"").item(0);
            Permissions permissions = new Permissions();
            permissions.setComment(permissionsElement.getAttribute(""permcomment""));
            permissions.setAddmeta(permissionsElement.getAttribute(""permaddmeta""));
            photo.setPermissions(permissions);
        } catch (IndexOutOfBoundsException e) {
        } catch (NullPointerException e) {
            // nop
        }

        try {
            Element editabilityElement = (Element) photoElement.getElementsByTagName(""editability"").item(0);
            Editability editability = new Editability();
            editability.setComment(""1"".equals(editabilityElement.getAttribute(""cancomment"")));
            editability.setAddmeta(""1"".equals(editabilityElement.getAttribute(""canaddmeta"")));
            photo.setEditability(editability);
        } catch (IndexOutOfBoundsException e) {
        } catch (NullPointerException e) {
            // nop
        }

        try {
            Element publicEditabilityElement = (Element) photoElement.getElementsByTagName(""publiceditability"").item(0);
            Editability publicEditability = new Editability();
            publicEditability.setComment(""1"".equals(publicEditabilityElement.getAttribute(""cancomment"")));
            publicEditability.setAddmeta(""1"".equals(publicEditabilityElement.getAttribute(""canaddmeta"")));
            photo.setPublicEditability(publicEditability);
        } catch (IndexOutOfBoundsException e) {
        } catch (NullPointerException e) {
            // nop
        }

        try {
            Element usageElement = (Element) photoElement.getElementsByTagName(""usage"").item(0);
            Usage usage = new Usage();

            usage.setIsCanBlog(""1"".equals(usageElement.getAttribute(""canblog"")));
            usage.setIsCanDownload(""1"".equals(usageElement.getAttribute(""candownload"")));
            usage.setIsCanShare(""1"".equals(usageElement.getAttribute(""canshare"")));
            usage.setIsCanPrint(""1"".equals(usageElement.getAttribute(""canprint"")));
            photo.setUsage(usage);
        } catch (IndexOutOfBoundsException e) {
        } catch (NullPointerException e) {
            // nop
        }

        try {
            Element commentsElement = (Element) photoElement.getElementsByTagName(""comments"").item(0);
            photo.setComments(((Text) commentsElement.getFirstChild()).getData());
        } catch (IndexOutOfBoundsException e) {
        } catch (NullPointerException e) {
            // nop
        }

        try {
            Element notesElement = (Element) photoElement.getElementsByTagName(""notes"").item(0);
            List<Note> notes = new ArrayList<Note>();
            NodeList noteNodes = notesElement.getElementsByTagName(""note"");
            for (int i = 0; i < noteNodes.getLength(); i++) {
                Element noteElement = (Element) noteNodes.item(i);
                Note note = new Note();
                note.setId(noteElement.getAttribute(""id""));
                note.setAuthor(noteElement.getAttribute(""author""));
                note.setAuthorName(noteElement.getAttribute(""authorname""));
                note.setBounds(noteElement.getAttribute(""x""), noteElement.getAttribute(""y""), noteElement.getAttribute(""w""), noteElement.getAttribute(""h""));
                note.setText(noteElement.getTextContent());
                notes.add(note);
            }
            photo.setNotes(notes);
        } catch (IndexOutOfBoundsException e) {
            photo.setNotes(new ArrayList<Note>());
        } catch (NullPointerException e) {
            photo.setNotes(new ArrayList<Note>());
        }

        // Tags coming as space-seperated attribute calling
        // InterestingnessInterface#getList().
        // Through PhotoInterface#getInfo() the Photo has a list of
        // Elements.
        try {
            List<Tag> tags = new ArrayList<Tag>();
            String tagsAttr = photoElement.getAttribute(""tags"");
            if (!tagsAttr.equals("""")) {
                String[] values = tagsAttr.split(""\\s+"");
                for (int i = 0; i < values.length; i++) {
                    Tag tag = new Tag();
                    tag.setValue(values[i]);
                    tags.add(tag);
                }
            } else {
                try {
                    Element tagsElement = (Element) photoElement.getElementsByTagName(""tags"").item(0);
                    NodeList tagNodes = tagsElement.getElementsByTagName(""tag"");
                    for (int i = 0; i < tagNodes.getLength(); i++) {
                        Element tagElement = (Element) tagNodes.item(i);
                        Tag tag = new Tag();
                        tag.setId(tagElement.getAttribute(""id""));
                        tag.setAuthor(tagElement.getAttribute(""author""));
                        tag.setRaw(tagElement.getAttribute(""raw""));
                        tag.setValue(((Text) tagElement.getFirstChild()).getData());
                        tags.add(tag);
                    }
                } catch (IndexOutOfBoundsException e) {
                }
            }
            photo.setTags(tags);
        } catch (NullPointerException e) {
            photo.setTags(new ArrayList<Tag>());
        }

        try {
            Element urlsElement = (Element) photoElement.getElementsByTagName(""urls"").item(0);
            List<String> urls = new ArrayList<String>();
            NodeList urlNodes = urlsElement.getElementsByTagName(""url"");
            for (int i = 0; i < urlNodes.getLength(); i++) {
                Element urlElement = (Element) urlNodes.item(i);
                PhotoUrl photoUrl = new PhotoUrl();
                photo.setPhotoUrl(photoUrl);
                photoUrl.setType(urlElement.getAttribute(""type""));
                photoUrl.setUrl(XMLUtilities.getValue(urlElement));
                if (photoUrl.getType().equals(""photopage"")) {
                    photo.setUrl(photoUrl.getUrl());
                    urls.add(photoUrl.getUrl());
                }

            }

            photo.setUrls(urls);
        } catch (IndexOutOfBoundsException e) {
        } catch (NullPointerException e) {
            photo.setUrls(new ArrayList<String>());
        }

        String longitude = null;
        String latitude = null;
        String accuracy = null;
        try {
            Element geoElement = (Element) photoElement.getElementsByTagName(""location"").item(0);
            longitude = geoElement.getAttribute(""longitude"");
            latitude = geoElement.getAttribute(""latitude"");
            accuracy = geoElement.getAttribute(""accuracy"");
        } catch (IndexOutOfBoundsException e) {
        } catch (NullPointerException e) {
            // Geodata may be available as attributes in the photo-tag itself!
            try {
                longitude = photoElement.getAttribute(""longitude"");
                latitude = photoElement.getAttribute(""latitude"");
                accuracy = photoElement.getAttribute(""accuracy"");
            } catch (NullPointerException e2) {
                // no geodata at all
            }
        }
        if (longitude != null && latitude != null) {
            if (longitude.length() > 0 && latitude.length() > 0 && !(""0"".equals(longitude) && ""0"".equals(latitude))) {
                photo.setGeoData(new GeoData(longitude, latitude, accuracy));
            }
        }

        try {
            Place place = null;
            Element element = (Element) photoElement.getElementsByTagName(""locality"").item(0);
            place = new Place(element.getAttribute(""place_id""), element.getTextContent(), element.getAttribute(""woeid""));
            photo.setLocality(place);
        } catch (IndexOutOfBoundsException e) {
        } catch (NullPointerException e) {
        }

        try {
            Place place = null;
            Element element = (Element) photoElement.getElementsByTagName(""county"").item(0);
            place = new Place(element.getAttribute(""place_id""), element.getTextContent(), element.getAttribute(""woeid""));
            photo.setCounty(place);
        } catch (IndexOutOfBoundsException e) {
        } catch (NullPointerException e) {
        }

        try {
            Place place = null;
            Element element = (Element) photoElement.getElementsByTagName(""region"").item(0);
            place = new Place(element.getAttribute(""place_id""), element.getTextContent(), element.getAttribute(""woeid""));
            photo.setRegion(place);
        } catch (IndexOutOfBoundsException e) {
        } catch (NullPointerException e) {
        }

        try {
            Place place = null;
            Element element = (Element) photoElement.getElementsByTagName(""country"").item(0);
            place = new Place(element.getAttribute(""place_id""), element.getTextContent(), element.getAttribute(""woeid""));
            photo.setCountry(place);
        } catch (IndexOutOfBoundsException e) {
        } catch (NullPointerException e) {
        }
        
        //set stats from extras (count_faves,count_comments,count_views)
        try {
            Stats stats = new Stats();;
            stats.setFavorites(photoElement.getAttribute(""count_faves""));
            stats.setComments(photoElement.getAttribute(""count_comments""));
            stats.setViews(photoElement.getAttribute(""count_views""));
            photo.setStats(stats);
        } catch (IndexOutOfBoundsException e) {
        } catch (NullPointerException e) {
        }

        return photo;
    }

    /**
     * Parse a list of Photos from given Element.
     * 
     * @param photosElement
     * @return PhotoList
     */
    public static final PhotoList<Photo> createPhotoList(Element photosElement) {
        PhotoList<Photo> photos = new PhotoList<Photo>();
        photos.setPage(photosElement.getAttribute(""page""));
        photos.setPages(photosElement.getAttribute(""pages""));
        photos.setPerPage(photosElement.getAttribute(""perpage""));
        photos.setTotal(photosElement.getAttribute(""total""));

        NodeList photoNodes = photosElement.getElementsByTagName(""photo"");
        for (int i = 0; i < photoNodes.getLength(); i++) {
            Element photoElement = (Element) photoNodes.item(i);
            photos.add(PhotoUtils.createPhoto(photoElement));
        }
        return photos;
    }

}
","package com.flickr4java.flickr.photos; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.places.Place; import com.flickr4java.flickr.stats.Stats; import com.flickr4java.flickr.tags.Tag; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import org.w3c.dom.Text; import java.util.ArrayList; import java.util.List; public final class PhotoUtils { private PhotoUtils() { } private static String getAttribute(String name, Element firstElement, Element secondElement) { String val = firstElement.getAttribute(name); if (val.length() == 0 && secondElement != null) { val = secondElement.getAttribute(name); } return val; } public static final Photo createPhoto(Element photoElement) { return createPhoto(photoElement, null); } public static final Photo createPhoto(Element photoElement, Element defaultElement) { Photo photo = new Photo(); photo.setId(photoElement.getAttribute(""id"")); photo.setPlaceId(photoElement.getAttribute(""place_id"")); photo.setSecret(photoElement.getAttribute(""secret"")); photo.setServer(photoElement.getAttribute(""server"")); photo.setFarm(photoElement.getAttribute(""farm"")); photo.setRotation(photoElement.getAttribute(""rotation"")); photo.setFavorite(""1"".equals(photoElement.getAttribute(""isfavorite""))); photo.setLicense(photoElement.getAttribute(""license"")); photo.setOriginalFormat(photoElement.getAttribute(""originalformat"")); photo.setOriginalSecret(photoElement.getAttribute(""originalsecret"")); photo.setIconServer(photoElement.getAttribute(""iconserver"")); photo.setIconFarm(photoElement.getAttribute(""iconfarm"")); photo.setDateTaken(photoElement.getAttribute(""datetaken"")); photo.setDatePosted(photoElement.getAttribute(""dateupload"")); photo.setLastUpdate(photoElement.getAttribute(""lastupdate"")); photo.setDateAdded(photoElement.getAttribute(""dateadded"")); photo.setOriginalWidth(photoElement.getAttribute(""width_o"")); photo.setOriginalHeight(photoElement.getAttribute(""height_o"")); photo.setMedia(photoElement.getAttribute(""media"")); photo.setMediaStatus(photoElement.getAttribute(""media_status"")); photo.setPathAlias(photoElement.getAttribute(""pathalias"")); photo.setViews(photoElement.getAttribute(""views"")); Element peopleElement = (Element) photoElement.getElementsByTagName(""people"").item(0); if (peopleElement != null) { photo.setIsHasPeople(""1"".equals(peopleElement.getAttribute(""haspeople""))); } else { photo.setIsHasPeople(false); } List<Size> sizes = new ArrayList<Size>(); String urlTmp = photoElement.getAttribute(""url_t""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.THUMB); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_t"")); sizeT.setHeight(photoElement.getAttribute(""height_t"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_s""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.SMALL); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_s"")); sizeT.setHeight(photoElement.getAttribute(""height_s"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_sq""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.SQUARE); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_sq"")); sizeT.setHeight(photoElement.getAttribute(""height_sq"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_m""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.MEDIUM); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_m"")); sizeT.setHeight(photoElement.getAttribute(""height_m"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_l""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.LARGE); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_l"")); sizeT.setHeight(photoElement.getAttribute(""height_l"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_o""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.ORIGINAL); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_o"")); sizeT.setHeight(photoElement.getAttribute(""height_o"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_q""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.SQUARE_LARGE); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_q"")); sizeT.setHeight(photoElement.getAttribute(""height_q"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_n""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.SMALL_320); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_n"")); sizeT.setHeight(photoElement.getAttribute(""height_n"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_z""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.MEDIUM_640); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_z"")); sizeT.setHeight(photoElement.getAttribute(""height_z"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_c""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.MEDIUM_800); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_c"")); sizeT.setHeight(photoElement.getAttribute(""height_c"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_h""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.LARGE_1600); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_h"")); sizeT.setHeight(photoElement.getAttribute(""height_h"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_k""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.LARGE_2048); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_k"")); sizeT.setHeight(photoElement.getAttribute(""height_k"")); sizes.add(sizeT); } if (sizes.size() > 0) { photo.setSizes(sizes); } try { if (photo.getOriginalFormat() == null || photo.getOriginalFormat().equals("""")) { String media = photo.getMedia(); if (media != null && media.equals(""video""))
                    photo.setOriginalFormat(""mov""); else
                    photo.setOriginalFormat(""jpg""); } } catch (NullPointerException e) { photo.setOriginalFormat(""jpg""); } try { Element ownerElement = (Element) photoElement.getElementsByTagName(""owner"").item(0); if (ownerElement == null) { User owner = new User(); owner.setId(getAttribute(""owner"", photoElement, defaultElement)); owner.setUsername(getAttribute(""ownername"", photoElement, defaultElement)); photo.setOwner(owner); } else { User owner = new User(); owner.setId(ownerElement.getAttribute(""nsid"")); String username = ownerElement.getAttribute(""username""); String ownername = ownerElement.getAttribute(""ownername""); if (username != null && !"""".equals(username)) { owner.setUsername(username); } else if (ownername != null && !"""".equals(ownername)) { owner.setUsername(ownername); } owner.setUsername(ownerElement.getAttribute(""username"")); owner.setRealName(ownerElement.getAttribute(""realname"")); owner.setLocation(ownerElement.getAttribute(""location"")); photo.setOwner(owner); } } catch (IndexOutOfBoundsException e) { User owner = new User(); owner.setId(photoElement.getAttribute(""owner"")); owner.setUsername(photoElement.getAttribute(""ownername"")); photo.setOwner(owner); } try { photo.setTitle(XMLUtilities.getChildValue(photoElement, ""title"")); if (photo.getTitle() == null) { photo.setTitle(photoElement.getAttribute(""title"")); } } catch (IndexOutOfBoundsException e) { photo.setTitle(photoElement.getAttribute(""title"")); } try { photo.setDescription(XMLUtilities.getChildValue(photoElement, ""description"")); } catch (IndexOutOfBoundsException e) { } try { Element visibilityElement = (Element) photoElement.getElementsByTagName(""visibility"").item(0); photo.setPublicFlag(""1"".equals(visibilityElement.getAttribute(""ispublic""))); photo.setFriendFlag(""1"".equals(visibilityElement.getAttribute(""isfriend""))); photo.setFamilyFlag(""1"".equals(visibilityElement.getAttribute(""isfamily""))); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { photo.setPublicFlag(""1"".equals(photoElement.getAttribute(""ispublic""))); photo.setFriendFlag(""1"".equals(photoElement.getAttribute(""isfriend""))); photo.setFamilyFlag(""1"".equals(photoElement.getAttribute(""isfamily""))); } try { Element datesElement = XMLUtilities.getChild(photoElement, ""dates""); photo.setDatePosted(datesElement.getAttribute(""posted"")); photo.setDateTaken(datesElement.getAttribute(""taken"")); photo.setTakenGranularity(datesElement.getAttribute(""takengranularity"")); photo.setLastUpdate(datesElement.getAttribute(""lastupdate"")); } catch (IndexOutOfBoundsException e) { photo.setDateTaken(photoElement.getAttribute(""datetaken"")); } catch (NullPointerException e) { photo.setDateTaken(photoElement.getAttribute(""datetaken"")); } try { Element permissionsElement = (Element) photoElement.getElementsByTagName(""permissions"").item(0); Permissions permissions = new Permissions(); permissions.setComment(permissionsElement.getAttribute(""permcomment"")); permissions.setAddmeta(permissionsElement.getAttribute(""permaddmeta"")); photo.setPermissions(permissions); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { } try { Element editabilityElement = (Element) photoElement.getElementsByTagName(""editability"").item(0); Editability editability = new Editability(); editability.setComment(""1"".equals(editabilityElement.getAttribute(""cancomment""))); editability.setAddmeta(""1"".equals(editabilityElement.getAttribute(""canaddmeta""))); photo.setEditability(editability); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { } try { Element publicEditabilityElement = (Element) photoElement.getElementsByTagName(""publiceditability"").item(0); Editability publicEditability = new Editability(); publicEditability.setComment(""1"".equals(publicEditabilityElement.getAttribute(""cancomment""))); publicEditability.setAddmeta(""1"".equals(publicEditabilityElement.getAttribute(""canaddmeta""))); photo.setPublicEditability(publicEditability); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { } try { Element usageElement = (Element) photoElement.getElementsByTagName(""usage"").item(0); Usage usage = new Usage(); usage.setIsCanBlog(""1"".equals(usageElement.getAttribute(""canblog""))); usage.setIsCanDownload(""1"".equals(usageElement.getAttribute(""candownload""))); usage.setIsCanShare(""1"".equals(usageElement.getAttribute(""canshare""))); usage.setIsCanPrint(""1"".equals(usageElement.getAttribute(""canprint""))); photo.setUsage(usage); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { } try { Element commentsElement = (Element) photoElement.getElementsByTagName(""comments"").item(0); photo.setComments(((Text) commentsElement.getFirstChild()).getData()); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { } try { Element notesElement = (Element) photoElement.getElementsByTagName(""notes"").item(0); List<Note> notes = new ArrayList<Note>(); NodeList noteNodes = notesElement.getElementsByTagName(""note""); for (int i = 0; i < noteNodes.getLength(); i++) { Element noteElement = (Element) noteNodes.item(i); Note note = new Note(); note.setId(noteElement.getAttribute(""id"")); note.setAuthor(noteElement.getAttribute(""author"")); note.setAuthorName(noteElement.getAttribute(""authorname"")); note.setBounds(noteElement.getAttribute(""x""), noteElement.getAttribute(""y""), noteElement.getAttribute(""w""), noteElement.getAttribute(""h"")); note.setText(noteElement.getTextContent()); notes.add(note); } photo.setNotes(notes); } catch (IndexOutOfBoundsException e) { photo.setNotes(new ArrayList<Note>()); } catch (NullPointerException e) { photo.setNotes(new ArrayList<Note>()); } try { List<Tag> tags = new ArrayList<Tag>(); String tagsAttr = photoElement.getAttribute(""tags""); if (!tagsAttr.equals("""")) { String[] values = tagsAttr.split(""\\s+""); for (int i = 0; i < values.length; i++) { Tag tag = new Tag(); tag.setValue(values[i]); tags.add(tag); } } else { try { Element tagsElement = (Element) photoElement.getElementsByTagName(""tags"").item(0); NodeList tagNodes = tagsElement.getElementsByTagName(""tag""); for (int i = 0; i < tagNodes.getLength(); i++) { Element tagElement = (Element) tagNodes.item(i); Tag tag = new Tag(); tag.setId(tagElement.getAttribute(""id"")); tag.setAuthor(tagElement.getAttribute(""author"")); tag.setRaw(tagElement.getAttribute(""raw"")); tag.setValue(((Text) tagElement.getFirstChild()).getData()); tags.add(tag); } } catch (IndexOutOfBoundsException e) { } } photo.setTags(tags); } catch (NullPointerException e) { photo.setTags(new ArrayList<Tag>()); } try { Element urlsElement = (Element) photoElement.getElementsByTagName(""urls"").item(0); List<String> urls = new ArrayList<String>(); NodeList urlNodes = urlsElement.getElementsByTagName(""url""); for (int i = 0; i < urlNodes.getLength(); i++) { Element urlElement = (Element) urlNodes.item(i); PhotoUrl photoUrl = new PhotoUrl(); photo.setPhotoUrl(photoUrl); photoUrl.setType(urlElement.getAttribute(""type"")); photoUrl.setUrl(XMLUtilities.getValue(urlElement)); if (photoUrl.getType().equals(""photopage"")) { photo.setUrl(photoUrl.getUrl()); urls.add(photoUrl.getUrl()); } } photo.setUrls(urls); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { photo.setUrls(new ArrayList<String>()); } String longitude = null; String latitude = null; String accuracy = null; try { Element geoElement = (Element) photoElement.getElementsByTagName(""location"").item(0); longitude = geoElement.getAttribute(""longitude""); latitude = geoElement.getAttribute(""latitude""); accuracy = geoElement.getAttribute(""accuracy""); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { try { longitude = photoElement.getAttribute(""longitude""); latitude = photoElement.getAttribute(""latitude""); accuracy = photoElement.getAttribute(""accuracy""); } catch (NullPointerException e2) { } } if (longitude != null && latitude != null) { if (longitude.length() > 0 && latitude.length() > 0 && !(""0"".equals(longitude) && ""0"".equals(latitude))) { photo.setGeoData(new GeoData(longitude, latitude, accuracy)); } } try { Place place = null; Element element = (Element) photoElement.getElementsByTagName(""locality"").item(0); place = new Place(element.getAttribute(""place_id""), element.getTextContent(), element.getAttribute(""woeid"")); photo.setLocality(place); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { } try { Place place = null; Element element = (Element) photoElement.getElementsByTagName(""county"").item(0); place = new Place(element.getAttribute(""place_id""), element.getTextContent(), element.getAttribute(""woeid"")); photo.setCounty(place); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { } try { Place place = null; Element element = (Element) photoElement.getElementsByTagName(""region"").item(0); place = new Place(element.getAttribute(""place_id""), element.getTextContent(), element.getAttribute(""woeid"")); photo.setRegion(place); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { } try { Place place = null; Element element = (Element) photoElement.getElementsByTagName(""country"").item(0); place = new Place(element.getAttribute(""place_id""), element.getTextContent(), element.getAttribute(""woeid"")); photo.setCountry(place); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { } try { Stats stats = new Stats(); ; stats.setFavorites(photoElement.getAttribute(""count_faves"")); stats.setComments(photoElement.getAttribute(""count_comments"")); stats.setViews(photoElement.getAttribute(""count_views"")); photo.setStats(stats); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { } return photo; } public static final PhotoList<Photo> createPhotoList(Element photosElement) { PhotoList<Photo> photos = new PhotoList<Photo>(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.photos; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.places.Place; import com.flickr4java.flickr.stats.Stats; import com.flickr4java.flickr.tags.Tag; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import org.w3c.dom.Text; import java.util.ArrayList; import java.util.List; public final class PhotoUtils { private PhotoUtils() { } private static String getAttribute(String name, Element firstElement, Element secondElement) { String val = firstElement.getAttribute(name); if (val.length() == 0 && secondElement != null) { val = secondElement.getAttribute(name); } return val; } public static final Photo createPhoto(Element photoElement) { return createPhoto(photoElement, null); } public static final Photo createPhoto(Element photoElement, Element defaultElement) { Photo photo = new Photo(); photo.setId(photoElement.getAttribute(""id"")); photo.setPlaceId(photoElement.getAttribute(""place_id"")); photo.setSecret(photoElement.getAttribute(""secret"")); photo.setServer(photoElement.getAttribute(""server"")); photo.setFarm(photoElement.getAttribute(""farm"")); photo.setRotation(photoElement.getAttribute(""rotation"")); photo.setFavorite(""1"".equals(photoElement.getAttribute(""isfavorite""))); photo.setLicense(photoElement.getAttribute(""license"")); photo.setOriginalFormat(photoElement.getAttribute(""originalformat"")); photo.setOriginalSecret(photoElement.getAttribute(""originalsecret"")); photo.setIconServer(photoElement.getAttribute(""iconserver"")); photo.setIconFarm(photoElement.getAttribute(""iconfarm"")); photo.setDateTaken(photoElement.getAttribute(""datetaken"")); photo.setDatePosted(photoElement.getAttribute(""dateupload"")); photo.setLastUpdate(photoElement.getAttribute(""lastupdate"")); photo.setDateAdded(photoElement.getAttribute(""dateadded"")); photo.setOriginalWidth(photoElement.getAttribute(""width_o"")); photo.setOriginalHeight(photoElement.getAttribute(""height_o"")); photo.setMedia(photoElement.getAttribute(""media"")); photo.setMediaStatus(photoElement.getAttribute(""media_status"")); photo.setPathAlias(photoElement.getAttribute(""pathalias"")); photo.setViews(photoElement.getAttribute(""views"")); Element peopleElement = (Element) photoElement.getElementsByTagName(""people"").item(0); if (peopleElement != null) { photo.setIsHasPeople(""1"".equals(peopleElement.getAttribute(""haspeople""))); } else { photo.setIsHasPeople(false); } List<Size> sizes = new ArrayList<Size>(); String urlTmp = photoElement.getAttribute(""url_t""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.THUMB); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_t"")); sizeT.setHeight(photoElement.getAttribute(""height_t"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_s""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.SMALL); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_s"")); sizeT.setHeight(photoElement.getAttribute(""height_s"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_sq""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.SQUARE); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_sq"")); sizeT.setHeight(photoElement.getAttribute(""height_sq"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_m""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.MEDIUM); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_m"")); sizeT.setHeight(photoElement.getAttribute(""height_m"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_l""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.LARGE); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_l"")); sizeT.setHeight(photoElement.getAttribute(""height_l"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_o""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.ORIGINAL); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_o"")); sizeT.setHeight(photoElement.getAttribute(""height_o"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_q""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.SQUARE_LARGE); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_q"")); sizeT.setHeight(photoElement.getAttribute(""height_q"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_n""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.SMALL_320); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_n"")); sizeT.setHeight(photoElement.getAttribute(""height_n"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_z""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.MEDIUM_640); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_z"")); sizeT.setHeight(photoElement.getAttribute(""height_z"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_c""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.MEDIUM_800); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_c"")); sizeT.setHeight(photoElement.getAttribute(""height_c"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_h""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.LARGE_1600); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_h"")); sizeT.setHeight(photoElement.getAttribute(""height_h"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_k""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.LARGE_2048); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_k"")); sizeT.setHeight(photoElement.getAttribute(""height_k"")); sizes.add(sizeT); } if (sizes.size() > 0) { photo.setSizes(sizes); } try { if (photo.getOriginalFormat() == null || photo.getOriginalFormat().equals("""")) { String media = photo.getMedia(); if (media != null && media.equals(""video""))
                    photo.setOriginalFormat(""mov""); else
                    photo.setOriginalFormat(""jpg""); } } catch (NullPointerException e) { photo.setOriginalFormat(""jpg""); } try { Element ownerElement = (Element) photoElement.getElementsByTagName(""owner"").item(0); if (ownerElement == null) { User owner = new User(); owner.setId(getAttribute(""owner"", photoElement, defaultElement)); owner.setUsername(getAttribute(""ownername"", photoElement, defaultElement)); photo.setOwner(owner); } else { User owner = new User(); owner.setId(ownerElement.getAttribute(""nsid"")); String username = ownerElement.getAttribute(""username""); String ownername = ownerElement.getAttribute(""ownername""); if (username != null && !"""".equals(username)) { owner.setUsername(username); } else if (ownername != null && !"""".equals(ownername)) { owner.setUsername(ownername); } owner.setUsername(ownerElement.getAttribute(""username"")); owner.setRealName(ownerElement.getAttribute(""realname"")); owner.setLocation(ownerElement.getAttribute(""location"")); photo.setOwner(owner); } } catch (IndexOutOfBoundsException e) { User owner = new User(); owner.setId(photoElement.getAttribute(""owner"")); owner.setUsername(photoElement.getAttribute(""ownername"")); photo.setOwner(owner); } try { photo.setTitle(XMLUtilities.getChildValue(photoElement, ""title"")); if (photo.getTitle() == null) { photo.setTitle(photoElement.getAttribute(""title"")); } } catch (IndexOutOfBoundsException e) { photo.setTitle(photoElement.getAttribute(""title"")); } try { photo.setDescription(XMLUtilities.getChildValue(photoElement, ""description"")); } catch (IndexOutOfBoundsException e) { } try { Element visibilityElement = (Element) photoElement.getElementsByTagName(""visibility"").item(0); photo.setPublicFlag(""1"".equals(visibilityElement.getAttribute(""ispublic""))); photo.setFriendFlag(""1"".equals(visibilityElement.getAttribute(""isfriend""))); photo.setFamilyFlag(""1"".equals(visibilityElement.getAttribute(""isfamily""))); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { photo.setPublicFlag(""1"".equals(photoElement.getAttribute(""ispublic""))); photo.setFriendFlag(""1"".equals(photoElement.getAttribute(""isfriend""))); photo.setFamilyFlag(""1"".equals(photoElement.getAttribute(""isfamily""))); } try { Element datesElement = XMLUtilities.getChild(photoElement, ""dates""); photo.setDatePosted(datesElement.getAttribute(""posted"")); photo.setDateTaken(datesElement.getAttribute(""taken"")); photo.setTakenGranularity(datesElement.getAttribute(""takengranularity"")); photo.setLastUpdate(datesElement.getAttribute(""lastupdate"")); } catch (IndexOutOfBoundsException e) { photo.setDateTaken(photoElement.getAttribute(""datetaken"")); } catch (NullPointerException e) { photo.setDateTaken(photoElement.getAttribute(""datetaken"")); } try { Element permissionsElement = (Element) photoElement.getElementsByTagName(""permissions"").item(0); Permissions permissions = new Permissions(); permissions.setComment(permissionsElement.getAttribute(""permcomment"")); permissions.setAddmeta(permissionsElement.getAttribute(""permaddmeta"")); photo.setPermissions(permissions); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { } try { Element editabilityElement = (Element) photoElement.getElementsByTagName(""editability"").item(0); Editability editability = new Editability(); editability.setComment(""1"".equals(editabilityElement.getAttribute(""cancomment""))); editability.setAddmeta(""1"".equals(editabilityElement.getAttribute(""canaddmeta""))); photo.setEditability(editability); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { } try { Element publicEditabilityElement = (Element) photoElement.getElementsByTagName(""publiceditability"").item(0); Editability publicEditability = new Editability(); publicEditability.setComment(""1"".equals(publicEditabilityElement.getAttribute(""cancomment""))); publicEditability.setAddmeta(""1"".equals(publicEditabilityElement.getAttribute(""canaddmeta""))); photo.setPublicEditability(publicEditability); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { } try { Element usageElement = (Element) photoElement.getElementsByTagName(""usage"").item(0); Usage usage = new Usage(); usage.setIsCanBlog(""1"".equals(usageElement.getAttribute(""canblog""))); usage.setIsCanDownload(""1"".equals(usageElement.getAttribute(""candownload""))); usage.setIsCanShare(""1"".equals(usageElement.getAttribute(""canshare""))); usage.setIsCanPrint(""1"".equals(usageElement.getAttribute(""canprint""))); photo.setUsage(usage); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { } try { Element commentsElement = (Element) photoElement.getElementsByTagName(""comments"").item(0); photo.setComments(((Text) commentsElement.getFirstChild()).getData()); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { } try { Element notesElement = (Element) photoElement.getElementsByTagName(""notes"").item(0); List<Note> notes = new ArrayList<Note>(); NodeList noteNodes = notesElement.getElementsByTagName(""note""); for (int i = 0; i < noteNodes.getLength(); i++) { Element noteElement = (Element) noteNodes.item(i); Note note = new Note(); note.setId(noteElement.getAttribute(""id"")); note.setAuthor(noteElement.getAttribute(""author"")); note.setAuthorName(noteElement.getAttribute(""authorname"")); note.setBounds(noteElement.getAttribute(""x""), noteElement.getAttribute(""y""), noteElement.getAttribute(""w""), noteElement.getAttribute(""h"")); note.setText(noteElement.getTextContent()); notes.add(note); } photo.setNotes(notes); } catch (IndexOutOfBoundsException e) { photo.setNotes(new ArrayList<Note>()); } catch (NullPointerException e) { photo.setNotes(new ArrayList<Note>()); } try { List<Tag> tags = new ArrayList<Tag>(); String tagsAttr = photoElement.getAttribute(""tags""); if (!tagsAttr.equals("""")) { String[] values = tagsAttr.split(""\\s+""); for (int i = 0; i < values.length; i++) { Tag tag = new Tag(); tag.setValue(values[i]); tags.add(tag); } } else { try { Element tagsElement = (Element) photoElement.getElementsByTagName(""tags"").item(0); NodeList tagNodes = tagsElement.getElementsByTagName(""tag""); for (int i = 0; i < tagNodes.getLength(); i++) { Element tagElement = (Element) tagNodes.item(i); Tag tag = new Tag(); tag.setId(tagElement.getAttribute(""id"")); tag.setAuthor(tagElement.getAttribute(""author"")); tag.setRaw(tagElement.getAttribute(""raw"")); tag.setValue(((Text) tagElement.getFirstChild()).getData()); tags.add(tag); } } catch (IndexOutOfBoundsException e) { } } photo.setTags(tags); } catch (NullPointerException e) { photo.setTags(new ArrayList<Tag>()); } try { Element urlsElement = (Element) photoElement.getElementsByTagName(""urls"").item(0); List<String> urls = new ArrayList<String>(); NodeList urlNodes = urlsElement.getElementsByTagName(""url""); for (int i = 0; i < urlNodes.getLength(); i++) { Element urlElement = (Element) urlNodes.item(i); PhotoUrl photoUrl = new PhotoUrl(); photo.setPhotoUrl(photoUrl); photoUrl.setType(urlElement.getAttribute(""type"")); photoUrl.setUrl(XMLUtilities.getValue(urlElement)); if (photoUrl.getType().equals(""photopage"")) { photo.setUrl(photoUrl.getUrl()); urls.add(photoUrl.getUrl()); } } photo.setUrls(urls); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { photo.setUrls(new ArrayList<String>()); } String longitude = null; String latitude = null; String accuracy = null; try { Element geoElement = (Element) photoElement.getElementsByTagName(""location"").item(0); longitude = geoElement.getAttribute(""longitude""); latitude = geoElement.getAttribute(""latitude""); accuracy = geoElement.getAttribute(""accuracy""); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { try { longitude = photoElement.getAttribute(""longitude""); latitude = photoElement.getAttribute(""latitude""); accuracy = photoElement.getAttribute(""accuracy""); } catch (NullPointerException e2) { } } if (longitude != null && latitude != null) { if (longitude.length() > 0 && latitude.length() > 0 && !(""0"".equals(longitude) && ""0"".equals(latitude))) { photo.setGeoData(new GeoData(longitude, latitude, accuracy)); } } try { Place place = null; Element element = (Element) photoElement.getElementsByTagName(""locality"").item(0); place = new Place(element.getAttribute(""place_id""), element.getTextContent(), element.getAttribute(""woeid"")); photo.setLocality(place); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { } try { Place place = null; Element element = (Element) photoElement.getElementsByTagName(""county"").item(0); place = new Place(element.getAttribute(""place_id""), element.getTextContent(), element.getAttribute(""woeid"")); photo.setCounty(place); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { } try { Place place = null; Element element = (Element) photoElement.getElementsByTagName(""region"").item(0); place = new Place(element.getAttribute(""place_id""), element.getTextContent(), element.getAttribute(""woeid"")); photo.setRegion(place); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { } try { Place place = null; Element element = (Element) photoElement.getElementsByTagName(""country"").item(0); place = new Place(element.getAttribute(""place_id""), element.getTextContent(), element.getAttribute(""woeid"")); photo.setCountry(place); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { } try { Stats stats = new Stats(); ; stats.setFavorites(photoElement.getAttribute(""count_faves"")); stats.setComments(photoElement.getAttribute(""count_comments"")); stats.setViews(photoElement.getAttribute(""count_views"")); photo.setStats(stats); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { } return photo; } public static final PhotoList<Photo> createPhotoList(Element photosElement) { PhotoList<Photo> photos = new PhotoList<Photo>(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } } ","package com.flickr4java.flickr.photos;  import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.places.Place; import com.flickr4java.flickr.stats.Stats; import com.flickr4java.flickr.tags.Tag; import com.flickr4java.flickr.util.XMLUtilities;  import org.w3c.dom.Element; import org.w3c.dom.NodeList; import org.w3c.dom.Text;  import java.util.ArrayList; import java.util.List;  /**
 * Utilitiy-methods to transfer requested XML to Photo-objects.
 * 
 * @author till, x-mago
 * @version $Id: PhotoUtils.java,v 1.20 2009/07/23 21:49:35 x-mago Exp $
 */ public final class PhotoUtils {  private PhotoUtils() { }  /**
     * Try to get an attribute value from two elements.
     * 
     * @param firstElement
     * @param secondElement
     * @return attribute value
     */ private static String getAttribute(String name, Element firstElement, Element secondElement) { String val = firstElement.getAttribute(name); if (val.length() == 0 && secondElement != null) { val = secondElement.getAttribute(name); } return val; }  /**
     * Transfer the Information of a photo from a DOM-object to a Photo-object.
     * 
     * @param photoElement
     * @return Photo
     */ public static final Photo createPhoto(Element photoElement) { return createPhoto(photoElement, null); }  /**
     * Transfer the Information of a photo from a DOM-object to a Photo-object.
     * 
     * @param photoElement
     * @param defaultElement
     * @return Photo
     */ public static final Photo createPhoto(Element photoElement, Element defaultElement) { Photo photo = new Photo(); photo.setId(photoElement.getAttribute(""id"")); photo.setPlaceId(photoElement.getAttribute(""place_id"")); photo.setSecret(photoElement.getAttribute(""secret"")); photo.setServer(photoElement.getAttribute(""server"")); photo.setFarm(photoElement.getAttribute(""farm"")); photo.setRotation(photoElement.getAttribute(""rotation"")); photo.setFavorite(""1"".equals(photoElement.getAttribute(""isfavorite""))); photo.setLicense(photoElement.getAttribute(""license"")); photo.setOriginalFormat(photoElement.getAttribute(""originalformat"")); photo.setOriginalSecret(photoElement.getAttribute(""originalsecret"")); photo.setIconServer(photoElement.getAttribute(""iconserver"")); photo.setIconFarm(photoElement.getAttribute(""iconfarm"")); photo.setDateTaken(photoElement.getAttribute(""datetaken"")); photo.setDatePosted(photoElement.getAttribute(""dateupload"")); photo.setLastUpdate(photoElement.getAttribute(""lastupdate"")); // flickr.groups.pools.getPhotos provides this value! photo.setDateAdded(photoElement.getAttribute(""dateadded"")); photo.setOriginalWidth(photoElement.getAttribute(""width_o"")); photo.setOriginalHeight(photoElement.getAttribute(""height_o"")); photo.setMedia(photoElement.getAttribute(""media"")); photo.setMediaStatus(photoElement.getAttribute(""media_status"")); photo.setPathAlias(photoElement.getAttribute(""pathalias"")); photo.setViews(photoElement.getAttribute(""views""));  Element peopleElement = (Element) photoElement.getElementsByTagName(""people"").item(0); if (peopleElement != null) { photo.setIsHasPeople(""1"".equals(peopleElement.getAttribute(""haspeople""))); } else { photo.setIsHasPeople(false); }  // If the attributes active that contain the image-urls, // Size-objects created from them, which are used to override // the Url-generation. List<Size> sizes = new ArrayList<Size>(); String urlTmp = photoElement.getAttribute(""url_t""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.THUMB); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_t"")); sizeT.setHeight(photoElement.getAttribute(""height_t"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_s""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.SMALL); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_s"")); sizeT.setHeight(photoElement.getAttribute(""height_s"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_sq""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.SQUARE); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_sq"")); sizeT.setHeight(photoElement.getAttribute(""height_sq"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_m""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.MEDIUM); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_m"")); sizeT.setHeight(photoElement.getAttribute(""height_m"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_l""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.LARGE); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_l"")); sizeT.setHeight(photoElement.getAttribute(""height_l"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_o""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.ORIGINAL); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_o"")); sizeT.setHeight(photoElement.getAttribute(""height_o"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_q""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.SQUARE_LARGE); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_q"")); sizeT.setHeight(photoElement.getAttribute(""height_q"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_n""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.SMALL_320); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_n"")); sizeT.setHeight(photoElement.getAttribute(""height_n"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_z""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.MEDIUM_640); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_z"")); sizeT.setHeight(photoElement.getAttribute(""height_z"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_c""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.MEDIUM_800); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_c"")); sizeT.setHeight(photoElement.getAttribute(""height_c"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_h""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.LARGE_1600); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_h"")); sizeT.setHeight(photoElement.getAttribute(""height_h"")); sizes.add(sizeT); } urlTmp = photoElement.getAttribute(""url_k""); if (urlTmp != null && urlTmp.startsWith(""http"")) { Size sizeT = new Size(); sizeT.setLabel(Size.LARGE_2048); sizeT.setSource(urlTmp); sizeT.setWidth(photoElement.getAttribute(""width_k"")); sizeT.setHeight(photoElement.getAttribute(""height_k"")); sizes.add(sizeT); } if (sizes.size() > 0) { photo.setSizes(sizes); }  // Searches, or other list may contain orginal_format. // If not choosen via extras, set jpg as default. try { if (photo.getOriginalFormat() == null || photo.getOriginalFormat().equals("""")) { String media = photo.getMedia(); if (media != null && media.equals(""video""))
                    photo.setOriginalFormat(""mov""); // Currently flickr incorrectly returns original_format as jpg for movies. else
                    photo.setOriginalFormat(""jpg""); } } catch (NullPointerException e) { photo.setOriginalFormat(""jpg""); }  try { Element ownerElement = (Element) photoElement.getElementsByTagName(""owner"").item(0); if (ownerElement == null) { User owner = new User(); owner.setId(getAttribute(""owner"", photoElement, defaultElement)); owner.setUsername(getAttribute(""ownername"", photoElement, defaultElement)); photo.setOwner(owner); //flickr.com/photos/"" + owner.getId() + ""/"" + photo.getId()); } else { User owner = new User(); owner.setId(ownerElement.getAttribute(""nsid""));  String username = ownerElement.getAttribute(""username""); String ownername = ownerElement.getAttribute(""ownername""); // try to get the username either from the ""username"" attribute or // from the ""ownername"" attribute if (username != null && !"""".equals(username)) { owner.setUsername(username); } else if (ownername != null && !"""".equals(ownername)) { owner.setUsername(ownername); }  owner.setUsername(ownerElement.getAttribute(""username"")); owner.setRealName(ownerElement.getAttribute(""realname"")); owner.setLocation(ownerElement.getAttribute(""location"")); photo.setOwner(owner); //flickr.com/photos/"" + owner.getId() + ""/"" + photo.getId()); } } catch (IndexOutOfBoundsException e) { User owner = new User(); owner.setId(photoElement.getAttribute(""owner"")); owner.setUsername(photoElement.getAttribute(""ownername"")); photo.setOwner(owner); //flickr.com/photos/"" + owner.getId() + ""/"" + photo.getId()); }  try { photo.setTitle(XMLUtilities.getChildValue(photoElement, ""title"")); if (photo.getTitle() == null) { photo.setTitle(photoElement.getAttribute(""title"")); } } catch (IndexOutOfBoundsException e) { photo.setTitle(photoElement.getAttribute(""title"")); }  try { photo.setDescription(XMLUtilities.getChildValue(photoElement, ""description"")); } catch (IndexOutOfBoundsException e) { }  try { // here the flags are set, if the photo is read by getInfo(). Element visibilityElement = (Element) photoElement.getElementsByTagName(""visibility"").item(0); photo.setPublicFlag(""1"".equals(visibilityElement.getAttribute(""ispublic""))); photo.setFriendFlag(""1"".equals(visibilityElement.getAttribute(""isfriend""))); photo.setFamilyFlag(""1"".equals(visibilityElement.getAttribute(""isfamily""))); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { // these flags are set here, if photos read from a list. photo.setPublicFlag(""1"".equals(photoElement.getAttribute(""ispublic""))); photo.setFriendFlag(""1"".equals(photoElement.getAttribute(""isfriend""))); photo.setFamilyFlag(""1"".equals(photoElement.getAttribute(""isfamily""))); }  // Parse either photo by getInfo, or from list try { Element datesElement = XMLUtilities.getChild(photoElement, ""dates""); photo.setDatePosted(datesElement.getAttribute(""posted"")); photo.setDateTaken(datesElement.getAttribute(""taken"")); photo.setTakenGranularity(datesElement.getAttribute(""takengranularity"")); photo.setLastUpdate(datesElement.getAttribute(""lastupdate"")); } catch (IndexOutOfBoundsException e) { photo.setDateTaken(photoElement.getAttribute(""datetaken"")); } catch (NullPointerException e) { photo.setDateTaken(photoElement.getAttribute(""datetaken"")); }  try { Element permissionsElement = (Element) photoElement.getElementsByTagName(""permissions"").item(0); Permissions permissions = new Permissions(); permissions.setComment(permissionsElement.getAttribute(""permcomment"")); permissions.setAddmeta(permissionsElement.getAttribute(""permaddmeta"")); photo.setPermissions(permissions); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { // nop }  try { Element editabilityElement = (Element) photoElement.getElementsByTagName(""editability"").item(0); Editability editability = new Editability(); editability.setComment(""1"".equals(editabilityElement.getAttribute(""cancomment""))); editability.setAddmeta(""1"".equals(editabilityElement.getAttribute(""canaddmeta""))); photo.setEditability(editability); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { // nop }  try { Element publicEditabilityElement = (Element) photoElement.getElementsByTagName(""publiceditability"").item(0); Editability publicEditability = new Editability(); publicEditability.setComment(""1"".equals(publicEditabilityElement.getAttribute(""cancomment""))); publicEditability.setAddmeta(""1"".equals(publicEditabilityElement.getAttribute(""canaddmeta""))); photo.setPublicEditability(publicEditability); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { // nop }  try { Element usageElement = (Element) photoElement.getElementsByTagName(""usage"").item(0); Usage usage = new Usage();  usage.setIsCanBlog(""1"".equals(usageElement.getAttribute(""canblog""))); usage.setIsCanDownload(""1"".equals(usageElement.getAttribute(""candownload""))); usage.setIsCanShare(""1"".equals(usageElement.getAttribute(""canshare""))); usage.setIsCanPrint(""1"".equals(usageElement.getAttribute(""canprint""))); photo.setUsage(usage); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { // nop }  try { Element commentsElement = (Element) photoElement.getElementsByTagName(""comments"").item(0); photo.setComments(((Text) commentsElement.getFirstChild()).getData()); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { // nop }  try { Element notesElement = (Element) photoElement.getElementsByTagName(""notes"").item(0); List<Note> notes = new ArrayList<Note>(); NodeList noteNodes = notesElement.getElementsByTagName(""note""); for (int i = 0; i < noteNodes.getLength(); i++) { Element noteElement = (Element) noteNodes.item(i); Note note = new Note(); note.setId(noteElement.getAttribute(""id"")); note.setAuthor(noteElement.getAttribute(""author"")); note.setAuthorName(noteElement.getAttribute(""authorname"")); note.setBounds(noteElement.getAttribute(""x""), noteElement.getAttribute(""y""), noteElement.getAttribute(""w""), noteElement.getAttribute(""h"")); note.setText(noteElement.getTextContent()); notes.add(note); } photo.setNotes(notes); } catch (IndexOutOfBoundsException e) { photo.setNotes(new ArrayList<Note>()); } catch (NullPointerException e) { photo.setNotes(new ArrayList<Note>()); }  // Tags coming as space-seperated attribute calling // InterestingnessInterface#getList(). // Through PhotoInterface#getInfo() the Photo has a list of // Elements. try { List<Tag> tags = new ArrayList<Tag>(); String tagsAttr = photoElement.getAttribute(""tags""); if (!tagsAttr.equals("""")) { String[] values = tagsAttr.split(""\\s+""); for (int i = 0; i < values.length; i++) { Tag tag = new Tag(); tag.setValue(values[i]); tags.add(tag); } } else { try { Element tagsElement = (Element) photoElement.getElementsByTagName(""tags"").item(0); NodeList tagNodes = tagsElement.getElementsByTagName(""tag""); for (int i = 0; i < tagNodes.getLength(); i++) { Element tagElement = (Element) tagNodes.item(i); Tag tag = new Tag(); tag.setId(tagElement.getAttribute(""id"")); tag.setAuthor(tagElement.getAttribute(""author"")); tag.setRaw(tagElement.getAttribute(""raw"")); tag.setValue(((Text) tagElement.getFirstChild()).getData()); tags.add(tag); } } catch (IndexOutOfBoundsException e) { } } photo.setTags(tags); } catch (NullPointerException e) { photo.setTags(new ArrayList<Tag>()); }  try { Element urlsElement = (Element) photoElement.getElementsByTagName(""urls"").item(0); List<String> urls = new ArrayList<String>(); NodeList urlNodes = urlsElement.getElementsByTagName(""url""); for (int i = 0; i < urlNodes.getLength(); i++) { Element urlElement = (Element) urlNodes.item(i); PhotoUrl photoUrl = new PhotoUrl(); photo.setPhotoUrl(photoUrl); photoUrl.setType(urlElement.getAttribute(""type"")); photoUrl.setUrl(XMLUtilities.getValue(urlElement)); if (photoUrl.getType().equals(""photopage"")) { photo.setUrl(photoUrl.getUrl()); urls.add(photoUrl.getUrl()); }  }  photo.setUrls(urls); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { photo.setUrls(new ArrayList<String>()); }  String longitude = null; String latitude = null; String accuracy = null; try { Element geoElement = (Element) photoElement.getElementsByTagName(""location"").item(0); longitude = geoElement.getAttribute(""longitude""); latitude = geoElement.getAttribute(""latitude""); accuracy = geoElement.getAttribute(""accuracy""); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { // Geodata may be available as attributes in the photo-tag itself! try { longitude = photoElement.getAttribute(""longitude""); latitude = photoElement.getAttribute(""latitude""); accuracy = photoElement.getAttribute(""accuracy""); } catch (NullPointerException e2) { // no geodata at all } } if (longitude != null && latitude != null) { if (longitude.length() > 0 && latitude.length() > 0 && !(""0"".equals(longitude) && ""0"".equals(latitude))) { photo.setGeoData(new GeoData(longitude, latitude, accuracy)); } }  try { Place place = null; Element element = (Element) photoElement.getElementsByTagName(""locality"").item(0); place = new Place(element.getAttribute(""place_id""), element.getTextContent(), element.getAttribute(""woeid"")); photo.setLocality(place); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { }  try { Place place = null; Element element = (Element) photoElement.getElementsByTagName(""county"").item(0); place = new Place(element.getAttribute(""place_id""), element.getTextContent(), element.getAttribute(""woeid"")); photo.setCounty(place); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { }  try { Place place = null; Element element = (Element) photoElement.getElementsByTagName(""region"").item(0); place = new Place(element.getAttribute(""place_id""), element.getTextContent(), element.getAttribute(""woeid"")); photo.setRegion(place); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { }  try { Place place = null; Element element = (Element) photoElement.getElementsByTagName(""country"").item(0); place = new Place(element.getAttribute(""place_id""), element.getTextContent(), element.getAttribute(""woeid"")); photo.setCountry(place); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { }          //set stats from extras (count_faves,count_comments,count_views) try { Stats stats = new Stats(); ; stats.setFavorites(photoElement.getAttribute(""count_faves"")); stats.setComments(photoElement.getAttribute(""count_comments"")); stats.setViews(photoElement.getAttribute(""count_views"")); photo.setStats(stats); } catch (IndexOutOfBoundsException e) { } catch (NullPointerException e) { }  return photo; }  /**
     * Parse a list of Photos from given Element.
     * 
     * @param photosElement
     * @return PhotoList
     */ public static final PhotoList<Photo> createPhotoList(Element photosElement) { PhotoList<Photo> photos = new PhotoList<Photo>(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total""));  NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; }  }  "
src/main/java/com/flickr4java/flickr/photos/Photocount.java,"
package com.flickr4java.flickr.photos;

import java.util.Date;

/**
 * @author Anthony Eden
 */
public class Photocount {

    private int count;

    private Date fromDate;

    private Date toDate;

    public Photocount() {

    }

    public int getCount() {
        return count;
    }

    public void setCount(int count) {
        this.count = count;
    }

    public void setCount(String count) {
        if (count != null)
            setCount(Integer.parseInt(count));
    }

    public Date getFromDate() {
        return fromDate;
    }

    public void setFromDate(Date fromDate) {
        this.fromDate = fromDate;
    }

    public void setFromDate(long fromDate) {
        setFromDate(new Date(fromDate));
    }

    public void setFromDate(String fromDate) {
        if (fromDate != null)
            setFromDate(Long.parseLong(fromDate));
    }

    public Date getToDate() {
        return toDate;
    }

    public void setToDate(Date toDate) {
        this.toDate = toDate;
    }

    public void setToDate(long toDate) {
        setToDate(new Date(toDate));
    }

    public void setToDate(String toDate) {
        if (toDate != null)
            setToDate(Long.parseLong(toDate));
    }

}
","package com.flickr4java.flickr.photos; import java.util.Date; public class Photocount { private int count; private Date fromDate; private Date toDate; public Photocount() { } public int getCount() { return count; } public void setCount(int count) { this.count = count; } public void setCount(String count) { if (count != null)
            setCount(Integer.parseInt(count)); } public Date getFromDate() { return fromDate; } public void setFromDate(Date fromDate) { this.fromDate = fromDate; } public void setFromDate(long fromDate) { setFromDate(new Date(fromDate)); } public void setFromDate(String fromDate) { if (fromDate != null)
            setFromDate(Long.parseLong(fromDate)); } public Date getToDate() { return toDate; } public void setToDate(Date toDate) { this.toDate = toDate; } public void setToDate(long toDate) { setToDate(new Date(toDate)); } public void setToDate(String toDate) { if (toDate != null)
            setToDate(Long.parseLong(toDate)); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.photos; import java.util.Date; public class Photocount { private int count; private Date fromDate; private Date toDate; public Photocount() { } public int getCount() { return count; } public void setCount(int count) { this.count = count; } public void setCount(String count) { if (count != null)
            setCount(Integer.parseInt(count)); } public Date getFromDate() { return fromDate; } public void setFromDate(Date fromDate) { this.fromDate = fromDate; } public void setFromDate(long fromDate) { setFromDate(new Date(fromDate)); } public void setFromDate(String fromDate) { if (fromDate != null)
            setFromDate(Long.parseLong(fromDate)); } public Date getToDate() { return toDate; } public void setToDate(Date toDate) { this.toDate = toDate; } public void setToDate(long toDate) { setToDate(new Date(toDate)); } public void setToDate(String toDate) { if (toDate != null)
            setToDate(Long.parseLong(toDate)); } } "," package com.flickr4java.flickr.photos;  import java.util.Date;  /**
 * @author Anthony Eden
 */ public class Photocount {  private int count;  private Date fromDate;  private Date toDate;  public Photocount() {  }  public int getCount() { return count; }  public void setCount(int count) { this.count = count; }  public void setCount(String count) { if (count != null)
            setCount(Integer.parseInt(count)); }  public Date getFromDate() { return fromDate; }  public void setFromDate(Date fromDate) { this.fromDate = fromDate; }  public void setFromDate(long fromDate) { setFromDate(new Date(fromDate)); }  public void setFromDate(String fromDate) { if (fromDate != null)
            setFromDate(Long.parseLong(fromDate)); }  public Date getToDate() { return toDate; }  public void setToDate(Date toDate) { this.toDate = toDate; }  public void setToDate(long toDate) { setToDate(new Date(toDate)); }  public void setToDate(String toDate) { if (toDate != null)
            setToDate(Long.parseLong(toDate)); }  }  "
src/main/java/com/flickr4java/flickr/photos/PhotosInterface.java,"
package com.flickr4java.flickr.photos;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.REST;
import com.flickr4java.flickr.RequestContext;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.people.User;
import com.flickr4java.flickr.photos.geo.GeoInterface;
import com.flickr4java.flickr.util.IOUtilities;
import com.flickr4java.flickr.util.StringUtilities;
import com.flickr4java.flickr.util.XMLUtilities;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import javax.imageio.ImageIO;
import javax.net.ssl.HttpsURLConnection;

import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Interface for working with Flickr Photos.
 * 
 * @author Anthony Eden
 * @version $Id: PhotosInterface.java,v 1.51 2010/07/20 20:11:16 x-mago Exp $
 */
public class PhotosInterface {

    public static final String METHOD_ADD_TAGS = ""flickr.photos.addTags"";

    public static final String METHOD_DELETE = ""flickr.photos.delete"";

    public static final String METHOD_GET_ALL_CONTEXTS = ""flickr.photos.getAllContexts"";

    public static final String METHOD_GET_CONTACTS_PHOTOS = ""flickr.photos.getContactsPhotos"";

    public static final String METHOD_GET_CONTACTS_PUBLIC_PHOTOS = ""flickr.photos.getContactsPublicPhotos"";

    public static final String METHOD_GET_CONTEXT = ""flickr.photos.getContext"";

    public static final String METHOD_GET_COUNTS = ""flickr.photos.getCounts"";

    public static final String METHOD_GET_EXIF = ""flickr.photos.getExif"";

    public static final String METHOD_GET_FAVORITES = ""flickr.photos.getFavorites"";

    public static final String METHOD_GET_INFO = ""flickr.photos.getInfo"";

    public static final String METHOD_GET_NOT_IN_SET = ""flickr.photos.getNotInSet"";

    public static final String METHOD_GET_PERMS = ""flickr.photos.getPerms"";

    public static final String METHOD_GET_RECENT = ""flickr.photos.getRecent"";

    public static final String METHOD_GET_SIZES = ""flickr.photos.getSizes"";

    public static final String METHOD_GET_UNTAGGED = ""flickr.photos.getUntagged"";

    public static final String METHOD_GET_WITH_GEO_DATA = ""flickr.photos.getWithGeoData"";

    public static final String METHOD_GET_WITHOUT_GEO_DATA = ""flickr.photos.getWithoutGeoData"";

    public static final String METHOD_RECENTLY_UPDATED = ""flickr.photos.recentlyUpdated"";

    public static final String METHOD_REMOVE_TAG = ""flickr.photos.removeTag"";

    public static final String METHOD_SEARCH = ""flickr.photos.search"";

    public static final String METHOD_SET_CONTENTTYPE = ""flickr.photos.setContentType"";

    public static final String METHOD_SET_DATES = ""flickr.photos.setDates"";

    public static final String METHOD_SET_META = ""flickr.photos.setMeta"";

    public static final String METHOD_SET_PERMS = ""flickr.photos.setPerms"";

    public static final String METHOD_SET_SAFETYLEVEL = ""flickr.photos.setSafetyLevel"";

    public static final String METHOD_SET_TAGS = ""flickr.photos.setTags"";

    public static final String METHOD_GET_INTERESTINGNESS = ""flickr.interestingness.getList"";

    private static final ThreadLocal<SimpleDateFormat> DATE_FORMATS = new ThreadLocal<SimpleDateFormat>() {
        @Override
        protected synchronized SimpleDateFormat initialValue() {
            return new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
        }
    };

    private GeoInterface geoInterface = null;

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transport;

    public PhotosInterface(String apiKey, String sharedSecret, Transport transport) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transport = transport;
    }

    /**
     * Get the geo interface.
     * 
     * @return Access class to the flickr.photos.geo methods.
     */
    public synchronized GeoInterface getGeoInterface() {
        if (geoInterface == null) {
            geoInterface = new GeoInterface(apiKey, sharedSecret, transport);
        }
        return geoInterface;
    }

    /**
     * Add tags to a photo.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param photoId
     *            The photo ID
     * @param tags
     *            The tags
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void addTags(String photoId, String[] tags) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_ADD_TAGS);

        parameters.put(""photo_id"", photoId);
        parameters.put(""tags"", StringUtilities.join(tags, "" "", true));

        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Delete a photo from flickr.
     * 
     * This method requires authentication with 'delete' permission.
     * 
     * @param photoId
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void delete(String photoId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_DELETE);

        parameters.put(""photo_id"", photoId);

        // Note: This method requires an HTTP POST request.
        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        // This method has no specific response - It returns an empty
        // sucess response if it completes without error.
    }

    /**
     * Returns all visble sets and pools the photo belongs to.
     * 
     * This method does not require authentication.
     * 
     * @param photoId
     *            The photo to return information for.
     * @return a list of {@link PhotoContext} objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PhotoAllContext getAllContexts(String photoId) throws FlickrException {
        PhotoSetList<PhotoSet> setList = new PhotoSetList<PhotoSet>();
        PoolList<Pool> poolList = new PoolList<Pool>();
        PhotoAllContext allContext = new PhotoAllContext();

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_ALL_CONTEXTS);

        parameters.put(""photo_id"", photoId);

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Collection<Element> photosElement = response.getPayloadCollection();

        for (Element setElement : photosElement) {
            if (setElement.getTagName().equals(""set"")) {
                PhotoSet pset = new PhotoSet();
                pset.setTitle(setElement.getAttribute(""title""));
                pset.setSecret(setElement.getAttribute(""secret""));
                pset.setId(setElement.getAttribute(""id""));
                pset.setFarm(setElement.getAttribute(""farm""));
                pset.setPrimary(setElement.getAttribute(""primary""));
                pset.setServer(setElement.getAttribute(""server""));
                pset.setViewCount(Integer.parseInt(setElement.getAttribute(""view_count"")));
                pset.setCommentCount(Integer.parseInt(setElement.getAttribute(""comment_count"")));
                pset.setCountPhoto(Integer.parseInt(setElement.getAttribute(""count_photo"")));
                pset.setCountVideo(Integer.parseInt(setElement.getAttribute(""count_video"")));
                setList.add(pset);
                allContext.setPhotoSetList(setList);
            } else if (setElement.getTagName().equals(""pool"")) {
                Pool pool = new Pool();
                pool.setTitle(setElement.getAttribute(""title""));
                pool.setId(setElement.getAttribute(""id""));
                pool.setUrl(setElement.getAttribute(""url""));
                pool.setIconServer(setElement.getAttribute(""iconserver""));
                pool.setIconFarm(setElement.getAttribute(""iconfarm""));
                pool.setMemberCount(Integer.parseInt(setElement.getAttribute(""members"")));
                pool.setPoolCount(Integer.parseInt(setElement.getAttribute(""pool_count"")));
                poolList.add(pool);
                allContext.setPoolList(poolList);
            }
        }

        return allContext;

    }

    /**
     * Get photos from the user's contacts.
     * 
     * This method requires authentication with 'read' permission.
     * 
     * @param count
     *            The number of photos to return
     * @param justFriends
     *            Set to true to only show friends photos
     * @param singlePhoto
     *            Set to true to get a single photo
     * @param includeSelf
     *            Set to true to include self
     * @return The Collection of photos
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PhotoList<Photo> getContactsPhotos(int count, boolean justFriends, boolean singlePhoto, boolean includeSelf) throws FlickrException {
        PhotoList<Photo> photos = new PhotoList<Photo>();

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_CONTACTS_PHOTOS);

        if (count > 0) {
            parameters.put(""count"", Integer.toString(count));
        }
        if (justFriends) {
            parameters.put(""just_friends"", ""1"");
        }
        if (singlePhoto) {
            parameters.put(""single_photo"", ""1"");
        }
        if (includeSelf) {
            parameters.put(""include_self"", ""1"");
        }

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element photosElement = response.getPayload();
        NodeList photoNodes = photosElement.getElementsByTagName(""photo"");
        photos.setPage(""1"");
        photos.setPages(""1"");
        photos.setPerPage("""" + photoNodes.getLength());
        photos.setTotal("""" + photoNodes.getLength());
        for (int i = 0; i < photoNodes.getLength(); i++) {
            Element photoElement = (Element) photoNodes.item(i);
            photos.add(PhotoUtils.createPhoto(photoElement));
        }
        return photos;
    }

    /**
     * Get public photos from the user's contacts.
     * 
     * This method does not require authentication.
     * 
     * @see com.flickr4java.flickr.photos.Extras
     * @param userId
     *            The user ID
     * @param count
     *            The number of photos to return
     * @param justFriends
     *            True to include friends
     * @param singlePhoto
     *            True to get a single photo
     * @param includeSelf
     *            True to include self
     * @return A collection of Photo objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PhotoList<Photo> getContactsPublicPhotos(String userId, int count, boolean justFriends, boolean singlePhoto, boolean includeSelf)
            throws FlickrException {
        return getContactsPublicPhotos(userId, Extras.MIN_EXTRAS, count, justFriends, singlePhoto, includeSelf);
    }

    public PhotoList<Photo> getContactsPublicPhotos(String userId, Set<String> extras, int count, boolean justFriends, boolean singlePhoto, boolean includeSelf)
            throws FlickrException {
        PhotoList<Photo> photos = new PhotoList<Photo>();

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_CONTACTS_PUBLIC_PHOTOS);

        parameters.put(""user_id"", userId);

        if (count > 0) {
            parameters.put(""count"", Integer.toString(count));
        }
        if (justFriends) {
            parameters.put(""just_friends"", ""1"");
        }
        if (singlePhoto) {
            parameters.put(""single_photo"", ""1"");
        }
        if (includeSelf) {
            parameters.put(""include_self"", ""1"");
        }

        if (extras != null) {
            StringBuffer sb = new StringBuffer();
            Iterator<String> it = extras.iterator();
            for (int i = 0; it.hasNext(); i++) {
                if (i > 0) {
                    sb.append("","");
                }
                sb.append(it.next());
            }
            parameters.put(Extras.KEY_EXTRAS, sb.toString());
        }

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element photosElement = response.getPayload();
        NodeList photoNodes = photosElement.getElementsByTagName(""photo"");
        photos.setPage(""1"");
        photos.setPages(""1"");
        photos.setPerPage("""" + photoNodes.getLength());
        photos.setTotal("""" + photoNodes.getLength());
        for (int i = 0; i < photoNodes.getLength(); i++) {
            Element photoElement = (Element) photoNodes.item(i);
            photos.add(PhotoUtils.createPhoto(photoElement));
        }
        return photos;
    }

    /**
     * Get the context for the specified photo.
     * 
     * This method does not require authentication.
     * 
     * @param photoId
     *            The photo ID
     * @return The PhotoContext
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PhotoContext getContext(String photoId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_CONTEXT);

        parameters.put(""photo_id"", photoId);

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        PhotoContext photoContext = new PhotoContext();
        Collection<Element> payload = response.getPayloadCollection();
        for (Element payloadElement : payload) {
            String tagName = payloadElement.getTagName();
            if (tagName.equals(""prevphoto"")) {
                Photo photo = new Photo();
                photo.setId(payloadElement.getAttribute(""id""));
                photo.setSecret(payloadElement.getAttribute(""secret""));
                photo.setTitle(payloadElement.getAttribute(""title""));
                photo.setFarm(payloadElement.getAttribute(""farm""));
                photo.setUrl(payloadElement.getAttribute(""url""));
                photoContext.setPreviousPhoto(photo);
            } else if (tagName.equals(""nextphoto"")) {
                Photo photo = new Photo();
                photo.setId(payloadElement.getAttribute(""id""));
                photo.setSecret(payloadElement.getAttribute(""secret""));
                photo.setTitle(payloadElement.getAttribute(""title""));
                photo.setFarm(payloadElement.getAttribute(""farm""));
                photo.setUrl(payloadElement.getAttribute(""url""));
                photoContext.setNextPhoto(photo);
            }
        }
        return photoContext;
    }

    /**
     * Gets a collection of photo counts for the given date ranges for the calling user.
     * 
     * This method requires authentication with 'read' permission.
     * 
     * @param dates
     *            An array of dates, denoting the periods to return counts for. They should be specified smallest first.
     * @param takenDates
     *            An array of dates, denoting the periods to return counts for. They should be specified smallest first.
     * @return A Collection of Photocount objects
     */
    public Collection<Photocount> getCounts(Date[] dates, Date[] takenDates) throws FlickrException {
        List<Photocount> photocounts = new ArrayList<Photocount>();

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_COUNTS);

        if (dates == null && takenDates == null) {
            throw new IllegalArgumentException(""You must provide a value for either dates or takenDates"");
        }

        if (dates != null) {
            List<String> dateList = new ArrayList<String>();
            for (int i = 0; i < dates.length; i++) {
                dateList.add(String.valueOf(dates[i].getTime() / 1000L));
            }
            parameters.put(""dates"", StringUtilities.join(dateList, "",""));
        }

        if (takenDates != null) {
            List<String> takenDateList = new ArrayList<String>();
            for (int i = 0; i < takenDates.length; i++) {
                takenDateList.add(String.valueOf(takenDates[i].getTime() / 1000L));
            }
            parameters.put(""taken_dates"", StringUtilities.join(takenDateList, "",""));
        }

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element photocountsElement = response.getPayload();
        NodeList photocountNodes = photocountsElement.getElementsByTagName(""photocount"");
        for (int i = 0; i < photocountNodes.getLength(); i++) {
            Element photocountElement = (Element) photocountNodes.item(i);
            Photocount photocount = new Photocount();
            photocount.setCount(photocountElement.getAttribute(""count""));
            photocount.setFromDate(photocountElement.getAttribute(""fromdate""));
            photocount.setToDate(photocountElement.getAttribute(""todate""));
            photocounts.add(photocount);
        }
        return photocounts;
    }

    /**
     * Get the Exif data for the photo.
     * 
     * The calling user must have permission to view the photo.
     * 
     * This method does not require authentication.
     * 
     * @param photoId
     *            The photo ID
     * @param secret
     *            The secret
     * @return A collection of Exif objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Collection<Exif> getExif(String photoId, String secret) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_EXIF);

        parameters.put(""photo_id"", photoId);
        if (secret != null) {
            parameters.put(""secret"", secret);
        }

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        List<Exif> exifs = new ArrayList<Exif>();
        Element photoElement = response.getPayload();
        NodeList exifElements = photoElement.getElementsByTagName(""exif"");
        for (int i = 0; i < exifElements.getLength(); i++) {
            Element exifElement = (Element) exifElements.item(i);
            Exif exif = new Exif();
            exif.setTagspace(exifElement.getAttribute(""tagspace""));
            exif.setTagspaceId(exifElement.getAttribute(""tagspaceid""));
            exif.setTag(exifElement.getAttribute(""tag""));
            exif.setLabel(exifElement.getAttribute(""label""));
            exif.setRaw(XMLUtilities.getChildValue(exifElement, ""raw""));
            exif.setClean(XMLUtilities.getChildValue(exifElement, ""clean""));
            exifs.add(exif);
        }
        return exifs;
    }

    /**
     * Returns the list of people who have favorited a given photo.
     * 
     * This method does not require authentication.
     * 
     * @param photoId
     * @param perPage
     * @param page
     * @return List of {@link com.flickr4java.flickr.people.User}
     */
    public Collection<User> getFavorites(String photoId, int perPage, int page) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();

        parameters.put(""method"", METHOD_GET_FAVORITES);

        parameters.put(""photo_id"", photoId);

        if (perPage > 0) {
            parameters.put(""per_page"", Integer.toString(perPage));
        }

        if (page > 0) {
            parameters.put(""page"", Integer.toString(page));
        }

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        List<User> users = new ArrayList<User>();

        Element userRoot = response.getPayload();
        NodeList userNodes = userRoot.getElementsByTagName(""person"");
        for (int i = 0; i < userNodes.getLength(); i++) {
            Element userElement = (Element) userNodes.item(i);
            User user = new User();
            user.setId(userElement.getAttribute(""nsid""));
            user.setUsername(userElement.getAttribute(""username""));
            user.setFaveDate(userElement.getAttribute(""favedate""));
            users.add(user);
        }
        return users;
    }

    /**
     * Get all info for the specified photo.
     * 
     * The calling user must have permission to view the photo.
     * 
     * This method does not require authentication.
     * 
     * @param photoId
     *            The photo Id
     * @param secret
     *            The optional secret String
     * @return The Photo
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Photo getInfo(String photoId, String secret) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_INFO);

        parameters.put(""photo_id"", photoId);
        if (secret != null) {
            parameters.put(""secret"", secret);
        }

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element photoElement = response.getPayload();

        return PhotoUtils.createPhoto(photoElement);
    }

    /**
     * Return a collection of Photo objects not in part of any sets.
     * 
     * This method requires authentication with 'read' permission.
     * 
     * @param perPage
     *            The per page
     * @param page
     *            The page
     * @return The collection of Photo objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PhotoList<Photo> getNotInSet(int perPage, int page) throws FlickrException {
        PhotoList<Photo> photos = new PhotoList<Photo>();

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", PhotosInterface.METHOD_GET_NOT_IN_SET);

        RequestContext requestContext = RequestContext.getRequestContext();

        List<String> extras = requestContext.getExtras();
        if (extras.size() > 0) {
            parameters.put(""extras"", StringUtilities.join(extras, "",""));
        }

        if (perPage > 0) {
            parameters.put(""per_page"", Integer.toString(perPage));
        }
        if (page > 0) {
            parameters.put(""page"", Integer.toString(page));
        }

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element photosElement = response.getPayload();
        photos.setPage(photosElement.getAttribute(""page""));
        photos.setPages(photosElement.getAttribute(""pages""));
        photos.setPerPage(photosElement.getAttribute(""perpage""));
        photos.setTotal(photosElement.getAttribute(""total""));

        NodeList photoElements = photosElement.getElementsByTagName(""photo"");
        for (int i = 0; i < photoElements.getLength(); i++) {
            Element photoElement = (Element) photoElements.item(i);
            photos.add(PhotoUtils.createPhoto(photoElement));
        }
        return photos;
    }

    /**
     * Get the permission information for the specified photo.
     * 
     * This method requires authentication with 'read' permission.
     * 
     * @param photoId
     *            The photo id
     * @return The Permissions object
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Permissions getPerms(String photoId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_PERMS);

        parameters.put(""photo_id"", photoId);

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element permissionsElement = response.getPayload();
        Permissions permissions = new Permissions();
        permissions.setId(permissionsElement.getAttribute(""id""));
        permissions.setPublicFlag(""1"".equals(permissionsElement.getAttribute(""ispublic"")));
        permissions.setFamilyFlag(""1"".equals(permissionsElement.getAttribute(""isfamily"")));
        permissions.setFriendFlag(""1"".equals(permissionsElement.getAttribute(""isfriend"")));
        permissions.setComment(permissionsElement.getAttribute(""permcomment""));
        permissions.setAddmeta(permissionsElement.getAttribute(""permaddmeta""));
        return permissions;
    }

    /**
     * Get a collection of recent photos.
     * 
     * This method does not require authentication.
     * 
     * @see com.flickr4java.flickr.photos.Extras
     * @param extras
     *            Set of extra-fields
     * @param perPage
     *            The number of photos per page
     * @param page
     *            The page offset
     * @return A collection of Photo objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PhotoList<Photo> getRecent(Set<String> extras, int perPage, int page) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_RECENT);

        if (extras != null && !extras.isEmpty()) {
            parameters.put(Extras.KEY_EXTRAS, StringUtilities.join(extras, "",""));
        }
        if (perPage > 0) {
            parameters.put(""per_page"", Integer.toString(perPage));
        }
        if (page > 0) {
            parameters.put(""page"", Integer.toString(page));
        }

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element photosElement = response.getPayload();
        PhotoList<Photo> photos = PhotoUtils.createPhotoList(photosElement);
        return photos;
    }

    /**
     * Get the available sizes of a Photo.
     * 
     * The calling user must have permission to view the photo.
     * 
     * This method uses no authentication.
     * 
     * @param photoId
     *            The photo ID
     * @return A collection of {@link Size}
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Collection<Size> getSizes(String photoId) throws FlickrException {
        return getSizes(photoId, false);
    }

    /**
     * Get the available sizes of a Photo.
     * 
     * The boolean toggle allows to (api-)sign the call.
     * 
     * This way the calling user can retrieve sizes for <b>his own</b> private photos.
     * 
     * @param photoId
     *            The photo ID
     * @param sign
     *            toggle to allow optionally signing the call (Authenticate)
     * @return A collection of {@link Size}
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Collection<Size> getSizes(String photoId, boolean sign) throws FlickrException {
        SizeList<Size> sizes = new SizeList<>();

        Map<String, Object> parameters = new HashMap<>();
        parameters.put(""method"", METHOD_GET_SIZES);

        parameters.put(""photo_id"", photoId);

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element sizesElement = response.getPayload();
        sizes.setIsCanBlog(""1"".equals(sizesElement.getAttribute(""canblog"")));
        sizes.setIsCanDownload(""1"".equals(sizesElement.getAttribute(""candownload"")));
        sizes.setIsCanPrint(""1"".equals(sizesElement.getAttribute(""canprint"")));
        NodeList sizeNodes = sizesElement.getElementsByTagName(""size"");
        for (int i = 0; i < sizeNodes.getLength(); i++) {
            Element sizeElement = (Element) sizeNodes.item(i);
            Size size = new Size();
            size.setLabel(sizeElement.getAttribute(""label""));
            size.setWidth(sizeElement.getAttribute(""width""));
            size.setHeight(sizeElement.getAttribute(""height""));
            size.setSource(sizeElement.getAttribute(""source""));
            size.setUrl(sizeElement.getAttribute(""url""));
            size.setMedia(sizeElement.getAttribute(""media""));
            sizes.add(size);
        }
        return sizes;
    }

    /**
     * Get the collection of untagged photos.
     * 
     * This method requires authentication with 'read' permission.
     * 
     * @param perPage
     * @param page
     * @return A Collection of Photos
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PhotoList<Photo> getUntagged(int perPage, int page) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_UNTAGGED);

        if (perPage > 0) {
            parameters.put(""per_page"", Integer.toString(perPage));
        }
        if (page > 0) {
            parameters.put(""page"", Integer.toString(page));
        }

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element photosElement = response.getPayload();
        PhotoList<Photo> photos = PhotoUtils.createPhotoList(photosElement);
        return photos;
    }

    /**
     * Returns a list of your geo-tagged photos.
     * 
     * This method requires authentication with 'read' permission.
     * 
     * @param minUploadDate
     *            Minimum upload date. Photos with an upload date greater than or equal to this value will be returned. Set to null to not specify a date.
     * @param maxUploadDate
     *            Maximum upload date. Photos with an upload date less than or equal to this value will be returned. Set to null to not specify a date.
     * @param minTakenDate
     *            Minimum taken date. Photos with an taken date greater than or equal to this value will be returned. Set to null to not specify a date.
     * @param maxTakenDate
     *            Maximum taken date. Photos with an taken date less than or equal to this value will be returned. Set to null to not specify a date.
     * @param privacyFilter
     *            Return photos only matching a certain privacy level. Valid values are:
     *            <ul>
     *            <li>1 public photos</li>
     *            <li>2 private photos visible to friends</li>
     *            <li>3 private photos visible to family</li>
     *            <li>4 private photos visible to friends and family</li>
     *            <li>5 completely private photos</li>
     *            </ul>
     *            Set to 0 to not specify a privacy Filter.
     * 
     * @see com.flickr4java.flickr.photos.Extras
     * @param sort
     *            The order in which to sort returned photos. Deafults to date-posted-desc. The possible values are: date-posted-asc, date-posted-desc,
     *            date-taken-asc, date-taken-desc, interestingness-desc, and interestingness-asc.
     * @param extras
     *            A set of Strings controlling the extra information to fetch for each returned record. Currently supported fields are: license, date_upload,
     *            date_taken, owner_name, icon_server, original_format, last_update, geo. Set to null or an empty set to not specify any extras.
     * @param perPage
     *            Number of photos to return per page. If this argument is 0, it defaults to 100. The maximum allowed value is 500.
     * @param page
     *            The page of results to return. If this argument is 0, it defaults to 1.
     * @return photos
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PhotoList<Photo> getWithGeoData(Date minUploadDate, Date maxUploadDate, Date minTakenDate, Date maxTakenDate, int privacyFilter, String sort,
            Set<String> extras, int perPage, int page) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_WITH_GEO_DATA);

        if (minUploadDate != null) {
            parameters.put(""min_upload_date"", Long.toString(minUploadDate.getTime() / 1000L));
        }
        if (maxUploadDate != null) {
            parameters.put(""max_upload_date"", Long.toString(maxUploadDate.getTime() / 1000L));
        }
        if (minTakenDate != null) {
            parameters.put(""min_taken_date"", Long.toString(minTakenDate.getTime() / 1000L));
        }
        if (maxTakenDate != null) {
            parameters.put(""max_taken_date"", Long.toString(maxTakenDate.getTime() / 1000L));
        }
        if (privacyFilter > 0) {
            parameters.put(""privacy_filter"", Integer.toString(privacyFilter));
        }
        if (sort != null) {
            parameters.put(""sort"", sort);
        }
        if (extras != null && !extras.isEmpty()) {
            parameters.put(""extras"", StringUtilities.join(extras, "",""));
        }
        if (perPage > 0) {
            parameters.put(""per_page"", Integer.toString(perPage));
        }
        if (page > 0) {
            parameters.put(""page"", Integer.toString(page));
        }

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element photosElement = response.getPayload();
        PhotoList<Photo> photos = PhotoUtils.createPhotoList(photosElement);
        return photos;
    }

    /**
     * Returns a list of your photos which haven't been geo-tagged.
     * 
     * This method requires authentication with 'read' permission.
     * 
     * @param minUploadDate
     *            Minimum upload date. Photos with an upload date greater than or equal to this value will be returned. Set to null to not specify a date.
     * @param maxUploadDate
     *            Maximum upload date. Photos with an upload date less than or equal to this value will be returned. Set to null to not specify a date.
     * @param minTakenDate
     *            Minimum taken date. Photos with an taken date greater than or equal to this value will be returned. Set to null to not specify a date.
     * @param maxTakenDate
     *            Maximum taken date. Photos with an taken date less than or equal to this value will be returned. Set to null to not specify a date.
     * @param privacyFilter
     *            Return photos only matching a certain privacy level. Valid values are:
     *            <ul>
     *            <li>1 public photos</li>
     *            <li>2 private photos visible to friends</li>
     *            <li>3 private photos visible to family</li>
     *            <li>4 private photos visible to friends and family</li>
     *            <li>5 completely private photos</li>
     *            </ul>
     *            Set to 0 to not specify a privacy Filter.
     * 
     * @see com.flickr4java.flickr.photos.Extras
     * @param sort
     *            The order in which to sort returned photos. Deafults to date-posted-desc. The possible values are: date-posted-asc, date-posted-desc,
     *            date-taken-asc, date-taken-desc, interestingness-desc, and interestingness-asc.
     * @param extras
     *            A set of Strings controlling the extra information to fetch for each returned record. Currently supported fields are: license, date_upload,
     *            date_taken, owner_name, icon_server, original_format, last_update, geo. Set to null or an empty set to not specify any extras.
     * @param perPage
     *            Number of photos to return per page. If this argument is 0, it defaults to 100. The maximum allowed value is 500.
     * @param page
     *            The page of results to return. If this argument is 0, it defaults to 1.
     * @return a photo list
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PhotoList<Photo> getWithoutGeoData(Date minUploadDate, Date maxUploadDate, Date minTakenDate, Date maxTakenDate, int privacyFilter, String sort,
            Set<String> extras, int perPage, int page) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_WITHOUT_GEO_DATA);

        if (minUploadDate != null) {
            parameters.put(""min_upload_date"", Long.toString(minUploadDate.getTime() / 1000L));
        }
        if (maxUploadDate != null) {
            parameters.put(""max_upload_date"", Long.toString(maxUploadDate.getTime() / 1000L));
        }
        if (minTakenDate != null) {
            parameters.put(""min_taken_date"", Long.toString(minTakenDate.getTime() / 1000L));
        }
        if (maxTakenDate != null) {
            parameters.put(""max_taken_date"", Long.toString(maxTakenDate.getTime() / 1000L));
        }
        if (privacyFilter > 0) {
            parameters.put(""privacy_filter"", Long.toString(privacyFilter));
        }
        if (sort != null) {
            parameters.put(""sort"", sort);
        }
        if (extras != null && !extras.isEmpty()) {
            parameters.put(""extras"", StringUtilities.join(extras, "",""));
        }
        if (perPage > 0) {
            parameters.put(""per_page"", Integer.toString(perPage));
        }
        if (page > 0) {
            parameters.put(""page"", Integer.toString(page));
        }

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element photosElement = response.getPayload();
        PhotoList<Photo> photos = PhotoUtils.createPhotoList(photosElement);
        return photos;
    }

    /**
     * Return a list of your photos that have been recently created or which have been recently modified. Recently modified may mean that the photo's metadata
     * (title, description, tags) may have been changed or a comment has been added (or just modified somehow :-)
     * 
     * This method requires authentication with 'read' permission.
     * 
     * @see com.flickr4java.flickr.photos.Extras
     * @param minDate
     *            Date indicating the date from which modifications should be compared. Must be given.
     * @param extras
     *            A set of Strings controlling the extra information to fetch for each returned record. Currently supported fields are: license, date_upload,
     *            date_taken, owner_name, icon_server, original_format, last_update, geo. Set to null or an empty set to not specify any extras.
     * @param perPage
     *            Number of photos to return per page. If this argument is 0, it defaults to 100. The maximum allowed value is 500.
     * @param page
     *            The page of results to return. If this argument is 0, it defaults to 1.
     * @return a list of photos
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PhotoList<Photo> recentlyUpdated(Date minDate, Set<String> extras, int perPage, int page) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_RECENTLY_UPDATED);

        parameters.put(""min_date"", Long.toString(minDate.getTime() / 1000L));

        if (extras != null && !extras.isEmpty()) {
            parameters.put(""extras"", StringUtilities.join(extras, "",""));
        }
        if (perPage > 0) {
            parameters.put(""per_page"", Integer.toString(perPage));
        }
        if (page > 0) {
            parameters.put(""page"", Integer.toString(page));
        }

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element photosElement = response.getPayload();
        PhotoList<Photo> photos = PhotoUtils.createPhotoList(photosElement);
        return photos;
    }

    /**
     * Remove a tag from a photo.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param tagId
     *            The tag ID
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void removeTag(String tagId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_REMOVE_TAG);

        parameters.put(""tag_id"", tagId);

        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Search for photos which match the given search parameters.
     * 
     * @param params
     *            The search parameters
     * @param perPage
     *            The number of photos to show per page
     * @param page
     *            The page offset
     * @return A PhotoList
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PhotoList<Photo> search(SearchParameters params, int perPage, int page) throws FlickrException {
        PhotoList<Photo> photos = new PhotoList<Photo>();

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_SEARCH);

        parameters.putAll(params.getAsParameters());

        if (perPage > 0) {
            parameters.put(""per_page"", """" + perPage);
        }
        if (page > 0) {
            parameters.put(""page"", """" + page);
        }

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element photosElement = response.getPayload();
        photos.setPage(photosElement.getAttribute(""page""));
        photos.setPages(photosElement.getAttribute(""pages""));
        photos.setPerPage(photosElement.getAttribute(""perpage""));
        photos.setTotal(photosElement.getAttribute(""total""));

        NodeList photoNodes = photosElement.getElementsByTagName(""photo"");
        for (int i = 0; i < photoNodes.getLength(); i++) {
            Element photoElement = (Element) photoNodes.item(i);
            photos.add(PhotoUtils.createPhoto(photoElement));
        }
        return photos;
    }

    /**
     * Search for interesting photos using the Flickr Interestingness algorithm.
     * 
     * @param params
     *            Any search parameters
     * @param perPage
     *            Number of items per page
     * @param page
     *            The page to start on
     * @return A PhotoList
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PhotoList<Photo> searchInterestingness(SearchParameters params, int perPage, int page) throws FlickrException {
        PhotoList<Photo> photos = new PhotoList<Photo>();

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_INTERESTINGNESS);

        parameters.putAll(params.getAsParameters());

        if (perPage > 0) {
            parameters.put(""per_page"", Integer.toString(perPage));
        }
        if (page > 0) {
            parameters.put(""page"", Integer.toString(page));
        }

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element photosElement = response.getPayload();
        photos.setPage(photosElement.getAttribute(""page""));
        photos.setPages(photosElement.getAttribute(""pages""));
        photos.setPerPage(photosElement.getAttribute(""perpage""));
        photos.setTotal(photosElement.getAttribute(""total""));

        NodeList photoNodes = photosElement.getElementsByTagName(""photo"");
        for (int i = 0; i < photoNodes.getLength(); i++) {
            Element photoElement = (Element) photoNodes.item(i);
            Photo photo = new Photo();
            photo.setId(photoElement.getAttribute(""id""));

            User owner = new User();
            owner.setId(photoElement.getAttribute(""owner""));
            photo.setOwner(owner);

            photo.setSecret(photoElement.getAttribute(""secret""));
            photo.setServer(photoElement.getAttribute(""server""));
            photo.setFarm(photoElement.getAttribute(""farm""));
            photo.setTitle(photoElement.getAttribute(""title""));
            photo.setPublicFlag(""1"".equals(photoElement.getAttribute(""ispublic"")));
            photo.setFriendFlag(""1"".equals(photoElement.getAttribute(""isfriend"")));
            photo.setFamilyFlag(""1"".equals(photoElement.getAttribute(""isfamily"")));
            photos.add(photo);
        }
        return photos;
    }

    /**
     * Set the content type of a photo.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @see com.flickr4java.flickr.Flickr#CONTENTTYPE_PHOTO
     * @see com.flickr4java.flickr.Flickr#CONTENTTYPE_SCREENSHOT
     * @see com.flickr4java.flickr.Flickr#CONTENTTYPE_OTHER
     * @param photoId
     *            The photo ID
     * @param contentType
     *            The contentType to set
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void setContentType(String photoId, String contentType) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_SET_CONTENTTYPE);

        parameters.put(""photo_id"", photoId);
        parameters.put(""content_type"", contentType);

        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Set the dates for the specified photo.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param photoId
     *            The photo ID
     * @param datePosted
     *            The date the photo was posted or null
     * @param dateTaken
     *            The date the photo was taken or null
     * @param dateTakenGranularity
     *            The granularity of the taken date or null
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void setDates(String photoId, Date datePosted, Date dateTaken, String dateTakenGranularity) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_SET_DATES);

        parameters.put(""photo_id"", photoId);

        if (datePosted != null) {
            parameters.put(""date_posted"", Long.toString(datePosted.getTime() / 1000));
        }

        if (dateTaken != null) {
            parameters.put(""date_taken"", ((DateFormat) DATE_FORMATS.get()).format(dateTaken));
        }

        if (dateTakenGranularity != null) {
            parameters.put(""date_taken_granularity"", dateTakenGranularity);
        }

        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Set the meta data for the photo.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param photoId
     *            The photo ID
     * @param title
     *            The new title
     * @param description
     *            The new description
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void setMeta(String photoId, String title, String description) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_SET_META);

        parameters.put(""photo_id"", photoId);
        parameters.put(""title"", title);
        parameters.put(""description"", description);

        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Set the permissions for the photo.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param photoId
     *            The photo ID
     * @param permissions
     *            The permissions object
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void setPerms(String photoId, Permissions permissions) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_SET_PERMS);

        parameters.put(""photo_id"", photoId);
        parameters.put(""is_public"", permissions.isPublicFlag() ? ""1"" : ""0"");
        parameters.put(""is_friend"", permissions.isFriendFlag() ? ""1"" : ""0"");
        parameters.put(""is_family"", permissions.isFamilyFlag() ? ""1"" : ""0"");
        parameters.put(""perm_comment"", Integer.toString(permissions.getComment()));
        parameters.put(""perm_addmeta"", Integer.toString(permissions.getAddmeta()));

        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Set the safety level (adultness) of a photo.
     * <p>
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param photoId
     *            The photo ID
     * @param safetyLevel
     *            The safety level of the photo or null
     * @param hidden
     *            Hidden from public searches or not or null
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_SAFE
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_MODERATE
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_RESTRICTED
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void setSafetyLevel(String photoId, String safetyLevel, Boolean hidden) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_SET_SAFETYLEVEL);

        parameters.put(""photo_id"", photoId);

        if (safetyLevel != null) {
            parameters.put(""safety_level"", safetyLevel);
        }

        if (hidden != null) {
            parameters.put(""hidden"", hidden.booleanValue() ? ""1"" : ""0"");
        }

        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Set the tags for a photo.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param photoId
     *            The photo ID
     * @param tags
     *            The tag array
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void setTags(String photoId, String[] tags) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_SET_TAGS);

        parameters.put(""photo_id"", photoId);
        parameters.put(""tags"", StringUtilities.join(tags, "" "", true));

        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Get the photo for the specified ID. Currently maps to the getInfo() method.
     * 
     * @param id
     *            The ID
     * @return The Photo
     */
    public Photo getPhoto(String id) throws FlickrException {
        return getPhoto(id, null);
    }

    /**
     * Get the photo for the specified ID with the given secret. Currently maps to the getInfo() method.
     * 
     * @param id
     *            The ID
     * @param secret
     *            The secret
     * @return The Photo
     */
    public Photo getPhoto(String id, String secret) throws FlickrException {
        return getInfo(id, secret);
    }

    /**
     * Request an image from the Flickr-servers.<br>
     * Callers must close the stream upon completion.
     * <p>
     * 
     * At {@link Size} you can find constants for the available sizes.
     * 
     * @param photo
     *            A photo-object
     * @param size
     *            The Size
     * @return InputStream The InputStream
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public InputStream getImageAsStream(Photo photo, int size) throws FlickrException {
        try {
            String urlStr = """";
            if (size == Size.SQUARE) {
                urlStr = photo.getSmallSquareUrl();
            } else if (size == Size.THUMB) {
                urlStr = photo.getThumbnailUrl();
            } else if (size == Size.SMALL) {
                urlStr = photo.getSmallUrl();
            } else if (size == Size.MEDIUM) {
                urlStr = photo.getMediumUrl();
            } else if (size == Size.LARGE) {
                urlStr = photo.getLargeUrl();
            } else if (size == Size.LARGE_1600) {
                urlStr = photo.getLarge1600Url();
            } else if (size == Size.LARGE_2048) {
                urlStr = photo.getLarge2048Url();
            } else if (size == Size.ORIGINAL) {
                urlStr = photo.getOriginalUrl();
            } else if (size == Size.SQUARE_LARGE) {
                urlStr = photo.getSquareLargeUrl();
            } else if (size == Size.SMALL_320) {
                urlStr = photo.getSmall320Url();
            } else if (size == Size.MEDIUM_640) {
                urlStr = photo.getMedium640Url();
            } else if (size == Size.MEDIUM_800) {
                urlStr = photo.getMedium800Url();
            } else if (size == Size.VIDEO_ORIGINAL) {
                urlStr = photo.getVideoOriginalUrl();
            } else if (size == Size.VIDEO_PLAYER) {
                urlStr = photo.getVideoPlayerUrl();
            } else if (size == Size.SITE_MP4) {
                urlStr = photo.getSiteMP4Url();
            } else if (size == Size.MOBILE_MP4) {
                urlStr = photo.getMobileMp4Url();
            } else if (size == Size.HD_MP4) {
                urlStr = photo.getHdMp4Url();
            } else {
                throw new FlickrException(""0"", ""Unknown Photo-size"");
            }
            URL url = new URL(urlStr);
            HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
            if (transport instanceof REST) {
                if (((REST) transport).isProxyAuth()) {
                    conn.setRequestProperty(""Proxy-Authorization"", ""Basic "" + ((REST) transport).getProxyCredentials());
                }
            }
            conn.connect();
            return conn.getInputStream();
        } catch (IOException e) {
            throw new FlickrException(e.getMessage(), e.getCause());
        }
    }

    /**
     * Request an image from the Flickr-servers.
     * <p>
     * 
     * At {@link Size} you can find constants for the available sizes.
     * 
     * @param photo
     *            A photo-object
     * @param size
     *            The size
     * @return An Image
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public BufferedImage getImage(Photo photo, int size) throws FlickrException {
        try {
            return ImageIO.read(getImageAsStream(photo, size));
        } catch (IOException e) {
            throw new FlickrException(e.getMessage(), e.getCause());
        }
    }

    /**
     * Download of an image by URL.
     * 
     * @param urlStr
     *            The URL of a Photo
     * @return BufferedImage The The Image
     */
    public BufferedImage getImage(String urlStr) throws FlickrException {
        InputStream in = null;
        try {
            URL url = new URL(urlStr);
            HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
            if (transport instanceof REST) {
                if (((REST) transport).isProxyAuth()) {
                    conn.setRequestProperty(""Proxy-Authorization"", ""Basic "" + ((REST) transport).getProxyCredentials());
                }
            }
            conn.connect();
            in = conn.getInputStream();
            return ImageIO.read(in);
        } catch (IOException e) {
            throw new FlickrException(e.getMessage(), e.getCause());
        } finally {
            IOUtilities.close(in);
        }
    }
}
","package com.flickr4java.flickr.photos; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.REST; import com.flickr4java.flickr.RequestContext; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.photos.geo.GeoInterface; import com.flickr4java.flickr.util.IOUtilities; import com.flickr4java.flickr.util.StringUtilities; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import javax.imageio.ImageIO; import javax.net.ssl.HttpsURLConnection; import java.awt.image.BufferedImage; import java.io.IOException; import java.io.InputStream; import java.net.URL; import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Collection; import java.util.Date; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; public class PhotosInterface { public static final String METHOD_ADD_TAGS = ""flickr.photos.addTags""; public static final String METHOD_DELETE = ""flickr.photos.delete""; public static final String METHOD_GET_ALL_CONTEXTS = ""flickr.photos.getAllContexts""; public static final String METHOD_GET_CONTACTS_PHOTOS = ""flickr.photos.getContactsPhotos""; public static final String METHOD_GET_CONTACTS_PUBLIC_PHOTOS = ""flickr.photos.getContactsPublicPhotos""; public static final String METHOD_GET_CONTEXT = ""flickr.photos.getContext""; public static final String METHOD_GET_COUNTS = ""flickr.photos.getCounts""; public static final String METHOD_GET_EXIF = ""flickr.photos.getExif""; public static final String METHOD_GET_FAVORITES = ""flickr.photos.getFavorites""; public static final String METHOD_GET_INFO = ""flickr.photos.getInfo""; public static final String METHOD_GET_NOT_IN_SET = ""flickr.photos.getNotInSet""; public static final String METHOD_GET_PERMS = ""flickr.photos.getPerms""; public static final String METHOD_GET_RECENT = ""flickr.photos.getRecent""; public static final String METHOD_GET_SIZES = ""flickr.photos.getSizes""; public static final String METHOD_GET_UNTAGGED = ""flickr.photos.getUntagged""; public static final String METHOD_GET_WITH_GEO_DATA = ""flickr.photos.getWithGeoData""; public static final String METHOD_GET_WITHOUT_GEO_DATA = ""flickr.photos.getWithoutGeoData""; public static final String METHOD_RECENTLY_UPDATED = ""flickr.photos.recentlyUpdated""; public static final String METHOD_REMOVE_TAG = ""flickr.photos.removeTag""; public static final String METHOD_SEARCH = ""flickr.photos.search""; public static final String METHOD_SET_CONTENTTYPE = ""flickr.photos.setContentType""; public static final String METHOD_SET_DATES = ""flickr.photos.setDates""; public static final String METHOD_SET_META = ""flickr.photos.setMeta""; public static final String METHOD_SET_PERMS = ""flickr.photos.setPerms""; public static final String METHOD_SET_SAFETYLEVEL = ""flickr.photos.setSafetyLevel""; public static final String METHOD_SET_TAGS = ""flickr.photos.setTags""; public static final String METHOD_GET_INTERESTINGNESS = ""flickr.interestingness.getList""; private static final ThreadLocal<SimpleDateFormat> DATE_FORMATS = new ThreadLocal<SimpleDateFormat>() { @Override
        protected synchronized SimpleDateFormat initialValue() { return new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); } } ; private GeoInterface geoInterface = null; private final String apiKey; private final String sharedSecret; private final Transport transport; public PhotosInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transport = transport; } public synchronized GeoInterface getGeoInterface() { if (geoInterface == null) { geoInterface = new GeoInterface(apiKey, sharedSecret, transport); } return geoInterface; } public void addTags(String photoId, String[] tags) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD_TAGS); parameters.put(""photo_id"", photoId); parameters.put(""tags"", StringUtilities.join(tags, "" "", true)); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void delete(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_DELETE); parameters.put(""photo_id"", photoId); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public PhotoAllContext getAllContexts(String photoId) throws FlickrException { PhotoSetList<PhotoSet> setList = new PhotoSetList<PhotoSet>(); PoolList<Pool> poolList = new PoolList<Pool>(); PhotoAllContext allContext = new PhotoAllContext(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_ALL_CONTEXTS); parameters.put(""photo_id"", photoId); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Collection<Element> photosElement = response.getPayloadCollection(); for (Element setElement : photosElement) { if (setElement.getTagName().equals(""set"")) { PhotoSet pset = new PhotoSet(); pset.setTitle(setElement.getAttribute(""title"")); pset.setSecret(setElement.getAttribute(""secret"")); pset.setId(setElement.getAttribute(""id"")); pset.setFarm(setElement.getAttribute(""farm"")); pset.setPrimary(setElement.getAttribute(""primary"")); pset.setServer(setElement.getAttribute(""server"")); pset.setViewCount(Integer.parseInt(setElement.getAttribute(""view_count""))); pset.setCommentCount(Integer.parseInt(setElement.getAttribute(""comment_count""))); pset.setCountPhoto(Integer.parseInt(setElement.getAttribute(""count_photo""))); pset.setCountVideo(Integer.parseInt(setElement.getAttribute(""count_video""))); setList.add(pset); allContext.setPhotoSetList(setList); } else if (setElement.getTagName().equals(""pool"")) { Pool pool = new Pool(); pool.setTitle(setElement.getAttribute(""title"")); pool.setId(setElement.getAttribute(""id"")); pool.setUrl(setElement.getAttribute(""url"")); pool.setIconServer(setElement.getAttribute(""iconserver"")); pool.setIconFarm(setElement.getAttribute(""iconfarm"")); pool.setMemberCount(Integer.parseInt(setElement.getAttribute(""members""))); pool.setPoolCount(Integer.parseInt(setElement.getAttribute(""pool_count""))); poolList.add(pool); allContext.setPoolList(poolList); } } return allContext; } public PhotoList<Photo> getContactsPhotos(int count, boolean justFriends, boolean singlePhoto, boolean includeSelf) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CONTACTS_PHOTOS); if (count > 0) { parameters.put(""count"", Integer.toString(count)); } if (justFriends) { parameters.put(""just_friends"", ""1""); } if (singlePhoto) { parameters.put(""single_photo"", ""1""); } if (includeSelf) { parameters.put(""include_self"", ""1""); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); photos.setPage(""1""); photos.setPages(""1""); photos.setPerPage("""" + photoNodes.getLength()); photos.setTotal("""" + photoNodes.getLength()); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } public PhotoList<Photo> getContactsPublicPhotos(String userId, int count, boolean justFriends, boolean singlePhoto, boolean includeSelf)
            throws FlickrException { return getContactsPublicPhotos(userId, Extras.MIN_EXTRAS, count, justFriends, singlePhoto, includeSelf); } public PhotoList<Photo> getContactsPublicPhotos(String userId, Set<String> extras, int count, boolean justFriends, boolean singlePhoto, boolean includeSelf)
            throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CONTACTS_PUBLIC_PHOTOS); parameters.put(""user_id"", userId); if (count > 0) { parameters.put(""count"", Integer.toString(count)); } if (justFriends) { parameters.put(""just_friends"", ""1""); } if (singlePhoto) { parameters.put(""single_photo"", ""1""); } if (includeSelf) { parameters.put(""include_self"", ""1""); } if (extras != null) { StringBuffer sb = new StringBuffer(); Iterator<String> it = extras.iterator(); for (int i = 0; it.hasNext(); i++) { if (i > 0) { sb.append("",""); } sb.append(it.next()); } parameters.put(Extras.KEY_EXTRAS, sb.toString()); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); photos.setPage(""1""); photos.setPages(""1""); photos.setPerPage("""" + photoNodes.getLength()); photos.setTotal("""" + photoNodes.getLength()); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } public PhotoContext getContext(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CONTEXT); parameters.put(""photo_id"", photoId); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } PhotoContext photoContext = new PhotoContext(); Collection<Element> payload = response.getPayloadCollection(); for (Element payloadElement : payload) { String tagName = payloadElement.getTagName(); if (tagName.equals(""prevphoto"")) { Photo photo = new Photo(); photo.setId(payloadElement.getAttribute(""id"")); photo.setSecret(payloadElement.getAttribute(""secret"")); photo.setTitle(payloadElement.getAttribute(""title"")); photo.setFarm(payloadElement.getAttribute(""farm"")); photo.setUrl(payloadElement.getAttribute(""url"")); photoContext.setPreviousPhoto(photo); } else if (tagName.equals(""nextphoto"")) { Photo photo = new Photo(); photo.setId(payloadElement.getAttribute(""id"")); photo.setSecret(payloadElement.getAttribute(""secret"")); photo.setTitle(payloadElement.getAttribute(""title"")); photo.setFarm(payloadElement.getAttribute(""farm"")); photo.setUrl(payloadElement.getAttribute(""url"")); photoContext.setNextPhoto(photo); } } return photoContext; } public Collection<Photocount> getCounts(Date[] dates, Date[] takenDates) throws FlickrException { List<Photocount> photocounts = new ArrayList<Photocount>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_COUNTS); if (dates == null && takenDates == null) { throw new IllegalArgumentException(""You must provide a value for either dates or takenDates""); } if (dates != null) { List<String> dateList = new ArrayList<String>(); for (int i = 0; i < dates.length; i++) { dateList.add(String.valueOf(dates[i].getTime() / 1000L)); } parameters.put(""dates"", StringUtilities.join(dateList, "","")); } if (takenDates != null) { List<String> takenDateList = new ArrayList<String>(); for (int i = 0; i < takenDates.length; i++) { takenDateList.add(String.valueOf(takenDates[i].getTime() / 1000L)); } parameters.put(""taken_dates"", StringUtilities.join(takenDateList, "","")); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photocountsElement = response.getPayload(); NodeList photocountNodes = photocountsElement.getElementsByTagName(""photocount""); for (int i = 0; i < photocountNodes.getLength(); i++) { Element photocountElement = (Element) photocountNodes.item(i); Photocount photocount = new Photocount(); photocount.setCount(photocountElement.getAttribute(""count"")); photocount.setFromDate(photocountElement.getAttribute(""fromdate"")); photocount.setToDate(photocountElement.getAttribute(""todate"")); photocounts.add(photocount); } return photocounts; } public Collection<Exif> getExif(String photoId, String secret) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_EXIF); parameters.put(""photo_id"", photoId); if (secret != null) { parameters.put(""secret"", secret); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } List<Exif> exifs = new ArrayList<Exif>(); Element photoElement = response.getPayload(); NodeList exifElements = photoElement.getElementsByTagName(""exif""); for (int i = 0; i < exifElements.getLength(); i++) { Element exifElement = (Element) exifElements.item(i); Exif exif = new Exif(); exif.setTagspace(exifElement.getAttribute(""tagspace"")); exif.setTagspaceId(exifElement.getAttribute(""tagspaceid"")); exif.setTag(exifElement.getAttribute(""tag"")); exif.setLabel(exifElement.getAttribute(""label"")); exif.setRaw(XMLUtilities.getChildValue(exifElement, ""raw"")); exif.setClean(XMLUtilities.getChildValue(exifElement, ""clean"")); exifs.add(exif); } return exifs; } public Collection<User> getFavorites(String photoId, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_FAVORITES); parameters.put(""photo_id"", photoId); if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } List<User> users = new ArrayList<User>(); Element userRoot = response.getPayload(); NodeList userNodes = userRoot.getElementsByTagName(""person""); for (int i = 0; i < userNodes.getLength(); i++) { Element userElement = (Element) userNodes.item(i); User user = new User(); user.setId(userElement.getAttribute(""nsid"")); user.setUsername(userElement.getAttribute(""username"")); user.setFaveDate(userElement.getAttribute(""favedate"")); users.add(user); } return users; } public Photo getInfo(String photoId, String secret) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO); parameters.put(""photo_id"", photoId); if (secret != null) { parameters.put(""secret"", secret); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photoElement = response.getPayload(); return PhotoUtils.createPhoto(photoElement); } public PhotoList<Photo> getNotInSet(int perPage, int page) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", PhotosInterface.METHOD_GET_NOT_IN_SET); RequestContext requestContext = RequestContext.getRequestContext(); List<String> extras = requestContext.getExtras(); if (extras.size() > 0) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoElements = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoElements.getLength(); i++) { Element photoElement = (Element) photoElements.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } public Permissions getPerms(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PERMS); parameters.put(""photo_id"", photoId); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element permissionsElement = response.getPayload(); Permissions permissions = new Permissions(); permissions.setId(permissionsElement.getAttribute(""id"")); permissions.setPublicFlag(""1"".equals(permissionsElement.getAttribute(""ispublic""))); permissions.setFamilyFlag(""1"".equals(permissionsElement.getAttribute(""isfamily""))); permissions.setFriendFlag(""1"".equals(permissionsElement.getAttribute(""isfriend""))); permissions.setComment(permissionsElement.getAttribute(""permcomment"")); permissions.setAddmeta(permissionsElement.getAttribute(""permaddmeta"")); return permissions; } public PhotoList<Photo> getRecent(Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_RECENT); if (extras != null && !extras.isEmpty()) { parameters.put(Extras.KEY_EXTRAS, StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); PhotoList<Photo> photos = PhotoUtils.createPhotoList(photosElement); return photos; } public Collection<Size> getSizes(String photoId) throws FlickrException { return getSizes(photoId, false); } public Collection<Size> getSizes(String photoId, boolean sign) throws FlickrException { SizeList<Size> sizes = new SizeList<>(); Map<String, Object> parameters = new HashMap<>(); parameters.put(""method"", METHOD_GET_SIZES); parameters.put(""photo_id"", photoId); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element sizesElement = response.getPayload(); sizes.setIsCanBlog(""1"".equals(sizesElement.getAttribute(""canblog""))); sizes.setIsCanDownload(""1"".equals(sizesElement.getAttribute(""candownload""))); sizes.setIsCanPrint(""1"".equals(sizesElement.getAttribute(""canprint""))); NodeList sizeNodes = sizesElement.getElementsByTagName(""size""); for (int i = 0; i < sizeNodes.getLength(); i++) { Element sizeElement = (Element) sizeNodes.item(i); Size size = new Size(); size.setLabel(sizeElement.getAttribute(""label"")); size.setWidth(sizeElement.getAttribute(""width"")); size.setHeight(sizeElement.getAttribute(""height"")); size.setSource(sizeElement.getAttribute(""source"")); size.setUrl(sizeElement.getAttribute(""url"")); size.setMedia(sizeElement.getAttribute(""media"")); sizes.add(size); } return sizes; } public PhotoList<Photo> getUntagged(int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_UNTAGGED); if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); PhotoList<Photo> photos = PhotoUtils.createPhotoList(photosElement); return photos; } public PhotoList<Photo> getWithGeoData(Date minUploadDate, Date maxUploadDate, Date minTakenDate, Date maxTakenDate, int privacyFilter, String sort,
            Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_WITH_GEO_DATA); if (minUploadDate != null) { parameters.put(""min_upload_date"", Long.toString(minUploadDate.getTime() / 1000L)); } if (maxUploadDate != null) { parameters.put(""max_upload_date"", Long.toString(maxUploadDate.getTime() / 1000L)); } if (minTakenDate != null) { parameters.put(""min_taken_date"", Long.toString(minTakenDate.getTime() / 1000L)); } if (maxTakenDate != null) { parameters.put(""max_taken_date"", Long.toString(maxTakenDate.getTime() / 1000L)); } if (privacyFilter > 0) { parameters.put(""privacy_filter"", Integer.toString(privacyFilter)); } if (sort != null) { parameters.put(""sort"", sort); } if (extras != null && !extras.isEmpty()) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); PhotoList<Photo> photos = PhotoUtils.createPhotoList(photosElement); return photos; } public PhotoList<Photo> getWithoutGeoData(Date minUploadDate, Date maxUploadDate, Date minTakenDate, Date maxTakenDate, int privacyFilter, String sort,
            Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_WITHOUT_GEO_DATA); if (minUploadDate != null) { parameters.put(""min_upload_date"", Long.toString(minUploadDate.getTime() / 1000L)); } if (maxUploadDate != null) { parameters.put(""max_upload_date"", Long.toString(maxUploadDate.getTime() / 1000L)); } if (minTakenDate != null) { parameters.put(""min_taken_date"", Long.toString(minTakenDate.getTime() / 1000L)); } if (maxTakenDate != null) { parameters.put(""max_taken_date"", Long.toString(maxTakenDate.getTime() / 1000L)); } if (privacyFilter > 0) { parameters.put(""privacy_filter"", Long.toString(privacyFilter)); } if (sort != null) { parameters.put(""sort"", sort); } if (extras != null && !extras.isEmpty()) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); PhotoList<Photo> photos = PhotoUtils.createPhotoList(photosElement); return photos; } public PhotoList<Photo> recentlyUpdated(Date minDate, Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_RECENTLY_UPDATED); parameters.put(""min_date"", Long.toString(minDate.getTime() / 1000L)); if (extras != null && !extras.isEmpty()) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); PhotoList<Photo> photos = PhotoUtils.createPhotoList(photosElement); return photos; } public void removeTag(String tagId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REMOVE_TAG); parameters.put(""tag_id"", tagId); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public PhotoList<Photo> search(SearchParameters params, int perPage, int page) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SEARCH); parameters.putAll(params.getAsParameters()); if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } public PhotoList<Photo> searchInterestingness(SearchParameters params, int perPage, int page) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INTERESTINGNESS); parameters.putAll(params.getAsParameters()); if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); Photo photo = new Photo(); photo.setId(photoElement.getAttribute(""id"")); User owner = new User(); owner.setId(photoElement.getAttribute(""owner"")); photo.setOwner(owner); photo.setSecret(photoElement.getAttribute(""secret"")); photo.setServer(photoElement.getAttribute(""server"")); photo.setFarm(photoElement.getAttribute(""farm"")); photo.setTitle(photoElement.getAttribute(""title"")); photo.setPublicFlag(""1"".equals(photoElement.getAttribute(""ispublic""))); photo.setFriendFlag(""1"".equals(photoElement.getAttribute(""isfriend""))); photo.setFamilyFlag(""1"".equals(photoElement.getAttribute(""isfamily""))); photos.add(photo); } return photos; } public void setContentType(String photoId, String contentType) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_CONTENTTYPE); parameters.put(""photo_id"", photoId); parameters.put(""content_type"", contentType); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void setDates(String photoId, Date datePosted, Date dateTaken, String dateTakenGranularity) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_DATES); parameters.put(""photo_id"", photoId); if (datePosted != null) { parameters.put(""date_posted"", Long.toString(datePosted.getTime() / 1000)); } if (dateTaken != null) { parameters.put(""date_taken"", ((DateFormat) DATE_FORMATS.get()).format(dateTaken)); } if (dateTakenGranularity != null) { parameters.put(""date_taken_granularity"", dateTakenGranularity); } Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void setMeta(String photoId, String title, String description) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_META); parameters.put(""photo_id"", photoId); parameters.put(""title"", title); parameters.put(""description"", description); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void setPerms(String photoId, Permissions permissions) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_PERMS); parameters.put(""photo_id"", photoId); parameters.put(""is_public"", permissions.isPublicFlag() ? ""1"" : ""0""); parameters.put(""is_friend"", permissions.isFriendFlag() ? ""1"" : ""0""); parameters.put(""is_family"", permissions.isFamilyFlag() ? ""1"" : ""0""); parameters.put(""perm_comment"", Integer.toString(permissions.getComment())); parameters.put(""perm_addmeta"", Integer.toString(permissions.getAddmeta())); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void setSafetyLevel(String photoId, String safetyLevel, Boolean hidden) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_SAFETYLEVEL); parameters.put(""photo_id"", photoId); if (safetyLevel != null) { parameters.put(""safety_level"", safetyLevel); } if (hidden != null) { parameters.put(""hidden"", hidden.booleanValue() ? ""1"" : ""0""); } Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void setTags(String photoId, String[] tags) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_TAGS); parameters.put(""photo_id"", photoId); parameters.put(""tags"", StringUtilities.join(tags, "" "", true)); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public Photo getPhoto(String id) throws FlickrException { return getPhoto(id, null); } public Photo getPhoto(String id, String secret) throws FlickrException { return getInfo(id, secret); } public InputStream getImageAsStream(Photo photo, int size) throws FlickrException { try { String urlStr = """"; if (size == Size.SQUARE) { urlStr = photo.getSmallSquareUrl(); } else if (size == Size.THUMB) { urlStr = photo.getThumbnailUrl(); } else if (size == Size.SMALL) { urlStr = photo.getSmallUrl(); } else if (size == Size.MEDIUM) { urlStr = photo.getMediumUrl(); } else if (size == Size.LARGE) { urlStr = photo.getLargeUrl(); } else if (size == Size.LARGE_1600) { urlStr = photo.getLarge1600Url(); } else if (size == Size.LARGE_2048) { urlStr = photo.getLarge2048Url(); } else if (size == Size.ORIGINAL) { urlStr = photo.getOriginalUrl(); } else if (size == Size.SQUARE_LARGE) { urlStr = photo.getSquareLargeUrl(); } else if (size == Size.SMALL_320) { urlStr = photo.getSmall320Url(); } else if (size == Size.MEDIUM_640) { urlStr = photo.getMedium640Url(); } else if (size == Size.MEDIUM_800) { urlStr = photo.getMedium800Url(); } else if (size == Size.VIDEO_ORIGINAL) { urlStr = photo.getVideoOriginalUrl(); } else if (size == Size.VIDEO_PLAYER) { urlStr = photo.getVideoPlayerUrl(); } else if (size == Size.SITE_MP4) { urlStr = photo.getSiteMP4Url(); } else if (size == Size.MOBILE_MP4) { urlStr = photo.getMobileMp4Url(); } else if (size == Size.HD_MP4) { urlStr = photo.getHdMp4Url(); } else { throw new FlickrException(""0"", ""Unknown Photo-size""); } URL url = new URL(urlStr); HttpsURLConnection conn = (HttpsURLConnection) url.openConnection(); if (transport instanceof REST) { if (((REST) transport).isProxyAuth()) { conn.setRequestProperty(""Proxy-Authorization"", ""Basic "" + ((REST) transport).getProxyCredentials()); } } conn.connect(); return conn.getInputStream(); } catch (IOException e) { throw new FlickrException(e.getMessage(), e.getCause()); } } public BufferedImage getImage(Photo photo, int size) throws FlickrException { try { return ImageIO.read(getImageAsStream(photo, size)); } catch (IOException e) { throw new FlickrException(e.getMessage(), e.getCause()); } } public BufferedImage getImage(String urlStr) throws FlickrException { InputStream in = null; try { URL url = new URL(urlStr); HttpsURLConnection conn = (HttpsURLConnection) url.openConnection(); if (transport instanceof REST) { if (((REST) transport).isProxyAuth()) { conn.setRequestProperty(""Proxy-Authorization"", ""Basic "" + ((REST) transport).getProxyCredentials()); } } conn.connect(); in = conn.getInputStream(); return ImageIO.read(in); } catch (IOException e) { throw new FlickrException(e.getMessage(), e.getCause()); } finally { IOUtilities.close(in); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.photos; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.REST; import com.flickr4java.flickr.RequestContext; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.photos.geo.GeoInterface; import com.flickr4java.flickr.util.IOUtilities; import com.flickr4java.flickr.util.StringUtilities; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import javax.imageio.ImageIO; import javax.net.ssl.HttpsURLConnection; import java.awt.image.BufferedImage; import java.io.IOException; import java.io.InputStream; import java.net.URL; import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Collection; import java.util.Date; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; public class PhotosInterface { public static final String METHOD_ADD_TAGS = ""flickr.photos.addTags""; public static final String METHOD_DELETE = ""flickr.photos.delete""; public static final String METHOD_GET_ALL_CONTEXTS = ""flickr.photos.getAllContexts""; public static final String METHOD_GET_CONTACTS_PHOTOS = ""flickr.photos.getContactsPhotos""; public static final String METHOD_GET_CONTACTS_PUBLIC_PHOTOS = ""flickr.photos.getContactsPublicPhotos""; public static final String METHOD_GET_CONTEXT = ""flickr.photos.getContext""; public static final String METHOD_GET_COUNTS = ""flickr.photos.getCounts""; public static final String METHOD_GET_EXIF = ""flickr.photos.getExif""; public static final String METHOD_GET_FAVORITES = ""flickr.photos.getFavorites""; public static final String METHOD_GET_INFO = ""flickr.photos.getInfo""; public static final String METHOD_GET_NOT_IN_SET = ""flickr.photos.getNotInSet""; public static final String METHOD_GET_PERMS = ""flickr.photos.getPerms""; public static final String METHOD_GET_RECENT = ""flickr.photos.getRecent""; public static final String METHOD_GET_SIZES = ""flickr.photos.getSizes""; public static final String METHOD_GET_UNTAGGED = ""flickr.photos.getUntagged""; public static final String METHOD_GET_WITH_GEO_DATA = ""flickr.photos.getWithGeoData""; public static final String METHOD_GET_WITHOUT_GEO_DATA = ""flickr.photos.getWithoutGeoData""; public static final String METHOD_RECENTLY_UPDATED = ""flickr.photos.recentlyUpdated""; public static final String METHOD_REMOVE_TAG = ""flickr.photos.removeTag""; public static final String METHOD_SEARCH = ""flickr.photos.search""; public static final String METHOD_SET_CONTENTTYPE = ""flickr.photos.setContentType""; public static final String METHOD_SET_DATES = ""flickr.photos.setDates""; public static final String METHOD_SET_META = ""flickr.photos.setMeta""; public static final String METHOD_SET_PERMS = ""flickr.photos.setPerms""; public static final String METHOD_SET_SAFETYLEVEL = ""flickr.photos.setSafetyLevel""; public static final String METHOD_SET_TAGS = ""flickr.photos.setTags""; public static final String METHOD_GET_INTERESTINGNESS = ""flickr.interestingness.getList""; private static final ThreadLocal<SimpleDateFormat> DATE_FORMATS = new ThreadLocal<SimpleDateFormat>() { @Override
        protected synchronized SimpleDateFormat initialValue() { return new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); } } ; private GeoInterface geoInterface = null; private final String apiKey; private final String sharedSecret; private final Transport transport; public PhotosInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transport = transport; } public synchronized GeoInterface getGeoInterface() { if (geoInterface == null) { geoInterface = new GeoInterface(apiKey, sharedSecret, transport); } return geoInterface; } public void addTags(String photoId, String[] tags) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD_TAGS); parameters.put(""photo_id"", photoId); parameters.put(""tags"", StringUtilities.join(tags, "" "", true)); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void delete(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_DELETE); parameters.put(""photo_id"", photoId); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public PhotoAllContext getAllContexts(String photoId) throws FlickrException { PhotoSetList<PhotoSet> setList = new PhotoSetList<PhotoSet>(); PoolList<Pool> poolList = new PoolList<Pool>(); PhotoAllContext allContext = new PhotoAllContext(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_ALL_CONTEXTS); parameters.put(""photo_id"", photoId); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Collection<Element> photosElement = response.getPayloadCollection(); for (Element setElement : photosElement) { if (setElement.getTagName().equals(""set"")) { PhotoSet pset = new PhotoSet(); pset.setTitle(setElement.getAttribute(""title"")); pset.setSecret(setElement.getAttribute(""secret"")); pset.setId(setElement.getAttribute(""id"")); pset.setFarm(setElement.getAttribute(""farm"")); pset.setPrimary(setElement.getAttribute(""primary"")); pset.setServer(setElement.getAttribute(""server"")); pset.setViewCount(Integer.parseInt(setElement.getAttribute(""view_count""))); pset.setCommentCount(Integer.parseInt(setElement.getAttribute(""comment_count""))); pset.setCountPhoto(Integer.parseInt(setElement.getAttribute(""count_photo""))); pset.setCountVideo(Integer.parseInt(setElement.getAttribute(""count_video""))); setList.add(pset); allContext.setPhotoSetList(setList); } else if (setElement.getTagName().equals(""pool"")) { Pool pool = new Pool(); pool.setTitle(setElement.getAttribute(""title"")); pool.setId(setElement.getAttribute(""id"")); pool.setUrl(setElement.getAttribute(""url"")); pool.setIconServer(setElement.getAttribute(""iconserver"")); pool.setIconFarm(setElement.getAttribute(""iconfarm"")); pool.setMemberCount(Integer.parseInt(setElement.getAttribute(""members""))); pool.setPoolCount(Integer.parseInt(setElement.getAttribute(""pool_count""))); poolList.add(pool); allContext.setPoolList(poolList); } } return allContext; } public PhotoList<Photo> getContactsPhotos(int count, boolean justFriends, boolean singlePhoto, boolean includeSelf) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CONTACTS_PHOTOS); if (count > 0) { parameters.put(""count"", Integer.toString(count)); } if (justFriends) { parameters.put(""just_friends"", ""1""); } if (singlePhoto) { parameters.put(""single_photo"", ""1""); } if (includeSelf) { parameters.put(""include_self"", ""1""); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); photos.setPage(""1""); photos.setPages(""1""); photos.setPerPage("""" + photoNodes.getLength()); photos.setTotal("""" + photoNodes.getLength()); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } public PhotoList<Photo> getContactsPublicPhotos(String userId, int count, boolean justFriends, boolean singlePhoto, boolean includeSelf)
            throws FlickrException { return getContactsPublicPhotos(userId, Extras.MIN_EXTRAS, count, justFriends, singlePhoto, includeSelf); } public PhotoList<Photo> getContactsPublicPhotos(String userId, Set<String> extras, int count, boolean justFriends, boolean singlePhoto, boolean includeSelf)
            throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CONTACTS_PUBLIC_PHOTOS); parameters.put(""user_id"", userId); if (count > 0) { parameters.put(""count"", Integer.toString(count)); } if (justFriends) { parameters.put(""just_friends"", ""1""); } if (singlePhoto) { parameters.put(""single_photo"", ""1""); } if (includeSelf) { parameters.put(""include_self"", ""1""); } if (extras != null) { StringBuffer sb = new StringBuffer(); Iterator<String> it = extras.iterator(); for (int i = 0; it.hasNext(); i++) { if (i > 0) { sb.append("",""); } sb.append(it.next()); } parameters.put(Extras.KEY_EXTRAS, sb.toString()); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); photos.setPage(""1""); photos.setPages(""1""); photos.setPerPage("""" + photoNodes.getLength()); photos.setTotal("""" + photoNodes.getLength()); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } public PhotoContext getContext(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CONTEXT); parameters.put(""photo_id"", photoId); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } PhotoContext photoContext = new PhotoContext(); Collection<Element> payload = response.getPayloadCollection(); for (Element payloadElement : payload) { String tagName = payloadElement.getTagName(); if (tagName.equals(""prevphoto"")) { Photo photo = new Photo(); photo.setId(payloadElement.getAttribute(""id"")); photo.setSecret(payloadElement.getAttribute(""secret"")); photo.setTitle(payloadElement.getAttribute(""title"")); photo.setFarm(payloadElement.getAttribute(""farm"")); photo.setUrl(payloadElement.getAttribute(""url"")); photoContext.setPreviousPhoto(photo); } else if (tagName.equals(""nextphoto"")) { Photo photo = new Photo(); photo.setId(payloadElement.getAttribute(""id"")); photo.setSecret(payloadElement.getAttribute(""secret"")); photo.setTitle(payloadElement.getAttribute(""title"")); photo.setFarm(payloadElement.getAttribute(""farm"")); photo.setUrl(payloadElement.getAttribute(""url"")); photoContext.setNextPhoto(photo); } } return photoContext; } public Collection<Photocount> getCounts(Date[] dates, Date[] takenDates) throws FlickrException { List<Photocount> photocounts = new ArrayList<Photocount>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_COUNTS); if (dates == null && takenDates == null) { throw new IllegalArgumentException(""You must provide a value for either dates or takenDates""); } if (dates != null) { List<String> dateList = new ArrayList<String>(); for (int i = 0; i < dates.length; i++) { dateList.add(String.valueOf(dates[i].getTime() / 1000L)); } parameters.put(""dates"", StringUtilities.join(dateList, "","")); } if (takenDates != null) { List<String> takenDateList = new ArrayList<String>(); for (int i = 0; i < takenDates.length; i++) { takenDateList.add(String.valueOf(takenDates[i].getTime() / 1000L)); } parameters.put(""taken_dates"", StringUtilities.join(takenDateList, "","")); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photocountsElement = response.getPayload(); NodeList photocountNodes = photocountsElement.getElementsByTagName(""photocount""); for (int i = 0; i < photocountNodes.getLength(); i++) { Element photocountElement = (Element) photocountNodes.item(i); Photocount photocount = new Photocount(); photocount.setCount(photocountElement.getAttribute(""count"")); photocount.setFromDate(photocountElement.getAttribute(""fromdate"")); photocount.setToDate(photocountElement.getAttribute(""todate"")); photocounts.add(photocount); } return photocounts; } public Collection<Exif> getExif(String photoId, String secret) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_EXIF); parameters.put(""photo_id"", photoId); if (secret != null) { parameters.put(""secret"", secret); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } List<Exif> exifs = new ArrayList<Exif>(); Element photoElement = response.getPayload(); NodeList exifElements = photoElement.getElementsByTagName(""exif""); for (int i = 0; i < exifElements.getLength(); i++) { Element exifElement = (Element) exifElements.item(i); Exif exif = new Exif(); exif.setTagspace(exifElement.getAttribute(""tagspace"")); exif.setTagspaceId(exifElement.getAttribute(""tagspaceid"")); exif.setTag(exifElement.getAttribute(""tag"")); exif.setLabel(exifElement.getAttribute(""label"")); exif.setRaw(XMLUtilities.getChildValue(exifElement, ""raw"")); exif.setClean(XMLUtilities.getChildValue(exifElement, ""clean"")); exifs.add(exif); } return exifs; } public Collection<User> getFavorites(String photoId, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_FAVORITES); parameters.put(""photo_id"", photoId); if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } List<User> users = new ArrayList<User>(); Element userRoot = response.getPayload(); NodeList userNodes = userRoot.getElementsByTagName(""person""); for (int i = 0; i < userNodes.getLength(); i++) { Element userElement = (Element) userNodes.item(i); User user = new User(); user.setId(userElement.getAttribute(""nsid"")); user.setUsername(userElement.getAttribute(""username"")); user.setFaveDate(userElement.getAttribute(""favedate"")); users.add(user); } return users; } public Photo getInfo(String photoId, String secret) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO); parameters.put(""photo_id"", photoId); if (secret != null) { parameters.put(""secret"", secret); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photoElement = response.getPayload(); return PhotoUtils.createPhoto(photoElement); } public PhotoList<Photo> getNotInSet(int perPage, int page) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", PhotosInterface.METHOD_GET_NOT_IN_SET); RequestContext requestContext = RequestContext.getRequestContext(); List<String> extras = requestContext.getExtras(); if (extras.size() > 0) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoElements = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoElements.getLength(); i++) { Element photoElement = (Element) photoElements.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } public Permissions getPerms(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PERMS); parameters.put(""photo_id"", photoId); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element permissionsElement = response.getPayload(); Permissions permissions = new Permissions(); permissions.setId(permissionsElement.getAttribute(""id"")); permissions.setPublicFlag(""1"".equals(permissionsElement.getAttribute(""ispublic""))); permissions.setFamilyFlag(""1"".equals(permissionsElement.getAttribute(""isfamily""))); permissions.setFriendFlag(""1"".equals(permissionsElement.getAttribute(""isfriend""))); permissions.setComment(permissionsElement.getAttribute(""permcomment"")); permissions.setAddmeta(permissionsElement.getAttribute(""permaddmeta"")); return permissions; } public PhotoList<Photo> getRecent(Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_RECENT); if (extras != null && !extras.isEmpty()) { parameters.put(Extras.KEY_EXTRAS, StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); PhotoList<Photo> photos = PhotoUtils.createPhotoList(photosElement); return photos; } public Collection<Size> getSizes(String photoId) throws FlickrException { return getSizes(photoId, false); } public Collection<Size> getSizes(String photoId, boolean sign) throws FlickrException { SizeList<Size> sizes = new SizeList<>(); Map<String, Object> parameters = new HashMap<>(); parameters.put(""method"", METHOD_GET_SIZES); parameters.put(""photo_id"", photoId); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element sizesElement = response.getPayload(); sizes.setIsCanBlog(""1"".equals(sizesElement.getAttribute(""canblog""))); sizes.setIsCanDownload(""1"".equals(sizesElement.getAttribute(""candownload""))); sizes.setIsCanPrint(""1"".equals(sizesElement.getAttribute(""canprint""))); NodeList sizeNodes = sizesElement.getElementsByTagName(""size""); for (int i = 0; i < sizeNodes.getLength(); i++) { Element sizeElement = (Element) sizeNodes.item(i); Size size = new Size(); size.setLabel(sizeElement.getAttribute(""label"")); size.setWidth(sizeElement.getAttribute(""width"")); size.setHeight(sizeElement.getAttribute(""height"")); size.setSource(sizeElement.getAttribute(""source"")); size.setUrl(sizeElement.getAttribute(""url"")); size.setMedia(sizeElement.getAttribute(""media"")); sizes.add(size); } return sizes; } public PhotoList<Photo> getUntagged(int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_UNTAGGED); if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); PhotoList<Photo> photos = PhotoUtils.createPhotoList(photosElement); return photos; } public PhotoList<Photo> getWithGeoData(Date minUploadDate, Date maxUploadDate, Date minTakenDate, Date maxTakenDate, int privacyFilter, String sort,
            Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_WITH_GEO_DATA); if (minUploadDate != null) { parameters.put(""min_upload_date"", Long.toString(minUploadDate.getTime() / 1000L)); } if (maxUploadDate != null) { parameters.put(""max_upload_date"", Long.toString(maxUploadDate.getTime() / 1000L)); } if (minTakenDate != null) { parameters.put(""min_taken_date"", Long.toString(minTakenDate.getTime() / 1000L)); } if (maxTakenDate != null) { parameters.put(""max_taken_date"", Long.toString(maxTakenDate.getTime() / 1000L)); } if (privacyFilter > 0) { parameters.put(""privacy_filter"", Integer.toString(privacyFilter)); } if (sort != null) { parameters.put(""sort"", sort); } if (extras != null && !extras.isEmpty()) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); PhotoList<Photo> photos = PhotoUtils.createPhotoList(photosElement); return photos; } public PhotoList<Photo> getWithoutGeoData(Date minUploadDate, Date maxUploadDate, Date minTakenDate, Date maxTakenDate, int privacyFilter, String sort,
            Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_WITHOUT_GEO_DATA); if (minUploadDate != null) { parameters.put(""min_upload_date"", Long.toString(minUploadDate.getTime() / 1000L)); } if (maxUploadDate != null) { parameters.put(""max_upload_date"", Long.toString(maxUploadDate.getTime() / 1000L)); } if (minTakenDate != null) { parameters.put(""min_taken_date"", Long.toString(minTakenDate.getTime() / 1000L)); } if (maxTakenDate != null) { parameters.put(""max_taken_date"", Long.toString(maxTakenDate.getTime() / 1000L)); } if (privacyFilter > 0) { parameters.put(""privacy_filter"", Long.toString(privacyFilter)); } if (sort != null) { parameters.put(""sort"", sort); } if (extras != null && !extras.isEmpty()) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); PhotoList<Photo> photos = PhotoUtils.createPhotoList(photosElement); return photos; } public PhotoList<Photo> recentlyUpdated(Date minDate, Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_RECENTLY_UPDATED); parameters.put(""min_date"", Long.toString(minDate.getTime() / 1000L)); if (extras != null && !extras.isEmpty()) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); PhotoList<Photo> photos = PhotoUtils.createPhotoList(photosElement); return photos; } public void removeTag(String tagId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REMOVE_TAG); parameters.put(""tag_id"", tagId); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public PhotoList<Photo> search(SearchParameters params, int perPage, int page) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SEARCH); parameters.putAll(params.getAsParameters()); if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } public PhotoList<Photo> searchInterestingness(SearchParameters params, int perPage, int page) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INTERESTINGNESS); parameters.putAll(params.getAsParameters()); if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); Photo photo = new Photo(); photo.setId(photoElement.getAttribute(""id"")); User owner = new User(); owner.setId(photoElement.getAttribute(""owner"")); photo.setOwner(owner); photo.setSecret(photoElement.getAttribute(""secret"")); photo.setServer(photoElement.getAttribute(""server"")); photo.setFarm(photoElement.getAttribute(""farm"")); photo.setTitle(photoElement.getAttribute(""title"")); photo.setPublicFlag(""1"".equals(photoElement.getAttribute(""ispublic""))); photo.setFriendFlag(""1"".equals(photoElement.getAttribute(""isfriend""))); photo.setFamilyFlag(""1"".equals(photoElement.getAttribute(""isfamily""))); photos.add(photo); } return photos; } public void setContentType(String photoId, String contentType) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_CONTENTTYPE); parameters.put(""photo_id"", photoId); parameters.put(""content_type"", contentType); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void setDates(String photoId, Date datePosted, Date dateTaken, String dateTakenGranularity) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_DATES); parameters.put(""photo_id"", photoId); if (datePosted != null) { parameters.put(""date_posted"", Long.toString(datePosted.getTime() / 1000)); } if (dateTaken != null) { parameters.put(""date_taken"", ((DateFormat) DATE_FORMATS.get()).format(dateTaken)); } if (dateTakenGranularity != null) { parameters.put(""date_taken_granularity"", dateTakenGranularity); } Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void setMeta(String photoId, String title, String description) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_META); parameters.put(""photo_id"", photoId); parameters.put(""title"", title); parameters.put(""description"", description); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void setPerms(String photoId, Permissions permissions) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_PERMS); parameters.put(""photo_id"", photoId); parameters.put(""is_public"", permissions.isPublicFlag() ? ""1"" : ""0""); parameters.put(""is_friend"", permissions.isFriendFlag() ? ""1"" : ""0""); parameters.put(""is_family"", permissions.isFamilyFlag() ? ""1"" : ""0""); parameters.put(""perm_comment"", Integer.toString(permissions.getComment())); parameters.put(""perm_addmeta"", Integer.toString(permissions.getAddmeta())); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void setSafetyLevel(String photoId, String safetyLevel, Boolean hidden) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_SAFETYLEVEL); parameters.put(""photo_id"", photoId); if (safetyLevel != null) { parameters.put(""safety_level"", safetyLevel); } if (hidden != null) { parameters.put(""hidden"", hidden.booleanValue() ? ""1"" : ""0""); } Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void setTags(String photoId, String[] tags) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_TAGS); parameters.put(""photo_id"", photoId); parameters.put(""tags"", StringUtilities.join(tags, "" "", true)); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public Photo getPhoto(String id) throws FlickrException { return getPhoto(id, null); } public Photo getPhoto(String id, String secret) throws FlickrException { return getInfo(id, secret); } public InputStream getImageAsStream(Photo photo, int size) throws FlickrException { try { String urlStr = """"; if (size == Size.SQUARE) { urlStr = photo.getSmallSquareUrl(); } else if (size == Size.THUMB) { urlStr = photo.getThumbnailUrl(); } else if (size == Size.SMALL) { urlStr = photo.getSmallUrl(); } else if (size == Size.MEDIUM) { urlStr = photo.getMediumUrl(); } else if (size == Size.LARGE) { urlStr = photo.getLargeUrl(); } else if (size == Size.LARGE_1600) { urlStr = photo.getLarge1600Url(); } else if (size == Size.LARGE_2048) { urlStr = photo.getLarge2048Url(); } else if (size == Size.ORIGINAL) { urlStr = photo.getOriginalUrl(); } else if (size == Size.SQUARE_LARGE) { urlStr = photo.getSquareLargeUrl(); } else if (size == Size.SMALL_320) { urlStr = photo.getSmall320Url(); } else if (size == Size.MEDIUM_640) { urlStr = photo.getMedium640Url(); } else if (size == Size.MEDIUM_800) { urlStr = photo.getMedium800Url(); } else if (size == Size.VIDEO_ORIGINAL) { urlStr = photo.getVideoOriginalUrl(); } else if (size == Size.VIDEO_PLAYER) { urlStr = photo.getVideoPlayerUrl(); } else if (size == Size.SITE_MP4) { urlStr = photo.getSiteMP4Url(); } else if (size == Size.MOBILE_MP4) { urlStr = photo.getMobileMp4Url(); } else if (size == Size.HD_MP4) { urlStr = photo.getHdMp4Url(); } else { throw new FlickrException(""0"", ""Unknown Photo-size""); } URL url = new URL(urlStr); HttpsURLConnection conn = (HttpsURLConnection) url.openConnection(); if (transport instanceof REST) { if (((REST) transport).isProxyAuth()) { conn.setRequestProperty(""Proxy-Authorization"", ""Basic "" + ((REST) transport).getProxyCredentials()); } } conn.connect(); return conn.getInputStream(); } catch (IOException e) { throw new FlickrException(e.getMessage(), e.getCause()); } } public BufferedImage getImage(Photo photo, int size) throws FlickrException { try { return ImageIO.read(getImageAsStream(photo, size)); } catch (IOException e) { throw new FlickrException(e.getMessage(), e.getCause()); } } public BufferedImage getImage(String urlStr) throws FlickrException { InputStream in = null; try { URL url = new URL(urlStr); HttpsURLConnection conn = (HttpsURLConnection) url.openConnection(); if (transport instanceof REST) { if (((REST) transport).isProxyAuth()) { conn.setRequestProperty(""Proxy-Authorization"", ""Basic "" + ((REST) transport).getProxyCredentials()); } } conn.connect(); in = conn.getInputStream(); return ImageIO.read(in); } catch (IOException e) { throw new FlickrException(e.getMessage(), e.getCause()); } finally { IOUtilities.close(in); } } } "," package com.flickr4java.flickr.photos;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.REST; import com.flickr4java.flickr.RequestContext; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.photos.geo.GeoInterface; import com.flickr4java.flickr.util.IOUtilities; import com.flickr4java.flickr.util.StringUtilities; import com.flickr4java.flickr.util.XMLUtilities;  import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import javax.imageio.ImageIO; import javax.net.ssl.HttpsURLConnection;  import java.awt.image.BufferedImage; import java.io.IOException; import java.io.InputStream; import java.net.URL; import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Collection; import java.util.Date; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set;  /**
 * Interface for working with Flickr Photos.
 * 
 * @author Anthony Eden
 * @version $Id: PhotosInterface.java,v 1.51 2010/07/20 20:11:16 x-mago Exp $
 */ public class PhotosInterface {  public static final String METHOD_ADD_TAGS = ""flickr.photos.addTags"";  public static final String METHOD_DELETE = ""flickr.photos.delete"";  public static final String METHOD_GET_ALL_CONTEXTS = ""flickr.photos.getAllContexts"";  public static final String METHOD_GET_CONTACTS_PHOTOS = ""flickr.photos.getContactsPhotos"";  public static final String METHOD_GET_CONTACTS_PUBLIC_PHOTOS = ""flickr.photos.getContactsPublicPhotos"";  public static final String METHOD_GET_CONTEXT = ""flickr.photos.getContext"";  public static final String METHOD_GET_COUNTS = ""flickr.photos.getCounts"";  public static final String METHOD_GET_EXIF = ""flickr.photos.getExif"";  public static final String METHOD_GET_FAVORITES = ""flickr.photos.getFavorites"";  public static final String METHOD_GET_INFO = ""flickr.photos.getInfo"";  public static final String METHOD_GET_NOT_IN_SET = ""flickr.photos.getNotInSet"";  public static final String METHOD_GET_PERMS = ""flickr.photos.getPerms"";  public static final String METHOD_GET_RECENT = ""flickr.photos.getRecent"";  public static final String METHOD_GET_SIZES = ""flickr.photos.getSizes"";  public static final String METHOD_GET_UNTAGGED = ""flickr.photos.getUntagged"";  public static final String METHOD_GET_WITH_GEO_DATA = ""flickr.photos.getWithGeoData"";  public static final String METHOD_GET_WITHOUT_GEO_DATA = ""flickr.photos.getWithoutGeoData"";  public static final String METHOD_RECENTLY_UPDATED = ""flickr.photos.recentlyUpdated"";  public static final String METHOD_REMOVE_TAG = ""flickr.photos.removeTag"";  public static final String METHOD_SEARCH = ""flickr.photos.search"";  public static final String METHOD_SET_CONTENTTYPE = ""flickr.photos.setContentType"";  public static final String METHOD_SET_DATES = ""flickr.photos.setDates"";  public static final String METHOD_SET_META = ""flickr.photos.setMeta"";  public static final String METHOD_SET_PERMS = ""flickr.photos.setPerms"";  public static final String METHOD_SET_SAFETYLEVEL = ""flickr.photos.setSafetyLevel"";  public static final String METHOD_SET_TAGS = ""flickr.photos.setTags"";  public static final String METHOD_GET_INTERESTINGNESS = ""flickr.interestingness.getList"";  private static final ThreadLocal<SimpleDateFormat> DATE_FORMATS = new ThreadLocal<SimpleDateFormat>() { @Override
        protected synchronized SimpleDateFormat initialValue() { return new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); } } ;  private GeoInterface geoInterface = null;  private final String apiKey;  private final String sharedSecret;  private final Transport transport;  public PhotosInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transport = transport; }  /**
     * Get the geo interface.
     * 
     * @return Access class to the flickr.photos.geo methods.
     */ public synchronized GeoInterface getGeoInterface() { if (geoInterface == null) { geoInterface = new GeoInterface(apiKey, sharedSecret, transport); } return geoInterface; }  /**
     * Add tags to a photo.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param photoId
     *            The photo ID
     * @param tags
     *            The tags
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void addTags(String photoId, String[] tags) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD_TAGS);  parameters.put(""photo_id"", photoId); parameters.put(""tags"", StringUtilities.join(tags, "" "", true));  Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Delete a photo from flickr.
     * 
     * This method requires authentication with 'delete' permission.
     * 
     * @param photoId
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void delete(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_DELETE);  parameters.put(""photo_id"", photoId);  // Note: This method requires an HTTP POST request. Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } // This method has no specific response - It returns an empty // sucess response if it completes without error. }  /**
     * Returns all visble sets and pools the photo belongs to.
     * 
     * This method does not require authentication.
     * 
     * @param photoId
     *            The photo to return information for.
     * @return a list of {@link PhotoContext} objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PhotoAllContext getAllContexts(String photoId) throws FlickrException { PhotoSetList<PhotoSet> setList = new PhotoSetList<PhotoSet>(); PoolList<Pool> poolList = new PoolList<Pool>(); PhotoAllContext allContext = new PhotoAllContext();  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_ALL_CONTEXTS);  parameters.put(""photo_id"", photoId);  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Collection<Element> photosElement = response.getPayloadCollection();  for (Element setElement : photosElement) { if (setElement.getTagName().equals(""set"")) { PhotoSet pset = new PhotoSet(); pset.setTitle(setElement.getAttribute(""title"")); pset.setSecret(setElement.getAttribute(""secret"")); pset.setId(setElement.getAttribute(""id"")); pset.setFarm(setElement.getAttribute(""farm"")); pset.setPrimary(setElement.getAttribute(""primary"")); pset.setServer(setElement.getAttribute(""server"")); pset.setViewCount(Integer.parseInt(setElement.getAttribute(""view_count""))); pset.setCommentCount(Integer.parseInt(setElement.getAttribute(""comment_count""))); pset.setCountPhoto(Integer.parseInt(setElement.getAttribute(""count_photo""))); pset.setCountVideo(Integer.parseInt(setElement.getAttribute(""count_video""))); setList.add(pset); allContext.setPhotoSetList(setList); } else if (setElement.getTagName().equals(""pool"")) { Pool pool = new Pool(); pool.setTitle(setElement.getAttribute(""title"")); pool.setId(setElement.getAttribute(""id"")); pool.setUrl(setElement.getAttribute(""url"")); pool.setIconServer(setElement.getAttribute(""iconserver"")); pool.setIconFarm(setElement.getAttribute(""iconfarm"")); pool.setMemberCount(Integer.parseInt(setElement.getAttribute(""members""))); pool.setPoolCount(Integer.parseInt(setElement.getAttribute(""pool_count""))); poolList.add(pool); allContext.setPoolList(poolList); } }  return allContext;  }  /**
     * Get photos from the user's contacts.
     * 
     * This method requires authentication with 'read' permission.
     * 
     * @param count
     *            The number of photos to return
     * @param justFriends
     *            Set to true to only show friends photos
     * @param singlePhoto
     *            Set to true to get a single photo
     * @param includeSelf
     *            Set to true to include self
     * @return The Collection of photos
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PhotoList<Photo> getContactsPhotos(int count, boolean justFriends, boolean singlePhoto, boolean includeSelf) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>();  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CONTACTS_PHOTOS);  if (count > 0) { parameters.put(""count"", Integer.toString(count)); } if (justFriends) { parameters.put(""just_friends"", ""1""); } if (singlePhoto) { parameters.put(""single_photo"", ""1""); } if (includeSelf) { parameters.put(""include_self"", ""1""); }  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); photos.setPage(""1""); photos.setPages(""1""); photos.setPerPage("""" + photoNodes.getLength()); photos.setTotal("""" + photoNodes.getLength()); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; }  /**
     * Get public photos from the user's contacts.
     * 
     * This method does not require authentication.
     * 
     * @see com.flickr4java.flickr.photos.Extras
     * @param userId
     *            The user ID
     * @param count
     *            The number of photos to return
     * @param justFriends
     *            True to include friends
     * @param singlePhoto
     *            True to get a single photo
     * @param includeSelf
     *            True to include self
     * @return A collection of Photo objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PhotoList<Photo> getContactsPublicPhotos(String userId, int count, boolean justFriends, boolean singlePhoto, boolean includeSelf)
            throws FlickrException { return getContactsPublicPhotos(userId, Extras.MIN_EXTRAS, count, justFriends, singlePhoto, includeSelf); }  public PhotoList<Photo> getContactsPublicPhotos(String userId, Set<String> extras, int count, boolean justFriends, boolean singlePhoto, boolean includeSelf)
            throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>();  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CONTACTS_PUBLIC_PHOTOS);  parameters.put(""user_id"", userId);  if (count > 0) { parameters.put(""count"", Integer.toString(count)); } if (justFriends) { parameters.put(""just_friends"", ""1""); } if (singlePhoto) { parameters.put(""single_photo"", ""1""); } if (includeSelf) { parameters.put(""include_self"", ""1""); }  if (extras != null) { StringBuffer sb = new StringBuffer(); Iterator<String> it = extras.iterator(); for (int i = 0; it.hasNext(); i++) { if (i > 0) { sb.append("",""); } sb.append(it.next()); } parameters.put(Extras.KEY_EXTRAS, sb.toString()); }  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); photos.setPage(""1""); photos.setPages(""1""); photos.setPerPage("""" + photoNodes.getLength()); photos.setTotal("""" + photoNodes.getLength()); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; }  /**
     * Get the context for the specified photo.
     * 
     * This method does not require authentication.
     * 
     * @param photoId
     *            The photo ID
     * @return The PhotoContext
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PhotoContext getContext(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CONTEXT);  parameters.put(""photo_id"", photoId);  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } PhotoContext photoContext = new PhotoContext(); Collection<Element> payload = response.getPayloadCollection(); for (Element payloadElement : payload) { String tagName = payloadElement.getTagName(); if (tagName.equals(""prevphoto"")) { Photo photo = new Photo(); photo.setId(payloadElement.getAttribute(""id"")); photo.setSecret(payloadElement.getAttribute(""secret"")); photo.setTitle(payloadElement.getAttribute(""title"")); photo.setFarm(payloadElement.getAttribute(""farm"")); photo.setUrl(payloadElement.getAttribute(""url"")); photoContext.setPreviousPhoto(photo); } else if (tagName.equals(""nextphoto"")) { Photo photo = new Photo(); photo.setId(payloadElement.getAttribute(""id"")); photo.setSecret(payloadElement.getAttribute(""secret"")); photo.setTitle(payloadElement.getAttribute(""title"")); photo.setFarm(payloadElement.getAttribute(""farm"")); photo.setUrl(payloadElement.getAttribute(""url"")); photoContext.setNextPhoto(photo); } } return photoContext; }  /**
     * Gets a collection of photo counts for the given date ranges for the calling user.
     * 
     * This method requires authentication with 'read' permission.
     * 
     * @param dates
     *            An array of dates, denoting the periods to return counts for. They should be specified smallest first.
     * @param takenDates
     *            An array of dates, denoting the periods to return counts for. They should be specified smallest first.
     * @return A Collection of Photocount objects
     */ public Collection<Photocount> getCounts(Date[] dates, Date[] takenDates) throws FlickrException { List<Photocount> photocounts = new ArrayList<Photocount>();  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_COUNTS);  if (dates == null && takenDates == null) { throw new IllegalArgumentException(""You must provide a value for either dates or takenDates""); }  if (dates != null) { List<String> dateList = new ArrayList<String>(); for (int i = 0; i < dates.length; i++) { dateList.add(String.valueOf(dates[i].getTime() / 1000L)); } parameters.put(""dates"", StringUtilities.join(dateList, "","")); }  if (takenDates != null) { List<String> takenDateList = new ArrayList<String>(); for (int i = 0; i < takenDates.length; i++) { takenDateList.add(String.valueOf(takenDates[i].getTime() / 1000L)); } parameters.put(""taken_dates"", StringUtilities.join(takenDateList, "","")); }  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photocountsElement = response.getPayload(); NodeList photocountNodes = photocountsElement.getElementsByTagName(""photocount""); for (int i = 0; i < photocountNodes.getLength(); i++) { Element photocountElement = (Element) photocountNodes.item(i); Photocount photocount = new Photocount(); photocount.setCount(photocountElement.getAttribute(""count"")); photocount.setFromDate(photocountElement.getAttribute(""fromdate"")); photocount.setToDate(photocountElement.getAttribute(""todate"")); photocounts.add(photocount); } return photocounts; }  /**
     * Get the Exif data for the photo.
     * 
     * The calling user must have permission to view the photo.
     * 
     * This method does not require authentication.
     * 
     * @param photoId
     *            The photo ID
     * @param secret
     *            The secret
     * @return A collection of Exif objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Collection<Exif> getExif(String photoId, String secret) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_EXIF);  parameters.put(""photo_id"", photoId); if (secret != null) { parameters.put(""secret"", secret); }  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } List<Exif> exifs = new ArrayList<Exif>(); Element photoElement = response.getPayload(); NodeList exifElements = photoElement.getElementsByTagName(""exif""); for (int i = 0; i < exifElements.getLength(); i++) { Element exifElement = (Element) exifElements.item(i); Exif exif = new Exif(); exif.setTagspace(exifElement.getAttribute(""tagspace"")); exif.setTagspaceId(exifElement.getAttribute(""tagspaceid"")); exif.setTag(exifElement.getAttribute(""tag"")); exif.setLabel(exifElement.getAttribute(""label"")); exif.setRaw(XMLUtilities.getChildValue(exifElement, ""raw"")); exif.setClean(XMLUtilities.getChildValue(exifElement, ""clean"")); exifs.add(exif); } return exifs; }  /**
     * Returns the list of people who have favorited a given photo.
     * 
     * This method does not require authentication.
     * 
     * @param photoId
     * @param perPage
     * @param page
     * @return List of {@link com.flickr4java.flickr.people.User}
     */ public Collection<User> getFavorites(String photoId, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>();  parameters.put(""method"", METHOD_GET_FAVORITES);  parameters.put(""photo_id"", photoId);  if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); }  if (page > 0) { parameters.put(""page"", Integer.toString(page)); }  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } List<User> users = new ArrayList<User>();  Element userRoot = response.getPayload(); NodeList userNodes = userRoot.getElementsByTagName(""person""); for (int i = 0; i < userNodes.getLength(); i++) { Element userElement = (Element) userNodes.item(i); User user = new User(); user.setId(userElement.getAttribute(""nsid"")); user.setUsername(userElement.getAttribute(""username"")); user.setFaveDate(userElement.getAttribute(""favedate"")); users.add(user); } return users; }  /**
     * Get all info for the specified photo.
     * 
     * The calling user must have permission to view the photo.
     * 
     * This method does not require authentication.
     * 
     * @param photoId
     *            The photo Id
     * @param secret
     *            The optional secret String
     * @return The Photo
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Photo getInfo(String photoId, String secret) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO);  parameters.put(""photo_id"", photoId); if (secret != null) { parameters.put(""secret"", secret); }  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photoElement = response.getPayload();  return PhotoUtils.createPhoto(photoElement); }  /**
     * Return a collection of Photo objects not in part of any sets.
     * 
     * This method requires authentication with 'read' permission.
     * 
     * @param perPage
     *            The per page
     * @param page
     *            The page
     * @return The collection of Photo objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PhotoList<Photo> getNotInSet(int perPage, int page) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>();  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", PhotosInterface.METHOD_GET_NOT_IN_SET);  RequestContext requestContext = RequestContext.getRequestContext();  List<String> extras = requestContext.getExtras(); if (extras.size() > 0) { parameters.put(""extras"", StringUtilities.join(extras, "","")); }  if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); }  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total""));  NodeList photoElements = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoElements.getLength(); i++) { Element photoElement = (Element) photoElements.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; }  /**
     * Get the permission information for the specified photo.
     * 
     * This method requires authentication with 'read' permission.
     * 
     * @param photoId
     *            The photo id
     * @return The Permissions object
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Permissions getPerms(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PERMS);  parameters.put(""photo_id"", photoId);  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element permissionsElement = response.getPayload(); Permissions permissions = new Permissions(); permissions.setId(permissionsElement.getAttribute(""id"")); permissions.setPublicFlag(""1"".equals(permissionsElement.getAttribute(""ispublic""))); permissions.setFamilyFlag(""1"".equals(permissionsElement.getAttribute(""isfamily""))); permissions.setFriendFlag(""1"".equals(permissionsElement.getAttribute(""isfriend""))); permissions.setComment(permissionsElement.getAttribute(""permcomment"")); permissions.setAddmeta(permissionsElement.getAttribute(""permaddmeta"")); return permissions; }  /**
     * Get a collection of recent photos.
     * 
     * This method does not require authentication.
     * 
     * @see com.flickr4java.flickr.photos.Extras
     * @param extras
     *            Set of extra-fields
     * @param perPage
     *            The number of photos per page
     * @param page
     *            The page offset
     * @return A collection of Photo objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PhotoList<Photo> getRecent(Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_RECENT);  if (extras != null && !extras.isEmpty()) { parameters.put(Extras.KEY_EXTRAS, StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); }  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); PhotoList<Photo> photos = PhotoUtils.createPhotoList(photosElement); return photos; }  /**
     * Get the available sizes of a Photo.
     * 
     * The calling user must have permission to view the photo.
     * 
     * This method uses no authentication.
     * 
     * @param photoId
     *            The photo ID
     * @return A collection of {@link Size}
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Collection<Size> getSizes(String photoId) throws FlickrException { return getSizes(photoId, false); }  /**
     * Get the available sizes of a Photo.
     * 
     * The boolean toggle allows to (api-)sign the call.
     * 
     * This way the calling user can retrieve sizes for <b>his own</b> private photos.
     * 
     * @param photoId
     *            The photo ID
     * @param sign
     *            toggle to allow optionally signing the call (Authenticate)
     * @return A collection of {@link Size}
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Collection<Size> getSizes(String photoId, boolean sign) throws FlickrException { SizeList<Size> sizes = new SizeList<>();  Map<String, Object> parameters = new HashMap<>(); parameters.put(""method"", METHOD_GET_SIZES);  parameters.put(""photo_id"", photoId);  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element sizesElement = response.getPayload(); sizes.setIsCanBlog(""1"".equals(sizesElement.getAttribute(""canblog""))); sizes.setIsCanDownload(""1"".equals(sizesElement.getAttribute(""candownload""))); sizes.setIsCanPrint(""1"".equals(sizesElement.getAttribute(""canprint""))); NodeList sizeNodes = sizesElement.getElementsByTagName(""size""); for (int i = 0; i < sizeNodes.getLength(); i++) { Element sizeElement = (Element) sizeNodes.item(i); Size size = new Size(); size.setLabel(sizeElement.getAttribute(""label"")); size.setWidth(sizeElement.getAttribute(""width"")); size.setHeight(sizeElement.getAttribute(""height"")); size.setSource(sizeElement.getAttribute(""source"")); size.setUrl(sizeElement.getAttribute(""url"")); size.setMedia(sizeElement.getAttribute(""media"")); sizes.add(size); } return sizes; }  /**
     * Get the collection of untagged photos.
     * 
     * This method requires authentication with 'read' permission.
     * 
     * @param perPage
     * @param page
     * @return A Collection of Photos
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PhotoList<Photo> getUntagged(int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_UNTAGGED);  if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); }  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); PhotoList<Photo> photos = PhotoUtils.createPhotoList(photosElement); return photos; }  /**
     * Returns a list of your geo-tagged photos.
     * 
     * This method requires authentication with 'read' permission.
     * 
     * @param minUploadDate
     *            Minimum upload date. Photos with an upload date greater than or equal to this value will be returned. Set to null to not specify a date.
     * @param maxUploadDate
     *            Maximum upload date. Photos with an upload date less than or equal to this value will be returned. Set to null to not specify a date.
     * @param minTakenDate
     *            Minimum taken date. Photos with an taken date greater than or equal to this value will be returned. Set to null to not specify a date.
     * @param maxTakenDate
     *            Maximum taken date. Photos with an taken date less than or equal to this value will be returned. Set to null to not specify a date.
     * @param privacyFilter
     *            Return photos only matching a certain privacy level. Valid values are:
     *            <ul>
     *            <li>1 public photos</li>
     *            <li>2 private photos visible to friends</li>
     *            <li>3 private photos visible to family</li>
     *            <li>4 private photos visible to friends and family</li>
     *            <li>5 completely private photos</li>
     *            </ul>
     *            Set to 0 to not specify a privacy Filter.
     * 
     * @see com.flickr4java.flickr.photos.Extras
     * @param sort
     *            The order in which to sort returned photos. Deafults to date-posted-desc. The possible values are: date-posted-asc, date-posted-desc,
     *            date-taken-asc, date-taken-desc, interestingness-desc, and interestingness-asc.
     * @param extras
     *            A set of Strings controlling the extra information to fetch for each returned record. Currently supported fields are: license, date_upload,
     *            date_taken, owner_name, icon_server, original_format, last_update, geo. Set to null or an empty set to not specify any extras.
     * @param perPage
     *            Number of photos to return per page. If this argument is 0, it defaults to 100. The maximum allowed value is 500.
     * @param page
     *            The page of results to return. If this argument is 0, it defaults to 1.
     * @return photos
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PhotoList<Photo> getWithGeoData(Date minUploadDate, Date maxUploadDate, Date minTakenDate, Date maxTakenDate, int privacyFilter, String sort,
            Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_WITH_GEO_DATA);  if (minUploadDate != null) { parameters.put(""min_upload_date"", Long.toString(minUploadDate.getTime() / 1000L)); } if (maxUploadDate != null) { parameters.put(""max_upload_date"", Long.toString(maxUploadDate.getTime() / 1000L)); } if (minTakenDate != null) { parameters.put(""min_taken_date"", Long.toString(minTakenDate.getTime() / 1000L)); } if (maxTakenDate != null) { parameters.put(""max_taken_date"", Long.toString(maxTakenDate.getTime() / 1000L)); } if (privacyFilter > 0) { parameters.put(""privacy_filter"", Integer.toString(privacyFilter)); } if (sort != null) { parameters.put(""sort"", sort); } if (extras != null && !extras.isEmpty()) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); }  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); PhotoList<Photo> photos = PhotoUtils.createPhotoList(photosElement); return photos; }  /**
     * Returns a list of your photos which haven't been geo-tagged.
     * 
     * This method requires authentication with 'read' permission.
     * 
     * @param minUploadDate
     *            Minimum upload date. Photos with an upload date greater than or equal to this value will be returned. Set to null to not specify a date.
     * @param maxUploadDate
     *            Maximum upload date. Photos with an upload date less than or equal to this value will be returned. Set to null to not specify a date.
     * @param minTakenDate
     *            Minimum taken date. Photos with an taken date greater than or equal to this value will be returned. Set to null to not specify a date.
     * @param maxTakenDate
     *            Maximum taken date. Photos with an taken date less than or equal to this value will be returned. Set to null to not specify a date.
     * @param privacyFilter
     *            Return photos only matching a certain privacy level. Valid values are:
     *            <ul>
     *            <li>1 public photos</li>
     *            <li>2 private photos visible to friends</li>
     *            <li>3 private photos visible to family</li>
     *            <li>4 private photos visible to friends and family</li>
     *            <li>5 completely private photos</li>
     *            </ul>
     *            Set to 0 to not specify a privacy Filter.
     * 
     * @see com.flickr4java.flickr.photos.Extras
     * @param sort
     *            The order in which to sort returned photos. Deafults to date-posted-desc. The possible values are: date-posted-asc, date-posted-desc,
     *            date-taken-asc, date-taken-desc, interestingness-desc, and interestingness-asc.
     * @param extras
     *            A set of Strings controlling the extra information to fetch for each returned record. Currently supported fields are: license, date_upload,
     *            date_taken, owner_name, icon_server, original_format, last_update, geo. Set to null or an empty set to not specify any extras.
     * @param perPage
     *            Number of photos to return per page. If this argument is 0, it defaults to 100. The maximum allowed value is 500.
     * @param page
     *            The page of results to return. If this argument is 0, it defaults to 1.
     * @return a photo list
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PhotoList<Photo> getWithoutGeoData(Date minUploadDate, Date maxUploadDate, Date minTakenDate, Date maxTakenDate, int privacyFilter, String sort,
            Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_WITHOUT_GEO_DATA);  if (minUploadDate != null) { parameters.put(""min_upload_date"", Long.toString(minUploadDate.getTime() / 1000L)); } if (maxUploadDate != null) { parameters.put(""max_upload_date"", Long.toString(maxUploadDate.getTime() / 1000L)); } if (minTakenDate != null) { parameters.put(""min_taken_date"", Long.toString(minTakenDate.getTime() / 1000L)); } if (maxTakenDate != null) { parameters.put(""max_taken_date"", Long.toString(maxTakenDate.getTime() / 1000L)); } if (privacyFilter > 0) { parameters.put(""privacy_filter"", Long.toString(privacyFilter)); } if (sort != null) { parameters.put(""sort"", sort); } if (extras != null && !extras.isEmpty()) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); }  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); PhotoList<Photo> photos = PhotoUtils.createPhotoList(photosElement); return photos; }  /**
     * Return a list of your photos that have been recently created or which have been recently modified. Recently modified may mean that the photo's metadata
     * (title, description, tags) may have been changed or a comment has been added (or just modified somehow :-)
     * 
     * This method requires authentication with 'read' permission.
     * 
     * @see com.flickr4java.flickr.photos.Extras
     * @param minDate
     *            Date indicating the date from which modifications should be compared. Must be given.
     * @param extras
     *            A set of Strings controlling the extra information to fetch for each returned record. Currently supported fields are: license, date_upload,
     *            date_taken, owner_name, icon_server, original_format, last_update, geo. Set to null or an empty set to not specify any extras.
     * @param perPage
     *            Number of photos to return per page. If this argument is 0, it defaults to 100. The maximum allowed value is 500.
     * @param page
     *            The page of results to return. If this argument is 0, it defaults to 1.
     * @return a list of photos
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PhotoList<Photo> recentlyUpdated(Date minDate, Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_RECENTLY_UPDATED);  parameters.put(""min_date"", Long.toString(minDate.getTime() / 1000L));  if (extras != null && !extras.isEmpty()) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); }  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); PhotoList<Photo> photos = PhotoUtils.createPhotoList(photosElement); return photos; }  /**
     * Remove a tag from a photo.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param tagId
     *            The tag ID
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void removeTag(String tagId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REMOVE_TAG);  parameters.put(""tag_id"", tagId);  Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Search for photos which match the given search parameters.
     * 
     * @param params
     *            The search parameters
     * @param perPage
     *            The number of photos to show per page
     * @param page
     *            The page offset
     * @return A PhotoList
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PhotoList<Photo> search(SearchParameters params, int perPage, int page) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>();  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SEARCH);  parameters.putAll(params.getAsParameters());  if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); }  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total""));  NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; }  /**
     * Search for interesting photos using the Flickr Interestingness algorithm.
     * 
     * @param params
     *            Any search parameters
     * @param perPage
     *            Number of items per page
     * @param page
     *            The page to start on
     * @return A PhotoList
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PhotoList<Photo> searchInterestingness(SearchParameters params, int perPage, int page) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>();  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INTERESTINGNESS);  parameters.putAll(params.getAsParameters());  if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); }  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total""));  NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); Photo photo = new Photo(); photo.setId(photoElement.getAttribute(""id""));  User owner = new User(); owner.setId(photoElement.getAttribute(""owner"")); photo.setOwner(owner);  photo.setSecret(photoElement.getAttribute(""secret"")); photo.setServer(photoElement.getAttribute(""server"")); photo.setFarm(photoElement.getAttribute(""farm"")); photo.setTitle(photoElement.getAttribute(""title"")); photo.setPublicFlag(""1"".equals(photoElement.getAttribute(""ispublic""))); photo.setFriendFlag(""1"".equals(photoElement.getAttribute(""isfriend""))); photo.setFamilyFlag(""1"".equals(photoElement.getAttribute(""isfamily""))); photos.add(photo); } return photos; }  /**
     * Set the content type of a photo.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @see com.flickr4java.flickr.Flickr#CONTENTTYPE_PHOTO
     * @see com.flickr4java.flickr.Flickr#CONTENTTYPE_SCREENSHOT
     * @see com.flickr4java.flickr.Flickr#CONTENTTYPE_OTHER
     * @param photoId
     *            The photo ID
     * @param contentType
     *            The contentType to set
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void setContentType(String photoId, String contentType) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_CONTENTTYPE);  parameters.put(""photo_id"", photoId); parameters.put(""content_type"", contentType);  Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Set the dates for the specified photo.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param photoId
     *            The photo ID
     * @param datePosted
     *            The date the photo was posted or null
     * @param dateTaken
     *            The date the photo was taken or null
     * @param dateTakenGranularity
     *            The granularity of the taken date or null
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void setDates(String photoId, Date datePosted, Date dateTaken, String dateTakenGranularity) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_DATES);  parameters.put(""photo_id"", photoId);  if (datePosted != null) { parameters.put(""date_posted"", Long.toString(datePosted.getTime() / 1000)); }  if (dateTaken != null) { parameters.put(""date_taken"", ((DateFormat) DATE_FORMATS.get()).format(dateTaken)); }  if (dateTakenGranularity != null) { parameters.put(""date_taken_granularity"", dateTakenGranularity); }  Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Set the meta data for the photo.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param photoId
     *            The photo ID
     * @param title
     *            The new title
     * @param description
     *            The new description
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void setMeta(String photoId, String title, String description) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_META);  parameters.put(""photo_id"", photoId); parameters.put(""title"", title); parameters.put(""description"", description);  Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Set the permissions for the photo.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param photoId
     *            The photo ID
     * @param permissions
     *            The permissions object
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void setPerms(String photoId, Permissions permissions) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_PERMS);  parameters.put(""photo_id"", photoId); parameters.put(""is_public"", permissions.isPublicFlag() ? ""1"" : ""0""); parameters.put(""is_friend"", permissions.isFriendFlag() ? ""1"" : ""0""); parameters.put(""is_family"", permissions.isFamilyFlag() ? ""1"" : ""0""); parameters.put(""perm_comment"", Integer.toString(permissions.getComment())); parameters.put(""perm_addmeta"", Integer.toString(permissions.getAddmeta()));  Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Set the safety level (adultness) of a photo.
     * <p>
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param photoId
     *            The photo ID
     * @param safetyLevel
     *            The safety level of the photo or null
     * @param hidden
     *            Hidden from public searches or not or null
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_SAFE
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_MODERATE
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_RESTRICTED
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void setSafetyLevel(String photoId, String safetyLevel, Boolean hidden) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_SAFETYLEVEL);  parameters.put(""photo_id"", photoId);  if (safetyLevel != null) { parameters.put(""safety_level"", safetyLevel); }  if (hidden != null) { parameters.put(""hidden"", hidden.booleanValue() ? ""1"" : ""0""); }  Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Set the tags for a photo.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param photoId
     *            The photo ID
     * @param tags
     *            The tag array
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void setTags(String photoId, String[] tags) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_TAGS);  parameters.put(""photo_id"", photoId); parameters.put(""tags"", StringUtilities.join(tags, "" "", true));  Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Get the photo for the specified ID. Currently maps to the getInfo() method.
     * 
     * @param id
     *            The ID
     * @return The Photo
     */ public Photo getPhoto(String id) throws FlickrException { return getPhoto(id, null); }  /**
     * Get the photo for the specified ID with the given secret. Currently maps to the getInfo() method.
     * 
     * @param id
     *            The ID
     * @param secret
     *            The secret
     * @return The Photo
     */ public Photo getPhoto(String id, String secret) throws FlickrException { return getInfo(id, secret); }  /**
     * Request an image from the Flickr-servers.<br>
     * Callers must close the stream upon completion.
     * <p>
     * 
     * At {@link Size} you can find constants for the available sizes.
     * 
     * @param photo
     *            A photo-object
     * @param size
     *            The Size
     * @return InputStream The InputStream
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public InputStream getImageAsStream(Photo photo, int size) throws FlickrException { try { String urlStr = """"; if (size == Size.SQUARE) { urlStr = photo.getSmallSquareUrl(); } else if (size == Size.THUMB) { urlStr = photo.getThumbnailUrl(); } else if (size == Size.SMALL) { urlStr = photo.getSmallUrl(); } else if (size == Size.MEDIUM) { urlStr = photo.getMediumUrl(); } else if (size == Size.LARGE) { urlStr = photo.getLargeUrl(); } else if (size == Size.LARGE_1600) { urlStr = photo.getLarge1600Url(); } else if (size == Size.LARGE_2048) { urlStr = photo.getLarge2048Url(); } else if (size == Size.ORIGINAL) { urlStr = photo.getOriginalUrl(); } else if (size == Size.SQUARE_LARGE) { urlStr = photo.getSquareLargeUrl(); } else if (size == Size.SMALL_320) { urlStr = photo.getSmall320Url(); } else if (size == Size.MEDIUM_640) { urlStr = photo.getMedium640Url(); } else if (size == Size.MEDIUM_800) { urlStr = photo.getMedium800Url(); } else if (size == Size.VIDEO_ORIGINAL) { urlStr = photo.getVideoOriginalUrl(); } else if (size == Size.VIDEO_PLAYER) { urlStr = photo.getVideoPlayerUrl(); } else if (size == Size.SITE_MP4) { urlStr = photo.getSiteMP4Url(); } else if (size == Size.MOBILE_MP4) { urlStr = photo.getMobileMp4Url(); } else if (size == Size.HD_MP4) { urlStr = photo.getHdMp4Url(); } else { throw new FlickrException(""0"", ""Unknown Photo-size""); } URL url = new URL(urlStr); HttpsURLConnection conn = (HttpsURLConnection) url.openConnection(); if (transport instanceof REST) { if (((REST) transport).isProxyAuth()) { conn.setRequestProperty(""Proxy-Authorization"", ""Basic "" + ((REST) transport).getProxyCredentials()); } } conn.connect(); return conn.getInputStream(); } catch (IOException e) { throw new FlickrException(e.getMessage(), e.getCause()); } }  /**
     * Request an image from the Flickr-servers.
     * <p>
     * 
     * At {@link Size} you can find constants for the available sizes.
     * 
     * @param photo
     *            A photo-object
     * @param size
     *            The size
     * @return An Image
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public BufferedImage getImage(Photo photo, int size) throws FlickrException { try { return ImageIO.read(getImageAsStream(photo, size)); } catch (IOException e) { throw new FlickrException(e.getMessage(), e.getCause()); } }  /**
     * Download of an image by URL.
     * 
     * @param urlStr
     *            The URL of a Photo
     * @return BufferedImage The The Image
     */ public BufferedImage getImage(String urlStr) throws FlickrException { InputStream in = null; try { URL url = new URL(urlStr); HttpsURLConnection conn = (HttpsURLConnection) url.openConnection(); if (transport instanceof REST) { if (((REST) transport).isProxyAuth()) { conn.setRequestProperty(""Proxy-Authorization"", ""Basic "" + ((REST) transport).getProxyCredentials()); } } conn.connect(); in = conn.getInputStream(); return ImageIO.read(in); } catch (IOException e) { throw new FlickrException(e.getMessage(), e.getCause()); } finally { IOUtilities.close(in); } } }  "
src/main/java/com/flickr4java/flickr/photos/Pool.java,"package com.flickr4java.flickr.photos;

public class Pool {

	 private String title;
	 private String id;
	 private String url;
	 private String iconServer;
	 private String iconFarm;
	 private int memberCount;
	 private int poolCount;
	 
	public String getTitle() {
		return title;
	}
	public void setTitle(String title) {
		this.title = title;
	}
	public String getId() {
		return id;
	}
	public void setId(String id) {
		this.id = id;
	}
	public String getUrl() {
		return url;
	}
	public void setUrl(String url) {
		this.url = url;
	}
	public String getIconServer() {
		return iconServer;
	}
	public void setIconServer(String iconServer) {
		this.iconServer = iconServer;
	}
	public String getIconFarm() {
		return iconFarm;
	}
	public void setIconFarm(String iconFarm) {
		this.iconFarm = iconFarm;
	}
	public int getMemberCount() {
		return memberCount;
	}
	public void setMemberCount(int memberCount) {
		this.memberCount = memberCount;
	}
	public int getPoolCount() {
		return poolCount;
	}
	public void setPoolCount(int poolCount) {
		this.poolCount = poolCount;
	}

	
}
",package com.flickr4java.flickr.photos; public class Pool { private String title; private String id; private String url; private String iconServer; private String iconFarm; private int memberCount; private int poolCount; public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } public String getIconServer() { return iconServer; } public void setIconServer(String iconServer) { this.iconServer = iconServer; } public String getIconFarm() { return iconFarm; } public void setIconFarm(String iconFarm) { this.iconFarm = iconFarm; } public int getMemberCount() { return memberCount; } public void setMemberCount(int memberCount) { this.memberCount = memberCount; } public int getPoolCount() { return poolCount; } public void setPoolCount(int poolCount) { this.poolCount = poolCount; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.photos; public class Pool { private String title; private String id; private String url; private String iconServer; private String iconFarm; private int memberCount; private int poolCount; public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } public String getIconServer() { return iconServer; } public void setIconServer(String iconServer) { this.iconServer = iconServer; } public String getIconFarm() { return iconFarm; } public void setIconFarm(String iconFarm) { this.iconFarm = iconFarm; } public int getMemberCount() { return memberCount; } public void setMemberCount(int memberCount) { this.memberCount = memberCount; } public int getPoolCount() { return poolCount; } public void setPoolCount(int poolCount) { this.poolCount = poolCount; } } ,"package com.flickr4java.flickr.photos;  public class Pool {  private String title; private String id; private String url; private String iconServer; private String iconFarm; private int memberCount; private int poolCount; 	  public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } public String getIconServer() { return iconServer; } public void setIconServer(String iconServer) { this.iconServer = iconServer; } public String getIconFarm() { return iconFarm; } public void setIconFarm(String iconFarm) { this.iconFarm = iconFarm; } public int getMemberCount() { return memberCount; } public void setMemberCount(int memberCount) { this.memberCount = memberCount; } public int getPoolCount() { return poolCount; } public void setPoolCount(int poolCount) { this.poolCount = poolCount; } 
	 }  "
src/main/java/com/flickr4java/flickr/photos/PoolList.java,"package com.flickr4java.flickr.photos;

import java.util.ArrayList;

public class PoolList<E> extends ArrayList<Pool> {

	/**
	 * 
	 */
	private static final long serialVersionUID = -6749839441338939904L;
	
}
",package com.flickr4java.flickr.photos; import java.util.ArrayList; public class PoolList<E> extends ArrayList<Pool> { private static final long serialVersionUID = -6749839441338939904L; },0 0 0 0 0 0,package com.flickr4java.flickr.photos; import java.util.ArrayList; public class PoolList<E> extends ArrayList<Pool> { private static final long serialVersionUID = -6749839441338939904L; } ,"package com.flickr4java.flickr.photos;  import java.util.ArrayList;  public class PoolList<E> extends ArrayList<Pool> {  /**
	 * 
	 */ private static final long serialVersionUID = -6749839441338939904L; 	 }  "
src/main/java/com/flickr4java/flickr/photos/SearchParameters.java,"
package com.flickr4java.flickr.photos;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.util.StringUtilities;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * @author Anthony Eden
 * @version $Id: SearchParameters.java,v 1.20 2009/07/23 20:41:03 x-mago Exp $
 */
public class SearchParameters {

    private String userId;

    private String groupId;

    private String woeId;

    private String media;

    private String contacts;

    private String[] tags;

    private String tagMode;

    private String text;

    private Date minUploadDate;

    private Date maxUploadDate;

    private Date minTakenDate;

    private Date maxTakenDate;

    private Date interestingnessDate;

    private String license;

    private Set<String> extras;

    private String[] bbox;

    private String placeId;

    private int accuracy = 0;

    private int privacyFilter = 0;

    private String safeSearch;

    private String[] machineTags;

    private String machineTagMode;

    private String latitude;

    private String longitude;

    private double radius = -1;

    private String radiusUnits;

    private boolean hasGeo = false;

    private boolean inGallery = false;

    private boolean isCommons = false;

    private boolean isGetty = false;

    public static final ThreadLocal<SimpleDateFormat> DATE_FORMATS = new ThreadLocal<SimpleDateFormat>() {
        @Override
        protected synchronized SimpleDateFormat initialValue() {
            return new SimpleDateFormat(""yyyy-MM-dd"");
        }
    };

    public static final ThreadLocal<SimpleDateFormat> MYSQL_DATE_FORMATS = new ThreadLocal<SimpleDateFormat>() {
        @Override
        protected synchronized SimpleDateFormat initialValue() {
            return new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
        }
    };

    /** order argument */
    public static int DATE_POSTED_DESC = 0;

    /** order argument */
    public static int DATE_POSTED_ASC = 1;

    /** order argument */
    public static int DATE_TAKEN_DESC = 2;

    /** order argument */
    public static int DATE_TAKEN_ASC = 3;

    /** order argument */
    public static int INTERESTINGNESS_DESC = 4;

    /** order argument */
    public static int INTERESTINGNESS_ASC = 5;

    /** order argument */
    public static int RELEVANCE = 6;

    private int sort = 0;

    public SearchParameters() {

    }

    /**
     * Optional to use, if BBox is set.
     * <p>
     * Defaults to maximum value if not specified.
     * 
     * @param accuracy
     *            from 1 to 16
     * @see com.flickr4java.flickr.Flickr#ACCURACY_WORLD
     * @see com.flickr4java.flickr.Flickr#ACCURACY_COUNTRY
     * @see com.flickr4java.flickr.Flickr#ACCURACY_REGION
     * @see com.flickr4java.flickr.Flickr#ACCURACY_CITY
     * @see com.flickr4java.flickr.Flickr#ACCURACY_STREET
     */
    public void setAccuracy(int accuracy) {
        this.accuracy = accuracy;
    }

    public int getAccuracy() {
        return accuracy;
    }

    /**
     * @return the privacyFilter
     */
    public int getPrivacyFilter() {
        return privacyFilter;
    }

    /**
     * @param privacyFilter
     *            Return photos only matching a certain privacy level.
     * 
     *            This only applies when making an authenticated call to view photos you own. Valid values are:
     *            <ul>
     *            <li>1 public photos
     *            <li>2 private photos visible to friends
     *            <li>3 private photos visible to family
     *            <li>4 private photos visible to friends and family
     *            <li>5 completely private photos
     *            </ul>
     */
    public void setPrivacyFilter(int privacyFilter) {
        this.privacyFilter = privacyFilter;
    }

    public String getGroupId() {
        return groupId;
    }

    /**
     * The id of a group who's pool to search. If specified, only matching photos posted to the group's pool will be returned.
     * 
     * @param groupId
     */
    public void setGroupId(String groupId) {
        this.groupId = groupId;
    }

    /**
     * Any photo that has been geotagged.
     * <p>
     * 
     * Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against
     * ""parameterless searches"" for queries without a geo component.
     * <p>
     * 
     * A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters &mdash; If no limiting factor is
     * passed flickr will return only photos added in the last 12 hours (though flickr may extend the limit in the future).
     * 
     * @param hasGeo
     */
    public void setHasGeo(boolean hasGeo) {
        this.hasGeo = hasGeo;
    }

    public boolean getHasGeo() {
        return hasGeo;
    }

    public String[] getTags() {
        return tags;
    }

    public void setTags(String[] tags) {
        this.tags = tags;
    }

    public String getTagMode() {
        return tagMode;
    }

    public void setTagMode(String tagMode) {
        this.tagMode = tagMode;
    }

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }

    public Date getMinUploadDate() {
        return minUploadDate;
    }

    public void setMinUploadDate(Date minUploadDate) {
        this.minUploadDate = minUploadDate;
    }

    public Date getMaxUploadDate() {
        return maxUploadDate;
    }

    public void setMaxUploadDate(Date maxUploadDate) {
        this.maxUploadDate = maxUploadDate;
    }

    public Date getMinTakenDate() {
        return minTakenDate;
    }

    public void setMinTakenDate(Date minTakenDate) {
        this.minTakenDate = minTakenDate;
    }

    public Date getMaxTakenDate() {
        return maxTakenDate;
    }

    public void setMaxTakenDate(Date maxTakenDate) {
        this.maxTakenDate = maxTakenDate;
    }

    public String getLicense() {
        return license;
    }

    public void setLicense(String license) {
        this.license = license;
    }

    public Date getInterestingnessDate() {
        return interestingnessDate;
    }

    /**
     * Set the date, for which interesting Photos to request.
     * 
     * @param intrestingnessDate
     */
    public void setInterestingnessDate(Date intrestingnessDate) {
        this.interestingnessDate = intrestingnessDate;
    }

    /**
     * Set the machine tags, for which Photos to request.
     * 
     * @param tags
     */
    public void setMachineTags(String[] tags) {
        this.machineTags = tags;
    }

    public String[] getMachineTags() {
        return machineTags;
    }

    /**
     * Set the machine tags search mode to use when requesting photos
     * 
     * @param tagMode
     */
    public void setMachineTagMode(String tagMode) {
        this.machineTagMode = tagMode;
    }

    public String getMachineTagMode() {
        return machineTagMode;
    }

    /**
     * List of extra information to fetch for each returned record. Currently supported fields are: license, date_upload, date_taken, owner_name, icon_server,
     * original_format, last_update, geo, tags, machine_tags, o_dims, views, media, path_alias, url_sq, url_t, url_s, url_m, url_l, url_o,count_faves,count_comments,count_views
     * 
     * @param extras
     *            A set of extra-attributes
     * @see com.flickr4java.flickr.photos.Extras#ALL_EXTRAS
     * @see com.flickr4java.flickr.photos.Extras#MIN_EXTRAS
     */
    public void setExtras(Set<String> extras) {
        this.extras = extras;
    }
    
    public Set<String> getExtras() {
        return extras;
    }

    /**
     * 4 values defining the Bounding Box of the area that will be searched.
     * <p>
     * The 4 values represent the bottom-left corner of the box and the top-right corner, minimum_longitude, minimum_latitude, maximum_longitude,
     * maximum_latitude.
     * <p>
     * 
     * Longitude has a range of -180 to 180, latitude of -90 to 90. Defaults to -180, -90, 180, 90 if not specified.
     * <p>
     * 
     * Unlike standard photo queries, geo (or bounding box) queries will only return 250 results per page.
     * <p>
     * 
     * Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against
     * ""parameterless searches"" for queries without a geo component.
     * <p>
     * 
     * A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters. If no limiting factor is passed
     * flickr returns only photos added in the last 12 hours (though flickr may extend the limit in the future).
     * 
     * @param minimum_longitude
     * @param minimum_latitude
     * @param maximum_longitude
     * @param maximum_latitude
     */
    public void setBBox(String minimum_longitude, String minimum_latitude, String maximum_longitude, String maximum_latitude) {
        this.bbox = new String[] { minimum_longitude, minimum_latitude, maximum_longitude, maximum_latitude };
    }

    public String[] getBBox() {
        return bbox;
    }

    /**
     * Optional safe search setting.<br>
     * Un-authed calls can only see Safe content.
     * 
     * @param level
     *            1, 2 or 3
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_SAFE
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_MODERATE
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_RESTRICTED
     */
    public void setSafeSearch(String level) {
        this.safeSearch = level;
    }

    public String getSafeSearch() {
        return safeSearch;
    }

    public int getSort() {
        return sort;
    }

    /**
     * Set the sort-order.
     * <p>
     * The default is <a href=""#DATE_POSTED_DESC"">DATE_POSTED_DESC</a>
     * 
     * @see com.flickr4java.flickr.photos.SearchParameters#DATE_POSTED_ASC
     * @see com.flickr4java.flickr.photos.SearchParameters#DATE_POSTED_DESC
     * @see com.flickr4java.flickr.photos.SearchParameters#DATE_TAKEN_ASC
     * @see com.flickr4java.flickr.photos.SearchParameters#DATE_TAKEN_DESC
     * @see com.flickr4java.flickr.photos.SearchParameters#INTERESTINGNESS_ASC
     * @see com.flickr4java.flickr.photos.SearchParameters#INTERESTINGNESS_DESC
     * @see com.flickr4java.flickr.photos.SearchParameters#RELEVANCE
     * @param order
     */
    public void setSort(int order) {
        this.sort = order;
    }

    /**
     * @return A placeId
     * @see com.flickr4java.flickr.places.PlacesInterface#resolvePlaceId(String)
     */
    public String getPlaceId() {
        return placeId;
    }

    /**
     * PlaceId only used when bbox not set.
     * 
     * Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against
     * ""parameterless searches"" for queries without a geo component.
     * <p>
     * 
     * A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters &mdash; If no limiting factor is
     * passed we return only photos added in the last 12 hours (though we may extend the limit in the future).
     * 
     * @param placeId
     * @see com.flickr4java.flickr.places.PlacesInterface#resolvePlaceId(String)
     * @see com.flickr4java.flickr.places.Place#getPlaceId()
     * @see com.flickr4java.flickr.places.Location#getPlaceId()
     */
    public void setPlaceId(String placeId) {
        this.placeId = placeId;
    }

    public String getWoeId() {
        return woeId;
    }

    /**
     * A Where on Earth identifier to use to filter photo clusters.<br>
     * For example all the photos clustered by locality in the United States (WOE ID 23424977).<br>
     * (not used if bbox argument is present).
     * <p>
     * 
     * Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against
     * ""parameterless searches"" for queries without a geo component.
     * <p>
     * 
     * A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters. If no limiting factor is passed we
     * return only photos added in the last 12 hours (though flickr may extend the limit in the future).
     * <p>
     * 
     * @param woeId
     * @see com.flickr4java.flickr.places.Place#getWoeId()
     * @see com.flickr4java.flickr.places.Location#getWoeId()
     */
    public void setWoeId(String woeId) {
        this.woeId = woeId;
    }

    public String getMedia() {
        return media;
    }

    /**
     * Filter results by media type. Possible values are all (default), photos or videos.
     * 
     * @param media
     */
    public void setMedia(String media) throws FlickrException {
        if (media.equals(""all"") || media.equals(""photos"") || media.equals(""videos"")) {
            this.media = media;
        } else {
            throw new FlickrException(""0"", ""Media type is not valid."");
        }
    }

    public String getContacts() {
        return contacts;
    }

    /**
     * Search your contacts. Valid arguments are either 'all' or 'ff' for just friends and family.
     * <p>
     * 
     * It requires that the ""user_id"" field also be set and allows you to limit queries to only photos belonging to that user's photos. As in : All my contacts
     * photos tagged ""aaron"". (Experimental)
     * 
     * @param contacts
     */
    public void setContacts(String contacts) {
        this.contacts = contacts;
    }

    public Map<String, Object> getAsParameters() {
        Map<String, Object> parameters = new HashMap<String, Object>();

        String lat = getLatitude();
        if (lat != null) {
            parameters.put(""lat"", lat);
        }

        String lon = getLongitude();
        if (lon != null) {
            parameters.put(""lon"", lon);
        }

        double radius = getRadius();
        if (radius > 0) {
            parameters.put(""radius"", Double.toString(radius));
        }

        String radiusUnits = getRadiusUnits();
        if (radiusUnits != null) {
            parameters.put(""radius_units"", radiusUnits);
        }

        String media = getMedia();
        if (media != null) {
            parameters.put(""media"", media);
        }

        String userId = getUserId();
        if (userId != null) {
            parameters.put(""user_id"", userId);
            String contacts = getContacts();
            if (contacts != null) {
                parameters.put(""contacts"", contacts);
            }
        }

        String groupId = getGroupId();
        if (groupId != null) {
            parameters.put(""group_id"", groupId);
        }

        String[] tags = getTags();
        if (tags != null) {
            parameters.put(""tags"", StringUtilities.join(tags, "",""));
        }

        String tagMode = getTagMode();
        if (tagMode != null) {
            parameters.put(""tag_mode"", tagMode);
        }

        String[] mtags = getMachineTags();
        if (mtags != null) {
            parameters.put(""machine_tags"", StringUtilities.join(mtags, "",""));
        }

        String mtagMode = getMachineTagMode();
        if (mtagMode != null) {
            parameters.put(""machine_tag_mode"", mtagMode);
        }

        String text = getText();
        if (text != null) {
            parameters.put(""text"", text);
        }

        Date minUploadDate = getMinUploadDate();
        if (minUploadDate != null) {
            parameters.put(""min_upload_date"", Long.toString(minUploadDate.getTime() / 1000L));
        }

        Date maxUploadDate = getMaxUploadDate();
        if (maxUploadDate != null) {
            parameters.put(""max_upload_date"", Long.toString(maxUploadDate.getTime() / 1000L));
        }

        Date minTakenDate = getMinTakenDate();
        if (minTakenDate != null) {
            parameters.put(""min_taken_date"", ((DateFormat) MYSQL_DATE_FORMATS.get()).format(minTakenDate));
        }

        Date maxTakenDate = getMaxTakenDate();
        if (maxTakenDate != null) {
            parameters.put(""max_taken_date"", ((DateFormat) MYSQL_DATE_FORMATS.get()).format(maxTakenDate));
        }

        String license = getLicense();
        if (license != null) {
            parameters.put(""license"", license);
        }

        Date intrestingnessDate = getInterestingnessDate();
        if (intrestingnessDate != null) {
            parameters.put(""date"", ((DateFormat) DATE_FORMATS.get()).format(intrestingnessDate));
        }

        String[] bbox = getBBox();
        if (bbox != null) {
            parameters.put(""bbox"", StringUtilities.join(bbox, "",""));
            if (accuracy > 0) {
                parameters.put(""accuracy"", Integer.toString(accuracy));
            }
        } else {
            String woeId = getWoeId();
            if (woeId != null) {
                parameters.put(""woe_id"", woeId);
            }
        }

        String safeSearch = getSafeSearch();
        if (safeSearch != null) {
            parameters.put(""safe_search"", safeSearch);
        }

        boolean hasGeo = getHasGeo();
        if (hasGeo) {
            parameters.put(""has_geo"", ""true"");
        }

        boolean inGallery = getInGallery();
        if (inGallery) {
            parameters.put(""in_gallery"", ""true"");
        }

        boolean isCommons = getIsCommons();
        if (isCommons) {
            parameters.put(""is_commons"", ""true"");
        }

        boolean isGetty = getIsGetty();
        if (isGetty) {
            parameters.put(""is_getty"", ""true"");
        }

        if (privacyFilter > 0) {
            parameters.put(""privacy_filter"", Integer.toString(privacyFilter));
        }

        if (extras != null && !extras.isEmpty()) {
            parameters.put(""extras"", StringUtilities.join(extras, "",""));
        }

        if (sort != DATE_POSTED_DESC) {
            String sortArg = null;
            if (sort == DATE_POSTED_ASC) {
                sortArg = ""date-posted-asc"";
            }
            if (sort == DATE_TAKEN_DESC) {
                sortArg = ""date-taken-desc"";
            }
            if (sort == DATE_TAKEN_ASC) {
                sortArg = ""date-taken-asc"";
            }
            if (sort == INTERESTINGNESS_DESC) {
                sortArg = ""interestingness-desc"";
            }
            if (sort == INTERESTINGNESS_ASC) {
                sortArg = ""interestingness-asc"";
            }
            if (sort == RELEVANCE) {
                sortArg = ""relevance"";
            }
            if (sortArg != null) {
                parameters.put(""sort"", sortArg);
            }
        }

        if (placeId != null && !placeId.isEmpty()) {
            parameters.put(""place_id"", placeId);
        }

        return parameters;
    }

    public void setLatitude(String lat) {
        latitude = lat;
    }

    public void setRadius(double r) {
        radius = r;
    }

    public void setRadius(int r) {
        radius = r;
    }

    public void setLongitude(String lon) {
        longitude = lon;
    }

    public void setRadiusUnits(String units) {
        radiusUnits = units;
    }

    public String getLatitude() {
        return latitude;
    }

    public String getLongitude() {
        return longitude;
    }

    public double getRadius() {
        return radius;
    }

    public String getRadiusUnits() {
        return radiusUnits;
    }

    public String getUserId() {
        return userId;
    }

    public void setUserId(String userId) {
        this.userId = userId;
    }

    public void setInGallery(boolean inGallery) {
        this.inGallery = inGallery;
    }

    public boolean getInGallery() {
        return inGallery;
    }

    public void setIsCommons(boolean isCommons) {
        this.isCommons = isCommons;
    }

    public boolean getIsCommons() {
        return isCommons;
    }

    public void setIsGetty(boolean isGetty) {
        this.isGetty = isGetty;
    }

    public boolean getIsGetty() {
        return isGetty;
    }
}
","package com.flickr4java.flickr.photos; public class SearchParameters { private String userId; private String groupId; private String woeId; private String media; private String contacts; private String[] tags; private String tagMode; private String text; private Date minUploadDate; private Date maxUploadDate; private Date minTakenDate; private Date maxTakenDate; private Date interestingnessDate; private String license; private Set<String> extras; private String[] bbox; private String placeId; private int accuracy = 0; private int privacyFilter = 0; private String safeSearch; private String[] machineTags; private String machineTagMode; private String latitude; private String longitude; private double radius = -1; private String radiusUnits; private boolean hasGeo = false; private boolean inGallery = false; private boolean isCommons = false; private boolean isGetty = false; public static final ThreadLocal<SimpleDateFormat> DATE_FORMATS = new ThreadLocal<SimpleDateFormat>() { @Override
        protected synchronized SimpleDateFormat initialValue() { return new SimpleDateFormat(""yyyy-MM-dd""); } } ; public static final ThreadLocal<SimpleDateFormat> MYSQL_DATE_FORMATS = new ThreadLocal<SimpleDateFormat>() { @Override
        protected synchronized SimpleDateFormat initialValue() { return new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); } } ; public static int DATE_POSTED_DESC = 0; public static int DATE_POSTED_ASC = 1; public static int DATE_TAKEN_DESC = 2; public static int DATE_TAKEN_ASC = 3; public static int INTERESTINGNESS_DESC = 4; public static int INTERESTINGNESS_ASC = 5; public static int RELEVANCE = 6; private int sort = 0; public SearchParameters() { } public void setAccuracy(int accuracy) { this.accuracy = accuracy; } public int getAccuracy() { return accuracy; } public int getPrivacyFilter() { return privacyFilter; } public void setPrivacyFilter(int privacyFilter) { this.privacyFilter = privacyFilter; } public String getGroupId() { return groupId; } public void setGroupId(String groupId) { this.groupId = groupId; } public void setHasGeo(boolean hasGeo) { this.hasGeo = hasGeo; } public boolean getHasGeo() { return hasGeo; } public String[] getTags() { return tags; } public void setTags(String[] tags) { this.tags = tags; } public String getTagMode() { return tagMode; } public void setTagMode(String tagMode) { this.tagMode = tagMode; } public String getText() { return text; } public void setText(String text) { this.text = text; } public Date getMinUploadDate() { return minUploadDate; } public void setMinUploadDate(Date minUploadDate) { this.minUploadDate = minUploadDate; } public Date getMaxUploadDate() { return maxUploadDate; } public void setMaxUploadDate(Date maxUploadDate) { this.maxUploadDate = maxUploadDate; } public Date getMinTakenDate() { return minTakenDate; } public void setMinTakenDate(Date minTakenDate) { this.minTakenDate = minTakenDate; } public Date getMaxTakenDate() { return maxTakenDate; } public void setMaxTakenDate(Date maxTakenDate) { this.maxTakenDate = maxTakenDate; } public String getLicense() { return license; } public void setLicense(String license) { this.license = license; } public Date getInterestingnessDate() { return interestingnessDate; } public void setInterestingnessDate(Date intrestingnessDate) { this.interestingnessDate = intrestingnessDate; } public void setMachineTags(String[] tags) { this.machineTags = tags; } public String[] getMachineTags() { return machineTags; } public void setMachineTagMode(String tagMode) { this.machineTagMode = tagMode; } public String getMachineTagMode() { return machineTagMode; } public void setExtras(Set<String> extras) { this.extras = extras; } public Set<String> getExtras() { return extras; } public void setBBox(String minimum_longitude, String minimum_latitude, String maximum_longitude, String maximum_latitude) { this.bbox = new String[] { minimum_longitude, minimum_latitude, maximum_longitude, maximum_latitude } ; } public String[] getBBox() { return bbox; } public void setSafeSearch(String level) { this.safeSearch = level; } public String getSafeSearch() { return safeSearch; } public int getSort() { return sort; } public void setSort(int order) { this.sort = order; } public String getPlaceId() { return placeId; } public void setPlaceId(String placeId) { this.placeId = placeId; } public String getWoeId() { return woeId; } public void setWoeId(String woeId) { this.woeId = woeId; } public String getMedia() { return media; } public void setMedia(String media) throws FlickrException { if (media.equals(""all"") || media.equals(""photos"") || media.equals(""videos"")) { this.media = media; } else { throw new FlickrException(""0"", ""Media type is not valid.""); } } public String getContacts() { return contacts; } public void setContacts(String contacts) { this.contacts = contacts; } public Map<String, Object> getAsParameters() { Map<String, Object> parameters = new HashMap<String, Object>(); String lat = getLatitude(); if (lat != null) { parameters.put(""lat"", lat); } String lon = getLongitude(); if (lon != null) { parameters.put(""lon"", lon); } double radius = getRadius(); if (radius > 0) { parameters.put(""radius"", Double.toString(radius)); } String radiusUnits = getRadiusUnits(); if (radiusUnits != null) { parameters.put(""radius_units"", radiusUnits); } String media = getMedia(); if (media != null) { parameters.put(""media"", media); } String userId = getUserId(); if (userId != null) { parameters.put(""user_id"", userId); String contacts = getContacts(); if (contacts != null) { parameters.put(""contacts"", contacts); } } String groupId = getGroupId(); if (groupId != null) { parameters.put(""group_id"", groupId); } String[] tags = getTags(); if (tags != null) { parameters.put(""tags"", StringUtilities.join(tags, "","")); } String tagMode = getTagMode(); if (tagMode != null) { parameters.put(""tag_mode"", tagMode); } String[] mtags = getMachineTags(); if (mtags != null) { parameters.put(""machine_tags"", StringUtilities.join(mtags, "","")); } String mtagMode = getMachineTagMode(); if (mtagMode != null) { parameters.put(""machine_tag_mode"", mtagMode); } String text = getText(); if (text != null) { parameters.put(""text"", text); } Date minUploadDate = getMinUploadDate(); if (minUploadDate != null) { parameters.put(""min_upload_date"", Long.toString(minUploadDate.getTime() / 1000L)); } Date maxUploadDate = getMaxUploadDate(); if (maxUploadDate != null) { parameters.put(""max_upload_date"", Long.toString(maxUploadDate.getTime() / 1000L)); } Date minTakenDate = getMinTakenDate(); if (minTakenDate != null) { parameters.put(""min_taken_date"", ((DateFormat) MYSQL_DATE_FORMATS.get()).format(minTakenDate)); } Date maxTakenDate = getMaxTakenDate(); if (maxTakenDate != null) { parameters.put(""max_taken_date"", ((DateFormat) MYSQL_DATE_FORMATS.get()).format(maxTakenDate)); } String license = getLicense(); if (license != null) { parameters.put(""license"", license); } Date intrestingnessDate = getInterestingnessDate(); if (intrestingnessDate != null) { parameters.put(""date"", ((DateFormat) DATE_FORMATS.get()).format(intrestingnessDate)); } String[] bbox = getBBox(); if (bbox != null) { parameters.put(""bbox"", StringUtilities.join(bbox, "","")); if (accuracy > 0) { parameters.put(""accuracy"", Integer.toString(accuracy)); } } else { String woeId = getWoeId(); if (woeId != null) { parameters.put(""woe_id"", woeId); } } String safeSearch = getSafeSearch(); if (safeSearch != null) { parameters.put(""safe_search"", safeSearch); } boolean hasGeo = getHasGeo(); if (hasGeo) { parameters.put(""has_geo"", ""true""); } boolean inGallery = getInGallery(); if (inGallery) { parameters.put(""in_gallery"", ""true""); } boolean isCommons = getIsCommons(); if (isCommons) { parameters.put(""is_commons"", ""true""); } boolean isGetty = getIsGetty(); if (isGetty) { parameters.put(""is_getty"", ""true""); } if (privacyFilter > 0) { parameters.put(""privacy_filter"", Integer.toString(privacyFilter)); } if (extras != null && !extras.isEmpty()) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (sort != DATE_POSTED_DESC) { String sortArg = null; if (sort == DATE_POSTED_ASC) { sortArg = ""date-posted-asc""; } if (sort == DATE_TAKEN_DESC) { sortArg = ""date-taken-desc""; } if (sort == DATE_TAKEN_ASC) { sortArg = ""date-taken-asc""; } if (sort == INTERESTINGNESS_DESC) { sortArg = ""interestingness-desc""; } if (sort == INTERESTINGNESS_ASC) { sortArg = ""interestingness-asc""; } if (sort == RELEVANCE) { sortArg = ""relevance""; } if (sortArg != null) { parameters.put(""sort"", sortArg); } } if (placeId != null && !placeId.isEmpty()) { parameters.put(""place_id"", placeId); } return parameters; } public void setLatitude(String lat) { latitude = lat; } public void setRadius(double r) { radius = r; } public void setRadius(int r) { radius = r; } public void setLongitude(String lon) { longitude = lon; } public void setRadiusUnits(String units) { radiusUnits = units; } public String getLatitude() { return latitude; } public String getLongitude() { return longitude; } public double getRadius() { return radius; } public String getRadiusUnits() { return radiusUnits; } public String getUserId() { return userId; } public void setUserId(String userId) { this.userId = userId; } public void setInGallery(boolean inGallery) { this.inGallery = inGallery; } public boolean getInGallery() { return inGallery; } public void setIsCommons(boolean isCommons) { this.isCommons = isCommons; } public boolean getIsCommons() { return isCommons; } public void setIsGetty(boolean isGetty) { this.isGetty = isGetty; } public boolean getIsGetty() { return isGetty; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.photos; public class SearchParameters { private String userId; private String groupId; private String woeId; private String media; private String contacts; private String[] tags; private String tagMode; private String text; private Date minUploadDate; private Date maxUploadDate; private Date minTakenDate; private Date maxTakenDate; private Date interestingnessDate; private String license; private Set<String> extras; private String[] bbox; private String placeId; private int accuracy = 0; private int privacyFilter = 0; private String safeSearch; private String[] machineTags; private String machineTagMode; private String latitude; private String longitude; private double radius = -1; private String radiusUnits; private boolean hasGeo = false; private boolean inGallery = false; private boolean isCommons = false; private boolean isGetty = false; public static final ThreadLocal<SimpleDateFormat> DATE_FORMATS = new ThreadLocal<SimpleDateFormat>() { @Override
        protected synchronized SimpleDateFormat initialValue() { return new SimpleDateFormat(""yyyy-MM-dd""); } } ; public static final ThreadLocal<SimpleDateFormat> MYSQL_DATE_FORMATS = new ThreadLocal<SimpleDateFormat>() { @Override
        protected synchronized SimpleDateFormat initialValue() { return new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); } } ; public static int DATE_POSTED_DESC = 0; public static int DATE_POSTED_ASC = 1; public static int DATE_TAKEN_DESC = 2; public static int DATE_TAKEN_ASC = 3; public static int INTERESTINGNESS_DESC = 4; public static int INTERESTINGNESS_ASC = 5; public static int RELEVANCE = 6; private int sort = 0; public SearchParameters() { } public void setAccuracy(int accuracy) { this.accuracy = accuracy; } public int getAccuracy() { return accuracy; } public int getPrivacyFilter() { return privacyFilter; } public void setPrivacyFilter(int privacyFilter) { this.privacyFilter = privacyFilter; } public String getGroupId() { return groupId; } public void setGroupId(String groupId) { this.groupId = groupId; } public void setHasGeo(boolean hasGeo) { this.hasGeo = hasGeo; } public boolean getHasGeo() { return hasGeo; } public String[] getTags() { return tags; } public void setTags(String[] tags) { this.tags = tags; } public String getTagMode() { return tagMode; } public void setTagMode(String tagMode) { this.tagMode = tagMode; } public String getText() { return text; } public void setText(String text) { this.text = text; } public Date getMinUploadDate() { return minUploadDate; } public void setMinUploadDate(Date minUploadDate) { this.minUploadDate = minUploadDate; } public Date getMaxUploadDate() { return maxUploadDate; } public void setMaxUploadDate(Date maxUploadDate) { this.maxUploadDate = maxUploadDate; } public Date getMinTakenDate() { return minTakenDate; } public void setMinTakenDate(Date minTakenDate) { this.minTakenDate = minTakenDate; } public Date getMaxTakenDate() { return maxTakenDate; } public void setMaxTakenDate(Date maxTakenDate) { this.maxTakenDate = maxTakenDate; } public String getLicense() { return license; } public void setLicense(String license) { this.license = license; } public Date getInterestingnessDate() { return interestingnessDate; } public void setInterestingnessDate(Date intrestingnessDate) { this.interestingnessDate = intrestingnessDate; } public void setMachineTags(String[] tags) { this.machineTags = tags; } public String[] getMachineTags() { return machineTags; } public void setMachineTagMode(String tagMode) { this.machineTagMode = tagMode; } public String getMachineTagMode() { return machineTagMode; } public void setExtras(Set<String> extras) { this.extras = extras; } public Set<String> getExtras() { return extras; } public void setBBox(String minimum_longitude, String minimum_latitude, String maximum_longitude, String maximum_latitude) { this.bbox = new String[] { minimum_longitude, minimum_latitude, maximum_longitude, maximum_latitude } ; } public String[] getBBox() { return bbox; } public void setSafeSearch(String level) { this.safeSearch = level; } public String getSafeSearch() { return safeSearch; } public int getSort() { return sort; } public void setSort(int order) { this.sort = order; } public String getPlaceId() { return placeId; } public void setPlaceId(String placeId) { this.placeId = placeId; } public String getWoeId() { return woeId; } public void setWoeId(String woeId) { this.woeId = woeId; } public String getMedia() { return media; } public void setMedia(String media) throws FlickrException { if (media.equals(""all"") || media.equals(""photos"") || media.equals(""videos"")) { this.media = media; } else { throw new FlickrException(""0"", ""Media type is not valid.""); } } public String getContacts() { return contacts; } public void setContacts(String contacts) { this.contacts = contacts; } public Map<String, Object> getAsParameters() { Map<String, Object> parameters = new HashMap<String, Object>(); String lat = getLatitude(); if (lat != null) { parameters.put(""lat"", lat); } String lon = getLongitude(); if (lon != null) { parameters.put(""lon"", lon); } double radius = getRadius(); if (radius > 0) { parameters.put(""radius"", Double.toString(radius)); } String radiusUnits = getRadiusUnits(); if (radiusUnits != null) { parameters.put(""radius_units"", radiusUnits); } String media = getMedia(); if (media != null) { parameters.put(""media"", media); } String userId = getUserId(); if (userId != null) { parameters.put(""user_id"", userId); String contacts = getContacts(); if (contacts != null) { parameters.put(""contacts"", contacts); } } String groupId = getGroupId(); if (groupId != null) { parameters.put(""group_id"", groupId); } String[] tags = getTags(); if (tags != null) { parameters.put(""tags"", StringUtilities.join(tags, "","")); } String tagMode = getTagMode(); if (tagMode != null) { parameters.put(""tag_mode"", tagMode); } String[] mtags = getMachineTags(); if (mtags != null) { parameters.put(""machine_tags"", StringUtilities.join(mtags, "","")); } String mtagMode = getMachineTagMode(); if (mtagMode != null) { parameters.put(""machine_tag_mode"", mtagMode); } String text = getText(); if (text != null) { parameters.put(""text"", text); } Date minUploadDate = getMinUploadDate(); if (minUploadDate != null) { parameters.put(""min_upload_date"", Long.toString(minUploadDate.getTime() / 1000L)); } Date maxUploadDate = getMaxUploadDate(); if (maxUploadDate != null) { parameters.put(""max_upload_date"", Long.toString(maxUploadDate.getTime() / 1000L)); } Date minTakenDate = getMinTakenDate(); if (minTakenDate != null) { parameters.put(""min_taken_date"", ((DateFormat) MYSQL_DATE_FORMATS.get()).format(minTakenDate)); } Date maxTakenDate = getMaxTakenDate(); if (maxTakenDate != null) { parameters.put(""max_taken_date"", ((DateFormat) MYSQL_DATE_FORMATS.get()).format(maxTakenDate)); } String license = getLicense(); if (license != null) { parameters.put(""license"", license); } Date intrestingnessDate = getInterestingnessDate(); if (intrestingnessDate != null) { parameters.put(""date"", ((DateFormat) DATE_FORMATS.get()).format(intrestingnessDate)); } String[] bbox = getBBox(); if (bbox != null) { parameters.put(""bbox"", StringUtilities.join(bbox, "","")); if (accuracy > 0) { parameters.put(""accuracy"", Integer.toString(accuracy)); } } else { String woeId = getWoeId(); if (woeId != null) { parameters.put(""woe_id"", woeId); } } String safeSearch = getSafeSearch(); if (safeSearch != null) { parameters.put(""safe_search"", safeSearch); } boolean hasGeo = getHasGeo(); if (hasGeo) { parameters.put(""has_geo"", ""true""); } boolean inGallery = getInGallery(); if (inGallery) { parameters.put(""in_gallery"", ""true""); } boolean isCommons = getIsCommons(); if (isCommons) { parameters.put(""is_commons"", ""true""); } boolean isGetty = getIsGetty(); if (isGetty) { parameters.put(""is_getty"", ""true""); } if (privacyFilter > 0) { parameters.put(""privacy_filter"", Integer.toString(privacyFilter)); } if (extras != null && !extras.isEmpty()) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (sort != DATE_POSTED_DESC) { String sortArg = null; if (sort == DATE_POSTED_ASC) { sortArg = ""date-posted-asc""; } if (sort == DATE_TAKEN_DESC) { sortArg = ""date-taken-desc""; } if (sort == DATE_TAKEN_ASC) { sortArg = ""date-taken-asc""; } if (sort == INTERESTINGNESS_DESC) { sortArg = ""interestingness-desc""; } if (sort == INTERESTINGNESS_ASC) { sortArg = ""interestingness-asc""; } if (sort == RELEVANCE) { sortArg = ""relevance""; } if (sortArg != null) { parameters.put(""sort"", sortArg); } } if (placeId != null && !placeId.isEmpty()) { parameters.put(""place_id"", placeId); } return parameters; } public void setLatitude(String lat) { latitude = lat; } public void setRadius(double r) { radius = r; } public void setRadius(int r) { radius = r; } public void setLongitude(String lon) { longitude = lon; } public void setRadiusUnits(String units) { radiusUnits = units; } public String getLatitude() { return latitude; } public String getLongitude() { return longitude; } public double getRadius() { return radius; } public String getRadiusUnits() { return radiusUnits; } public String getUserId() { return userId; } public void setUserId(String userId) { this.userId = userId; } public void setInGallery(boolean inGallery) { this.inGallery = inGallery; } public boolean getInGallery() { return inGallery; } public void setIsCommons(boolean isCommons) { this.isCommons = isCommons; } public boolean getIsCommons() { return isCommons; } public void setIsGetty(boolean isGetty) { this.isGetty = isGetty; } public boolean getIsGetty() { return isGetty; } } "," package com.flickr4java.flickr.photos; 
import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.util.StringUtilities; 
import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.Date; import java.util.HashMap; import java.util.Map; import java.util.Set;  /**
 * @author Anthony Eden
 * @version $Id: SearchParameters.java,v 1.20 2009/07/23 20:41:03 x-mago Exp $
 */ public class SearchParameters {  private String userId;  private String groupId;  private String woeId;  private String media;  private String contacts;  private String[] tags;  private String tagMode;  private String text;  private Date minUploadDate;  private Date maxUploadDate;  private Date minTakenDate;  private Date maxTakenDate;  private Date interestingnessDate;  private String license;  private Set<String> extras;  private String[] bbox;  private String placeId;  private int accuracy = 0;  private int privacyFilter = 0;  private String safeSearch;  private String[] machineTags;  private String machineTagMode;  private String latitude;  private String longitude;  private double radius = -1;  private String radiusUnits;  private boolean hasGeo = false;  private boolean inGallery = false;  private boolean isCommons = false;  private boolean isGetty = false;  public static final ThreadLocal<SimpleDateFormat> DATE_FORMATS = new ThreadLocal<SimpleDateFormat>() { @Override
        protected synchronized SimpleDateFormat initialValue() { return new SimpleDateFormat(""yyyy-MM-dd""); } } ;  public static final ThreadLocal<SimpleDateFormat> MYSQL_DATE_FORMATS = new ThreadLocal<SimpleDateFormat>() { @Override
        protected synchronized SimpleDateFormat initialValue() { return new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); } } ;  /** order argument */ public static int DATE_POSTED_DESC = 0;  /** order argument */ public static int DATE_POSTED_ASC = 1;  /** order argument */ public static int DATE_TAKEN_DESC = 2;  /** order argument */ public static int DATE_TAKEN_ASC = 3;  /** order argument */ public static int INTERESTINGNESS_DESC = 4;  /** order argument */ public static int INTERESTINGNESS_ASC = 5;  /** order argument */ public static int RELEVANCE = 6;  private int sort = 0;  public SearchParameters() {  }  /**
     * Optional to use, if BBox is set.
     * <p>
     * Defaults to maximum value if not specified.
     * 
     * @param accuracy
     *            from 1 to 16
     * @see com.flickr4java.flickr.Flickr#ACCURACY_WORLD
     * @see com.flickr4java.flickr.Flickr#ACCURACY_COUNTRY
     * @see com.flickr4java.flickr.Flickr#ACCURACY_REGION
     * @see com.flickr4java.flickr.Flickr#ACCURACY_CITY
     * @see com.flickr4java.flickr.Flickr#ACCURACY_STREET
     */ public void setAccuracy(int accuracy) { this.accuracy = accuracy; }  public int getAccuracy() { return accuracy; }  /**
     * @return the privacyFilter
     */ public int getPrivacyFilter() { return privacyFilter; }  /**
     * @param privacyFilter
     *            Return photos only matching a certain privacy level.
     * 
     *            This only applies when making an authenticated call to view photos you own. Valid values are:
     *            <ul>
     *            <li>1 public photos
     *            <li>2 private photos visible to friends
     *            <li>3 private photos visible to family
     *            <li>4 private photos visible to friends and family
     *            <li>5 completely private photos
     *            </ul>
     */ public void setPrivacyFilter(int privacyFilter) { this.privacyFilter = privacyFilter; }  public String getGroupId() { return groupId; }  /**
     * The id of a group who's pool to search. If specified, only matching photos posted to the group's pool will be returned.
     * 
     * @param groupId
     */ public void setGroupId(String groupId) { this.groupId = groupId; }  /**
     * Any photo that has been geotagged.
     * <p>
     * 
     * Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against
     * ""parameterless searches"" for queries without a geo component.
     * <p>
     * 
     * A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters &mdash; If no limiting factor is
     * passed flickr will return only photos added in the last 12 hours (though flickr may extend the limit in the future).
     * 
     * @param hasGeo
     */ public void setHasGeo(boolean hasGeo) { this.hasGeo = hasGeo; }  public boolean getHasGeo() { return hasGeo; }  public String[] getTags() { return tags; }  public void setTags(String[] tags) { this.tags = tags; }  public String getTagMode() { return tagMode; }  public void setTagMode(String tagMode) { this.tagMode = tagMode; }  public String getText() { return text; }  public void setText(String text) { this.text = text; }  public Date getMinUploadDate() { return minUploadDate; }  public void setMinUploadDate(Date minUploadDate) { this.minUploadDate = minUploadDate; }  public Date getMaxUploadDate() { return maxUploadDate; }  public void setMaxUploadDate(Date maxUploadDate) { this.maxUploadDate = maxUploadDate; }  public Date getMinTakenDate() { return minTakenDate; }  public void setMinTakenDate(Date minTakenDate) { this.minTakenDate = minTakenDate; }  public Date getMaxTakenDate() { return maxTakenDate; }  public void setMaxTakenDate(Date maxTakenDate) { this.maxTakenDate = maxTakenDate; }  public String getLicense() { return license; }  public void setLicense(String license) { this.license = license; }  public Date getInterestingnessDate() { return interestingnessDate; }  /**
     * Set the date, for which interesting Photos to request.
     * 
     * @param intrestingnessDate
     */ public void setInterestingnessDate(Date intrestingnessDate) { this.interestingnessDate = intrestingnessDate; }  /**
     * Set the machine tags, for which Photos to request.
     * 
     * @param tags
     */ public void setMachineTags(String[] tags) { this.machineTags = tags; }  public String[] getMachineTags() { return machineTags; }  /**
     * Set the machine tags search mode to use when requesting photos
     * 
     * @param tagMode
     */ public void setMachineTagMode(String tagMode) { this.machineTagMode = tagMode; }  public String getMachineTagMode() { return machineTagMode; }  /**
     * List of extra information to fetch for each returned record. Currently supported fields are: license, date_upload, date_taken, owner_name, icon_server,
     * original_format, last_update, geo, tags, machine_tags, o_dims, views, media, path_alias, url_sq, url_t, url_s, url_m, url_l, url_o,count_faves,count_comments,count_views
     * 
     * @param extras
     *            A set of extra-attributes
     * @see com.flickr4java.flickr.photos.Extras#ALL_EXTRAS
     * @see com.flickr4java.flickr.photos.Extras#MIN_EXTRAS
     */ public void setExtras(Set<String> extras) { this.extras = extras; }      public Set<String> getExtras() { return extras; }  /**
     * 4 values defining the Bounding Box of the area that will be searched.
     * <p>
     * The 4 values represent the bottom-left corner of the box and the top-right corner, minimum_longitude, minimum_latitude, maximum_longitude,
     * maximum_latitude.
     * <p>
     * 
     * Longitude has a range of -180 to 180, latitude of -90 to 90. Defaults to -180, -90, 180, 90 if not specified.
     * <p>
     * 
     * Unlike standard photo queries, geo (or bounding box) queries will only return 250 results per page.
     * <p>
     * 
     * Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against
     * ""parameterless searches"" for queries without a geo component.
     * <p>
     * 
     * A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters. If no limiting factor is passed
     * flickr returns only photos added in the last 12 hours (though flickr may extend the limit in the future).
     * 
     * @param minimum_longitude
     * @param minimum_latitude
     * @param maximum_longitude
     * @param maximum_latitude
     */ public void setBBox(String minimum_longitude, String minimum_latitude, String maximum_longitude, String maximum_latitude) { this.bbox = new String[] { minimum_longitude, minimum_latitude, maximum_longitude, maximum_latitude } ; }  public String[] getBBox() { return bbox; }  /**
     * Optional safe search setting.<br>
     * Un-authed calls can only see Safe content.
     * 
     * @param level
     *            1, 2 or 3
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_SAFE
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_MODERATE
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_RESTRICTED
     */ public void setSafeSearch(String level) { this.safeSearch = level; }  public String getSafeSearch() { return safeSearch; }  public int getSort() { return sort; }  /**
     * Set the sort-order.
     * <p>
     * The default is <a href=""#DATE_POSTED_DESC"">DATE_POSTED_DESC</a>
     * 
     * @see com.flickr4java.flickr.photos.SearchParameters#DATE_POSTED_ASC
     * @see com.flickr4java.flickr.photos.SearchParameters#DATE_POSTED_DESC
     * @see com.flickr4java.flickr.photos.SearchParameters#DATE_TAKEN_ASC
     * @see com.flickr4java.flickr.photos.SearchParameters#DATE_TAKEN_DESC
     * @see com.flickr4java.flickr.photos.SearchParameters#INTERESTINGNESS_ASC
     * @see com.flickr4java.flickr.photos.SearchParameters#INTERESTINGNESS_DESC
     * @see com.flickr4java.flickr.photos.SearchParameters#RELEVANCE
     * @param order
     */ public void setSort(int order) { this.sort = order; }  /**
     * @return A placeId
     * @see com.flickr4java.flickr.places.PlacesInterface#resolvePlaceId(String)
     */ public String getPlaceId() { return placeId; }  /**
     * PlaceId only used when bbox not set.
     * 
     * Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against
     * ""parameterless searches"" for queries without a geo component.
     * <p>
     * 
     * A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters &mdash; If no limiting factor is
     * passed we return only photos added in the last 12 hours (though we may extend the limit in the future).
     * 
     * @param placeId
     * @see com.flickr4java.flickr.places.PlacesInterface#resolvePlaceId(String)
     * @see com.flickr4java.flickr.places.Place#getPlaceId()
     * @see com.flickr4java.flickr.places.Location#getPlaceId()
     */ public void setPlaceId(String placeId) { this.placeId = placeId; }  public String getWoeId() { return woeId; }  /**
     * A Where on Earth identifier to use to filter photo clusters.<br>
     * For example all the photos clustered by locality in the United States (WOE ID 23424977).<br>
     * (not used if bbox argument is present).
     * <p>
     * 
     * Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against
     * ""parameterless searches"" for queries without a geo component.
     * <p>
     * 
     * A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters. If no limiting factor is passed we
     * return only photos added in the last 12 hours (though flickr may extend the limit in the future).
     * <p>
     * 
     * @param woeId
     * @see com.flickr4java.flickr.places.Place#getWoeId()
     * @see com.flickr4java.flickr.places.Location#getWoeId()
     */ public void setWoeId(String woeId) { this.woeId = woeId; }  public String getMedia() { return media; }  /**
     * Filter results by media type. Possible values are all (default), photos or videos.
     * 
     * @param media
     */ public void setMedia(String media) throws FlickrException { if (media.equals(""all"") || media.equals(""photos"") || media.equals(""videos"")) { this.media = media; } else { throw new FlickrException(""0"", ""Media type is not valid.""); } }  public String getContacts() { return contacts; }  /**
     * Search your contacts. Valid arguments are either 'all' or 'ff' for just friends and family.
     * <p>
     * 
     * It requires that the ""user_id"" field also be set and allows you to limit queries to only photos belonging to that user's photos. As in : All my contacts
     * photos tagged ""aaron"". (Experimental)
     * 
     * @param contacts
     */ public void setContacts(String contacts) { this.contacts = contacts; }  public Map<String, Object> getAsParameters() { Map<String, Object> parameters = new HashMap<String, Object>();  String lat = getLatitude(); if (lat != null) { parameters.put(""lat"", lat); }  String lon = getLongitude(); if (lon != null) { parameters.put(""lon"", lon); }  double radius = getRadius(); if (radius > 0) { parameters.put(""radius"", Double.toString(radius)); }  String radiusUnits = getRadiusUnits(); if (radiusUnits != null) { parameters.put(""radius_units"", radiusUnits); }  String media = getMedia(); if (media != null) { parameters.put(""media"", media); }  String userId = getUserId(); if (userId != null) { parameters.put(""user_id"", userId); String contacts = getContacts(); if (contacts != null) { parameters.put(""contacts"", contacts); } }  String groupId = getGroupId(); if (groupId != null) { parameters.put(""group_id"", groupId); }  String[] tags = getTags(); if (tags != null) { parameters.put(""tags"", StringUtilities.join(tags, "","")); }  String tagMode = getTagMode(); if (tagMode != null) { parameters.put(""tag_mode"", tagMode); }  String[] mtags = getMachineTags(); if (mtags != null) { parameters.put(""machine_tags"", StringUtilities.join(mtags, "","")); }  String mtagMode = getMachineTagMode(); if (mtagMode != null) { parameters.put(""machine_tag_mode"", mtagMode); }  String text = getText(); if (text != null) { parameters.put(""text"", text); }  Date minUploadDate = getMinUploadDate(); if (minUploadDate != null) { parameters.put(""min_upload_date"", Long.toString(minUploadDate.getTime() / 1000L)); }  Date maxUploadDate = getMaxUploadDate(); if (maxUploadDate != null) { parameters.put(""max_upload_date"", Long.toString(maxUploadDate.getTime() / 1000L)); }  Date minTakenDate = getMinTakenDate(); if (minTakenDate != null) { parameters.put(""min_taken_date"", ((DateFormat) MYSQL_DATE_FORMATS.get()).format(minTakenDate)); }  Date maxTakenDate = getMaxTakenDate(); if (maxTakenDate != null) { parameters.put(""max_taken_date"", ((DateFormat) MYSQL_DATE_FORMATS.get()).format(maxTakenDate)); }  String license = getLicense(); if (license != null) { parameters.put(""license"", license); }  Date intrestingnessDate = getInterestingnessDate(); if (intrestingnessDate != null) { parameters.put(""date"", ((DateFormat) DATE_FORMATS.get()).format(intrestingnessDate)); }  String[] bbox = getBBox(); if (bbox != null) { parameters.put(""bbox"", StringUtilities.join(bbox, "","")); if (accuracy > 0) { parameters.put(""accuracy"", Integer.toString(accuracy)); } } else { String woeId = getWoeId(); if (woeId != null) { parameters.put(""woe_id"", woeId); } }  String safeSearch = getSafeSearch(); if (safeSearch != null) { parameters.put(""safe_search"", safeSearch); }  boolean hasGeo = getHasGeo(); if (hasGeo) { parameters.put(""has_geo"", ""true""); }  boolean inGallery = getInGallery(); if (inGallery) { parameters.put(""in_gallery"", ""true""); }  boolean isCommons = getIsCommons(); if (isCommons) { parameters.put(""is_commons"", ""true""); }  boolean isGetty = getIsGetty(); if (isGetty) { parameters.put(""is_getty"", ""true""); }  if (privacyFilter > 0) { parameters.put(""privacy_filter"", Integer.toString(privacyFilter)); }  if (extras != null && !extras.isEmpty()) { parameters.put(""extras"", StringUtilities.join(extras, "","")); }  if (sort != DATE_POSTED_DESC) { String sortArg = null; if (sort == DATE_POSTED_ASC) { sortArg = ""date-posted-asc""; } if (sort == DATE_TAKEN_DESC) { sortArg = ""date-taken-desc""; } if (sort == DATE_TAKEN_ASC) { sortArg = ""date-taken-asc""; } if (sort == INTERESTINGNESS_DESC) { sortArg = ""interestingness-desc""; } if (sort == INTERESTINGNESS_ASC) { sortArg = ""interestingness-asc""; } if (sort == RELEVANCE) { sortArg = ""relevance""; } if (sortArg != null) { parameters.put(""sort"", sortArg); } }  if (placeId != null && !placeId.isEmpty()) { parameters.put(""place_id"", placeId); }  return parameters; }  public void setLatitude(String lat) { latitude = lat; }  public void setRadius(double r) { radius = r; }  public void setRadius(int r) { radius = r; }  public void setLongitude(String lon) { longitude = lon; }  public void setRadiusUnits(String units) { radiusUnits = units; }  public String getLatitude() { return latitude; }  public String getLongitude() { return longitude; }  public double getRadius() { return radius; }  public String getRadiusUnits() { return radiusUnits; }  public String getUserId() { return userId; }  public void setUserId(String userId) { this.userId = userId; }  public void setInGallery(boolean inGallery) { this.inGallery = inGallery; }  public boolean getInGallery() { return inGallery; }  public void setIsCommons(boolean isCommons) { this.isCommons = isCommons; }  public boolean getIsCommons() { return isCommons; }  public void setIsGetty(boolean isGetty) { this.isGetty = isGetty; }  public boolean getIsGetty() { return isGetty; } }  "
src/main/java/com/flickr4java/flickr/photos/Size.java,"
package com.flickr4java.flickr.photos;

import java.util.Arrays;
import java.util.List;

/**
 * This class descibes a Size of a Photo.
 * <p>
 * 
 * @author Anthony Eden
 * @version $Id: Size.java,v 1.7 2009/07/23 20:41:03 x-mago Exp $
 */
public class Size {

    /**
     * Thumbnail, 100 on longest side.
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */
    public static final int THUMB = 0;

    /**
     * Small square 75x75.
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */
    public static final int SQUARE = 1;

    /**
     * Small, 240 on longest side.
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */
    public static final int SMALL = 2;

    /**
     * Medium, 500 on longest side.
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */
    public static final int MEDIUM = 3;

    /**
     * Large, 1024 on longest side (only exists for very large original images).
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */
    public static final int LARGE = 4;

    /**
     * Original image, either a jpg, gif or png, depending on source format.<br>
     * Only from pro-users original images are available!
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */
    public static final int ORIGINAL = 5;

    /**
     * Large Square 150x150
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */
    public static final int SQUARE_LARGE = 6;

    /**
     * Small, 320 px on the longest side
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */
    public static final int SMALL_320 = 7;

    /**
     * Medium, 640 px on the longest side
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */
    public static final int MEDIUM_640 = 8;

    /**
     * Medium, 640 px on the longest side
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */
    public static final int MEDIUM_800 = 9;

    /**
     * Large, 1600 px on the longest side
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */
    public static final int LARGE_1600 = 10;

    /**
     * Large, 2048 px on the longest side
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */
    public static final int LARGE_2048 = 11;

    /**
     * Video, for playback on the site.
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */
    public static final int SITE_MP4 = 12;

    /**
     * Video, for playback on the site.
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */
    public static final int VIDEO_PLAYER = 13;

    /**
     * Video, the original for download.
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */
    public static final int VIDEO_ORIGINAL = 14;

    /**
     * Video, the original for mobiles.
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */
    public static final int MOBILE_MP4 = 15;

    public static final int HD_MP4 = 16;

    private int label;

    private String labelName;

    private int width;

    private int height;

    private String source;

    private String url;

    private Media media;

    public Size() {

    }

    /**
     * Size of the Photo.
     * 
     * @return label
     * @see com.flickr4java.flickr.photos.Size#THUMB
     * @see com.flickr4java.flickr.photos.Size#SQUARE
     * @see com.flickr4java.flickr.photos.Size#SMALL
     * @see com.flickr4java.flickr.photos.Size#MEDIUM
     * @see com.flickr4java.flickr.photos.Size#LARGE
     * @see com.flickr4java.flickr.photos.Size#ORIGINAL
     * @see com.flickr4java.flickr.photos.Size#SQUARE_LARGE
     * @see com.flickr4java.flickr.photos.Size#SMALL_320
     * @see com.flickr4java.flickr.photos.Size#MEDIUM_640
     * @see com.flickr4java.flickr.photos.Size#MEDIUM_800
     */
    @Deprecated // This method is unreliable - use getLabelName instead
    public int getLabel() {

        return label;
    }

    public String getLabelName() {
        return labelName;
    }

    private final List<String> lstSizes = Arrays.asList(""Thumbnail"", ""Square"", ""Small"", ""Medium"", ""Large"", ""Original"", ""Large Square"", ""Small 320"",
            ""Medium 640"", ""Medium 800"", ""Large 1600"", ""Large 2048"", ""Site MP4"", ""Video Player"", ""Video Original"", ""Mobile MP4"", ""HD MP4"");

    /**
     * Set the String-representation of size.
     * 
     * Like: Square, Thumbnail, Small, Medium, Large, Original.
     * 
     * @param label
     */
    public void setLabel(String label) {

        int ix = lstSizes.indexOf(label);
        if (ix != -1) {
            setLabel(ix);
        }
        labelName = label;
    }

    /**
     * Size of the Photo.
     * 
     * @param label
     *            The integer-representation of a size
     * @see com.flickr4java.flickr.photos.Size#THUMB
     * @see com.flickr4java.flickr.photos.Size#SQUARE
     * @see com.flickr4java.flickr.photos.Size#SMALL
     * @see com.flickr4java.flickr.photos.Size#MEDIUM
     * @see com.flickr4java.flickr.photos.Size#LARGE
     * @see com.flickr4java.flickr.photos.Size#ORIGINAL
     */
    public void setLabel(int label) {

        this.label = label;
    }

    public int getWidth() {

        return width;
    }

    public void setWidth(int width) {

        this.width = width;
    }

    public void setWidth(String width) {

        if (!(width == null || """".equals(width))) { // checking both null and empty
            setWidth(Integer.parseInt(width));
        }
    }

    public int getHeight() {

        return height;
    }

    public void setHeight(int height) {

        this.height = height;
    }

    public void setHeight(String height) {

        if (!(height == null || """".equals(height))) { // checking both null and empty
            setHeight(Integer.parseInt(height));
        }
    }

    /**
     * URL of the image.
     * 
     * @return Image-URL
     */
    public String getSource() {

        return source;
    }

    public void setSource(String source) {

        this.source = source;
    }

    /**
     * URL of the photopage.
     * 
     * @return Page-URL
     */
    public String getUrl() {

        return url;
    }

    public void setUrl(String url) {

        this.url = url;
    }

    public Media getMedia() {
        return media;
    }

    public void setMedia(Media media) {
        this.media = media;
    }

    public void setMedia(String media) {
        this.media = Media.valueOf(media);
    }

    @Override
    public boolean equals(Object obj) {

        if ((obj == null) || (obj.getClass() != this.getClass())) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        Size test = (Size) obj;
        return label == test.label && width == test.width && height == test.height && areEqual(source, test.source) && areEqual(url, test.url);
    }

    @Override
    public int hashCode() {

        int hash = 1;
        hash += Integer.hashCode(label);
        hash += Integer.hashCode(width);
        hash += Integer.hashCode(height);
        if (source != null) {
            hash += source.hashCode();
        }
        if (url != null) {
            hash += url.hashCode();
        }
        return hash;
    }

    private boolean areEqual(Object x, Object y) {

        return x == null ? y == null : x.equals(y);
    }
}
","package com.flickr4java.flickr.photos; public class Size { public static final int THUMB = 0; public static final int SQUARE = 1; public static final int SMALL = 2; public static final int MEDIUM = 3; public static final int LARGE = 4; public static final int ORIGINAL = 5; public static final int SQUARE_LARGE = 6; public static final int SMALL_320 = 7; public static final int MEDIUM_640 = 8; public static final int MEDIUM_800 = 9; public static final int LARGE_1600 = 10; public static final int LARGE_2048 = 11; public static final int SITE_MP4 = 12; public static final int VIDEO_PLAYER = 13; public static final int VIDEO_ORIGINAL = 14; public static final int MOBILE_MP4 = 15; public static final int HD_MP4 = 16; private int label; private String labelName; private int width; private int height; private String source; private String url; private Media media; public Size() { } public int getLabel() { return label; } public String getLabelName() { return labelName; } private final List<String> lstSizes = Arrays.asList(""Thumbnail"", ""Square"", ""Small"", ""Medium"", ""Large"", ""Original"", ""Large Square"", ""Small 320"",
            ""Medium 640"", ""Medium 800"", ""Large 1600"", ""Large 2048"", ""Site MP4"", ""Video Player"", ""Video Original"", ""Mobile MP4"", ""HD MP4""); public void setLabel(String label) { int ix = lstSizes.indexOf(label); if (ix != -1) { setLabel(ix); } labelName = label; } public void setLabel(int label) { this.label = label; } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } public void setWidth(String width) { if (!(width == null || """".equals(width))) { setWidth(Integer.parseInt(width)); } } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } public void setHeight(String height) { if (!(height == null || """".equals(height))) { setHeight(Integer.parseInt(height)); } } public String getSource() { return source; } public void setSource(String source) { this.source = source; } public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } public Media getMedia() { return media; } public void setMedia(Media media) { this.media = media; } public void setMedia(String media) { this.media = Media.valueOf(media); } @Override
    public boolean equals(Object obj) { if ((obj == null) || (obj.getClass() != this.getClass())) { return false; } if (obj == this) { return true; } Size test = (Size) obj; return label == test.label && width == test.width && height == test.height && areEqual(source, test.source) && areEqual(url, test.url); } @Override
    public int hashCode() { int hash = 1; hash += Integer.hashCode(label); hash += Integer.hashCode(width); hash += Integer.hashCode(height); if (source != null) { hash += source.hashCode(); } if (url != null) { hash += url.hashCode(); } return hash; } private boolean areEqual(Object x, Object y) { return x == null ? y == null : x.equals(y); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.photos; public class Size { public static final int THUMB = 0; public static final int SQUARE = 1; public static final int SMALL = 2; public static final int MEDIUM = 3; public static final int LARGE = 4; public static final int ORIGINAL = 5; public static final int SQUARE_LARGE = 6; public static final int SMALL_320 = 7; public static final int MEDIUM_640 = 8; public static final int MEDIUM_800 = 9; public static final int LARGE_1600 = 10; public static final int LARGE_2048 = 11; public static final int SITE_MP4 = 12; public static final int VIDEO_PLAYER = 13; public static final int VIDEO_ORIGINAL = 14; public static final int MOBILE_MP4 = 15; public static final int HD_MP4 = 16; private int label; private String labelName; private int width; private int height; private String source; private String url; private Media media; public Size() { } public int getLabel() { return label; } public String getLabelName() { return labelName; } private final List<String> lstSizes = Arrays.asList(""Thumbnail"", ""Square"", ""Small"", ""Medium"", ""Large"", ""Original"", ""Large Square"", ""Small 320"",
            ""Medium 640"", ""Medium 800"", ""Large 1600"", ""Large 2048"", ""Site MP4"", ""Video Player"", ""Video Original"", ""Mobile MP4"", ""HD MP4""); public void setLabel(String label) { int ix = lstSizes.indexOf(label); if (ix != -1) { setLabel(ix); } labelName = label; } public void setLabel(int label) { this.label = label; } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } public void setWidth(String width) { if (!(width == null || """".equals(width))) { setWidth(Integer.parseInt(width)); } } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } public void setHeight(String height) { if (!(height == null || """".equals(height))) { setHeight(Integer.parseInt(height)); } } public String getSource() { return source; } public void setSource(String source) { this.source = source; } public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } public Media getMedia() { return media; } public void setMedia(Media media) { this.media = media; } public void setMedia(String media) { this.media = Media.valueOf(media); } @Override
    public boolean equals(Object obj) { if ((obj == null) || (obj.getClass() != this.getClass())) { return false; } if (obj == this) { return true; } Size test = (Size) obj; return label == test.label && width == test.width && height == test.height && areEqual(source, test.source) && areEqual(url, test.url); } @Override
    public int hashCode() { int hash = 1; hash += Integer.hashCode(label); hash += Integer.hashCode(width); hash += Integer.hashCode(height); if (source != null) { hash += source.hashCode(); } if (url != null) { hash += url.hashCode(); } return hash; } private boolean areEqual(Object x, Object y) { return x == null ? y == null : x.equals(y); } } "," package com.flickr4java.flickr.photos; 
import java.util.Arrays; import java.util.List;  /**
 * This class descibes a Size of a Photo.
 * <p>
 * 
 * @author Anthony Eden
 * @version $Id: Size.java,v 1.7 2009/07/23 20:41:03 x-mago Exp $
 */ public class Size {  /**
     * Thumbnail, 100 on longest side.
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */ public static final int THUMB = 0;  /**
     * Small square 75x75.
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */ public static final int SQUARE = 1;  /**
     * Small, 240 on longest side.
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */ public static final int SMALL = 2;  /**
     * Medium, 500 on longest side.
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */ public static final int MEDIUM = 3;  /**
     * Large, 1024 on longest side (only exists for very large original images).
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */ public static final int LARGE = 4;  /**
     * Original image, either a jpg, gif or png, depending on source format.<br>
     * Only from pro-users original images are available!
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */ public static final int ORIGINAL = 5;  /**
     * Large Square 150x150
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */ public static final int SQUARE_LARGE = 6;  /**
     * Small, 320 px on the longest side
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */ public static final int SMALL_320 = 7;  /**
     * Medium, 640 px on the longest side
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */ public static final int MEDIUM_640 = 8;  /**
     * Medium, 640 px on the longest side
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */ public static final int MEDIUM_800 = 9;  /**
     * Large, 1600 px on the longest side
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */ public static final int LARGE_1600 = 10;  /**
     * Large, 2048 px on the longest side
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */ public static final int LARGE_2048 = 11;  /**
     * Video, for playback on the site.
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */ public static final int SITE_MP4 = 12;  /**
     * Video, for playback on the site.
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */ public static final int VIDEO_PLAYER = 13;  /**
     * Video, the original for download.
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */ public static final int VIDEO_ORIGINAL = 14;  /**
     * Video, the original for mobiles.
     * 
     * @see com.flickr4java.flickr.photos.Size#getLabel()
     * @see com.flickr4java.flickr.photos.Size#setLabel(int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImage(Photo, int)
     * @see com.flickr4java.flickr.photos.PhotosInterface#getImageAsStream(Photo, int)
     */ public static final int MOBILE_MP4 = 15;  public static final int HD_MP4 = 16;  private int label;  private String labelName;  private int width;  private int height;  private String source;  private String url;  private Media media;  public Size() {  }  /**
     * Size of the Photo.
     * 
     * @return label
     * @see com.flickr4java.flickr.photos.Size#THUMB
     * @see com.flickr4java.flickr.photos.Size#SQUARE
     * @see com.flickr4java.flickr.photos.Size#SMALL
     * @see com.flickr4java.flickr.photos.Size#MEDIUM
     * @see com.flickr4java.flickr.photos.Size#LARGE
     * @see com.flickr4java.flickr.photos.Size#ORIGINAL
     * @see com.flickr4java.flickr.photos.Size#SQUARE_LARGE
     * @see com.flickr4java.flickr.photos.Size#SMALL_320
     * @see com.flickr4java.flickr.photos.Size#MEDIUM_640
     * @see com.flickr4java.flickr.photos.Size#MEDIUM_800
     */ // This method is unreliable - use getLabelName instead public int getLabel() {  return label; }  public String getLabelName() { return labelName; }  private final List<String> lstSizes = Arrays.asList(""Thumbnail"", ""Square"", ""Small"", ""Medium"", ""Large"", ""Original"", ""Large Square"", ""Small 320"",
            ""Medium 640"", ""Medium 800"", ""Large 1600"", ""Large 2048"", ""Site MP4"", ""Video Player"", ""Video Original"", ""Mobile MP4"", ""HD MP4"");  /**
     * Set the String-representation of size.
     * 
     * Like: Square, Thumbnail, Small, Medium, Large, Original.
     * 
     * @param label
     */ public void setLabel(String label) {  int ix = lstSizes.indexOf(label); if (ix != -1) { setLabel(ix); } labelName = label; }  /**
     * Size of the Photo.
     * 
     * @param label
     *            The integer-representation of a size
     * @see com.flickr4java.flickr.photos.Size#THUMB
     * @see com.flickr4java.flickr.photos.Size#SQUARE
     * @see com.flickr4java.flickr.photos.Size#SMALL
     * @see com.flickr4java.flickr.photos.Size#MEDIUM
     * @see com.flickr4java.flickr.photos.Size#LARGE
     * @see com.flickr4java.flickr.photos.Size#ORIGINAL
     */ public void setLabel(int label) {  this.label = label; }  public int getWidth() {  return width; }  public void setWidth(int width) {  this.width = width; }  public void setWidth(String width) {  if (!(width == null || """".equals(width))) { // checking both null and empty setWidth(Integer.parseInt(width)); } }  public int getHeight() {  return height; }  public void setHeight(int height) {  this.height = height; }  public void setHeight(String height) {  if (!(height == null || """".equals(height))) { // checking both null and empty setHeight(Integer.parseInt(height)); } }  /**
     * URL of the image.
     * 
     * @return Image-URL
     */ public String getSource() {  return source; }  public void setSource(String source) {  this.source = source; }  /**
     * URL of the photopage.
     * 
     * @return Page-URL
     */ public String getUrl() {  return url; }  public void setUrl(String url) {  this.url = url; }  public Media getMedia() { return media; }  public void setMedia(Media media) { this.media = media; }  public void setMedia(String media) { this.media = Media.valueOf(media); }  @Override
    public boolean equals(Object obj) {  if ((obj == null) || (obj.getClass() != this.getClass())) { return false; } if (obj == this) { return true; } Size test = (Size) obj; return label == test.label && width == test.width && height == test.height && areEqual(source, test.source) && areEqual(url, test.url); }  @Override
    public int hashCode() {  int hash = 1; hash += Integer.hashCode(label); hash += Integer.hashCode(width); hash += Integer.hashCode(height); if (source != null) { hash += source.hashCode(); } if (url != null) { hash += url.hashCode(); } return hash; }  private boolean areEqual(Object x, Object y) {  return x == null ? y == null : x.equals(y); } }  "
src/main/java/com/flickr4java/flickr/photos/SizeList.java,"package com.flickr4java.flickr.photos;

import java.util.ArrayList;



public class SizeList<E> extends ArrayList<Size> {
	
	/**
	 * @author Jonathan Willis
	 */
	private static final long serialVersionUID = -4735611134085303463L;
	
	private boolean canBlog;
	private boolean canPrint;
	private boolean canDownload;
	
	public boolean isCanBlog() {
		return canBlog;
	}
	public void setIsCanBlog(boolean canBlog) {
		this.canBlog = canBlog;
	}
	
	public boolean isCanPrint() {
		return canPrint;
	}
	public void setIsCanPrint(boolean canPrint) {
		this.canPrint = canPrint;
	}
	
	public boolean isCanDownload() {
		return canDownload;
	}
	public void setIsCanDownload(boolean canDownload) {
		this.canDownload = canDownload;
	}
	
	

}
",package com.flickr4java.flickr.photos; import java.util.ArrayList; public class SizeList<E> extends ArrayList<Size> { private static final long serialVersionUID = -4735611134085303463L; private boolean canBlog; private boolean canPrint; private boolean canDownload; public boolean isCanBlog() { return canBlog; } public void setIsCanBlog(boolean canBlog) { this.canBlog = canBlog; } public boolean isCanPrint() { return canPrint; } public void setIsCanPrint(boolean canPrint) { this.canPrint = canPrint; } public boolean isCanDownload() { return canDownload; } public void setIsCanDownload(boolean canDownload) { this.canDownload = canDownload; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.photos; import java.util.ArrayList; public class SizeList<E> extends ArrayList<Size> { private static final long serialVersionUID = -4735611134085303463L; private boolean canBlog; private boolean canPrint; private boolean canDownload; public boolean isCanBlog() { return canBlog; } public void setIsCanBlog(boolean canBlog) { this.canBlog = canBlog; } public boolean isCanPrint() { return canPrint; } public void setIsCanPrint(boolean canPrint) { this.canPrint = canPrint; } public boolean isCanDownload() { return canDownload; } public void setIsCanDownload(boolean canDownload) { this.canDownload = canDownload; } } ,"package com.flickr4java.flickr.photos;  import java.util.ArrayList; 

 public class SizeList<E> extends ArrayList<Size> { 	 /**
	 * @author Jonathan Willis
	 */ private static final long serialVersionUID = -4735611134085303463L; 	 private boolean canBlog; private boolean canPrint; private boolean canDownload; 	 public boolean isCanBlog() { return canBlog; } public void setIsCanBlog(boolean canBlog) { this.canBlog = canBlog; } 	 public boolean isCanPrint() { return canPrint; } public void setIsCanPrint(boolean canPrint) { this.canPrint = canPrint; } 	 public boolean isCanDownload() { return canDownload; } public void setIsCanDownload(boolean canDownload) { this.canDownload = canDownload; } 	
	
 }  "
src/main/java/com/flickr4java/flickr/photos/Usage.java,"package com.flickr4java.flickr.photos;

public class Usage {
	
	private boolean canBlog;
	private boolean canPrint;
	private boolean canDownload;
	private boolean canShare;
	
	public boolean isCanBlog() {
		return canBlog;
	}
	public void setIsCanBlog(boolean canBlog) {
		this.canBlog = canBlog;
	}
	
	public boolean isCanPrint() {
		return canPrint;
	}
	public void setIsCanPrint(boolean canPrint) {
		this.canPrint = canPrint;
	}
	
	public boolean isCanDownload() {
		return canDownload;
	}
	public void setIsCanDownload(boolean canDownload) {
		this.canDownload = canDownload;
	}
	public boolean isCanShare() {
		return canShare;
	}
	public void setIsCanShare(boolean canShare) {
		this.canShare = canShare;
	}
	

}
",package com.flickr4java.flickr.photos; public class Usage { private boolean canBlog; private boolean canPrint; private boolean canDownload; private boolean canShare; public boolean isCanBlog() { return canBlog; } public void setIsCanBlog(boolean canBlog) { this.canBlog = canBlog; } public boolean isCanPrint() { return canPrint; } public void setIsCanPrint(boolean canPrint) { this.canPrint = canPrint; } public boolean isCanDownload() { return canDownload; } public void setIsCanDownload(boolean canDownload) { this.canDownload = canDownload; } public boolean isCanShare() { return canShare; } public void setIsCanShare(boolean canShare) { this.canShare = canShare; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.photos; public class Usage { private boolean canBlog; private boolean canPrint; private boolean canDownload; private boolean canShare; public boolean isCanBlog() { return canBlog; } public void setIsCanBlog(boolean canBlog) { this.canBlog = canBlog; } public boolean isCanPrint() { return canPrint; } public void setIsCanPrint(boolean canPrint) { this.canPrint = canPrint; } public boolean isCanDownload() { return canDownload; } public void setIsCanDownload(boolean canDownload) { this.canDownload = canDownload; } public boolean isCanShare() { return canShare; } public void setIsCanShare(boolean canShare) { this.canShare = canShare; } } ,"package com.flickr4java.flickr.photos;  public class Usage { 	 private boolean canBlog; private boolean canPrint; private boolean canDownload; private boolean canShare; 	 public boolean isCanBlog() { return canBlog; } public void setIsCanBlog(boolean canBlog) { this.canBlog = canBlog; } 	 public boolean isCanPrint() { return canPrint; } public void setIsCanPrint(boolean canPrint) { this.canPrint = canPrint; } 	 public boolean isCanDownload() { return canDownload; } public void setIsCanDownload(boolean canDownload) { this.canDownload = canDownload; } public boolean isCanShare() { return canShare; } public void setIsCanShare(boolean canShare) { this.canShare = canShare; } 	
 }  "
src/main/java/com/flickr4java/flickr/photosets/Photoset.java,"
package com.flickr4java.flickr.photosets;

import com.flickr4java.flickr.people.User;
import com.flickr4java.flickr.photos.Photo;

/**
 * Meta information about a photoset. To retrieve the photos in the photoset use PhotosetsInterface.getPhotos().
 * 
 * @author Anthony Eden
 * @version $Id: Photoset.java,v 1.7 2009/07/12 22:43:07 x-mago Exp $
 */
public class Photoset {
    private static final long serialVersionUID = 12L;

    private String id;

    private String url;

    private User owner;

    private Photo primaryPhoto;

    private String secret;

    private String server;

    private String farm;

    private int photoCount;
    
    private int videoCount;
    
    private int viewCount;
    
    private int commentCount;
    
    private String dateCreate;
    
    private String dateUpdate;

    private String title;

    private String description;
    
    private boolean isVisible;
    
    private boolean canComment;
    
    private boolean needsInterstitial;

    public Photoset() {

    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getUrl() {
        if (url == null) {
            StringBuffer sb = new StringBuffer();
            sb.append(""https://www.flickr.com/photos/"");
            sb.append(getOwner().getId());
            sb.append(""/sets/"");
            sb.append(getId());
            sb.append(""/"");
            return sb.toString();
        } else {
            return url;
        }
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public User getOwner() {
        return owner;
    }

    public void setOwner(User owner) {
        this.owner = owner;
    }

    public Photo getPrimaryPhoto() {
        return primaryPhoto;
    }

    public void setPrimaryPhoto(Photo primaryPhoto) {
        this.primaryPhoto = primaryPhoto;
    }

    public String getSecret() {
        return secret;
    }

    public void setSecret(String secret) {
        this.secret = secret;
    }

    public String getServer() {
        return server;
    }

    public void setServer(String server) {
        this.server = server;
    }

    public String getFarm() {
        return farm;
    }

    public void setFarm(String farm) {
        this.farm = farm;
    }

    public int getPhotoCount() {
        return photoCount;
    }

    public void setPhotoCount(int photoCount) {
        this.photoCount = photoCount;
    }

    public void setPhotoCount(String photoCount) {
        if (photoCount != null) {
            setPhotoCount(Integer.parseInt(photoCount));
        }
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

	public int getVideoCount() {
		return videoCount;
	}

	public void setVideoCount(int videoCount) {
		this.videoCount = videoCount;
	}

	public int getViewCount() {
		return viewCount;
	}

	public void setViewCount(int viewCount) {
		this.viewCount = viewCount;
	}

	public int getCommentCount() {
		return commentCount;
	}

	public void setCommentCount(int commentCount) {
		this.commentCount = commentCount;
	}

	public String getDateCreate() {
		return dateCreate;
	}

	public void setDateCreate(String dateCreate) {
		this.dateCreate = dateCreate;
	}

	public String getDateUpdate() {
		return dateUpdate;
	}

	public void setDateUpdate(String dateUpdate) {
		this.dateUpdate = dateUpdate;
	}

	public boolean isVisible() {
		return isVisible;
	}

	public void setIsVisible(boolean isVisible) {
		this.isVisible = isVisible;
	}



	public boolean isNeedsInterstitial() {
		return needsInterstitial;
	}

	public void setIsNeedsInterstitial(boolean needsInterstitial) {
		this.needsInterstitial = needsInterstitial;
	}

	public boolean isCanComment() {
		return canComment;
	}

	public void setIsCanComment(boolean canComment) {
		this.canComment = canComment;
	}

}
","package com.flickr4java.flickr.photosets; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.photos.Photo; public class Photoset { private static final long serialVersionUID = 12L; private String id; private String url; private User owner; private Photo primaryPhoto; private String secret; private String server; private String farm; private int photoCount; private int videoCount; private int viewCount; private int commentCount; private String dateCreate; private String dateUpdate; private String title; private String description; private boolean isVisible; private boolean canComment; private boolean needsInterstitial; public Photoset() { } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getUrl() { if (url == null) { StringBuffer sb = new StringBuffer(); sb.append(getOwner().getId()); sb.append(""/sets/""); sb.append(getId()); sb.append(""/""); return sb.toString(); } else { return url; } } public void setUrl(String url) { this.url = url; } public User getOwner() { return owner; } public void setOwner(User owner) { this.owner = owner; } public Photo getPrimaryPhoto() { return primaryPhoto; } public void setPrimaryPhoto(Photo primaryPhoto) { this.primaryPhoto = primaryPhoto; } public String getSecret() { return secret; } public void setSecret(String secret) { this.secret = secret; } public String getServer() { return server; } public void setServer(String server) { this.server = server; } public String getFarm() { return farm; } public void setFarm(String farm) { this.farm = farm; } public int getPhotoCount() { return photoCount; } public void setPhotoCount(int photoCount) { this.photoCount = photoCount; } public void setPhotoCount(String photoCount) { if (photoCount != null) { setPhotoCount(Integer.parseInt(photoCount)); } } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public int getVideoCount() { return videoCount; } public void setVideoCount(int videoCount) { this.videoCount = videoCount; } public int getViewCount() { return viewCount; } public void setViewCount(int viewCount) { this.viewCount = viewCount; } public int getCommentCount() { return commentCount; } public void setCommentCount(int commentCount) { this.commentCount = commentCount; } public String getDateCreate() { return dateCreate; } public void setDateCreate(String dateCreate) { this.dateCreate = dateCreate; } public String getDateUpdate() { return dateUpdate; } public void setDateUpdate(String dateUpdate) { this.dateUpdate = dateUpdate; } public boolean isVisible() { return isVisible; } public void setIsVisible(boolean isVisible) { this.isVisible = isVisible; } public boolean isNeedsInterstitial() { return needsInterstitial; } public void setIsNeedsInterstitial(boolean needsInterstitial) { this.needsInterstitial = needsInterstitial; } public boolean isCanComment() { return canComment; } public void setIsCanComment(boolean canComment) { this.canComment = canComment; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.photosets; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.photos.Photo; public class Photoset { private static final long serialVersionUID = 12L; private String id; private String url; private User owner; private Photo primaryPhoto; private String secret; private String server; private String farm; private int photoCount; private int videoCount; private int viewCount; private int commentCount; private String dateCreate; private String dateUpdate; private String title; private String description; private boolean isVisible; private boolean canComment; private boolean needsInterstitial; public Photoset() { } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getUrl() { if (url == null) { StringBuffer sb = new StringBuffer(); sb.append(getOwner().getId()); sb.append(""/sets/""); sb.append(getId()); sb.append(""/""); return sb.toString(); } else { return url; } } public void setUrl(String url) { this.url = url; } public User getOwner() { return owner; } public void setOwner(User owner) { this.owner = owner; } public Photo getPrimaryPhoto() { return primaryPhoto; } public void setPrimaryPhoto(Photo primaryPhoto) { this.primaryPhoto = primaryPhoto; } public String getSecret() { return secret; } public void setSecret(String secret) { this.secret = secret; } public String getServer() { return server; } public void setServer(String server) { this.server = server; } public String getFarm() { return farm; } public void setFarm(String farm) { this.farm = farm; } public int getPhotoCount() { return photoCount; } public void setPhotoCount(int photoCount) { this.photoCount = photoCount; } public void setPhotoCount(String photoCount) { if (photoCount != null) { setPhotoCount(Integer.parseInt(photoCount)); } } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public int getVideoCount() { return videoCount; } public void setVideoCount(int videoCount) { this.videoCount = videoCount; } public int getViewCount() { return viewCount; } public void setViewCount(int viewCount) { this.viewCount = viewCount; } public int getCommentCount() { return commentCount; } public void setCommentCount(int commentCount) { this.commentCount = commentCount; } public String getDateCreate() { return dateCreate; } public void setDateCreate(String dateCreate) { this.dateCreate = dateCreate; } public String getDateUpdate() { return dateUpdate; } public void setDateUpdate(String dateUpdate) { this.dateUpdate = dateUpdate; } public boolean isVisible() { return isVisible; } public void setIsVisible(boolean isVisible) { this.isVisible = isVisible; } public boolean isNeedsInterstitial() { return needsInterstitial; } public void setIsNeedsInterstitial(boolean needsInterstitial) { this.needsInterstitial = needsInterstitial; } public boolean isCanComment() { return canComment; } public void setIsCanComment(boolean canComment) { this.canComment = canComment; } } "," package com.flickr4java.flickr.photosets;  import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.photos.Photo;  /**
 * Meta information about a photoset. To retrieve the photos in the photoset use PhotosetsInterface.getPhotos().
 * 
 * @author Anthony Eden
 * @version $Id: Photoset.java,v 1.7 2009/07/12 22:43:07 x-mago Exp $
 */ public class Photoset { private static final long serialVersionUID = 12L;  private String id;  private String url;  private User owner;  private Photo primaryPhoto;  private String secret;  private String server;  private String farm;  private int photoCount;      private int videoCount;      private int viewCount;      private int commentCount;      private String dateCreate;      private String dateUpdate;  private String title;  private String description;      private boolean isVisible;      private boolean canComment;      private boolean needsInterstitial;  public Photoset() {  }  public String getId() { return id; }  public void setId(String id) { this.id = id; }  public String getUrl() { if (url == null) { StringBuffer sb = new StringBuffer(); //www.flickr.com/photos/""); sb.append(getOwner().getId()); sb.append(""/sets/""); sb.append(getId()); sb.append(""/""); return sb.toString(); } else { return url; } }  public void setUrl(String url) { this.url = url; }  public User getOwner() { return owner; }  public void setOwner(User owner) { this.owner = owner; }  public Photo getPrimaryPhoto() { return primaryPhoto; }  public void setPrimaryPhoto(Photo primaryPhoto) { this.primaryPhoto = primaryPhoto; }  public String getSecret() { return secret; }  public void setSecret(String secret) { this.secret = secret; }  public String getServer() { return server; }  public void setServer(String server) { this.server = server; }  public String getFarm() { return farm; }  public void setFarm(String farm) { this.farm = farm; }  public int getPhotoCount() { return photoCount; }  public void setPhotoCount(int photoCount) { this.photoCount = photoCount; }  public void setPhotoCount(String photoCount) { if (photoCount != null) { setPhotoCount(Integer.parseInt(photoCount)); } }  public String getTitle() { return title; }  public void setTitle(String title) { this.title = title; }  public String getDescription() { return description; }  public void setDescription(String description) { this.description = description; }  public int getVideoCount() { return videoCount; }  public void setVideoCount(int videoCount) { this.videoCount = videoCount; }  public int getViewCount() { return viewCount; }  public void setViewCount(int viewCount) { this.viewCount = viewCount; }  public int getCommentCount() { return commentCount; }  public void setCommentCount(int commentCount) { this.commentCount = commentCount; }  public String getDateCreate() { return dateCreate; }  public void setDateCreate(String dateCreate) { this.dateCreate = dateCreate; }  public String getDateUpdate() { return dateUpdate; }  public void setDateUpdate(String dateUpdate) { this.dateUpdate = dateUpdate; }  public boolean isVisible() { return isVisible; }  public void setIsVisible(boolean isVisible) { this.isVisible = isVisible; } 

 public boolean isNeedsInterstitial() { return needsInterstitial; }  public void setIsNeedsInterstitial(boolean needsInterstitial) { this.needsInterstitial = needsInterstitial; }  public boolean isCanComment() { return canComment; }  public void setIsCanComment(boolean canComment) { this.canComment = canComment; }  }  "
src/main/java/com/flickr4java/flickr/photosets/Photosets.java,"
package com.flickr4java.flickr.photosets;

import java.util.Collection;

/**
 * Photoset collection. This class is required instead of a basic Collection object because of the cancreate flag.
 * 
 * @author Anthony Eden
 */
public class Photosets {

	private int total;
	private int perPage;
	private int page;
	private int pages;
    private boolean canCreate;

    private Collection<Photoset> photosets;

    public Photosets() {

    }

    public boolean isCanCreate() {
        return canCreate;
    }

    public void setCanCreate(boolean canCreate) {
        this.canCreate = canCreate;
    }

    public Collection<Photoset> getPhotosets() {
        return photosets;
    }

    public void setPhotosets(Collection<Photoset> photosets) {
        this.photosets = photosets;
    }

	public int getTotal() {
		return total;
	}

	public void setTotal(int total) {
		this.total = total;
	}

	public int getPerPage() {
		return perPage;
	}

	public void setPerPage(int perPage) {
		this.perPage = perPage;
	}

	public int getPages() {
		return pages;
	}

	public void setPages(int pages) {
		this.pages = pages;
	}

	public int getPage() {
		return page;
	}

	public void setPage(int page) {
		this.page = page;
	}

}
",package com.flickr4java.flickr.photosets; import java.util.Collection; public class Photosets { private int total; private int perPage; private int page; private int pages; private boolean canCreate; private Collection<Photoset> photosets; public Photosets() { } public boolean isCanCreate() { return canCreate; } public void setCanCreate(boolean canCreate) { this.canCreate = canCreate; } public Collection<Photoset> getPhotosets() { return photosets; } public void setPhotosets(Collection<Photoset> photosets) { this.photosets = photosets; } public int getTotal() { return total; } public void setTotal(int total) { this.total = total; } public int getPerPage() { return perPage; } public void setPerPage(int perPage) { this.perPage = perPage; } public int getPages() { return pages; } public void setPages(int pages) { this.pages = pages; } public int getPage() { return page; } public void setPage(int page) { this.page = page; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.photosets; import java.util.Collection; public class Photosets { private int total; private int perPage; private int page; private int pages; private boolean canCreate; private Collection<Photoset> photosets; public Photosets() { } public boolean isCanCreate() { return canCreate; } public void setCanCreate(boolean canCreate) { this.canCreate = canCreate; } public Collection<Photoset> getPhotosets() { return photosets; } public void setPhotosets(Collection<Photoset> photosets) { this.photosets = photosets; } public int getTotal() { return total; } public void setTotal(int total) { this.total = total; } public int getPerPage() { return perPage; } public void setPerPage(int perPage) { this.perPage = perPage; } public int getPages() { return pages; } public void setPages(int pages) { this.pages = pages; } public int getPage() { return page; } public void setPage(int page) { this.page = page; } } ," package com.flickr4java.flickr.photosets;  import java.util.Collection;  /**
 * Photoset collection. This class is required instead of a basic Collection object because of the cancreate flag.
 * 
 * @author Anthony Eden
 */ public class Photosets {  private int total; private int perPage; private int page; private int pages; private boolean canCreate;  private Collection<Photoset> photosets;  public Photosets() {  }  public boolean isCanCreate() { return canCreate; }  public void setCanCreate(boolean canCreate) { this.canCreate = canCreate; }  public Collection<Photoset> getPhotosets() { return photosets; }  public void setPhotosets(Collection<Photoset> photosets) { this.photosets = photosets; }  public int getTotal() { return total; }  public void setTotal(int total) { this.total = total; }  public int getPerPage() { return perPage; }  public void setPerPage(int perPage) { this.perPage = perPage; }  public int getPages() { return pages; }  public void setPages(int pages) { this.pages = pages; }  public int getPage() { return page; }  public void setPage(int page) { this.page = page; }  }  "
src/main/java/com/flickr4java/flickr/photosets/PhotosetsInterface.java,"
package com.flickr4java.flickr.photosets;

import com.flickr4java.flickr.Flickr;
import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.people.User;
import com.flickr4java.flickr.photos.Extras;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoContext;
import com.flickr4java.flickr.photos.PhotoList;
import com.flickr4java.flickr.photos.PhotoUtils;
import com.flickr4java.flickr.util.StringUtilities;
import com.flickr4java.flickr.util.XMLUtilities;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Interface for working with photosets.
 * 
 * @author Anthony Eden
 * @version $Id: PhotosetsInterface.java,v 1.27 2009/11/08 21:58:00 x-mago Exp $
 */
public class PhotosetsInterface {

    private static Logger _log = LoggerFactory.getLogger(PhotosetsInterface.class);

    public static final String METHOD_ADD_PHOTO = ""flickr.photosets.addPhoto"";

    public static final String METHOD_CREATE = ""flickr.photosets.create"";

    public static final String METHOD_DELETE = ""flickr.photosets.delete"";

    public static final String METHOD_EDIT_META = ""flickr.photosets.editMeta"";

    public static final String METHOD_EDIT_PHOTOS = ""flickr.photosets.editPhotos"";

    public static final String METHOD_GET_CONTEXT = ""flickr.photosets.getContext"";

    public static final String METHOD_GET_INFO = ""flickr.photosets.getInfo"";

    public static final String METHOD_GET_LIST = ""flickr.photosets.getList"";

    public static final String METHOD_GET_PHOTOS = ""flickr.photosets.getPhotos"";

    public static final String METHOD_ORDER_SETS = ""flickr.photosets.orderSets"";

    public static final String METHOD_REMOVE_PHOTO = ""flickr.photosets.removePhoto"";

    public static final String METHOD_REMOVE_PHOTOS = ""flickr.photosets.removePhotos"";

    public static final String METHOD_REORDER_PHOTOS = ""flickr.photosets.reorderPhotos"";

    public static final String METHOD_SET_PRIMARY_PHOTO = ""flickr.photosets.setPrimaryPhoto"";

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transportAPI;

    public PhotosetsInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transportAPI;
    }

    /**
     * Add a photo to the end of the photoset.
     * <p>
     * Note: requires authentication with the new authentication API with 'write' permission.
     * 
     * @param photosetId
     *            The photoset ID
     * @param photoId
     *            The photo ID
     */
    public void addPhoto(String photosetId, String photoId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_ADD_PHOTO);

        parameters.put(""photoset_id"", photosetId);
        parameters.put(""photo_id"", photoId);

        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Create a new photoset.
     * 
     * @param title
     *            The photoset title
     * @param description
     *            The photoset description
     * @param primaryPhotoId
     *            The primary photo id
     * @return The new Photset
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Photoset create(String title, String description, String primaryPhotoId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_CREATE);

        parameters.put(""title"", title);
        parameters.put(""description"", description);
        parameters.put(""primary_photo_id"", primaryPhotoId);

        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element photosetElement = response.getPayload();
        Photoset photoset = new Photoset();
        photoset.setId(photosetElement.getAttribute(""id""));
        photoset.setUrl(photosetElement.getAttribute(""url""));
        return photoset;
    }

    /**
     * Delete the specified photoset.
     * 
     * @param photosetId
     *            The photoset ID
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void delete(String photosetId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_DELETE);

        parameters.put(""photoset_id"", photosetId);

        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Modify the meta-data for a photoset.
     * 
     * @param photosetId
     *            The photoset ID
     * @param title
     *            A new title
     * @param description
     *            A new description (can be null)
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void editMeta(String photosetId, String title, String description) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_EDIT_META);

        parameters.put(""photoset_id"", photosetId);
        parameters.put(""title"", title);
        if (description != null) {
            parameters.put(""description"", description);
        }

        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Edit which photos are in the photoset.
     * 
     * @param photosetId
     *            The photoset ID
     * @param primaryPhotoId
     *            The primary photo Id
     * @param photoIds
     *            The photo IDs for the photos in the set
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void editPhotos(String photosetId, String primaryPhotoId, String[] photoIds) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_EDIT_PHOTOS);

        parameters.put(""photoset_id"", photosetId);
        parameters.put(""primary_photo_id"", primaryPhotoId);
        parameters.put(""photo_ids"", StringUtilities.join(photoIds, "",""));

        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Get a photo's context in the specified photo set.
     * 
     * This method does not require authentication.
     * 
     * @param photoId
     *            The photo ID
     * @param photosetId
     *            The photoset ID
     * @return The PhotoContext
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PhotoContext getContext(String photoId, String photosetId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_CONTEXT);

        parameters.put(""photo_id"", photoId);
        parameters.put(""photoset_id"", photosetId);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Collection<Element> payload = response.getPayloadCollection();
        PhotoContext photoContext = new PhotoContext();
        for (Element element : payload) {
            String elementName = element.getTagName();
            if (elementName.equals(""prevphoto"")) {
                Photo photo = new Photo();
                photo.setId(element.getAttribute(""id""));
                photoContext.setPreviousPhoto(photo);
            } else if (elementName.equals(""nextphoto"")) {
                Photo photo = new Photo();
                photo.setId(element.getAttribute(""id""));
                photoContext.setNextPhoto(photo);
            } else if (elementName.equals(""count"")) {
                // TODO: process this information
            } else {
                _log.warn(""unsupported element name: "" + elementName);
            }
        }
        return photoContext;
    }

    /**
     * Get the information for a specified photoset.
     * 
     * This method does not require authentication.
     * 
     * @param photosetId
     *            The photoset ID
     * @return The Photoset
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Photoset getInfo(String photosetId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_INFO);

        parameters.put(""photoset_id"", photosetId);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element photosetElement = response.getPayload();
        Photoset photoset = new Photoset();
        photoset.setId(photosetElement.getAttribute(""id""));

        User owner = new User();
        owner.setId(photosetElement.getAttribute(""owner""));
        photoset.setOwner(owner);

        Photo primaryPhoto = new Photo();
        primaryPhoto.setId(photosetElement.getAttribute(""primary""));
        primaryPhoto.setSecret(photosetElement.getAttribute(""secret"")); // TODO verify that this is the secret for the photo
        primaryPhoto.setServer(photosetElement.getAttribute(""server"")); // TODO verify that this is the server for the photo
        primaryPhoto.setFarm(photosetElement.getAttribute(""farm""));
        photoset.setPrimaryPhoto(primaryPhoto);

        // TODO remove secret/server/farm from photoset?
        // It's rather related to the primaryPhoto, then to the photoset itself.
        photoset.setSecret(photosetElement.getAttribute(""secret""));
        photoset.setServer(photosetElement.getAttribute(""server""));
        photoset.setFarm(photosetElement.getAttribute(""farm""));
        photoset.setPhotoCount(photosetElement.getAttribute(""count_photos""));
        photoset.setVideoCount(Integer.parseInt(photosetElement.getAttribute(""count_videos"")));
        photoset.setViewCount(Integer.parseInt(photosetElement.getAttribute(""count_views"")));
        photoset.setCommentCount(Integer.parseInt(photosetElement.getAttribute(""count_comments"")));
        photoset.setDateCreate(photosetElement.getAttribute(""date_create""));
        photoset.setDateUpdate(photosetElement.getAttribute(""date_update""));

        photoset.setIsCanComment(""1"".equals(photosetElement.getAttribute(""can_comment"")));

        photoset.setTitle(XMLUtilities.getChildValue(photosetElement, ""title""));
        photoset.setDescription(XMLUtilities.getChildValue(photosetElement, ""description""));
        photoset.setPrimaryPhoto(primaryPhoto);

        return photoset;
    }

    /**
     * Get a list of all photosets for the specified user.
     * 
     * This method does not require authentication. But to get a Photoset into the list, that contains just private photos, the call needs to be authenticated.
     * 
     * @param userId
     *            The User id
     * @return The Photosets collection
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Photosets getList(String userId) throws FlickrException {
        return getList(userId, 0, 0, null);
    }

    /**
     * Get a list of all photosets for the specified user.
     * 
     * This method does not require authentication. But to get a Photoset into the list, that contains just private photos, the call needs to be authenticated.
     * 
     * @param userId
     *            The User id
     * @param primaryPhotoExtras
     *            A comma-delimited list of extra information to fetch for the primary photo
     * @return The Photosets collection
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Photosets getList(String userId, String primaryPhotoExtras) throws FlickrException {
        return getList(userId, 0, 0, primaryPhotoExtras);
    }

    /**
     * Get a list of all photosets for the specified user.
     * 
     * This method does not require authentication. But to get a Photoset into the list, that contains just private photos, the call needs to be authenticated.
     * 
     * @param userId
     *            The User id
     * @param perPage
     *            The number of photosets per page
     * @param page
     *            The page offset
     * @param primaryPhotoExtras
     *            A comma-delimited list of extra information to fetch for the primary photo
     * @return The Photosets collection
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Photosets getList(String userId, int perPage, int page, String primaryPhotoExtras) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_LIST);

        if (userId != null) {
            parameters.put(""user_id"", userId);
        }

        if (perPage > 0) {
            parameters.put(""per_page"", String.valueOf(perPage));
        }

        if (page > 0) {
            parameters.put(""page"", String.valueOf(page));
        }

        if (primaryPhotoExtras != null) {
            parameters.put(""primary_photo_extras"", primaryPhotoExtras);
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Photosets photosetsObject = new Photosets();
        Element photosetsElement = response.getPayload();
        photosetsObject.setCanCreate(XMLUtilities.getBooleanAttribute(photosetsElement, ""cancreate""));
        photosetsObject.setPage(XMLUtilities.getIntAttribute(photosetsElement, ""page""));
        photosetsObject.setPages(XMLUtilities.getIntAttribute(photosetsElement, ""pages""));
        photosetsObject.setPerPage(XMLUtilities.getIntAttribute(photosetsElement, ""perpage""));
        photosetsObject.setTotal(XMLUtilities.getIntAttribute(photosetsElement, ""total""));
        List<Photoset> photosets = new ArrayList<Photoset>();
        NodeList photosetElements = photosetsElement.getElementsByTagName(""photoset"");
        for (int i = 0; i < photosetElements.getLength(); i++) {
            Element photosetElement = (Element) photosetElements.item(i);
            Photoset photoset = new Photoset();
            photoset.setId(photosetElement.getAttribute(""id""));

            User owner = new User();
            owner.setId(photosetElement.getAttribute(""owner""));
            photoset.setOwner(owner);

            Element primaryPhotoExtrasEl = XMLUtilities.getChild(photosetElement, ""primary_photo_extras"");
            Photo primaryPhoto;
            if (primaryPhotoExtrasEl != null) {
                primaryPhoto = PhotoUtils.createPhoto(primaryPhotoExtrasEl);
            } else {
                primaryPhoto = new Photo();
            }
            primaryPhoto.setId(photosetElement.getAttribute(""primary""));
            primaryPhoto.setSecret(photosetElement.getAttribute(""secret"")); // TODO verify that this is the secret for the photo
            primaryPhoto.setServer(photosetElement.getAttribute(""server"")); // TODO verify that this is the server for the photo
            primaryPhoto.setFarm(photosetElement.getAttribute(""farm""));
            photoset.setPrimaryPhoto(primaryPhoto);

            photoset.setSecret(photosetElement.getAttribute(""secret""));
            photoset.setServer(photosetElement.getAttribute(""server""));
            photoset.setFarm(photosetElement.getAttribute(""farm""));
            photoset.setPhotoCount(photosetElement.getAttribute(""photos""));
            photoset.setVideoCount(Integer.parseInt(photosetElement.getAttribute(""videos"")));
            photoset.setViewCount(Integer.parseInt(photosetElement.getAttribute(""count_views"")));
            photoset.setCommentCount(Integer.parseInt(photosetElement.getAttribute(""count_comments"")));
            photoset.setDateCreate(photosetElement.getAttribute(""date_create""));
            photoset.setDateUpdate(photosetElement.getAttribute(""date_update""));

            photoset.setIsCanComment(""1"".equals(photosetElement.getAttribute(""can_comment"")));
            photoset.setIsNeedsInterstitial(""1"".equals(photosetElement.getAttribute(""needs_interstitial"")));
            photoset.setIsVisible(""1"".equals(photosetElement.getAttribute(""visibility_can_see_set"")));
            photoset.setDescription(XMLUtilities.getChildValue(photosetElement, ""description""));

            photoset.setTitle(XMLUtilities.getChildValue(photosetElement, ""title""));
            photoset.setDescription(XMLUtilities.getChildValue(photosetElement, ""description""));

            photosets.add(photoset);
        }

        photosetsObject.setPhotosets(photosets);

        return photosetsObject;
    }

    /**
     * Convenience method.
     * 
     * Get the total number of sets belonging to a user
     * 
     * @param userId
     *            The User id
     * @return int The number of photosets
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public int getPhotosetCount(String userId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_LIST);

        if (userId != null) {
            parameters.put(""user_id"", userId);
        }

        // Request the bare minimum
        parameters.put(""per_page"", String.valueOf(1));
        parameters.put(""page"", String.valueOf(1));

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element photosetsElement = response.getPayload();

        return Integer.valueOf(photosetsElement.getAttribute(""total""));
    }

    /**
     * Get a collection of Photo objects for the specified Photoset.
     * 
     * This method does not require authentication.
     * 
     * @see com.flickr4java.flickr.photos.Extras
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_NO_FILTER
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_PUBLIC
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FRIENDS
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FRIENDS_FAMILY
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FAMILY
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FRIENDS
     * @param photosetId
     *            The photoset ID
     * @param extras
     *            Set of extra-fields
     * @param privacy_filter
     *            filter value for authenticated calls
     * @param perPage
     *            The number of photos per page
     * @param page
     *            The page offset
     * @return PhotoList The Collection of Photo objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PhotoList<Photo> getPhotos(String photosetId, Set<String> extras, int privacy_filter, int perPage, int page) throws FlickrException {
        PhotoList<Photo> photos = new PhotoList<Photo>();
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_PHOTOS);

        parameters.put(""photoset_id"", photosetId);

        if (perPage > 0) {
            parameters.put(""per_page"", String.valueOf(perPage));
        }

        if (page > 0) {
            parameters.put(""page"", String.valueOf(page));
        }

        if (privacy_filter > 0) {
            parameters.put(""privacy_filter"", """" + privacy_filter);
        }

        if (extras != null && !extras.isEmpty()) {
            parameters.put(Extras.KEY_EXTRAS, StringUtilities.join(extras, "",""));
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element photoset = response.getPayload();
        NodeList photoElements = photoset.getElementsByTagName(""photo"");
        photos.setPage(photoset.getAttribute(""page""));
        photos.setPages(photoset.getAttribute(""pages""));
        photos.setPerPage(photoset.getAttribute(""per_page""));
        photos.setTotal(photoset.getAttribute(""total""));

        for (int i = 0; i < photoElements.getLength(); i++) {
            Element photoElement = (Element) photoElements.item(i);
            photos.add(PhotoUtils.createPhoto(photoElement, photoset));
        }

        return photos;
    }

    /**
     * Convenience method.
     * 
     * Calls getPhotos() with Extras.MIN_EXTRAS and Flickr.PRIVACY_LEVEL_NO_FILTER.
     * 
     * This method does not require authentication.
     * 
     * @see com.flickr4java.flickr.photos.Extras
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_NO_FILTER
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_PUBLIC
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FRIENDS
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FRIENDS_FAMILY
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FAMILY
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FRIENDS
     * @param photosetId
     *            The photoset ID
     * @param perPage
     *            The number of photos per page
     * @param page
     *            The page offset
     * @return PhotoList The Collection of Photo objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PhotoList<Photo> getPhotos(String photosetId, int perPage, int page) throws FlickrException {
        return getPhotos(photosetId, Extras.MIN_EXTRAS, Flickr.PRIVACY_LEVEL_NO_FILTER, perPage, page);
    }

    /**
     * Set the order in which sets are returned for the user.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param photosetIds
     *            An array of Ids
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void orderSets(String[] photosetIds) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_ORDER_SETS);
        ;

        parameters.put(""photoset_ids"", StringUtilities.join(photosetIds, "",""));

        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Remove a photo from the set.
     * 
     * @param photosetId
     *            The photoset ID
     * @param photoId
     *            The photo ID
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void removePhoto(String photosetId, String photoId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_REMOVE_PHOTO);

        parameters.put(""photoset_id"", photosetId);
        parameters.put(""photo_id"", photoId);

        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Remove a photo from the set.
     * 
     * @param photosetId
     *            The photoset ID
     * @param photoIds
     *            The ID's of the photos, in CVS format
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void removePhotos(String photosetId, String photoIds) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_REMOVE_PHOTOS);

        parameters.put(""photoset_id"", photosetId);
        parameters.put(""photo_ids"", photoIds);

        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Remove a photo from the set.
     * 
     * @param photosetId
     *            The photoset ID
     * @param photoIds
     *            The ID's of the photos, in CSV format, in the order they need to be in.
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void reorderPhotos(String photosetId, String photoIds) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_REORDER_PHOTOS);

        parameters.put(""photoset_id"", photosetId);
        parameters.put(""photo_ids"", photoIds);

        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Remove a photo from the set.
     * 
     * @param photosetId
     *            The photoset ID
     * @param photoId
     *            The photo ID that is being added
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void setPrimaryPhoto(String photosetId, String photoId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_SET_PRIMARY_PHOTO);

        parameters.put(""photoset_id"", photosetId);
        parameters.put(""photo_id"", photoId);

        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

}
","package com.flickr4java.flickr.photosets; import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.photos.Extras; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoContext; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.util.StringUtilities; import com.flickr4java.flickr.util.XMLUtilities; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Set; public class PhotosetsInterface { private static Logger _log = LoggerFactory.getLogger(PhotosetsInterface.class); public static final String METHOD_ADD_PHOTO = ""flickr.photosets.addPhoto""; public static final String METHOD_CREATE = ""flickr.photosets.create""; public static final String METHOD_DELETE = ""flickr.photosets.delete""; public static final String METHOD_EDIT_META = ""flickr.photosets.editMeta""; public static final String METHOD_EDIT_PHOTOS = ""flickr.photosets.editPhotos""; public static final String METHOD_GET_CONTEXT = ""flickr.photosets.getContext""; public static final String METHOD_GET_INFO = ""flickr.photosets.getInfo""; public static final String METHOD_GET_LIST = ""flickr.photosets.getList""; public static final String METHOD_GET_PHOTOS = ""flickr.photosets.getPhotos""; public static final String METHOD_ORDER_SETS = ""flickr.photosets.orderSets""; public static final String METHOD_REMOVE_PHOTO = ""flickr.photosets.removePhoto""; public static final String METHOD_REMOVE_PHOTOS = ""flickr.photosets.removePhotos""; public static final String METHOD_REORDER_PHOTOS = ""flickr.photosets.reorderPhotos""; public static final String METHOD_SET_PRIMARY_PHOTO = ""flickr.photosets.setPrimaryPhoto""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public PhotosetsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public void addPhoto(String photosetId, String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD_PHOTO); parameters.put(""photoset_id"", photosetId); parameters.put(""photo_id"", photoId); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public Photoset create(String title, String description, String primaryPhotoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_CREATE); parameters.put(""title"", title); parameters.put(""description"", description); parameters.put(""primary_photo_id"", primaryPhotoId); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosetElement = response.getPayload(); Photoset photoset = new Photoset(); photoset.setId(photosetElement.getAttribute(""id"")); photoset.setUrl(photosetElement.getAttribute(""url"")); return photoset; } public void delete(String photosetId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_DELETE); parameters.put(""photoset_id"", photosetId); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void editMeta(String photosetId, String title, String description) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT_META); parameters.put(""photoset_id"", photosetId); parameters.put(""title"", title); if (description != null) { parameters.put(""description"", description); } Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void editPhotos(String photosetId, String primaryPhotoId, String[] photoIds) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT_PHOTOS); parameters.put(""photoset_id"", photosetId); parameters.put(""primary_photo_id"", primaryPhotoId); parameters.put(""photo_ids"", StringUtilities.join(photoIds, "","")); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public PhotoContext getContext(String photoId, String photosetId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CONTEXT); parameters.put(""photo_id"", photoId); parameters.put(""photoset_id"", photosetId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Collection<Element> payload = response.getPayloadCollection(); PhotoContext photoContext = new PhotoContext(); for (Element element : payload) { String elementName = element.getTagName(); if (elementName.equals(""prevphoto"")) { Photo photo = new Photo(); photo.setId(element.getAttribute(""id"")); photoContext.setPreviousPhoto(photo); } else if (elementName.equals(""nextphoto"")) { Photo photo = new Photo(); photo.setId(element.getAttribute(""id"")); photoContext.setNextPhoto(photo); } else if (elementName.equals(""count"")) { } else { } } return photoContext; } public Photoset getInfo(String photosetId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO); parameters.put(""photoset_id"", photosetId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosetElement = response.getPayload(); Photoset photoset = new Photoset(); photoset.setId(photosetElement.getAttribute(""id"")); User owner = new User(); owner.setId(photosetElement.getAttribute(""owner"")); photoset.setOwner(owner); Photo primaryPhoto = new Photo(); primaryPhoto.setId(photosetElement.getAttribute(""primary"")); primaryPhoto.setSecret(photosetElement.getAttribute(""secret"")); primaryPhoto.setServer(photosetElement.getAttribute(""server"")); primaryPhoto.setFarm(photosetElement.getAttribute(""farm"")); photoset.setPrimaryPhoto(primaryPhoto); photoset.setSecret(photosetElement.getAttribute(""secret"")); photoset.setServer(photosetElement.getAttribute(""server"")); photoset.setFarm(photosetElement.getAttribute(""farm"")); photoset.setPhotoCount(photosetElement.getAttribute(""count_photos"")); photoset.setVideoCount(Integer.parseInt(photosetElement.getAttribute(""count_videos""))); photoset.setViewCount(Integer.parseInt(photosetElement.getAttribute(""count_views""))); photoset.setCommentCount(Integer.parseInt(photosetElement.getAttribute(""count_comments""))); photoset.setDateCreate(photosetElement.getAttribute(""date_create"")); photoset.setDateUpdate(photosetElement.getAttribute(""date_update"")); photoset.setIsCanComment(""1"".equals(photosetElement.getAttribute(""can_comment""))); photoset.setTitle(XMLUtilities.getChildValue(photosetElement, ""title"")); photoset.setDescription(XMLUtilities.getChildValue(photosetElement, ""description"")); photoset.setPrimaryPhoto(primaryPhoto); return photoset; } public Photosets getList(String userId) throws FlickrException { return getList(userId, 0, 0, null); } public Photosets getList(String userId, String primaryPhotoExtras) throws FlickrException { return getList(userId, 0, 0, primaryPhotoExtras); } public Photosets getList(String userId, int perPage, int page, String primaryPhotoExtras) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); if (userId != null) { parameters.put(""user_id"", userId); } if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); } if (primaryPhotoExtras != null) { parameters.put(""primary_photo_extras"", primaryPhotoExtras); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Photosets photosetsObject = new Photosets(); Element photosetsElement = response.getPayload(); photosetsObject.setCanCreate(XMLUtilities.getBooleanAttribute(photosetsElement, ""cancreate"")); photosetsObject.setPage(XMLUtilities.getIntAttribute(photosetsElement, ""page"")); photosetsObject.setPages(XMLUtilities.getIntAttribute(photosetsElement, ""pages"")); photosetsObject.setPerPage(XMLUtilities.getIntAttribute(photosetsElement, ""perpage"")); photosetsObject.setTotal(XMLUtilities.getIntAttribute(photosetsElement, ""total"")); List<Photoset> photosets = new ArrayList<Photoset>(); NodeList photosetElements = photosetsElement.getElementsByTagName(""photoset""); for (int i = 0; i < photosetElements.getLength(); i++) { Element photosetElement = (Element) photosetElements.item(i); Photoset photoset = new Photoset(); photoset.setId(photosetElement.getAttribute(""id"")); User owner = new User(); owner.setId(photosetElement.getAttribute(""owner"")); photoset.setOwner(owner); Element primaryPhotoExtrasEl = XMLUtilities.getChild(photosetElement, ""primary_photo_extras""); Photo primaryPhoto; if (primaryPhotoExtrasEl != null) { primaryPhoto = PhotoUtils.createPhoto(primaryPhotoExtrasEl); } else { primaryPhoto = new Photo(); } primaryPhoto.setId(photosetElement.getAttribute(""primary"")); primaryPhoto.setSecret(photosetElement.getAttribute(""secret"")); primaryPhoto.setServer(photosetElement.getAttribute(""server"")); primaryPhoto.setFarm(photosetElement.getAttribute(""farm"")); photoset.setPrimaryPhoto(primaryPhoto); photoset.setSecret(photosetElement.getAttribute(""secret"")); photoset.setServer(photosetElement.getAttribute(""server"")); photoset.setFarm(photosetElement.getAttribute(""farm"")); photoset.setPhotoCount(photosetElement.getAttribute(""photos"")); photoset.setVideoCount(Integer.parseInt(photosetElement.getAttribute(""videos""))); photoset.setViewCount(Integer.parseInt(photosetElement.getAttribute(""count_views""))); photoset.setCommentCount(Integer.parseInt(photosetElement.getAttribute(""count_comments""))); photoset.setDateCreate(photosetElement.getAttribute(""date_create"")); photoset.setDateUpdate(photosetElement.getAttribute(""date_update"")); photoset.setIsCanComment(""1"".equals(photosetElement.getAttribute(""can_comment""))); photoset.setIsNeedsInterstitial(""1"".equals(photosetElement.getAttribute(""needs_interstitial""))); photoset.setIsVisible(""1"".equals(photosetElement.getAttribute(""visibility_can_see_set""))); photoset.setDescription(XMLUtilities.getChildValue(photosetElement, ""description"")); photoset.setTitle(XMLUtilities.getChildValue(photosetElement, ""title"")); photoset.setDescription(XMLUtilities.getChildValue(photosetElement, ""description"")); photosets.add(photoset); } photosetsObject.setPhotosets(photosets); return photosetsObject; } public int getPhotosetCount(String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); if (userId != null) { parameters.put(""user_id"", userId); } parameters.put(""per_page"", String.valueOf(1)); parameters.put(""page"", String.valueOf(1)); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosetsElement = response.getPayload(); return Integer.valueOf(photosetsElement.getAttribute(""total"")); } public PhotoList<Photo> getPhotos(String photosetId, Set<String> extras, int privacy_filter, int perPage, int page) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PHOTOS); parameters.put(""photoset_id"", photosetId); if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); } if (privacy_filter > 0) { parameters.put(""privacy_filter"", """" + privacy_filter); } if (extras != null && !extras.isEmpty()) { parameters.put(Extras.KEY_EXTRAS, StringUtilities.join(extras, "","")); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photoset = response.getPayload(); NodeList photoElements = photoset.getElementsByTagName(""photo""); photos.setPage(photoset.getAttribute(""page"")); photos.setPages(photoset.getAttribute(""pages"")); photos.setPerPage(photoset.getAttribute(""per_page"")); photos.setTotal(photoset.getAttribute(""total"")); for (int i = 0; i < photoElements.getLength(); i++) { Element photoElement = (Element) photoElements.item(i); photos.add(PhotoUtils.createPhoto(photoElement, photoset)); } return photos; } public PhotoList<Photo> getPhotos(String photosetId, int perPage, int page) throws FlickrException { return getPhotos(photosetId, Extras.MIN_EXTRAS, Flickr.PRIVACY_LEVEL_NO_FILTER, perPage, page); } public void orderSets(String[] photosetIds) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ORDER_SETS); ; parameters.put(""photoset_ids"", StringUtilities.join(photosetIds, "","")); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void removePhoto(String photosetId, String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REMOVE_PHOTO); parameters.put(""photoset_id"", photosetId); parameters.put(""photo_id"", photoId); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void removePhotos(String photosetId, String photoIds) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REMOVE_PHOTOS); parameters.put(""photoset_id"", photosetId); parameters.put(""photo_ids"", photoIds); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void reorderPhotos(String photosetId, String photoIds) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REORDER_PHOTOS); parameters.put(""photoset_id"", photosetId); parameters.put(""photo_ids"", photoIds); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void setPrimaryPhoto(String photosetId, String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_PRIMARY_PHOTO); parameters.put(""photoset_id"", photosetId); parameters.put(""photo_id"", photoId); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.photosets; import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.photos.Extras; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoContext; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.util.StringUtilities; import com.flickr4java.flickr.util.XMLUtilities; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Set; public class PhotosetsInterface { private static Logger _log = LoggerFactory.getLogger(PhotosetsInterface.class); public static final String METHOD_ADD_PHOTO = ""flickr.photosets.addPhoto""; public static final String METHOD_CREATE = ""flickr.photosets.create""; public static final String METHOD_DELETE = ""flickr.photosets.delete""; public static final String METHOD_EDIT_META = ""flickr.photosets.editMeta""; public static final String METHOD_EDIT_PHOTOS = ""flickr.photosets.editPhotos""; public static final String METHOD_GET_CONTEXT = ""flickr.photosets.getContext""; public static final String METHOD_GET_INFO = ""flickr.photosets.getInfo""; public static final String METHOD_GET_LIST = ""flickr.photosets.getList""; public static final String METHOD_GET_PHOTOS = ""flickr.photosets.getPhotos""; public static final String METHOD_ORDER_SETS = ""flickr.photosets.orderSets""; public static final String METHOD_REMOVE_PHOTO = ""flickr.photosets.removePhoto""; public static final String METHOD_REMOVE_PHOTOS = ""flickr.photosets.removePhotos""; public static final String METHOD_REORDER_PHOTOS = ""flickr.photosets.reorderPhotos""; public static final String METHOD_SET_PRIMARY_PHOTO = ""flickr.photosets.setPrimaryPhoto""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public PhotosetsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public void addPhoto(String photosetId, String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD_PHOTO); parameters.put(""photoset_id"", photosetId); parameters.put(""photo_id"", photoId); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public Photoset create(String title, String description, String primaryPhotoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_CREATE); parameters.put(""title"", title); parameters.put(""description"", description); parameters.put(""primary_photo_id"", primaryPhotoId); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosetElement = response.getPayload(); Photoset photoset = new Photoset(); photoset.setId(photosetElement.getAttribute(""id"")); photoset.setUrl(photosetElement.getAttribute(""url"")); return photoset; } public void delete(String photosetId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_DELETE); parameters.put(""photoset_id"", photosetId); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void editMeta(String photosetId, String title, String description) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT_META); parameters.put(""photoset_id"", photosetId); parameters.put(""title"", title); if (description != null) { parameters.put(""description"", description); } Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void editPhotos(String photosetId, String primaryPhotoId, String[] photoIds) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT_PHOTOS); parameters.put(""photoset_id"", photosetId); parameters.put(""primary_photo_id"", primaryPhotoId); parameters.put(""photo_ids"", StringUtilities.join(photoIds, "","")); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public PhotoContext getContext(String photoId, String photosetId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CONTEXT); parameters.put(""photo_id"", photoId); parameters.put(""photoset_id"", photosetId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Collection<Element> payload = response.getPayloadCollection(); PhotoContext photoContext = new PhotoContext(); for (Element element : payload) { String elementName = element.getTagName(); if (elementName.equals(""prevphoto"")) { Photo photo = new Photo(); photo.setId(element.getAttribute(""id"")); photoContext.setPreviousPhoto(photo); } else if (elementName.equals(""nextphoto"")) { Photo photo = new Photo(); photo.setId(element.getAttribute(""id"")); photoContext.setNextPhoto(photo); } else if (elementName.equals(""count"")) { } else { <FILL_ME> } } return photoContext; } public Photoset getInfo(String photosetId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO); parameters.put(""photoset_id"", photosetId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosetElement = response.getPayload(); Photoset photoset = new Photoset(); photoset.setId(photosetElement.getAttribute(""id"")); User owner = new User(); owner.setId(photosetElement.getAttribute(""owner"")); photoset.setOwner(owner); Photo primaryPhoto = new Photo(); primaryPhoto.setId(photosetElement.getAttribute(""primary"")); primaryPhoto.setSecret(photosetElement.getAttribute(""secret"")); primaryPhoto.setServer(photosetElement.getAttribute(""server"")); primaryPhoto.setFarm(photosetElement.getAttribute(""farm"")); photoset.setPrimaryPhoto(primaryPhoto); photoset.setSecret(photosetElement.getAttribute(""secret"")); photoset.setServer(photosetElement.getAttribute(""server"")); photoset.setFarm(photosetElement.getAttribute(""farm"")); photoset.setPhotoCount(photosetElement.getAttribute(""count_photos"")); photoset.setVideoCount(Integer.parseInt(photosetElement.getAttribute(""count_videos""))); photoset.setViewCount(Integer.parseInt(photosetElement.getAttribute(""count_views""))); photoset.setCommentCount(Integer.parseInt(photosetElement.getAttribute(""count_comments""))); photoset.setDateCreate(photosetElement.getAttribute(""date_create"")); photoset.setDateUpdate(photosetElement.getAttribute(""date_update"")); photoset.setIsCanComment(""1"".equals(photosetElement.getAttribute(""can_comment""))); photoset.setTitle(XMLUtilities.getChildValue(photosetElement, ""title"")); photoset.setDescription(XMLUtilities.getChildValue(photosetElement, ""description"")); photoset.setPrimaryPhoto(primaryPhoto); return photoset; } public Photosets getList(String userId) throws FlickrException { return getList(userId, 0, 0, null); } public Photosets getList(String userId, String primaryPhotoExtras) throws FlickrException { return getList(userId, 0, 0, primaryPhotoExtras); } public Photosets getList(String userId, int perPage, int page, String primaryPhotoExtras) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); if (userId != null) { parameters.put(""user_id"", userId); } if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); } if (primaryPhotoExtras != null) { parameters.put(""primary_photo_extras"", primaryPhotoExtras); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Photosets photosetsObject = new Photosets(); Element photosetsElement = response.getPayload(); photosetsObject.setCanCreate(XMLUtilities.getBooleanAttribute(photosetsElement, ""cancreate"")); photosetsObject.setPage(XMLUtilities.getIntAttribute(photosetsElement, ""page"")); photosetsObject.setPages(XMLUtilities.getIntAttribute(photosetsElement, ""pages"")); photosetsObject.setPerPage(XMLUtilities.getIntAttribute(photosetsElement, ""perpage"")); photosetsObject.setTotal(XMLUtilities.getIntAttribute(photosetsElement, ""total"")); List<Photoset> photosets = new ArrayList<Photoset>(); NodeList photosetElements = photosetsElement.getElementsByTagName(""photoset""); for (int i = 0; i < photosetElements.getLength(); i++) { Element photosetElement = (Element) photosetElements.item(i); Photoset photoset = new Photoset(); photoset.setId(photosetElement.getAttribute(""id"")); User owner = new User(); owner.setId(photosetElement.getAttribute(""owner"")); photoset.setOwner(owner); Element primaryPhotoExtrasEl = XMLUtilities.getChild(photosetElement, ""primary_photo_extras""); Photo primaryPhoto; if (primaryPhotoExtrasEl != null) { primaryPhoto = PhotoUtils.createPhoto(primaryPhotoExtrasEl); } else { primaryPhoto = new Photo(); } primaryPhoto.setId(photosetElement.getAttribute(""primary"")); primaryPhoto.setSecret(photosetElement.getAttribute(""secret"")); primaryPhoto.setServer(photosetElement.getAttribute(""server"")); primaryPhoto.setFarm(photosetElement.getAttribute(""farm"")); photoset.setPrimaryPhoto(primaryPhoto); photoset.setSecret(photosetElement.getAttribute(""secret"")); photoset.setServer(photosetElement.getAttribute(""server"")); photoset.setFarm(photosetElement.getAttribute(""farm"")); photoset.setPhotoCount(photosetElement.getAttribute(""photos"")); photoset.setVideoCount(Integer.parseInt(photosetElement.getAttribute(""videos""))); photoset.setViewCount(Integer.parseInt(photosetElement.getAttribute(""count_views""))); photoset.setCommentCount(Integer.parseInt(photosetElement.getAttribute(""count_comments""))); photoset.setDateCreate(photosetElement.getAttribute(""date_create"")); photoset.setDateUpdate(photosetElement.getAttribute(""date_update"")); photoset.setIsCanComment(""1"".equals(photosetElement.getAttribute(""can_comment""))); photoset.setIsNeedsInterstitial(""1"".equals(photosetElement.getAttribute(""needs_interstitial""))); photoset.setIsVisible(""1"".equals(photosetElement.getAttribute(""visibility_can_see_set""))); photoset.setDescription(XMLUtilities.getChildValue(photosetElement, ""description"")); photoset.setTitle(XMLUtilities.getChildValue(photosetElement, ""title"")); photoset.setDescription(XMLUtilities.getChildValue(photosetElement, ""description"")); photosets.add(photoset); } photosetsObject.setPhotosets(photosets); return photosetsObject; } public int getPhotosetCount(String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); if (userId != null) { parameters.put(""user_id"", userId); } parameters.put(""per_page"", String.valueOf(1)); parameters.put(""page"", String.valueOf(1)); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosetsElement = response.getPayload(); return Integer.valueOf(photosetsElement.getAttribute(""total"")); } public PhotoList<Photo> getPhotos(String photosetId, Set<String> extras, int privacy_filter, int perPage, int page) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PHOTOS); parameters.put(""photoset_id"", photosetId); if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); } if (privacy_filter > 0) { parameters.put(""privacy_filter"", """" + privacy_filter); } if (extras != null && !extras.isEmpty()) { parameters.put(Extras.KEY_EXTRAS, StringUtilities.join(extras, "","")); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photoset = response.getPayload(); NodeList photoElements = photoset.getElementsByTagName(""photo""); photos.setPage(photoset.getAttribute(""page"")); photos.setPages(photoset.getAttribute(""pages"")); photos.setPerPage(photoset.getAttribute(""per_page"")); photos.setTotal(photoset.getAttribute(""total"")); for (int i = 0; i < photoElements.getLength(); i++) { Element photoElement = (Element) photoElements.item(i); photos.add(PhotoUtils.createPhoto(photoElement, photoset)); } return photos; } public PhotoList<Photo> getPhotos(String photosetId, int perPage, int page) throws FlickrException { return getPhotos(photosetId, Extras.MIN_EXTRAS, Flickr.PRIVACY_LEVEL_NO_FILTER, perPage, page); } public void orderSets(String[] photosetIds) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ORDER_SETS); ; parameters.put(""photoset_ids"", StringUtilities.join(photosetIds, "","")); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void removePhoto(String photosetId, String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REMOVE_PHOTO); parameters.put(""photoset_id"", photosetId); parameters.put(""photo_id"", photoId); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void removePhotos(String photosetId, String photoIds) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REMOVE_PHOTOS); parameters.put(""photoset_id"", photosetId); parameters.put(""photo_ids"", photoIds); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void reorderPhotos(String photosetId, String photoIds) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REORDER_PHOTOS); parameters.put(""photoset_id"", photosetId); parameters.put(""photo_ids"", photoIds); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void setPrimaryPhoto(String photosetId, String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_PRIMARY_PHOTO); parameters.put(""photoset_id"", photosetId); parameters.put(""photo_id"", photoId); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } } "," package com.flickr4java.flickr.photosets;  import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.photos.Extras; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoContext; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.util.StringUtilities; import com.flickr4java.flickr.util.XMLUtilities; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Set;  /**
 * Interface for working with photosets.
 * 
 * @author Anthony Eden
 * @version $Id: PhotosetsInterface.java,v 1.27 2009/11/08 21:58:00 x-mago Exp $
 */ public class PhotosetsInterface {  private static Logger _log = LoggerFactory.getLogger(PhotosetsInterface.class);  public static final String METHOD_ADD_PHOTO = ""flickr.photosets.addPhoto"";  public static final String METHOD_CREATE = ""flickr.photosets.create"";  public static final String METHOD_DELETE = ""flickr.photosets.delete"";  public static final String METHOD_EDIT_META = ""flickr.photosets.editMeta"";  public static final String METHOD_EDIT_PHOTOS = ""flickr.photosets.editPhotos"";  public static final String METHOD_GET_CONTEXT = ""flickr.photosets.getContext"";  public static final String METHOD_GET_INFO = ""flickr.photosets.getInfo"";  public static final String METHOD_GET_LIST = ""flickr.photosets.getList"";  public static final String METHOD_GET_PHOTOS = ""flickr.photosets.getPhotos"";  public static final String METHOD_ORDER_SETS = ""flickr.photosets.orderSets"";  public static final String METHOD_REMOVE_PHOTO = ""flickr.photosets.removePhoto"";  public static final String METHOD_REMOVE_PHOTOS = ""flickr.photosets.removePhotos"";  public static final String METHOD_REORDER_PHOTOS = ""flickr.photosets.reorderPhotos"";  public static final String METHOD_SET_PRIMARY_PHOTO = ""flickr.photosets.setPrimaryPhoto"";  private final String apiKey;  private final String sharedSecret;  private final Transport transportAPI;  public PhotosetsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; }  /**
     * Add a photo to the end of the photoset.
     * <p>
     * Note: requires authentication with the new authentication API with 'write' permission.
     * 
     * @param photosetId
     *            The photoset ID
     * @param photoId
     *            The photo ID
     */ public void addPhoto(String photosetId, String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD_PHOTO);  parameters.put(""photoset_id"", photosetId); parameters.put(""photo_id"", photoId);  Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Create a new photoset.
     * 
     * @param title
     *            The photoset title
     * @param description
     *            The photoset description
     * @param primaryPhotoId
     *            The primary photo id
     * @return The new Photset
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Photoset create(String title, String description, String primaryPhotoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_CREATE);  parameters.put(""title"", title); parameters.put(""description"", description); parameters.put(""primary_photo_id"", primaryPhotoId);  Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosetElement = response.getPayload(); Photoset photoset = new Photoset(); photoset.setId(photosetElement.getAttribute(""id"")); photoset.setUrl(photosetElement.getAttribute(""url"")); return photoset; }  /**
     * Delete the specified photoset.
     * 
     * @param photosetId
     *            The photoset ID
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void delete(String photosetId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_DELETE);  parameters.put(""photoset_id"", photosetId);  Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Modify the meta-data for a photoset.
     * 
     * @param photosetId
     *            The photoset ID
     * @param title
     *            A new title
     * @param description
     *            A new description (can be null)
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void editMeta(String photosetId, String title, String description) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT_META);  parameters.put(""photoset_id"", photosetId); parameters.put(""title"", title); if (description != null) { parameters.put(""description"", description); }  Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Edit which photos are in the photoset.
     * 
     * @param photosetId
     *            The photoset ID
     * @param primaryPhotoId
     *            The primary photo Id
     * @param photoIds
     *            The photo IDs for the photos in the set
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void editPhotos(String photosetId, String primaryPhotoId, String[] photoIds) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT_PHOTOS);  parameters.put(""photoset_id"", photosetId); parameters.put(""primary_photo_id"", primaryPhotoId); parameters.put(""photo_ids"", StringUtilities.join(photoIds, "",""));  Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Get a photo's context in the specified photo set.
     * 
     * This method does not require authentication.
     * 
     * @param photoId
     *            The photo ID
     * @param photosetId
     *            The photoset ID
     * @return The PhotoContext
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PhotoContext getContext(String photoId, String photosetId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CONTEXT);  parameters.put(""photo_id"", photoId); parameters.put(""photoset_id"", photosetId);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Collection<Element> payload = response.getPayloadCollection(); PhotoContext photoContext = new PhotoContext(); for (Element element : payload) { String elementName = element.getTagName(); if (elementName.equals(""prevphoto"")) { Photo photo = new Photo(); photo.setId(element.getAttribute(""id"")); photoContext.setPreviousPhoto(photo); } else if (elementName.equals(""nextphoto"")) { Photo photo = new Photo(); photo.setId(element.getAttribute(""id"")); photoContext.setNextPhoto(photo); } else if (elementName.equals(""count"")) { // TODO: process this information } else { <FILL_ME> } } return photoContext; }  /**
     * Get the information for a specified photoset.
     * 
     * This method does not require authentication.
     * 
     * @param photosetId
     *            The photoset ID
     * @return The Photoset
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Photoset getInfo(String photosetId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO);  parameters.put(""photoset_id"", photosetId);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosetElement = response.getPayload(); Photoset photoset = new Photoset(); photoset.setId(photosetElement.getAttribute(""id""));  User owner = new User(); owner.setId(photosetElement.getAttribute(""owner"")); photoset.setOwner(owner);  Photo primaryPhoto = new Photo(); primaryPhoto.setId(photosetElement.getAttribute(""primary"")); primaryPhoto.setSecret(photosetElement.getAttribute(""secret"")); // TODO verify that this is the secret for the photo primaryPhoto.setServer(photosetElement.getAttribute(""server"")); // TODO verify that this is the server for the photo primaryPhoto.setFarm(photosetElement.getAttribute(""farm"")); photoset.setPrimaryPhoto(primaryPhoto);  // TODO remove secret/server/farm from photoset? // It's rather related to the primaryPhoto, then to the photoset itself. photoset.setSecret(photosetElement.getAttribute(""secret"")); photoset.setServer(photosetElement.getAttribute(""server"")); photoset.setFarm(photosetElement.getAttribute(""farm"")); photoset.setPhotoCount(photosetElement.getAttribute(""count_photos"")); photoset.setVideoCount(Integer.parseInt(photosetElement.getAttribute(""count_videos""))); photoset.setViewCount(Integer.parseInt(photosetElement.getAttribute(""count_views""))); photoset.setCommentCount(Integer.parseInt(photosetElement.getAttribute(""count_comments""))); photoset.setDateCreate(photosetElement.getAttribute(""date_create"")); photoset.setDateUpdate(photosetElement.getAttribute(""date_update""));  photoset.setIsCanComment(""1"".equals(photosetElement.getAttribute(""can_comment"")));  photoset.setTitle(XMLUtilities.getChildValue(photosetElement, ""title"")); photoset.setDescription(XMLUtilities.getChildValue(photosetElement, ""description"")); photoset.setPrimaryPhoto(primaryPhoto);  return photoset; }  /**
     * Get a list of all photosets for the specified user.
     * 
     * This method does not require authentication. But to get a Photoset into the list, that contains just private photos, the call needs to be authenticated.
     * 
     * @param userId
     *            The User id
     * @return The Photosets collection
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Photosets getList(String userId) throws FlickrException { return getList(userId, 0, 0, null); }  /**
     * Get a list of all photosets for the specified user.
     * 
     * This method does not require authentication. But to get a Photoset into the list, that contains just private photos, the call needs to be authenticated.
     * 
     * @param userId
     *            The User id
     * @param primaryPhotoExtras
     *            A comma-delimited list of extra information to fetch for the primary photo
     * @return The Photosets collection
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Photosets getList(String userId, String primaryPhotoExtras) throws FlickrException { return getList(userId, 0, 0, primaryPhotoExtras); }  /**
     * Get a list of all photosets for the specified user.
     * 
     * This method does not require authentication. But to get a Photoset into the list, that contains just private photos, the call needs to be authenticated.
     * 
     * @param userId
     *            The User id
     * @param perPage
     *            The number of photosets per page
     * @param page
     *            The page offset
     * @param primaryPhotoExtras
     *            A comma-delimited list of extra information to fetch for the primary photo
     * @return The Photosets collection
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Photosets getList(String userId, int perPage, int page, String primaryPhotoExtras) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST);  if (userId != null) { parameters.put(""user_id"", userId); }  if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); }  if (page > 0) { parameters.put(""page"", String.valueOf(page)); }  if (primaryPhotoExtras != null) { parameters.put(""primary_photo_extras"", primaryPhotoExtras); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Photosets photosetsObject = new Photosets(); Element photosetsElement = response.getPayload(); photosetsObject.setCanCreate(XMLUtilities.getBooleanAttribute(photosetsElement, ""cancreate"")); photosetsObject.setPage(XMLUtilities.getIntAttribute(photosetsElement, ""page"")); photosetsObject.setPages(XMLUtilities.getIntAttribute(photosetsElement, ""pages"")); photosetsObject.setPerPage(XMLUtilities.getIntAttribute(photosetsElement, ""perpage"")); photosetsObject.setTotal(XMLUtilities.getIntAttribute(photosetsElement, ""total"")); List<Photoset> photosets = new ArrayList<Photoset>(); NodeList photosetElements = photosetsElement.getElementsByTagName(""photoset""); for (int i = 0; i < photosetElements.getLength(); i++) { Element photosetElement = (Element) photosetElements.item(i); Photoset photoset = new Photoset(); photoset.setId(photosetElement.getAttribute(""id""));  User owner = new User(); owner.setId(photosetElement.getAttribute(""owner"")); photoset.setOwner(owner);  Element primaryPhotoExtrasEl = XMLUtilities.getChild(photosetElement, ""primary_photo_extras""); Photo primaryPhoto; if (primaryPhotoExtrasEl != null) { primaryPhoto = PhotoUtils.createPhoto(primaryPhotoExtrasEl); } else { primaryPhoto = new Photo(); } primaryPhoto.setId(photosetElement.getAttribute(""primary"")); primaryPhoto.setSecret(photosetElement.getAttribute(""secret"")); // TODO verify that this is the secret for the photo primaryPhoto.setServer(photosetElement.getAttribute(""server"")); // TODO verify that this is the server for the photo primaryPhoto.setFarm(photosetElement.getAttribute(""farm"")); photoset.setPrimaryPhoto(primaryPhoto);  photoset.setSecret(photosetElement.getAttribute(""secret"")); photoset.setServer(photosetElement.getAttribute(""server"")); photoset.setFarm(photosetElement.getAttribute(""farm"")); photoset.setPhotoCount(photosetElement.getAttribute(""photos"")); photoset.setVideoCount(Integer.parseInt(photosetElement.getAttribute(""videos""))); photoset.setViewCount(Integer.parseInt(photosetElement.getAttribute(""count_views""))); photoset.setCommentCount(Integer.parseInt(photosetElement.getAttribute(""count_comments""))); photoset.setDateCreate(photosetElement.getAttribute(""date_create"")); photoset.setDateUpdate(photosetElement.getAttribute(""date_update""));  photoset.setIsCanComment(""1"".equals(photosetElement.getAttribute(""can_comment""))); photoset.setIsNeedsInterstitial(""1"".equals(photosetElement.getAttribute(""needs_interstitial""))); photoset.setIsVisible(""1"".equals(photosetElement.getAttribute(""visibility_can_see_set""))); photoset.setDescription(XMLUtilities.getChildValue(photosetElement, ""description""));  photoset.setTitle(XMLUtilities.getChildValue(photosetElement, ""title"")); photoset.setDescription(XMLUtilities.getChildValue(photosetElement, ""description""));  photosets.add(photoset); }  photosetsObject.setPhotosets(photosets);  return photosetsObject; }  /**
     * Convenience method.
     * 
     * Get the total number of sets belonging to a user
     * 
     * @param userId
     *            The User id
     * @return int The number of photosets
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public int getPhotosetCount(String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST);  if (userId != null) { parameters.put(""user_id"", userId); }  // Request the bare minimum parameters.put(""per_page"", String.valueOf(1)); parameters.put(""page"", String.valueOf(1));  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosetsElement = response.getPayload();  return Integer.valueOf(photosetsElement.getAttribute(""total"")); }  /**
     * Get a collection of Photo objects for the specified Photoset.
     * 
     * This method does not require authentication.
     * 
     * @see com.flickr4java.flickr.photos.Extras
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_NO_FILTER
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_PUBLIC
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FRIENDS
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FRIENDS_FAMILY
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FAMILY
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FRIENDS
     * @param photosetId
     *            The photoset ID
     * @param extras
     *            Set of extra-fields
     * @param privacy_filter
     *            filter value for authenticated calls
     * @param perPage
     *            The number of photos per page
     * @param page
     *            The page offset
     * @return PhotoList The Collection of Photo objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PhotoList<Photo> getPhotos(String photosetId, Set<String> extras, int privacy_filter, int perPage, int page) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PHOTOS);  parameters.put(""photoset_id"", photosetId);  if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); }  if (page > 0) { parameters.put(""page"", String.valueOf(page)); }  if (privacy_filter > 0) { parameters.put(""privacy_filter"", """" + privacy_filter); }  if (extras != null && !extras.isEmpty()) { parameters.put(Extras.KEY_EXTRAS, StringUtilities.join(extras, "","")); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element photoset = response.getPayload(); NodeList photoElements = photoset.getElementsByTagName(""photo""); photos.setPage(photoset.getAttribute(""page"")); photos.setPages(photoset.getAttribute(""pages"")); photos.setPerPage(photoset.getAttribute(""per_page"")); photos.setTotal(photoset.getAttribute(""total""));  for (int i = 0; i < photoElements.getLength(); i++) { Element photoElement = (Element) photoElements.item(i); photos.add(PhotoUtils.createPhoto(photoElement, photoset)); }  return photos; }  /**
     * Convenience method.
     * 
     * Calls getPhotos() with Extras.MIN_EXTRAS and Flickr.PRIVACY_LEVEL_NO_FILTER.
     * 
     * This method does not require authentication.
     * 
     * @see com.flickr4java.flickr.photos.Extras
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_NO_FILTER
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_PUBLIC
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FRIENDS
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FRIENDS_FAMILY
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FAMILY
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FRIENDS
     * @param photosetId
     *            The photoset ID
     * @param perPage
     *            The number of photos per page
     * @param page
     *            The page offset
     * @return PhotoList The Collection of Photo objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PhotoList<Photo> getPhotos(String photosetId, int perPage, int page) throws FlickrException { return getPhotos(photosetId, Extras.MIN_EXTRAS, Flickr.PRIVACY_LEVEL_NO_FILTER, perPage, page); }  /**
     * Set the order in which sets are returned for the user.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param photosetIds
     *            An array of Ids
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void orderSets(String[] photosetIds) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ORDER_SETS); ;  parameters.put(""photoset_ids"", StringUtilities.join(photosetIds, "",""));  Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Remove a photo from the set.
     * 
     * @param photosetId
     *            The photoset ID
     * @param photoId
     *            The photo ID
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void removePhoto(String photosetId, String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REMOVE_PHOTO);  parameters.put(""photoset_id"", photosetId); parameters.put(""photo_id"", photoId);  Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Remove a photo from the set.
     * 
     * @param photosetId
     *            The photoset ID
     * @param photoIds
     *            The ID's of the photos, in CVS format
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void removePhotos(String photosetId, String photoIds) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REMOVE_PHOTOS);  parameters.put(""photoset_id"", photosetId); parameters.put(""photo_ids"", photoIds);  Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Remove a photo from the set.
     * 
     * @param photosetId
     *            The photoset ID
     * @param photoIds
     *            The ID's of the photos, in CSV format, in the order they need to be in.
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void reorderPhotos(String photosetId, String photoIds) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REORDER_PHOTOS);  parameters.put(""photoset_id"", photosetId); parameters.put(""photo_ids"", photoIds);  Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Remove a photo from the set.
     * 
     * @param photosetId
     *            The photoset ID
     * @param photoId
     *            The photo ID that is being added
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void setPrimaryPhoto(String photosetId, String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_PRIMARY_PHOTO);  parameters.put(""photoset_id"", photosetId); parameters.put(""photo_id"", photoId);  Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  }  "
src/main/java/com/flickr4java/flickr/places/Location.java,"package com.flickr4java.flickr.places;

/**
 * A Flickr place.<br>
 * As a result to {@link PlacesInterface#getInfo(String, String)} a Location describes the relation of a place to various types of other places.
 * 
 * @author mago
 * @version $Id: Location.java,v 1.4 2009/07/12 22:43:07 x-mago Exp $
 * @see com.flickr4java.flickr.photos.SearchParameters#setPlaceId(String)
 * @see com.flickr4java.flickr.photos.Photo#getPlaceId()
 */
public class Location {
    private static final long serialVersionUID = 12L;

    private String woeId = """";

    private String placeId = """";

    private String placeUrl = """";

    private Place locality = null;

    private int accuracy = 0;
    
    private Place county = null;

    private Place region = null;

    private Place country = null;

    private double latitude = 0.0;

    private double longitude = 0.0;

    private int placeType = 0;
    
    private String timezone;
    
    private String name;
    
    private String woeName;
    
    private boolean hasShapeData;
    
    private ShapeData shapeData;

    public Location() {
    }

    public String getPlaceId() {
        return placeId;
    }

    public void setPlaceId(String placeId) {
        this.placeId = placeId;
    }

    public String getPlaceUrl() {
        return placeUrl;
    }

    public void setPlaceUrl(String placeUrl) {
        this.placeUrl = placeUrl;
    }

    public Place getLocality() {
        return locality;
    }

    public void setLocality(Place locality) {
        this.locality = locality;
    }

    public Place getCounty() {
        return county;
    }

    public void setCounty(Place county) {
        this.county = county;
    }

    public Place getRegion() {
        return region;
    }

    public void setRegion(Place region) {
        this.region = region;
    }

    public Place getCountry() {
        return country;
    }

    public void setCountry(Place country) {
        this.country = country;
    }

    /**
     * 
     * @return woeid
     * @see com.flickr4java.flickr.photos.SearchParameters#setWoeId(String)
     */
    public String getWoeId() {
        return woeId;
    }

    public void setWoeId(String woeId) {
        this.woeId = woeId;
    }

    public double getLatitude() {
        return latitude;
    }

    public void setLatitude(String latitude) {
        try {
            setLatitude(Double.parseDouble(latitude));
        } catch (NumberFormatException e) {
        }
    }

    public void setLatitude(double latitude) {
        this.latitude = latitude;
    }

    public double getLongitude() {
        return longitude;
    }

    public void setLongitude(String longitude) {
        try {
            setLongitude(Double.parseDouble(longitude));
        } catch (NumberFormatException e) {
        }
    }

    public void setLongitude(double longitude) {
        this.longitude = longitude;
    }

    public int getPlaceType() {
        return placeType;
    }

    public void setPlaceType(int placeType) {
        this.placeType = placeType;
    }

	public int getAccuracy() {
		return accuracy;
	}

	public void setAccuracy(int accuracy) {
		this.accuracy = accuracy;
	}

	public String getTimezone() {
		return timezone;
	}

	public void setTimezone(String timezone) {
		this.timezone = timezone;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getWoeName() {
		return woeName;
	}

	public void setWoeName(String woeName) {
		this.woeName = woeName;
	}

	public boolean isHasShapeData() {
		return hasShapeData;
	}

	public void setIsHasShapeData(boolean hasShapeData) {
		this.hasShapeData = hasShapeData;
	}

	public ShapeData getShapedata() {
		return shapeData;
	}

	public void setShapedata(ShapeData shapeData) {
		this.shapeData = shapeData;
	}



}
","package com.flickr4java.flickr.places; public class Location { private static final long serialVersionUID = 12L; private String woeId = """"; private String placeId = """"; private String placeUrl = """"; private Place locality = null; private int accuracy = 0; private Place county = null; private Place region = null; private Place country = null; private double latitude = 0.0; private double longitude = 0.0; private int placeType = 0; private String timezone; private String name; private String woeName; private boolean hasShapeData; private ShapeData shapeData; public Location() { } public String getPlaceId() { return placeId; } public void setPlaceId(String placeId) { this.placeId = placeId; } public String getPlaceUrl() { return placeUrl; } public void setPlaceUrl(String placeUrl) { this.placeUrl = placeUrl; } public Place getLocality() { return locality; } public void setLocality(Place locality) { this.locality = locality; } public Place getCounty() { return county; } public void setCounty(Place county) { this.county = county; } public Place getRegion() { return region; } public void setRegion(Place region) { this.region = region; } public Place getCountry() { return country; } public void setCountry(Place country) { this.country = country; } public String getWoeId() { return woeId; } public void setWoeId(String woeId) { this.woeId = woeId; } public double getLatitude() { return latitude; } public void setLatitude(String latitude) { try { setLatitude(Double.parseDouble(latitude)); } catch (NumberFormatException e) { } } public void setLatitude(double latitude) { this.latitude = latitude; } public double getLongitude() { return longitude; } public void setLongitude(String longitude) { try { setLongitude(Double.parseDouble(longitude)); } catch (NumberFormatException e) { } } public void setLongitude(double longitude) { this.longitude = longitude; } public int getPlaceType() { return placeType; } public void setPlaceType(int placeType) { this.placeType = placeType; } public int getAccuracy() { return accuracy; } public void setAccuracy(int accuracy) { this.accuracy = accuracy; } public String getTimezone() { return timezone; } public void setTimezone(String timezone) { this.timezone = timezone; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getWoeName() { return woeName; } public void setWoeName(String woeName) { this.woeName = woeName; } public boolean isHasShapeData() { return hasShapeData; } public void setIsHasShapeData(boolean hasShapeData) { this.hasShapeData = hasShapeData; } public ShapeData getShapedata() { return shapeData; } public void setShapedata(ShapeData shapeData) { this.shapeData = shapeData; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.places; public class Location { private static final long serialVersionUID = 12L; private String woeId = """"; private String placeId = """"; private String placeUrl = """"; private Place locality = null; private int accuracy = 0; private Place county = null; private Place region = null; private Place country = null; private double latitude = 0.0; private double longitude = 0.0; private int placeType = 0; private String timezone; private String name; private String woeName; private boolean hasShapeData; private ShapeData shapeData; public Location() { } public String getPlaceId() { return placeId; } public void setPlaceId(String placeId) { this.placeId = placeId; } public String getPlaceUrl() { return placeUrl; } public void setPlaceUrl(String placeUrl) { this.placeUrl = placeUrl; } public Place getLocality() { return locality; } public void setLocality(Place locality) { this.locality = locality; } public Place getCounty() { return county; } public void setCounty(Place county) { this.county = county; } public Place getRegion() { return region; } public void setRegion(Place region) { this.region = region; } public Place getCountry() { return country; } public void setCountry(Place country) { this.country = country; } public String getWoeId() { return woeId; } public void setWoeId(String woeId) { this.woeId = woeId; } public double getLatitude() { return latitude; } public void setLatitude(String latitude) { try { setLatitude(Double.parseDouble(latitude)); } catch (NumberFormatException e) { } } public void setLatitude(double latitude) { this.latitude = latitude; } public double getLongitude() { return longitude; } public void setLongitude(String longitude) { try { setLongitude(Double.parseDouble(longitude)); } catch (NumberFormatException e) { } } public void setLongitude(double longitude) { this.longitude = longitude; } public int getPlaceType() { return placeType; } public void setPlaceType(int placeType) { this.placeType = placeType; } public int getAccuracy() { return accuracy; } public void setAccuracy(int accuracy) { this.accuracy = accuracy; } public String getTimezone() { return timezone; } public void setTimezone(String timezone) { this.timezone = timezone; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getWoeName() { return woeName; } public void setWoeName(String woeName) { this.woeName = woeName; } public boolean isHasShapeData() { return hasShapeData; } public void setIsHasShapeData(boolean hasShapeData) { this.hasShapeData = hasShapeData; } public ShapeData getShapedata() { return shapeData; } public void setShapedata(ShapeData shapeData) { this.shapeData = shapeData; } } ","package com.flickr4java.flickr.places;  /**
 * A Flickr place.<br>
 * As a result to {@link PlacesInterface#getInfo(String, String)} a Location describes the relation of a place to various types of other places.
 * 
 * @author mago
 * @version $Id: Location.java,v 1.4 2009/07/12 22:43:07 x-mago Exp $
 * @see com.flickr4java.flickr.photos.SearchParameters#setPlaceId(String)
 * @see com.flickr4java.flickr.photos.Photo#getPlaceId()
 */ public class Location { private static final long serialVersionUID = 12L;  private String woeId = """";  private String placeId = """";  private String placeUrl = """";  private Place locality = null;  private int accuracy = 0;      private Place county = null;  private Place region = null;  private Place country = null;  private double latitude = 0.0;  private double longitude = 0.0;  private int placeType = 0;      private String timezone;      private String name;      private String woeName;      private boolean hasShapeData;      private ShapeData shapeData;  public Location() { }  public String getPlaceId() { return placeId; }  public void setPlaceId(String placeId) { this.placeId = placeId; }  public String getPlaceUrl() { return placeUrl; }  public void setPlaceUrl(String placeUrl) { this.placeUrl = placeUrl; }  public Place getLocality() { return locality; }  public void setLocality(Place locality) { this.locality = locality; }  public Place getCounty() { return county; }  public void setCounty(Place county) { this.county = county; }  public Place getRegion() { return region; }  public void setRegion(Place region) { this.region = region; }  public Place getCountry() { return country; }  public void setCountry(Place country) { this.country = country; }  /**
     * 
     * @return woeid
     * @see com.flickr4java.flickr.photos.SearchParameters#setWoeId(String)
     */ public String getWoeId() { return woeId; }  public void setWoeId(String woeId) { this.woeId = woeId; }  public double getLatitude() { return latitude; }  public void setLatitude(String latitude) { try { setLatitude(Double.parseDouble(latitude)); } catch (NumberFormatException e) { } }  public void setLatitude(double latitude) { this.latitude = latitude; }  public double getLongitude() { return longitude; }  public void setLongitude(String longitude) { try { setLongitude(Double.parseDouble(longitude)); } catch (NumberFormatException e) { } }  public void setLongitude(double longitude) { this.longitude = longitude; }  public int getPlaceType() { return placeType; }  public void setPlaceType(int placeType) { this.placeType = placeType; }  public int getAccuracy() { return accuracy; }  public void setAccuracy(int accuracy) { this.accuracy = accuracy; }  public String getTimezone() { return timezone; }  public void setTimezone(String timezone) { this.timezone = timezone; }  public String getName() { return name; }  public void setName(String name) { this.name = name; }  public String getWoeName() { return woeName; }  public void setWoeName(String woeName) { this.woeName = woeName; }  public boolean isHasShapeData() { return hasShapeData; }  public void setIsHasShapeData(boolean hasShapeData) { this.hasShapeData = hasShapeData; }  public ShapeData getShapedata() { return shapeData; }  public void setShapedata(ShapeData shapeData) { this.shapeData = shapeData; } 

 }  "
src/main/java/com/flickr4java/flickr/places/Place.java,"package com.flickr4java.flickr.places;

/**
 * Describes a place inside a {@link Location}.
 * 
 * Each place contain its place ID, corresponding URL (underneath <a href=""http://www.flickr.com/places/"" target=""_top"">http://www.flickr.com/places/</a>) and
 * place type for disambiguating different locations with the same name.
 * <p>
 * 
 * A place delivered by find contains an URL, whereas the URL is missing if delivered by resolvePlaceId and resolvePlaceUrl.
 * 
 * @author mago
 * @version $Id: Place.java,v 1.7 2009/07/12 22:43:07 x-mago Exp $
 */
public class Place {
    private static final long serialVersionUID = 12L;

    public static final int TYPE_UNSET = 0;

    public static final int TYPE_LOCALITY = 7;

    public static final int TYPE_COUNTY = 9;

    public static final int TYPE_REGION = 8;

    public static final int TYPE_COUNTRY = 12;

    public static final int TYPE_CONTINENT = 29;

    public static final int TYPE_NEIGHBOURHOOD = 22;

    private String name = """";

    private String placeId = """";

    private String woeId = """";

    private double latitude = 0.0;

    private double longitude = 0.0;

    /**
     * Set only if requested by find.
     */
    private String placeUrl = """";

    private int placeType = 0;

    private int photoCount = 0;

    public Place() {
    }

    public Place(String placeId, String name) {
        this.name = name;
        this.placeId = placeId;
    }

    public Place(String placeId, String name, int placeType) {
        this.name = name;
        this.placeId = placeId;
        this.placeType = placeType;
    }

    public Place(String placeId, String name, String woeId) {
        this.name = name;
        this.placeId = placeId;
        this.woeId = woeId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPlaceId() {
        return placeId;
    }

    public void setPlaceId(String placeId) {
        this.placeId = placeId;
    }

    /**
     * The PlaceType.
     * 
     * @return The PlaceType
     * @see Place#TYPE_COUNTRY
     * @see Place#TYPE_COUNTY
     * @see Place#TYPE_LOCALITY
     * @see Place#TYPE_REGION
     */
    public int getPlaceType() {
        return placeType;
    }

    /**
     * The PlaceType.
     * 
     * @param placeType
     * @see Place#TYPE_COUNTRY
     * @see Place#TYPE_COUNTY
     * @see Place#TYPE_LOCALITY
     * @see Place#TYPE_REGION
     * @see Place#TYPE_NEIGHBOURHOOD
     * @see Place#TYPE_CONTINENT
     */
    public void setPlaceType(int placeType) {
        this.placeType = placeType;
    }

    public void setPlaceType(String placeType) {
        try {
            setPlaceType(Integer.parseInt(placeType));
        } catch (NumberFormatException e) {
        }
    }

    public String getPlaceUrl() {
        return placeUrl;
    }

    public void setPlaceUrl(String placeUrl) {
        this.placeUrl = placeUrl;
    }

    public String getWoeId() {
        return woeId;
    }

    public void setWoeId(String woeId) {
        this.woeId = woeId;
    }

    public double getLatitude() {
        return latitude;
    }

    public void setLatitude(String latitude) {
        try {
            setLatitude(Double.parseDouble(latitude));
        } catch (NumberFormatException e) {
        }
    }

    public void setLatitude(double latitude) {
        this.latitude = latitude;
    }

    public double getLongitude() {
        return longitude;
    }

    public void setLongitude(String longitude) {
        try {
            setLongitude(Double.parseDouble(longitude));
        } catch (NumberFormatException e) {
        }
    }

    public void setLongitude(double longitude) {
        this.longitude = longitude;
    }

    public int getPhotoCount() {
        return photoCount;
    }

    public void setPhotoCount(String photoCount) {
        try {
            setPhotoCount(Integer.parseInt(photoCount));
        } catch (NumberFormatException e) {
        }
    }

    public void setPhotoCount(int photoCount) {
        this.photoCount = photoCount;
    }

    @Override
    public String toString() {
        return String.format(""%s (%s)"", name, placeId);
    }
}
","package com.flickr4java.flickr.places; public class Place { private static final long serialVersionUID = 12L; public static final int TYPE_UNSET = 0; public static final int TYPE_LOCALITY = 7; public static final int TYPE_COUNTY = 9; public static final int TYPE_REGION = 8; public static final int TYPE_COUNTRY = 12; public static final int TYPE_CONTINENT = 29; public static final int TYPE_NEIGHBOURHOOD = 22; private String name = """"; private String placeId = """"; private String woeId = """"; private double latitude = 0.0; private double longitude = 0.0; private String placeUrl = """"; private int placeType = 0; private int photoCount = 0; public Place() { } public Place(String placeId, String name) { this.name = name; this.placeId = placeId; } public Place(String placeId, String name, int placeType) { this.name = name; this.placeId = placeId; this.placeType = placeType; } public Place(String placeId, String name, String woeId) { this.name = name; this.placeId = placeId; this.woeId = woeId; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPlaceId() { return placeId; } public void setPlaceId(String placeId) { this.placeId = placeId; } public int getPlaceType() { return placeType; } public void setPlaceType(int placeType) { this.placeType = placeType; } public void setPlaceType(String placeType) { try { setPlaceType(Integer.parseInt(placeType)); } catch (NumberFormatException e) { } } public String getPlaceUrl() { return placeUrl; } public void setPlaceUrl(String placeUrl) { this.placeUrl = placeUrl; } public String getWoeId() { return woeId; } public void setWoeId(String woeId) { this.woeId = woeId; } public double getLatitude() { return latitude; } public void setLatitude(String latitude) { try { setLatitude(Double.parseDouble(latitude)); } catch (NumberFormatException e) { } } public void setLatitude(double latitude) { this.latitude = latitude; } public double getLongitude() { return longitude; } public void setLongitude(String longitude) { try { setLongitude(Double.parseDouble(longitude)); } catch (NumberFormatException e) { } } public void setLongitude(double longitude) { this.longitude = longitude; } public int getPhotoCount() { return photoCount; } public void setPhotoCount(String photoCount) { try { setPhotoCount(Integer.parseInt(photoCount)); } catch (NumberFormatException e) { } } public void setPhotoCount(int photoCount) { this.photoCount = photoCount; } @Override
    public String toString() { return String.format(""%s (%s)"", name, placeId); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.places; public class Place { private static final long serialVersionUID = 12L; public static final int TYPE_UNSET = 0; public static final int TYPE_LOCALITY = 7; public static final int TYPE_COUNTY = 9; public static final int TYPE_REGION = 8; public static final int TYPE_COUNTRY = 12; public static final int TYPE_CONTINENT = 29; public static final int TYPE_NEIGHBOURHOOD = 22; private String name = """"; private String placeId = """"; private String woeId = """"; private double latitude = 0.0; private double longitude = 0.0; private String placeUrl = """"; private int placeType = 0; private int photoCount = 0; public Place() { } public Place(String placeId, String name) { this.name = name; this.placeId = placeId; } public Place(String placeId, String name, int placeType) { this.name = name; this.placeId = placeId; this.placeType = placeType; } public Place(String placeId, String name, String woeId) { this.name = name; this.placeId = placeId; this.woeId = woeId; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPlaceId() { return placeId; } public void setPlaceId(String placeId) { this.placeId = placeId; } public int getPlaceType() { return placeType; } public void setPlaceType(int placeType) { this.placeType = placeType; } public void setPlaceType(String placeType) { try { setPlaceType(Integer.parseInt(placeType)); } catch (NumberFormatException e) { } } public String getPlaceUrl() { return placeUrl; } public void setPlaceUrl(String placeUrl) { this.placeUrl = placeUrl; } public String getWoeId() { return woeId; } public void setWoeId(String woeId) { this.woeId = woeId; } public double getLatitude() { return latitude; } public void setLatitude(String latitude) { try { setLatitude(Double.parseDouble(latitude)); } catch (NumberFormatException e) { } } public void setLatitude(double latitude) { this.latitude = latitude; } public double getLongitude() { return longitude; } public void setLongitude(String longitude) { try { setLongitude(Double.parseDouble(longitude)); } catch (NumberFormatException e) { } } public void setLongitude(double longitude) { this.longitude = longitude; } public int getPhotoCount() { return photoCount; } public void setPhotoCount(String photoCount) { try { setPhotoCount(Integer.parseInt(photoCount)); } catch (NumberFormatException e) { } } public void setPhotoCount(int photoCount) { this.photoCount = photoCount; } @Override
    public String toString() { return String.format(""%s (%s)"", name, placeId); } } ","package com.flickr4java.flickr.places;  /**
 * Describes a place inside a {@link Location}.
 * 
 * Each place contain its place ID, corresponding URL (underneath <a href=""http://www.flickr.com/places/"" target=""_top"">http://www.flickr.com/places/</a>) and
 * place type for disambiguating different locations with the same name.
 * <p>
 * 
 * A place delivered by find contains an URL, whereas the URL is missing if delivered by resolvePlaceId and resolvePlaceUrl.
 * 
 * @author mago
 * @version $Id: Place.java,v 1.7 2009/07/12 22:43:07 x-mago Exp $
 */ public class Place { private static final long serialVersionUID = 12L;  public static final int TYPE_UNSET = 0;  public static final int TYPE_LOCALITY = 7;  public static final int TYPE_COUNTY = 9;  public static final int TYPE_REGION = 8;  public static final int TYPE_COUNTRY = 12;  public static final int TYPE_CONTINENT = 29;  public static final int TYPE_NEIGHBOURHOOD = 22;  private String name = """";  private String placeId = """";  private String woeId = """";  private double latitude = 0.0;  private double longitude = 0.0;  /**
     * Set only if requested by find.
     */ private String placeUrl = """";  private int placeType = 0;  private int photoCount = 0;  public Place() { }  public Place(String placeId, String name) { this.name = name; this.placeId = placeId; }  public Place(String placeId, String name, int placeType) { this.name = name; this.placeId = placeId; this.placeType = placeType; }  public Place(String placeId, String name, String woeId) { this.name = name; this.placeId = placeId; this.woeId = woeId; }  public String getName() { return name; }  public void setName(String name) { this.name = name; }  public String getPlaceId() { return placeId; }  public void setPlaceId(String placeId) { this.placeId = placeId; }  /**
     * The PlaceType.
     * 
     * @return The PlaceType
     * @see Place#TYPE_COUNTRY
     * @see Place#TYPE_COUNTY
     * @see Place#TYPE_LOCALITY
     * @see Place#TYPE_REGION
     */ public int getPlaceType() { return placeType; }  /**
     * The PlaceType.
     * 
     * @param placeType
     * @see Place#TYPE_COUNTRY
     * @see Place#TYPE_COUNTY
     * @see Place#TYPE_LOCALITY
     * @see Place#TYPE_REGION
     * @see Place#TYPE_NEIGHBOURHOOD
     * @see Place#TYPE_CONTINENT
     */ public void setPlaceType(int placeType) { this.placeType = placeType; }  public void setPlaceType(String placeType) { try { setPlaceType(Integer.parseInt(placeType)); } catch (NumberFormatException e) { } }  public String getPlaceUrl() { return placeUrl; }  public void setPlaceUrl(String placeUrl) { this.placeUrl = placeUrl; }  public String getWoeId() { return woeId; }  public void setWoeId(String woeId) { this.woeId = woeId; }  public double getLatitude() { return latitude; }  public void setLatitude(String latitude) { try { setLatitude(Double.parseDouble(latitude)); } catch (NumberFormatException e) { } }  public void setLatitude(double latitude) { this.latitude = latitude; }  public double getLongitude() { return longitude; }  public void setLongitude(String longitude) { try { setLongitude(Double.parseDouble(longitude)); } catch (NumberFormatException e) { } }  public void setLongitude(double longitude) { this.longitude = longitude; }  public int getPhotoCount() { return photoCount; }  public void setPhotoCount(String photoCount) { try { setPhotoCount(Integer.parseInt(photoCount)); } catch (NumberFormatException e) { } }  public void setPhotoCount(int photoCount) { this.photoCount = photoCount; }  @Override
    public String toString() { return String.format(""%s (%s)"", name, placeId); } }  "
src/main/java/com/flickr4java/flickr/places/PlaceType.java,"package com.flickr4java.flickr.places;

/**
 * PlaceType as requested by {@link PlacesInterface#getPlaceTypes()}
 * 
 * @see Place#TYPE_COUNTRY
 * @see Place#TYPE_COUNTY
 * @see Place#TYPE_LOCALITY
 * @see Place#TYPE_REGION
 * @see Place#TYPE_NEIGHBOURHOOD
 * @see Place#TYPE_CONTINENT
 * @author mago
 * @version $Id: PlaceType.java,v 1.2 2009/07/12 22:43:07 x-mago Exp $
 */
public class PlaceType {
    private static final long serialVersionUID = 12L;

    int placeTypeId;

    String placeTypeName;

    public int getPlaceTypeId() {
        return placeTypeId;
    }

    public void setPlaceTypeId(String placeTypeId) {
        try {
            setPlaceTypeId(Integer.parseInt(placeTypeId));
        } catch (NumberFormatException e) {
        }
    }

    public void setPlaceTypeId(int placeTypeId) {
        this.placeTypeId = placeTypeId;
    }

    public String getPlaceTypeName() {
        return placeTypeName;
    }

    public void setPlaceTypeName(String placeTypeName) {
        this.placeTypeName = placeTypeName;
    }

}
",package com.flickr4java.flickr.places; public class PlaceType { private static final long serialVersionUID = 12L; int placeTypeId; String placeTypeName; public int getPlaceTypeId() { return placeTypeId; } public void setPlaceTypeId(String placeTypeId) { try { setPlaceTypeId(Integer.parseInt(placeTypeId)); } catch (NumberFormatException e) { } } public void setPlaceTypeId(int placeTypeId) { this.placeTypeId = placeTypeId; } public String getPlaceTypeName() { return placeTypeName; } public void setPlaceTypeName(String placeTypeName) { this.placeTypeName = placeTypeName; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.places; public class PlaceType { private static final long serialVersionUID = 12L; int placeTypeId; String placeTypeName; public int getPlaceTypeId() { return placeTypeId; } public void setPlaceTypeId(String placeTypeId) { try { setPlaceTypeId(Integer.parseInt(placeTypeId)); } catch (NumberFormatException e) { } } public void setPlaceTypeId(int placeTypeId) { this.placeTypeId = placeTypeId; } public String getPlaceTypeName() { return placeTypeName; } public void setPlaceTypeName(String placeTypeName) { this.placeTypeName = placeTypeName; } } ,"package com.flickr4java.flickr.places;  /**
 * PlaceType as requested by {@link PlacesInterface#getPlaceTypes()}
 * 
 * @see Place#TYPE_COUNTRY
 * @see Place#TYPE_COUNTY
 * @see Place#TYPE_LOCALITY
 * @see Place#TYPE_REGION
 * @see Place#TYPE_NEIGHBOURHOOD
 * @see Place#TYPE_CONTINENT
 * @author mago
 * @version $Id: PlaceType.java,v 1.2 2009/07/12 22:43:07 x-mago Exp $
 */ public class PlaceType { private static final long serialVersionUID = 12L;  int placeTypeId;  String placeTypeName;  public int getPlaceTypeId() { return placeTypeId; }  public void setPlaceTypeId(String placeTypeId) { try { setPlaceTypeId(Integer.parseInt(placeTypeId)); } catch (NumberFormatException e) { } }  public void setPlaceTypeId(int placeTypeId) { this.placeTypeId = placeTypeId; }  public String getPlaceTypeName() { return placeTypeName; }  public void setPlaceTypeName(String placeTypeName) { this.placeTypeName = placeTypeName; }  }  "
src/main/java/com/flickr4java/flickr/places/PlacesInterface.java,"package com.flickr4java.flickr.places;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.photos.SearchParameters;
import com.flickr4java.flickr.tags.Tag;
import com.flickr4java.flickr.util.StringUtilities;
import com.flickr4java.flickr.util.XMLUtilities;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.text.DateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

/**
 * Lookup Flickr Places.
 * <p>
 *
 * Note: As of May 2021 many of these methods no longer seem to work correctly in the Flickr API.
 * Confirmed via the https://www.flickr.com/services/api/ page.
 * 
 * Announcement on places from yahoo:
 * <p>
 * 
 * <PRE>
 * From: kellan - kellan@yahoo-inc.com
 * Date: Fri, 11 Jan 2008 15:57:59 -0800
 * Subject: [yws-flickr] Flickr and ""Place IDs""
 * 
 * At Flickr we've got a really big database that lists a significant
 * percentage of the places that exist in the world, and a few that don't.
 * When you geotag a photo we try to identify the ""place"" (neighborhood,
 * village, city, county, state, or country) where the photo was taken. And
 * we assign that photo a ""place ID"".
 * 
 * A place ID is a globally unique identifier for a place on Earth.  A city
 * has a place ID, so do counties, states, and countries.  Even some
 * neighborhoods and landmarks have them, though Flickr isn't currently
 * tracking those. And we're starting to expose these place IDs around Flickr.
 * 
 * ### Place IDs and flickr.photos.search()
 * 
 * The Flickr API method flickr.photos.search() now accepts place_id as an
 * argument.  Along with all of the other parameters you can
 * search on you can now scope your search to a given place.   Historically
 * you've been able to pass bounding boxes to the API, but calculating the
 * right bounding box for a city is tricky, and you can get noise and bad
 * results around the edge.  Now you can pass a single non-ambiguous string
 * and get photos geotagged in San Francisco, CA, or Ohio, or Beijing.
 * (kH8dLOubBZRvX_YZ, LtkqzVqbApjAbJxv, and wpK7URqbAJnWB90W respectively)
 * 
 * The documentation has been updated at:
 * http://www.flickr.com/services/api/flickr.photos.search.html
 * 
 * ### Sources of Place IDs
 * 
 * Place IDs are now returned from a number of source:
 * flickr.photos.getInfo will return place IDs for geotagged photos
 * available as a microformat on the appropriate Places page
 * flickr.places.resolvePlaceURL, and flickr.places.resolvePlaceId are
 * available for round tripping Flickr Places URLs.
 * 
 * http://www.flickr.com/services/api/flickr.photos.getInfo.html
 * http://www.flickr.com/services/api/flickr.places.resolvePlaceURL.html
 * http://www.flickr.com/services/api/flickr.places.resolvePlaceId.html
 * 
 * ### More Place IDs
 * 
 * Right now you can also place IDs in the places URL, and pass them to the
 * map like so:
 * 
 * http://flickr.com/places/wpK7URqbAJnWB90W
 * http://flickr.com/map?place_id=kH8dLOubBZRvX_YZ
 * 
 * ### Place IDs elsewhere
 * 
 * The especially eagle-eyed among you might recognize Place IDs.  Upcoming
 * has been quietly using them for months to uniquely identify their metros.
 * 
 * See events from San Francisco at:
 * http://upcoming.yahoo.com/place/kH8dLOubBZRvX_YZ
 * 
 * See photos from San Francisco at: http://flickr.com/places/kH8dLOubBZRvX_YZ
 * 
 * Additionally Yahoo's skunkworks project FireEagle will also support
 * place IDs.
 * 
 * And yes, there is more work to do, but we're exciting about this as a start.
 * 
 * Thanks,
 * -kellan
 * </PRE>
 * 
 * @author mago
 * @version $Id: PlacesInterface.java,v 1.10 2011/07/02 19:47:35 x-mago Exp $
 */
public class PlacesInterface {
    private static final String METHOD_FIND = ""flickr.places.find"";

    private static final String METHOD_FIND_BY_LATLON = ""flickr.places.findByLatLon"";

    private static final String METHOD_RESOLVE_PLACE_ID = ""flickr.places.resolvePlaceId"";

    private static final String METHOD_RESOLVE_PLACE_URL = ""flickr.places.resolvePlaceURL"";

    private static final String METHOD_GET_CHILDREN_WITH_PHOTOS_PUBLIC = ""flickr.places.getChildrenWithPhotosPublic"";

    private static final String METHOD_GET_INFO = ""flickr.places.getInfo"";

    private static final String METHOD_GET_INFO_BY_URL = ""flickr.places.getInfoByUrl"";

    private static final String METHOD_GET_PLACETYPES = ""flickr.places.getPlaceTypes"";

    private static final String METHOD_GET_SHAPEHISTORY = ""flickr.places.getShapeHistory"";

    private static final String METHOD_GET_TOP_PLACES_LIST = ""flickr.places.getTopPlacesList"";

    private static final String METHOD_PLACES_FOR_BOUNDINGBOX = ""flickr.places.placesForBoundingBox"";

    private static final String METHOD_PLACES_FOR_CONTACTS = ""flickr.places.placesForContacts"";

    private static final String METHOD_PLACES_FOR_TAGS = ""flickr.places.placesForTags"";

    private static final String METHOD_PLACES_FOR_USER = ""flickr.places.placesForUser"";

    private static final String METHOD_TAGS_FOR_PLACE = ""flickr.places.tagsForPlace"";

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transportAPI;

    public PlacesInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transportAPI;
    }

    /**
     * Return a list of place IDs for a query string.
     * 
     * The flickr.places.find method is not a geocoder. It will round ""up"" to the nearest place type to which place IDs apply. For example, if you pass it a
     * street level address it will return the city that contains the address rather than the street, or building, itself.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param query
     * @return PlacesList
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PlacesList<Place> find(String query) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        PlacesList<Place> placesList = new PlacesList<Place>();
        parameters.put(""method"", METHOD_FIND);

        parameters.put(""query"", query);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element placesElement = response.getPayload();
        NodeList placesNodes = placesElement.getElementsByTagName(""place"");
        placesList.setPage(""1"");
        placesList.setPages(""1"");
        placesList.setPerPage("""" + placesNodes.getLength());
        placesList.setTotal("""" + placesNodes.getLength());
        for (int i = 0; i < placesNodes.getLength(); i++) {
            Element placeElement = (Element) placesNodes.item(i);
            placesList.add(parsePlace(placeElement));
        }
        return placesList;
    }

    /**
     * Return a place ID for a latitude, longitude and accuracy triple.
     * <p>
     * 
     * The flickr.places.findByLatLon method is not meant to be a (reverse) geocoder in the traditional sense. It is designed to allow users to find photos for
     * ""places"" and will round up to the nearest place type to which corresponding place IDs apply.
     * <p>
     * 
     * For example, if you pass it a street level coordinate it will return the city that contains the point rather than the street, or building, itself.
     * <p>
     * 
     * It will also truncate latitudes and longitudes to three decimal points.
     * <p>
     * 
     * The gory details :
     * 
     * This is (most of) the same magic that is performed when you geotag one of your photos on the site itself. We know that at the neighbourhood level this
     * can get messy and not always return the correct location.
     * <p>
     * 
     * At the city level things are much better but there may still be some gotchas floating around. Sometimes it's as simple as a bug and other times it is an
     * issue of two competing ideas of where a place ""is"".
     * <p>
     * 
     * This comes with the territory and we are eager to identify and wherever possible fix the problems so when you see something that looks wrong please be
     * gentle :-)
     * <p>
     * 
     * (Reports of incorrect places sent to mailing list will not be ignored but it would be better if you could use the forums for that sort of thing.)
     * <p>
     * 
     * Also, as we do on the site if we can not identify a location for a point as a specific accuracy we pop up the stack and try again. For example, if we
     * can't find a city for a given set of coordinates we try instead to locate the state.
     * <p>
     * 
     * As mentioned above, this method is not designed to serve as a general purpose (reverse) geocoder which is partly reflected by the truncated lat/long
     * coordinates.
     * <p>
     * 
     * If you think that three decimal points are the cause of wonky results locating photos for places, we are happy to investigate but until then it should be
     * All Good (tm).
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param latitude
     *            The latitude whose valid range is -90 to 90. Anything more than 4 decimal places will be truncated.
     * @param longitude
     *            The longitude whose valid range is -180 to 180. Anything more than 4 decimal places will be truncated.
     * @param accuracy
     * @return A PlacesList
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PlacesList<Place> findByLatLon(double latitude, double longitude, int accuracy) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        PlacesList<Place> placesList = new PlacesList<Place>();
        parameters.put(""method"", METHOD_FIND_BY_LATLON);

        parameters.put(""lat"", """" + Double.toString(latitude));
        parameters.put(""lon"", """" + Double.toString(longitude));
        parameters.put(""accuracy"", """" + Integer.toString(accuracy));

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element placesElement = response.getPayload();
        NodeList placesNodes = placesElement.getElementsByTagName(""place"");
        placesList.setPage(""1"");
        placesList.setPages(""1"");
        placesList.setPerPage("""" + placesNodes.getLength());
        placesList.setTotal("""" + placesNodes.getLength());
        for (int i = 0; i < placesNodes.getLength(); i++) {
            Element placeElement = (Element) placesNodes.item(i);
            placesList.add(parsePlace(placeElement));
        }
        return placesList;
    }

    /**
     * <p>
     * Return a list of locations with public photos that are parented by a Where on Earth (WOE) or Places ID.
     * </p>
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param placeId
     *            A Flickr Places ID. Can be null. (While optional, you must pass either a valid Places ID or a WOE ID.)
     * @param woeId
     *            A Where On Earth (WOE) ID. Can be null. (While optional, you must pass either a valid Places ID or a WOE ID.)
     * @return List of Places
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PlacesList<Place> getChildrenWithPhotosPublic(String placeId, String woeId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        PlacesList<Place> placesList = new PlacesList<Place>();
        parameters.put(""method"", METHOD_GET_CHILDREN_WITH_PHOTOS_PUBLIC);

        if (placeId != null) {
            parameters.put(""place_id"", placeId);
        }
        if (woeId != null) {
            parameters.put(""woe_id"", woeId);
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element placesElement = response.getPayload();
        NodeList placesNodes = placesElement.getElementsByTagName(""place"");
        placesList.setPage(""1"");
        placesList.setPages(""1"");
        placesList.setPerPage("""" + placesNodes.getLength());
        placesList.setTotal("""" + placesNodes.getLength());
        for (int i = 0; i < placesNodes.getLength(); i++) {
            Element placeElement = (Element) placesNodes.item(i);
            placesList.add(parsePlace(placeElement));
        }
        return placesList;
    }

    /**
     * Get informations about a place.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param placeId
     *            A Flickr Places ID. Optional, can be null. (While optional, you must pass either a valid Places ID or a WOE ID.)
     * @param woeId
     *            A Where On Earth (WOE) ID. Optional, can be null. (While optional, you must pass either a valid Places ID or a WOE ID.)
     * @return A Location
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Location getInfo(String placeId, String woeId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_INFO);

        if (placeId != null) {
            parameters.put(""place_id"", placeId);
        }
        if (woeId != null) {
            parameters.put(""woe_id"", woeId);
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element locationElement = response.getPayload();
        return parseLocation(locationElement);
    }

    /**
     * Lookup information about a place, by its flickr.com/places URL.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param url
     * @return A Location
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Location getInfoByUrl(String url) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_INFO_BY_URL);

        parameters.put(""url"", url);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element locationElement = response.getPayload();
        return parseLocation(locationElement);
    }

    /**
     * Fetches a list of available place types for Flickr.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @return A list of placetypes
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public ArrayList<PlaceType> getPlaceTypes() throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_PLACETYPES);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        ArrayList<PlaceType> placeTypeList = new ArrayList<PlaceType>();
        Element placeTypeElement = response.getPayload();
        NodeList placeTypeNodes = placeTypeElement.getElementsByTagName(""place_type"");
        for (int i = 0; i < placeTypeNodes.getLength(); i++) {
            placeTypeElement = (Element) placeTypeNodes.item(i);
            PlaceType placeType = new PlaceType();
            placeType.setPlaceTypeId(placeTypeElement.getAttribute(""id""));
            placeType.setPlaceTypeName(XMLUtilities.getValue(placeTypeElement));
            placeTypeList.add(placeType);
        }
        return placeTypeList;
    }

    /**
     * Return an historical list of all the shape data generated for a Places or Where on Earth (WOE) ID.
     * <p>
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * <p>
     * Not working. As it was not possible to find any results. Not even the ones, that have been described in the announcement of this feature.
     * </p>
     * 
     * @param placeId
     *            A Flickr Places ID. Optional, can be null.
     * @param woeId
     *            A Where On Earth (WOE) ID. Optional, can be null.
     * @return A list of shapes
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public ShapeDataList<ShapeData> getShapeHistory(String placeId, String woeId) throws FlickrException {
        ShapeDataList<ShapeData> shapeList = new ShapeDataList<ShapeData>();
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_SHAPEHISTORY);

        if (placeId != null) {
            parameters.put(""place_id"", placeId);
        }
        if (woeId != null) {
            parameters.put(""woe_id"", woeId);
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element shapeElements = response.getPayload();
        shapeList.setTotal(Integer.parseInt(shapeElements.getAttribute(""total"")));
        shapeList.setWoeId(shapeElements.getAttribute(""woe_id""));
        shapeList.setPlaceId(shapeElements.getAttribute(""place_id""));
        shapeList.setPlaceType(shapeElements.getAttribute(""place_type""));
        shapeList.setPlaceTypeId(Integer.parseInt(shapeElements.getAttribute(""place_type_id"")));
        NodeList shapeNodes = shapeElements.getElementsByTagName(""shape"");
        for (int i = 0; i < shapeNodes.getLength(); i++) {
            Element shapeElement = (Element) shapeNodes.item(i);
            ShapeData data = new ShapeData();
            data.setAlpha(Double.parseDouble(shapeElement.getAttribute(""alpha"")));
            data.setCountEdges(Integer.parseInt(shapeElement.getAttribute(""count_edges"")));
            data.setCountPoints(Integer.parseInt(shapeElement.getAttribute(""count_points"")));
            data.setCreated(shapeElement.getAttribute(""created""));
            data.setIsDonutHole(""1"".equals(shapeElement.getAttribute(""is_donuthole"")));
            data.setHasDonuthole(""1"".equals(shapeElement.getAttribute(""has_donuthole"")));

            Element polyElement = XMLUtilities.getChild(shapeElement, ""polylines"");
            data.setPolyline(XMLUtilities.getChildValue(polyElement, ""polyline""));
            Element urlElement = XMLUtilities.getChild(shapeElement, ""urls"");
            data.setShapefile(XMLUtilities.getChildValue(urlElement, ""shapefile""));
            shapeList.add(data);
        }

        return shapeList;
    }

    /**
     * Return the top 100 most geotagged places for a day.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param placeType
     * @param date
     *            Optional, can be null. The default is yesterday.
     * @param placeId
     *            A Flickr Places ID. Optional, can be null.
     * @param woeId
     *            A Where On Earth (WOE) ID. Optional, can be null.
     * @return PlacesList
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PlacesList<Place> getTopPlacesList(int placeType, Date date, String placeId, String woeId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        PlacesList<Place> placesList = new PlacesList<Place>();
        parameters.put(""method"", METHOD_GET_TOP_PLACES_LIST);

        parameters.put(""place_type"", intPlaceTypeToString(placeType));
        if (placeId != null) {
            parameters.put(""place_id"", placeId);
        }
        if (woeId != null) {
            parameters.put(""woe_id"", woeId);
        }
        if (date != null) {
            parameters.put(""date"", ((DateFormat) SearchParameters.DATE_FORMATS.get()).format(date));
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element placesElement = response.getPayload();
        NodeList placesNodes = placesElement.getElementsByTagName(""place"");
        placesList.setPage(""1"");
        placesList.setPages(""1"");
        placesList.setPerPage("""" + placesNodes.getLength());
        placesList.setTotal("""" + placesNodes.getLength());
        for (int i = 0; i < placesNodes.getLength(); i++) {
            Element placeElement = (Element) placesNodes.item(i);
            placesList.add(parsePlace(placeElement));
        }
        return placesList;
    }

    /**
     * Return all the locations of a matching place type for a bounding box.
     * <p>
     * 
     * The maximum allowable size of a bounding box (the distance between the SW and NE corners) is governed by the place type you are requesting. Allowable
     * sizes are as follows:
     * <ul>
     * <li>neighbourhood: 3km (1.8mi)</li>
     * <li>locality: 7km (4.3mi)</li>
     * <li>county: 50km (31mi)</li>
     * <li>region: 200km (124mi)</li>
     * <li>country: 500km (310mi)</li>
     * <li>continent: 1500km (932mi)</li>
     * </ul>
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param bbox
     * @param placeType
     * @return A PlacesList
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PlacesList<Place> placesForBoundingBox(int placeType, String bbox) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        PlacesList<Place> placesList = new PlacesList<Place>();
        parameters.put(""method"", METHOD_PLACES_FOR_BOUNDINGBOX);

        parameters.put(""place_type"", intPlaceTypeToString(placeType));
        parameters.put(""bbox"", bbox);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element placesElement = response.getPayload();
        NodeList placesNodes = placesElement.getElementsByTagName(""place"");
        placesList.setPage(""1"");
        placesList.setPages(""1"");
        placesList.setPerPage("""" + placesNodes.getLength());
        placesList.setTotal("""" + placesNodes.getLength());
        placesList.setBBox(placesElement.getAttribute(""bbox""));
        placesList.setPlaceType(placesElement.getAttribute(""place_type""));
        for (int i = 0; i < placesNodes.getLength(); i++) {
            Element placeElement = (Element) placesNodes.item(i);
            placesList.add(parsePlace(placeElement));
        }
        return placesList;
    }

    /**
     * Return a list of the top 100 unique places clustered by a given placetype for a user's contacts.
     * 
     * @param placeType
     *            Use Type-constants at {@link Place}
     * @param placeId
     *            A Flickr Places ID. Optional, can be null.
     * @param woeId
     *            A Where On Earth (WOE) ID. Optional, can be null.
     * @param threshold
     *            The minimum number of photos that a place type must have to be included. If the number of photos is lowered then the parent place type for
     *            that place will be used. Optional, can be null.
     * @param contacts
     *            Search your contacts. Either 'all' or 'ff' for just friends and family. (Optional, default is all)
     * @return A PlacesList
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PlacesList<Place> placesForContacts(int placeType, String placeId, String woeId, String threshold, String contacts) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        PlacesList<Place> placesList = new PlacesList<Place>();
        parameters.put(""method"", METHOD_PLACES_FOR_CONTACTS);

        parameters.put(""place_type"", intPlaceTypeToString(placeType));
        if (placeId != null) {
            parameters.put(""place_id"", placeId);
        }
        if (woeId != null) {
            parameters.put(""woe_id"", woeId);
        }
        if (threshold != null) {
            parameters.put(""threshold"", threshold);
        }
        if (contacts != null) {
            parameters.put(""contacts"", contacts);
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element placesElement = response.getPayload();
        NodeList placesNodes = placesElement.getElementsByTagName(""place"");
        placesList.setPage(""1"");
        placesList.setPages(""1"");
        placesList.setPerPage("""" + placesNodes.getLength());
        placesList.setTotal("""" + placesNodes.getLength());
        for (int i = 0; i < placesNodes.getLength(); i++) {
            Element placeElement = (Element) placesNodes.item(i);
            placesList.add(parsePlace(placeElement));
        }
        return placesList;
    }

    /**
     * Return a list of the top 100 unique places clustered by a given placetype for set of tags or machine tags.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param placeTypeId
     * @param woeId
     *            A Where On Earth (WOE) ID. Optional, can be null. (While optional, you must pass either a valid Places ID or a WOE ID.)
     * @param placeId
     *            A Flickr Places ID. Optional, can be null. (While optional, you must pass either a valid Places ID or a WOE ID.)
     * @param threshold
     *            The minimum number of photos that a place type must have to be included. If the number of photos is lowered then the parent place type for
     *            that place will be used. Optional, can be null.
     * @param tags
     *            A String-array of Tags. Photos with one or more of the tags listed will be returned. Optional, can be null.
     * @param tagMode
     *            Either 'any' for an OR combination of tags, or 'all' for an AND combination. Defaults to 'any' if not specified. Optional, can be null.
     * @param machineTags
     * @param machineTagMode
     *            Either 'any' for an OR combination of tags, or 'all' for an AND combination. Defaults to 'any' if not specified. Optional, can be null.
     * @param minUploadDate
     *            Optional, can be null.
     * @param maxUploadDate
     *            Optional, can be null.
     * @param minTakenDate
     *            Optional, can be null.
     * @param maxTakenDate
     *            Optional, can be null.
     * @return A PlacesList
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PlacesList<Place> placesForTags(int placeTypeId, String woeId, String placeId, String threshold, String[] tags, String tagMode, String machineTags,
            String machineTagMode, Date minUploadDate, Date maxUploadDate, Date minTakenDate, Date maxTakenDate) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        PlacesList<Place> placesList = new PlacesList<Place>();
        parameters.put(""method"", METHOD_PLACES_FOR_TAGS);

        parameters.put(""place_type_id"", Integer.toString(placeTypeId));
        if (woeId != null) {
            parameters.put(""woe_id"", woeId);
        }
        if (placeId != null) {
            parameters.put(""place_id"", placeId);
        }
        if (threshold != null) {
            parameters.put(""threshold"", threshold);
        }
        if (tags != null) {
            parameters.put(""tags"", StringUtilities.join(tags, "",""));
        }
        if (tagMode != null) {
            parameters.put(""tag_mode"", tagMode);
        }
        if (machineTags != null) {
            parameters.put(""machine_tags"", machineTags);
        }
        if (machineTagMode != null) {
            parameters.put(""machine_tag_mode"", machineTagMode);
        }
        if (minUploadDate != null) {
            parameters.put(""min_upload_date"", Long.toString(minUploadDate.getTime() / 1000L));
        }
        if (maxUploadDate != null) {
            parameters.put(""max_upload_date"", Long.toString(maxUploadDate.getTime() / 1000L));
        }
        if (minTakenDate != null) {
            parameters.put(""min_taken_date"", ((DateFormat) SearchParameters.MYSQL_DATE_FORMATS.get()).format(minTakenDate));
        }
        if (maxTakenDate != null) {
            parameters.put(""max_taken_date"", ((DateFormat) SearchParameters.MYSQL_DATE_FORMATS.get()).format(maxTakenDate));
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element placesElement = response.getPayload();
        NodeList placesNodes = placesElement.getElementsByTagName(""place"");
        placesList.setPage(""1"");
        placesList.setPages(""1"");
        placesList.setPerPage("""" + placesNodes.getLength());
        placesList.setTotal("""" + placesNodes.getLength());
        for (int i = 0; i < placesNodes.getLength(); i++) {
            Element placeElement = (Element) placesNodes.item(i);
            placesList.add(parsePlace(placeElement));
        }
        return placesList;
    }

    /**
     * Return a list of the top 100 unique places clustered by a given placetype for a user.
     * 
     * @param placeType
     *            Use Type-constants at {@link Place}
     * @param woeId
     *            A Where On Earth (WOE) ID. Optional, can be null.
     * @param placeId
     *            A Flickr Places ID. Optional, can be null.
     * @param threshold
     *            The minimum number of photos that a place type must have to be included. If the number of photos is lowered then the parent place type for
     *            that place will be used. Optional, can be null.
     * @param minUploadDate
     *            Optional, can be null.
     * @param maxUploadDate
     *            Optional, can be null.
     * @param minTakenDate
     *            Optional, can be null.
     * @param maxTakenDate
     *            Optional, can be null.
     * @return A PlacesList
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PlacesList<Place> placesForUser(int placeType, String woeId, String placeId, String threshold, Date minUploadDate, Date maxUploadDate,
            Date minTakenDate, Date maxTakenDate) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        PlacesList<Place> placesList = new PlacesList<Place>();
        parameters.put(""method"", METHOD_PLACES_FOR_USER);

        parameters.put(""place_type"", intPlaceTypeToString(placeType));
        if (placeId != null) {
            parameters.put(""place_id"", placeId);
        }
        if (woeId != null) {
            parameters.put(""woe_id"", woeId);
        }
        if (threshold != null) {
            parameters.put(""threshold"", threshold);
        }
        if (minUploadDate != null) {
            parameters.put(""min_upload_date"", Long.toString(minUploadDate.getTime() / 1000L));
        }
        if (maxUploadDate != null) {
            parameters.put(""max_upload_date"", Long.toString(maxUploadDate.getTime() / 1000L));
        }
        if (minTakenDate != null) {
            parameters.put(""min_taken_date"", ((DateFormat) SearchParameters.MYSQL_DATE_FORMATS.get()).format(minTakenDate));
        }
        if (maxTakenDate != null) {
            parameters.put(""max_taken_date"", ((DateFormat) SearchParameters.MYSQL_DATE_FORMATS.get()).format(maxTakenDate));
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element placesElement = response.getPayload();
        NodeList placesNodes = placesElement.getElementsByTagName(""place"");
        placesList.setPage(""1"");
        placesList.setPages(""1"");
        placesList.setPerPage("""" + placesNodes.getLength());
        placesList.setTotal("""" + placesNodes.getLength());
        for (int i = 0; i < placesNodes.getLength(); i++) {
            Element placeElement = (Element) placesNodes.item(i);
            placesList.add(parsePlace(placeElement));
        }
        return placesList;
    }

    /**
     * Find Flickr Places information by Place ID.
     * 
     * @deprecated This method has been deprecated. It won't be removed but you should use {@link #getInfo(String, String)} instead.
     * @param placeId
     * @return A Location
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    @Deprecated
    public Location resolvePlaceId(String placeId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_RESOLVE_PLACE_ID);

        parameters.put(""place_id"", placeId);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element locationElement = response.getPayload();
        return parseLocation(locationElement);
    }

    /**
     * Find Flickr Places information by Place URL.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @deprecated This method has been deprecated. It won't be removed but you should use {@link PlacesInterface#getInfoByUrl(String)} instead.
     * @param flickrPlacesUrl
     * @return A Location
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    @Deprecated
    public Location resolvePlaceURL(String flickrPlacesUrl) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_RESOLVE_PLACE_URL);

        parameters.put(""url"", flickrPlacesUrl);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element locationElement = response.getPayload();
        return parseLocation(locationElement);
    }

    /**
     * Return a list of the top 100 unique tags for a Flickr Places or Where on Earth (WOE) ID.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param woeId
     *            A Where On Earth (WOE) ID. Optional, can be null.
     * @param placeId
     *            A Flickr Places ID. Optional, can be null.
     * @param minUploadDate
     *            Optional, can be null.
     * @param maxUploadDate
     *            Optional, can be null.
     * @param minTakenDate
     *            Optional, can be null.
     * @param maxTakenDate
     *            Optional, can be null.
     * @return A list of Tags
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public ArrayList<Tag> tagsForPlace(String woeId, String placeId, Date minUploadDate, Date maxUploadDate, Date minTakenDate, Date maxTakenDate)
            throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        ArrayList<Tag> tagsList = new ArrayList<Tag>();
        parameters.put(""method"", METHOD_TAGS_FOR_PLACE);

        if (woeId != null) {
            parameters.put(""woe_id"", woeId);
        }
        if (placeId != null) {
            parameters.put(""place_id"", placeId);
        }
        if (minUploadDate != null) {
            parameters.put(""min_upload_date"", Long.toString(minUploadDate.getTime() / 1000L));
        }
        if (maxUploadDate != null) {
            parameters.put(""max_upload_date"", Long.toString(maxUploadDate.getTime() / 1000L));
        }
        if (minTakenDate != null) {
            parameters.put(""min_taken_date"", ((DateFormat) SearchParameters.MYSQL_DATE_FORMATS.get()).format(minTakenDate));
        }
        if (maxTakenDate != null) {
            parameters.put(""max_taken_date"", ((DateFormat) SearchParameters.MYSQL_DATE_FORMATS.get()).format(maxTakenDate));
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element tagsElement = response.getPayload();
        NodeList tagsNodes = tagsElement.getElementsByTagName(""tag"");
        for (int i = 0; i < tagsNodes.getLength(); i++) {
            Element tagElement = (Element) tagsNodes.item(i);
            Tag tag = new Tag();
            tag.setCount(tagElement.getAttribute(""count""));
            tag.setValue(XMLUtilities.getValue(tagElement));
            tagsList.add(tag);
        }
        return tagsList;
    }

    private Location parseLocation(Element locationElement) {
        Location location = new Location();
        Element localityElement = (Element) locationElement.getElementsByTagName(""locality"").item(0);
        Element countyElement = (Element) locationElement.getElementsByTagName(""county"").item(0);
        Element regionElement = (Element) locationElement.getElementsByTagName(""region"").item(0);
        Element countryElement = (Element) locationElement.getElementsByTagName(""country"").item(0);

        location.setPlaceId(locationElement.getAttribute(""place_id""));
        // location.setName(locationElement.getAttribute(""name""));
        location.setPlaceUrl(locationElement.getAttribute(""place_url""));
        location.setWoeId(locationElement.getAttribute(""woeid""));
        location.setLatitude(locationElement.getAttribute(""latitude""));
        location.setLongitude(locationElement.getAttribute(""longitude""));
        location.setTimezone(locationElement.getAttribute(""timezone""));
        location.setName(locationElement.getAttribute(""name""));
        location.setWoeName(locationElement.getAttribute(""woe_name""));
        location.setIsHasShapeData(""1"".equals(locationElement.getAttribute(""has_shapedata"")));
        location.setPlaceType(stringPlaceTypeToInt(locationElement.getAttribute(""place_type"")));
        location.setLocality(parseLocationPlace(localityElement, Place.TYPE_LOCALITY));
        location.setCounty(parseLocationPlace(countyElement, Place.TYPE_COUNTY));
        location.setRegion(parseLocationPlace(regionElement, Place.TYPE_REGION));
        location.setCountry(parseLocationPlace(countryElement, Place.TYPE_COUNTRY));

        return location;
    }

    private Place parseLocationPlace(Element element, int type) {
        Place place = null;
        if (element != null) {
            place = new Place();
            place.setName(XMLUtilities.getValue(element));
            place.setPlaceId(element.getAttribute(""place_id""));
            place.setPlaceUrl(element.getAttribute(""place_url""));
            place.setWoeId(element.getAttribute(""woeid""));
            place.setLatitude(element.getAttribute(""latitude""));
            place.setLongitude(element.getAttribute(""longitude""));
            place.setPlaceType(type);
        }

        return place;
    }

    private Place parsePlace(Element placeElement) {
        Place place = new Place();
        place.setPlaceId(placeElement.getAttribute(""place_id""));
        place.setPlaceUrl(placeElement.getAttribute(""place_url""));
        place.setWoeId(placeElement.getAttribute(""woeid""));
        place.setLatitude(placeElement.getAttribute(""latitude""));
        place.setLongitude(placeElement.getAttribute(""longitude""));
        place.setPhotoCount(placeElement.getAttribute(""photo_count""));
        // String typeString = placeElement.getAttribute(""place_type"");
        // Now the place-Id is directly available
        place.setPlaceType(placeElement.getAttribute(""place_type_id""));
        // place.setPlaceType(stringPlaceTypeToInt(typeString));
        place.setName(XMLUtilities.getValue(placeElement));
        return place;
    }

    private int stringPlaceTypeToInt(String typeString) {
        int placeType = 0;
        if (typeString.equals(""locality"")) {
            placeType = Place.TYPE_LOCALITY;
        } else if (typeString.equals(""county"")) {
            placeType = Place.TYPE_COUNTY;
        } else if (typeString.equals(""region"")) {
            placeType = Place.TYPE_REGION;
        } else if (typeString.equals(""country"")) {
            placeType = Place.TYPE_COUNTRY;
        } else if (typeString.equals(""continent"")) {
            placeType = Place.TYPE_CONTINENT;
        } else if (typeString.equals(""neighbourhood"")) {
            placeType = Place.TYPE_NEIGHBOURHOOD;
        }
        return placeType;
    }

    public String intPlaceTypeToString(int placeType) throws FlickrException {
        String placeTypeStr = """";
        if (placeType == Place.TYPE_COUNTRY) {
            placeTypeStr = ""country"";
        } else if (placeType == Place.TYPE_REGION) {
            placeTypeStr = ""region"";
        } else if (placeType == Place.TYPE_LOCALITY) {
            placeTypeStr = ""locality"";
        } else if (placeType == Place.TYPE_CONTINENT) {
            placeTypeStr = ""continent"";
        } else if (placeType == Place.TYPE_NEIGHBOURHOOD) {
            placeTypeStr = ""neighbourhood"";
        } else {
            throw new FlickrException(""33"", ""Not a valid place type"");
        }
        return placeTypeStr;
    }
}
","package com.flickr4java.flickr.places; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.SearchParameters; import com.flickr4java.flickr.tags.Tag; import com.flickr4java.flickr.util.StringUtilities; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.text.DateFormat; import java.util.ArrayList; import java.util.Date; import java.util.HashMap; import java.util.Map; public class PlacesInterface { private static final String METHOD_FIND = ""flickr.places.find""; private static final String METHOD_FIND_BY_LATLON = ""flickr.places.findByLatLon""; private static final String METHOD_RESOLVE_PLACE_ID = ""flickr.places.resolvePlaceId""; private static final String METHOD_RESOLVE_PLACE_URL = ""flickr.places.resolvePlaceURL""; private static final String METHOD_GET_CHILDREN_WITH_PHOTOS_PUBLIC = ""flickr.places.getChildrenWithPhotosPublic""; private static final String METHOD_GET_INFO = ""flickr.places.getInfo""; private static final String METHOD_GET_INFO_BY_URL = ""flickr.places.getInfoByUrl""; private static final String METHOD_GET_PLACETYPES = ""flickr.places.getPlaceTypes""; private static final String METHOD_GET_SHAPEHISTORY = ""flickr.places.getShapeHistory""; private static final String METHOD_GET_TOP_PLACES_LIST = ""flickr.places.getTopPlacesList""; private static final String METHOD_PLACES_FOR_BOUNDINGBOX = ""flickr.places.placesForBoundingBox""; private static final String METHOD_PLACES_FOR_CONTACTS = ""flickr.places.placesForContacts""; private static final String METHOD_PLACES_FOR_TAGS = ""flickr.places.placesForTags""; private static final String METHOD_PLACES_FOR_USER = ""flickr.places.placesForUser""; private static final String METHOD_TAGS_FOR_PLACE = ""flickr.places.tagsForPlace""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public PlacesInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public PlacesList<Place> find(String query) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PlacesList<Place> placesList = new PlacesList<Place>(); parameters.put(""method"", METHOD_FIND); parameters.put(""query"", query); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element placesElement = response.getPayload(); NodeList placesNodes = placesElement.getElementsByTagName(""place""); placesList.setPage(""1""); placesList.setPages(""1""); placesList.setPerPage("""" + placesNodes.getLength()); placesList.setTotal("""" + placesNodes.getLength()); for (int i = 0; i < placesNodes.getLength(); i++) { Element placeElement = (Element) placesNodes.item(i); placesList.add(parsePlace(placeElement)); } return placesList; } public PlacesList<Place> findByLatLon(double latitude, double longitude, int accuracy) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PlacesList<Place> placesList = new PlacesList<Place>(); parameters.put(""method"", METHOD_FIND_BY_LATLON); parameters.put(""lat"", """" + Double.toString(latitude)); parameters.put(""lon"", """" + Double.toString(longitude)); parameters.put(""accuracy"", """" + Integer.toString(accuracy)); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element placesElement = response.getPayload(); NodeList placesNodes = placesElement.getElementsByTagName(""place""); placesList.setPage(""1""); placesList.setPages(""1""); placesList.setPerPage("""" + placesNodes.getLength()); placesList.setTotal("""" + placesNodes.getLength()); for (int i = 0; i < placesNodes.getLength(); i++) { Element placeElement = (Element) placesNodes.item(i); placesList.add(parsePlace(placeElement)); } return placesList; } public PlacesList<Place> getChildrenWithPhotosPublic(String placeId, String woeId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PlacesList<Place> placesList = new PlacesList<Place>(); parameters.put(""method"", METHOD_GET_CHILDREN_WITH_PHOTOS_PUBLIC); if (placeId != null) { parameters.put(""place_id"", placeId); } if (woeId != null) { parameters.put(""woe_id"", woeId); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element placesElement = response.getPayload(); NodeList placesNodes = placesElement.getElementsByTagName(""place""); placesList.setPage(""1""); placesList.setPages(""1""); placesList.setPerPage("""" + placesNodes.getLength()); placesList.setTotal("""" + placesNodes.getLength()); for (int i = 0; i < placesNodes.getLength(); i++) { Element placeElement = (Element) placesNodes.item(i); placesList.add(parsePlace(placeElement)); } return placesList; } public Location getInfo(String placeId, String woeId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO); if (placeId != null) { parameters.put(""place_id"", placeId); } if (woeId != null) { parameters.put(""woe_id"", woeId); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element locationElement = response.getPayload(); return parseLocation(locationElement); } public Location getInfoByUrl(String url) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO_BY_URL); parameters.put(""url"", url); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element locationElement = response.getPayload(); return parseLocation(locationElement); } public ArrayList<PlaceType> getPlaceTypes() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PLACETYPES); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } ArrayList<PlaceType> placeTypeList = new ArrayList<PlaceType>(); Element placeTypeElement = response.getPayload(); NodeList placeTypeNodes = placeTypeElement.getElementsByTagName(""place_type""); for (int i = 0; i < placeTypeNodes.getLength(); i++) { placeTypeElement = (Element) placeTypeNodes.item(i); PlaceType placeType = new PlaceType(); placeType.setPlaceTypeId(placeTypeElement.getAttribute(""id"")); placeType.setPlaceTypeName(XMLUtilities.getValue(placeTypeElement)); placeTypeList.add(placeType); } return placeTypeList; } public ShapeDataList<ShapeData> getShapeHistory(String placeId, String woeId) throws FlickrException { ShapeDataList<ShapeData> shapeList = new ShapeDataList<ShapeData>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_SHAPEHISTORY); if (placeId != null) { parameters.put(""place_id"", placeId); } if (woeId != null) { parameters.put(""woe_id"", woeId); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element shapeElements = response.getPayload(); shapeList.setTotal(Integer.parseInt(shapeElements.getAttribute(""total""))); shapeList.setWoeId(shapeElements.getAttribute(""woe_id"")); shapeList.setPlaceId(shapeElements.getAttribute(""place_id"")); shapeList.setPlaceType(shapeElements.getAttribute(""place_type"")); shapeList.setPlaceTypeId(Integer.parseInt(shapeElements.getAttribute(""place_type_id""))); NodeList shapeNodes = shapeElements.getElementsByTagName(""shape""); for (int i = 0; i < shapeNodes.getLength(); i++) { Element shapeElement = (Element) shapeNodes.item(i); ShapeData data = new ShapeData(); data.setAlpha(Double.parseDouble(shapeElement.getAttribute(""alpha""))); data.setCountEdges(Integer.parseInt(shapeElement.getAttribute(""count_edges""))); data.setCountPoints(Integer.parseInt(shapeElement.getAttribute(""count_points""))); data.setCreated(shapeElement.getAttribute(""created"")); data.setIsDonutHole(""1"".equals(shapeElement.getAttribute(""is_donuthole""))); data.setHasDonuthole(""1"".equals(shapeElement.getAttribute(""has_donuthole""))); Element polyElement = XMLUtilities.getChild(shapeElement, ""polylines""); data.setPolyline(XMLUtilities.getChildValue(polyElement, ""polyline"")); Element urlElement = XMLUtilities.getChild(shapeElement, ""urls""); data.setShapefile(XMLUtilities.getChildValue(urlElement, ""shapefile"")); shapeList.add(data); } return shapeList; } public PlacesList<Place> getTopPlacesList(int placeType, Date date, String placeId, String woeId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PlacesList<Place> placesList = new PlacesList<Place>(); parameters.put(""method"", METHOD_GET_TOP_PLACES_LIST); parameters.put(""place_type"", intPlaceTypeToString(placeType)); if (placeId != null) { parameters.put(""place_id"", placeId); } if (woeId != null) { parameters.put(""woe_id"", woeId); } if (date != null) { parameters.put(""date"", ((DateFormat) SearchParameters.DATE_FORMATS.get()).format(date)); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element placesElement = response.getPayload(); NodeList placesNodes = placesElement.getElementsByTagName(""place""); placesList.setPage(""1""); placesList.setPages(""1""); placesList.setPerPage("""" + placesNodes.getLength()); placesList.setTotal("""" + placesNodes.getLength()); for (int i = 0; i < placesNodes.getLength(); i++) { Element placeElement = (Element) placesNodes.item(i); placesList.add(parsePlace(placeElement)); } return placesList; } public PlacesList<Place> placesForBoundingBox(int placeType, String bbox) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PlacesList<Place> placesList = new PlacesList<Place>(); parameters.put(""method"", METHOD_PLACES_FOR_BOUNDINGBOX); parameters.put(""place_type"", intPlaceTypeToString(placeType)); parameters.put(""bbox"", bbox); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element placesElement = response.getPayload(); NodeList placesNodes = placesElement.getElementsByTagName(""place""); placesList.setPage(""1""); placesList.setPages(""1""); placesList.setPerPage("""" + placesNodes.getLength()); placesList.setTotal("""" + placesNodes.getLength()); placesList.setBBox(placesElement.getAttribute(""bbox"")); placesList.setPlaceType(placesElement.getAttribute(""place_type"")); for (int i = 0; i < placesNodes.getLength(); i++) { Element placeElement = (Element) placesNodes.item(i); placesList.add(parsePlace(placeElement)); } return placesList; } public PlacesList<Place> placesForContacts(int placeType, String placeId, String woeId, String threshold, String contacts) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PlacesList<Place> placesList = new PlacesList<Place>(); parameters.put(""method"", METHOD_PLACES_FOR_CONTACTS); parameters.put(""place_type"", intPlaceTypeToString(placeType)); if (placeId != null) { parameters.put(""place_id"", placeId); } if (woeId != null) { parameters.put(""woe_id"", woeId); } if (threshold != null) { parameters.put(""threshold"", threshold); } if (contacts != null) { parameters.put(""contacts"", contacts); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element placesElement = response.getPayload(); NodeList placesNodes = placesElement.getElementsByTagName(""place""); placesList.setPage(""1""); placesList.setPages(""1""); placesList.setPerPage("""" + placesNodes.getLength()); placesList.setTotal("""" + placesNodes.getLength()); for (int i = 0; i < placesNodes.getLength(); i++) { Element placeElement = (Element) placesNodes.item(i); placesList.add(parsePlace(placeElement)); } return placesList; } public PlacesList<Place> placesForTags(int placeTypeId, String woeId, String placeId, String threshold, String[] tags, String tagMode, String machineTags,
            String machineTagMode, Date minUploadDate, Date maxUploadDate, Date minTakenDate, Date maxTakenDate) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PlacesList<Place> placesList = new PlacesList<Place>(); parameters.put(""method"", METHOD_PLACES_FOR_TAGS); parameters.put(""place_type_id"", Integer.toString(placeTypeId)); if (woeId != null) { parameters.put(""woe_id"", woeId); } if (placeId != null) { parameters.put(""place_id"", placeId); } if (threshold != null) { parameters.put(""threshold"", threshold); } if (tags != null) { parameters.put(""tags"", StringUtilities.join(tags, "","")); } if (tagMode != null) { parameters.put(""tag_mode"", tagMode); } if (machineTags != null) { parameters.put(""machine_tags"", machineTags); } if (machineTagMode != null) { parameters.put(""machine_tag_mode"", machineTagMode); } if (minUploadDate != null) { parameters.put(""min_upload_date"", Long.toString(minUploadDate.getTime() / 1000L)); } if (maxUploadDate != null) { parameters.put(""max_upload_date"", Long.toString(maxUploadDate.getTime() / 1000L)); } if (minTakenDate != null) { parameters.put(""min_taken_date"", ((DateFormat) SearchParameters.MYSQL_DATE_FORMATS.get()).format(minTakenDate)); } if (maxTakenDate != null) { parameters.put(""max_taken_date"", ((DateFormat) SearchParameters.MYSQL_DATE_FORMATS.get()).format(maxTakenDate)); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element placesElement = response.getPayload(); NodeList placesNodes = placesElement.getElementsByTagName(""place""); placesList.setPage(""1""); placesList.setPages(""1""); placesList.setPerPage("""" + placesNodes.getLength()); placesList.setTotal("""" + placesNodes.getLength()); for (int i = 0; i < placesNodes.getLength(); i++) { Element placeElement = (Element) placesNodes.item(i); placesList.add(parsePlace(placeElement)); } return placesList; } public PlacesList<Place> placesForUser(int placeType, String woeId, String placeId, String threshold, Date minUploadDate, Date maxUploadDate,
            Date minTakenDate, Date maxTakenDate) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PlacesList<Place> placesList = new PlacesList<Place>(); parameters.put(""method"", METHOD_PLACES_FOR_USER); parameters.put(""place_type"", intPlaceTypeToString(placeType)); if (placeId != null) { parameters.put(""place_id"", placeId); } if (woeId != null) { parameters.put(""woe_id"", woeId); } if (threshold != null) { parameters.put(""threshold"", threshold); } if (minUploadDate != null) { parameters.put(""min_upload_date"", Long.toString(minUploadDate.getTime() / 1000L)); } if (maxUploadDate != null) { parameters.put(""max_upload_date"", Long.toString(maxUploadDate.getTime() / 1000L)); } if (minTakenDate != null) { parameters.put(""min_taken_date"", ((DateFormat) SearchParameters.MYSQL_DATE_FORMATS.get()).format(minTakenDate)); } if (maxTakenDate != null) { parameters.put(""max_taken_date"", ((DateFormat) SearchParameters.MYSQL_DATE_FORMATS.get()).format(maxTakenDate)); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element placesElement = response.getPayload(); NodeList placesNodes = placesElement.getElementsByTagName(""place""); placesList.setPage(""1""); placesList.setPages(""1""); placesList.setPerPage("""" + placesNodes.getLength()); placesList.setTotal("""" + placesNodes.getLength()); for (int i = 0; i < placesNodes.getLength(); i++) { Element placeElement = (Element) placesNodes.item(i); placesList.add(parsePlace(placeElement)); } return placesList; } @Deprecated
    public Location resolvePlaceId(String placeId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_RESOLVE_PLACE_ID); parameters.put(""place_id"", placeId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element locationElement = response.getPayload(); return parseLocation(locationElement); } @Deprecated
    public Location resolvePlaceURL(String flickrPlacesUrl) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_RESOLVE_PLACE_URL); parameters.put(""url"", flickrPlacesUrl); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element locationElement = response.getPayload(); return parseLocation(locationElement); } public ArrayList<Tag> tagsForPlace(String woeId, String placeId, Date minUploadDate, Date maxUploadDate, Date minTakenDate, Date maxTakenDate)
            throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); ArrayList<Tag> tagsList = new ArrayList<Tag>(); parameters.put(""method"", METHOD_TAGS_FOR_PLACE); if (woeId != null) { parameters.put(""woe_id"", woeId); } if (placeId != null) { parameters.put(""place_id"", placeId); } if (minUploadDate != null) { parameters.put(""min_upload_date"", Long.toString(minUploadDate.getTime() / 1000L)); } if (maxUploadDate != null) { parameters.put(""max_upload_date"", Long.toString(maxUploadDate.getTime() / 1000L)); } if (minTakenDate != null) { parameters.put(""min_taken_date"", ((DateFormat) SearchParameters.MYSQL_DATE_FORMATS.get()).format(minTakenDate)); } if (maxTakenDate != null) { parameters.put(""max_taken_date"", ((DateFormat) SearchParameters.MYSQL_DATE_FORMATS.get()).format(maxTakenDate)); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element tagsElement = response.getPayload(); NodeList tagsNodes = tagsElement.getElementsByTagName(""tag""); for (int i = 0; i < tagsNodes.getLength(); i++) { Element tagElement = (Element) tagsNodes.item(i); Tag tag = new Tag(); tag.setCount(tagElement.getAttribute(""count"")); tag.setValue(XMLUtilities.getValue(tagElement)); tagsList.add(tag); } return tagsList; } private Location parseLocation(Element locationElement) { Location location = new Location(); Element localityElement = (Element) locationElement.getElementsByTagName(""locality"").item(0); Element countyElement = (Element) locationElement.getElementsByTagName(""county"").item(0); Element regionElement = (Element) locationElement.getElementsByTagName(""region"").item(0); Element countryElement = (Element) locationElement.getElementsByTagName(""country"").item(0); location.setPlaceId(locationElement.getAttribute(""place_id"")); location.setPlaceUrl(locationElement.getAttribute(""place_url"")); location.setWoeId(locationElement.getAttribute(""woeid"")); location.setLatitude(locationElement.getAttribute(""latitude"")); location.setLongitude(locationElement.getAttribute(""longitude"")); location.setTimezone(locationElement.getAttribute(""timezone"")); location.setName(locationElement.getAttribute(""name"")); location.setWoeName(locationElement.getAttribute(""woe_name"")); location.setIsHasShapeData(""1"".equals(locationElement.getAttribute(""has_shapedata""))); location.setPlaceType(stringPlaceTypeToInt(locationElement.getAttribute(""place_type""))); location.setLocality(parseLocationPlace(localityElement, Place.TYPE_LOCALITY)); location.setCounty(parseLocationPlace(countyElement, Place.TYPE_COUNTY)); location.setRegion(parseLocationPlace(regionElement, Place.TYPE_REGION)); location.setCountry(parseLocationPlace(countryElement, Place.TYPE_COUNTRY)); return location; } private Place parseLocationPlace(Element element, int type) { Place place = null; if (element != null) { place = new Place(); place.setName(XMLUtilities.getValue(element)); place.setPlaceId(element.getAttribute(""place_id"")); place.setPlaceUrl(element.getAttribute(""place_url"")); place.setWoeId(element.getAttribute(""woeid"")); place.setLatitude(element.getAttribute(""latitude"")); place.setLongitude(element.getAttribute(""longitude"")); place.setPlaceType(type); } return place; } private Place parsePlace(Element placeElement) { Place place = new Place(); place.setPlaceId(placeElement.getAttribute(""place_id"")); place.setPlaceUrl(placeElement.getAttribute(""place_url"")); place.setWoeId(placeElement.getAttribute(""woeid"")); place.setLatitude(placeElement.getAttribute(""latitude"")); place.setLongitude(placeElement.getAttribute(""longitude"")); place.setPhotoCount(placeElement.getAttribute(""photo_count"")); place.setPlaceType(placeElement.getAttribute(""place_type_id"")); place.setName(XMLUtilities.getValue(placeElement)); return place; } private int stringPlaceTypeToInt(String typeString) { int placeType = 0; if (typeString.equals(""locality"")) { placeType = Place.TYPE_LOCALITY; } else if (typeString.equals(""county"")) { placeType = Place.TYPE_COUNTY; } else if (typeString.equals(""region"")) { placeType = Place.TYPE_REGION; } else if (typeString.equals(""country"")) { placeType = Place.TYPE_COUNTRY; } else if (typeString.equals(""continent"")) { placeType = Place.TYPE_CONTINENT; } else if (typeString.equals(""neighbourhood"")) { placeType = Place.TYPE_NEIGHBOURHOOD; } return placeType; } public String intPlaceTypeToString(int placeType) throws FlickrException { String placeTypeStr = """"; if (placeType == Place.TYPE_COUNTRY) { placeTypeStr = ""country""; } else if (placeType == Place.TYPE_REGION) { placeTypeStr = ""region""; } else if (placeType == Place.TYPE_LOCALITY) { placeTypeStr = ""locality""; } else if (placeType == Place.TYPE_CONTINENT) { placeTypeStr = ""continent""; } else if (placeType == Place.TYPE_NEIGHBOURHOOD) { placeTypeStr = ""neighbourhood""; } else { throw new FlickrException(""33"", ""Not a valid place type""); } return placeTypeStr; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.places; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.SearchParameters; import com.flickr4java.flickr.tags.Tag; import com.flickr4java.flickr.util.StringUtilities; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.text.DateFormat; import java.util.ArrayList; import java.util.Date; import java.util.HashMap; import java.util.Map; public class PlacesInterface { private static final String METHOD_FIND = ""flickr.places.find""; private static final String METHOD_FIND_BY_LATLON = ""flickr.places.findByLatLon""; private static final String METHOD_RESOLVE_PLACE_ID = ""flickr.places.resolvePlaceId""; private static final String METHOD_RESOLVE_PLACE_URL = ""flickr.places.resolvePlaceURL""; private static final String METHOD_GET_CHILDREN_WITH_PHOTOS_PUBLIC = ""flickr.places.getChildrenWithPhotosPublic""; private static final String METHOD_GET_INFO = ""flickr.places.getInfo""; private static final String METHOD_GET_INFO_BY_URL = ""flickr.places.getInfoByUrl""; private static final String METHOD_GET_PLACETYPES = ""flickr.places.getPlaceTypes""; private static final String METHOD_GET_SHAPEHISTORY = ""flickr.places.getShapeHistory""; private static final String METHOD_GET_TOP_PLACES_LIST = ""flickr.places.getTopPlacesList""; private static final String METHOD_PLACES_FOR_BOUNDINGBOX = ""flickr.places.placesForBoundingBox""; private static final String METHOD_PLACES_FOR_CONTACTS = ""flickr.places.placesForContacts""; private static final String METHOD_PLACES_FOR_TAGS = ""flickr.places.placesForTags""; private static final String METHOD_PLACES_FOR_USER = ""flickr.places.placesForUser""; private static final String METHOD_TAGS_FOR_PLACE = ""flickr.places.tagsForPlace""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public PlacesInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public PlacesList<Place> find(String query) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PlacesList<Place> placesList = new PlacesList<Place>(); parameters.put(""method"", METHOD_FIND); parameters.put(""query"", query); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element placesElement = response.getPayload(); NodeList placesNodes = placesElement.getElementsByTagName(""place""); placesList.setPage(""1""); placesList.setPages(""1""); placesList.setPerPage("""" + placesNodes.getLength()); placesList.setTotal("""" + placesNodes.getLength()); for (int i = 0; i < placesNodes.getLength(); i++) { Element placeElement = (Element) placesNodes.item(i); placesList.add(parsePlace(placeElement)); } return placesList; } public PlacesList<Place> findByLatLon(double latitude, double longitude, int accuracy) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PlacesList<Place> placesList = new PlacesList<Place>(); parameters.put(""method"", METHOD_FIND_BY_LATLON); parameters.put(""lat"", """" + Double.toString(latitude)); parameters.put(""lon"", """" + Double.toString(longitude)); parameters.put(""accuracy"", """" + Integer.toString(accuracy)); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element placesElement = response.getPayload(); NodeList placesNodes = placesElement.getElementsByTagName(""place""); placesList.setPage(""1""); placesList.setPages(""1""); placesList.setPerPage("""" + placesNodes.getLength()); placesList.setTotal("""" + placesNodes.getLength()); for (int i = 0; i < placesNodes.getLength(); i++) { Element placeElement = (Element) placesNodes.item(i); placesList.add(parsePlace(placeElement)); } return placesList; } public PlacesList<Place> getChildrenWithPhotosPublic(String placeId, String woeId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PlacesList<Place> placesList = new PlacesList<Place>(); parameters.put(""method"", METHOD_GET_CHILDREN_WITH_PHOTOS_PUBLIC); if (placeId != null) { parameters.put(""place_id"", placeId); } if (woeId != null) { parameters.put(""woe_id"", woeId); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element placesElement = response.getPayload(); NodeList placesNodes = placesElement.getElementsByTagName(""place""); placesList.setPage(""1""); placesList.setPages(""1""); placesList.setPerPage("""" + placesNodes.getLength()); placesList.setTotal("""" + placesNodes.getLength()); for (int i = 0; i < placesNodes.getLength(); i++) { Element placeElement = (Element) placesNodes.item(i); placesList.add(parsePlace(placeElement)); } return placesList; } public Location getInfo(String placeId, String woeId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO); if (placeId != null) { parameters.put(""place_id"", placeId); } if (woeId != null) { parameters.put(""woe_id"", woeId); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element locationElement = response.getPayload(); return parseLocation(locationElement); } public Location getInfoByUrl(String url) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO_BY_URL); parameters.put(""url"", url); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element locationElement = response.getPayload(); return parseLocation(locationElement); } public ArrayList<PlaceType> getPlaceTypes() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PLACETYPES); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } ArrayList<PlaceType> placeTypeList = new ArrayList<PlaceType>(); Element placeTypeElement = response.getPayload(); NodeList placeTypeNodes = placeTypeElement.getElementsByTagName(""place_type""); for (int i = 0; i < placeTypeNodes.getLength(); i++) { placeTypeElement = (Element) placeTypeNodes.item(i); PlaceType placeType = new PlaceType(); placeType.setPlaceTypeId(placeTypeElement.getAttribute(""id"")); placeType.setPlaceTypeName(XMLUtilities.getValue(placeTypeElement)); placeTypeList.add(placeType); } return placeTypeList; } public ShapeDataList<ShapeData> getShapeHistory(String placeId, String woeId) throws FlickrException { ShapeDataList<ShapeData> shapeList = new ShapeDataList<ShapeData>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_SHAPEHISTORY); if (placeId != null) { parameters.put(""place_id"", placeId); } if (woeId != null) { parameters.put(""woe_id"", woeId); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element shapeElements = response.getPayload(); shapeList.setTotal(Integer.parseInt(shapeElements.getAttribute(""total""))); shapeList.setWoeId(shapeElements.getAttribute(""woe_id"")); shapeList.setPlaceId(shapeElements.getAttribute(""place_id"")); shapeList.setPlaceType(shapeElements.getAttribute(""place_type"")); shapeList.setPlaceTypeId(Integer.parseInt(shapeElements.getAttribute(""place_type_id""))); NodeList shapeNodes = shapeElements.getElementsByTagName(""shape""); for (int i = 0; i < shapeNodes.getLength(); i++) { Element shapeElement = (Element) shapeNodes.item(i); ShapeData data = new ShapeData(); data.setAlpha(Double.parseDouble(shapeElement.getAttribute(""alpha""))); data.setCountEdges(Integer.parseInt(shapeElement.getAttribute(""count_edges""))); data.setCountPoints(Integer.parseInt(shapeElement.getAttribute(""count_points""))); data.setCreated(shapeElement.getAttribute(""created"")); data.setIsDonutHole(""1"".equals(shapeElement.getAttribute(""is_donuthole""))); data.setHasDonuthole(""1"".equals(shapeElement.getAttribute(""has_donuthole""))); Element polyElement = XMLUtilities.getChild(shapeElement, ""polylines""); data.setPolyline(XMLUtilities.getChildValue(polyElement, ""polyline"")); Element urlElement = XMLUtilities.getChild(shapeElement, ""urls""); data.setShapefile(XMLUtilities.getChildValue(urlElement, ""shapefile"")); shapeList.add(data); } return shapeList; } public PlacesList<Place> getTopPlacesList(int placeType, Date date, String placeId, String woeId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PlacesList<Place> placesList = new PlacesList<Place>(); parameters.put(""method"", METHOD_GET_TOP_PLACES_LIST); parameters.put(""place_type"", intPlaceTypeToString(placeType)); if (placeId != null) { parameters.put(""place_id"", placeId); } if (woeId != null) { parameters.put(""woe_id"", woeId); } if (date != null) { parameters.put(""date"", ((DateFormat) SearchParameters.DATE_FORMATS.get()).format(date)); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element placesElement = response.getPayload(); NodeList placesNodes = placesElement.getElementsByTagName(""place""); placesList.setPage(""1""); placesList.setPages(""1""); placesList.setPerPage("""" + placesNodes.getLength()); placesList.setTotal("""" + placesNodes.getLength()); for (int i = 0; i < placesNodes.getLength(); i++) { Element placeElement = (Element) placesNodes.item(i); placesList.add(parsePlace(placeElement)); } return placesList; } public PlacesList<Place> placesForBoundingBox(int placeType, String bbox) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PlacesList<Place> placesList = new PlacesList<Place>(); parameters.put(""method"", METHOD_PLACES_FOR_BOUNDINGBOX); parameters.put(""place_type"", intPlaceTypeToString(placeType)); parameters.put(""bbox"", bbox); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element placesElement = response.getPayload(); NodeList placesNodes = placesElement.getElementsByTagName(""place""); placesList.setPage(""1""); placesList.setPages(""1""); placesList.setPerPage("""" + placesNodes.getLength()); placesList.setTotal("""" + placesNodes.getLength()); placesList.setBBox(placesElement.getAttribute(""bbox"")); placesList.setPlaceType(placesElement.getAttribute(""place_type"")); for (int i = 0; i < placesNodes.getLength(); i++) { Element placeElement = (Element) placesNodes.item(i); placesList.add(parsePlace(placeElement)); } return placesList; } public PlacesList<Place> placesForContacts(int placeType, String placeId, String woeId, String threshold, String contacts) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PlacesList<Place> placesList = new PlacesList<Place>(); parameters.put(""method"", METHOD_PLACES_FOR_CONTACTS); parameters.put(""place_type"", intPlaceTypeToString(placeType)); if (placeId != null) { parameters.put(""place_id"", placeId); } if (woeId != null) { parameters.put(""woe_id"", woeId); } if (threshold != null) { parameters.put(""threshold"", threshold); } if (contacts != null) { parameters.put(""contacts"", contacts); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element placesElement = response.getPayload(); NodeList placesNodes = placesElement.getElementsByTagName(""place""); placesList.setPage(""1""); placesList.setPages(""1""); placesList.setPerPage("""" + placesNodes.getLength()); placesList.setTotal("""" + placesNodes.getLength()); for (int i = 0; i < placesNodes.getLength(); i++) { Element placeElement = (Element) placesNodes.item(i); placesList.add(parsePlace(placeElement)); } return placesList; } public PlacesList<Place> placesForTags(int placeTypeId, String woeId, String placeId, String threshold, String[] tags, String tagMode, String machineTags,
            String machineTagMode, Date minUploadDate, Date maxUploadDate, Date minTakenDate, Date maxTakenDate) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PlacesList<Place> placesList = new PlacesList<Place>(); parameters.put(""method"", METHOD_PLACES_FOR_TAGS); parameters.put(""place_type_id"", Integer.toString(placeTypeId)); if (woeId != null) { parameters.put(""woe_id"", woeId); } if (placeId != null) { parameters.put(""place_id"", placeId); } if (threshold != null) { parameters.put(""threshold"", threshold); } if (tags != null) { parameters.put(""tags"", StringUtilities.join(tags, "","")); } if (tagMode != null) { parameters.put(""tag_mode"", tagMode); } if (machineTags != null) { parameters.put(""machine_tags"", machineTags); } if (machineTagMode != null) { parameters.put(""machine_tag_mode"", machineTagMode); } if (minUploadDate != null) { parameters.put(""min_upload_date"", Long.toString(minUploadDate.getTime() / 1000L)); } if (maxUploadDate != null) { parameters.put(""max_upload_date"", Long.toString(maxUploadDate.getTime() / 1000L)); } if (minTakenDate != null) { parameters.put(""min_taken_date"", ((DateFormat) SearchParameters.MYSQL_DATE_FORMATS.get()).format(minTakenDate)); } if (maxTakenDate != null) { parameters.put(""max_taken_date"", ((DateFormat) SearchParameters.MYSQL_DATE_FORMATS.get()).format(maxTakenDate)); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element placesElement = response.getPayload(); NodeList placesNodes = placesElement.getElementsByTagName(""place""); placesList.setPage(""1""); placesList.setPages(""1""); placesList.setPerPage("""" + placesNodes.getLength()); placesList.setTotal("""" + placesNodes.getLength()); for (int i = 0; i < placesNodes.getLength(); i++) { Element placeElement = (Element) placesNodes.item(i); placesList.add(parsePlace(placeElement)); } return placesList; } public PlacesList<Place> placesForUser(int placeType, String woeId, String placeId, String threshold, Date minUploadDate, Date maxUploadDate,
            Date minTakenDate, Date maxTakenDate) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PlacesList<Place> placesList = new PlacesList<Place>(); parameters.put(""method"", METHOD_PLACES_FOR_USER); parameters.put(""place_type"", intPlaceTypeToString(placeType)); if (placeId != null) { parameters.put(""place_id"", placeId); } if (woeId != null) { parameters.put(""woe_id"", woeId); } if (threshold != null) { parameters.put(""threshold"", threshold); } if (minUploadDate != null) { parameters.put(""min_upload_date"", Long.toString(minUploadDate.getTime() / 1000L)); } if (maxUploadDate != null) { parameters.put(""max_upload_date"", Long.toString(maxUploadDate.getTime() / 1000L)); } if (minTakenDate != null) { parameters.put(""min_taken_date"", ((DateFormat) SearchParameters.MYSQL_DATE_FORMATS.get()).format(minTakenDate)); } if (maxTakenDate != null) { parameters.put(""max_taken_date"", ((DateFormat) SearchParameters.MYSQL_DATE_FORMATS.get()).format(maxTakenDate)); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element placesElement = response.getPayload(); NodeList placesNodes = placesElement.getElementsByTagName(""place""); placesList.setPage(""1""); placesList.setPages(""1""); placesList.setPerPage("""" + placesNodes.getLength()); placesList.setTotal("""" + placesNodes.getLength()); for (int i = 0; i < placesNodes.getLength(); i++) { Element placeElement = (Element) placesNodes.item(i); placesList.add(parsePlace(placeElement)); } return placesList; } @Deprecated
    public Location resolvePlaceId(String placeId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_RESOLVE_PLACE_ID); parameters.put(""place_id"", placeId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element locationElement = response.getPayload(); return parseLocation(locationElement); } @Deprecated
    public Location resolvePlaceURL(String flickrPlacesUrl) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_RESOLVE_PLACE_URL); parameters.put(""url"", flickrPlacesUrl); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element locationElement = response.getPayload(); return parseLocation(locationElement); } public ArrayList<Tag> tagsForPlace(String woeId, String placeId, Date minUploadDate, Date maxUploadDate, Date minTakenDate, Date maxTakenDate)
            throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); ArrayList<Tag> tagsList = new ArrayList<Tag>(); parameters.put(""method"", METHOD_TAGS_FOR_PLACE); if (woeId != null) { parameters.put(""woe_id"", woeId); } if (placeId != null) { parameters.put(""place_id"", placeId); } if (minUploadDate != null) { parameters.put(""min_upload_date"", Long.toString(minUploadDate.getTime() / 1000L)); } if (maxUploadDate != null) { parameters.put(""max_upload_date"", Long.toString(maxUploadDate.getTime() / 1000L)); } if (minTakenDate != null) { parameters.put(""min_taken_date"", ((DateFormat) SearchParameters.MYSQL_DATE_FORMATS.get()).format(minTakenDate)); } if (maxTakenDate != null) { parameters.put(""max_taken_date"", ((DateFormat) SearchParameters.MYSQL_DATE_FORMATS.get()).format(maxTakenDate)); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element tagsElement = response.getPayload(); NodeList tagsNodes = tagsElement.getElementsByTagName(""tag""); for (int i = 0; i < tagsNodes.getLength(); i++) { Element tagElement = (Element) tagsNodes.item(i); Tag tag = new Tag(); tag.setCount(tagElement.getAttribute(""count"")); tag.setValue(XMLUtilities.getValue(tagElement)); tagsList.add(tag); } return tagsList; } private Location parseLocation(Element locationElement) { Location location = new Location(); Element localityElement = (Element) locationElement.getElementsByTagName(""locality"").item(0); Element countyElement = (Element) locationElement.getElementsByTagName(""county"").item(0); Element regionElement = (Element) locationElement.getElementsByTagName(""region"").item(0); Element countryElement = (Element) locationElement.getElementsByTagName(""country"").item(0); location.setPlaceId(locationElement.getAttribute(""place_id"")); location.setPlaceUrl(locationElement.getAttribute(""place_url"")); location.setWoeId(locationElement.getAttribute(""woeid"")); location.setLatitude(locationElement.getAttribute(""latitude"")); location.setLongitude(locationElement.getAttribute(""longitude"")); location.setTimezone(locationElement.getAttribute(""timezone"")); location.setName(locationElement.getAttribute(""name"")); location.setWoeName(locationElement.getAttribute(""woe_name"")); location.setIsHasShapeData(""1"".equals(locationElement.getAttribute(""has_shapedata""))); location.setPlaceType(stringPlaceTypeToInt(locationElement.getAttribute(""place_type""))); location.setLocality(parseLocationPlace(localityElement, Place.TYPE_LOCALITY)); location.setCounty(parseLocationPlace(countyElement, Place.TYPE_COUNTY)); location.setRegion(parseLocationPlace(regionElement, Place.TYPE_REGION)); location.setCountry(parseLocationPlace(countryElement, Place.TYPE_COUNTRY)); return location; } private Place parseLocationPlace(Element element, int type) { Place place = null; if (element != null) { place = new Place(); place.setName(XMLUtilities.getValue(element)); place.setPlaceId(element.getAttribute(""place_id"")); place.setPlaceUrl(element.getAttribute(""place_url"")); place.setWoeId(element.getAttribute(""woeid"")); place.setLatitude(element.getAttribute(""latitude"")); place.setLongitude(element.getAttribute(""longitude"")); place.setPlaceType(type); } return place; } private Place parsePlace(Element placeElement) { Place place = new Place(); place.setPlaceId(placeElement.getAttribute(""place_id"")); place.setPlaceUrl(placeElement.getAttribute(""place_url"")); place.setWoeId(placeElement.getAttribute(""woeid"")); place.setLatitude(placeElement.getAttribute(""latitude"")); place.setLongitude(placeElement.getAttribute(""longitude"")); place.setPhotoCount(placeElement.getAttribute(""photo_count"")); place.setPlaceType(placeElement.getAttribute(""place_type_id"")); place.setName(XMLUtilities.getValue(placeElement)); return place; } private int stringPlaceTypeToInt(String typeString) { int placeType = 0; if (typeString.equals(""locality"")) { placeType = Place.TYPE_LOCALITY; } else if (typeString.equals(""county"")) { placeType = Place.TYPE_COUNTY; } else if (typeString.equals(""region"")) { placeType = Place.TYPE_REGION; } else if (typeString.equals(""country"")) { placeType = Place.TYPE_COUNTRY; } else if (typeString.equals(""continent"")) { placeType = Place.TYPE_CONTINENT; } else if (typeString.equals(""neighbourhood"")) { placeType = Place.TYPE_NEIGHBOURHOOD; } return placeType; } public String intPlaceTypeToString(int placeType) throws FlickrException { String placeTypeStr = """"; if (placeType == Place.TYPE_COUNTRY) { placeTypeStr = ""country""; } else if (placeType == Place.TYPE_REGION) { placeTypeStr = ""region""; } else if (placeType == Place.TYPE_LOCALITY) { placeTypeStr = ""locality""; } else if (placeType == Place.TYPE_CONTINENT) { placeTypeStr = ""continent""; } else if (placeType == Place.TYPE_NEIGHBOURHOOD) { placeTypeStr = ""neighbourhood""; } else { throw new FlickrException(""33"", ""Not a valid place type""); } return placeTypeStr; } } ","package com.flickr4java.flickr.places;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.SearchParameters; import com.flickr4java.flickr.tags.Tag; import com.flickr4java.flickr.util.StringUtilities; import com.flickr4java.flickr.util.XMLUtilities;  import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import java.text.DateFormat; import java.util.ArrayList; import java.util.Date; import java.util.HashMap; import java.util.Map;  /**
 * Lookup Flickr Places.
 * <p>
 *
 * Note: As of May 2021 many of these methods no longer seem to work correctly in the Flickr API.
 * Confirmed via the https://www.flickr.com/services/api/ page.
 * 
 * Announcement on places from yahoo:
 * <p>
 * 
 * <PRE>
 * From: kellan - kellan@yahoo-inc.com
 * Date: Fri, 11 Jan 2008 15:57:59 -0800
 * Subject: [yws-flickr] Flickr and ""Place IDs""
 * 
 * At Flickr we've got a really big database that lists a significant
 * percentage of the places that exist in the world, and a few that don't.
 * When you geotag a photo we try to identify the ""place"" (neighborhood,
 * village, city, county, state, or country) where the photo was taken. And
 * we assign that photo a ""place ID"".
 * 
 * A place ID is a globally unique identifier for a place on Earth.  A city
 * has a place ID, so do counties, states, and countries.  Even some
 * neighborhoods and landmarks have them, though Flickr isn't currently
 * tracking those. And we're starting to expose these place IDs around Flickr.
 * 
 * ### Place IDs and flickr.photos.search()
 * 
 * The Flickr API method flickr.photos.search() now accepts place_id as an
 * argument.  Along with all of the other parameters you can
 * search on you can now scope your search to a given place.   Historically
 * you've been able to pass bounding boxes to the API, but calculating the
 * right bounding box for a city is tricky, and you can get noise and bad
 * results around the edge.  Now you can pass a single non-ambiguous string
 * and get photos geotagged in San Francisco, CA, or Ohio, or Beijing.
 * (kH8dLOubBZRvX_YZ, LtkqzVqbApjAbJxv, and wpK7URqbAJnWB90W respectively)
 * 
 * The documentation has been updated at:
 * http://www.flickr.com/services/api/flickr.photos.search.html
 * 
 * ### Sources of Place IDs
 * 
 * Place IDs are now returned from a number of source:
 * flickr.photos.getInfo will return place IDs for geotagged photos
 * available as a microformat on the appropriate Places page
 * flickr.places.resolvePlaceURL, and flickr.places.resolvePlaceId are
 * available for round tripping Flickr Places URLs.
 * 
 * http://www.flickr.com/services/api/flickr.photos.getInfo.html
 * http://www.flickr.com/services/api/flickr.places.resolvePlaceURL.html
 * http://www.flickr.com/services/api/flickr.places.resolvePlaceId.html
 * 
 * ### More Place IDs
 * 
 * Right now you can also place IDs in the places URL, and pass them to the
 * map like so:
 * 
 * http://flickr.com/places/wpK7URqbAJnWB90W
 * http://flickr.com/map?place_id=kH8dLOubBZRvX_YZ
 * 
 * ### Place IDs elsewhere
 * 
 * The especially eagle-eyed among you might recognize Place IDs.  Upcoming
 * has been quietly using them for months to uniquely identify their metros.
 * 
 * See events from San Francisco at:
 * http://upcoming.yahoo.com/place/kH8dLOubBZRvX_YZ
 * 
 * See photos from San Francisco at: http://flickr.com/places/kH8dLOubBZRvX_YZ
 * 
 * Additionally Yahoo's skunkworks project FireEagle will also support
 * place IDs.
 * 
 * And yes, there is more work to do, but we're exciting about this as a start.
 * 
 * Thanks,
 * -kellan
 * </PRE>
 * 
 * @author mago
 * @version $Id: PlacesInterface.java,v 1.10 2011/07/02 19:47:35 x-mago Exp $
 */ public class PlacesInterface { private static final String METHOD_FIND = ""flickr.places.find"";  private static final String METHOD_FIND_BY_LATLON = ""flickr.places.findByLatLon"";  private static final String METHOD_RESOLVE_PLACE_ID = ""flickr.places.resolvePlaceId"";  private static final String METHOD_RESOLVE_PLACE_URL = ""flickr.places.resolvePlaceURL"";  private static final String METHOD_GET_CHILDREN_WITH_PHOTOS_PUBLIC = ""flickr.places.getChildrenWithPhotosPublic"";  private static final String METHOD_GET_INFO = ""flickr.places.getInfo"";  private static final String METHOD_GET_INFO_BY_URL = ""flickr.places.getInfoByUrl"";  private static final String METHOD_GET_PLACETYPES = ""flickr.places.getPlaceTypes"";  private static final String METHOD_GET_SHAPEHISTORY = ""flickr.places.getShapeHistory"";  private static final String METHOD_GET_TOP_PLACES_LIST = ""flickr.places.getTopPlacesList"";  private static final String METHOD_PLACES_FOR_BOUNDINGBOX = ""flickr.places.placesForBoundingBox"";  private static final String METHOD_PLACES_FOR_CONTACTS = ""flickr.places.placesForContacts"";  private static final String METHOD_PLACES_FOR_TAGS = ""flickr.places.placesForTags"";  private static final String METHOD_PLACES_FOR_USER = ""flickr.places.placesForUser"";  private static final String METHOD_TAGS_FOR_PLACE = ""flickr.places.tagsForPlace"";  private final String apiKey;  private final String sharedSecret;  private final Transport transportAPI;  public PlacesInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; }  /**
     * Return a list of place IDs for a query string.
     * 
     * The flickr.places.find method is not a geocoder. It will round ""up"" to the nearest place type to which place IDs apply. For example, if you pass it a
     * street level address it will return the city that contains the address rather than the street, or building, itself.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param query
     * @return PlacesList
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PlacesList<Place> find(String query) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PlacesList<Place> placesList = new PlacesList<Place>(); parameters.put(""method"", METHOD_FIND);  parameters.put(""query"", query);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element placesElement = response.getPayload(); NodeList placesNodes = placesElement.getElementsByTagName(""place""); placesList.setPage(""1""); placesList.setPages(""1""); placesList.setPerPage("""" + placesNodes.getLength()); placesList.setTotal("""" + placesNodes.getLength()); for (int i = 0; i < placesNodes.getLength(); i++) { Element placeElement = (Element) placesNodes.item(i); placesList.add(parsePlace(placeElement)); } return placesList; }  /**
     * Return a place ID for a latitude, longitude and accuracy triple.
     * <p>
     * 
     * The flickr.places.findByLatLon method is not meant to be a (reverse) geocoder in the traditional sense. It is designed to allow users to find photos for
     * ""places"" and will round up to the nearest place type to which corresponding place IDs apply.
     * <p>
     * 
     * For example, if you pass it a street level coordinate it will return the city that contains the point rather than the street, or building, itself.
     * <p>
     * 
     * It will also truncate latitudes and longitudes to three decimal points.
     * <p>
     * 
     * The gory details :
     * 
     * This is (most of) the same magic that is performed when you geotag one of your photos on the site itself. We know that at the neighbourhood level this
     * can get messy and not always return the correct location.
     * <p>
     * 
     * At the city level things are much better but there may still be some gotchas floating around. Sometimes it's as simple as a bug and other times it is an
     * issue of two competing ideas of where a place ""is"".
     * <p>
     * 
     * This comes with the territory and we are eager to identify and wherever possible fix the problems so when you see something that looks wrong please be
     * gentle :-)
     * <p>
     * 
     * (Reports of incorrect places sent to mailing list will not be ignored but it would be better if you could use the forums for that sort of thing.)
     * <p>
     * 
     * Also, as we do on the site if we can not identify a location for a point as a specific accuracy we pop up the stack and try again. For example, if we
     * can't find a city for a given set of coordinates we try instead to locate the state.
     * <p>
     * 
     * As mentioned above, this method is not designed to serve as a general purpose (reverse) geocoder which is partly reflected by the truncated lat/long
     * coordinates.
     * <p>
     * 
     * If you think that three decimal points are the cause of wonky results locating photos for places, we are happy to investigate but until then it should be
     * All Good (tm).
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param latitude
     *            The latitude whose valid range is -90 to 90. Anything more than 4 decimal places will be truncated.
     * @param longitude
     *            The longitude whose valid range is -180 to 180. Anything more than 4 decimal places will be truncated.
     * @param accuracy
     * @return A PlacesList
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PlacesList<Place> findByLatLon(double latitude, double longitude, int accuracy) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PlacesList<Place> placesList = new PlacesList<Place>(); parameters.put(""method"", METHOD_FIND_BY_LATLON);  parameters.put(""lat"", """" + Double.toString(latitude)); parameters.put(""lon"", """" + Double.toString(longitude)); parameters.put(""accuracy"", """" + Integer.toString(accuracy));  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element placesElement = response.getPayload(); NodeList placesNodes = placesElement.getElementsByTagName(""place""); placesList.setPage(""1""); placesList.setPages(""1""); placesList.setPerPage("""" + placesNodes.getLength()); placesList.setTotal("""" + placesNodes.getLength()); for (int i = 0; i < placesNodes.getLength(); i++) { Element placeElement = (Element) placesNodes.item(i); placesList.add(parsePlace(placeElement)); } return placesList; }  /**
     * <p>
     * Return a list of locations with public photos that are parented by a Where on Earth (WOE) or Places ID.
     * </p>
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param placeId
     *            A Flickr Places ID. Can be null. (While optional, you must pass either a valid Places ID or a WOE ID.)
     * @param woeId
     *            A Where On Earth (WOE) ID. Can be null. (While optional, you must pass either a valid Places ID or a WOE ID.)
     * @return List of Places
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PlacesList<Place> getChildrenWithPhotosPublic(String placeId, String woeId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PlacesList<Place> placesList = new PlacesList<Place>(); parameters.put(""method"", METHOD_GET_CHILDREN_WITH_PHOTOS_PUBLIC);  if (placeId != null) { parameters.put(""place_id"", placeId); } if (woeId != null) { parameters.put(""woe_id"", woeId); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element placesElement = response.getPayload(); NodeList placesNodes = placesElement.getElementsByTagName(""place""); placesList.setPage(""1""); placesList.setPages(""1""); placesList.setPerPage("""" + placesNodes.getLength()); placesList.setTotal("""" + placesNodes.getLength()); for (int i = 0; i < placesNodes.getLength(); i++) { Element placeElement = (Element) placesNodes.item(i); placesList.add(parsePlace(placeElement)); } return placesList; }  /**
     * Get informations about a place.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param placeId
     *            A Flickr Places ID. Optional, can be null. (While optional, you must pass either a valid Places ID or a WOE ID.)
     * @param woeId
     *            A Where On Earth (WOE) ID. Optional, can be null. (While optional, you must pass either a valid Places ID or a WOE ID.)
     * @return A Location
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Location getInfo(String placeId, String woeId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO);  if (placeId != null) { parameters.put(""place_id"", placeId); } if (woeId != null) { parameters.put(""woe_id"", woeId); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element locationElement = response.getPayload(); return parseLocation(locationElement); }  /**
     * Lookup information about a place, by its flickr.com/places URL.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param url
     * @return A Location
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Location getInfoByUrl(String url) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO_BY_URL);  parameters.put(""url"", url);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element locationElement = response.getPayload(); return parseLocation(locationElement); }  /**
     * Fetches a list of available place types for Flickr.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @return A list of placetypes
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public ArrayList<PlaceType> getPlaceTypes() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PLACETYPES);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } ArrayList<PlaceType> placeTypeList = new ArrayList<PlaceType>(); Element placeTypeElement = response.getPayload(); NodeList placeTypeNodes = placeTypeElement.getElementsByTagName(""place_type""); for (int i = 0; i < placeTypeNodes.getLength(); i++) { placeTypeElement = (Element) placeTypeNodes.item(i); PlaceType placeType = new PlaceType(); placeType.setPlaceTypeId(placeTypeElement.getAttribute(""id"")); placeType.setPlaceTypeName(XMLUtilities.getValue(placeTypeElement)); placeTypeList.add(placeType); } return placeTypeList; }  /**
     * Return an historical list of all the shape data generated for a Places or Where on Earth (WOE) ID.
     * <p>
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * <p>
     * Not working. As it was not possible to find any results. Not even the ones, that have been described in the announcement of this feature.
     * </p>
     * 
     * @param placeId
     *            A Flickr Places ID. Optional, can be null.
     * @param woeId
     *            A Where On Earth (WOE) ID. Optional, can be null.
     * @return A list of shapes
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public ShapeDataList<ShapeData> getShapeHistory(String placeId, String woeId) throws FlickrException { ShapeDataList<ShapeData> shapeList = new ShapeDataList<ShapeData>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_SHAPEHISTORY);  if (placeId != null) { parameters.put(""place_id"", placeId); } if (woeId != null) { parameters.put(""woe_id"", woeId); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element shapeElements = response.getPayload(); shapeList.setTotal(Integer.parseInt(shapeElements.getAttribute(""total""))); shapeList.setWoeId(shapeElements.getAttribute(""woe_id"")); shapeList.setPlaceId(shapeElements.getAttribute(""place_id"")); shapeList.setPlaceType(shapeElements.getAttribute(""place_type"")); shapeList.setPlaceTypeId(Integer.parseInt(shapeElements.getAttribute(""place_type_id""))); NodeList shapeNodes = shapeElements.getElementsByTagName(""shape""); for (int i = 0; i < shapeNodes.getLength(); i++) { Element shapeElement = (Element) shapeNodes.item(i); ShapeData data = new ShapeData(); data.setAlpha(Double.parseDouble(shapeElement.getAttribute(""alpha""))); data.setCountEdges(Integer.parseInt(shapeElement.getAttribute(""count_edges""))); data.setCountPoints(Integer.parseInt(shapeElement.getAttribute(""count_points""))); data.setCreated(shapeElement.getAttribute(""created"")); data.setIsDonutHole(""1"".equals(shapeElement.getAttribute(""is_donuthole""))); data.setHasDonuthole(""1"".equals(shapeElement.getAttribute(""has_donuthole"")));  Element polyElement = XMLUtilities.getChild(shapeElement, ""polylines""); data.setPolyline(XMLUtilities.getChildValue(polyElement, ""polyline"")); Element urlElement = XMLUtilities.getChild(shapeElement, ""urls""); data.setShapefile(XMLUtilities.getChildValue(urlElement, ""shapefile"")); shapeList.add(data); }  return shapeList; }  /**
     * Return the top 100 most geotagged places for a day.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param placeType
     * @param date
     *            Optional, can be null. The default is yesterday.
     * @param placeId
     *            A Flickr Places ID. Optional, can be null.
     * @param woeId
     *            A Where On Earth (WOE) ID. Optional, can be null.
     * @return PlacesList
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PlacesList<Place> getTopPlacesList(int placeType, Date date, String placeId, String woeId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PlacesList<Place> placesList = new PlacesList<Place>(); parameters.put(""method"", METHOD_GET_TOP_PLACES_LIST);  parameters.put(""place_type"", intPlaceTypeToString(placeType)); if (placeId != null) { parameters.put(""place_id"", placeId); } if (woeId != null) { parameters.put(""woe_id"", woeId); } if (date != null) { parameters.put(""date"", ((DateFormat) SearchParameters.DATE_FORMATS.get()).format(date)); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element placesElement = response.getPayload(); NodeList placesNodes = placesElement.getElementsByTagName(""place""); placesList.setPage(""1""); placesList.setPages(""1""); placesList.setPerPage("""" + placesNodes.getLength()); placesList.setTotal("""" + placesNodes.getLength()); for (int i = 0; i < placesNodes.getLength(); i++) { Element placeElement = (Element) placesNodes.item(i); placesList.add(parsePlace(placeElement)); } return placesList; }  /**
     * Return all the locations of a matching place type for a bounding box.
     * <p>
     * 
     * The maximum allowable size of a bounding box (the distance between the SW and NE corners) is governed by the place type you are requesting. Allowable
     * sizes are as follows:
     * <ul>
     * <li>neighbourhood: 3km (1.8mi)</li>
     * <li>locality: 7km (4.3mi)</li>
     * <li>county: 50km (31mi)</li>
     * <li>region: 200km (124mi)</li>
     * <li>country: 500km (310mi)</li>
     * <li>continent: 1500km (932mi)</li>
     * </ul>
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param bbox
     * @param placeType
     * @return A PlacesList
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PlacesList<Place> placesForBoundingBox(int placeType, String bbox) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PlacesList<Place> placesList = new PlacesList<Place>(); parameters.put(""method"", METHOD_PLACES_FOR_BOUNDINGBOX);  parameters.put(""place_type"", intPlaceTypeToString(placeType)); parameters.put(""bbox"", bbox);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element placesElement = response.getPayload(); NodeList placesNodes = placesElement.getElementsByTagName(""place""); placesList.setPage(""1""); placesList.setPages(""1""); placesList.setPerPage("""" + placesNodes.getLength()); placesList.setTotal("""" + placesNodes.getLength()); placesList.setBBox(placesElement.getAttribute(""bbox"")); placesList.setPlaceType(placesElement.getAttribute(""place_type"")); for (int i = 0; i < placesNodes.getLength(); i++) { Element placeElement = (Element) placesNodes.item(i); placesList.add(parsePlace(placeElement)); } return placesList; }  /**
     * Return a list of the top 100 unique places clustered by a given placetype for a user's contacts.
     * 
     * @param placeType
     *            Use Type-constants at {@link Place}
     * @param placeId
     *            A Flickr Places ID. Optional, can be null.
     * @param woeId
     *            A Where On Earth (WOE) ID. Optional, can be null.
     * @param threshold
     *            The minimum number of photos that a place type must have to be included. If the number of photos is lowered then the parent place type for
     *            that place will be used. Optional, can be null.
     * @param contacts
     *            Search your contacts. Either 'all' or 'ff' for just friends and family. (Optional, default is all)
     * @return A PlacesList
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PlacesList<Place> placesForContacts(int placeType, String placeId, String woeId, String threshold, String contacts) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PlacesList<Place> placesList = new PlacesList<Place>(); parameters.put(""method"", METHOD_PLACES_FOR_CONTACTS);  parameters.put(""place_type"", intPlaceTypeToString(placeType)); if (placeId != null) { parameters.put(""place_id"", placeId); } if (woeId != null) { parameters.put(""woe_id"", woeId); } if (threshold != null) { parameters.put(""threshold"", threshold); } if (contacts != null) { parameters.put(""contacts"", contacts); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element placesElement = response.getPayload(); NodeList placesNodes = placesElement.getElementsByTagName(""place""); placesList.setPage(""1""); placesList.setPages(""1""); placesList.setPerPage("""" + placesNodes.getLength()); placesList.setTotal("""" + placesNodes.getLength()); for (int i = 0; i < placesNodes.getLength(); i++) { Element placeElement = (Element) placesNodes.item(i); placesList.add(parsePlace(placeElement)); } return placesList; }  /**
     * Return a list of the top 100 unique places clustered by a given placetype for set of tags or machine tags.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param placeTypeId
     * @param woeId
     *            A Where On Earth (WOE) ID. Optional, can be null. (While optional, you must pass either a valid Places ID or a WOE ID.)
     * @param placeId
     *            A Flickr Places ID. Optional, can be null. (While optional, you must pass either a valid Places ID or a WOE ID.)
     * @param threshold
     *            The minimum number of photos that a place type must have to be included. If the number of photos is lowered then the parent place type for
     *            that place will be used. Optional, can be null.
     * @param tags
     *            A String-array of Tags. Photos with one or more of the tags listed will be returned. Optional, can be null.
     * @param tagMode
     *            Either 'any' for an OR combination of tags, or 'all' for an AND combination. Defaults to 'any' if not specified. Optional, can be null.
     * @param machineTags
     * @param machineTagMode
     *            Either 'any' for an OR combination of tags, or 'all' for an AND combination. Defaults to 'any' if not specified. Optional, can be null.
     * @param minUploadDate
     *            Optional, can be null.
     * @param maxUploadDate
     *            Optional, can be null.
     * @param minTakenDate
     *            Optional, can be null.
     * @param maxTakenDate
     *            Optional, can be null.
     * @return A PlacesList
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PlacesList<Place> placesForTags(int placeTypeId, String woeId, String placeId, String threshold, String[] tags, String tagMode, String machineTags,
            String machineTagMode, Date minUploadDate, Date maxUploadDate, Date minTakenDate, Date maxTakenDate) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PlacesList<Place> placesList = new PlacesList<Place>(); parameters.put(""method"", METHOD_PLACES_FOR_TAGS);  parameters.put(""place_type_id"", Integer.toString(placeTypeId)); if (woeId != null) { parameters.put(""woe_id"", woeId); } if (placeId != null) { parameters.put(""place_id"", placeId); } if (threshold != null) { parameters.put(""threshold"", threshold); } if (tags != null) { parameters.put(""tags"", StringUtilities.join(tags, "","")); } if (tagMode != null) { parameters.put(""tag_mode"", tagMode); } if (machineTags != null) { parameters.put(""machine_tags"", machineTags); } if (machineTagMode != null) { parameters.put(""machine_tag_mode"", machineTagMode); } if (minUploadDate != null) { parameters.put(""min_upload_date"", Long.toString(minUploadDate.getTime() / 1000L)); } if (maxUploadDate != null) { parameters.put(""max_upload_date"", Long.toString(maxUploadDate.getTime() / 1000L)); } if (minTakenDate != null) { parameters.put(""min_taken_date"", ((DateFormat) SearchParameters.MYSQL_DATE_FORMATS.get()).format(minTakenDate)); } if (maxTakenDate != null) { parameters.put(""max_taken_date"", ((DateFormat) SearchParameters.MYSQL_DATE_FORMATS.get()).format(maxTakenDate)); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element placesElement = response.getPayload(); NodeList placesNodes = placesElement.getElementsByTagName(""place""); placesList.setPage(""1""); placesList.setPages(""1""); placesList.setPerPage("""" + placesNodes.getLength()); placesList.setTotal("""" + placesNodes.getLength()); for (int i = 0; i < placesNodes.getLength(); i++) { Element placeElement = (Element) placesNodes.item(i); placesList.add(parsePlace(placeElement)); } return placesList; }  /**
     * Return a list of the top 100 unique places clustered by a given placetype for a user.
     * 
     * @param placeType
     *            Use Type-constants at {@link Place}
     * @param woeId
     *            A Where On Earth (WOE) ID. Optional, can be null.
     * @param placeId
     *            A Flickr Places ID. Optional, can be null.
     * @param threshold
     *            The minimum number of photos that a place type must have to be included. If the number of photos is lowered then the parent place type for
     *            that place will be used. Optional, can be null.
     * @param minUploadDate
     *            Optional, can be null.
     * @param maxUploadDate
     *            Optional, can be null.
     * @param minTakenDate
     *            Optional, can be null.
     * @param maxTakenDate
     *            Optional, can be null.
     * @return A PlacesList
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PlacesList<Place> placesForUser(int placeType, String woeId, String placeId, String threshold, Date minUploadDate, Date maxUploadDate,
            Date minTakenDate, Date maxTakenDate) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PlacesList<Place> placesList = new PlacesList<Place>(); parameters.put(""method"", METHOD_PLACES_FOR_USER);  parameters.put(""place_type"", intPlaceTypeToString(placeType)); if (placeId != null) { parameters.put(""place_id"", placeId); } if (woeId != null) { parameters.put(""woe_id"", woeId); } if (threshold != null) { parameters.put(""threshold"", threshold); } if (minUploadDate != null) { parameters.put(""min_upload_date"", Long.toString(minUploadDate.getTime() / 1000L)); } if (maxUploadDate != null) { parameters.put(""max_upload_date"", Long.toString(maxUploadDate.getTime() / 1000L)); } if (minTakenDate != null) { parameters.put(""min_taken_date"", ((DateFormat) SearchParameters.MYSQL_DATE_FORMATS.get()).format(minTakenDate)); } if (maxTakenDate != null) { parameters.put(""max_taken_date"", ((DateFormat) SearchParameters.MYSQL_DATE_FORMATS.get()).format(maxTakenDate)); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element placesElement = response.getPayload(); NodeList placesNodes = placesElement.getElementsByTagName(""place""); placesList.setPage(""1""); placesList.setPages(""1""); placesList.setPerPage("""" + placesNodes.getLength()); placesList.setTotal("""" + placesNodes.getLength()); for (int i = 0; i < placesNodes.getLength(); i++) { Element placeElement = (Element) placesNodes.item(i); placesList.add(parsePlace(placeElement)); } return placesList; }  /**
     * Find Flickr Places information by Place ID.
     * 
     * @deprecated This method has been deprecated. It won't be removed but you should use {@link #getInfo(String, String)} instead.
     * @param placeId
     * @return A Location
     * @throws FlickrException if there was a problem connecting to Flickr
     */ @Deprecated
    public Location resolvePlaceId(String placeId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_RESOLVE_PLACE_ID);  parameters.put(""place_id"", placeId);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element locationElement = response.getPayload(); return parseLocation(locationElement); }  /**
     * Find Flickr Places information by Place URL.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @deprecated This method has been deprecated. It won't be removed but you should use {@link PlacesInterface#getInfoByUrl(String)} instead.
     * @param flickrPlacesUrl
     * @return A Location
     * @throws FlickrException if there was a problem connecting to Flickr
     */ @Deprecated
    public Location resolvePlaceURL(String flickrPlacesUrl) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_RESOLVE_PLACE_URL);  parameters.put(""url"", flickrPlacesUrl);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element locationElement = response.getPayload(); return parseLocation(locationElement); }  /**
     * Return a list of the top 100 unique tags for a Flickr Places or Where on Earth (WOE) ID.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param woeId
     *            A Where On Earth (WOE) ID. Optional, can be null.
     * @param placeId
     *            A Flickr Places ID. Optional, can be null.
     * @param minUploadDate
     *            Optional, can be null.
     * @param maxUploadDate
     *            Optional, can be null.
     * @param minTakenDate
     *            Optional, can be null.
     * @param maxTakenDate
     *            Optional, can be null.
     * @return A list of Tags
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public ArrayList<Tag> tagsForPlace(String woeId, String placeId, Date minUploadDate, Date maxUploadDate, Date minTakenDate, Date maxTakenDate)
            throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); ArrayList<Tag> tagsList = new ArrayList<Tag>(); parameters.put(""method"", METHOD_TAGS_FOR_PLACE);  if (woeId != null) { parameters.put(""woe_id"", woeId); } if (placeId != null) { parameters.put(""place_id"", placeId); } if (minUploadDate != null) { parameters.put(""min_upload_date"", Long.toString(minUploadDate.getTime() / 1000L)); } if (maxUploadDate != null) { parameters.put(""max_upload_date"", Long.toString(maxUploadDate.getTime() / 1000L)); } if (minTakenDate != null) { parameters.put(""min_taken_date"", ((DateFormat) SearchParameters.MYSQL_DATE_FORMATS.get()).format(minTakenDate)); } if (maxTakenDate != null) { parameters.put(""max_taken_date"", ((DateFormat) SearchParameters.MYSQL_DATE_FORMATS.get()).format(maxTakenDate)); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element tagsElement = response.getPayload(); NodeList tagsNodes = tagsElement.getElementsByTagName(""tag""); for (int i = 0; i < tagsNodes.getLength(); i++) { Element tagElement = (Element) tagsNodes.item(i); Tag tag = new Tag(); tag.setCount(tagElement.getAttribute(""count"")); tag.setValue(XMLUtilities.getValue(tagElement)); tagsList.add(tag); } return tagsList; }  private Location parseLocation(Element locationElement) { Location location = new Location(); Element localityElement = (Element) locationElement.getElementsByTagName(""locality"").item(0); Element countyElement = (Element) locationElement.getElementsByTagName(""county"").item(0); Element regionElement = (Element) locationElement.getElementsByTagName(""region"").item(0); Element countryElement = (Element) locationElement.getElementsByTagName(""country"").item(0);  location.setPlaceId(locationElement.getAttribute(""place_id"")); // location.setName(locationElement.getAttribute(""name"")); location.setPlaceUrl(locationElement.getAttribute(""place_url"")); location.setWoeId(locationElement.getAttribute(""woeid"")); location.setLatitude(locationElement.getAttribute(""latitude"")); location.setLongitude(locationElement.getAttribute(""longitude"")); location.setTimezone(locationElement.getAttribute(""timezone"")); location.setName(locationElement.getAttribute(""name"")); location.setWoeName(locationElement.getAttribute(""woe_name"")); location.setIsHasShapeData(""1"".equals(locationElement.getAttribute(""has_shapedata""))); location.setPlaceType(stringPlaceTypeToInt(locationElement.getAttribute(""place_type""))); location.setLocality(parseLocationPlace(localityElement, Place.TYPE_LOCALITY)); location.setCounty(parseLocationPlace(countyElement, Place.TYPE_COUNTY)); location.setRegion(parseLocationPlace(regionElement, Place.TYPE_REGION)); location.setCountry(parseLocationPlace(countryElement, Place.TYPE_COUNTRY));  return location; }  private Place parseLocationPlace(Element element, int type) { Place place = null; if (element != null) { place = new Place(); place.setName(XMLUtilities.getValue(element)); place.setPlaceId(element.getAttribute(""place_id"")); place.setPlaceUrl(element.getAttribute(""place_url"")); place.setWoeId(element.getAttribute(""woeid"")); place.setLatitude(element.getAttribute(""latitude"")); place.setLongitude(element.getAttribute(""longitude"")); place.setPlaceType(type); }  return place; }  private Place parsePlace(Element placeElement) { Place place = new Place(); place.setPlaceId(placeElement.getAttribute(""place_id"")); place.setPlaceUrl(placeElement.getAttribute(""place_url"")); place.setWoeId(placeElement.getAttribute(""woeid"")); place.setLatitude(placeElement.getAttribute(""latitude"")); place.setLongitude(placeElement.getAttribute(""longitude"")); place.setPhotoCount(placeElement.getAttribute(""photo_count"")); // String typeString = placeElement.getAttribute(""place_type""); // Now the place-Id is directly available place.setPlaceType(placeElement.getAttribute(""place_type_id"")); // place.setPlaceType(stringPlaceTypeToInt(typeString)); place.setName(XMLUtilities.getValue(placeElement)); return place; }  private int stringPlaceTypeToInt(String typeString) { int placeType = 0; if (typeString.equals(""locality"")) { placeType = Place.TYPE_LOCALITY; } else if (typeString.equals(""county"")) { placeType = Place.TYPE_COUNTY; } else if (typeString.equals(""region"")) { placeType = Place.TYPE_REGION; } else if (typeString.equals(""country"")) { placeType = Place.TYPE_COUNTRY; } else if (typeString.equals(""continent"")) { placeType = Place.TYPE_CONTINENT; } else if (typeString.equals(""neighbourhood"")) { placeType = Place.TYPE_NEIGHBOURHOOD; } return placeType; }  public String intPlaceTypeToString(int placeType) throws FlickrException { String placeTypeStr = """"; if (placeType == Place.TYPE_COUNTRY) { placeTypeStr = ""country""; } else if (placeType == Place.TYPE_REGION) { placeTypeStr = ""region""; } else if (placeType == Place.TYPE_LOCALITY) { placeTypeStr = ""locality""; } else if (placeType == Place.TYPE_CONTINENT) { placeTypeStr = ""continent""; } else if (placeType == Place.TYPE_NEIGHBOURHOOD) { placeTypeStr = ""neighbourhood""; } else { throw new FlickrException(""33"", ""Not a valid place type""); } return placeTypeStr; } }  "
src/main/java/com/flickr4java/flickr/places/PlacesList.java,"package com.flickr4java.flickr.places;

import com.flickr4java.flickr.SearchResultList;

/**
 * Simple Extension of SearchResultList.
 * 
 * @author mago
 * @version $Id: PlacesList.java,v 1.1 2008/01/19 22:53:56 x-mago Exp $
 */
public class PlacesList<E> extends SearchResultList<Place> {
    private static final long serialVersionUID = -6773614467896936754L;
    private String bBox;
    private String placeType;
    
    public PlacesList() {
    }

	public String getBBox() {
		return bBox;
	}

	public void setBBox(String bBox) {
		this.bBox = bBox;
	}

	public String getPlaceType() {
		return placeType;
	}

	public void setPlaceType(String placeType) {
		this.placeType = placeType;
	}

	
}
",package com.flickr4java.flickr.places; import com.flickr4java.flickr.SearchResultList; public class PlacesList<E> extends SearchResultList<Place> { private static final long serialVersionUID = -6773614467896936754L; private String bBox; private String placeType; public PlacesList() { } public String getBBox() { return bBox; } public void setBBox(String bBox) { this.bBox = bBox; } public String getPlaceType() { return placeType; } public void setPlaceType(String placeType) { this.placeType = placeType; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.places; import com.flickr4java.flickr.SearchResultList; public class PlacesList<E> extends SearchResultList<Place> { private static final long serialVersionUID = -6773614467896936754L; private String bBox; private String placeType; public PlacesList() { } public String getBBox() { return bBox; } public void setBBox(String bBox) { this.bBox = bBox; } public String getPlaceType() { return placeType; } public void setPlaceType(String placeType) { this.placeType = placeType; } } ,"package com.flickr4java.flickr.places;  import com.flickr4java.flickr.SearchResultList;  /**
 * Simple Extension of SearchResultList.
 * 
 * @author mago
 * @version $Id: PlacesList.java,v 1.1 2008/01/19 22:53:56 x-mago Exp $
 */ public class PlacesList<E> extends SearchResultList<Place> { private static final long serialVersionUID = -6773614467896936754L; private String bBox; private String placeType;      public PlacesList() { }  public String getBBox() { return bBox; }  public void setBBox(String bBox) { this.bBox = bBox; }  public String getPlaceType() { return placeType; }  public void setPlaceType(String placeType) { this.placeType = placeType; } 
	 }  "
src/main/java/com/flickr4java/flickr/places/ShapeData.java,"package com.flickr4java.flickr.places;

public class ShapeData {

	private String created;
	
	private double alpha;
	
	private int countPoints;
	
	private int countEdges;
	
	private boolean hasDonuthole;
	
	private boolean isDonutHole;
	
	private String polyline;
	
	private String shapefile;

	public String getCreated() {
		return created;
	}

	public void setCreated(String created) {
		this.created = created;
	}

	public double getAlpha() {
		return alpha;
	}

	public void setAlpha(double alpha) {
		this.alpha = alpha;
	}

	public int getCountPoints() {
		return countPoints;
	}

	public void setCountPoints(int countPoints) {
		this.countPoints = countPoints;
	}

	public int getCountEdges() {
		return countEdges;
	}

	public void setCountEdges(int countEdges) {
		this.countEdges = countEdges;
	}

	public boolean isHasDonuthole() {
		return hasDonuthole;
	}

	public void setHasDonuthole(boolean hasDonuthole) {
		this.hasDonuthole = hasDonuthole;
	}

	public boolean isDonutHole() {
		return isDonutHole;
	}

	public void setIsDonutHole(boolean isDonutHole) {
		this.isDonutHole = isDonutHole;
	}

	public String getPolyline() {
		return polyline;
	}

	public void setPolyline(String polyline) {
		this.polyline = polyline;
	}

	public String getShapefile() {
		return shapefile;
	}

	public void setShapefile(String shapefile) {
		this.shapefile = shapefile;
	}
	
}
",package com.flickr4java.flickr.places; public class ShapeData { private String created; private double alpha; private int countPoints; private int countEdges; private boolean hasDonuthole; private boolean isDonutHole; private String polyline; private String shapefile; public String getCreated() { return created; } public void setCreated(String created) { this.created = created; } public double getAlpha() { return alpha; } public void setAlpha(double alpha) { this.alpha = alpha; } public int getCountPoints() { return countPoints; } public void setCountPoints(int countPoints) { this.countPoints = countPoints; } public int getCountEdges() { return countEdges; } public void setCountEdges(int countEdges) { this.countEdges = countEdges; } public boolean isHasDonuthole() { return hasDonuthole; } public void setHasDonuthole(boolean hasDonuthole) { this.hasDonuthole = hasDonuthole; } public boolean isDonutHole() { return isDonutHole; } public void setIsDonutHole(boolean isDonutHole) { this.isDonutHole = isDonutHole; } public String getPolyline() { return polyline; } public void setPolyline(String polyline) { this.polyline = polyline; } public String getShapefile() { return shapefile; } public void setShapefile(String shapefile) { this.shapefile = shapefile; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.places; public class ShapeData { private String created; private double alpha; private int countPoints; private int countEdges; private boolean hasDonuthole; private boolean isDonutHole; private String polyline; private String shapefile; public String getCreated() { return created; } public void setCreated(String created) { this.created = created; } public double getAlpha() { return alpha; } public void setAlpha(double alpha) { this.alpha = alpha; } public int getCountPoints() { return countPoints; } public void setCountPoints(int countPoints) { this.countPoints = countPoints; } public int getCountEdges() { return countEdges; } public void setCountEdges(int countEdges) { this.countEdges = countEdges; } public boolean isHasDonuthole() { return hasDonuthole; } public void setHasDonuthole(boolean hasDonuthole) { this.hasDonuthole = hasDonuthole; } public boolean isDonutHole() { return isDonutHole; } public void setIsDonutHole(boolean isDonutHole) { this.isDonutHole = isDonutHole; } public String getPolyline() { return polyline; } public void setPolyline(String polyline) { this.polyline = polyline; } public String getShapefile() { return shapefile; } public void setShapefile(String shapefile) { this.shapefile = shapefile; } } ,package com.flickr4java.flickr.places;  public class ShapeData {  private String created; 	 private double alpha; 	 private int countPoints; 	 private int countEdges; 	 private boolean hasDonuthole; 	 private boolean isDonutHole; 	 private String polyline; 	 private String shapefile;  public String getCreated() { return created; }  public void setCreated(String created) { this.created = created; }  public double getAlpha() { return alpha; }  public void setAlpha(double alpha) { this.alpha = alpha; }  public int getCountPoints() { return countPoints; }  public void setCountPoints(int countPoints) { this.countPoints = countPoints; }  public int getCountEdges() { return countEdges; }  public void setCountEdges(int countEdges) { this.countEdges = countEdges; }  public boolean isHasDonuthole() { return hasDonuthole; }  public void setHasDonuthole(boolean hasDonuthole) { this.hasDonuthole = hasDonuthole; }  public boolean isDonutHole() { return isDonutHole; }  public void setIsDonutHole(boolean isDonutHole) { this.isDonutHole = isDonutHole; }  public String getPolyline() { return polyline; }  public void setPolyline(String polyline) { this.polyline = polyline; }  public String getShapefile() { return shapefile; }  public void setShapefile(String shapefile) { this.shapefile = shapefile; } 	 }  
src/main/java/com/flickr4java/flickr/places/ShapeDataList.java,"package com.flickr4java.flickr.places;

import java.util.ArrayList;

public class ShapeDataList<E> extends ArrayList<ShapeData>{

	/**
	 * 
	 */
	private static final long serialVersionUID = 3405746186476466870L;
	
	private int total;
	private String woeId;
	private String placeId;
	private String placeType;
	private int placeTypeId;
	
	
	public int getPlaceTypeId() {
		return placeTypeId;
	}
	
	public void setPlaceTypeId(int placeTypeId) {
		this.placeTypeId = placeTypeId;
	}
	public int getTotal() {
		return total;
	}
	public void setTotal(int total) {
		this.total = total;
	}
	public String getWoeId() {
		return woeId;
	}
	public void setWoeId(String woeId) {
		this.woeId = woeId;
	}
	public String getPlaceId() {
		return placeId;
	}
	public void setPlaceId(String placeId) {
		this.placeId = placeId;
	}

	public String getPlaceType() {
		return placeType;
	}

	public void setPlaceType(String placeType) {
		this.placeType = placeType;
	}

}
",package com.flickr4java.flickr.places; import java.util.ArrayList; public class ShapeDataList<E> extends ArrayList<ShapeData>{ private static final long serialVersionUID = 3405746186476466870L; private int total; private String woeId; private String placeId; private String placeType; private int placeTypeId; public int getPlaceTypeId() { return placeTypeId; } public void setPlaceTypeId(int placeTypeId) { this.placeTypeId = placeTypeId; } public int getTotal() { return total; } public void setTotal(int total) { this.total = total; } public String getWoeId() { return woeId; } public void setWoeId(String woeId) { this.woeId = woeId; } public String getPlaceId() { return placeId; } public void setPlaceId(String placeId) { this.placeId = placeId; } public String getPlaceType() { return placeType; } public void setPlaceType(String placeType) { this.placeType = placeType; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.places; import java.util.ArrayList; public class ShapeDataList<E> extends ArrayList<ShapeData>{ private static final long serialVersionUID = 3405746186476466870L; private int total; private String woeId; private String placeId; private String placeType; private int placeTypeId; public int getPlaceTypeId() { return placeTypeId; } public void setPlaceTypeId(int placeTypeId) { this.placeTypeId = placeTypeId; } public int getTotal() { return total; } public void setTotal(int total) { this.total = total; } public String getWoeId() { return woeId; } public void setWoeId(String woeId) { this.woeId = woeId; } public String getPlaceId() { return placeId; } public void setPlaceId(String placeId) { this.placeId = placeId; } public String getPlaceType() { return placeType; } public void setPlaceType(String placeType) { this.placeType = placeType; } } ,"package com.flickr4java.flickr.places;  import java.util.ArrayList;  public class ShapeDataList<E> extends ArrayList<ShapeData>{  /**
	 * 
	 */ private static final long serialVersionUID = 3405746186476466870L; 	 private int total; private String woeId; private String placeId; private String placeType; private int placeTypeId; 	
	 public int getPlaceTypeId() { return placeTypeId; } 	 public void setPlaceTypeId(int placeTypeId) { this.placeTypeId = placeTypeId; } public int getTotal() { return total; } public void setTotal(int total) { this.total = total; } public String getWoeId() { return woeId; } public void setWoeId(String woeId) { this.woeId = woeId; } public String getPlaceId() { return placeId; } public void setPlaceId(String placeId) { this.placeId = placeId; }  public String getPlaceType() { return placeType; }  public void setPlaceType(String placeType) { this.placeType = placeType; }  }  "
src/main/java/com/flickr4java/flickr/prefs/PrefsInterface.java,"/*
 * Copyright (c) 2007 Martin Goebel
 */
package com.flickr4java.flickr.prefs;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;

import org.w3c.dom.Element;

import java.util.HashMap;
import java.util.Map;

/**
 * Requesting preferences for the current authenticated user.
 * 
 * @author Martin Goebel
 * @version $Id: PrefsInterface.java,v 1.6 2008/06/28 22:30:04 x-mago Exp $
 */
public class PrefsInterface {
    public static final String METHOD_GET_CONTENT_TYPE = ""flickr.prefs.getContentType"";

    public static final String METHOD_GET_HIDDEN = ""flickr.prefs.getHidden"";

    public static final String METHOD_GET_SAFETY_LEVEL = ""flickr.prefs.getSafetyLevel"";

    public static final String METHOD_GET_PRIVACY = ""flickr.prefs.getPrivacy"";

    public static final String METHOD_GET_GEO_PERMS = ""flickr.prefs.getGeoPerms"";

    private String apiKey;

    private String sharedSecret;

    private Transport transportAPI;

    /**
     * Construct a PrefsInterface.
     * 
     * @param apiKey
     *            The API key
     * @param transportAPI
     *            The Transport interface
     */
    public PrefsInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transportAPI;
    }

    /**
     * Returns the default content type preference for the user.
     * 
     * @see com.flickr4java.flickr.Flickr#CONTENTTYPE_OTHER
     * @see com.flickr4java.flickr.Flickr#CONTENTTYPE_PHOTO
     * @see com.flickr4java.flickr.Flickr#CONTENTTYPE_SCREENSHOT
     * @return The content-type
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public String getContentType() throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_CONTENT_TYPE);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element personElement = response.getPayload();
        return personElement.getAttribute(""content_type"");
    }

    /**
     * Returns the default privacy level for geographic information attached to the user's photos.
     * 
     * @return privacy-level
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_NO_FILTER
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_PUBLIC
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FRIENDS
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FAMILY
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FRIENDS_FAMILY
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_PRIVATE
     */
    public int getGeoPerms() throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_GEO_PERMS);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        int perm = -1;
        Element personElement = response.getPayload();
        String geoPerms = personElement.getAttribute(""geoperms"");
        try {
            perm = Integer.parseInt(geoPerms);
        } catch (NumberFormatException e) {
            throw new FlickrException(""0"", ""Unable to parse geoPermission"");
        }
        return perm;
    }

    /**
     * Returns the default hidden preference for the user.
     * 
     * @return boolean hidden or not
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public boolean getHidden() throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_HIDDEN);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element personElement = response.getPayload();
        return personElement.getAttribute(""hidden"").equals(""1"") ? true : false;
    }

    /**
     * Returns the default safety level preference for the user.
     * 
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_MODERATE
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_RESTRICTED
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_SAFE
     * @return The current users safety-level
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public String getSafetyLevel() throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_SAFETY_LEVEL);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element personElement = response.getPayload();
        return personElement.getAttribute(""safety_level"");
    }

    /**
     * Returns the default privacy level preference for the user.
     * 
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_NO_FILTER
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_PUBLIC
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FRIENDS
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FRIENDS_FAMILY
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FAMILY
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FRIENDS
     * @throws FlickrException if there was a problem connecting to Flickr
     * @return privacyLevel
     */
    public int getPrivacy() throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_PRIVACY);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element personElement = response.getPayload();
        return Integer.parseInt(personElement.getAttribute(""privacy""));
    }
}
","package com.flickr4java.flickr.prefs; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import org.w3c.dom.Element; import java.util.HashMap; import java.util.Map; public class PrefsInterface { public static final String METHOD_GET_CONTENT_TYPE = ""flickr.prefs.getContentType""; public static final String METHOD_GET_HIDDEN = ""flickr.prefs.getHidden""; public static final String METHOD_GET_SAFETY_LEVEL = ""flickr.prefs.getSafetyLevel""; public static final String METHOD_GET_PRIVACY = ""flickr.prefs.getPrivacy""; public static final String METHOD_GET_GEO_PERMS = ""flickr.prefs.getGeoPerms""; private String apiKey; private String sharedSecret; private Transport transportAPI; public PrefsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public String getContentType() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CONTENT_TYPE); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element personElement = response.getPayload(); return personElement.getAttribute(""content_type""); } public int getGeoPerms() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_GEO_PERMS); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } int perm = -1; Element personElement = response.getPayload(); String geoPerms = personElement.getAttribute(""geoperms""); try { perm = Integer.parseInt(geoPerms); } catch (NumberFormatException e) { throw new FlickrException(""0"", ""Unable to parse geoPermission""); } return perm; } public boolean getHidden() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_HIDDEN); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element personElement = response.getPayload(); return personElement.getAttribute(""hidden"").equals(""1"") ? true : false; } public String getSafetyLevel() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_SAFETY_LEVEL); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element personElement = response.getPayload(); return personElement.getAttribute(""safety_level""); } public int getPrivacy() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PRIVACY); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element personElement = response.getPayload(); return Integer.parseInt(personElement.getAttribute(""privacy"")); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.prefs; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import org.w3c.dom.Element; import java.util.HashMap; import java.util.Map; public class PrefsInterface { public static final String METHOD_GET_CONTENT_TYPE = ""flickr.prefs.getContentType""; public static final String METHOD_GET_HIDDEN = ""flickr.prefs.getHidden""; public static final String METHOD_GET_SAFETY_LEVEL = ""flickr.prefs.getSafetyLevel""; public static final String METHOD_GET_PRIVACY = ""flickr.prefs.getPrivacy""; public static final String METHOD_GET_GEO_PERMS = ""flickr.prefs.getGeoPerms""; private String apiKey; private String sharedSecret; private Transport transportAPI; public PrefsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public String getContentType() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CONTENT_TYPE); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element personElement = response.getPayload(); return personElement.getAttribute(""content_type""); } public int getGeoPerms() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_GEO_PERMS); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } int perm = -1; Element personElement = response.getPayload(); String geoPerms = personElement.getAttribute(""geoperms""); try { perm = Integer.parseInt(geoPerms); } catch (NumberFormatException e) { throw new FlickrException(""0"", ""Unable to parse geoPermission""); } return perm; } public boolean getHidden() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_HIDDEN); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element personElement = response.getPayload(); return personElement.getAttribute(""hidden"").equals(""1"") ? true : false; } public String getSafetyLevel() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_SAFETY_LEVEL); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element personElement = response.getPayload(); return personElement.getAttribute(""safety_level""); } public int getPrivacy() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PRIVACY); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element personElement = response.getPayload(); return Integer.parseInt(personElement.getAttribute(""privacy"")); } } ","/*
 * Copyright (c) 2007 Martin Goebel
 */ package com.flickr4java.flickr.prefs;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport;  import org.w3c.dom.Element;  import java.util.HashMap; import java.util.Map;  /**
 * Requesting preferences for the current authenticated user.
 * 
 * @author Martin Goebel
 * @version $Id: PrefsInterface.java,v 1.6 2008/06/28 22:30:04 x-mago Exp $
 */ public class PrefsInterface { public static final String METHOD_GET_CONTENT_TYPE = ""flickr.prefs.getContentType"";  public static final String METHOD_GET_HIDDEN = ""flickr.prefs.getHidden"";  public static final String METHOD_GET_SAFETY_LEVEL = ""flickr.prefs.getSafetyLevel"";  public static final String METHOD_GET_PRIVACY = ""flickr.prefs.getPrivacy"";  public static final String METHOD_GET_GEO_PERMS = ""flickr.prefs.getGeoPerms"";  private String apiKey;  private String sharedSecret;  private Transport transportAPI;  /**
     * Construct a PrefsInterface.
     * 
     * @param apiKey
     *            The API key
     * @param transportAPI
     *            The Transport interface
     */ public PrefsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; }  /**
     * Returns the default content type preference for the user.
     * 
     * @see com.flickr4java.flickr.Flickr#CONTENTTYPE_OTHER
     * @see com.flickr4java.flickr.Flickr#CONTENTTYPE_PHOTO
     * @see com.flickr4java.flickr.Flickr#CONTENTTYPE_SCREENSHOT
     * @return The content-type
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public String getContentType() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CONTENT_TYPE);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element personElement = response.getPayload(); return personElement.getAttribute(""content_type""); }  /**
     * Returns the default privacy level for geographic information attached to the user's photos.
     * 
     * @return privacy-level
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_NO_FILTER
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_PUBLIC
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FRIENDS
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FAMILY
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FRIENDS_FAMILY
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_PRIVATE
     */ public int getGeoPerms() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_GEO_PERMS);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  int perm = -1; Element personElement = response.getPayload(); String geoPerms = personElement.getAttribute(""geoperms""); try { perm = Integer.parseInt(geoPerms); } catch (NumberFormatException e) { throw new FlickrException(""0"", ""Unable to parse geoPermission""); } return perm; }  /**
     * Returns the default hidden preference for the user.
     * 
     * @return boolean hidden or not
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public boolean getHidden() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_HIDDEN);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element personElement = response.getPayload(); return personElement.getAttribute(""hidden"").equals(""1"") ? true : false; }  /**
     * Returns the default safety level preference for the user.
     * 
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_MODERATE
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_RESTRICTED
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_SAFE
     * @return The current users safety-level
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public String getSafetyLevel() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_SAFETY_LEVEL);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element personElement = response.getPayload(); return personElement.getAttribute(""safety_level""); }  /**
     * Returns the default privacy level preference for the user.
     * 
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_NO_FILTER
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_PUBLIC
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FRIENDS
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FRIENDS_FAMILY
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FAMILY
     * @see com.flickr4java.flickr.Flickr#PRIVACY_LEVEL_FRIENDS
     * @throws FlickrException if there was a problem connecting to Flickr
     * @return privacyLevel
     */ public int getPrivacy() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PRIVACY);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element personElement = response.getPayload(); return Integer.parseInt(personElement.getAttribute(""privacy"")); } }  "
src/main/java/com/flickr4java/flickr/push/PushInterface.java,"/**
 * @author acaplan
 */
package com.flickr4java.flickr.push;

import com.flickr4java.flickr.Transport;

/**
 * @author acaplan
 * 
 */
public class PushInterface {

    public static final String METHOD_GET_SUBSCRIPTIONS = ""flickr.push.getSubscriptions"";

    public static final String METHOD_GET_TOPICS = ""flickr.push.getTopics"";

    public static final String METHOD_SUBSCRIBE = ""flickr.push.subscribe"";

    public static final String METHOD_UNSUBSCRIBE = ""flickr.push.unsubscribe"";

    private String apiKey;

    private String sharedSecret;

    private Transport transportAPI;

    /**
     * 
     * @param apiKey
     * @param sharedSecret
     * @param transportAPI
     */
    public PushInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transportAPI;
    }

}
","package com.flickr4java.flickr.push; import com.flickr4java.flickr.Transport; public class PushInterface { public static final String METHOD_GET_SUBSCRIPTIONS = ""flickr.push.getSubscriptions""; public static final String METHOD_GET_TOPICS = ""flickr.push.getTopics""; public static final String METHOD_SUBSCRIBE = ""flickr.push.subscribe""; public static final String METHOD_UNSUBSCRIBE = ""flickr.push.unsubscribe""; private String apiKey; private String sharedSecret; private Transport transportAPI; public PushInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.push; import com.flickr4java.flickr.Transport; public class PushInterface { public static final String METHOD_GET_SUBSCRIPTIONS = ""flickr.push.getSubscriptions""; public static final String METHOD_GET_TOPICS = ""flickr.push.getTopics""; public static final String METHOD_SUBSCRIBE = ""flickr.push.subscribe""; public static final String METHOD_UNSUBSCRIBE = ""flickr.push.unsubscribe""; private String apiKey; private String sharedSecret; private Transport transportAPI; public PushInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } } ","/**
 * @author acaplan
 */ package com.flickr4java.flickr.push;  import com.flickr4java.flickr.Transport;  /**
 * @author acaplan
 * 
 */ public class PushInterface {  public static final String METHOD_GET_SUBSCRIPTIONS = ""flickr.push.getSubscriptions"";  public static final String METHOD_GET_TOPICS = ""flickr.push.getTopics"";  public static final String METHOD_SUBSCRIBE = ""flickr.push.subscribe"";  public static final String METHOD_UNSUBSCRIBE = ""flickr.push.unsubscribe"";  private String apiKey;  private String sharedSecret;  private Transport transportAPI;  /**
     * 
     * @param apiKey
     * @param sharedSecret
     * @param transportAPI
     */ public PushInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; }  }  "
src/main/java/com/flickr4java/flickr/reflection/Argument.java,"

package com.flickr4java.flickr.reflection;

/**
 * Describes an argument of a Flickr-method.
 * 
 * @author Anthony Eden
 * @see Method#getArguments()
 * @see Method#setArguments(java.util.Collection)
 * @version $Id: Argument.java,v 1.3 2007/11/18 22:48:09 x-mago Exp $
 */
public class Argument {

    private String name;

    private boolean optional;

    private String description;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public boolean isOptional() {
        return optional;
    }

    public void setOptional(boolean optional) {
        this.optional = optional;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

}
",package com.flickr4java.flickr.reflection; public class Argument { private String name; private boolean optional; private String description; public String getName() { return name; } public void setName(String name) { this.name = name; } public boolean isOptional() { return optional; } public void setOptional(boolean optional) { this.optional = optional; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.reflection; public class Argument { private String name; private boolean optional; private String description; public String getName() { return name; } public void setName(String name) { this.name = name; } public boolean isOptional() { return optional; } public void setOptional(boolean optional) { this.optional = optional; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } } ,"
 package com.flickr4java.flickr.reflection;  /**
 * Describes an argument of a Flickr-method.
 * 
 * @author Anthony Eden
 * @see Method#getArguments()
 * @see Method#setArguments(java.util.Collection)
 * @version $Id: Argument.java,v 1.3 2007/11/18 22:48:09 x-mago Exp $
 */ public class Argument {  private String name;  private boolean optional;  private String description;  public String getName() { return name; }  public void setName(String name) { this.name = name; }  public boolean isOptional() { return optional; }  public void setOptional(boolean optional) { this.optional = optional; }  public String getDescription() { return description; }  public void setDescription(String description) { this.description = description; }  }  "
src/main/java/com/flickr4java/flickr/reflection/Error.java,"

package com.flickr4java.flickr.reflection;

/**
 * Describes one possible error-code of a Flickr-method.
 * 
 * @author Anthony Eden
 * @see Method#getErrors()
 * @see Method#setErrors(java.util.Collection)
 * @version $Id: Error.java,v 1.3 2007/11/18 22:48:09 x-mago Exp $
 */
public class Error {

    private int code;

    private String message;

    private String explaination;

    public int getCode() {
        return code;
    }

    public void setCode(int code) {
        this.code = code;
    }

    public void setCode(String code) {
        setCode(Integer.parseInt(code));
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public String getExplaination() {
        return explaination;
    }

    public void setExplaination(String explaination) {
        this.explaination = explaination;
    }

}
",package com.flickr4java.flickr.reflection; public class Error { private int code; private String message; private String explaination; public int getCode() { return code; } public void setCode(int code) { this.code = code; } public void setCode(String code) { setCode(Integer.parseInt(code)); } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } public String getExplaination() { return explaination; } public void setExplaination(String explaination) { this.explaination = explaination; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.reflection; public class Error { private int code; private String message; private String explaination; public int getCode() { return code; } public void setCode(int code) { this.code = code; } public void setCode(String code) { setCode(Integer.parseInt(code)); } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } public String getExplaination() { return explaination; } public void setExplaination(String explaination) { this.explaination = explaination; } } ,"
 package com.flickr4java.flickr.reflection;  /**
 * Describes one possible error-code of a Flickr-method.
 * 
 * @author Anthony Eden
 * @see Method#getErrors()
 * @see Method#setErrors(java.util.Collection)
 * @version $Id: Error.java,v 1.3 2007/11/18 22:48:09 x-mago Exp $
 */ public class Error {  private int code;  private String message;  private String explaination;  public int getCode() { return code; }  public void setCode(int code) { this.code = code; }  public void setCode(String code) { setCode(Integer.parseInt(code)); }  public String getMessage() { return message; }  public void setMessage(String message) { this.message = message; }  public String getExplaination() { return explaination; }  public void setExplaination(String explaination) { this.explaination = explaination; }  }  "
src/main/java/com/flickr4java/flickr/reflection/Method.java,"

package com.flickr4java.flickr.reflection;

import java.util.ArrayList;
import java.util.Collection;

/**
 * Describes a method requested with {@link ReflectionInterface#getMethodInfo(String)}.
 * 
 * @author Anthony Eden
 * @version $Id: Method.java,v 1.6 2007/11/18 22:48:09 x-mago Exp $
 */
public class Method {

    public static final int READ_PERMISSION = 1;

    public static final int WRITE_PERMISSION = 2;

    private String name;

    private boolean needsLogin;

    private boolean needsSigning;

    private int requiredPerms;

    private String description;

    private String response;

    private String explanation;

    private Collection<Argument> arguments;

    private Collection<Error> errors;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public boolean needsLogin() {
        return needsLogin;
    }

    public void setNeedsLogin(boolean needsLogin) {
        this.needsLogin = needsLogin;
    }

    public boolean needsSigning() {
        return needsSigning;
    }

    public void setNeedsSigning(boolean needsSigning) {
        this.needsSigning = needsSigning;
    }

    public int getRequiredPerms() {
        return requiredPerms;
    }

    public void setRequiredPerms(int reqiredPerms) {
        this.requiredPerms = reqiredPerms;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getResponse() {
        return response;
    }

    public void setResponse(String response) {
        this.response = response;
    }

    public String getExplanation() {
        return explanation;
    }

    public void setExplanation(String explanation) {
        this.explanation = explanation;
    }

    public Collection<Argument> getArguments() {
        if (arguments == null) {
            arguments = new ArrayList<Argument>();
        }
        return arguments;
    }

    public void setArguments(Collection<Argument> arguments) {
        this.arguments = arguments;
    }

    public Collection<Error> getErrors() {
        if (errors == null) {
            errors = new ArrayList<Error>();
        }
        return errors;
    }

    public void setErrors(Collection<Error> errors) {
        this.errors = errors;
    }

}
",package com.flickr4java.flickr.reflection; import java.util.ArrayList; import java.util.Collection; public class Method { public static final int READ_PERMISSION = 1; public static final int WRITE_PERMISSION = 2; private String name; private boolean needsLogin; private boolean needsSigning; private int requiredPerms; private String description; private String response; private String explanation; private Collection<Argument> arguments; private Collection<Error> errors; public String getName() { return name; } public void setName(String name) { this.name = name; } public boolean needsLogin() { return needsLogin; } public void setNeedsLogin(boolean needsLogin) { this.needsLogin = needsLogin; } public boolean needsSigning() { return needsSigning; } public void setNeedsSigning(boolean needsSigning) { this.needsSigning = needsSigning; } public int getRequiredPerms() { return requiredPerms; } public void setRequiredPerms(int reqiredPerms) { this.requiredPerms = reqiredPerms; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public String getResponse() { return response; } public void setResponse(String response) { this.response = response; } public String getExplanation() { return explanation; } public void setExplanation(String explanation) { this.explanation = explanation; } public Collection<Argument> getArguments() { if (arguments == null) { arguments = new ArrayList<Argument>(); } return arguments; } public void setArguments(Collection<Argument> arguments) { this.arguments = arguments; } public Collection<Error> getErrors() { if (errors == null) { errors = new ArrayList<Error>(); } return errors; } public void setErrors(Collection<Error> errors) { this.errors = errors; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.reflection; import java.util.ArrayList; import java.util.Collection; public class Method { public static final int READ_PERMISSION = 1; public static final int WRITE_PERMISSION = 2; private String name; private boolean needsLogin; private boolean needsSigning; private int requiredPerms; private String description; private String response; private String explanation; private Collection<Argument> arguments; private Collection<Error> errors; public String getName() { return name; } public void setName(String name) { this.name = name; } public boolean needsLogin() { return needsLogin; } public void setNeedsLogin(boolean needsLogin) { this.needsLogin = needsLogin; } public boolean needsSigning() { return needsSigning; } public void setNeedsSigning(boolean needsSigning) { this.needsSigning = needsSigning; } public int getRequiredPerms() { return requiredPerms; } public void setRequiredPerms(int reqiredPerms) { this.requiredPerms = reqiredPerms; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public String getResponse() { return response; } public void setResponse(String response) { this.response = response; } public String getExplanation() { return explanation; } public void setExplanation(String explanation) { this.explanation = explanation; } public Collection<Argument> getArguments() { if (arguments == null) { arguments = new ArrayList<Argument>(); } return arguments; } public void setArguments(Collection<Argument> arguments) { this.arguments = arguments; } public Collection<Error> getErrors() { if (errors == null) { errors = new ArrayList<Error>(); } return errors; } public void setErrors(Collection<Error> errors) { this.errors = errors; } } ,"
 package com.flickr4java.flickr.reflection;  import java.util.ArrayList; import java.util.Collection;  /**
 * Describes a method requested with {@link ReflectionInterface#getMethodInfo(String)}.
 * 
 * @author Anthony Eden
 * @version $Id: Method.java,v 1.6 2007/11/18 22:48:09 x-mago Exp $
 */ public class Method {  public static final int READ_PERMISSION = 1;  public static final int WRITE_PERMISSION = 2;  private String name;  private boolean needsLogin;  private boolean needsSigning;  private int requiredPerms;  private String description;  private String response;  private String explanation;  private Collection<Argument> arguments;  private Collection<Error> errors;  public String getName() { return name; }  public void setName(String name) { this.name = name; }  public boolean needsLogin() { return needsLogin; }  public void setNeedsLogin(boolean needsLogin) { this.needsLogin = needsLogin; }  public boolean needsSigning() { return needsSigning; }  public void setNeedsSigning(boolean needsSigning) { this.needsSigning = needsSigning; }  public int getRequiredPerms() { return requiredPerms; }  public void setRequiredPerms(int reqiredPerms) { this.requiredPerms = reqiredPerms; }  public String getDescription() { return description; }  public void setDescription(String description) { this.description = description; }  public String getResponse() { return response; }  public void setResponse(String response) { this.response = response; }  public String getExplanation() { return explanation; }  public void setExplanation(String explanation) { this.explanation = explanation; }  public Collection<Argument> getArguments() { if (arguments == null) { arguments = new ArrayList<Argument>(); } return arguments; }  public void setArguments(Collection<Argument> arguments) { this.arguments = arguments; }  public Collection<Error> getErrors() { if (errors == null) { errors = new ArrayList<Error>(); } return errors; }  public void setErrors(Collection<Error> errors) { this.errors = errors; }  }  "
src/main/java/com/flickr4java/flickr/reflection/ReflectionInterface.java,"
package com.flickr4java.flickr.reflection;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.util.XMLUtilities;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Interface for testing the complete implementation of all Flickr-methods.
 * <p>
 * 
 * @author Anthony Eden
 * @version $Id: ReflectionInterface.java,v 1.10 2008/01/28 23:01:45 x-mago Exp $
 */
public class ReflectionInterface {

    private static Logger _log = LoggerFactory.getLogger(ReflectionInterface.class);

    public static final String METHOD_GET_METHOD_INFO = ""flickr.reflection.getMethodInfo"";

    public static final String METHOD_GET_METHODS = ""flickr.reflection.getMethods"";

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transport;

    /**
     * Construct a ReflectionInterface.
     * 
     * @param apiKey
     *            The API key
     * @param sharedSecret
     *            The Shared Secret
     * @param transport
     *            The Transport interface
     */
    public ReflectionInterface(String apiKey, String sharedSecret, Transport transport) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transport = transport;
    }

    /**
     * Get the info for the specified method.
     * 
     * @param methodName
     *            The method name
     * @return The Method object
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Method getMethodInfo(String methodName) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_METHOD_INFO);

        parameters.put(""method_name"", methodName);

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element methodElement = response.getPayload();
        Method method = new Method();
        method.setName(methodElement.getAttribute(""name""));
        method.setNeedsLogin(""1"".equals(methodElement.getAttribute(""needslogin"")));
        method.setNeedsSigning(""1"".equals(methodElement.getAttribute(""needssigning"")));
        String requiredPermsStr = methodElement.getAttribute(""requiredperms"");
        if (requiredPermsStr != null && requiredPermsStr.length() > 0) {
            try {
                int perms = Integer.parseInt(requiredPermsStr);
                method.setRequiredPerms(perms);
            } catch (NumberFormatException e) {
                // what shall we do?
                e.printStackTrace();
            }
        }
        method.setDescription(XMLUtilities.getChildValue(methodElement, ""description""));
        method.setResponse(XMLUtilities.getChildValue(methodElement, ""response""));
        method.setExplanation(XMLUtilities.getChildValue(methodElement, ""explanation""));

        List<Argument> arguments = new ArrayList<Argument>();
        Element argumentsElement = XMLUtilities.getChild(methodElement, ""arguments"");
        // tolerant fix for incorrect nesting of the <arguments> element
        // as observed in current flickr responses of this method
        //
        // specified as
        // <rsp>
        // <method>
        // <arguments>
        // <errors>
        // <method>
        // </rsp>
        //
        // observed as
        // <rsp>
        // <method>
        // <arguments>
        // <errors>
        // </rsp>
        //
        if (argumentsElement == null) {
            _log.debug(""getMethodInfo: Using workaround for arguments array"");
            Element parent = (Element) methodElement.getParentNode();
            Element child = XMLUtilities.getChild(parent, ""arguments"");
            if (child != null) {
                argumentsElement = child;
            }
        }
        NodeList argumentElements = argumentsElement.getElementsByTagName(""argument"");
        for (int i = 0; i < argumentElements.getLength(); i++) {
            Argument argument = new Argument();
            Element argumentElement = (Element) argumentElements.item(i);
            argument.setName(argumentElement.getAttribute(""name""));
            argument.setOptional(""1"".equals(argumentElement.getAttribute(""optional"")));
            argument.setDescription(XMLUtilities.getValue(argumentElement));
            arguments.add(argument);
        }
        method.setArguments(arguments);

        Element errorsElement = XMLUtilities.getChild(methodElement, ""errors"");
        // tolerant fix for incorrect nesting of the <errors> element
        // as observed in current flickr responses of this method
        // as of 2006-09-15
        //
        // specified as
        // <rsp>
        // <method>
        // <arguments>
        // <errors>
        // <method>
        // </rsp>
        //
        // observed as
        // <rsp>
        // <method>
        // <arguments>
        // <errors>
        // </rsp>
        //
        if (errorsElement == null) {
            _log.debug(""getMethodInfo: Using workaround for errors array"");
            Element parent = (Element) methodElement.getParentNode();
            Element child = XMLUtilities.getChild(parent, ""errors"");
            if (child != null) {
                errorsElement = child;
            }
        }
        List<Error> errors = new ArrayList<Error>();
        NodeList errorElements = errorsElement.getElementsByTagName(""error"");
        for (int i = 0; i < errorElements.getLength(); i++) {
            Error error = new Error();
            Element errorElement = (Element) errorElements.item(i);
            error.setCode(errorElement.getAttribute(""code""));
            error.setMessage(errorElement.getAttribute(""message""));
            error.setExplaination(XMLUtilities.getValue(errorElement));
            errors.add(error);
        }
        method.setErrors(errors);

        return method;
    }

    /**
     * Get a list of all methods.
     * 
     * @return The method names
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Collection<String> getMethods() throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_METHODS);

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element methodsElement = response.getPayload();

        List<String> methods = new ArrayList<String>();
        NodeList methodElements = methodsElement.getElementsByTagName(""method"");
        for (int i = 0; i < methodElements.getLength(); i++) {
            Element methodElement = (Element) methodElements.item(i);
            methods.add(XMLUtilities.getValue(methodElement));
        }
        return methods;
    }

}
","package com.flickr4java.flickr.reflection; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.XMLUtilities; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.List; import java.util.Map; public class ReflectionInterface { private static Logger _log = LoggerFactory.getLogger(ReflectionInterface.class); public static final String METHOD_GET_METHOD_INFO = ""flickr.reflection.getMethodInfo""; public static final String METHOD_GET_METHODS = ""flickr.reflection.getMethods""; private final String apiKey; private final String sharedSecret; private final Transport transport; public ReflectionInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transport = transport; } public Method getMethodInfo(String methodName) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_METHOD_INFO); parameters.put(""method_name"", methodName); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element methodElement = response.getPayload(); Method method = new Method(); method.setName(methodElement.getAttribute(""name"")); method.setNeedsLogin(""1"".equals(methodElement.getAttribute(""needslogin""))); method.setNeedsSigning(""1"".equals(methodElement.getAttribute(""needssigning""))); String requiredPermsStr = methodElement.getAttribute(""requiredperms""); if (requiredPermsStr != null && requiredPermsStr.length() > 0) { try { int perms = Integer.parseInt(requiredPermsStr); method.setRequiredPerms(perms); } catch (NumberFormatException e) { e.printStackTrace(); } } method.setDescription(XMLUtilities.getChildValue(methodElement, ""description"")); method.setResponse(XMLUtilities.getChildValue(methodElement, ""response"")); method.setExplanation(XMLUtilities.getChildValue(methodElement, ""explanation"")); List<Argument> arguments = new ArrayList<Argument>(); Element argumentsElement = XMLUtilities.getChild(methodElement, ""arguments""); if (argumentsElement == null) { Element parent = (Element) methodElement.getParentNode(); Element child = XMLUtilities.getChild(parent, ""arguments""); if (child != null) { argumentsElement = child; } } NodeList argumentElements = argumentsElement.getElementsByTagName(""argument""); for (int i = 0; i < argumentElements.getLength(); i++) { Argument argument = new Argument(); Element argumentElement = (Element) argumentElements.item(i); argument.setName(argumentElement.getAttribute(""name"")); argument.setOptional(""1"".equals(argumentElement.getAttribute(""optional""))); argument.setDescription(XMLUtilities.getValue(argumentElement)); arguments.add(argument); } method.setArguments(arguments); Element errorsElement = XMLUtilities.getChild(methodElement, ""errors""); if (errorsElement == null) { Element parent = (Element) methodElement.getParentNode(); Element child = XMLUtilities.getChild(parent, ""errors""); if (child != null) { errorsElement = child; } } List<Error> errors = new ArrayList<Error>(); NodeList errorElements = errorsElement.getElementsByTagName(""error""); for (int i = 0; i < errorElements.getLength(); i++) { Error error = new Error(); Element errorElement = (Element) errorElements.item(i); error.setCode(errorElement.getAttribute(""code"")); error.setMessage(errorElement.getAttribute(""message"")); error.setExplaination(XMLUtilities.getValue(errorElement)); errors.add(error); } method.setErrors(errors); return method; } public Collection<String> getMethods() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_METHODS); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element methodsElement = response.getPayload(); List<String> methods = new ArrayList<String>(); NodeList methodElements = methodsElement.getElementsByTagName(""method""); for (int i = 0; i < methodElements.getLength(); i++) { Element methodElement = (Element) methodElements.item(i); methods.add(XMLUtilities.getValue(methodElement)); } return methods; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.reflection; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.XMLUtilities; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.List; import java.util.Map; public class ReflectionInterface { private static Logger _log = LoggerFactory.getLogger(ReflectionInterface.class); public static final String METHOD_GET_METHOD_INFO = ""flickr.reflection.getMethodInfo""; public static final String METHOD_GET_METHODS = ""flickr.reflection.getMethods""; private final String apiKey; private final String sharedSecret; private final Transport transport; public ReflectionInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transport = transport; } public Method getMethodInfo(String methodName) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_METHOD_INFO); parameters.put(""method_name"", methodName); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element methodElement = response.getPayload(); Method method = new Method(); method.setName(methodElement.getAttribute(""name"")); method.setNeedsLogin(""1"".equals(methodElement.getAttribute(""needslogin""))); method.setNeedsSigning(""1"".equals(methodElement.getAttribute(""needssigning""))); String requiredPermsStr = methodElement.getAttribute(""requiredperms""); if (requiredPermsStr != null && requiredPermsStr.length() > 0) { try { int perms = Integer.parseInt(requiredPermsStr); method.setRequiredPerms(perms); } catch (NumberFormatException e) { e.printStackTrace(); } } method.setDescription(XMLUtilities.getChildValue(methodElement, ""description"")); method.setResponse(XMLUtilities.getChildValue(methodElement, ""response"")); method.setExplanation(XMLUtilities.getChildValue(methodElement, ""explanation"")); List<Argument> arguments = new ArrayList<Argument>(); Element argumentsElement = XMLUtilities.getChild(methodElement, ""arguments""); if (argumentsElement == null) { <FILL_ME> Element parent = (Element) methodElement.getParentNode(); Element child = XMLUtilities.getChild(parent, ""arguments""); if (child != null) { argumentsElement = child; } } NodeList argumentElements = argumentsElement.getElementsByTagName(""argument""); for (int i = 0; i < argumentElements.getLength(); i++) { Argument argument = new Argument(); Element argumentElement = (Element) argumentElements.item(i); argument.setName(argumentElement.getAttribute(""name"")); argument.setOptional(""1"".equals(argumentElement.getAttribute(""optional""))); argument.setDescription(XMLUtilities.getValue(argumentElement)); arguments.add(argument); } method.setArguments(arguments); Element errorsElement = XMLUtilities.getChild(methodElement, ""errors""); if (errorsElement == null) { <FILL_ME> Element parent = (Element) methodElement.getParentNode(); Element child = XMLUtilities.getChild(parent, ""errors""); if (child != null) { errorsElement = child; } } List<Error> errors = new ArrayList<Error>(); NodeList errorElements = errorsElement.getElementsByTagName(""error""); for (int i = 0; i < errorElements.getLength(); i++) { Error error = new Error(); Element errorElement = (Element) errorElements.item(i); error.setCode(errorElement.getAttribute(""code"")); error.setMessage(errorElement.getAttribute(""message"")); error.setExplaination(XMLUtilities.getValue(errorElement)); errors.add(error); } method.setErrors(errors); return method; } public Collection<String> getMethods() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_METHODS); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element methodsElement = response.getPayload(); List<String> methods = new ArrayList<String>(); NodeList methodElements = methodsElement.getElementsByTagName(""method""); for (int i = 0; i < methodElements.getLength(); i++) { Element methodElement = (Element) methodElements.item(i); methods.add(XMLUtilities.getValue(methodElement)); } return methods; } } "," package com.flickr4java.flickr.reflection;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.XMLUtilities; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.List; import java.util.Map;  /**
 * Interface for testing the complete implementation of all Flickr-methods.
 * <p>
 * 
 * @author Anthony Eden
 * @version $Id: ReflectionInterface.java,v 1.10 2008/01/28 23:01:45 x-mago Exp $
 */ public class ReflectionInterface {  private static Logger _log = LoggerFactory.getLogger(ReflectionInterface.class);  public static final String METHOD_GET_METHOD_INFO = ""flickr.reflection.getMethodInfo"";  public static final String METHOD_GET_METHODS = ""flickr.reflection.getMethods"";  private final String apiKey;  private final String sharedSecret;  private final Transport transport;  /**
     * Construct a ReflectionInterface.
     * 
     * @param apiKey
     *            The API key
     * @param sharedSecret
     *            The Shared Secret
     * @param transport
     *            The Transport interface
     */ public ReflectionInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transport = transport; }  /**
     * Get the info for the specified method.
     * 
     * @param methodName
     *            The method name
     * @return The Method object
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Method getMethodInfo(String methodName) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_METHOD_INFO);  parameters.put(""method_name"", methodName);  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element methodElement = response.getPayload(); Method method = new Method(); method.setName(methodElement.getAttribute(""name"")); method.setNeedsLogin(""1"".equals(methodElement.getAttribute(""needslogin""))); method.setNeedsSigning(""1"".equals(methodElement.getAttribute(""needssigning""))); String requiredPermsStr = methodElement.getAttribute(""requiredperms""); if (requiredPermsStr != null && requiredPermsStr.length() > 0) { try { int perms = Integer.parseInt(requiredPermsStr); method.setRequiredPerms(perms); } catch (NumberFormatException e) { // what shall we do? e.printStackTrace(); } } method.setDescription(XMLUtilities.getChildValue(methodElement, ""description"")); method.setResponse(XMLUtilities.getChildValue(methodElement, ""response"")); method.setExplanation(XMLUtilities.getChildValue(methodElement, ""explanation""));  List<Argument> arguments = new ArrayList<Argument>(); Element argumentsElement = XMLUtilities.getChild(methodElement, ""arguments""); // tolerant fix for incorrect nesting of the <arguments> element // as observed in current flickr responses of this method // // specified as // <rsp> // <method> // <arguments> // <errors> // <method> // </rsp> // // observed as // <rsp> // <method> // <arguments> // <errors> // </rsp> // if (argumentsElement == null) { <FILL_ME> Element parent = (Element) methodElement.getParentNode(); Element child = XMLUtilities.getChild(parent, ""arguments""); if (child != null) { argumentsElement = child; } } NodeList argumentElements = argumentsElement.getElementsByTagName(""argument""); for (int i = 0; i < argumentElements.getLength(); i++) { Argument argument = new Argument(); Element argumentElement = (Element) argumentElements.item(i); argument.setName(argumentElement.getAttribute(""name"")); argument.setOptional(""1"".equals(argumentElement.getAttribute(""optional""))); argument.setDescription(XMLUtilities.getValue(argumentElement)); arguments.add(argument); } method.setArguments(arguments);  Element errorsElement = XMLUtilities.getChild(methodElement, ""errors""); // tolerant fix for incorrect nesting of the <errors> element // as observed in current flickr responses of this method // as of 2006-09-15 // // specified as // <rsp> // <method> // <arguments> // <errors> // <method> // </rsp> // // observed as // <rsp> // <method> // <arguments> // <errors> // </rsp> // if (errorsElement == null) { <FILL_ME> Element parent = (Element) methodElement.getParentNode(); Element child = XMLUtilities.getChild(parent, ""errors""); if (child != null) { errorsElement = child; } } List<Error> errors = new ArrayList<Error>(); NodeList errorElements = errorsElement.getElementsByTagName(""error""); for (int i = 0; i < errorElements.getLength(); i++) { Error error = new Error(); Element errorElement = (Element) errorElements.item(i); error.setCode(errorElement.getAttribute(""code"")); error.setMessage(errorElement.getAttribute(""message"")); error.setExplaination(XMLUtilities.getValue(errorElement)); errors.add(error); } method.setErrors(errors);  return method; }  /**
     * Get a list of all methods.
     * 
     * @return The method names
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Collection<String> getMethods() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_METHODS);  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element methodsElement = response.getPayload();  List<String> methods = new ArrayList<String>(); NodeList methodElements = methodsElement.getElementsByTagName(""method""); for (int i = 0; i < methodElements.getLength(); i++) { Element methodElement = (Element) methodElements.item(i); methods.add(XMLUtilities.getValue(methodElement)); } return methods; }  }  "
src/main/java/com/flickr4java/flickr/stats/Csv.java,"package com.flickr4java.flickr.stats;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Date;

/**
 * For the flickr.stats.getCSVFiles call.
 * 
 * @author Darren Greaves
 * @version $Id$ Copyright (c) 2012 Darren Greaves.
 */
public class Csv {

    /**
     * Logger.
     */
    @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(Csv.class);

    private String href;

    private String type;

    private Date date;

    public String getHref() {
        return href;
    }

    public void setHref(String href) {
        this.href = href;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }
}
","package com.flickr4java.flickr.stats; public class Csv { @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(Csv.class); private String href; private String type; private Date date; public String getHref() { return href; } public void setHref(String href) { this.href = href; } public String getType() { return type; } public void setType(String type) { this.type = type; } public Date getDate() { return date; } public void setDate(Date date) { this.date = date; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.stats; public class Csv { @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(Csv.class); private String href; private String type; private Date date; public String getHref() { return href; } public void setHref(String href) { this.href = href; } public String getType() { return type; } public void setType(String type) { this.type = type; } public Date getDate() { return date; } public void setDate(Date date) { this.date = date; } } ","package com.flickr4java.flickr.stats; 
import org.slf4j.Logger; import org.slf4j.LoggerFactory; 
import java.util.Date;  /**
 * For the flickr.stats.getCSVFiles call.
 * 
 * @author Darren Greaves
 * @version $Id$ Copyright (c) 2012 Darren Greaves.
 */ public class Csv {  /**
     * Logger.
     */ @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(Csv.class);  private String href;  private String type;  private Date date;  public String getHref() { return href; }  public void setHref(String href) { this.href = href; }  public String getType() { return type; }  public void setType(String type) { this.type = type; }  public Date getDate() { return date; }  public void setDate(Date date) { this.date = date; } }  "
src/main/java/com/flickr4java/flickr/stats/Domain.java,"package com.flickr4java.flickr.stats;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Domain information as returned by the stats interface.
 * 
 * @author Darren Greaves
 * @version $Id$ Copyright (c) 2012 Darren Greaves.
 */
public class Domain {

    /**
     * Logger.
     */
    @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(Domain.class);

    public Domain() {
    }

    public Domain(String name, Long views) {
        super();
        this.name = name;
        this.views = views;
    }

    private String name;

    private Long views;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Long getViews() {
        return views;
    }

    public void setViews(Long views) {
        this.views = views;
    }

    public void setViews(String views) {

        try {
            setViews(Long.valueOf(views));
        } catch (NumberFormatException e) {
            // ignore and set value as null
        }
    }

    @Override
    public String toString() {

        return String.format(""%s (%d)"", name, views);
    }
}
","package com.flickr4java.flickr.stats; public class Domain { @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(Domain.class); public Domain() { } public Domain(String name, Long views) { super(); this.name = name; this.views = views; } private String name; private Long views; public String getName() { return name; } public void setName(String name) { this.name = name; } public Long getViews() { return views; } public void setViews(Long views) { this.views = views; } public void setViews(String views) { try { setViews(Long.valueOf(views)); } catch (NumberFormatException e) { } } @Override
    public String toString() { return String.format(""%s (%d)"", name, views); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.stats; public class Domain { @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(Domain.class); public Domain() { } public Domain(String name, Long views) { super(); this.name = name; this.views = views; } private String name; private Long views; public String getName() { return name; } public void setName(String name) { this.name = name; } public Long getViews() { return views; } public void setViews(Long views) { this.views = views; } public void setViews(String views) { try { setViews(Long.valueOf(views)); } catch (NumberFormatException e) { } } @Override
    public String toString() { return String.format(""%s (%d)"", name, views); } } ","package com.flickr4java.flickr.stats; 
import org.slf4j.Logger; import org.slf4j.LoggerFactory;  /**
 * Domain information as returned by the stats interface.
 * 
 * @author Darren Greaves
 * @version $Id$ Copyright (c) 2012 Darren Greaves.
 */ public class Domain {  /**
     * Logger.
     */ @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(Domain.class);  public Domain() { }  public Domain(String name, Long views) { super(); this.name = name; this.views = views; }  private String name;  private Long views;  public String getName() { return name; }  public void setName(String name) { this.name = name; }  public Long getViews() { return views; }  public void setViews(Long views) { this.views = views; }  public void setViews(String views) {  try { setViews(Long.valueOf(views)); } catch (NumberFormatException e) { // ignore and set value as null } }  @Override
    public String toString() {  return String.format(""%s (%d)"", name, views); } }  "
src/main/java/com/flickr4java/flickr/stats/DomainList.java,"package com.flickr4java.flickr.stats;

import com.flickr4java.flickr.SearchResultList;

/**
 * 
 * @author Darren Greaves
 */
public class DomainList extends SearchResultList<Domain> {

}
",package com.flickr4java.flickr.stats; public class DomainList extends SearchResultList<Domain> { },0 0 0 0,package com.flickr4java.flickr.stats; public class DomainList extends SearchResultList<Domain> { } ,"package com.flickr4java.flickr.stats; 
import com.flickr4java.flickr.SearchResultList;  /**
 * 
 * @author Darren Greaves
 */ public class DomainList extends SearchResultList<Domain> {  }  "
src/main/java/com/flickr4java/flickr/stats/Referrer.java,"package com.flickr4java.flickr.stats;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Referrer information as returned by the stats interface.
 * 
 * @author Darren Greaves
 * @version $Id$ Copyright (c) 2012 Darren Greaves.
 */
public class Referrer {

    /**
     * Logger.
     */
    @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(Referrer.class);

    public Referrer() {
    }

    public Referrer(String url, Long views) {
        super();
        this.url = url;
        this.views = views;
    }

    private String url;

    private Long views;

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public Long getViews() {
        return views;
    }

    public void setViews(Long views) {
        this.views = views;
    }

    public void setViews(String views) {

        try {
            setViews(Long.valueOf(views));
        } catch (NumberFormatException e) {
            // ignore and set value as null
        }
    }

    @Override
    public String toString() {

        return String.format(""%s (%d)"", url, views);
    }
}
","package com.flickr4java.flickr.stats; public class Referrer { @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(Referrer.class); public Referrer() { } public Referrer(String url, Long views) { super(); this.url = url; this.views = views; } private String url; private Long views; public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } public Long getViews() { return views; } public void setViews(Long views) { this.views = views; } public void setViews(String views) { try { setViews(Long.valueOf(views)); } catch (NumberFormatException e) { } } @Override
    public String toString() { return String.format(""%s (%d)"", url, views); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.stats; public class Referrer { @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(Referrer.class); public Referrer() { } public Referrer(String url, Long views) { super(); this.url = url; this.views = views; } private String url; private Long views; public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } public Long getViews() { return views; } public void setViews(Long views) { this.views = views; } public void setViews(String views) { try { setViews(Long.valueOf(views)); } catch (NumberFormatException e) { } } @Override
    public String toString() { return String.format(""%s (%d)"", url, views); } } ","package com.flickr4java.flickr.stats; 
import org.slf4j.Logger; import org.slf4j.LoggerFactory;  /**
 * Referrer information as returned by the stats interface.
 * 
 * @author Darren Greaves
 * @version $Id$ Copyright (c) 2012 Darren Greaves.
 */ public class Referrer {  /**
     * Logger.
     */ @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(Referrer.class);  public Referrer() { }  public Referrer(String url, Long views) { super(); this.url = url; this.views = views; }  private String url;  private Long views;  public String getUrl() { return url; }  public void setUrl(String url) { this.url = url; }  public Long getViews() { return views; }  public void setViews(Long views) { this.views = views; }  public void setViews(String views) {  try { setViews(Long.valueOf(views)); } catch (NumberFormatException e) { // ignore and set value as null } }  @Override
    public String toString() {  return String.format(""%s (%d)"", url, views); } }  "
src/main/java/com/flickr4java/flickr/stats/ReferrerList.java,"package com.flickr4java.flickr.stats;

import com.flickr4java.flickr.SearchResultList;

/**
 * 
 * @author Darren Greaves
 */
public class ReferrerList extends SearchResultList<Referrer> {

    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
",package com.flickr4java.flickr.stats; public class ReferrerList extends SearchResultList<Referrer> { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } },0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.stats; public class ReferrerList extends SearchResultList<Referrer> { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } ,"package com.flickr4java.flickr.stats; 
import com.flickr4java.flickr.SearchResultList;  /**
 * 
 * @author Darren Greaves
 */ public class ReferrerList extends SearchResultList<Referrer> {  private String name;  public String getName() { return name; }  public void setName(String name) { this.name = name; } }  "
src/main/java/com/flickr4java/flickr/stats/Stats.java,"package com.flickr4java.flickr.stats;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Stats information as returned by the stats interface.
 * 
 * @author Darren Greaves
 * @version $Id$ Copyright (c) 2012 Darren Greaves.
 */
public class Stats {

    /**
     * Logger.
     */
    @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(Stats.class);

    private int views;

    private int comments;

    private int favorites;

    public Stats() {
    }

    public int getViews() {
        return views;
    }

    public void setViews(int views) {
        this.views = views;
    }

    public void setViews(String views) {
        try {
            setViews(Integer.parseInt(views));
        } catch (NumberFormatException e) {
            // ignore and set value as 0
            setViews(0);
        }
    }

    public int getComments() {
        return comments;
    }

    public void setComments(int comments) {
        this.comments = comments;
    }

    public void setComments(String comments) {
        try {
            setComments(Integer.parseInt(comments));
        } catch (NumberFormatException e) {
            // ignore and set value as 0
            setComments(0);
        }
    }

    public int getFavorites() {
        return favorites;
    }

    public void setFavorites(int favorites) {
        this.favorites = favorites;
    }

    public void setFavorites(String favorites) {
        try {
            setFavorites(Integer.parseInt(favorites));
        } catch (NumberFormatException e) {
            // ignore and set value as null
            setFavorites(0);
        }
    }

    @SuppressWarnings(""boxing"")
    @Override
    public String toString() {

        return String.format(""views (%d), favorites (%d), comments (%d)"", views, favorites, comments);
    }
}
","package com.flickr4java.flickr.stats; public class Stats { @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(Stats.class); private int views; private int comments; private int favorites; public Stats() { } public int getViews() { return views; } public void setViews(int views) { this.views = views; } public void setViews(String views) { try { setViews(Integer.parseInt(views)); } catch (NumberFormatException e) { setViews(0); } } public int getComments() { return comments; } public void setComments(int comments) { this.comments = comments; } public void setComments(String comments) { try { setComments(Integer.parseInt(comments)); } catch (NumberFormatException e) { setComments(0); } } public int getFavorites() { return favorites; } public void setFavorites(int favorites) { this.favorites = favorites; } public void setFavorites(String favorites) { try { setFavorites(Integer.parseInt(favorites)); } catch (NumberFormatException e) { setFavorites(0); } } @SuppressWarnings(""boxing"")
    @Override
    public String toString() { return String.format(""views (%d), favorites (%d), comments (%d)"", views, favorites, comments); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.stats; public class Stats { @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(Stats.class); private int views; private int comments; private int favorites; public Stats() { } public int getViews() { return views; } public void setViews(int views) { this.views = views; } public void setViews(String views) { try { setViews(Integer.parseInt(views)); } catch (NumberFormatException e) { setViews(0); } } public int getComments() { return comments; } public void setComments(int comments) { this.comments = comments; } public void setComments(String comments) { try { setComments(Integer.parseInt(comments)); } catch (NumberFormatException e) { setComments(0); } } public int getFavorites() { return favorites; } public void setFavorites(int favorites) { this.favorites = favorites; } public void setFavorites(String favorites) { try { setFavorites(Integer.parseInt(favorites)); } catch (NumberFormatException e) { setFavorites(0); } } @SuppressWarnings(""boxing"")
    @Override
    public String toString() { return String.format(""views (%d), favorites (%d), comments (%d)"", views, favorites, comments); } } ","package com.flickr4java.flickr.stats; 
import org.slf4j.Logger; import org.slf4j.LoggerFactory;  /**
 * Stats information as returned by the stats interface.
 * 
 * @author Darren Greaves
 * @version $Id$ Copyright (c) 2012 Darren Greaves.
 */ public class Stats {  /**
     * Logger.
     */ @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(Stats.class);  private int views;  private int comments;  private int favorites;  public Stats() { }  public int getViews() { return views; }  public void setViews(int views) { this.views = views; }  public void setViews(String views) { try { setViews(Integer.parseInt(views)); } catch (NumberFormatException e) { // ignore and set value as 0 setViews(0); } }  public int getComments() { return comments; }  public void setComments(int comments) { this.comments = comments; }  public void setComments(String comments) { try { setComments(Integer.parseInt(comments)); } catch (NumberFormatException e) { // ignore and set value as 0 setComments(0); } }  public int getFavorites() { return favorites; }  public void setFavorites(int favorites) { this.favorites = favorites; }  public void setFavorites(String favorites) { try { setFavorites(Integer.parseInt(favorites)); } catch (NumberFormatException e) { // ignore and set value as null setFavorites(0); } }  @SuppressWarnings(""boxing"")
    @Override
    public String toString() {  return String.format(""views (%d), favorites (%d), comments (%d)"", views, favorites, comments); } }  "
src/main/java/com/flickr4java/flickr/stats/StatsInterface.java,"package com.flickr4java.flickr.stats;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.FlickrRuntimeException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoList;
import com.flickr4java.flickr.photos.PhotoUtils;
import com.flickr4java.flickr.util.XMLUtilities;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Interface to the Stats API.
 * 
 * @author Darren Greaves
 * @version $Id$ Copyright (c) 2012 Darren Greaves.
 */
public class StatsInterface {

    /**
     * Logger.
     */
    @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(StatsInterface.class);

    private static final String METHOD_GET_COLLECTION_DOMAINS = ""flickr.stats.getCollectionDomains"";

    private static final String METHOD_GET_COLLECTION_REFERRERS = ""flickr.stats.getCollectionReferrers"";

    private static final String METHOD_GET_COLLECTION_STATS = ""flickr.stats.getCollectionStats"";

    private static final String METHOD_GET_CSV_FILES = ""flickr.stats.getCSVFiles"";

    private static final String METHOD_GET_PHOTO_DOMAINS = ""flickr.stats.getPhotoDomains"";

    private static final String METHOD_GET_PHOTO_REFERRERS = ""flickr.stats.getPhotoReferrers"";

    private static final String METHOD_GET_PHOTO_STATS = ""flickr.stats.getPhotoStats"";

    private static final String METHOD_GET_PHOTOSET_DOMAINS = ""flickr.stats.getPhotosetDomains"";

    private static final String METHOD_GET_PHOTOSET_REFERRERS = ""flickr.stats.getPhotosetReferrers"";

    private static final String METHOD_GET_PHOTOSET_STATS = ""flickr.stats.getPhotosetStats"";

    private static final String METHOD_GET_PHOTOSTREAM_DOMAINS = ""flickr.stats.getPhotostreamDomains"";

    private static final String METHOD_GET_PHOTOSTREAM_REFERRERS = ""flickr.stats.getPhotostreamReferrers"";

    private static final String METHOD_GET_PHOTOSTREAM_STATS = ""flickr.stats.getPhotostreamStats"";

    private static final String METHOD_GET_POPULAR_PHOTOS = ""flickr.stats.getPopularPhotos"";

    private static final String METHOD_GET_TOTAL_VIEWS = ""flickr.stats.getTotalViews"";

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transportAPI;

    public StatsInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transportAPI;
    }

    /**
     * Get a list of referring domains for a collection.
     * 
     * @param date
     *            (Required) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day.
     * @param collectionId
     *            (Optional) The id of the collection to get stats for. If not provided, stats for all collections will be returned.
     * @param perPage
     *            (Optional) Number of domains to return per page. If this argument is omitted, it defaults to 25. The maximum allowed value is 100.
     * @param page
     *            (Optional) The page of results to return. If this argument is omitted, it defaults to 1.
     * @see ""http://www.flickr.com/services/api/flickr.stats.getCollectionDomains.html""
     */
    public DomainList getCollectionDomains(Date date, String collectionId, int perPage, int page) throws FlickrException {
        return getDomains(METHOD_GET_COLLECTION_DOMAINS, ""collection_id"", collectionId, date, perPage, page);
    }

    /**
     * Get a list of referrers from a given domain to a collection.
     * 
     * @param date
     *            (Required) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day.
     * @param domain
     *            (Required) The domain to return referrers for. This should be a hostname (eg: ""flickr.com"") with no protocol or pathname.
     * @param collectionId
     *            (Optional) The id of the collection to get stats for. If not provided, stats for all collections will be returned.
     * @param perPage
     *            (Optional) Number of domains to return per page. If this argument is omitted, it defaults to 25. The maximum allowed value is 100.
     * @param page
     *            (Optional) The page of results to return. If this argument is omitted, it defaults to 1.
     * @see ""http://www.flickr.com/services/api/flickr.stats.getCollectionReferrers.html""
     */
    public ReferrerList getCollectionReferrers(Date date, String domain, String collectionId, int perPage, int page) throws FlickrException {
        return getReferrers(METHOD_GET_COLLECTION_REFERRERS, domain, ""collection_id"", collectionId, date, perPage, page);
    }

    /**
     * Get the number of views, comments and favorites on a collection for a given date.
     * 
     * @param date
     *            (Required) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day.
     * @param collectionId
     *            (Required) The id (from the URL!) of the collection to get stats for.
     * @see ""http://www.flickr.com/services/api/flickr.stats.getCollectionStats.htm""
     */
    public Stats getCollectionStats(String collectionId, Date date) throws FlickrException {
        return getStats(METHOD_GET_COLLECTION_STATS, ""collection_id"", collectionId, date);
    }

    /**
     * Returns a list of URLs for text files containing all your stats data (from November 26th 2007 onwards) for the currently auth'd user.
     * 
     * @throws FlickrException if there was a problem connecting to Flickr
     * 
     * @see ""http://www.flickr.com/services/api/flickr.stats.getCSVFiles.html""
     */
    public List<Csv> getCSVFiles() throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_CSV_FILES);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        List<Csv> csvFiles = parseCsvFiles(response);

        return csvFiles;
    }

    /**
     * Get a list of referring domains for a photo.
     * 
     * @param date
     *            (Required) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day.
     * @param photoId
     *            (Optional) The id of the photo to get stats for. If not provided, stats for all photos will be returned.
     * @param perPage
     *            (Optional) Number of domains to return per page. If this argument is omitted, it defaults to 25. The maximum allowed value is 100.
     * @param page
     *            (Optional) The page of results to return. If this argument is omitted, it defaults to 1.
     * @see ""http://www.flickr.com/services/api/flickr.stats.getPhotoDomains.html""
     */
    public DomainList getPhotoDomains(Date date, String photoId, int perPage, int page) throws FlickrException {
        return getDomains(METHOD_GET_PHOTO_DOMAINS, ""photo_id"", photoId, date, perPage, page);
    }

    /**
     * Get a list of referrers from a given domain to a photo.
     * 
     * @param date
     *            (Required) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day.
     * @param domain
     *            (Required) The domain to return referrers for. This should be a hostname (eg: ""flickr.com"") with no protocol or pathname.
     * @param photoId
     *            (Optional) The id of the photo to get stats for. If not provided, stats for all photos will be returned.
     * @param perPage
     *            (Optional) Number of domains to return per page. If this argument is omitted, it defaults to 25. The maximum allowed value is 100.
     * @param page
     *            (Optional) The page of results to return. If this argument is omitted, it defaults to 1.
     * @see ""http://www.flickr.com/services/api/flickr.stats.getPhotoReferrers.html""
     */
    public ReferrerList getPhotoReferrers(Date date, String domain, String photoId, int perPage, int page) throws FlickrException {
        return getReferrers(METHOD_GET_PHOTO_REFERRERS, domain, ""photo_id"", photoId, date, perPage, page);
    }

    /**
     * Get the number of views, comments and favorites on a photo for a given date.
     * 
     * @param date
     *            (Required) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day.
     * @param photoId
     *            (Required) The id of the photo to get stats for.
     * @see ""http://www.flickr.com/services/api/flickr.stats.getPhotoStats.htm""
     */
    public Stats getPhotoStats(String photoId, Date date) throws FlickrException {
        return getStats(METHOD_GET_PHOTO_STATS, ""photo_id"", photoId, date);
    }

    /**
     * Get a list of referring domains for a photoset.
     * 
     * @param date
     *            (Required) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day.
     * @param photosetId
     *            (Optional) The id of the photoset to get stats for. If not provided, stats for all photos will be returned.
     * @param perPage
     *            (Optional) Number of domains to return per page. If this argument is omitted, it defaults to 25. The maximum allowed value is 100.
     * @param page
     *            (Optional) The page of results to return. If this argument is omitted, it defaults to 1.
     * @see ""http://www.flickr.com/services/api/flickr.stats.getPhotosetDomains.html""
     */
    public DomainList getPhotosetDomains(Date date, String photosetId, int perPage, int page) throws FlickrException {
        return getDomains(METHOD_GET_PHOTOSET_DOMAINS, ""photoset_id"", photosetId, date, perPage, page);
    }

    /**
     * Get a list of referrers from a given domain to a photoset.
     * 
     * @param date
     *            (Required) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day.
     * @param domain
     *            (Required) The domain to return referrers for. This should be a hostname (eg: ""flickr.com"") with no protocol or pathname.
     * @param photosetId
     *            (Optional) The id of the photoset to get stats for. If not provided, stats for all sets will be returned.
     * @param perPage
     *            (Optional) Number of domains to return per page. If this argument is omitted, it defaults to 25. The maximum allowed value is 100.
     * @param page
     *            (Optional) The page of results to return. If this argument is omitted, it defaults to 1.
     * @see ""http://www.flickr.com/services/api/flickr.stats.getPhotosetReferrers.html""
     */
    public ReferrerList getPhotosetReferrers(Date date, String domain, String photosetId, int perPage, int page) throws FlickrException {
        return getReferrers(METHOD_GET_PHOTOSET_REFERRERS, domain, ""photoset_id"", photosetId, date, perPage, page);
    }

    /**
     * Get the number of views, comments and favorites on a photoset for a given date.
     * 
     * @param date
     *            (Required) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day.
     * @param photosetId
     *            (Required) The id of the photoset to get stats for.
     * @see ""http://www.flickr.com/services/api/flickr.stats.getPhotosetStats.htm""
     */
    public Stats getPhotosetStats(String photosetId, Date date) throws FlickrException {
        return getStats(METHOD_GET_PHOTOSET_STATS, ""photoset_id"", photosetId, date);
    }

    /**
     * Get a list of referring domains for a photostream.
     * 
     * @param date
     *            (Required) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day.
     * @param perPage
     *            (Optional) Number of domains to return per page. If this argument is omitted, it defaults to 25. The maximum allowed value is 100.
     * @param page
     *            (Optional) The page of results to return. If this argument is omitted, it defaults to 1.
     * @see ""http://www.flickr.com/services/api/flickr.stats.getPhotostreamDomains.html""
     */
    public DomainList getPhotostreamDomains(Date date, int perPage, int page) throws FlickrException {
        return getDomains(METHOD_GET_PHOTOSTREAM_DOMAINS, null, null, date, perPage, page);

    }

    /**
     * Get a list of referrers from a given domain to a user's photostream.
     * 
     * @param date
     *            (Required) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day.
     * @param domain
     *            (Required) The domain to return referrers for. This should be a hostname (eg: ""flickr.com"") with no protocol or pathname.
     * @param perPage
     *            (Optional) Number of domains to return per page. If this argument is omitted, it defaults to 25. The maximum allowed value is 100.
     * @param page
     *            (Optional) The page of results to return. If this argument is omitted, it defaults to 1.
     * @see ""http://www.flickr.com/services/api/flickr.stats.getPhotostreamReferrers.html""
     */
    public ReferrerList getPhotostreamReferrers(Date date, String domain, int perPage, int page) throws FlickrException {
        return getReferrers(METHOD_GET_PHOTOSTREAM_REFERRERS, domain, null, null, date, perPage, page);
    }

    /**
     * Get the number of views, comments and favorites on a photostream for a given date.
     * 
     * @param date
     *            (Required) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day.
     * @see ""http://www.flickr.com/services/api/flickr.stats.getPhotostreamStats.htm""
     */
    public Stats getPhotostreamStats(Date date) throws FlickrException {
        return getStats(METHOD_GET_PHOTOSTREAM_STATS, null, null, date);
    }

    /**
     * List the photos with the most views, comments or favorites.
     * 
     * @param date
     *            (Optional) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day. If no date is provided, all time view counts will be returned.
     * @param sort
     *            (Optional) The order in which to sort returned photos. Defaults to views. The possible values are views, comments and favorites. Other sort
     *            options are available through flickr.photos.search.
     * @param perPage
     *            (Optional) Number of referrers to return per page. If this argument is omitted, it defaults to 25. The maximum allowed value is 100.
     * @param page
     *            (Optional) The page of results to return. If this argument is omitted, it defaults to 1.
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see ""http://www.flickr.com/services/api/flickr.stats.getPopularPhotos.html""
     */
    public PhotoList<Photo> getPopularPhotos(Date date, StatsSort sort, int perPage, int page) throws FlickrException {

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_POPULAR_PHOTOS);
        if (date != null) {
            parameters.put(""date"", String.valueOf(date.getTime() / 1000L));
        }
        if (sort != null) {
            parameters.put(""sort"", sort.name());
        }
        addPaginationParameters(parameters, perPage, page);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        return parsePopularPhotos(response);
    }

    /**
     * Get the overall view counts for an account
     * 
     * @param date
     *            (Optional) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day. If no date is provided, all time view counts will be returned.
     * @throws FlickrException if there was a problem connecting to Flickr
     * 
     * @see ""http://www.flickr.com/services/api/flickr.stats.getTotalViews.html""
     */
    public Totals getTotalViews(Date date) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_TOTAL_VIEWS);
        if (date != null) {
            parameters.put(""date"", String.valueOf(date.getTime() / 1000L));
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Totals totals = parseTotals(response);

        return totals;
    }

    private DomainList getDomains(String method, String idKey, String idValue, Date date, int perPage, int page) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", method);
        parameters.put(""date"", String.valueOf(date.getTime() / 1000L));
        if (idValue != null) {
            parameters.put(idKey, idValue);
        }
        addPaginationParameters(parameters, perPage, page);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        DomainList domains = parseDomains(response);

        return domains;
    }

    private DomainList parseDomains(Response response) {

        Element element = response.getPayload();
        DomainList domains = new DomainList();
        domains.setPage(element.getAttribute(""page""));
        domains.setPages(element.getAttribute(""pages""));
        domains.setPerPage(element.getAttribute(""perpage""));
        domains.setTotal(element.getAttribute(""total""));

        NodeList domainElements = element.getElementsByTagName(""domain"");
        for (int i = 0; i < domainElements.getLength(); i++) {
            Element domainElement = (Element) domainElements.item(i);
            Domain domain = new Domain();
            domain.setName(domainElement.getAttribute(""name""));
            domain.setViews(domainElement.getAttribute(""views""));
            domains.add(domain);
        }

        return domains;
    }

    private ReferrerList getReferrers(String method, String domain, String idKey, String idValue, Date date, int perPage, int page) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", method);
        parameters.put(""domain"", domain);
        parameters.put(""date"", String.valueOf(date.getTime() / 1000L));
        if (idValue != null) {
            parameters.put(idKey, idValue);
        }
        addPaginationParameters(parameters, perPage, page);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        ReferrerList referrers = parseReferrers(response);

        return referrers;
    }

    private ReferrerList parseReferrers(Response response) {

        Element element = response.getPayload();
        ReferrerList referrers = new ReferrerList();
        referrers.setPage(element.getAttribute(""page""));
        referrers.setPages(element.getAttribute(""pages""));
        referrers.setPerPage(element.getAttribute(""perpage""));
        referrers.setTotal(element.getAttribute(""total""));
        referrers.setName(element.getAttribute(""name""));

        NodeList referrerElements = element.getElementsByTagName(""referrer"");
        for (int i = 0; i < referrerElements.getLength(); i++) {
            Element referrerElement = (Element) referrerElements.item(i);
            Referrer referrer = new Referrer();
            referrer.setUrl(referrerElement.getAttribute(""url""));
            referrer.setViews(referrerElement.getAttribute(""views""));
            referrers.add(referrer);
        }

        return referrers;
    }

    private Stats getStats(String method, String idKey, String idValue, Date date) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", method);
        parameters.put(""date"", String.valueOf(date.getTime() / 1000L));
        if (idValue != null) {
            parameters.put(idKey, idValue);
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Stats stats = parseStats(response.getPayload());

        return stats;
    }

    /**
     * 
     * @param element
     */
    private Stats parseStats(Element element) {
        Stats stats = new Stats();
        String views = element.getAttribute(""views"");
        String comments = element.getAttribute(""comments"");
        String favorites = element.getAttribute(""favorites"");

        stats.setViews(views);
        stats.setComments(comments);
        stats.setFavorites(favorites);

        return stats;
    }

    private Totals parseTotals(Response response) {
        Element element = response.getPayload();

        Totals stats = new Totals();

        NodeList childNodes = element.getChildNodes();
        for (int i = 0; i < childNodes.getLength(); i++) {

            Node node = childNodes.item(i);
            if (node.getNodeType() == Node.ELEMENT_NODE) {
                Element childElement = (Element) node;
                String total = getViewsValue(childElement, ""total"");
                if (total != null) {
                    stats.setTotal(total);
                }

                String photos = getViewsValue(childElement, ""photos"");
                if (photos != null) {
                    stats.setPhotos(photos);
                }

                String photostream = getViewsValue(childElement, ""photostream"");
                if (photostream != null) {
                    stats.setPhotostream(photostream);
                }

                String collections = getViewsValue(childElement, ""collections"");
                if (collections != null) {
                    stats.setCollections(collections);
                }

                String sets = getViewsValue(childElement, ""sets"");
                if (sets != null) {
                    stats.setSets(sets);
                }
            }
        }

        return stats;
    }

    private String getViewsValue(Element childElement, String name) {
        String total = null;
        if (childElement.getNodeName().equals(name)) {
            total = childElement.getAttribute(""views"");
        }

        return total;
    }

    private void addPaginationParameters(Map<String, Object> parameters, int perPage, int page) {
        if (perPage > 0) {
            parameters.put(""per_page"", String.valueOf(perPage));
        }
        if (page > 0) {
            parameters.put(""page"", String.valueOf(page));
        }
    }

    private List<Csv> parseCsvFiles(Response response) {
        Element element = response.getPayload();

        List<Csv> csvFiles = new ArrayList<Csv>();
        SimpleDateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd"");

        NodeList csvElements = element.getElementsByTagName(""csv"");
        for (int i = 0; i < csvElements.getLength(); i++) {
            Element csvElement = (Element) csvElements.item(i);
            Csv csv = new Csv();
            csv.setHref(csvElement.getAttribute(""href""));
            csv.setType(csvElement.getAttribute(""type""));
            try {
                csv.setDate(dateFormat.parse(csvElement.getAttribute(""date"")));
            } catch (ParseException e) {
                throw new FlickrRuntimeException(e);
            }

            csvFiles.add(csv);
        }
        return csvFiles;
    }

    /**
     * 
     * @param response
     */
    private PhotoList<Photo> parsePopularPhotos(Response response) {

        Element payload = response.getPayload();
        PhotoList<Photo> photos = new PhotoList<Photo>();

        NodeList photoElements = payload.getElementsByTagName(""photo"");
        for (int i = 0; i < photoElements.getLength(); i++) {
            Element photoElement = (Element) photoElements.item(i);
            Photo photo = PhotoUtils.createPhoto(photoElement);

            Element statsElement = XMLUtilities.getChild(photoElement, ""stats"");
            Stats stats = parseStats(statsElement);
            photo.setStats(stats);

            photos.add(photo);
        }

        return photos;
    }

}
","package com.flickr4java.flickr.stats; public class StatsInterface { @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(StatsInterface.class); private static final String METHOD_GET_COLLECTION_DOMAINS = ""flickr.stats.getCollectionDomains""; private static final String METHOD_GET_COLLECTION_REFERRERS = ""flickr.stats.getCollectionReferrers""; private static final String METHOD_GET_COLLECTION_STATS = ""flickr.stats.getCollectionStats""; private static final String METHOD_GET_CSV_FILES = ""flickr.stats.getCSVFiles""; private static final String METHOD_GET_PHOTO_DOMAINS = ""flickr.stats.getPhotoDomains""; private static final String METHOD_GET_PHOTO_REFERRERS = ""flickr.stats.getPhotoReferrers""; private static final String METHOD_GET_PHOTO_STATS = ""flickr.stats.getPhotoStats""; private static final String METHOD_GET_PHOTOSET_DOMAINS = ""flickr.stats.getPhotosetDomains""; private static final String METHOD_GET_PHOTOSET_REFERRERS = ""flickr.stats.getPhotosetReferrers""; private static final String METHOD_GET_PHOTOSET_STATS = ""flickr.stats.getPhotosetStats""; private static final String METHOD_GET_PHOTOSTREAM_DOMAINS = ""flickr.stats.getPhotostreamDomains""; private static final String METHOD_GET_PHOTOSTREAM_REFERRERS = ""flickr.stats.getPhotostreamReferrers""; private static final String METHOD_GET_PHOTOSTREAM_STATS = ""flickr.stats.getPhotostreamStats""; private static final String METHOD_GET_POPULAR_PHOTOS = ""flickr.stats.getPopularPhotos""; private static final String METHOD_GET_TOTAL_VIEWS = ""flickr.stats.getTotalViews""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public StatsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public DomainList getCollectionDomains(Date date, String collectionId, int perPage, int page) throws FlickrException { return getDomains(METHOD_GET_COLLECTION_DOMAINS, ""collection_id"", collectionId, date, perPage, page); } public ReferrerList getCollectionReferrers(Date date, String domain, String collectionId, int perPage, int page) throws FlickrException { return getReferrers(METHOD_GET_COLLECTION_REFERRERS, domain, ""collection_id"", collectionId, date, perPage, page); } public Stats getCollectionStats(String collectionId, Date date) throws FlickrException { return getStats(METHOD_GET_COLLECTION_STATS, ""collection_id"", collectionId, date); } public List<Csv> getCSVFiles() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CSV_FILES); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } List<Csv> csvFiles = parseCsvFiles(response); return csvFiles; } public DomainList getPhotoDomains(Date date, String photoId, int perPage, int page) throws FlickrException { return getDomains(METHOD_GET_PHOTO_DOMAINS, ""photo_id"", photoId, date, perPage, page); } public ReferrerList getPhotoReferrers(Date date, String domain, String photoId, int perPage, int page) throws FlickrException { return getReferrers(METHOD_GET_PHOTO_REFERRERS, domain, ""photo_id"", photoId, date, perPage, page); } public Stats getPhotoStats(String photoId, Date date) throws FlickrException { return getStats(METHOD_GET_PHOTO_STATS, ""photo_id"", photoId, date); } public DomainList getPhotosetDomains(Date date, String photosetId, int perPage, int page) throws FlickrException { return getDomains(METHOD_GET_PHOTOSET_DOMAINS, ""photoset_id"", photosetId, date, perPage, page); } public ReferrerList getPhotosetReferrers(Date date, String domain, String photosetId, int perPage, int page) throws FlickrException { return getReferrers(METHOD_GET_PHOTOSET_REFERRERS, domain, ""photoset_id"", photosetId, date, perPage, page); } public Stats getPhotosetStats(String photosetId, Date date) throws FlickrException { return getStats(METHOD_GET_PHOTOSET_STATS, ""photoset_id"", photosetId, date); } public DomainList getPhotostreamDomains(Date date, int perPage, int page) throws FlickrException { return getDomains(METHOD_GET_PHOTOSTREAM_DOMAINS, null, null, date, perPage, page); } public ReferrerList getPhotostreamReferrers(Date date, String domain, int perPage, int page) throws FlickrException { return getReferrers(METHOD_GET_PHOTOSTREAM_REFERRERS, domain, null, null, date, perPage, page); } public Stats getPhotostreamStats(Date date) throws FlickrException { return getStats(METHOD_GET_PHOTOSTREAM_STATS, null, null, date); } public PhotoList<Photo> getPopularPhotos(Date date, StatsSort sort, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_POPULAR_PHOTOS); if (date != null) { parameters.put(""date"", String.valueOf(date.getTime() / 1000L)); } if (sort != null) { parameters.put(""sort"", sort.name()); } addPaginationParameters(parameters, perPage, page); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } return parsePopularPhotos(response); } public Totals getTotalViews(Date date) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_TOTAL_VIEWS); if (date != null) { parameters.put(""date"", String.valueOf(date.getTime() / 1000L)); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Totals totals = parseTotals(response); return totals; } private DomainList getDomains(String method, String idKey, String idValue, Date date, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", method); parameters.put(""date"", String.valueOf(date.getTime() / 1000L)); if (idValue != null) { parameters.put(idKey, idValue); } addPaginationParameters(parameters, perPage, page); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } DomainList domains = parseDomains(response); return domains; } private DomainList parseDomains(Response response) { Element element = response.getPayload(); DomainList domains = new DomainList(); domains.setPage(element.getAttribute(""page"")); domains.setPages(element.getAttribute(""pages"")); domains.setPerPage(element.getAttribute(""perpage"")); domains.setTotal(element.getAttribute(""total"")); NodeList domainElements = element.getElementsByTagName(""domain""); for (int i = 0; i < domainElements.getLength(); i++) { Element domainElement = (Element) domainElements.item(i); Domain domain = new Domain(); domain.setName(domainElement.getAttribute(""name"")); domain.setViews(domainElement.getAttribute(""views"")); domains.add(domain); } return domains; } private ReferrerList getReferrers(String method, String domain, String idKey, String idValue, Date date, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", method); parameters.put(""domain"", domain); parameters.put(""date"", String.valueOf(date.getTime() / 1000L)); if (idValue != null) { parameters.put(idKey, idValue); } addPaginationParameters(parameters, perPage, page); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } ReferrerList referrers = parseReferrers(response); return referrers; } private ReferrerList parseReferrers(Response response) { Element element = response.getPayload(); ReferrerList referrers = new ReferrerList(); referrers.setPage(element.getAttribute(""page"")); referrers.setPages(element.getAttribute(""pages"")); referrers.setPerPage(element.getAttribute(""perpage"")); referrers.setTotal(element.getAttribute(""total"")); referrers.setName(element.getAttribute(""name"")); NodeList referrerElements = element.getElementsByTagName(""referrer""); for (int i = 0; i < referrerElements.getLength(); i++) { Element referrerElement = (Element) referrerElements.item(i); Referrer referrer = new Referrer(); referrer.setUrl(referrerElement.getAttribute(""url"")); referrer.setViews(referrerElement.getAttribute(""views"")); referrers.add(referrer); } return referrers; } private Stats getStats(String method, String idKey, String idValue, Date date) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", method); parameters.put(""date"", String.valueOf(date.getTime() / 1000L)); if (idValue != null) { parameters.put(idKey, idValue); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Stats stats = parseStats(response.getPayload()); return stats; } private Stats parseStats(Element element) { Stats stats = new Stats(); String views = element.getAttribute(""views""); String comments = element.getAttribute(""comments""); String favorites = element.getAttribute(""favorites""); stats.setViews(views); stats.setComments(comments); stats.setFavorites(favorites); return stats; } private Totals parseTotals(Response response) { Element element = response.getPayload(); Totals stats = new Totals(); NodeList childNodes = element.getChildNodes(); for (int i = 0; i < childNodes.getLength(); i++) { Node node = childNodes.item(i); if (node.getNodeType() == Node.ELEMENT_NODE) { Element childElement = (Element) node; String total = getViewsValue(childElement, ""total""); if (total != null) { stats.setTotal(total); } String photos = getViewsValue(childElement, ""photos""); if (photos != null) { stats.setPhotos(photos); } String photostream = getViewsValue(childElement, ""photostream""); if (photostream != null) { stats.setPhotostream(photostream); } String collections = getViewsValue(childElement, ""collections""); if (collections != null) { stats.setCollections(collections); } String sets = getViewsValue(childElement, ""sets""); if (sets != null) { stats.setSets(sets); } } } return stats; } private String getViewsValue(Element childElement, String name) { String total = null; if (childElement.getNodeName().equals(name)) { total = childElement.getAttribute(""views""); } return total; } private void addPaginationParameters(Map<String, Object> parameters, int perPage, int page) { if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); } } private List<Csv> parseCsvFiles(Response response) { Element element = response.getPayload(); List<Csv> csvFiles = new ArrayList<Csv>(); SimpleDateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd""); NodeList csvElements = element.getElementsByTagName(""csv""); for (int i = 0; i < csvElements.getLength(); i++) { Element csvElement = (Element) csvElements.item(i); Csv csv = new Csv(); csv.setHref(csvElement.getAttribute(""href"")); csv.setType(csvElement.getAttribute(""type"")); try { csv.setDate(dateFormat.parse(csvElement.getAttribute(""date""))); } catch (ParseException e) { throw new FlickrRuntimeException(e); } csvFiles.add(csv); } return csvFiles; } private PhotoList<Photo> parsePopularPhotos(Response response) { Element payload = response.getPayload(); PhotoList<Photo> photos = new PhotoList<Photo>(); NodeList photoElements = payload.getElementsByTagName(""photo""); for (int i = 0; i < photoElements.getLength(); i++) { Element photoElement = (Element) photoElements.item(i); Photo photo = PhotoUtils.createPhoto(photoElement); Element statsElement = XMLUtilities.getChild(photoElement, ""stats""); Stats stats = parseStats(statsElement); photo.setStats(stats); photos.add(photo); } return photos; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.stats; public class StatsInterface { @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(StatsInterface.class); private static final String METHOD_GET_COLLECTION_DOMAINS = ""flickr.stats.getCollectionDomains""; private static final String METHOD_GET_COLLECTION_REFERRERS = ""flickr.stats.getCollectionReferrers""; private static final String METHOD_GET_COLLECTION_STATS = ""flickr.stats.getCollectionStats""; private static final String METHOD_GET_CSV_FILES = ""flickr.stats.getCSVFiles""; private static final String METHOD_GET_PHOTO_DOMAINS = ""flickr.stats.getPhotoDomains""; private static final String METHOD_GET_PHOTO_REFERRERS = ""flickr.stats.getPhotoReferrers""; private static final String METHOD_GET_PHOTO_STATS = ""flickr.stats.getPhotoStats""; private static final String METHOD_GET_PHOTOSET_DOMAINS = ""flickr.stats.getPhotosetDomains""; private static final String METHOD_GET_PHOTOSET_REFERRERS = ""flickr.stats.getPhotosetReferrers""; private static final String METHOD_GET_PHOTOSET_STATS = ""flickr.stats.getPhotosetStats""; private static final String METHOD_GET_PHOTOSTREAM_DOMAINS = ""flickr.stats.getPhotostreamDomains""; private static final String METHOD_GET_PHOTOSTREAM_REFERRERS = ""flickr.stats.getPhotostreamReferrers""; private static final String METHOD_GET_PHOTOSTREAM_STATS = ""flickr.stats.getPhotostreamStats""; private static final String METHOD_GET_POPULAR_PHOTOS = ""flickr.stats.getPopularPhotos""; private static final String METHOD_GET_TOTAL_VIEWS = ""flickr.stats.getTotalViews""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public StatsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public DomainList getCollectionDomains(Date date, String collectionId, int perPage, int page) throws FlickrException { return getDomains(METHOD_GET_COLLECTION_DOMAINS, ""collection_id"", collectionId, date, perPage, page); } public ReferrerList getCollectionReferrers(Date date, String domain, String collectionId, int perPage, int page) throws FlickrException { return getReferrers(METHOD_GET_COLLECTION_REFERRERS, domain, ""collection_id"", collectionId, date, perPage, page); } public Stats getCollectionStats(String collectionId, Date date) throws FlickrException { return getStats(METHOD_GET_COLLECTION_STATS, ""collection_id"", collectionId, date); } public List<Csv> getCSVFiles() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CSV_FILES); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } List<Csv> csvFiles = parseCsvFiles(response); return csvFiles; } public DomainList getPhotoDomains(Date date, String photoId, int perPage, int page) throws FlickrException { return getDomains(METHOD_GET_PHOTO_DOMAINS, ""photo_id"", photoId, date, perPage, page); } public ReferrerList getPhotoReferrers(Date date, String domain, String photoId, int perPage, int page) throws FlickrException { return getReferrers(METHOD_GET_PHOTO_REFERRERS, domain, ""photo_id"", photoId, date, perPage, page); } public Stats getPhotoStats(String photoId, Date date) throws FlickrException { return getStats(METHOD_GET_PHOTO_STATS, ""photo_id"", photoId, date); } public DomainList getPhotosetDomains(Date date, String photosetId, int perPage, int page) throws FlickrException { return getDomains(METHOD_GET_PHOTOSET_DOMAINS, ""photoset_id"", photosetId, date, perPage, page); } public ReferrerList getPhotosetReferrers(Date date, String domain, String photosetId, int perPage, int page) throws FlickrException { return getReferrers(METHOD_GET_PHOTOSET_REFERRERS, domain, ""photoset_id"", photosetId, date, perPage, page); } public Stats getPhotosetStats(String photosetId, Date date) throws FlickrException { return getStats(METHOD_GET_PHOTOSET_STATS, ""photoset_id"", photosetId, date); } public DomainList getPhotostreamDomains(Date date, int perPage, int page) throws FlickrException { return getDomains(METHOD_GET_PHOTOSTREAM_DOMAINS, null, null, date, perPage, page); } public ReferrerList getPhotostreamReferrers(Date date, String domain, int perPage, int page) throws FlickrException { return getReferrers(METHOD_GET_PHOTOSTREAM_REFERRERS, domain, null, null, date, perPage, page); } public Stats getPhotostreamStats(Date date) throws FlickrException { return getStats(METHOD_GET_PHOTOSTREAM_STATS, null, null, date); } public PhotoList<Photo> getPopularPhotos(Date date, StatsSort sort, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_POPULAR_PHOTOS); if (date != null) { parameters.put(""date"", String.valueOf(date.getTime() / 1000L)); } if (sort != null) { parameters.put(""sort"", sort.name()); } addPaginationParameters(parameters, perPage, page); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } return parsePopularPhotos(response); } public Totals getTotalViews(Date date) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_TOTAL_VIEWS); if (date != null) { parameters.put(""date"", String.valueOf(date.getTime() / 1000L)); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Totals totals = parseTotals(response); return totals; } private DomainList getDomains(String method, String idKey, String idValue, Date date, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", method); parameters.put(""date"", String.valueOf(date.getTime() / 1000L)); if (idValue != null) { parameters.put(idKey, idValue); } addPaginationParameters(parameters, perPage, page); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } DomainList domains = parseDomains(response); return domains; } private DomainList parseDomains(Response response) { Element element = response.getPayload(); DomainList domains = new DomainList(); domains.setPage(element.getAttribute(""page"")); domains.setPages(element.getAttribute(""pages"")); domains.setPerPage(element.getAttribute(""perpage"")); domains.setTotal(element.getAttribute(""total"")); NodeList domainElements = element.getElementsByTagName(""domain""); for (int i = 0; i < domainElements.getLength(); i++) { Element domainElement = (Element) domainElements.item(i); Domain domain = new Domain(); domain.setName(domainElement.getAttribute(""name"")); domain.setViews(domainElement.getAttribute(""views"")); domains.add(domain); } return domains; } private ReferrerList getReferrers(String method, String domain, String idKey, String idValue, Date date, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", method); parameters.put(""domain"", domain); parameters.put(""date"", String.valueOf(date.getTime() / 1000L)); if (idValue != null) { parameters.put(idKey, idValue); } addPaginationParameters(parameters, perPage, page); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } ReferrerList referrers = parseReferrers(response); return referrers; } private ReferrerList parseReferrers(Response response) { Element element = response.getPayload(); ReferrerList referrers = new ReferrerList(); referrers.setPage(element.getAttribute(""page"")); referrers.setPages(element.getAttribute(""pages"")); referrers.setPerPage(element.getAttribute(""perpage"")); referrers.setTotal(element.getAttribute(""total"")); referrers.setName(element.getAttribute(""name"")); NodeList referrerElements = element.getElementsByTagName(""referrer""); for (int i = 0; i < referrerElements.getLength(); i++) { Element referrerElement = (Element) referrerElements.item(i); Referrer referrer = new Referrer(); referrer.setUrl(referrerElement.getAttribute(""url"")); referrer.setViews(referrerElement.getAttribute(""views"")); referrers.add(referrer); } return referrers; } private Stats getStats(String method, String idKey, String idValue, Date date) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", method); parameters.put(""date"", String.valueOf(date.getTime() / 1000L)); if (idValue != null) { parameters.put(idKey, idValue); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Stats stats = parseStats(response.getPayload()); return stats; } private Stats parseStats(Element element) { Stats stats = new Stats(); String views = element.getAttribute(""views""); String comments = element.getAttribute(""comments""); String favorites = element.getAttribute(""favorites""); stats.setViews(views); stats.setComments(comments); stats.setFavorites(favorites); return stats; } private Totals parseTotals(Response response) { Element element = response.getPayload(); Totals stats = new Totals(); NodeList childNodes = element.getChildNodes(); for (int i = 0; i < childNodes.getLength(); i++) { Node node = childNodes.item(i); if (node.getNodeType() == Node.ELEMENT_NODE) { Element childElement = (Element) node; String total = getViewsValue(childElement, ""total""); if (total != null) { stats.setTotal(total); } String photos = getViewsValue(childElement, ""photos""); if (photos != null) { stats.setPhotos(photos); } String photostream = getViewsValue(childElement, ""photostream""); if (photostream != null) { stats.setPhotostream(photostream); } String collections = getViewsValue(childElement, ""collections""); if (collections != null) { stats.setCollections(collections); } String sets = getViewsValue(childElement, ""sets""); if (sets != null) { stats.setSets(sets); } } } return stats; } private String getViewsValue(Element childElement, String name) { String total = null; if (childElement.getNodeName().equals(name)) { total = childElement.getAttribute(""views""); } return total; } private void addPaginationParameters(Map<String, Object> parameters, int perPage, int page) { if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); } } private List<Csv> parseCsvFiles(Response response) { Element element = response.getPayload(); List<Csv> csvFiles = new ArrayList<Csv>(); SimpleDateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd""); NodeList csvElements = element.getElementsByTagName(""csv""); for (int i = 0; i < csvElements.getLength(); i++) { Element csvElement = (Element) csvElements.item(i); Csv csv = new Csv(); csv.setHref(csvElement.getAttribute(""href"")); csv.setType(csvElement.getAttribute(""type"")); try { csv.setDate(dateFormat.parse(csvElement.getAttribute(""date""))); } catch (ParseException e) { throw new FlickrRuntimeException(e); } csvFiles.add(csv); } return csvFiles; } private PhotoList<Photo> parsePopularPhotos(Response response) { Element payload = response.getPayload(); PhotoList<Photo> photos = new PhotoList<Photo>(); NodeList photoElements = payload.getElementsByTagName(""photo""); for (int i = 0; i < photoElements.getLength(); i++) { Element photoElement = (Element) photoElements.item(i); Photo photo = PhotoUtils.createPhoto(photoElement); Element statsElement = XMLUtilities.getChild(photoElement, ""stats""); Stats stats = parseStats(statsElement); photo.setStats(stats); photos.add(photo); } return photos; } } ","package com.flickr4java.flickr.stats; 
import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.FlickrRuntimeException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.util.XMLUtilities; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.w3c.dom.Element; import org.w3c.dom.Node; import org.w3c.dom.NodeList; 
import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map;  /**
 * Interface to the Stats API.
 * 
 * @author Darren Greaves
 * @version $Id$ Copyright (c) 2012 Darren Greaves.
 */ public class StatsInterface {  /**
     * Logger.
     */ @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(StatsInterface.class);  private static final String METHOD_GET_COLLECTION_DOMAINS = ""flickr.stats.getCollectionDomains"";  private static final String METHOD_GET_COLLECTION_REFERRERS = ""flickr.stats.getCollectionReferrers"";  private static final String METHOD_GET_COLLECTION_STATS = ""flickr.stats.getCollectionStats"";  private static final String METHOD_GET_CSV_FILES = ""flickr.stats.getCSVFiles"";  private static final String METHOD_GET_PHOTO_DOMAINS = ""flickr.stats.getPhotoDomains"";  private static final String METHOD_GET_PHOTO_REFERRERS = ""flickr.stats.getPhotoReferrers"";  private static final String METHOD_GET_PHOTO_STATS = ""flickr.stats.getPhotoStats"";  private static final String METHOD_GET_PHOTOSET_DOMAINS = ""flickr.stats.getPhotosetDomains"";  private static final String METHOD_GET_PHOTOSET_REFERRERS = ""flickr.stats.getPhotosetReferrers"";  private static final String METHOD_GET_PHOTOSET_STATS = ""flickr.stats.getPhotosetStats"";  private static final String METHOD_GET_PHOTOSTREAM_DOMAINS = ""flickr.stats.getPhotostreamDomains"";  private static final String METHOD_GET_PHOTOSTREAM_REFERRERS = ""flickr.stats.getPhotostreamReferrers"";  private static final String METHOD_GET_PHOTOSTREAM_STATS = ""flickr.stats.getPhotostreamStats"";  private static final String METHOD_GET_POPULAR_PHOTOS = ""flickr.stats.getPopularPhotos"";  private static final String METHOD_GET_TOTAL_VIEWS = ""flickr.stats.getTotalViews"";  private final String apiKey;  private final String sharedSecret;  private final Transport transportAPI;  public StatsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; }  /**
     * Get a list of referring domains for a collection.
     * 
     * @param date
     *            (Required) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day.
     * @param collectionId
     *            (Optional) The id of the collection to get stats for. If not provided, stats for all collections will be returned.
     * @param perPage
     *            (Optional) Number of domains to return per page. If this argument is omitted, it defaults to 25. The maximum allowed value is 100.
     * @param page
     *            (Optional) The page of results to return. If this argument is omitted, it defaults to 1.
     * @see ""http://www.flickr.com/services/api/flickr.stats.getCollectionDomains.html""
     */ public DomainList getCollectionDomains(Date date, String collectionId, int perPage, int page) throws FlickrException { return getDomains(METHOD_GET_COLLECTION_DOMAINS, ""collection_id"", collectionId, date, perPage, page); }  /**
     * Get a list of referrers from a given domain to a collection.
     * 
     * @param date
     *            (Required) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day.
     * @param domain
     *            (Required) The domain to return referrers for. This should be a hostname (eg: ""flickr.com"") with no protocol or pathname.
     * @param collectionId
     *            (Optional) The id of the collection to get stats for. If not provided, stats for all collections will be returned.
     * @param perPage
     *            (Optional) Number of domains to return per page. If this argument is omitted, it defaults to 25. The maximum allowed value is 100.
     * @param page
     *            (Optional) The page of results to return. If this argument is omitted, it defaults to 1.
     * @see ""http://www.flickr.com/services/api/flickr.stats.getCollectionReferrers.html""
     */ public ReferrerList getCollectionReferrers(Date date, String domain, String collectionId, int perPage, int page) throws FlickrException { return getReferrers(METHOD_GET_COLLECTION_REFERRERS, domain, ""collection_id"", collectionId, date, perPage, page); }  /**
     * Get the number of views, comments and favorites on a collection for a given date.
     * 
     * @param date
     *            (Required) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day.
     * @param collectionId
     *            (Required) The id (from the URL!) of the collection to get stats for.
     * @see ""http://www.flickr.com/services/api/flickr.stats.getCollectionStats.htm""
     */ public Stats getCollectionStats(String collectionId, Date date) throws FlickrException { return getStats(METHOD_GET_COLLECTION_STATS, ""collection_id"", collectionId, date); }  /**
     * Returns a list of URLs for text files containing all your stats data (from November 26th 2007 onwards) for the currently auth'd user.
     * 
     * @throws FlickrException if there was a problem connecting to Flickr
     * 
     * @see ""http://www.flickr.com/services/api/flickr.stats.getCSVFiles.html""
     */ public List<Csv> getCSVFiles() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CSV_FILES);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  List<Csv> csvFiles = parseCsvFiles(response);  return csvFiles; }  /**
     * Get a list of referring domains for a photo.
     * 
     * @param date
     *            (Required) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day.
     * @param photoId
     *            (Optional) The id of the photo to get stats for. If not provided, stats for all photos will be returned.
     * @param perPage
     *            (Optional) Number of domains to return per page. If this argument is omitted, it defaults to 25. The maximum allowed value is 100.
     * @param page
     *            (Optional) The page of results to return. If this argument is omitted, it defaults to 1.
     * @see ""http://www.flickr.com/services/api/flickr.stats.getPhotoDomains.html""
     */ public DomainList getPhotoDomains(Date date, String photoId, int perPage, int page) throws FlickrException { return getDomains(METHOD_GET_PHOTO_DOMAINS, ""photo_id"", photoId, date, perPage, page); }  /**
     * Get a list of referrers from a given domain to a photo.
     * 
     * @param date
     *            (Required) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day.
     * @param domain
     *            (Required) The domain to return referrers for. This should be a hostname (eg: ""flickr.com"") with no protocol or pathname.
     * @param photoId
     *            (Optional) The id of the photo to get stats for. If not provided, stats for all photos will be returned.
     * @param perPage
     *            (Optional) Number of domains to return per page. If this argument is omitted, it defaults to 25. The maximum allowed value is 100.
     * @param page
     *            (Optional) The page of results to return. If this argument is omitted, it defaults to 1.
     * @see ""http://www.flickr.com/services/api/flickr.stats.getPhotoReferrers.html""
     */ public ReferrerList getPhotoReferrers(Date date, String domain, String photoId, int perPage, int page) throws FlickrException { return getReferrers(METHOD_GET_PHOTO_REFERRERS, domain, ""photo_id"", photoId, date, perPage, page); }  /**
     * Get the number of views, comments and favorites on a photo for a given date.
     * 
     * @param date
     *            (Required) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day.
     * @param photoId
     *            (Required) The id of the photo to get stats for.
     * @see ""http://www.flickr.com/services/api/flickr.stats.getPhotoStats.htm""
     */ public Stats getPhotoStats(String photoId, Date date) throws FlickrException { return getStats(METHOD_GET_PHOTO_STATS, ""photo_id"", photoId, date); }  /**
     * Get a list of referring domains for a photoset.
     * 
     * @param date
     *            (Required) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day.
     * @param photosetId
     *            (Optional) The id of the photoset to get stats for. If not provided, stats for all photos will be returned.
     * @param perPage
     *            (Optional) Number of domains to return per page. If this argument is omitted, it defaults to 25. The maximum allowed value is 100.
     * @param page
     *            (Optional) The page of results to return. If this argument is omitted, it defaults to 1.
     * @see ""http://www.flickr.com/services/api/flickr.stats.getPhotosetDomains.html""
     */ public DomainList getPhotosetDomains(Date date, String photosetId, int perPage, int page) throws FlickrException { return getDomains(METHOD_GET_PHOTOSET_DOMAINS, ""photoset_id"", photosetId, date, perPage, page); }  /**
     * Get a list of referrers from a given domain to a photoset.
     * 
     * @param date
     *            (Required) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day.
     * @param domain
     *            (Required) The domain to return referrers for. This should be a hostname (eg: ""flickr.com"") with no protocol or pathname.
     * @param photosetId
     *            (Optional) The id of the photoset to get stats for. If not provided, stats for all sets will be returned.
     * @param perPage
     *            (Optional) Number of domains to return per page. If this argument is omitted, it defaults to 25. The maximum allowed value is 100.
     * @param page
     *            (Optional) The page of results to return. If this argument is omitted, it defaults to 1.
     * @see ""http://www.flickr.com/services/api/flickr.stats.getPhotosetReferrers.html""
     */ public ReferrerList getPhotosetReferrers(Date date, String domain, String photosetId, int perPage, int page) throws FlickrException { return getReferrers(METHOD_GET_PHOTOSET_REFERRERS, domain, ""photoset_id"", photosetId, date, perPage, page); }  /**
     * Get the number of views, comments and favorites on a photoset for a given date.
     * 
     * @param date
     *            (Required) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day.
     * @param photosetId
     *            (Required) The id of the photoset to get stats for.
     * @see ""http://www.flickr.com/services/api/flickr.stats.getPhotosetStats.htm""
     */ public Stats getPhotosetStats(String photosetId, Date date) throws FlickrException { return getStats(METHOD_GET_PHOTOSET_STATS, ""photoset_id"", photosetId, date); }  /**
     * Get a list of referring domains for a photostream.
     * 
     * @param date
     *            (Required) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day.
     * @param perPage
     *            (Optional) Number of domains to return per page. If this argument is omitted, it defaults to 25. The maximum allowed value is 100.
     * @param page
     *            (Optional) The page of results to return. If this argument is omitted, it defaults to 1.
     * @see ""http://www.flickr.com/services/api/flickr.stats.getPhotostreamDomains.html""
     */ public DomainList getPhotostreamDomains(Date date, int perPage, int page) throws FlickrException { return getDomains(METHOD_GET_PHOTOSTREAM_DOMAINS, null, null, date, perPage, page);  }  /**
     * Get a list of referrers from a given domain to a user's photostream.
     * 
     * @param date
     *            (Required) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day.
     * @param domain
     *            (Required) The domain to return referrers for. This should be a hostname (eg: ""flickr.com"") with no protocol or pathname.
     * @param perPage
     *            (Optional) Number of domains to return per page. If this argument is omitted, it defaults to 25. The maximum allowed value is 100.
     * @param page
     *            (Optional) The page of results to return. If this argument is omitted, it defaults to 1.
     * @see ""http://www.flickr.com/services/api/flickr.stats.getPhotostreamReferrers.html""
     */ public ReferrerList getPhotostreamReferrers(Date date, String domain, int perPage, int page) throws FlickrException { return getReferrers(METHOD_GET_PHOTOSTREAM_REFERRERS, domain, null, null, date, perPage, page); }  /**
     * Get the number of views, comments and favorites on a photostream for a given date.
     * 
     * @param date
     *            (Required) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day.
     * @see ""http://www.flickr.com/services/api/flickr.stats.getPhotostreamStats.htm""
     */ public Stats getPhotostreamStats(Date date) throws FlickrException { return getStats(METHOD_GET_PHOTOSTREAM_STATS, null, null, date); }  /**
     * List the photos with the most views, comments or favorites.
     * 
     * @param date
     *            (Optional) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day. If no date is provided, all time view counts will be returned.
     * @param sort
     *            (Optional) The order in which to sort returned photos. Defaults to views. The possible values are views, comments and favorites. Other sort
     *            options are available through flickr.photos.search.
     * @param perPage
     *            (Optional) Number of referrers to return per page. If this argument is omitted, it defaults to 25. The maximum allowed value is 100.
     * @param page
     *            (Optional) The page of results to return. If this argument is omitted, it defaults to 1.
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see ""http://www.flickr.com/services/api/flickr.stats.getPopularPhotos.html""
     */ public PhotoList<Photo> getPopularPhotos(Date date, StatsSort sort, int perPage, int page) throws FlickrException {  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_POPULAR_PHOTOS); if (date != null) { parameters.put(""date"", String.valueOf(date.getTime() / 1000L)); } if (sort != null) { parameters.put(""sort"", sort.name()); } addPaginationParameters(parameters, perPage, page);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  return parsePopularPhotos(response); }  /**
     * Get the overall view counts for an account
     * 
     * @param date
     *            (Optional) Stats will be returned for this date. A day according to Flickr Stats starts at midnight GMT for all users, and timestamps will
     *            automatically be rounded down to the start of the day. If no date is provided, all time view counts will be returned.
     * @throws FlickrException if there was a problem connecting to Flickr
     * 
     * @see ""http://www.flickr.com/services/api/flickr.stats.getTotalViews.html""
     */ public Totals getTotalViews(Date date) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_TOTAL_VIEWS); if (date != null) { parameters.put(""date"", String.valueOf(date.getTime() / 1000L)); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Totals totals = parseTotals(response);  return totals; }  private DomainList getDomains(String method, String idKey, String idValue, Date date, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", method); parameters.put(""date"", String.valueOf(date.getTime() / 1000L)); if (idValue != null) { parameters.put(idKey, idValue); } addPaginationParameters(parameters, perPage, page);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  DomainList domains = parseDomains(response);  return domains; }  private DomainList parseDomains(Response response) {  Element element = response.getPayload(); DomainList domains = new DomainList(); domains.setPage(element.getAttribute(""page"")); domains.setPages(element.getAttribute(""pages"")); domains.setPerPage(element.getAttribute(""perpage"")); domains.setTotal(element.getAttribute(""total""));  NodeList domainElements = element.getElementsByTagName(""domain""); for (int i = 0; i < domainElements.getLength(); i++) { Element domainElement = (Element) domainElements.item(i); Domain domain = new Domain(); domain.setName(domainElement.getAttribute(""name"")); domain.setViews(domainElement.getAttribute(""views"")); domains.add(domain); }  return domains; }  private ReferrerList getReferrers(String method, String domain, String idKey, String idValue, Date date, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", method); parameters.put(""domain"", domain); parameters.put(""date"", String.valueOf(date.getTime() / 1000L)); if (idValue != null) { parameters.put(idKey, idValue); } addPaginationParameters(parameters, perPage, page);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  ReferrerList referrers = parseReferrers(response);  return referrers; }  private ReferrerList parseReferrers(Response response) {  Element element = response.getPayload(); ReferrerList referrers = new ReferrerList(); referrers.setPage(element.getAttribute(""page"")); referrers.setPages(element.getAttribute(""pages"")); referrers.setPerPage(element.getAttribute(""perpage"")); referrers.setTotal(element.getAttribute(""total"")); referrers.setName(element.getAttribute(""name""));  NodeList referrerElements = element.getElementsByTagName(""referrer""); for (int i = 0; i < referrerElements.getLength(); i++) { Element referrerElement = (Element) referrerElements.item(i); Referrer referrer = new Referrer(); referrer.setUrl(referrerElement.getAttribute(""url"")); referrer.setViews(referrerElement.getAttribute(""views"")); referrers.add(referrer); }  return referrers; }  private Stats getStats(String method, String idKey, String idValue, Date date) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", method); parameters.put(""date"", String.valueOf(date.getTime() / 1000L)); if (idValue != null) { parameters.put(idKey, idValue); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Stats stats = parseStats(response.getPayload());  return stats; }  /**
     * 
     * @param element
     */ private Stats parseStats(Element element) { Stats stats = new Stats(); String views = element.getAttribute(""views""); String comments = element.getAttribute(""comments""); String favorites = element.getAttribute(""favorites"");  stats.setViews(views); stats.setComments(comments); stats.setFavorites(favorites);  return stats; }  private Totals parseTotals(Response response) { Element element = response.getPayload();  Totals stats = new Totals();  NodeList childNodes = element.getChildNodes(); for (int i = 0; i < childNodes.getLength(); i++) {  Node node = childNodes.item(i); if (node.getNodeType() == Node.ELEMENT_NODE) { Element childElement = (Element) node; String total = getViewsValue(childElement, ""total""); if (total != null) { stats.setTotal(total); }  String photos = getViewsValue(childElement, ""photos""); if (photos != null) { stats.setPhotos(photos); }  String photostream = getViewsValue(childElement, ""photostream""); if (photostream != null) { stats.setPhotostream(photostream); }  String collections = getViewsValue(childElement, ""collections""); if (collections != null) { stats.setCollections(collections); }  String sets = getViewsValue(childElement, ""sets""); if (sets != null) { stats.setSets(sets); } } }  return stats; }  private String getViewsValue(Element childElement, String name) { String total = null; if (childElement.getNodeName().equals(name)) { total = childElement.getAttribute(""views""); }  return total; }  private void addPaginationParameters(Map<String, Object> parameters, int perPage, int page) { if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); } }  private List<Csv> parseCsvFiles(Response response) { Element element = response.getPayload();  List<Csv> csvFiles = new ArrayList<Csv>(); SimpleDateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd"");  NodeList csvElements = element.getElementsByTagName(""csv""); for (int i = 0; i < csvElements.getLength(); i++) { Element csvElement = (Element) csvElements.item(i); Csv csv = new Csv(); csv.setHref(csvElement.getAttribute(""href"")); csv.setType(csvElement.getAttribute(""type"")); try { csv.setDate(dateFormat.parse(csvElement.getAttribute(""date""))); } catch (ParseException e) { throw new FlickrRuntimeException(e); }  csvFiles.add(csv); } return csvFiles; }  /**
     * 
     * @param response
     */ private PhotoList<Photo> parsePopularPhotos(Response response) {  Element payload = response.getPayload(); PhotoList<Photo> photos = new PhotoList<Photo>();  NodeList photoElements = payload.getElementsByTagName(""photo""); for (int i = 0; i < photoElements.getLength(); i++) { Element photoElement = (Element) photoElements.item(i); Photo photo = PhotoUtils.createPhoto(photoElement);  Element statsElement = XMLUtilities.getChild(photoElement, ""stats""); Stats stats = parseStats(statsElement); photo.setStats(stats);  photos.add(photo); }  return photos; }  }  "
src/main/java/com/flickr4java/flickr/stats/StatsSort.java,"package com.flickr4java.flickr.stats;

/**
 * Sort orders for {@link StatsInterface#getPopularPhotos}
 * 
 * @author Darren Greaves
 * @version $Id$ Copyright (c) 2012 Darren Greaves.
 */
public enum StatsSort {

    views, comments, favorites;
}
","package com.flickr4java.flickr.stats; public enum StatsSort { views, comments, favorites; }",0 0 0 0 0,"package com.flickr4java.flickr.stats; public enum StatsSort { views, comments, favorites; } ","package com.flickr4java.flickr.stats;  /**
 * Sort orders for {@link StatsInterface#getPopularPhotos}
 * 
 * @author Darren Greaves
 * @version $Id$ Copyright (c) 2012 Darren Greaves.
 */ public enum StatsSort {  views, comments, favorites; }  "
src/main/java/com/flickr4java/flickr/stats/Totals.java,"package com.flickr4java.flickr.stats;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Stats information as returned by the stats interface.
 * 
 * @author Darren Greaves
 * @version $Id$ Copyright (c) 2012 Darren Greaves.
 */
public class Totals {

    /**
     * Logger.
     */
    @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(Totals.class);

    private int total;

    private int photos;

    private int photostream;

    private int sets;

    private int collections;

    public Totals() {
    }

    public int getTotal() {
        return total;
    }

    public void setTotal(int total) {
        this.total = total;
    }

    public void setTotal(String total) {
        try {
            setTotal(Integer.parseInt(total));
        } catch (NumberFormatException e) {
            // ignore and set value as 0
            setTotal(0);
        }
    }

    public int getPhotos() {
        return photos;
    }

    public void setPhotos(int photos) {
        this.photos = photos;
    }

    public void setPhotos(String photos) {
        try {
            setPhotos(Integer.parseInt(photos));
        } catch (NumberFormatException e) {
            // ignore and set value as 0
            setPhotos(0);
        }
    }

    public int getPhotostream() {
        return photostream;
    }

    public void setPhotostream(int photostream) {
        this.photostream = photostream;
    }

    public void setPhotostream(String photostream) {
        try {
            setPhotostream(Integer.parseInt(photostream));
        } catch (NumberFormatException e) {
            // ignore and set value as null
            setPhotostream(0);
        }
    }

    public int getSets() {
        return sets;
    }

    public void setSets(int sets) {
        this.sets = sets;
    }

    public void setSets(String sets) {
        try {
            setSets(Integer.parseInt(sets));
        } catch (NumberFormatException e) {
            // ignore and set value as null
            setSets(0);
        }
    }

    public int getCollections() {
        return collections;
    }

    public void setCollections(int collections) {
        this.collections = collections;
    }

    public void setCollections(String collections) {
        try {
            setCollections(Integer.parseInt(collections));
        } catch (NumberFormatException e) {
            // ignore and set value as null
            setCollections(0);
        }
    }

    @SuppressWarnings(""boxing"")
    @Override
    public String toString() {

        return String.format(""total (%d), photostream (%d), photos (%d), sets (%d), collections (%d)"", total, photostream, photos, sets, collections);
    }
}
","package com.flickr4java.flickr.stats; public class Totals { @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(Totals.class); private int total; private int photos; private int photostream; private int sets; private int collections; public Totals() { } public int getTotal() { return total; } public void setTotal(int total) { this.total = total; } public void setTotal(String total) { try { setTotal(Integer.parseInt(total)); } catch (NumberFormatException e) { setTotal(0); } } public int getPhotos() { return photos; } public void setPhotos(int photos) { this.photos = photos; } public void setPhotos(String photos) { try { setPhotos(Integer.parseInt(photos)); } catch (NumberFormatException e) { setPhotos(0); } } public int getPhotostream() { return photostream; } public void setPhotostream(int photostream) { this.photostream = photostream; } public void setPhotostream(String photostream) { try { setPhotostream(Integer.parseInt(photostream)); } catch (NumberFormatException e) { setPhotostream(0); } } public int getSets() { return sets; } public void setSets(int sets) { this.sets = sets; } public void setSets(String sets) { try { setSets(Integer.parseInt(sets)); } catch (NumberFormatException e) { setSets(0); } } public int getCollections() { return collections; } public void setCollections(int collections) { this.collections = collections; } public void setCollections(String collections) { try { setCollections(Integer.parseInt(collections)); } catch (NumberFormatException e) { setCollections(0); } } @SuppressWarnings(""boxing"")
    @Override
    public String toString() { return String.format(""total (%d), photostream (%d), photos (%d), sets (%d), collections (%d)"", total, photostream, photos, sets, collections); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.stats; public class Totals { @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(Totals.class); private int total; private int photos; private int photostream; private int sets; private int collections; public Totals() { } public int getTotal() { return total; } public void setTotal(int total) { this.total = total; } public void setTotal(String total) { try { setTotal(Integer.parseInt(total)); } catch (NumberFormatException e) { setTotal(0); } } public int getPhotos() { return photos; } public void setPhotos(int photos) { this.photos = photos; } public void setPhotos(String photos) { try { setPhotos(Integer.parseInt(photos)); } catch (NumberFormatException e) { setPhotos(0); } } public int getPhotostream() { return photostream; } public void setPhotostream(int photostream) { this.photostream = photostream; } public void setPhotostream(String photostream) { try { setPhotostream(Integer.parseInt(photostream)); } catch (NumberFormatException e) { setPhotostream(0); } } public int getSets() { return sets; } public void setSets(int sets) { this.sets = sets; } public void setSets(String sets) { try { setSets(Integer.parseInt(sets)); } catch (NumberFormatException e) { setSets(0); } } public int getCollections() { return collections; } public void setCollections(int collections) { this.collections = collections; } public void setCollections(String collections) { try { setCollections(Integer.parseInt(collections)); } catch (NumberFormatException e) { setCollections(0); } } @SuppressWarnings(""boxing"")
    @Override
    public String toString() { return String.format(""total (%d), photostream (%d), photos (%d), sets (%d), collections (%d)"", total, photostream, photos, sets, collections); } } ","package com.flickr4java.flickr.stats; 
import org.slf4j.Logger; import org.slf4j.LoggerFactory;  /**
 * Stats information as returned by the stats interface.
 * 
 * @author Darren Greaves
 * @version $Id$ Copyright (c) 2012 Darren Greaves.
 */ public class Totals {  /**
     * Logger.
     */ @SuppressWarnings(""unused"")
    private static Logger _log = LoggerFactory.getLogger(Totals.class);  private int total;  private int photos;  private int photostream;  private int sets;  private int collections;  public Totals() { }  public int getTotal() { return total; }  public void setTotal(int total) { this.total = total; }  public void setTotal(String total) { try { setTotal(Integer.parseInt(total)); } catch (NumberFormatException e) { // ignore and set value as 0 setTotal(0); } }  public int getPhotos() { return photos; }  public void setPhotos(int photos) { this.photos = photos; }  public void setPhotos(String photos) { try { setPhotos(Integer.parseInt(photos)); } catch (NumberFormatException e) { // ignore and set value as 0 setPhotos(0); } }  public int getPhotostream() { return photostream; }  public void setPhotostream(int photostream) { this.photostream = photostream; }  public void setPhotostream(String photostream) { try { setPhotostream(Integer.parseInt(photostream)); } catch (NumberFormatException e) { // ignore and set value as null setPhotostream(0); } }  public int getSets() { return sets; }  public void setSets(int sets) { this.sets = sets; }  public void setSets(String sets) { try { setSets(Integer.parseInt(sets)); } catch (NumberFormatException e) { // ignore and set value as null setSets(0); } }  public int getCollections() { return collections; }  public void setCollections(int collections) { this.collections = collections; }  public void setCollections(String collections) { try { setCollections(Integer.parseInt(collections)); } catch (NumberFormatException e) { // ignore and set value as null setCollections(0); } }  @SuppressWarnings(""boxing"")
    @Override
    public String toString() {  return String.format(""total (%d), photostream (%d), photos (%d), sets (%d), collections (%d)"", total, photostream, photos, sets, collections); } }  "
src/main/java/com/flickr4java/flickr/tags/Cluster.java,"package com.flickr4java.flickr.tags;

import java.util.ArrayList;

/**
 * Cluster (list) of tags.
 * 
 * @author mago
 * @since 1.2
 * @version $Id: Cluster.java,v 1.2 2009/07/12 22:43:07 x-mago Exp $
 */
public class Cluster {

    private ArrayList<Tag> tags = new ArrayList<Tag>();

    public void addTag(Tag tag) {
        tags.add(tag);
    }

    public ArrayList<Tag> getTags() {
        return tags;
    }

    public void setTags(ArrayList<Tag> tags) {
        this.tags = tags;
    }
}
",package com.flickr4java.flickr.tags; import java.util.ArrayList; public class Cluster { private ArrayList<Tag> tags = new ArrayList<Tag>(); public void addTag(Tag tag) { tags.add(tag); } public ArrayList<Tag> getTags() { return tags; } public void setTags(ArrayList<Tag> tags) { this.tags = tags; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.tags; import java.util.ArrayList; public class Cluster { private ArrayList<Tag> tags = new ArrayList<Tag>(); public void addTag(Tag tag) { tags.add(tag); } public ArrayList<Tag> getTags() { return tags; } public void setTags(ArrayList<Tag> tags) { this.tags = tags; } } ,"package com.flickr4java.flickr.tags;  import java.util.ArrayList;  /**
 * Cluster (list) of tags.
 * 
 * @author mago
 * @since 1.2
 * @version $Id: Cluster.java,v 1.2 2009/07/12 22:43:07 x-mago Exp $
 */ public class Cluster {  private ArrayList<Tag> tags = new ArrayList<Tag>();  public void addTag(Tag tag) { tags.add(tag); }  public ArrayList<Tag> getTags() { return tags; }  public void setTags(ArrayList<Tag> tags) { this.tags = tags; } }  "
src/main/java/com/flickr4java/flickr/tags/ClusterList.java,"package com.flickr4java.flickr.tags;

import java.util.ArrayList;

/**
 * List (tag-)clusters.
 * 
 * @author mago
 * @since 1.2
 * @version $Id: ClusterList.java,v 1.1 2008/07/19 14:42:54 x-mago Exp $
 */
public class ClusterList {

    private ArrayList<Cluster> clusters = new ArrayList<Cluster>();

    public void addCluster(Cluster cluster) {
        clusters.add(cluster);
    }

    public ArrayList<Cluster> getClusters() {
        return clusters;
    }
}
",package com.flickr4java.flickr.tags; import java.util.ArrayList; public class ClusterList { private ArrayList<Cluster> clusters = new ArrayList<Cluster>(); public void addCluster(Cluster cluster) { clusters.add(cluster); } public ArrayList<Cluster> getClusters() { return clusters; } },0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.tags; import java.util.ArrayList; public class ClusterList { private ArrayList<Cluster> clusters = new ArrayList<Cluster>(); public void addCluster(Cluster cluster) { clusters.add(cluster); } public ArrayList<Cluster> getClusters() { return clusters; } } ,"package com.flickr4java.flickr.tags;  import java.util.ArrayList;  /**
 * List (tag-)clusters.
 * 
 * @author mago
 * @since 1.2
 * @version $Id: ClusterList.java,v 1.1 2008/07/19 14:42:54 x-mago Exp $
 */ public class ClusterList {  private ArrayList<Cluster> clusters = new ArrayList<Cluster>();  public void addCluster(Cluster cluster) { clusters.add(cluster); }  public ArrayList<Cluster> getClusters() { return clusters; } }  "
src/main/java/com/flickr4java/flickr/tags/HotlistTag.java,"package com.flickr4java.flickr.tags;

/**
 * 
 * @author mago
 * @version $Id: HotlistTag.java,v 1.2 2009/07/12 22:43:07 x-mago Exp $
 */
public class HotlistTag {

    private String value;

    private int score = 0;

    public HotlistTag() {

    }

    @Deprecated
    // Note that the API no longer returns the score
    public int getScore() {
        return score;
    }

    public void setScore(int score) {
        this.score = score;
    }

    public void setScore(String score) {
        setScore(Integer.parseInt(score));
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }
}
",package com.flickr4java.flickr.tags; public class HotlistTag { private String value; private int score = 0; public HotlistTag() { } public int getScore() { return score; } public void setScore(int score) { this.score = score; } public void setScore(String score) { setScore(Integer.parseInt(score)); } public String getValue() { return value; } public void setValue(String value) { this.value = value; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.tags; public class HotlistTag { private String value; private int score = 0; public HotlistTag() { } public int getScore() { return score; } public void setScore(int score) { this.score = score; } public void setScore(String score) { setScore(Integer.parseInt(score)); } public String getValue() { return value; } public void setValue(String value) { this.value = value; } } ,"package com.flickr4java.flickr.tags;  /**
 * 
 * @author mago
 * @version $Id: HotlistTag.java,v 1.2 2009/07/12 22:43:07 x-mago Exp $
 */ public class HotlistTag {  private String value;  private int score = 0;  public HotlistTag() {  }  // Note that the API no longer returns the score public int getScore() { return score; }  public void setScore(int score) { this.score = score; }  public void setScore(String score) { setScore(Integer.parseInt(score)); }  public String getValue() { return value; }  public void setValue(String value) { this.value = value; } }  "
src/main/java/com/flickr4java/flickr/tags/RelatedTagsList.java,"

package com.flickr4java.flickr.tags;

import java.util.ArrayList;

/**
 * @author Anthony Eden
 */
public class RelatedTagsList extends ArrayList<Tag> {
    private static final long serialVersionUID = 12L;

    private String source;

    public String getSource() {
        return source;
    }

    public void setSource(String source) {
        this.source = source;
    }

}
",package com.flickr4java.flickr.tags; import java.util.ArrayList; public class RelatedTagsList extends ArrayList<Tag> { private static final long serialVersionUID = 12L; private String source; public String getSource() { return source; } public void setSource(String source) { this.source = source; } },0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.tags; import java.util.ArrayList; public class RelatedTagsList extends ArrayList<Tag> { private static final long serialVersionUID = 12L; private String source; public String getSource() { return source; } public void setSource(String source) { this.source = source; } } ,"
 package com.flickr4java.flickr.tags;  import java.util.ArrayList;  /**
 * @author Anthony Eden
 */ public class RelatedTagsList extends ArrayList<Tag> { private static final long serialVersionUID = 12L;  private String source;  public String getSource() { return source; }  public void setSource(String source) { this.source = source; }  }  "
src/main/java/com/flickr4java/flickr/tags/Tag.java,"
package com.flickr4java.flickr.tags;

/**
 * @author Anthony Eden
 */
public class Tag {

    private String id;

    private String author;

    private String authorName;

    private String raw;

    private String value;

    private int count;

    public Tag() {

    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public String getAuthorName() {
        return authorName;
    }

    public void setAuthorName(String authorName) {
        this.authorName = authorName;
    }

    public String getRaw() {
        return raw;
    }

    public void setRaw(String raw) {
        this.raw = raw;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public int getCount() {
        return count;
    }

    public void setCount(int count) {
        this.count = count;
    }

    public void setCount(String count) {
        setCount(Integer.parseInt(count));
    }

    @Override
    public boolean equals(Object obj) {
        if ((obj == null) || (obj.getClass() != this.getClass())) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        Tag test = (Tag) obj;
        return count == test.count && areEqual(value, test.value) && areEqual(raw, test.raw) && areEqual(author, test.author)
                && areEqual(authorName, test.authorName) && areEqual(id, test.id);
    }

    @Override
    public int hashCode() {
        int hash = 1;
        hash +=  Integer.hashCode(count);
        if (value != null) {
            hash += value.hashCode();
        }
        if (raw != null) {
            hash += raw.hashCode();
        }
        if (author != null) {
            hash += author.hashCode();
        }
        if (authorName != null) {
            hash += authorName.hashCode();
        }
        if (id != null) {
            hash += id.hashCode();
        }
        return hash;
    }

    private boolean areEqual(Object x, Object y) {
        return x == null ? y == null : x.equals(y);
    }

    @Override
    public String toString() {
        return String.format(""Tag [value=%s, count=%s]"", value, count);
    }
}
","package com.flickr4java.flickr.tags; public class Tag { private String id; private String author; private String authorName; private String raw; private String value; private int count; public Tag() { } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public String getAuthorName() { return authorName; } public void setAuthorName(String authorName) { this.authorName = authorName; } public String getRaw() { return raw; } public void setRaw(String raw) { this.raw = raw; } public String getValue() { return value; } public void setValue(String value) { this.value = value; } public int getCount() { return count; } public void setCount(int count) { this.count = count; } public void setCount(String count) { setCount(Integer.parseInt(count)); } @Override
    public boolean equals(Object obj) { if ((obj == null) || (obj.getClass() != this.getClass())) { return false; } if (obj == this) { return true; } Tag test = (Tag) obj; return count == test.count && areEqual(value, test.value) && areEqual(raw, test.raw) && areEqual(author, test.author)
                && areEqual(authorName, test.authorName) && areEqual(id, test.id); } @Override
    public int hashCode() { int hash = 1; hash +=  Integer.hashCode(count); if (value != null) { hash += value.hashCode(); } if (raw != null) { hash += raw.hashCode(); } if (author != null) { hash += author.hashCode(); } if (authorName != null) { hash += authorName.hashCode(); } if (id != null) { hash += id.hashCode(); } return hash; } private boolean areEqual(Object x, Object y) { return x == null ? y == null : x.equals(y); } @Override
    public String toString() { return String.format(""Tag [value=%s, count=%s]"", value, count); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.tags; public class Tag { private String id; private String author; private String authorName; private String raw; private String value; private int count; public Tag() { } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public String getAuthorName() { return authorName; } public void setAuthorName(String authorName) { this.authorName = authorName; } public String getRaw() { return raw; } public void setRaw(String raw) { this.raw = raw; } public String getValue() { return value; } public void setValue(String value) { this.value = value; } public int getCount() { return count; } public void setCount(int count) { this.count = count; } public void setCount(String count) { setCount(Integer.parseInt(count)); } @Override
    public boolean equals(Object obj) { if ((obj == null) || (obj.getClass() != this.getClass())) { return false; } if (obj == this) { return true; } Tag test = (Tag) obj; return count == test.count && areEqual(value, test.value) && areEqual(raw, test.raw) && areEqual(author, test.author)
                && areEqual(authorName, test.authorName) && areEqual(id, test.id); } @Override
    public int hashCode() { int hash = 1; hash +=  Integer.hashCode(count); if (value != null) { hash += value.hashCode(); } if (raw != null) { hash += raw.hashCode(); } if (author != null) { hash += author.hashCode(); } if (authorName != null) { hash += authorName.hashCode(); } if (id != null) { hash += id.hashCode(); } return hash; } private boolean areEqual(Object x, Object y) { return x == null ? y == null : x.equals(y); } @Override
    public String toString() { return String.format(""Tag [value=%s, count=%s]"", value, count); } } "," package com.flickr4java.flickr.tags;  /**
 * @author Anthony Eden
 */ public class Tag {  private String id;  private String author;  private String authorName;  private String raw;  private String value;  private int count;  public Tag() {  }  public String getId() { return id; }  public void setId(String id) { this.id = id; }  public String getAuthor() { return author; }  public void setAuthor(String author) { this.author = author; }  public String getAuthorName() { return authorName; }  public void setAuthorName(String authorName) { this.authorName = authorName; }  public String getRaw() { return raw; }  public void setRaw(String raw) { this.raw = raw; }  public String getValue() { return value; }  public void setValue(String value) { this.value = value; }  public int getCount() { return count; }  public void setCount(int count) { this.count = count; }  public void setCount(String count) { setCount(Integer.parseInt(count)); }  @Override
    public boolean equals(Object obj) { if ((obj == null) || (obj.getClass() != this.getClass())) { return false; } if (obj == this) { return true; } Tag test = (Tag) obj; return count == test.count && areEqual(value, test.value) && areEqual(raw, test.raw) && areEqual(author, test.author)
                && areEqual(authorName, test.authorName) && areEqual(id, test.id); }  @Override
    public int hashCode() { int hash = 1; hash +=  Integer.hashCode(count); if (value != null) { hash += value.hashCode(); } if (raw != null) { hash += raw.hashCode(); } if (author != null) { hash += author.hashCode(); } if (authorName != null) { hash += authorName.hashCode(); } if (id != null) { hash += id.hashCode(); } return hash; }  private boolean areEqual(Object x, Object y) { return x == null ? y == null : x.equals(y); }  @Override
    public String toString() { return String.format(""Tag [value=%s, count=%s]"", value, count); } }  "
src/main/java/com/flickr4java/flickr/tags/TagRaw.java,"package com.flickr4java.flickr.tags;

import java.util.ArrayList;
import java.util.List;

/**
 * 
 * @see com.flickr4java.flickr.tags.TagsInterface#getListUserRaw
 * @author mago
 * @version $Id: TagRaw.java,v 1.2 2009/07/12 22:43:07 x-mago Exp $
 */
public class TagRaw {

    private String owner;

    private String clean;

    private List<String> raw = new ArrayList<String>();

    public TagRaw() {
    }

    public String getClean() {
        return clean;
    }

    public void setClean(String clean) {
        this.clean = clean;
    }

    public String getOwner() {
        return owner;
    }

    public void setOwner(String owner) {
        this.owner = owner;
    }

    public List<String> getRaw() {
        return raw;
    }

    public void addRaw(String rawStr) {
        raw.add(rawStr);
    }
}
",package com.flickr4java.flickr.tags; import java.util.ArrayList; import java.util.List; public class TagRaw { private String owner; private String clean; private List<String> raw = new ArrayList<String>(); public TagRaw() { } public String getClean() { return clean; } public void setClean(String clean) { this.clean = clean; } public String getOwner() { return owner; } public void setOwner(String owner) { this.owner = owner; } public List<String> getRaw() { return raw; } public void addRaw(String rawStr) { raw.add(rawStr); } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.tags; import java.util.ArrayList; import java.util.List; public class TagRaw { private String owner; private String clean; private List<String> raw = new ArrayList<String>(); public TagRaw() { } public String getClean() { return clean; } public void setClean(String clean) { this.clean = clean; } public String getOwner() { return owner; } public void setOwner(String owner) { this.owner = owner; } public List<String> getRaw() { return raw; } public void addRaw(String rawStr) { raw.add(rawStr); } } ,"package com.flickr4java.flickr.tags;  import java.util.ArrayList; import java.util.List;  /**
 * 
 * @see com.flickr4java.flickr.tags.TagsInterface#getListUserRaw
 * @author mago
 * @version $Id: TagRaw.java,v 1.2 2009/07/12 22:43:07 x-mago Exp $
 */ public class TagRaw {  private String owner;  private String clean;  private List<String> raw = new ArrayList<String>();  public TagRaw() { }  public String getClean() { return clean; }  public void setClean(String clean) { this.clean = clean; }  public String getOwner() { return owner; }  public void setOwner(String owner) { this.owner = owner; }  public List<String> getRaw() { return raw; }  public void addRaw(String rawStr) { raw.add(rawStr); } }  "
src/main/java/com/flickr4java/flickr/tags/TagsInterface.java,"
package com.flickr4java.flickr.tags;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoList;
import com.flickr4java.flickr.photos.PhotoUtils;
import com.flickr4java.flickr.util.XMLUtilities;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Optional;
import java.util.Map;

/**
 * Interface for working with Flickr tags.
 * 
 * @author Anthony Eden
 * @version $Id: TagsInterface.java,v 1.19 2009/07/02 21:52:35 x-mago Exp $
 */
public class TagsInterface {

    public static final String METHOD_GET_CLUSTERS = ""flickr.tags.getClusters"";

    public static final String METHOD_GET_HOT_LIST = ""flickr.tags.getHotList"";

    public static final String METHOD_GET_LIST_PHOTO = ""flickr.tags.getListPhoto"";

    public static final String METHOD_GET_LIST_USER = ""flickr.tags.getListUser"";

    public static final String METHOD_GET_LIST_USER_POPULAR = ""flickr.tags.getListUserPopular"";

    public static final String METHOD_GET_LIST_USER_RAW = ""flickr.tags.getListUserRaw"";

    public static final String METHOD_GET_RELATED = ""flickr.tags.getRelated"";

    public static final String METHOD_GET_CLUSTER_PHOTOS = ""flickr.tags.getClusterPhotos"";

    public static final String PERIOD_WEEK = ""week"";

    public static final String PERIOD_DAY = ""day"";

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transportAPI;

    /**
     * Construct a TagsInterface.
     * 
     * @param apiKey
     *            The API key
     * @param transportAPI
     *            The Transport interface
     */
    public TagsInterface(String apiKey, String sharedSecret, Transport transportAPI) {

        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transportAPI;
    }

    /**
     * Search for tag-clusters.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @since 1.2
     * @param searchTag
     * @return a list of clusters
     */
    public ClusterList getClusters(String searchTag) throws FlickrException {

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_CLUSTERS);

        parameters.put(""tag"", searchTag);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        ClusterList clusters = new ClusterList();
        Element clustersElement = response.getPayload();
        NodeList clusterElements = clustersElement.getElementsByTagName(""cluster"");
        for (int i = 0; i < clusterElements.getLength(); i++) {
            Cluster cluster = new Cluster();
            NodeList tagElements = ((Element) clusterElements.item(i)).getElementsByTagName(""tag"");
            for (int j = 0; j < tagElements.getLength(); j++) {
                Tag tag = new Tag();
                tag.setValue(((Text) tagElements.item(j).getFirstChild()).getData());
                cluster.addTag(tag);
            }
            clusters.addCluster(cluster);
        }
        return clusters;
    }

    /**
     * Returns the first 24 photos for a given tag cluster.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param tag
     * @param clusterId
     * @return PhotoList
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PhotoList<Photo> getClusterPhotos(String tag, String clusterId) throws FlickrException {

        PhotoList<Photo> photos = new PhotoList<Photo>();
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_CLUSTER_PHOTOS);

        parameters.put(""tag"", tag);
        parameters.put(""cluster_id"", clusterId);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element photosElement = response.getPayload();
        NodeList photoNodes = photosElement.getElementsByTagName(""photo"");
        photos.setPage(""1"");
        photos.setPages(""1"");
        photos.setPerPage("""" + photoNodes.getLength());
        photos.setTotal("""" + photoNodes.getLength());
        for (int i = 0; i < photoNodes.getLength(); i++) {
            Element photoElement = (Element) photoNodes.item(i);
            photos.add(PhotoUtils.createPhoto(photoElement));
        }
        return photos;
    }

    /**
     * Returns a list of hot tags for the given period.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param period
     *            valid values are 'day' or 'week'
     * @param count
     *            maximum is 200
     * @return The collection of HotlistTag objects
     */
    public Collection<HotlistTag> getHotList(String period, int count) throws FlickrException {

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_HOT_LIST);

        parameters.put(""period"", period);
        parameters.put(""count"", """" + count);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Collection<Element> payloadCollection = response.getPayloadCollection();
        Optional<Element> element = payloadCollection.stream().filter(payload -> payload.getTagName().equals(""hottags"")).findFirst();

        List<HotlistTag> tags = new ArrayList<>();
        if (element.isPresent()) {
            NodeList tagElements = element.get().getElementsByTagName(""tag"");
            for (int i = 0; i < tagElements.getLength(); i++) {
                Element tagElement = (Element) tagElements.item(i);
                HotlistTag tag = new HotlistTag();
                tag.setValue(((Text) tagElement.getFirstChild()).getData());
                tags.add(tag);
            }
        }
        return tags;
    }

    /**
     * Get a list of tags for the specified photo.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param photoId
     *            The photo ID
     * @return The collection of Tag objects
     */
    public Photo getListPhoto(String photoId) throws FlickrException {

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_LIST_PHOTO);

        parameters.put(""photo_id"", photoId);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element photoElement = response.getPayload();
        Photo photo = new Photo();
        photo.setId(photoElement.getAttribute(""id""));

        List<Tag> tags = new ArrayList<Tag>();
        Element tagsElement = (Element) photoElement.getElementsByTagName(""tags"").item(0);
        NodeList tagElements = tagsElement.getElementsByTagName(""tag"");
        for (int i = 0; i < tagElements.getLength(); i++) {
            Element tagElement = (Element) tagElements.item(i);
            Tag tag = new Tag();
            tag.setId(tagElement.getAttribute(""id""));
            tag.setAuthor(tagElement.getAttribute(""author""));
            tag.setAuthorName(tagElement.getAttribute(""authorname""));
            tag.setRaw(tagElement.getAttribute(""raw""));
            tag.setValue(((Text) tagElement.getFirstChild()).getData());
            tags.add(tag);
        }
        photo.setTags(tags);
        return photo;
    }

    /**
     * Get a collection of tags used by the specified user.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param userId
     *            The User ID
     * @return The User object
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Collection<Tag> getListUser(String userId) throws FlickrException {

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_LIST_USER);

        parameters.put(""user_id"", userId);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element whoElement = response.getPayload();

        List<Tag> tags = new ArrayList<Tag>();
        Element tagsElement = (Element) whoElement.getElementsByTagName(""tags"").item(0);
        NodeList tagElements = tagsElement.getElementsByTagName(""tag"");
        for (int i = 0; i < tagElements.getLength(); i++) {
            Element tagElement = (Element) tagElements.item(i);
            Tag tag = new Tag();
            tag.setValue(((Text) tagElement.getFirstChild()).getData());
            tags.add(tag);
        }
        return tags;
    }

    /**
     * Get a list of the user's popular tags.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param userId
     *            The user ID
     * @return The collection of Tag objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Collection<Tag> getListUserPopular(String userId) throws FlickrException {

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_LIST_USER_POPULAR);

        parameters.put(""user_id"", userId);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element whoElement = response.getPayload();

        List<Tag> tags = new ArrayList<Tag>();
        Element tagsElement = (Element) whoElement.getElementsByTagName(""tags"").item(0);
        NodeList tagElements = tagsElement.getElementsByTagName(""tag"");
        for (int i = 0; i < tagElements.getLength(); i++) {
            Element tagElement = (Element) tagElements.item(i);
            Tag tag = new Tag();
            tag.setCount(tagElement.getAttribute(""count""));
            tag.setValue(((Text) tagElement.getFirstChild()).getData());
            tags.add(tag);
        }
        return tags;
    }

    /**
     * Get a list of the user's (identified by token) popular tags.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @return The collection of Tag objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Collection<TagRaw> getListUserRaw() throws FlickrException {

        return getListUserRaw(null);
    }

    /**
     * Get a list of the user's (identified by token) popular tags.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param tagVal
     *            a tag to search for (optional)
     * 
     * @return The collection of Tag objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Collection<TagRaw> getListUserRaw(String tagVal) throws FlickrException {

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_LIST_USER_RAW);

        if (tagVal != null) {
            parameters.put(""tag"", tagVal);
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element whoElement = response.getPayload();

        List<TagRaw> tags = new ArrayList<TagRaw>();
        Element tagsElement = (Element) whoElement.getElementsByTagName(""tags"").item(0);
        NodeList tagElements = tagsElement.getElementsByTagName(""tag"");
        for (int i = 0; i < tagElements.getLength(); i++) {
            Element tagElement = (Element) tagElements.item(i);
            TagRaw tag = new TagRaw();
            tag.setClean(tagElement.getAttribute(""clean""));
            NodeList rawElements = tagElement.getElementsByTagName(""raw"");
            for (int j = 0; j < rawElements.getLength(); j++) {
                Element rawElement = (Element) rawElements.item(j);
                tag.addRaw(((Text) rawElement.getFirstChild()).getData());
            }
            tags.add(tag);
        }
        return tags;
    }

    /**
     * Get the related tags.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param tag
     *            The source tag
     * @return A RelatedTagsList object
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public RelatedTagsList getRelated(String tag) throws FlickrException {

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_RELATED);

        parameters.put(""tag"", tag);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element tagsElement = response.getPayload();

        RelatedTagsList tags = new RelatedTagsList();
        tags.setSource(tagsElement.getAttribute(""source""));
        NodeList tagElements = tagsElement.getElementsByTagName(""tag"");
        for (int i = 0; i < tagElements.getLength(); i++) {
            Element tagElement = (Element) tagElements.item(i);
            Tag t = new Tag();
            t.setValue(XMLUtilities.getValue(tagElement));
            tags.add(t);
        }
        return tags;
    }

}
","package com.flickr4java.flickr.tags; public class TagsInterface { public static final String METHOD_GET_CLUSTERS = ""flickr.tags.getClusters""; public static final String METHOD_GET_HOT_LIST = ""flickr.tags.getHotList""; public static final String METHOD_GET_LIST_PHOTO = ""flickr.tags.getListPhoto""; public static final String METHOD_GET_LIST_USER = ""flickr.tags.getListUser""; public static final String METHOD_GET_LIST_USER_POPULAR = ""flickr.tags.getListUserPopular""; public static final String METHOD_GET_LIST_USER_RAW = ""flickr.tags.getListUserRaw""; public static final String METHOD_GET_RELATED = ""flickr.tags.getRelated""; public static final String METHOD_GET_CLUSTER_PHOTOS = ""flickr.tags.getClusterPhotos""; public static final String PERIOD_WEEK = ""week""; public static final String PERIOD_DAY = ""day""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public TagsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public ClusterList getClusters(String searchTag) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CLUSTERS); parameters.put(""tag"", searchTag); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } ClusterList clusters = new ClusterList(); Element clustersElement = response.getPayload(); NodeList clusterElements = clustersElement.getElementsByTagName(""cluster""); for (int i = 0; i < clusterElements.getLength(); i++) { Cluster cluster = new Cluster(); NodeList tagElements = ((Element) clusterElements.item(i)).getElementsByTagName(""tag""); for (int j = 0; j < tagElements.getLength(); j++) { Tag tag = new Tag(); tag.setValue(((Text) tagElements.item(j).getFirstChild()).getData()); cluster.addTag(tag); } clusters.addCluster(cluster); } return clusters; } public PhotoList<Photo> getClusterPhotos(String tag, String clusterId) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CLUSTER_PHOTOS); parameters.put(""tag"", tag); parameters.put(""cluster_id"", clusterId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); photos.setPage(""1""); photos.setPages(""1""); photos.setPerPage("""" + photoNodes.getLength()); photos.setTotal("""" + photoNodes.getLength()); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } public Collection<HotlistTag> getHotList(String period, int count) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_HOT_LIST); parameters.put(""period"", period); parameters.put(""count"", """" + count); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Collection<Element> payloadCollection = response.getPayloadCollection(); Optional<Element> element = payloadCollection.stream().filter(payload -> payload.getTagName().equals(""hottags"")).findFirst(); List<HotlistTag> tags = new ArrayList<>(); if (element.isPresent()) { NodeList tagElements = element.get().getElementsByTagName(""tag""); for (int i = 0; i < tagElements.getLength(); i++) { Element tagElement = (Element) tagElements.item(i); HotlistTag tag = new HotlistTag(); tag.setValue(((Text) tagElement.getFirstChild()).getData()); tags.add(tag); } } return tags; } public Photo getListPhoto(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST_PHOTO); parameters.put(""photo_id"", photoId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photoElement = response.getPayload(); Photo photo = new Photo(); photo.setId(photoElement.getAttribute(""id"")); List<Tag> tags = new ArrayList<Tag>(); Element tagsElement = (Element) photoElement.getElementsByTagName(""tags"").item(0); NodeList tagElements = tagsElement.getElementsByTagName(""tag""); for (int i = 0; i < tagElements.getLength(); i++) { Element tagElement = (Element) tagElements.item(i); Tag tag = new Tag(); tag.setId(tagElement.getAttribute(""id"")); tag.setAuthor(tagElement.getAttribute(""author"")); tag.setAuthorName(tagElement.getAttribute(""authorname"")); tag.setRaw(tagElement.getAttribute(""raw"")); tag.setValue(((Text) tagElement.getFirstChild()).getData()); tags.add(tag); } photo.setTags(tags); return photo; } public Collection<Tag> getListUser(String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST_USER); parameters.put(""user_id"", userId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element whoElement = response.getPayload(); List<Tag> tags = new ArrayList<Tag>(); Element tagsElement = (Element) whoElement.getElementsByTagName(""tags"").item(0); NodeList tagElements = tagsElement.getElementsByTagName(""tag""); for (int i = 0; i < tagElements.getLength(); i++) { Element tagElement = (Element) tagElements.item(i); Tag tag = new Tag(); tag.setValue(((Text) tagElement.getFirstChild()).getData()); tags.add(tag); } return tags; } public Collection<Tag> getListUserPopular(String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST_USER_POPULAR); parameters.put(""user_id"", userId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element whoElement = response.getPayload(); List<Tag> tags = new ArrayList<Tag>(); Element tagsElement = (Element) whoElement.getElementsByTagName(""tags"").item(0); NodeList tagElements = tagsElement.getElementsByTagName(""tag""); for (int i = 0; i < tagElements.getLength(); i++) { Element tagElement = (Element) tagElements.item(i); Tag tag = new Tag(); tag.setCount(tagElement.getAttribute(""count"")); tag.setValue(((Text) tagElement.getFirstChild()).getData()); tags.add(tag); } return tags; } public Collection<TagRaw> getListUserRaw() throws FlickrException { return getListUserRaw(null); } public Collection<TagRaw> getListUserRaw(String tagVal) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST_USER_RAW); if (tagVal != null) { parameters.put(""tag"", tagVal); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element whoElement = response.getPayload(); List<TagRaw> tags = new ArrayList<TagRaw>(); Element tagsElement = (Element) whoElement.getElementsByTagName(""tags"").item(0); NodeList tagElements = tagsElement.getElementsByTagName(""tag""); for (int i = 0; i < tagElements.getLength(); i++) { Element tagElement = (Element) tagElements.item(i); TagRaw tag = new TagRaw(); tag.setClean(tagElement.getAttribute(""clean"")); NodeList rawElements = tagElement.getElementsByTagName(""raw""); for (int j = 0; j < rawElements.getLength(); j++) { Element rawElement = (Element) rawElements.item(j); tag.addRaw(((Text) rawElement.getFirstChild()).getData()); } tags.add(tag); } return tags; } public RelatedTagsList getRelated(String tag) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_RELATED); parameters.put(""tag"", tag); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element tagsElement = response.getPayload(); RelatedTagsList tags = new RelatedTagsList(); tags.setSource(tagsElement.getAttribute(""source"")); NodeList tagElements = tagsElement.getElementsByTagName(""tag""); for (int i = 0; i < tagElements.getLength(); i++) { Element tagElement = (Element) tagElements.item(i); Tag t = new Tag(); t.setValue(XMLUtilities.getValue(tagElement)); tags.add(t); } return tags; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.tags; public class TagsInterface { public static final String METHOD_GET_CLUSTERS = ""flickr.tags.getClusters""; public static final String METHOD_GET_HOT_LIST = ""flickr.tags.getHotList""; public static final String METHOD_GET_LIST_PHOTO = ""flickr.tags.getListPhoto""; public static final String METHOD_GET_LIST_USER = ""flickr.tags.getListUser""; public static final String METHOD_GET_LIST_USER_POPULAR = ""flickr.tags.getListUserPopular""; public static final String METHOD_GET_LIST_USER_RAW = ""flickr.tags.getListUserRaw""; public static final String METHOD_GET_RELATED = ""flickr.tags.getRelated""; public static final String METHOD_GET_CLUSTER_PHOTOS = ""flickr.tags.getClusterPhotos""; public static final String PERIOD_WEEK = ""week""; public static final String PERIOD_DAY = ""day""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public TagsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public ClusterList getClusters(String searchTag) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CLUSTERS); parameters.put(""tag"", searchTag); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } ClusterList clusters = new ClusterList(); Element clustersElement = response.getPayload(); NodeList clusterElements = clustersElement.getElementsByTagName(""cluster""); for (int i = 0; i < clusterElements.getLength(); i++) { Cluster cluster = new Cluster(); NodeList tagElements = ((Element) clusterElements.item(i)).getElementsByTagName(""tag""); for (int j = 0; j < tagElements.getLength(); j++) { Tag tag = new Tag(); tag.setValue(((Text) tagElements.item(j).getFirstChild()).getData()); cluster.addTag(tag); } clusters.addCluster(cluster); } return clusters; } public PhotoList<Photo> getClusterPhotos(String tag, String clusterId) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CLUSTER_PHOTOS); parameters.put(""tag"", tag); parameters.put(""cluster_id"", clusterId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); photos.setPage(""1""); photos.setPages(""1""); photos.setPerPage("""" + photoNodes.getLength()); photos.setTotal("""" + photoNodes.getLength()); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } public Collection<HotlistTag> getHotList(String period, int count) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_HOT_LIST); parameters.put(""period"", period); parameters.put(""count"", """" + count); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Collection<Element> payloadCollection = response.getPayloadCollection(); Optional<Element> element = payloadCollection.stream().filter(payload -> payload.getTagName().equals(""hottags"")).findFirst(); List<HotlistTag> tags = new ArrayList<>(); if (element.isPresent()) { NodeList tagElements = element.get().getElementsByTagName(""tag""); for (int i = 0; i < tagElements.getLength(); i++) { Element tagElement = (Element) tagElements.item(i); HotlistTag tag = new HotlistTag(); tag.setValue(((Text) tagElement.getFirstChild()).getData()); tags.add(tag); } } return tags; } public Photo getListPhoto(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST_PHOTO); parameters.put(""photo_id"", photoId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photoElement = response.getPayload(); Photo photo = new Photo(); photo.setId(photoElement.getAttribute(""id"")); List<Tag> tags = new ArrayList<Tag>(); Element tagsElement = (Element) photoElement.getElementsByTagName(""tags"").item(0); NodeList tagElements = tagsElement.getElementsByTagName(""tag""); for (int i = 0; i < tagElements.getLength(); i++) { Element tagElement = (Element) tagElements.item(i); Tag tag = new Tag(); tag.setId(tagElement.getAttribute(""id"")); tag.setAuthor(tagElement.getAttribute(""author"")); tag.setAuthorName(tagElement.getAttribute(""authorname"")); tag.setRaw(tagElement.getAttribute(""raw"")); tag.setValue(((Text) tagElement.getFirstChild()).getData()); tags.add(tag); } photo.setTags(tags); return photo; } public Collection<Tag> getListUser(String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST_USER); parameters.put(""user_id"", userId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element whoElement = response.getPayload(); List<Tag> tags = new ArrayList<Tag>(); Element tagsElement = (Element) whoElement.getElementsByTagName(""tags"").item(0); NodeList tagElements = tagsElement.getElementsByTagName(""tag""); for (int i = 0; i < tagElements.getLength(); i++) { Element tagElement = (Element) tagElements.item(i); Tag tag = new Tag(); tag.setValue(((Text) tagElement.getFirstChild()).getData()); tags.add(tag); } return tags; } public Collection<Tag> getListUserPopular(String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST_USER_POPULAR); parameters.put(""user_id"", userId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element whoElement = response.getPayload(); List<Tag> tags = new ArrayList<Tag>(); Element tagsElement = (Element) whoElement.getElementsByTagName(""tags"").item(0); NodeList tagElements = tagsElement.getElementsByTagName(""tag""); for (int i = 0; i < tagElements.getLength(); i++) { Element tagElement = (Element) tagElements.item(i); Tag tag = new Tag(); tag.setCount(tagElement.getAttribute(""count"")); tag.setValue(((Text) tagElement.getFirstChild()).getData()); tags.add(tag); } return tags; } public Collection<TagRaw> getListUserRaw() throws FlickrException { return getListUserRaw(null); } public Collection<TagRaw> getListUserRaw(String tagVal) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST_USER_RAW); if (tagVal != null) { parameters.put(""tag"", tagVal); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element whoElement = response.getPayload(); List<TagRaw> tags = new ArrayList<TagRaw>(); Element tagsElement = (Element) whoElement.getElementsByTagName(""tags"").item(0); NodeList tagElements = tagsElement.getElementsByTagName(""tag""); for (int i = 0; i < tagElements.getLength(); i++) { Element tagElement = (Element) tagElements.item(i); TagRaw tag = new TagRaw(); tag.setClean(tagElement.getAttribute(""clean"")); NodeList rawElements = tagElement.getElementsByTagName(""raw""); for (int j = 0; j < rawElements.getLength(); j++) { Element rawElement = (Element) rawElements.item(j); tag.addRaw(((Text) rawElement.getFirstChild()).getData()); } tags.add(tag); } return tags; } public RelatedTagsList getRelated(String tag) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_RELATED); parameters.put(""tag"", tag); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element tagsElement = response.getPayload(); RelatedTagsList tags = new RelatedTagsList(); tags.setSource(tagsElement.getAttribute(""source"")); NodeList tagElements = tagsElement.getElementsByTagName(""tag""); for (int i = 0; i < tagElements.getLength(); i++) { Element tagElement = (Element) tagElements.item(i); Tag t = new Tag(); t.setValue(XMLUtilities.getValue(tagElement)); tags.add(t); } return tags; } } "," package com.flickr4java.flickr.tags; 
import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.util.XMLUtilities; 
import org.w3c.dom.Element; import org.w3c.dom.NodeList; import org.w3c.dom.Text; 
import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.List; import java.util.Optional; import java.util.Map;  /**
 * Interface for working with Flickr tags.
 * 
 * @author Anthony Eden
 * @version $Id: TagsInterface.java,v 1.19 2009/07/02 21:52:35 x-mago Exp $
 */ public class TagsInterface {  public static final String METHOD_GET_CLUSTERS = ""flickr.tags.getClusters"";  public static final String METHOD_GET_HOT_LIST = ""flickr.tags.getHotList"";  public static final String METHOD_GET_LIST_PHOTO = ""flickr.tags.getListPhoto"";  public static final String METHOD_GET_LIST_USER = ""flickr.tags.getListUser"";  public static final String METHOD_GET_LIST_USER_POPULAR = ""flickr.tags.getListUserPopular"";  public static final String METHOD_GET_LIST_USER_RAW = ""flickr.tags.getListUserRaw"";  public static final String METHOD_GET_RELATED = ""flickr.tags.getRelated"";  public static final String METHOD_GET_CLUSTER_PHOTOS = ""flickr.tags.getClusterPhotos"";  public static final String PERIOD_WEEK = ""week"";  public static final String PERIOD_DAY = ""day"";  private final String apiKey;  private final String sharedSecret;  private final Transport transportAPI;  /**
     * Construct a TagsInterface.
     * 
     * @param apiKey
     *            The API key
     * @param transportAPI
     *            The Transport interface
     */ public TagsInterface(String apiKey, String sharedSecret, Transport transportAPI) {  this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; }  /**
     * Search for tag-clusters.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @since 1.2
     * @param searchTag
     * @return a list of clusters
     */ public ClusterList getClusters(String searchTag) throws FlickrException {  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CLUSTERS);  parameters.put(""tag"", searchTag);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } ClusterList clusters = new ClusterList(); Element clustersElement = response.getPayload(); NodeList clusterElements = clustersElement.getElementsByTagName(""cluster""); for (int i = 0; i < clusterElements.getLength(); i++) { Cluster cluster = new Cluster(); NodeList tagElements = ((Element) clusterElements.item(i)).getElementsByTagName(""tag""); for (int j = 0; j < tagElements.getLength(); j++) { Tag tag = new Tag(); tag.setValue(((Text) tagElements.item(j).getFirstChild()).getData()); cluster.addTag(tag); } clusters.addCluster(cluster); } return clusters; }  /**
     * Returns the first 24 photos for a given tag cluster.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param tag
     * @param clusterId
     * @return PhotoList
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PhotoList<Photo> getClusterPhotos(String tag, String clusterId) throws FlickrException {  PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CLUSTER_PHOTOS);  parameters.put(""tag"", tag); parameters.put(""cluster_id"", clusterId);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element photosElement = response.getPayload(); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); photos.setPage(""1""); photos.setPages(""1""); photos.setPerPage("""" + photoNodes.getLength()); photos.setTotal("""" + photoNodes.getLength()); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; }  /**
     * Returns a list of hot tags for the given period.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param period
     *            valid values are 'day' or 'week'
     * @param count
     *            maximum is 200
     * @return The collection of HotlistTag objects
     */ public Collection<HotlistTag> getHotList(String period, int count) throws FlickrException {  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_HOT_LIST);  parameters.put(""period"", period); parameters.put(""count"", """" + count);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Collection<Element> payloadCollection = response.getPayloadCollection(); Optional<Element> element = payloadCollection.stream().filter(payload -> payload.getTagName().equals(""hottags"")).findFirst();  List<HotlistTag> tags = new ArrayList<>(); if (element.isPresent()) { NodeList tagElements = element.get().getElementsByTagName(""tag""); for (int i = 0; i < tagElements.getLength(); i++) { Element tagElement = (Element) tagElements.item(i); HotlistTag tag = new HotlistTag(); tag.setValue(((Text) tagElement.getFirstChild()).getData()); tags.add(tag); } } return tags; }  /**
     * Get a list of tags for the specified photo.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param photoId
     *            The photo ID
     * @return The collection of Tag objects
     */ public Photo getListPhoto(String photoId) throws FlickrException {  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST_PHOTO);  parameters.put(""photo_id"", photoId);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element photoElement = response.getPayload(); Photo photo = new Photo(); photo.setId(photoElement.getAttribute(""id""));  List<Tag> tags = new ArrayList<Tag>(); Element tagsElement = (Element) photoElement.getElementsByTagName(""tags"").item(0); NodeList tagElements = tagsElement.getElementsByTagName(""tag""); for (int i = 0; i < tagElements.getLength(); i++) { Element tagElement = (Element) tagElements.item(i); Tag tag = new Tag(); tag.setId(tagElement.getAttribute(""id"")); tag.setAuthor(tagElement.getAttribute(""author"")); tag.setAuthorName(tagElement.getAttribute(""authorname"")); tag.setRaw(tagElement.getAttribute(""raw"")); tag.setValue(((Text) tagElement.getFirstChild()).getData()); tags.add(tag); } photo.setTags(tags); return photo; }  /**
     * Get a collection of tags used by the specified user.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param userId
     *            The User ID
     * @return The User object
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Collection<Tag> getListUser(String userId) throws FlickrException {  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST_USER);  parameters.put(""user_id"", userId);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element whoElement = response.getPayload();  List<Tag> tags = new ArrayList<Tag>(); Element tagsElement = (Element) whoElement.getElementsByTagName(""tags"").item(0); NodeList tagElements = tagsElement.getElementsByTagName(""tag""); for (int i = 0; i < tagElements.getLength(); i++) { Element tagElement = (Element) tagElements.item(i); Tag tag = new Tag(); tag.setValue(((Text) tagElement.getFirstChild()).getData()); tags.add(tag); } return tags; }  /**
     * Get a list of the user's popular tags.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param userId
     *            The user ID
     * @return The collection of Tag objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Collection<Tag> getListUserPopular(String userId) throws FlickrException {  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST_USER_POPULAR);  parameters.put(""user_id"", userId);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element whoElement = response.getPayload();  List<Tag> tags = new ArrayList<Tag>(); Element tagsElement = (Element) whoElement.getElementsByTagName(""tags"").item(0); NodeList tagElements = tagsElement.getElementsByTagName(""tag""); for (int i = 0; i < tagElements.getLength(); i++) { Element tagElement = (Element) tagElements.item(i); Tag tag = new Tag(); tag.setCount(tagElement.getAttribute(""count"")); tag.setValue(((Text) tagElement.getFirstChild()).getData()); tags.add(tag); } return tags; }  /**
     * Get a list of the user's (identified by token) popular tags.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @return The collection of Tag objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Collection<TagRaw> getListUserRaw() throws FlickrException {  return getListUserRaw(null); }  /**
     * Get a list of the user's (identified by token) popular tags.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param tagVal
     *            a tag to search for (optional)
     * 
     * @return The collection of Tag objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Collection<TagRaw> getListUserRaw(String tagVal) throws FlickrException {  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST_USER_RAW);  if (tagVal != null) { parameters.put(""tag"", tagVal); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element whoElement = response.getPayload();  List<TagRaw> tags = new ArrayList<TagRaw>(); Element tagsElement = (Element) whoElement.getElementsByTagName(""tags"").item(0); NodeList tagElements = tagsElement.getElementsByTagName(""tag""); for (int i = 0; i < tagElements.getLength(); i++) { Element tagElement = (Element) tagElements.item(i); TagRaw tag = new TagRaw(); tag.setClean(tagElement.getAttribute(""clean"")); NodeList rawElements = tagElement.getElementsByTagName(""raw""); for (int j = 0; j < rawElements.getLength(); j++) { Element rawElement = (Element) rawElements.item(j); tag.addRaw(((Text) rawElement.getFirstChild()).getData()); } tags.add(tag); } return tags; }  /**
     * Get the related tags.
     * 
     * <p>
     * This method does not require authentication.
     * </p>
     * 
     * @param tag
     *            The source tag
     * @return A RelatedTagsList object
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public RelatedTagsList getRelated(String tag) throws FlickrException {  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_RELATED);  parameters.put(""tag"", tag);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element tagsElement = response.getPayload();  RelatedTagsList tags = new RelatedTagsList(); tags.setSource(tagsElement.getAttribute(""source"")); NodeList tagElements = tagsElement.getElementsByTagName(""tag""); for (int i = 0; i < tagElements.getLength(); i++) { Element tagElement = (Element) tagElements.item(i); Tag t = new Tag(); t.setValue(XMLUtilities.getValue(tagElement)); tags.add(t); } return tags; }  }  "
src/main/java/com/flickr4java/flickr/test/TestInterface.java,"
package com.flickr4java.flickr.test;

import com.flickr4java.flickr.Flickr;
import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.people.User;

import org.w3c.dom.Element;
import org.w3c.dom.Text;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

/**
 * Interface for testing Flickr connectivity.
 * 
 * @author Matt Ray
 */
public class TestInterface {

    public static final String METHOD_ECHO = ""flickr.test.echo"";

    public static final String METHOD_LOGIN = ""flickr.test.login"";

    public static final String METHOD_NULL = ""flickr.test.null"";

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transport;

    public TestInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transport = transportAPI;
    }

    /**
     * A testing method which echo's all paramaters back in the response.
     * 
     * @param params
     *            The parameters
     * @return The Collection of echoed elements
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Collection<Element> echo(Map<String, String> params) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_ECHO);
        parameters.put(Flickr.API_KEY, apiKey);
        parameters.putAll(params);

        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        return response.getPayloadCollection();
    }

    /**
     * A testing method which checks if the caller is logged in then returns a User object.
     * 
     * @return The User object
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public User login() throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_LOGIN);

        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element userElement = response.getPayload();
        User user = new User();
        user.setId(userElement.getAttribute(""id""));

        Element usernameElement = (Element) userElement.getElementsByTagName(""username"").item(0);
        user.setUsername(((Text) usernameElement.getFirstChild()).getData());

        return user;
    }

    /**
     * Null test. This method requires authentication with 'read' permission.
     * 
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void null_() throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_NULL);

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

}
","package com.flickr4java.flickr.test; import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.people.User; import org.w3c.dom.Element; import org.w3c.dom.Text; import java.util.Collection; import java.util.HashMap; import java.util.Map; public class TestInterface { public static final String METHOD_ECHO = ""flickr.test.echo""; public static final String METHOD_LOGIN = ""flickr.test.login""; public static final String METHOD_NULL = ""flickr.test.null""; private final String apiKey; private final String sharedSecret; private final Transport transport; public TestInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transport = transportAPI; } public Collection<Element> echo(Map<String, String> params) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ECHO); parameters.put(Flickr.API_KEY, apiKey); parameters.putAll(params); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } return response.getPayloadCollection(); } public User login() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_LOGIN); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element userElement = response.getPayload(); User user = new User(); user.setId(userElement.getAttribute(""id"")); Element usernameElement = (Element) userElement.getElementsByTagName(""username"").item(0); user.setUsername(((Text) usernameElement.getFirstChild()).getData()); return user; } public void null_() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_NULL); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.people.User; import org.w3c.dom.Element; import org.w3c.dom.Text; import java.util.Collection; import java.util.HashMap; import java.util.Map; public class TestInterface { public static final String METHOD_ECHO = ""flickr.test.echo""; public static final String METHOD_LOGIN = ""flickr.test.login""; public static final String METHOD_NULL = ""flickr.test.null""; private final String apiKey; private final String sharedSecret; private final Transport transport; public TestInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transport = transportAPI; } public Collection<Element> echo(Map<String, String> params) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ECHO); parameters.put(Flickr.API_KEY, apiKey); parameters.putAll(params); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } return response.getPayloadCollection(); } public User login() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_LOGIN); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element userElement = response.getPayload(); User user = new User(); user.setId(userElement.getAttribute(""id"")); Element usernameElement = (Element) userElement.getElementsByTagName(""username"").item(0); user.setUsername(((Text) usernameElement.getFirstChild()).getData()); return user; } public void null_() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_NULL); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } } "," package com.flickr4java.flickr.test;  import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.people.User;  import org.w3c.dom.Element; import org.w3c.dom.Text;  import java.util.Collection; import java.util.HashMap; import java.util.Map;  /**
 * Interface for testing Flickr connectivity.
 * 
 * @author Matt Ray
 */ public class TestInterface {  public static final String METHOD_ECHO = ""flickr.test.echo"";  public static final String METHOD_LOGIN = ""flickr.test.login"";  public static final String METHOD_NULL = ""flickr.test.null"";  private final String apiKey;  private final String sharedSecret;  private final Transport transport;  public TestInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transport = transportAPI; }  /**
     * A testing method which echo's all paramaters back in the response.
     * 
     * @param params
     *            The parameters
     * @return The Collection of echoed elements
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Collection<Element> echo(Map<String, String> params) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ECHO); parameters.put(Flickr.API_KEY, apiKey); parameters.putAll(params);  Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } return response.getPayloadCollection(); }  /**
     * A testing method which checks if the caller is logged in then returns a User object.
     * 
     * @return The User object
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public User login() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_LOGIN);  Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element userElement = response.getPayload(); User user = new User(); user.setId(userElement.getAttribute(""id""));  Element usernameElement = (Element) userElement.getElementsByTagName(""username"").item(0); user.setUsername(((Text) usernameElement.getFirstChild()).getData());  return user; }  /**
     * Null test. This method requires authentication with 'read' permission.
     * 
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void null_() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_NULL);  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  }  "
src/main/java/com/flickr4java/flickr/uploader/IUploader.java,"package com.flickr4java.flickr.uploader;

import com.flickr4java.flickr.FlickrException;

import java.io.File;
import java.io.InputStream;

public interface IUploader {
    String upload(byte[] data, UploadMetaData metaData) throws FlickrException;

    String upload(File file, UploadMetaData metaData) throws FlickrException;

    String upload(InputStream in, UploadMetaData metaData) throws FlickrException;

    String replace(InputStream in, String flickrId, boolean async) throws FlickrException;

    String replace(byte[] data, String flickrId, boolean async) throws FlickrException;

    String replace(File file, String flickrId, boolean async) throws FlickrException;
}
","package com.flickr4java.flickr.uploader; public interface IUploader { String upload(byte[] data, UploadMetaData metaData) throws FlickrException; String upload(File file, UploadMetaData metaData) throws FlickrException; String upload(InputStream in, UploadMetaData metaData) throws FlickrException; String replace(InputStream in, String flickrId, boolean async) throws FlickrException; String replace(byte[] data, String flickrId, boolean async) throws FlickrException; String replace(File file, String flickrId, boolean async) throws FlickrException; }",0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.uploader; public interface IUploader { String upload(byte[] data, UploadMetaData metaData) throws FlickrException; String upload(File file, UploadMetaData metaData) throws FlickrException; String upload(InputStream in, UploadMetaData metaData) throws FlickrException; String replace(InputStream in, String flickrId, boolean async) throws FlickrException; String replace(byte[] data, String flickrId, boolean async) throws FlickrException; String replace(File file, String flickrId, boolean async) throws FlickrException; } ","package com.flickr4java.flickr.uploader; 
import com.flickr4java.flickr.FlickrException; 
import java.io.File; import java.io.InputStream;  public interface IUploader { String upload(byte[] data, UploadMetaData metaData) throws FlickrException;  String upload(File file, UploadMetaData metaData) throws FlickrException;  String upload(InputStream in, UploadMetaData metaData) throws FlickrException;  String replace(InputStream in, String flickrId, boolean async) throws FlickrException;  String replace(byte[] data, String flickrId, boolean async) throws FlickrException;  String replace(File file, String flickrId, boolean async) throws FlickrException; }  "
src/main/java/com/flickr4java/flickr/uploader/Payload.java,"package com.flickr4java.flickr.uploader;

import com.flickr4java.flickr.FlickrRuntimeException;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;

public class Payload {

    private byte[] payload;

    private String photoId;

    public Payload(byte[] payload) {
        this.payload = payload;
    }

    public Payload(File file) {
        try {
            payload = Files.readAllBytes(file.toPath());
        } catch (IOException e) {
            throw new FlickrRuntimeException(e);
        }
    }

    public Payload(InputStream inputStream) {
        try (ByteArrayOutputStream buffer = new ByteArrayOutputStream()) {
            int nRead;
            byte[] data = new byte[16384];

            while ((nRead = inputStream.read(data, 0, data.length)) != -1) {
                buffer.write(data, 0, nRead);
            }

            payload = buffer.toByteArray();
        } catch (IOException e) {
            throw new FlickrRuntimeException(e);
        }
    }

    public Payload(InputStream inputStream, String photoId) {
        this(inputStream);
        this.photoId = photoId;
    }

    public Payload(byte[] payload, String photoId) {
        this(payload);
        this.photoId = photoId;
    }

    public Payload(File file, String photoId) {
        this(file);
        this.photoId = photoId;
    }

    public byte[] getPayload() {
        return payload;
    }

    public String getPhotoId() {
        return photoId;
    }
}
","package com.flickr4java.flickr.uploader; public class Payload { private byte[] payload; private String photoId; public Payload(byte[] payload) { this.payload = payload; } public Payload(File file) { try { payload = Files.readAllBytes(file.toPath()); } catch (IOException e) { throw new FlickrRuntimeException(e); } } public Payload(InputStream inputStream) { try (ByteArrayOutputStream buffer = new ByteArrayOutputStream()) { int nRead; byte[] data = new byte[16384]; while ((nRead = inputStream.read(data, 0, data.length)) != -1) { buffer.write(data, 0, nRead); } payload = buffer.toByteArray(); } catch (IOException e) { throw new FlickrRuntimeException(e); } } public Payload(InputStream inputStream, String photoId) { this(inputStream); this.photoId = photoId; } public Payload(byte[] payload, String photoId) { this(payload); this.photoId = photoId; } public Payload(File file, String photoId) { this(file); this.photoId = photoId; } public byte[] getPayload() { return payload; } public String getPhotoId() { return photoId; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.uploader; public class Payload { private byte[] payload; private String photoId; public Payload(byte[] payload) { this.payload = payload; } public Payload(File file) { try { payload = Files.readAllBytes(file.toPath()); } catch (IOException e) { throw new FlickrRuntimeException(e); } } public Payload(InputStream inputStream) { try (ByteArrayOutputStream buffer = new ByteArrayOutputStream()) { int nRead; byte[] data = new byte[16384]; while ((nRead = inputStream.read(data, 0, data.length)) != -1) { buffer.write(data, 0, nRead); } payload = buffer.toByteArray(); } catch (IOException e) { throw new FlickrRuntimeException(e); } } public Payload(InputStream inputStream, String photoId) { this(inputStream); this.photoId = photoId; } public Payload(byte[] payload, String photoId) { this(payload); this.photoId = photoId; } public Payload(File file, String photoId) { this(file); this.photoId = photoId; } public byte[] getPayload() { return payload; } public String getPhotoId() { return photoId; } } ","package com.flickr4java.flickr.uploader; 
import com.flickr4java.flickr.FlickrRuntimeException; 
import java.io.ByteArrayOutputStream; import java.io.File; import java.io.IOException; import java.io.InputStream; import java.nio.file.Files;  public class Payload {  private byte[] payload;  private String photoId;  public Payload(byte[] payload) { this.payload = payload; }  public Payload(File file) { try { payload = Files.readAllBytes(file.toPath()); } catch (IOException e) { throw new FlickrRuntimeException(e); } }  public Payload(InputStream inputStream) { try (ByteArrayOutputStream buffer = new ByteArrayOutputStream()) { int nRead; byte[] data = new byte[16384];  while ((nRead = inputStream.read(data, 0, data.length)) != -1) { buffer.write(data, 0, nRead); }  payload = buffer.toByteArray(); } catch (IOException e) { throw new FlickrRuntimeException(e); } }  public Payload(InputStream inputStream, String photoId) { this(inputStream); this.photoId = photoId; }  public Payload(byte[] payload, String photoId) { this(payload); this.photoId = photoId; }  public Payload(File file, String photoId) { this(file); this.photoId = photoId; }  public byte[] getPayload() { return payload; }  public String getPhotoId() { return photoId; } }  "
src/main/java/com/flickr4java/flickr/uploader/UploadMetaData.java,"

package com.flickr4java.flickr.uploader;

import com.flickr4java.flickr.util.StringUtilities;

import java.util.Collection;
import java.util.Map;
import java.util.TreeMap;

/**
 * Metadata that describe a photo.
 * 
 * @author Anthony Eden
 * @version $Id: UploadMetaData.java,v 1.7 2007/11/02 21:46:52 x-mago Exp $
 */
public class UploadMetaData {

	private String filename = ""image.jpg"";
	
	private String fileMimeType = ""image/jpeg"";
	
    private String title;

    private String description;

    private Collection<String> tags;

    private boolean publicFlag;

    private boolean friendFlag;

    private boolean familyFlag;

    private boolean async;

    private Boolean hidden;

    private String safetyLevel;

    private String contentType;

    private String photoId;

    public String getTitle() {
        return title;
    }

    public UploadMetaData setTitle(String title) {
        this.title = title;

        return this;
    }

    public String getDescription() {
        return description;
    }

    public UploadMetaData setDescription(String description) {
        this.description = description;

        return this;
    }

    public Collection<String> getTags() {
        return tags;
    }

    public UploadMetaData setTags(Collection<String> tags) {
        this.tags = tags;

        return this;
    }

    public boolean isPublicFlag() {
        return publicFlag;
    }

    public UploadMetaData setPublicFlag(boolean publicFlag) {
        this.publicFlag = publicFlag;

        return this;
    }

    public boolean isFriendFlag() {
        return friendFlag;
    }

    public UploadMetaData setFriendFlag(boolean friendFlag) {
        this.friendFlag = friendFlag;

        return this;
    }

    public boolean isFamilyFlag() {
        return familyFlag;
    }

    public UploadMetaData setFamilyFlag(boolean familyFlag) {
        this.familyFlag = familyFlag;

        return this;
    }

    /**
     * Get the Content-type of the Photo.
     * 
     * @see com.flickr4java.flickr.Flickr#CONTENTTYPE_OTHER
     * @see com.flickr4java.flickr.Flickr#CONTENTTYPE_PHOTO
     * @see com.flickr4java.flickr.Flickr#CONTENTTYPE_SCREENSHOT
     * @return contentType
     */
    public String getContentType() {
        return contentType;
    }

    /**
     * Set the Content-type of the Photo.
     * 
     * @see com.flickr4java.flickr.Flickr#CONTENTTYPE_OTHER
     * @see com.flickr4java.flickr.Flickr#CONTENTTYPE_PHOTO
     * @see com.flickr4java.flickr.Flickr#CONTENTTYPE_SCREENSHOT
     * @param contentType
     */
    public UploadMetaData setContentType(String contentType) {
        this.contentType = contentType;

        return this;
    }

    public Boolean isHidden() {
        return hidden;
    }

    public UploadMetaData setHidden(Boolean hidden) {
        this.hidden = hidden;

        return this;
    }

    /**
     * Get the safety-level.
     * 
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_MODERATE
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_RESTRICTED
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_SAFE
     * @return The safety-level
     */
    public String getSafetyLevel() {
        return safetyLevel;
    }

    /**
     * Set the safety level (adultness) of a photo.
     * <p>
     * 
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_MODERATE
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_RESTRICTED
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_SAFE
     * @param safetyLevel
     */
    public UploadMetaData setSafetyLevel(String safetyLevel) {
        this.safetyLevel = safetyLevel;

        return this;
    }

    /**
	 * @return the filename
	 */
	public String getFilename() {
		return filename;
	}

	/**
	 * @param filename the filename to set
	 */
	public UploadMetaData setFilename(String filename) {
		this.filename = filename;
		
		return this;
	}

	public String getFilemimetype() {
		return fileMimeType;
	}

	public void setFilemimetype(String fileMimeType) {
		this.fileMimeType = fileMimeType;
	}

	public boolean isAsync() {
        return async;
    }

    /**
     * Switch the Uploader behaviour - synchronous or asynchronous.
     * <p>
     * 
     * The default is sychronous.
     * 
     * @param async
     *            boolean
     */
    public UploadMetaData setAsync(boolean async) {
        this.async = async;

        return this;
    }

    public String getPhotoId() {
        return photoId;
    }

    /**
     * Set the existing photo id for a replace operation.
     * @param photoId
     */
    public void setPhotoId(String photoId) {
        this.photoId = photoId;
    }

    /**
     * Get the upload parameters.
     * @return
     */
    public Map<String, String> getUploadParameters() {
        Map<String, String> parameters = new TreeMap<>();


        String title = getTitle();
        if (title != null) {
            parameters.put(""title"", title);
        }

        String description = getDescription();
        if (description != null) {
            parameters.put(""description"", description);
        }

        Collection<String> tags = getTags();
        if (tags != null) {
            parameters.put(""tags"", StringUtilities.join(tags, "" ""));
        }

        if (isHidden() != null) {
            parameters.put(""hidden"", isHidden().booleanValue() ? ""1"" : ""0"");
        }

        if (getSafetyLevel() != null) {
            parameters.put(""safety_level"", getSafetyLevel());
        }

        if (getContentType() != null) {
            parameters.put(""content_type"", getContentType());
        }

        if (getPhotoId() != null) {
            parameters.put(""photo_id"", getPhotoId());
        }

        parameters.put(""is_public"", isPublicFlag() ? ""1"" : ""0"");
        parameters.put(""is_family"", isFamilyFlag() ? ""1"" : ""0"");
        parameters.put(""is_friend"", isFriendFlag() ? ""1"" : ""0"");
        parameters.put(""async"", isAsync() ? ""1"" : ""0"");

        return parameters;
    }

    public static UploadMetaData replace(boolean async, String photoId) {
        UploadMetaData metaData = new UploadMetaData();
        metaData.async = async;
        metaData.photoId = photoId;
        return metaData;
    }

}
","package com.flickr4java.flickr.uploader; import com.flickr4java.flickr.util.StringUtilities; import java.util.Collection; import java.util.Map; import java.util.TreeMap; public class UploadMetaData { private String filename = ""image.jpg""; private String fileMimeType = ""image/jpeg""; private String title; private String description; private Collection<String> tags; private boolean publicFlag; private boolean friendFlag; private boolean familyFlag; private boolean async; private Boolean hidden; private String safetyLevel; private String contentType; private String photoId; public String getTitle() { return title; } public UploadMetaData setTitle(String title) { this.title = title; return this; } public String getDescription() { return description; } public UploadMetaData setDescription(String description) { this.description = description; return this; } public Collection<String> getTags() { return tags; } public UploadMetaData setTags(Collection<String> tags) { this.tags = tags; return this; } public boolean isPublicFlag() { return publicFlag; } public UploadMetaData setPublicFlag(boolean publicFlag) { this.publicFlag = publicFlag; return this; } public boolean isFriendFlag() { return friendFlag; } public UploadMetaData setFriendFlag(boolean friendFlag) { this.friendFlag = friendFlag; return this; } public boolean isFamilyFlag() { return familyFlag; } public UploadMetaData setFamilyFlag(boolean familyFlag) { this.familyFlag = familyFlag; return this; } public String getContentType() { return contentType; } public UploadMetaData setContentType(String contentType) { this.contentType = contentType; return this; } public Boolean isHidden() { return hidden; } public UploadMetaData setHidden(Boolean hidden) { this.hidden = hidden; return this; } public String getSafetyLevel() { return safetyLevel; } public UploadMetaData setSafetyLevel(String safetyLevel) { this.safetyLevel = safetyLevel; return this; } public String getFilename() { return filename; } public UploadMetaData setFilename(String filename) { this.filename = filename; return this; } public String getFilemimetype() { return fileMimeType; } public void setFilemimetype(String fileMimeType) { this.fileMimeType = fileMimeType; } public boolean isAsync() { return async; } public UploadMetaData setAsync(boolean async) { this.async = async; return this; } public String getPhotoId() { return photoId; } public void setPhotoId(String photoId) { this.photoId = photoId; } public Map<String, String> getUploadParameters() { Map<String, String> parameters = new TreeMap<>(); String title = getTitle(); if (title != null) { parameters.put(""title"", title); } String description = getDescription(); if (description != null) { parameters.put(""description"", description); } Collection<String> tags = getTags(); if (tags != null) { parameters.put(""tags"", StringUtilities.join(tags, "" "")); } if (isHidden() != null) { parameters.put(""hidden"", isHidden().booleanValue() ? ""1"" : ""0""); } if (getSafetyLevel() != null) { parameters.put(""safety_level"", getSafetyLevel()); } if (getContentType() != null) { parameters.put(""content_type"", getContentType()); } if (getPhotoId() != null) { parameters.put(""photo_id"", getPhotoId()); } parameters.put(""is_public"", isPublicFlag() ? ""1"" : ""0""); parameters.put(""is_family"", isFamilyFlag() ? ""1"" : ""0""); parameters.put(""is_friend"", isFriendFlag() ? ""1"" : ""0""); parameters.put(""async"", isAsync() ? ""1"" : ""0""); return parameters; } public static UploadMetaData replace(boolean async, String photoId) { UploadMetaData metaData = new UploadMetaData(); metaData.async = async; metaData.photoId = photoId; return metaData; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.uploader; import com.flickr4java.flickr.util.StringUtilities; import java.util.Collection; import java.util.Map; import java.util.TreeMap; public class UploadMetaData { private String filename = ""image.jpg""; private String fileMimeType = ""image/jpeg""; private String title; private String description; private Collection<String> tags; private boolean publicFlag; private boolean friendFlag; private boolean familyFlag; private boolean async; private Boolean hidden; private String safetyLevel; private String contentType; private String photoId; public String getTitle() { return title; } public UploadMetaData setTitle(String title) { this.title = title; return this; } public String getDescription() { return description; } public UploadMetaData setDescription(String description) { this.description = description; return this; } public Collection<String> getTags() { return tags; } public UploadMetaData setTags(Collection<String> tags) { this.tags = tags; return this; } public boolean isPublicFlag() { return publicFlag; } public UploadMetaData setPublicFlag(boolean publicFlag) { this.publicFlag = publicFlag; return this; } public boolean isFriendFlag() { return friendFlag; } public UploadMetaData setFriendFlag(boolean friendFlag) { this.friendFlag = friendFlag; return this; } public boolean isFamilyFlag() { return familyFlag; } public UploadMetaData setFamilyFlag(boolean familyFlag) { this.familyFlag = familyFlag; return this; } public String getContentType() { return contentType; } public UploadMetaData setContentType(String contentType) { this.contentType = contentType; return this; } public Boolean isHidden() { return hidden; } public UploadMetaData setHidden(Boolean hidden) { this.hidden = hidden; return this; } public String getSafetyLevel() { return safetyLevel; } public UploadMetaData setSafetyLevel(String safetyLevel) { this.safetyLevel = safetyLevel; return this; } public String getFilename() { return filename; } public UploadMetaData setFilename(String filename) { this.filename = filename; return this; } public String getFilemimetype() { return fileMimeType; } public void setFilemimetype(String fileMimeType) { this.fileMimeType = fileMimeType; } public boolean isAsync() { return async; } public UploadMetaData setAsync(boolean async) { this.async = async; return this; } public String getPhotoId() { return photoId; } public void setPhotoId(String photoId) { this.photoId = photoId; } public Map<String, String> getUploadParameters() { Map<String, String> parameters = new TreeMap<>(); String title = getTitle(); if (title != null) { parameters.put(""title"", title); } String description = getDescription(); if (description != null) { parameters.put(""description"", description); } Collection<String> tags = getTags(); if (tags != null) { parameters.put(""tags"", StringUtilities.join(tags, "" "")); } if (isHidden() != null) { parameters.put(""hidden"", isHidden().booleanValue() ? ""1"" : ""0""); } if (getSafetyLevel() != null) { parameters.put(""safety_level"", getSafetyLevel()); } if (getContentType() != null) { parameters.put(""content_type"", getContentType()); } if (getPhotoId() != null) { parameters.put(""photo_id"", getPhotoId()); } parameters.put(""is_public"", isPublicFlag() ? ""1"" : ""0""); parameters.put(""is_family"", isFamilyFlag() ? ""1"" : ""0""); parameters.put(""is_friend"", isFriendFlag() ? ""1"" : ""0""); parameters.put(""async"", isAsync() ? ""1"" : ""0""); return parameters; } public static UploadMetaData replace(boolean async, String photoId) { UploadMetaData metaData = new UploadMetaData(); metaData.async = async; metaData.photoId = photoId; return metaData; } } ","
 package com.flickr4java.flickr.uploader;  import com.flickr4java.flickr.util.StringUtilities;  import java.util.Collection; import java.util.Map; import java.util.TreeMap;  /**
 * Metadata that describe a photo.
 * 
 * @author Anthony Eden
 * @version $Id: UploadMetaData.java,v 1.7 2007/11/02 21:46:52 x-mago Exp $
 */ public class UploadMetaData {  private String filename = ""image.jpg""; 	 private String fileMimeType = ""image/jpeg""; 	 private String title;  private String description;  private Collection<String> tags;  private boolean publicFlag;  private boolean friendFlag;  private boolean familyFlag;  private boolean async;  private Boolean hidden;  private String safetyLevel;  private String contentType;  private String photoId;  public String getTitle() { return title; }  public UploadMetaData setTitle(String title) { this.title = title;  return this; }  public String getDescription() { return description; }  public UploadMetaData setDescription(String description) { this.description = description;  return this; }  public Collection<String> getTags() { return tags; }  public UploadMetaData setTags(Collection<String> tags) { this.tags = tags;  return this; }  public boolean isPublicFlag() { return publicFlag; }  public UploadMetaData setPublicFlag(boolean publicFlag) { this.publicFlag = publicFlag;  return this; }  public boolean isFriendFlag() { return friendFlag; }  public UploadMetaData setFriendFlag(boolean friendFlag) { this.friendFlag = friendFlag;  return this; }  public boolean isFamilyFlag() { return familyFlag; }  public UploadMetaData setFamilyFlag(boolean familyFlag) { this.familyFlag = familyFlag;  return this; }  /**
     * Get the Content-type of the Photo.
     * 
     * @see com.flickr4java.flickr.Flickr#CONTENTTYPE_OTHER
     * @see com.flickr4java.flickr.Flickr#CONTENTTYPE_PHOTO
     * @see com.flickr4java.flickr.Flickr#CONTENTTYPE_SCREENSHOT
     * @return contentType
     */ public String getContentType() { return contentType; }  /**
     * Set the Content-type of the Photo.
     * 
     * @see com.flickr4java.flickr.Flickr#CONTENTTYPE_OTHER
     * @see com.flickr4java.flickr.Flickr#CONTENTTYPE_PHOTO
     * @see com.flickr4java.flickr.Flickr#CONTENTTYPE_SCREENSHOT
     * @param contentType
     */ public UploadMetaData setContentType(String contentType) { this.contentType = contentType;  return this; }  public Boolean isHidden() { return hidden; }  public UploadMetaData setHidden(Boolean hidden) { this.hidden = hidden;  return this; }  /**
     * Get the safety-level.
     * 
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_MODERATE
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_RESTRICTED
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_SAFE
     * @return The safety-level
     */ public String getSafetyLevel() { return safetyLevel; }  /**
     * Set the safety level (adultness) of a photo.
     * <p>
     * 
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_MODERATE
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_RESTRICTED
     * @see com.flickr4java.flickr.Flickr#SAFETYLEVEL_SAFE
     * @param safetyLevel
     */ public UploadMetaData setSafetyLevel(String safetyLevel) { this.safetyLevel = safetyLevel;  return this; }  /**
	 * @return the filename
	 */ public String getFilename() { return filename; }  /**
	 * @param filename the filename to set
	 */ public UploadMetaData setFilename(String filename) { this.filename = filename; 		 return this; }  public String getFilemimetype() { return fileMimeType; }  public void setFilemimetype(String fileMimeType) { this.fileMimeType = fileMimeType; }  public boolean isAsync() { return async; }  /**
     * Switch the Uploader behaviour - synchronous or asynchronous.
     * <p>
     * 
     * The default is sychronous.
     * 
     * @param async
     *            boolean
     */ public UploadMetaData setAsync(boolean async) { this.async = async;  return this; }  public String getPhotoId() { return photoId; }  /**
     * Set the existing photo id for a replace operation.
     * @param photoId
     */ public void setPhotoId(String photoId) { this.photoId = photoId; }  /**
     * Get the upload parameters.
     * @return
     */ public Map<String, String> getUploadParameters() { Map<String, String> parameters = new TreeMap<>(); 
 String title = getTitle(); if (title != null) { parameters.put(""title"", title); }  String description = getDescription(); if (description != null) { parameters.put(""description"", description); }  Collection<String> tags = getTags(); if (tags != null) { parameters.put(""tags"", StringUtilities.join(tags, "" "")); }  if (isHidden() != null) { parameters.put(""hidden"", isHidden().booleanValue() ? ""1"" : ""0""); }  if (getSafetyLevel() != null) { parameters.put(""safety_level"", getSafetyLevel()); }  if (getContentType() != null) { parameters.put(""content_type"", getContentType()); }  if (getPhotoId() != null) { parameters.put(""photo_id"", getPhotoId()); }  parameters.put(""is_public"", isPublicFlag() ? ""1"" : ""0""); parameters.put(""is_family"", isFamilyFlag() ? ""1"" : ""0""); parameters.put(""is_friend"", isFriendFlag() ? ""1"" : ""0""); parameters.put(""async"", isAsync() ? ""1"" : ""0"");  return parameters; }  public static UploadMetaData replace(boolean async, String photoId) { UploadMetaData metaData = new UploadMetaData(); metaData.async = async; metaData.photoId = photoId; return metaData; }  }  "
src/main/java/com/flickr4java/flickr/uploader/Uploader.java,"

package com.flickr4java.flickr.uploader;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.REST;
import com.flickr4java.flickr.Transport;

import java.io.File;
import java.io.InputStream;
import java.util.Set;

/**
 * Upload a photo.
 * <p>
 * 
 * Setting {@link com.flickr4java.flickr.uploader.UploadMetaData#setAsync(boolean)} you can switch between synchronous and asynchronous uploads.
 * <p>
 * 
 * Synchronous uploads return the photoId, whilst asynchronous uploads return a ticketId.
 * <p>
 * 
 * TicketId's can be tracked with {@link com.flickr4java.flickr.photos.upload.UploadInterface#checkTickets(Set)} for completion.
 * 
 * @author Anthony Eden
 * @version $Id: Uploader.java,v 1.12 2009/12/15 20:57:49 x-mago Exp $
 */
public class Uploader implements IUploader {

    private static final String SERVICES_REPLACE_PATH = ""/services/replace/"";

    private static final String SERVICES_UPLOAD_PATH = ""/services/upload/"";

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transport;

    /**
     * Construct an Uploader.
     *
     * @param apiKey
     *            The API key
     */
    public Uploader(String apiKey, String sharedSecret) {
        this(apiKey, sharedSecret, new REST(Transport.UPLOAD_API_HOST));
        this.transport.setResponseClass(UploaderResponse.class);
    }

    /**
     * Construct an Uploader.
     *
     * @param apiKey
     *            The API key
     * @param transport
     */
    public Uploader(String apiKey, String sharedSecret, Transport transport) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transport = transport;
    }

    /**
     * Upload a photo from a byte-array.
     * 
     * @param data
     *            The photo data as a byte array
     * @param metaData
     *            The meta data
     * @return photoId or ticketId
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    @Override
    public String upload(byte[] data, UploadMetaData metaData) throws FlickrException {
        Payload payload = new Payload(data);
        return sendUploadRequest(metaData, payload);
    }

    /**
     * Upload a photo from a File.
     * 
     * @param file
     *            the photo file
     * @param metaData
     *            The meta data
     * @return photoId or ticketId
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    @Override
    public String upload(File file, UploadMetaData metaData) throws FlickrException {
        Payload payload = new Payload(file);
        return sendUploadRequest(metaData, payload);
    }

    /**
     * Upload a photo from an InputStream.
     * 
     * @param in
     * @param metaData
     * @return photoId or ticketId
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    @Override
    public String upload(InputStream in, UploadMetaData metaData) throws FlickrException {
        Payload payload = new Payload(in);
        return sendUploadRequest(metaData, payload);
    }

    /**
     * Replace a photo from an InputStream.
     * 
     * @param in
     * @return photoId or ticketId
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    @Override
    public String replace(InputStream in, String flickrId, boolean async) throws FlickrException {
        Payload payload = new Payload(in, flickrId);
        return sendReplaceRequest(async, payload);
    }

    /**
     * Replace a photo from an InputStream.
     * 
     * @param data
     * @param flickrId
     * @param async
     * @return photoId or ticketId
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    @Override
    public String replace(byte[] data, String flickrId, boolean async) throws FlickrException {
        Payload payload = new Payload(data, flickrId);
        return sendReplaceRequest(async, payload);
    }

    /**
     * Replace a photo from a File.
     * 
     * @param file
     * @param flickrId
     * @param async
     * @return photoId or ticketId
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    @Override
    public String replace(File file, String flickrId, boolean async) throws FlickrException {
        Payload payload = new Payload(file, flickrId);
        return sendReplaceRequest(async, payload);
    }

    private String sendUploadRequest(UploadMetaData metaData, Payload payload) throws FlickrException {
        UploaderResponse response = (UploaderResponse) transport.postMultiPart(SERVICES_UPLOAD_PATH, metaData, payload, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        return getResponseString(metaData.isAsync(), response);
    }

    private String sendReplaceRequest(boolean async, Payload payload) throws FlickrException {
        UploaderResponse response = (UploaderResponse) transport.postMultiPart(SERVICES_REPLACE_PATH, UploadMetaData.replace(async, payload.getPhotoId()), payload, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        return getResponseString(async, response);
    }

    /**
     * Get the photo or ticket id from the response.
     * 
     * @param async
     * @param response
     * @return
     */
    private String getResponseString(boolean async, UploaderResponse response) {
        return async ? response.getTicketId() : response.getPhotoId();
    }

    /**
     * Return the {@link REST} impl used by this instance so that properties can be set on it, eg {@link REST#setConnectTimeoutMs(Integer)}. TODO: should return
     * a wrapper that only allows ""safe"" properties to be set.
     * 
     * @return The {@link REST} transport used by this instance
     */
    public REST getTransport() {
        return (REST) transport;
    }
}
","package com.flickr4java.flickr.uploader; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.REST; import com.flickr4java.flickr.Transport; import java.io.File; import java.io.InputStream; import java.util.Set; public class Uploader implements IUploader { private static final String SERVICES_REPLACE_PATH = ""/services/replace/""; private static final String SERVICES_UPLOAD_PATH = ""/services/upload/""; private final String apiKey; private final String sharedSecret; private final Transport transport; public Uploader(String apiKey, String sharedSecret) { this(apiKey, sharedSecret, new REST(Transport.UPLOAD_API_HOST)); this.transport.setResponseClass(UploaderResponse.class); } public Uploader(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transport = transport; } @Override
    public String upload(byte[] data, UploadMetaData metaData) throws FlickrException { Payload payload = new Payload(data); return sendUploadRequest(metaData, payload); } @Override
    public String upload(File file, UploadMetaData metaData) throws FlickrException { Payload payload = new Payload(file); return sendUploadRequest(metaData, payload); } @Override
    public String upload(InputStream in, UploadMetaData metaData) throws FlickrException { Payload payload = new Payload(in); return sendUploadRequest(metaData, payload); } @Override
    public String replace(InputStream in, String flickrId, boolean async) throws FlickrException { Payload payload = new Payload(in, flickrId); return sendReplaceRequest(async, payload); } @Override
    public String replace(byte[] data, String flickrId, boolean async) throws FlickrException { Payload payload = new Payload(data, flickrId); return sendReplaceRequest(async, payload); } @Override
    public String replace(File file, String flickrId, boolean async) throws FlickrException { Payload payload = new Payload(file, flickrId); return sendReplaceRequest(async, payload); } private String sendUploadRequest(UploadMetaData metaData, Payload payload) throws FlickrException { UploaderResponse response = (UploaderResponse) transport.postMultiPart(SERVICES_UPLOAD_PATH, metaData, payload, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } return getResponseString(metaData.isAsync(), response); } private String sendReplaceRequest(boolean async, Payload payload) throws FlickrException { UploaderResponse response = (UploaderResponse) transport.postMultiPart(SERVICES_REPLACE_PATH, UploadMetaData.replace(async, payload.getPhotoId()), payload, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } return getResponseString(async, response); } private String getResponseString(boolean async, UploaderResponse response) { return async ? response.getTicketId() : response.getPhotoId(); } public REST getTransport() { return (REST) transport; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.uploader; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.REST; import com.flickr4java.flickr.Transport; import java.io.File; import java.io.InputStream; import java.util.Set; public class Uploader implements IUploader { private static final String SERVICES_REPLACE_PATH = ""/services/replace/""; private static final String SERVICES_UPLOAD_PATH = ""/services/upload/""; private final String apiKey; private final String sharedSecret; private final Transport transport; public Uploader(String apiKey, String sharedSecret) { this(apiKey, sharedSecret, new REST(Transport.UPLOAD_API_HOST)); this.transport.setResponseClass(UploaderResponse.class); } public Uploader(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transport = transport; } @Override
    public String upload(byte[] data, UploadMetaData metaData) throws FlickrException { Payload payload = new Payload(data); return sendUploadRequest(metaData, payload); } @Override
    public String upload(File file, UploadMetaData metaData) throws FlickrException { Payload payload = new Payload(file); return sendUploadRequest(metaData, payload); } @Override
    public String upload(InputStream in, UploadMetaData metaData) throws FlickrException { Payload payload = new Payload(in); return sendUploadRequest(metaData, payload); } @Override
    public String replace(InputStream in, String flickrId, boolean async) throws FlickrException { Payload payload = new Payload(in, flickrId); return sendReplaceRequest(async, payload); } @Override
    public String replace(byte[] data, String flickrId, boolean async) throws FlickrException { Payload payload = new Payload(data, flickrId); return sendReplaceRequest(async, payload); } @Override
    public String replace(File file, String flickrId, boolean async) throws FlickrException { Payload payload = new Payload(file, flickrId); return sendReplaceRequest(async, payload); } private String sendUploadRequest(UploadMetaData metaData, Payload payload) throws FlickrException { UploaderResponse response = (UploaderResponse) transport.postMultiPart(SERVICES_UPLOAD_PATH, metaData, payload, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } return getResponseString(metaData.isAsync(), response); } private String sendReplaceRequest(boolean async, Payload payload) throws FlickrException { UploaderResponse response = (UploaderResponse) transport.postMultiPart(SERVICES_REPLACE_PATH, UploadMetaData.replace(async, payload.getPhotoId()), payload, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } return getResponseString(async, response); } private String getResponseString(boolean async, UploaderResponse response) { return async ? response.getTicketId() : response.getPhotoId(); } public REST getTransport() { return (REST) transport; } } ","
 package com.flickr4java.flickr.uploader;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.REST; import com.flickr4java.flickr.Transport;  import java.io.File; import java.io.InputStream; import java.util.Set;  /**
 * Upload a photo.
 * <p>
 * 
 * Setting {@link com.flickr4java.flickr.uploader.UploadMetaData#setAsync(boolean)} you can switch between synchronous and asynchronous uploads.
 * <p>
 * 
 * Synchronous uploads return the photoId, whilst asynchronous uploads return a ticketId.
 * <p>
 * 
 * TicketId's can be tracked with {@link com.flickr4java.flickr.photos.upload.UploadInterface#checkTickets(Set)} for completion.
 * 
 * @author Anthony Eden
 * @version $Id: Uploader.java,v 1.12 2009/12/15 20:57:49 x-mago Exp $
 */ public class Uploader implements IUploader {  private static final String SERVICES_REPLACE_PATH = ""/services/replace/"";  private static final String SERVICES_UPLOAD_PATH = ""/services/upload/"";  private final String apiKey;  private final String sharedSecret;  private final Transport transport;  /**
     * Construct an Uploader.
     *
     * @param apiKey
     *            The API key
     */ public Uploader(String apiKey, String sharedSecret) { this(apiKey, sharedSecret, new REST(Transport.UPLOAD_API_HOST)); this.transport.setResponseClass(UploaderResponse.class); }  /**
     * Construct an Uploader.
     *
     * @param apiKey
     *            The API key
     * @param transport
     */ public Uploader(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transport = transport; }  /**
     * Upload a photo from a byte-array.
     * 
     * @param data
     *            The photo data as a byte array
     * @param metaData
     *            The meta data
     * @return photoId or ticketId
     * @throws FlickrException if there was a problem connecting to Flickr
     */ @Override
    public String upload(byte[] data, UploadMetaData metaData) throws FlickrException { Payload payload = new Payload(data); return sendUploadRequest(metaData, payload); }  /**
     * Upload a photo from a File.
     * 
     * @param file
     *            the photo file
     * @param metaData
     *            The meta data
     * @return photoId or ticketId
     * @throws FlickrException if there was a problem connecting to Flickr
     */ @Override
    public String upload(File file, UploadMetaData metaData) throws FlickrException { Payload payload = new Payload(file); return sendUploadRequest(metaData, payload); }  /**
     * Upload a photo from an InputStream.
     * 
     * @param in
     * @param metaData
     * @return photoId or ticketId
     * @throws FlickrException if there was a problem connecting to Flickr
     */ @Override
    public String upload(InputStream in, UploadMetaData metaData) throws FlickrException { Payload payload = new Payload(in); return sendUploadRequest(metaData, payload); }  /**
     * Replace a photo from an InputStream.
     * 
     * @param in
     * @return photoId or ticketId
     * @throws FlickrException if there was a problem connecting to Flickr
     */ @Override
    public String replace(InputStream in, String flickrId, boolean async) throws FlickrException { Payload payload = new Payload(in, flickrId); return sendReplaceRequest(async, payload); }  /**
     * Replace a photo from an InputStream.
     * 
     * @param data
     * @param flickrId
     * @param async
     * @return photoId or ticketId
     * @throws FlickrException if there was a problem connecting to Flickr
     */ @Override
    public String replace(byte[] data, String flickrId, boolean async) throws FlickrException { Payload payload = new Payload(data, flickrId); return sendReplaceRequest(async, payload); }  /**
     * Replace a photo from a File.
     * 
     * @param file
     * @param flickrId
     * @param async
     * @return photoId or ticketId
     * @throws FlickrException if there was a problem connecting to Flickr
     */ @Override
    public String replace(File file, String flickrId, boolean async) throws FlickrException { Payload payload = new Payload(file, flickrId); return sendReplaceRequest(async, payload); }  private String sendUploadRequest(UploadMetaData metaData, Payload payload) throws FlickrException { UploaderResponse response = (UploaderResponse) transport.postMultiPart(SERVICES_UPLOAD_PATH, metaData, payload, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  return getResponseString(metaData.isAsync(), response); }  private String sendReplaceRequest(boolean async, Payload payload) throws FlickrException { UploaderResponse response = (UploaderResponse) transport.postMultiPart(SERVICES_REPLACE_PATH, UploadMetaData.replace(async, payload.getPhotoId()), payload, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  return getResponseString(async, response); }  /**
     * Get the photo or ticket id from the response.
     * 
     * @param async
     * @param response
     * @return
     */ private String getResponseString(boolean async, UploaderResponse response) { return async ? response.getTicketId() : response.getPhotoId(); }  /**
     * Return the {@link REST} impl used by this instance so that properties can be set on it, eg {@link REST#setConnectTimeoutMs(Integer)}. TODO: should return
     * a wrapper that only allows ""safe"" properties to be set.
     * 
     * @return The {@link REST} transport used by this instance
     */ public REST getTransport() { return (REST) transport; } }  "
src/main/java/com/flickr4java/flickr/uploader/UploaderResponse.java,"

package com.flickr4java.flickr.uploader;

import com.flickr4java.flickr.Response;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Text;

import java.util.Collection;

/**
 * Parsing the response after an upload.
 * 
 * @author Anthony Eden
 * @version $Id: UploaderResponse.java,v 1.7 2007/11/02 21:46:52 x-mago Exp $
 */
public class UploaderResponse implements Response {

    private String status;

    private String photoId;

    private String ticketId;

    private String errorCode;

    private String errorMessage;

    private Element responsePayLoad;

    /**
     * Parsing the response.
     * <p>
     * After a successful sychronous upload the photId is set.<br>
     * After an asychronous upload the ticketId.
     * 
     * @see #getPhotoId()
     * @see #getTicketId()
     */
    public void parse(Document document) {
        responsePayLoad = document.getDocumentElement();
        status = responsePayLoad.getAttribute(""stat"");
        if (""ok"".equals(status)) {
            Element photoIdElement = (Element) responsePayLoad.getElementsByTagName(""photoid"").item(0);
            if (photoIdElement != null) {
                photoId = ((Text) photoIdElement.getFirstChild()).getData();
            } else {
                photoId = null;
            }
            Element ticketIdElement = (Element) responsePayLoad.getElementsByTagName(""ticketid"").item(0);
            if (ticketIdElement != null) {
                ticketId = ((Text) ticketIdElement.getFirstChild()).getData();
            } else {
                ticketId = null;
            }
        } else {
            Element errElement = (Element) responsePayLoad.getElementsByTagName(""err"").item(0);
            errorCode = errElement.getAttribute(""code"");
            errorMessage = errElement.getAttribute(""msg"");
        }
    }

    public String getStatus() {
        return status;
    }

    public String getPhotoId() {
        return photoId;
    }

    public String getTicketId() {
        return ticketId;
    }

    public boolean isError() {
        return errorMessage != null;
    }

    public String getErrorCode() {
        return errorCode;
    }

    public String getErrorMessage() {
        return errorMessage;
    }

    /**
     * @see com.flickr4java.flickr.Response#getPayload()
     */
    public Element getPayload() {
        return responsePayLoad;
    }

    /**
     * @see com.flickr4java.flickr.Response#getPayloadCollection()
     */
    public Collection<Element> getPayloadCollection() {
        return null;
    }

}
","package com.flickr4java.flickr.uploader; import com.flickr4java.flickr.Response; import org.w3c.dom.Document; import org.w3c.dom.Element; import org.w3c.dom.Text; import java.util.Collection; public class UploaderResponse implements Response { private String status; private String photoId; private String ticketId; private String errorCode; private String errorMessage; private Element responsePayLoad; public void parse(Document document) { responsePayLoad = document.getDocumentElement(); status = responsePayLoad.getAttribute(""stat""); if (""ok"".equals(status)) { Element photoIdElement = (Element) responsePayLoad.getElementsByTagName(""photoid"").item(0); if (photoIdElement != null) { photoId = ((Text) photoIdElement.getFirstChild()).getData(); } else { photoId = null; } Element ticketIdElement = (Element) responsePayLoad.getElementsByTagName(""ticketid"").item(0); if (ticketIdElement != null) { ticketId = ((Text) ticketIdElement.getFirstChild()).getData(); } else { ticketId = null; } } else { Element errElement = (Element) responsePayLoad.getElementsByTagName(""err"").item(0); errorCode = errElement.getAttribute(""code""); errorMessage = errElement.getAttribute(""msg""); } } public String getStatus() { return status; } public String getPhotoId() { return photoId; } public String getTicketId() { return ticketId; } public boolean isError() { return errorMessage != null; } public String getErrorCode() { return errorCode; } public String getErrorMessage() { return errorMessage; } public Element getPayload() { return responsePayLoad; } public Collection<Element> getPayloadCollection() { return null; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.uploader; import com.flickr4java.flickr.Response; import org.w3c.dom.Document; import org.w3c.dom.Element; import org.w3c.dom.Text; import java.util.Collection; public class UploaderResponse implements Response { private String status; private String photoId; private String ticketId; private String errorCode; private String errorMessage; private Element responsePayLoad; public void parse(Document document) { responsePayLoad = document.getDocumentElement(); status = responsePayLoad.getAttribute(""stat""); if (""ok"".equals(status)) { Element photoIdElement = (Element) responsePayLoad.getElementsByTagName(""photoid"").item(0); if (photoIdElement != null) { photoId = ((Text) photoIdElement.getFirstChild()).getData(); } else { photoId = null; } Element ticketIdElement = (Element) responsePayLoad.getElementsByTagName(""ticketid"").item(0); if (ticketIdElement != null) { ticketId = ((Text) ticketIdElement.getFirstChild()).getData(); } else { ticketId = null; } } else { Element errElement = (Element) responsePayLoad.getElementsByTagName(""err"").item(0); errorCode = errElement.getAttribute(""code""); errorMessage = errElement.getAttribute(""msg""); } } public String getStatus() { return status; } public String getPhotoId() { return photoId; } public String getTicketId() { return ticketId; } public boolean isError() { return errorMessage != null; } public String getErrorCode() { return errorCode; } public String getErrorMessage() { return errorMessage; } public Element getPayload() { return responsePayLoad; } public Collection<Element> getPayloadCollection() { return null; } } ","
 package com.flickr4java.flickr.uploader;  import com.flickr4java.flickr.Response;  import org.w3c.dom.Document; import org.w3c.dom.Element; import org.w3c.dom.Text;  import java.util.Collection;  /**
 * Parsing the response after an upload.
 * 
 * @author Anthony Eden
 * @version $Id: UploaderResponse.java,v 1.7 2007/11/02 21:46:52 x-mago Exp $
 */ public class UploaderResponse implements Response {  private String status;  private String photoId;  private String ticketId;  private String errorCode;  private String errorMessage;  private Element responsePayLoad;  /**
     * Parsing the response.
     * <p>
     * After a successful sychronous upload the photId is set.<br>
     * After an asychronous upload the ticketId.
     * 
     * @see #getPhotoId()
     * @see #getTicketId()
     */ public void parse(Document document) { responsePayLoad = document.getDocumentElement(); status = responsePayLoad.getAttribute(""stat""); if (""ok"".equals(status)) { Element photoIdElement = (Element) responsePayLoad.getElementsByTagName(""photoid"").item(0); if (photoIdElement != null) { photoId = ((Text) photoIdElement.getFirstChild()).getData(); } else { photoId = null; } Element ticketIdElement = (Element) responsePayLoad.getElementsByTagName(""ticketid"").item(0); if (ticketIdElement != null) { ticketId = ((Text) ticketIdElement.getFirstChild()).getData(); } else { ticketId = null; } } else { Element errElement = (Element) responsePayLoad.getElementsByTagName(""err"").item(0); errorCode = errElement.getAttribute(""code""); errorMessage = errElement.getAttribute(""msg""); } }  public String getStatus() { return status; }  public String getPhotoId() { return photoId; }  public String getTicketId() { return ticketId; }  public boolean isError() { return errorMessage != null; }  public String getErrorCode() { return errorCode; }  public String getErrorMessage() { return errorMessage; }  /**
     * @see com.flickr4java.flickr.Response#getPayload()
     */ public Element getPayload() { return responsePayLoad; }  /**
     * @see com.flickr4java.flickr.Response#getPayloadCollection()
     */ public Collection<Element> getPayloadCollection() { return null; }  }  "
src/main/java/com/flickr4java/flickr/urls/UrlsInterface.java,"
package com.flickr4java.flickr.urls;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.galleries.Gallery;
import com.flickr4java.flickr.groups.Group;
import com.flickr4java.flickr.people.User;
import com.flickr4java.flickr.util.XMLUtilities;

import org.w3c.dom.Element;
import org.w3c.dom.Text;

import java.util.HashMap;
import java.util.Map;

/**
 * Interface for testing Flickr connectivity.
 * 
 * @author Anthony Eden
 */
public class UrlsInterface {

    public static final String METHOD_GET_GROUP = ""flickr.urls.getGroup"";

    public static final String METHOD_GET_USER_PHOTOS = ""flickr.urls.getUserPhotos"";

    public static final String METHOD_GET_USER_PROFILE = ""flickr.urls.getUserProfile"";

    public static final String METHOD_LOOKUP_GROUP = ""flickr.urls.lookupGroup"";

    public static final String METHOD_LOOKUP_USER = ""flickr.urls.lookupUser"";

    public static final String METHOD_LOOKUP_GALLERY = ""flickr.urls.lookupGallery"";

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transport;

    /**
     * Construct a UrlsInterface.
     * 
     * @param apiKey
     *            The API key
     * @param transportAPI
     *            The Transport interface
     */
    public UrlsInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transport = transportAPI;
    }

    /**
     * Get the group URL for the specified group ID
     * 
     * @param groupId
     *            The group ID
     * @return The group URL
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public String getGroup(String groupId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_GROUP);

        parameters.put(""group_id"", groupId);

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element payload = response.getPayload();
        return payload.getAttribute(""url"");
    }

    /**
     * Get the URL for the user's photos.
     * 
     * @param userId
     *            The user ID
     * @return The user photo URL
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public String getUserPhotos(String userId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_USER_PHOTOS);

        parameters.put(""user_id"", userId);

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element payload = response.getPayload();
        return payload.getAttribute(""url"");
    }

    /**
     * Get the URL for the user's profile.
     * 
     * @param userId
     *            The user ID
     * @return The URL
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public String getUserProfile(String userId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_USER_PROFILE);

        parameters.put(""user_id"", userId);

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element payload = response.getPayload();
        return payload.getAttribute(""url"");
    }

    /**
     * Lookup the group for the specified URL.
     * 
     * @param url
     *            The url
     * @return The group
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Group lookupGroup(String url) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_LOOKUP_GROUP);

        parameters.put(""url"", url);

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Group group = new Group();
        Element payload = response.getPayload();
        Element groupnameElement = (Element) payload.getElementsByTagName(""groupname"").item(0);
        group.setId(payload.getAttribute(""id""));
        group.setName(((Text) groupnameElement.getFirstChild()).getData());
        return group;
    }

    /**
     * Lookup the username for the specified User URL.
     *
     * @param url
     *            The user profile URL
     * @return The username
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public String lookupUsernameByURL(String url) throws FlickrException {
        return lookupUserByURL(url).getUsername();
    }

    /**
     * Lookup the username for the specified User URL.
     * 
     * @param url
     *            The user profile URL
     * @return The username
     * @throws FlickrException if there was a problem connecting to Flickr
     * @deprecated use {@link #lookupUsernameByURL(String) }
     */
    @Deprecated
    public String lookupUser(String url) throws FlickrException {
        return lookupUsernameByURL(url);
    }

    /**
     * Lookup the user for the specified User URL.
     *
     * @param url
     *            The user profile URL
     * @return The user
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public User lookupUserByURL(String url) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_LOOKUP_USER);

        parameters.put(""url"", url);

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element payload = response.getPayload();
        Element groupnameElement = (Element) payload.getElementsByTagName(""username"").item(0);
        User user = new User();
        user.setId(payload.getAttribute(""id""));
        user.setUsername(((Text) groupnameElement.getFirstChild()).getData());
        return user;
    }

    /**
     * Lookup the Gallery for the specified ID.
     * 
     * @param galleryId
     *            The user profile URL
     * @return The Gallery
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Gallery lookupGallery(String galleryId) throws FlickrException {

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_LOOKUP_GALLERY);
        parameters.put(""url"", galleryId);

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element galleryElement = response.getPayload();
        Gallery gallery = new Gallery();
        gallery.setId(galleryElement.getAttribute(""id""));
        gallery.setUrl(galleryElement.getAttribute(""url""));

        User owner = new User();
        owner.setId(galleryElement.getAttribute(""owner""));
        gallery.setOwner(owner);
        gallery.setCreateDate(galleryElement.getAttribute(""date_create""));
        gallery.setUpdateDate(galleryElement.getAttribute(""date_update""));
        gallery.setPrimaryPhotoId(galleryElement.getAttribute(""primary_photo_id""));
        gallery.setPrimaryPhotoServer(galleryElement.getAttribute(""primary_photo_server""));
        gallery.setVideoCount(galleryElement.getAttribute(""count_videos""));
        gallery.setPhotoCount(galleryElement.getAttribute(""count_photos""));
        gallery.setPrimaryPhotoFarm(galleryElement.getAttribute(""farm""));
        gallery.setPrimaryPhotoSecret(galleryElement.getAttribute(""secret""));

        gallery.setTitle(XMLUtilities.getChildValue(galleryElement, ""title""));
        gallery.setDesc(XMLUtilities.getChildValue(galleryElement, ""description""));
        return gallery;
    }

}
","package com.flickr4java.flickr.urls; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.galleries.Gallery; import com.flickr4java.flickr.groups.Group; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.Text; import java.util.HashMap; import java.util.Map; public class UrlsInterface { public static final String METHOD_GET_GROUP = ""flickr.urls.getGroup""; public static final String METHOD_GET_USER_PHOTOS = ""flickr.urls.getUserPhotos""; public static final String METHOD_GET_USER_PROFILE = ""flickr.urls.getUserProfile""; public static final String METHOD_LOOKUP_GROUP = ""flickr.urls.lookupGroup""; public static final String METHOD_LOOKUP_USER = ""flickr.urls.lookupUser""; public static final String METHOD_LOOKUP_GALLERY = ""flickr.urls.lookupGallery""; private final String apiKey; private final String sharedSecret; private final Transport transport; public UrlsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transport = transportAPI; } public String getGroup(String groupId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_GROUP); parameters.put(""group_id"", groupId); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element payload = response.getPayload(); return payload.getAttribute(""url""); } public String getUserPhotos(String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_USER_PHOTOS); parameters.put(""user_id"", userId); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element payload = response.getPayload(); return payload.getAttribute(""url""); } public String getUserProfile(String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_USER_PROFILE); parameters.put(""user_id"", userId); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element payload = response.getPayload(); return payload.getAttribute(""url""); } public Group lookupGroup(String url) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_LOOKUP_GROUP); parameters.put(""url"", url); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Group group = new Group(); Element payload = response.getPayload(); Element groupnameElement = (Element) payload.getElementsByTagName(""groupname"").item(0); group.setId(payload.getAttribute(""id"")); group.setName(((Text) groupnameElement.getFirstChild()).getData()); return group; } public String lookupUsernameByURL(String url) throws FlickrException { return lookupUserByURL(url).getUsername(); } @Deprecated
    public String lookupUser(String url) throws FlickrException { return lookupUsernameByURL(url); } public User lookupUserByURL(String url) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_LOOKUP_USER); parameters.put(""url"", url); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element payload = response.getPayload(); Element groupnameElement = (Element) payload.getElementsByTagName(""username"").item(0); User user = new User(); user.setId(payload.getAttribute(""id"")); user.setUsername(((Text) groupnameElement.getFirstChild()).getData()); return user; } public Gallery lookupGallery(String galleryId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_LOOKUP_GALLERY); parameters.put(""url"", galleryId); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element galleryElement = response.getPayload(); Gallery gallery = new Gallery(); gallery.setId(galleryElement.getAttribute(""id"")); gallery.setUrl(galleryElement.getAttribute(""url"")); User owner = new User(); owner.setId(galleryElement.getAttribute(""owner"")); gallery.setOwner(owner); gallery.setCreateDate(galleryElement.getAttribute(""date_create"")); gallery.setUpdateDate(galleryElement.getAttribute(""date_update"")); gallery.setPrimaryPhotoId(galleryElement.getAttribute(""primary_photo_id"")); gallery.setPrimaryPhotoServer(galleryElement.getAttribute(""primary_photo_server"")); gallery.setVideoCount(galleryElement.getAttribute(""count_videos"")); gallery.setPhotoCount(galleryElement.getAttribute(""count_photos"")); gallery.setPrimaryPhotoFarm(galleryElement.getAttribute(""farm"")); gallery.setPrimaryPhotoSecret(galleryElement.getAttribute(""secret"")); gallery.setTitle(XMLUtilities.getChildValue(galleryElement, ""title"")); gallery.setDesc(XMLUtilities.getChildValue(galleryElement, ""description"")); return gallery; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.urls; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.galleries.Gallery; import com.flickr4java.flickr.groups.Group; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.Text; import java.util.HashMap; import java.util.Map; public class UrlsInterface { public static final String METHOD_GET_GROUP = ""flickr.urls.getGroup""; public static final String METHOD_GET_USER_PHOTOS = ""flickr.urls.getUserPhotos""; public static final String METHOD_GET_USER_PROFILE = ""flickr.urls.getUserProfile""; public static final String METHOD_LOOKUP_GROUP = ""flickr.urls.lookupGroup""; public static final String METHOD_LOOKUP_USER = ""flickr.urls.lookupUser""; public static final String METHOD_LOOKUP_GALLERY = ""flickr.urls.lookupGallery""; private final String apiKey; private final String sharedSecret; private final Transport transport; public UrlsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transport = transportAPI; } public String getGroup(String groupId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_GROUP); parameters.put(""group_id"", groupId); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element payload = response.getPayload(); return payload.getAttribute(""url""); } public String getUserPhotos(String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_USER_PHOTOS); parameters.put(""user_id"", userId); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element payload = response.getPayload(); return payload.getAttribute(""url""); } public String getUserProfile(String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_USER_PROFILE); parameters.put(""user_id"", userId); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element payload = response.getPayload(); return payload.getAttribute(""url""); } public Group lookupGroup(String url) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_LOOKUP_GROUP); parameters.put(""url"", url); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Group group = new Group(); Element payload = response.getPayload(); Element groupnameElement = (Element) payload.getElementsByTagName(""groupname"").item(0); group.setId(payload.getAttribute(""id"")); group.setName(((Text) groupnameElement.getFirstChild()).getData()); return group; } public String lookupUsernameByURL(String url) throws FlickrException { return lookupUserByURL(url).getUsername(); } @Deprecated
    public String lookupUser(String url) throws FlickrException { return lookupUsernameByURL(url); } public User lookupUserByURL(String url) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_LOOKUP_USER); parameters.put(""url"", url); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element payload = response.getPayload(); Element groupnameElement = (Element) payload.getElementsByTagName(""username"").item(0); User user = new User(); user.setId(payload.getAttribute(""id"")); user.setUsername(((Text) groupnameElement.getFirstChild()).getData()); return user; } public Gallery lookupGallery(String galleryId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_LOOKUP_GALLERY); parameters.put(""url"", galleryId); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element galleryElement = response.getPayload(); Gallery gallery = new Gallery(); gallery.setId(galleryElement.getAttribute(""id"")); gallery.setUrl(galleryElement.getAttribute(""url"")); User owner = new User(); owner.setId(galleryElement.getAttribute(""owner"")); gallery.setOwner(owner); gallery.setCreateDate(galleryElement.getAttribute(""date_create"")); gallery.setUpdateDate(galleryElement.getAttribute(""date_update"")); gallery.setPrimaryPhotoId(galleryElement.getAttribute(""primary_photo_id"")); gallery.setPrimaryPhotoServer(galleryElement.getAttribute(""primary_photo_server"")); gallery.setVideoCount(galleryElement.getAttribute(""count_videos"")); gallery.setPhotoCount(galleryElement.getAttribute(""count_photos"")); gallery.setPrimaryPhotoFarm(galleryElement.getAttribute(""farm"")); gallery.setPrimaryPhotoSecret(galleryElement.getAttribute(""secret"")); gallery.setTitle(XMLUtilities.getChildValue(galleryElement, ""title"")); gallery.setDesc(XMLUtilities.getChildValue(galleryElement, ""description"")); return gallery; } } "," package com.flickr4java.flickr.urls;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.galleries.Gallery; import com.flickr4java.flickr.groups.Group; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.util.XMLUtilities;  import org.w3c.dom.Element; import org.w3c.dom.Text;  import java.util.HashMap; import java.util.Map;  /**
 * Interface for testing Flickr connectivity.
 * 
 * @author Anthony Eden
 */ public class UrlsInterface {  public static final String METHOD_GET_GROUP = ""flickr.urls.getGroup"";  public static final String METHOD_GET_USER_PHOTOS = ""flickr.urls.getUserPhotos"";  public static final String METHOD_GET_USER_PROFILE = ""flickr.urls.getUserProfile"";  public static final String METHOD_LOOKUP_GROUP = ""flickr.urls.lookupGroup"";  public static final String METHOD_LOOKUP_USER = ""flickr.urls.lookupUser"";  public static final String METHOD_LOOKUP_GALLERY = ""flickr.urls.lookupGallery"";  private final String apiKey;  private final String sharedSecret;  private final Transport transport;  /**
     * Construct a UrlsInterface.
     * 
     * @param apiKey
     *            The API key
     * @param transportAPI
     *            The Transport interface
     */ public UrlsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transport = transportAPI; }  /**
     * Get the group URL for the specified group ID
     * 
     * @param groupId
     *            The group ID
     * @return The group URL
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public String getGroup(String groupId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_GROUP);  parameters.put(""group_id"", groupId);  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element payload = response.getPayload(); return payload.getAttribute(""url""); }  /**
     * Get the URL for the user's photos.
     * 
     * @param userId
     *            The user ID
     * @return The user photo URL
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public String getUserPhotos(String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_USER_PHOTOS);  parameters.put(""user_id"", userId);  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element payload = response.getPayload(); return payload.getAttribute(""url""); }  /**
     * Get the URL for the user's profile.
     * 
     * @param userId
     *            The user ID
     * @return The URL
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public String getUserProfile(String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_USER_PROFILE);  parameters.put(""user_id"", userId);  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element payload = response.getPayload(); return payload.getAttribute(""url""); }  /**
     * Lookup the group for the specified URL.
     * 
     * @param url
     *            The url
     * @return The group
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Group lookupGroup(String url) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_LOOKUP_GROUP);  parameters.put(""url"", url);  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Group group = new Group(); Element payload = response.getPayload(); Element groupnameElement = (Element) payload.getElementsByTagName(""groupname"").item(0); group.setId(payload.getAttribute(""id"")); group.setName(((Text) groupnameElement.getFirstChild()).getData()); return group; }  /**
     * Lookup the username for the specified User URL.
     *
     * @param url
     *            The user profile URL
     * @return The username
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public String lookupUsernameByURL(String url) throws FlickrException { return lookupUserByURL(url).getUsername(); }  /**
     * Lookup the username for the specified User URL.
     * 
     * @param url
     *            The user profile URL
     * @return The username
     * @throws FlickrException if there was a problem connecting to Flickr
     * @deprecated use {@link #lookupUsernameByURL(String) }
     */ @Deprecated
    public String lookupUser(String url) throws FlickrException { return lookupUsernameByURL(url); }  /**
     * Lookup the user for the specified User URL.
     *
     * @param url
     *            The user profile URL
     * @return The user
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public User lookupUserByURL(String url) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_LOOKUP_USER);  parameters.put(""url"", url);  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element payload = response.getPayload(); Element groupnameElement = (Element) payload.getElementsByTagName(""username"").item(0); User user = new User(); user.setId(payload.getAttribute(""id"")); user.setUsername(((Text) groupnameElement.getFirstChild()).getData()); return user; }  /**
     * Lookup the Gallery for the specified ID.
     * 
     * @param galleryId
     *            The user profile URL
     * @return The Gallery
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Gallery lookupGallery(String galleryId) throws FlickrException {  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_LOOKUP_GALLERY); parameters.put(""url"", galleryId);  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element galleryElement = response.getPayload(); Gallery gallery = new Gallery(); gallery.setId(galleryElement.getAttribute(""id"")); gallery.setUrl(galleryElement.getAttribute(""url""));  User owner = new User(); owner.setId(galleryElement.getAttribute(""owner"")); gallery.setOwner(owner); gallery.setCreateDate(galleryElement.getAttribute(""date_create"")); gallery.setUpdateDate(galleryElement.getAttribute(""date_update"")); gallery.setPrimaryPhotoId(galleryElement.getAttribute(""primary_photo_id"")); gallery.setPrimaryPhotoServer(galleryElement.getAttribute(""primary_photo_server"")); gallery.setVideoCount(galleryElement.getAttribute(""count_videos"")); gallery.setPhotoCount(galleryElement.getAttribute(""count_photos"")); gallery.setPrimaryPhotoFarm(galleryElement.getAttribute(""farm"")); gallery.setPrimaryPhotoSecret(galleryElement.getAttribute(""secret""));  gallery.setTitle(XMLUtilities.getChildValue(galleryElement, ""title"")); gallery.setDesc(XMLUtilities.getChildValue(galleryElement, ""description"")); return gallery; }  }  "
src/main/java/com/flickr4java/flickr/util/AuthStore.java,"/**
 * 
 */
package com.flickr4java.flickr.util;

import com.flickr4java.flickr.auth.Auth;

import java.io.IOException;

/**
 * Defines an interface for possibly persistent storage of token information.
 * 
 * @author Matthew MacKenzie
 * @version $Id: AuthStore.java,v 1.2 2007/09/09 17:15:57 x-mago Exp $
 */
public interface AuthStore {
    /**
     * Store an Auth.
     * 
     * @param token
     *            Auth object to be stored.
     * @throws IOException
     */
    void store(Auth token) throws IOException;

    /**
     * Retrieve Auth for a given NSID.
     * 
     * @param nsid
     *            NSID
     * @return Auth
     */
    Auth retrieve(String nsid);

    /**
     * Retrieve all Auth objects being stored.
     * 
     * @return Auth objects
     */
    Auth[] retrieveAll();

    /**
     * Clear out the store.
     * 
     */
    void clearAll();

    /**
     * Clear for a given NSID.
     * 
     * @param nsid
     */
    void clear(String nsid);
}
",package com.flickr4java.flickr.util; import com.flickr4java.flickr.auth.Auth; import java.io.IOException; public interface AuthStore { void store(Auth token) throws IOException; Auth retrieve(String nsid); Auth[] retrieveAll(); void clearAll(); void clear(String nsid); },0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.util; import com.flickr4java.flickr.auth.Auth; import java.io.IOException; public interface AuthStore { void store(Auth token) throws IOException; Auth retrieve(String nsid); Auth[] retrieveAll(); void clearAll(); void clear(String nsid); } ,"/**
 * 
 */ package com.flickr4java.flickr.util;  import com.flickr4java.flickr.auth.Auth;  import java.io.IOException;  /**
 * Defines an interface for possibly persistent storage of token information.
 * 
 * @author Matthew MacKenzie
 * @version $Id: AuthStore.java,v 1.2 2007/09/09 17:15:57 x-mago Exp $
 */ public interface AuthStore { /**
     * Store an Auth.
     * 
     * @param token
     *            Auth object to be stored.
     * @throws IOException
     */ void store(Auth token) throws IOException;  /**
     * Retrieve Auth for a given NSID.
     * 
     * @param nsid
     *            NSID
     * @return Auth
     */ Auth retrieve(String nsid);  /**
     * Retrieve all Auth objects being stored.
     * 
     * @return Auth objects
     */ Auth[] retrieveAll();  /**
     * Clear out the store.
     * 
     */ void clearAll();  /**
     * Clear for a given NSID.
     * 
     * @param nsid
     */ void clear(String nsid); }  "
src/main/java/com/flickr4java/flickr/util/BuddyIconable.java,"package com.flickr4java.flickr.util;

/**
 * Defines an interface for methods needed to get a BuddyIconUrl.
 * 
 * @author mago
 * @version $Id: BuddyIconable.java,v 1.1 2008/01/11 21:02:55 x-mago Exp $
 */
public interface BuddyIconable {
    String getBuddyIconUrl();

    int getIconFarm();

    int getIconServer();

    void setIconFarm(int iconFarm);

    void setIconFarm(String iconFarm);

    void setIconServer(int iconServer);

    void setIconServer(String iconServer);
}
",package com.flickr4java.flickr.util; public interface BuddyIconable { String getBuddyIconUrl(); int getIconFarm(); int getIconServer(); void setIconFarm(int iconFarm); void setIconFarm(String iconFarm); void setIconServer(int iconServer); void setIconServer(String iconServer); },0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.util; public interface BuddyIconable { String getBuddyIconUrl(); int getIconFarm(); int getIconServer(); void setIconFarm(int iconFarm); void setIconFarm(String iconFarm); void setIconServer(int iconServer); void setIconServer(String iconServer); } ,"package com.flickr4java.flickr.util;  /**
 * Defines an interface for methods needed to get a BuddyIconUrl.
 * 
 * @author mago
 * @version $Id: BuddyIconable.java,v 1.1 2008/01/11 21:02:55 x-mago Exp $
 */ public interface BuddyIconable { String getBuddyIconUrl();  int getIconFarm();  int getIconServer();  void setIconFarm(int iconFarm);  void setIconFarm(String iconFarm);  void setIconServer(int iconServer);  void setIconServer(String iconServer); }  "
src/main/java/com/flickr4java/flickr/util/ByteUtilities.java,"

package com.flickr4java.flickr.util;

/**
 * Byte utilities.
 * 
 * @author Anthony Eden
 */
public class ByteUtilities {

    static char[] hexChar = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };

    /**
     * Convert a byte array to a hex string.
     * 
     * @param b
     *            The byte array
     * @return The hex String
     */
    public static String toHexString(byte[] b) {
        StringBuffer sb = new StringBuffer(b.length * 2);
        for (int i = 0; i < b.length; i++) {
            // look up high nibble char
            sb.append(hexChar[(b[i] & 0xf0) >>> 4]);

            // look up low nibble char
            sb.append(hexChar[b[i] & 0x0f]);
        }
        return sb.toString();
    }

}
","package com.flickr4java.flickr.util; public class ByteUtilities { static char[] hexChar = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' } ; public static String toHexString(byte[] b) { StringBuffer sb = new StringBuffer(b.length * 2); for (int i = 0; i < b.length; i++) { sb.append(hexChar[(b[i] & 0xf0) >>> 4]); sb.append(hexChar[b[i] & 0x0f]); } return sb.toString(); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.util; public class ByteUtilities { static char[] hexChar = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' } ; public static String toHexString(byte[] b) { StringBuffer sb = new StringBuffer(b.length * 2); for (int i = 0; i < b.length; i++) { sb.append(hexChar[(b[i] & 0xf0) >>> 4]); sb.append(hexChar[b[i] & 0x0f]); } return sb.toString(); } } ","
 package com.flickr4java.flickr.util;  /**
 * Byte utilities.
 * 
 * @author Anthony Eden
 */ public class ByteUtilities {  static char[] hexChar = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' } ;  /**
     * Convert a byte array to a hex string.
     * 
     * @param b
     *            The byte array
     * @return The hex String
     */ public static String toHexString(byte[] b) { StringBuffer sb = new StringBuffer(b.length * 2); for (int i = 0; i < b.length; i++) { // look up high nibble char sb.append(hexChar[(b[i] & 0xf0) >>> 4]);  // look up low nibble char sb.append(hexChar[b[i] & 0x0f]); } return sb.toString(); }  }  "
src/main/java/com/flickr4java/flickr/util/DebugInputStream.java,"

package com.flickr4java.flickr.util;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

/**
 * A FilterInputStream which will print all read data to the specified PrintWriter.
 * 
 * @author Anthony Eden
 */
public class DebugInputStream extends FilterInputStream {

    private OutputStream debugOut;

    /**
     * Creates a <code>FilterInputStream</code> by assigning the argument <code>in</code> to the field <code>this.in</code> so as to remember it for later use.
     * 
     * @param in
     *            the underlying input stream, or <code>null</code> if this instance is to be created without an underlying stream.
     */
    public DebugInputStream(InputStream in, OutputStream debugOut) {
        super(in);
        this.debugOut = debugOut;
    }

    public int read() throws IOException {
        int c = super.read();
        debugOut.write((char) c);
        return c;
    }

    public int read(byte[] b) throws IOException {
        int readCount = super.read(b);
        for (int i = 0; i < readCount; i++) {
            debugOut.write((char) b[i]);
        }
        return readCount;
    }

    public int read(byte[] b, int offset, int length) throws IOException {
        int readCount = super.read(b, offset, length);
        int readTo = offset + readCount;
        for (int i = offset; i < readTo; i++) {
            debugOut.write((char) b[i]);
        }
        return readCount;
    }

}
","package com.flickr4java.flickr.util; import java.io.FilterInputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; public class DebugInputStream extends FilterInputStream { private OutputStream debugOut; public DebugInputStream(InputStream in, OutputStream debugOut) { super(in); this.debugOut = debugOut; } public int read() throws IOException { int c = super.read(); debugOut.write((char) c); return c; } public int read(byte[] b) throws IOException { int readCount = super.read(b); for (int i = 0; i < readCount; i++) { debugOut.write((char) b[i]); } return readCount; } public int read(byte[] b, int offset, int length) throws IOException { int readCount = super.read(b, offset, length); int readTo = offset + readCount; for (int i = offset; i < readTo; i++) { debugOut.write((char) b[i]); } return readCount; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.util; import java.io.FilterInputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; public class DebugInputStream extends FilterInputStream { private OutputStream debugOut; public DebugInputStream(InputStream in, OutputStream debugOut) { super(in); this.debugOut = debugOut; } public int read() throws IOException { int c = super.read(); debugOut.write((char) c); return c; } public int read(byte[] b) throws IOException { int readCount = super.read(b); for (int i = 0; i < readCount; i++) { debugOut.write((char) b[i]); } return readCount; } public int read(byte[] b, int offset, int length) throws IOException { int readCount = super.read(b, offset, length); int readTo = offset + readCount; for (int i = offset; i < readTo; i++) { debugOut.write((char) b[i]); } return readCount; } } ","
 package com.flickr4java.flickr.util;  import java.io.FilterInputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream;  /**
 * A FilterInputStream which will print all read data to the specified PrintWriter.
 * 
 * @author Anthony Eden
 */ public class DebugInputStream extends FilterInputStream {  private OutputStream debugOut;  /**
     * Creates a <code>FilterInputStream</code> by assigning the argument <code>in</code> to the field <code>this.in</code> so as to remember it for later use.
     * 
     * @param in
     *            the underlying input stream, or <code>null</code> if this instance is to be created without an underlying stream.
     */ public DebugInputStream(InputStream in, OutputStream debugOut) { super(in); this.debugOut = debugOut; }  public int read() throws IOException { int c = super.read(); debugOut.write((char) c); return c; }  public int read(byte[] b) throws IOException { int readCount = super.read(b); for (int i = 0; i < readCount; i++) { debugOut.write((char) b[i]); } return readCount; }  public int read(byte[] b, int offset, int length) throws IOException { int readCount = super.read(b, offset, length); int readTo = offset + readCount; for (int i = offset; i < readTo; i++) { debugOut.write((char) b[i]); } return readCount; }  }  "
src/main/java/com/flickr4java/flickr/util/DebugOutputStream.java,"

package com.flickr4java.flickr.util;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;

/**
 * A FilterInputStream which will print all read data to the specified PrintWriter.
 * 
 * @author Anthony Eden
 */
public class DebugOutputStream extends FilterOutputStream {

    private OutputStream debugOut;

    /**
     * Creates a <code>FilterInputStream</code> by assigning the argument <code>in</code> to the field <code>this.in</code> so as to remember it for later use.
     * 
     * @param out
     *            the underlying output stream, or <code>null</code> if this instance is to be created without an underlying stream.
     */
    public DebugOutputStream(OutputStream out, OutputStream debugOut) {
        super(out);
        this.debugOut = debugOut;
    }

    public void write(int b) throws IOException {
        super.write(b);
        debugOut.write((char) b);
    }

    public void write(byte[] b) throws IOException {
        super.write(b);
        debugOut.write(b);
    }

    public void write(byte[] b, int offset, int length) throws IOException {
        super.write(b, offset, length);
        debugOut.write(b, offset, length);
    }

}
","package com.flickr4java.flickr.util; import java.io.FilterOutputStream; import java.io.IOException; import java.io.OutputStream; public class DebugOutputStream extends FilterOutputStream { private OutputStream debugOut; public DebugOutputStream(OutputStream out, OutputStream debugOut) { super(out); this.debugOut = debugOut; } public void write(int b) throws IOException { super.write(b); debugOut.write((char) b); } public void write(byte[] b) throws IOException { super.write(b); debugOut.write(b); } public void write(byte[] b, int offset, int length) throws IOException { super.write(b, offset, length); debugOut.write(b, offset, length); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.util; import java.io.FilterOutputStream; import java.io.IOException; import java.io.OutputStream; public class DebugOutputStream extends FilterOutputStream { private OutputStream debugOut; public DebugOutputStream(OutputStream out, OutputStream debugOut) { super(out); this.debugOut = debugOut; } public void write(int b) throws IOException { super.write(b); debugOut.write((char) b); } public void write(byte[] b) throws IOException { super.write(b); debugOut.write(b); } public void write(byte[] b, int offset, int length) throws IOException { super.write(b, offset, length); debugOut.write(b, offset, length); } } ","
 package com.flickr4java.flickr.util;  import java.io.FilterOutputStream; import java.io.IOException; import java.io.OutputStream;  /**
 * A FilterInputStream which will print all read data to the specified PrintWriter.
 * 
 * @author Anthony Eden
 */ public class DebugOutputStream extends FilterOutputStream {  private OutputStream debugOut;  /**
     * Creates a <code>FilterInputStream</code> by assigning the argument <code>in</code> to the field <code>this.in</code> so as to remember it for later use.
     * 
     * @param out
     *            the underlying output stream, or <code>null</code> if this instance is to be created without an underlying stream.
     */ public DebugOutputStream(OutputStream out, OutputStream debugOut) { super(out); this.debugOut = debugOut; }  public void write(int b) throws IOException { super.write(b); debugOut.write((char) b); }  public void write(byte[] b) throws IOException { super.write(b); debugOut.write(b); }  public void write(byte[] b, int offset, int length) throws IOException { super.write(b, offset, length); debugOut.write(b, offset, length); }  }  "
src/main/java/com/flickr4java/flickr/util/FileAuthStore.java,"/**
 * 
 */
package com.flickr4java.flickr.util;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.auth.Auth;
import com.flickr4java.flickr.people.User;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.HashMap;
import java.util.Map;

/**
 * 
 * Implements a filesystem based storage system for Auth instances. One "".auth"" file is maintained per Auth instance stored.
 * 
 * @author Matthew MacKenzie
 * 
 */
public class FileAuthStore implements AuthStore {

    private Map<String, Auth> auths;
    private Map<String, Auth> authsByUser; // Separate HashMap due to retrieveAll.

    private File authStoreDir;

    public FileAuthStore(File authStoreDir) throws FlickrException {
        this.auths = new HashMap<String, Auth>();
        this.authsByUser = new HashMap<String, Auth>();

        this.authStoreDir = authStoreDir;

        if (!authStoreDir.exists())
            authStoreDir.mkdir();

        if (!authStoreDir.canRead()) {
            try {
                throw new FlickrException(""Cannot read "" + authStoreDir.getCanonicalPath());
            } catch (IOException e) {
                throw new FlickrException(e.getMessage(), e);
            }
        }

        this.load();
    }

    private void load() throws FlickrException {
        try {
            File[] authFiles = authStoreDir.listFiles(new AuthFilenameFilter());

            for (int i = 0; i < authFiles.length; i++) {
                if (authFiles[i].isFile() && authFiles[i].canRead()) {
                    ObjectInputStream authStream = new ObjectInputStream(new FileInputStream(authFiles[i]));
                    Auth authInst = null;
                    try {
                        authInst = (Auth) authStream.readObject();
                    } catch (ClassCastException cce) {
                        // ignore. Its not an auth, so we won't store it. simple as that :-);
                    } catch (ClassNotFoundException e) {
                        // yep, ignoring. LALALALALLALAL. I can't hear you :-)
                    }
                    if (authInst != null) {
                        this.auths.put(authInst.getUser().getId(), authInst);
                        
                        // Also store by user-name since it is generally easier to remember.
                        this.authsByUser.put(authInst.getUser().getUsername(), authInst);
                    }
                    authStream.close();
                }
            }
        } catch (IOException e) {
            throw new FlickrException(e.getMessage(), e);
        }
    }

    /*
     * (non-Javadoc)
     * 
     * @see com.flickr4java.flickr.util.AuthStore#store(com.flickr4java.flickr.auth.Auth)
     */
    public void store(Auth token) throws IOException {
        this.auths.put(token.getUser().getId(), token);
        this.authsByUser.put(token.getUser().getUsername(), token);

        String filename = token.getUser().getId() + "".auth"";
        File outFile = new File(this.authStoreDir, filename);
        outFile.createNewFile();

        ObjectOutputStream authStream = new ObjectOutputStream(new FileOutputStream(outFile));
        authStream.writeObject(token);
        authStream.flush();
        authStream.close();
    }

    /*
     * (non-Javadoc)
     * Retrieve via flickr user id or username.
     * 
     * @see com.flickr4java.flickr.util.AuthStore#retrieve(java.lang.String)
     */
    public Auth retrieve(String nsid) {
    	Auth auth =  this.auths.get(nsid);
    	if(auth != null)
    		return auth;
    	else
    		return this.authsByUser.get(nsid);
    }

    /*
     * (non-Javadoc)
     * 
     * @see com.flickr4java.flickr.util.AuthStore#retrieveAll()
     */
    public Auth[] retrieveAll() {
        return this.auths.values().toArray(new Auth[this.auths.size()]);
    }

    /*
     * (non-Javadoc)
     * 
     * @see com.flickr4java.flickr.util.AuthStore#clearAll()
     */
    public void clearAll() {
        this.auths.clear();
        this.authsByUser.clear();
        File[] auths = this.authStoreDir.listFiles(new AuthFilenameFilter());
        for (int i = 0; i < auths.length; i++) {
            auths[i].delete();
        }
    }

    /*
     * (non-Javadoc)
     * 
     * @see com.flickr4java.flickr.util.AuthStore#clear(java.lang.String)
     */
    public void clear(String nsid) {
    	Auth a =  this.auths.get(nsid);
    	if(a != null) {
            this.authsByUser.remove(a.getUser().getUsername());
    	}
    	this.auths.remove(nsid);
        this.authsByUser.remove(nsid); // in case username is passed.
        File auth = new File(this.authStoreDir, nsid + "".auth"");
        if (auth.exists())
            auth.delete();

    }

    static class AuthFilenameFilter implements FilenameFilter {
        private static final String suffix = "".auth"";

        public boolean accept(File dir, String name) {
            if (name.endsWith(suffix))
                return true;
            return false;
        }

    }

    public static void main(String[] args) throws Exception {
        FileAuthStore fas = new FileAuthStore(new File(System.getProperty(""user.home"") + File.separatorChar + ""flickrauth""));
        Auth a = new Auth();
        User u = new User();
        u.setId(""THISISMYNSID"");
        a.setUser(u);
        fas.store(a);
        fas = null;

        fas = new FileAuthStore(new File(System.getProperty(""user.home"") + File.separatorChar + ""flickrauth""));
        Auth a2 = fas.retrieve(""THISISMYNSID"");

        System.out.println(a2.getUser().getId());
    }
}
","package com.flickr4java.flickr.util; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.people.User; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FilenameFilter; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.HashMap; import java.util.Map; public class FileAuthStore implements AuthStore { private Map<String, Auth> auths; private Map<String, Auth> authsByUser; private File authStoreDir; public FileAuthStore(File authStoreDir) throws FlickrException { this.auths = new HashMap<String, Auth>(); this.authsByUser = new HashMap<String, Auth>(); this.authStoreDir = authStoreDir; if (!authStoreDir.exists())
            authStoreDir.mkdir(); if (!authStoreDir.canRead()) { try { throw new FlickrException(""Cannot read "" + authStoreDir.getCanonicalPath()); } catch (IOException e) { throw new FlickrException(e.getMessage(), e); } } this.load(); } private void load() throws FlickrException { try { File[] authFiles = authStoreDir.listFiles(new AuthFilenameFilter()); for (int i = 0; i < authFiles.length; i++) { if (authFiles[i].isFile() && authFiles[i].canRead()) { ObjectInputStream authStream = new ObjectInputStream(new FileInputStream(authFiles[i])); Auth authInst = null; try { authInst = (Auth) authStream.readObject(); } catch (ClassCastException cce) { } catch (ClassNotFoundException e) { } if (authInst != null) { this.auths.put(authInst.getUser().getId(), authInst); this.authsByUser.put(authInst.getUser().getUsername(), authInst); } authStream.close(); } } } catch (IOException e) { throw new FlickrException(e.getMessage(), e); } } public void store(Auth token) throws IOException { this.auths.put(token.getUser().getId(), token); this.authsByUser.put(token.getUser().getUsername(), token); String filename = token.getUser().getId() + "".auth""; File outFile = new File(this.authStoreDir, filename); outFile.createNewFile(); ObjectOutputStream authStream = new ObjectOutputStream(new FileOutputStream(outFile)); authStream.writeObject(token); authStream.flush(); authStream.close(); } public Auth retrieve(String nsid) { Auth auth =  this.auths.get(nsid); if(auth != null)
    		return auth; else
    		return this.authsByUser.get(nsid); } public Auth[] retrieveAll() { return this.auths.values().toArray(new Auth[this.auths.size()]); } public void clearAll() { this.auths.clear(); this.authsByUser.clear(); File[] auths = this.authStoreDir.listFiles(new AuthFilenameFilter()); for (int i = 0; i < auths.length; i++) { auths[i].delete(); } } public void clear(String nsid) { Auth a =  this.auths.get(nsid); if(a != null) { this.authsByUser.remove(a.getUser().getUsername()); } this.auths.remove(nsid); this.authsByUser.remove(nsid); File auth = new File(this.authStoreDir, nsid + "".auth""); if (auth.exists())
            auth.delete(); } static class AuthFilenameFilter implements FilenameFilter { private static final String suffix = "".auth""; public boolean accept(File dir, String name) { if (name.endsWith(suffix))
                return true; return false; } } public static void main(String[] args) throws Exception { FileAuthStore fas = new FileAuthStore(new File(System.getProperty(""user.home"") + File.separatorChar + ""flickrauth"")); Auth a = new Auth(); User u = new User(); u.setId(""THISISMYNSID""); a.setUser(u); fas.store(a); fas = null; fas = new FileAuthStore(new File(System.getProperty(""user.home"") + File.separatorChar + ""flickrauth"")); Auth a2 = fas.retrieve(""THISISMYNSID""); System.out.println(a2.getUser().getId()); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.util; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.people.User; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FilenameFilter; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.HashMap; import java.util.Map; public class FileAuthStore implements AuthStore { private Map<String, Auth> auths; private Map<String, Auth> authsByUser; private File authStoreDir; public FileAuthStore(File authStoreDir) throws FlickrException { this.auths = new HashMap<String, Auth>(); this.authsByUser = new HashMap<String, Auth>(); this.authStoreDir = authStoreDir; if (!authStoreDir.exists())
            authStoreDir.mkdir(); if (!authStoreDir.canRead()) { try { throw new FlickrException(""Cannot read "" + authStoreDir.getCanonicalPath()); } catch (IOException e) { throw new FlickrException(e.getMessage(), e); } } this.load(); } private void load() throws FlickrException { try { File[] authFiles = authStoreDir.listFiles(new AuthFilenameFilter()); for (int i = 0; i < authFiles.length; i++) { if (authFiles[i].isFile() && authFiles[i].canRead()) { ObjectInputStream authStream = new ObjectInputStream(new FileInputStream(authFiles[i])); Auth authInst = null; try { authInst = (Auth) authStream.readObject(); } catch (ClassCastException cce) { } catch (ClassNotFoundException e) { } if (authInst != null) { this.auths.put(authInst.getUser().getId(), authInst); this.authsByUser.put(authInst.getUser().getUsername(), authInst); } authStream.close(); } } } catch (IOException e) { throw new FlickrException(e.getMessage(), e); } } public void store(Auth token) throws IOException { this.auths.put(token.getUser().getId(), token); this.authsByUser.put(token.getUser().getUsername(), token); String filename = token.getUser().getId() + "".auth""; File outFile = new File(this.authStoreDir, filename); outFile.createNewFile(); ObjectOutputStream authStream = new ObjectOutputStream(new FileOutputStream(outFile)); authStream.writeObject(token); authStream.flush(); authStream.close(); } public Auth retrieve(String nsid) { Auth auth =  this.auths.get(nsid); if(auth != null)
    		return auth; else
    		return this.authsByUser.get(nsid); } public Auth[] retrieveAll() { return this.auths.values().toArray(new Auth[this.auths.size()]); } public void clearAll() { this.auths.clear(); this.authsByUser.clear(); File[] auths = this.authStoreDir.listFiles(new AuthFilenameFilter()); for (int i = 0; i < auths.length; i++) { auths[i].delete(); } } public void clear(String nsid) { Auth a =  this.auths.get(nsid); if(a != null) { this.authsByUser.remove(a.getUser().getUsername()); } this.auths.remove(nsid); this.authsByUser.remove(nsid); File auth = new File(this.authStoreDir, nsid + "".auth""); if (auth.exists())
            auth.delete(); } static class AuthFilenameFilter implements FilenameFilter { private static final String suffix = "".auth""; public boolean accept(File dir, String name) { if (name.endsWith(suffix))
                return true; return false; } } public static void main(String[] args) throws Exception { FileAuthStore fas = new FileAuthStore(new File(System.getProperty(""user.home"") + File.separatorChar + ""flickrauth"")); Auth a = new Auth(); User u = new User(); u.setId(""THISISMYNSID""); a.setUser(u); fas.store(a); fas = null; fas = new FileAuthStore(new File(System.getProperty(""user.home"") + File.separatorChar + ""flickrauth"")); Auth a2 = fas.retrieve(""THISISMYNSID""); System.out.println(a2.getUser().getId()); } } ","/**
 * 
 */ package com.flickr4java.flickr.util;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.people.User;  import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FilenameFilter; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.HashMap; import java.util.Map;  /**
 * 
 * Implements a filesystem based storage system for Auth instances. One "".auth"" file is maintained per Auth instance stored.
 * 
 * @author Matthew MacKenzie
 * 
 */ public class FileAuthStore implements AuthStore {  private Map<String, Auth> auths; private Map<String, Auth> authsByUser; // Separate HashMap due to retrieveAll.  private File authStoreDir;  public FileAuthStore(File authStoreDir) throws FlickrException { this.auths = new HashMap<String, Auth>(); this.authsByUser = new HashMap<String, Auth>();  this.authStoreDir = authStoreDir;  if (!authStoreDir.exists())
            authStoreDir.mkdir();  if (!authStoreDir.canRead()) { try { throw new FlickrException(""Cannot read "" + authStoreDir.getCanonicalPath()); } catch (IOException e) { throw new FlickrException(e.getMessage(), e); } }  this.load(); }  private void load() throws FlickrException { try { File[] authFiles = authStoreDir.listFiles(new AuthFilenameFilter());  for (int i = 0; i < authFiles.length; i++) { if (authFiles[i].isFile() && authFiles[i].canRead()) { ObjectInputStream authStream = new ObjectInputStream(new FileInputStream(authFiles[i])); Auth authInst = null; try { authInst = (Auth) authStream.readObject(); } catch (ClassCastException cce) { // ignore. Its not an auth, so we won't store it. simple as that :-); } catch (ClassNotFoundException e) { // yep, ignoring. LALALALALLALAL. I can't hear you :-) } if (authInst != null) { this.auths.put(authInst.getUser().getId(), authInst);                          // Also store by user-name since it is generally easier to remember. this.authsByUser.put(authInst.getUser().getUsername(), authInst); } authStream.close(); } } } catch (IOException e) { throw new FlickrException(e.getMessage(), e); } }  /*
     * (non-Javadoc)
     * 
     * @see com.flickr4java.flickr.util.AuthStore#store(com.flickr4java.flickr.auth.Auth)
     */ public void store(Auth token) throws IOException { this.auths.put(token.getUser().getId(), token); this.authsByUser.put(token.getUser().getUsername(), token);  String filename = token.getUser().getId() + "".auth""; File outFile = new File(this.authStoreDir, filename); outFile.createNewFile();  ObjectOutputStream authStream = new ObjectOutputStream(new FileOutputStream(outFile)); authStream.writeObject(token); authStream.flush(); authStream.close(); }  /*
     * (non-Javadoc)
     * Retrieve via flickr user id or username.
     * 
     * @see com.flickr4java.flickr.util.AuthStore#retrieve(java.lang.String)
     */ public Auth retrieve(String nsid) { Auth auth =  this.auths.get(nsid); if(auth != null)
    		return auth; else
    		return this.authsByUser.get(nsid); }  /*
     * (non-Javadoc)
     * 
     * @see com.flickr4java.flickr.util.AuthStore#retrieveAll()
     */ public Auth[] retrieveAll() { return this.auths.values().toArray(new Auth[this.auths.size()]); }  /*
     * (non-Javadoc)
     * 
     * @see com.flickr4java.flickr.util.AuthStore#clearAll()
     */ public void clearAll() { this.auths.clear(); this.authsByUser.clear(); File[] auths = this.authStoreDir.listFiles(new AuthFilenameFilter()); for (int i = 0; i < auths.length; i++) { auths[i].delete(); } }  /*
     * (non-Javadoc)
     * 
     * @see com.flickr4java.flickr.util.AuthStore#clear(java.lang.String)
     */ public void clear(String nsid) { Auth a =  this.auths.get(nsid); if(a != null) { this.authsByUser.remove(a.getUser().getUsername()); } this.auths.remove(nsid); this.authsByUser.remove(nsid); // in case username is passed. File auth = new File(this.authStoreDir, nsid + "".auth""); if (auth.exists())
            auth.delete();  }  static class AuthFilenameFilter implements FilenameFilter { private static final String suffix = "".auth"";  public boolean accept(File dir, String name) { if (name.endsWith(suffix))
                return true; return false; }  }  public static void main(String[] args) throws Exception { FileAuthStore fas = new FileAuthStore(new File(System.getProperty(""user.home"") + File.separatorChar + ""flickrauth"")); Auth a = new Auth(); User u = new User(); u.setId(""THISISMYNSID""); a.setUser(u); fas.store(a); fas = null;  fas = new FileAuthStore(new File(System.getProperty(""user.home"") + File.separatorChar + ""flickrauth"")); Auth a2 = fas.retrieve(""THISISMYNSID"");  System.out.println(a2.getUser().getId()); } }  "
src/main/java/com/flickr4java/flickr/util/IOUtilities.java,"
package com.flickr4java.flickr.util;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;

/**
 * Common IO utilities.
 * 
 * @author Anthony Eden
 */
public class IOUtilities {

    private IOUtilities() {

    }

    public static void close(InputStream s) {
        if (s != null) {
            try {
                s.close();
            } catch (IOException e) {

            }
        }
    }

    public static void close(OutputStream s) {
        if (s != null) {
            try {
                s.close();
            } catch (IOException e) {

            }
        }
    }

    public static void close(Reader s) {
        if (s != null) {
            try {
                s.close();
            } catch (IOException e) {

            }
        }
    }

    public static void close(Writer s) {
        if (s != null) {
            try {
                s.close();
            } catch (IOException e) {

            }
        }
    }

}
",package com.flickr4java.flickr.util; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.io.Reader; import java.io.Writer; public class IOUtilities { private IOUtilities() { } public static void close(InputStream s) { if (s != null) { try { s.close(); } catch (IOException e) { } } } public static void close(OutputStream s) { if (s != null) { try { s.close(); } catch (IOException e) { } } } public static void close(Reader s) { if (s != null) { try { s.close(); } catch (IOException e) { } } } public static void close(Writer s) { if (s != null) { try { s.close(); } catch (IOException e) { } } } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.util; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.io.Reader; import java.io.Writer; public class IOUtilities { private IOUtilities() { } public static void close(InputStream s) { if (s != null) { try { s.close(); } catch (IOException e) { } } } public static void close(OutputStream s) { if (s != null) { try { s.close(); } catch (IOException e) { } } } public static void close(Reader s) { if (s != null) { try { s.close(); } catch (IOException e) { } } } public static void close(Writer s) { if (s != null) { try { s.close(); } catch (IOException e) { } } } } ," package com.flickr4java.flickr.util;  import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.io.Reader; import java.io.Writer;  /**
 * Common IO utilities.
 * 
 * @author Anthony Eden
 */ public class IOUtilities {  private IOUtilities() {  }  public static void close(InputStream s) { if (s != null) { try { s.close(); } catch (IOException e) {  } } }  public static void close(OutputStream s) { if (s != null) { try { s.close(); } catch (IOException e) {  } } }  public static void close(Reader s) { if (s != null) { try { s.close(); } catch (IOException e) {  } } }  public static void close(Writer s) { if (s != null) { try { s.close(); } catch (IOException e) {  } } }  }  "
src/main/java/com/flickr4java/flickr/util/ImageUtilities.java,"

package com.flickr4java.flickr.util;

import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.awt.image.ImageObserver;

/**
 * @author Anthony Eden
 */
public class ImageUtilities {

    private static final int DEFAULT_IMAGE_TYPE = BufferedImage.TYPE_INT_RGB;

    public BufferedImage bufferImage(Image image) {
        return bufferImage(image, DEFAULT_IMAGE_TYPE);
    }

    public BufferedImage bufferImage(Image image, int type) {
        BufferedImage bufferedImage = new BufferedImage(image.getWidth(null), image.getHeight(null), type);
        Graphics2D g = bufferedImage.createGraphics();
        g.drawImage(image, null, null);
        waitForImage(bufferedImage);
        return bufferedImage;
    }

    private void waitForImage(BufferedImage bufferedImage) {
        final ImageLoadStatus imageLoadStatus = new ImageLoadStatus();
        bufferedImage.getHeight(new ImageObserver() {
            public boolean imageUpdate(Image img, int infoflags, int x, int y, int width, int height) {
                if (infoflags == ALLBITS) {
                    imageLoadStatus.heightDone = true;
                    return true;
                }
                return false;
            }
        });
        bufferedImage.getWidth(new ImageObserver() {
            public boolean imageUpdate(Image img, int infoflags, int x, int y, int width, int height) {
                if (infoflags == ALLBITS) {
                    imageLoadStatus.widthDone = true;
                    return true;
                }
                return false;
            }
        });
        while (!imageLoadStatus.widthDone && !imageLoadStatus.heightDone) {
            try {
                Thread.sleep(300);
            } catch (InterruptedException e) {

            }
        }
    }

    class ImageLoadStatus {

        public boolean widthDone = false;

        public boolean heightDone = false;
    }

}
","package com.flickr4java.flickr.util; import java.awt.Graphics2D; import java.awt.Image; import java.awt.image.BufferedImage; import java.awt.image.ImageObserver; public class ImageUtilities { private static final int DEFAULT_IMAGE_TYPE = BufferedImage.TYPE_INT_RGB; public BufferedImage bufferImage(Image image) { return bufferImage(image, DEFAULT_IMAGE_TYPE); } public BufferedImage bufferImage(Image image, int type) { BufferedImage bufferedImage = new BufferedImage(image.getWidth(null), image.getHeight(null), type); Graphics2D g = bufferedImage.createGraphics(); g.drawImage(image, null, null); waitForImage(bufferedImage); return bufferedImage; } private void waitForImage(BufferedImage bufferedImage) { final ImageLoadStatus imageLoadStatus = new ImageLoadStatus(); bufferedImage.getHeight(new ImageObserver() { public boolean imageUpdate(Image img, int infoflags, int x, int y, int width, int height) { if (infoflags == ALLBITS) { imageLoadStatus.heightDone = true; return true; } return false; } } ); bufferedImage.getWidth(new ImageObserver() { public boolean imageUpdate(Image img, int infoflags, int x, int y, int width, int height) { if (infoflags == ALLBITS) { imageLoadStatus.widthDone = true; return true; } return false; } } ); while (!imageLoadStatus.widthDone && !imageLoadStatus.heightDone) { try { Thread.sleep(300); } catch (InterruptedException e) { } } } class ImageLoadStatus { public boolean widthDone = false; public boolean heightDone = false; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.util; import java.awt.Graphics2D; import java.awt.Image; import java.awt.image.BufferedImage; import java.awt.image.ImageObserver; public class ImageUtilities { private static final int DEFAULT_IMAGE_TYPE = BufferedImage.TYPE_INT_RGB; public BufferedImage bufferImage(Image image) { return bufferImage(image, DEFAULT_IMAGE_TYPE); } public BufferedImage bufferImage(Image image, int type) { BufferedImage bufferedImage = new BufferedImage(image.getWidth(null), image.getHeight(null), type); Graphics2D g = bufferedImage.createGraphics(); g.drawImage(image, null, null); waitForImage(bufferedImage); return bufferedImage; } private void waitForImage(BufferedImage bufferedImage) { final ImageLoadStatus imageLoadStatus = new ImageLoadStatus(); bufferedImage.getHeight(new ImageObserver() { public boolean imageUpdate(Image img, int infoflags, int x, int y, int width, int height) { if (infoflags == ALLBITS) { imageLoadStatus.heightDone = true; return true; } return false; } } ); bufferedImage.getWidth(new ImageObserver() { public boolean imageUpdate(Image img, int infoflags, int x, int y, int width, int height) { if (infoflags == ALLBITS) { imageLoadStatus.widthDone = true; return true; } return false; } } ); while (!imageLoadStatus.widthDone && !imageLoadStatus.heightDone) { try { Thread.sleep(300); } catch (InterruptedException e) { } } } class ImageLoadStatus { public boolean widthDone = false; public boolean heightDone = false; } } ","
 package com.flickr4java.flickr.util;  import java.awt.Graphics2D; import java.awt.Image; import java.awt.image.BufferedImage; import java.awt.image.ImageObserver;  /**
 * @author Anthony Eden
 */ public class ImageUtilities {  private static final int DEFAULT_IMAGE_TYPE = BufferedImage.TYPE_INT_RGB;  public BufferedImage bufferImage(Image image) { return bufferImage(image, DEFAULT_IMAGE_TYPE); }  public BufferedImage bufferImage(Image image, int type) { BufferedImage bufferedImage = new BufferedImage(image.getWidth(null), image.getHeight(null), type); Graphics2D g = bufferedImage.createGraphics(); g.drawImage(image, null, null); waitForImage(bufferedImage); return bufferedImage; }  private void waitForImage(BufferedImage bufferedImage) { final ImageLoadStatus imageLoadStatus = new ImageLoadStatus(); bufferedImage.getHeight(new ImageObserver() { public boolean imageUpdate(Image img, int infoflags, int x, int y, int width, int height) { if (infoflags == ALLBITS) { imageLoadStatus.heightDone = true; return true; } return false; } } ); bufferedImage.getWidth(new ImageObserver() { public boolean imageUpdate(Image img, int infoflags, int x, int y, int width, int height) { if (infoflags == ALLBITS) { imageLoadStatus.widthDone = true; return true; } return false; } } ); while (!imageLoadStatus.widthDone && !imageLoadStatus.heightDone) { try { Thread.sleep(300); } catch (InterruptedException e) {  } } }  class ImageLoadStatus {  public boolean widthDone = false;  public boolean heightDone = false; }  }  "
src/main/java/com/flickr4java/flickr/util/OAuthUtilities.java,"package com.flickr4java.flickr.util;

import java.util.Map;
import java.util.UUID;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.flickr4java.flickr.Flickr;
import com.flickr4java.flickr.RequestContext;
import com.flickr4java.flickr.auth.Auth;
import com.github.scribejava.apis.FlickrApi;
import com.github.scribejava.core.builder.ServiceBuilder;
import com.github.scribejava.core.httpclient.jdk.JDKHttpClientConfig;
import com.github.scribejava.core.model.OAuth1AccessToken;
import com.github.scribejava.core.model.OAuthRequest;
import com.github.scribejava.core.model.Verb;
import com.github.scribejava.core.oauth.OAuth10aService;

/**
 * OAuth utilities.
 * 
 * @author Vincent Privat
 */
public final class OAuthUtilities {

    private static final Logger logger = LoggerFactory.getLogger(OAuthUtilities.class);

    private OAuthUtilities() {

    }

    /**
     * Creates a new OAuth 1.0.a service.
     * 
     * @param apiKey OAuth API key
     * @param sharedSecret OAuth API secret
     * @param connectTimeoutMs connect timeout in milliseconds
     * @param readTimeoutMs read timeout in milliseconds
     *
     * @return OAuth 1.0.a service
     */
    public static OAuth10aService createOAuthService(String apiKey, String sharedSecret, Integer connectTimeoutMs, Integer readTimeoutMs) {
        JDKHttpClientConfig config = JDKHttpClientConfig.defaultConfig();
        if (connectTimeoutMs != null) {
            config.setConnectTimeout(connectTimeoutMs);
        }
        if (readTimeoutMs != null) {
            config.setReadTimeout(readTimeoutMs);
        }
        ServiceBuilder serviceBuilder = new ServiceBuilder(apiKey).apiSecret(sharedSecret).httpClientConfig(config);

        if (Flickr.debugRequest) {
            serviceBuilder = serviceBuilder.debug();
        }

        return serviceBuilder.build(FlickrApi.instance());
    }

    /**
     * Signs the given OAuth request using the given OAuth service. 
     *
     * @param service OAuth 1.0.a service
     * @param request OAuth request
     * @param proxyCredentials optional proxy credentials, can be null
     */
    public static void signRequest(OAuth10aService service, OAuthRequest request, String proxyCredentials) {
        Auth auth = RequestContext.getRequestContext().getAuth();
        if (auth != null) {
            service.signRequest(new OAuth1AccessToken(auth.getToken(), auth.getTokenSecret()), request);
        }

        if (proxyCredentials != null) {
            request.addHeader(""Proxy-Authorization"", ""Basic "" + proxyCredentials);
        }

        if (Flickr.debugRequest) {
            logger.debug(""POST: {}"", request.getCompleteUrl());
        }
    }

    /**
     * Builds a normal POST request.
     *
     * @param parameters body parameters
     * @param url URL
     * @return OAuth request
     */
    public static OAuthRequest buildNormalPostRequest(Map<String, ?> parameters, String url) {
        OAuthRequest request = new OAuthRequest(Verb.POST, url);
        parameters.entrySet().forEach(e -> request.addBodyParameter(e.getKey(), String.valueOf(e.getValue())));
        return request;
    }

    /**
     * Builds a multipart POST request.
     *
     * @param parameters QueryString parameters
     * @param url URL
     * @return OAuth request
     */
    public static OAuthRequest buildMultipartRequest(Map<String, String> parameters, String url) {
        OAuthRequest request = new OAuthRequest(Verb.POST, url);
        String multipartBoundary = getMultipartBoundary();
        request.initMultipartPayload(multipartBoundary);
        request.addHeader(""Content-Type"", ""multipart/form-data; boundary="" + multipartBoundary);
        parameters.entrySet().forEach(e -> request.addQuerystringParameter(e.getKey(), e.getValue()));
        return request;
    }

    private static String getMultipartBoundary() {
        return ""---------------------------"" + UUID.randomUUID();
    }
}
","package com.flickr4java.flickr.util; public final class OAuthUtilities { private static final Logger logger = LoggerFactory.getLogger(OAuthUtilities.class); private OAuthUtilities() { } public static OAuth10aService createOAuthService(String apiKey, String sharedSecret, Integer connectTimeoutMs, Integer readTimeoutMs) { JDKHttpClientConfig config = JDKHttpClientConfig.defaultConfig(); if (connectTimeoutMs != null) { config.setConnectTimeout(connectTimeoutMs); } if (readTimeoutMs != null) { config.setReadTimeout(readTimeoutMs); } ServiceBuilder serviceBuilder = new ServiceBuilder(apiKey).apiSecret(sharedSecret).httpClientConfig(config); if (Flickr.debugRequest) { serviceBuilder = serviceBuilder.debug(); } return serviceBuilder.build(FlickrApi.instance()); } public static void signRequest(OAuth10aService service, OAuthRequest request, String proxyCredentials) { Auth auth = RequestContext.getRequestContext().getAuth(); if (auth != null) { service.signRequest(new OAuth1AccessToken(auth.getToken(), auth.getTokenSecret()), request); } if (proxyCredentials != null) { request.addHeader(""Proxy-Authorization"", ""Basic "" + proxyCredentials); } if (Flickr.debugRequest) { logger.debug(""POST: { } "", request.getCompleteUrl()); } } public static OAuthRequest buildNormalPostRequest(Map<String, ?> parameters, String url) { OAuthRequest request = new OAuthRequest(Verb.POST, url); parameters.entrySet().forEach(e -> request.addBodyParameter(e.getKey(), String.valueOf(e.getValue()))); return request; } public static OAuthRequest buildMultipartRequest(Map<String, String> parameters, String url) { OAuthRequest request = new OAuthRequest(Verb.POST, url); String multipartBoundary = getMultipartBoundary(); request.initMultipartPayload(multipartBoundary); request.addHeader(""Content-Type"", ""multipart/form-data; boundary="" + multipartBoundary); parameters.entrySet().forEach(e -> request.addQuerystringParameter(e.getKey(), e.getValue())); return request; } private static String getMultipartBoundary() { return ""---------------------------"" + UUID.randomUUID(); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.util; public final class OAuthUtilities { private static final Logger logger = LoggerFactory.getLogger(OAuthUtilities.class); private OAuthUtilities() { } public static OAuth10aService createOAuthService(String apiKey, String sharedSecret, Integer connectTimeoutMs, Integer readTimeoutMs) { JDKHttpClientConfig config = JDKHttpClientConfig.defaultConfig(); if (connectTimeoutMs != null) { config.setConnectTimeout(connectTimeoutMs); } if (readTimeoutMs != null) { config.setReadTimeout(readTimeoutMs); } ServiceBuilder serviceBuilder = new ServiceBuilder(apiKey).apiSecret(sharedSecret).httpClientConfig(config); if (Flickr.debugRequest) { serviceBuilder = serviceBuilder.debug(); } return serviceBuilder.build(FlickrApi.instance()); } public static void signRequest(OAuth10aService service, OAuthRequest request, String proxyCredentials) { Auth auth = RequestContext.getRequestContext().getAuth(); if (auth != null) { service.signRequest(new OAuth1AccessToken(auth.getToken(), auth.getTokenSecret()), request); } if (proxyCredentials != null) { request.addHeader(""Proxy-Authorization"", ""Basic "" + proxyCredentials); } if (Flickr.debugRequest) { logger.debug(""POST: { } "", request.getCompleteUrl()); } } public static OAuthRequest buildNormalPostRequest(Map<String, ?> parameters, String url) { OAuthRequest request = new OAuthRequest(Verb.POST, url); parameters.entrySet().forEach(e -> request.addBodyParameter(e.getKey(), String.valueOf(e.getValue()))); return request; } public static OAuthRequest buildMultipartRequest(Map<String, String> parameters, String url) { OAuthRequest request = new OAuthRequest(Verb.POST, url); String multipartBoundary = getMultipartBoundary(); request.initMultipartPayload(multipartBoundary); request.addHeader(""Content-Type"", ""multipart/form-data; boundary="" + multipartBoundary); parameters.entrySet().forEach(e -> request.addQuerystringParameter(e.getKey(), e.getValue())); return request; } private static String getMultipartBoundary() { return ""---------------------------"" + UUID.randomUUID(); } } ","package com.flickr4java.flickr.util; 
import java.util.Map; import java.util.UUID; 
import org.slf4j.Logger; import org.slf4j.LoggerFactory; 
import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.RequestContext; import com.flickr4java.flickr.auth.Auth; import com.github.scribejava.apis.FlickrApi; import com.github.scribejava.core.builder.ServiceBuilder; import com.github.scribejava.core.httpclient.jdk.JDKHttpClientConfig; import com.github.scribejava.core.model.OAuth1AccessToken; import com.github.scribejava.core.model.OAuthRequest; import com.github.scribejava.core.model.Verb; import com.github.scribejava.core.oauth.OAuth10aService;  /**
 * OAuth utilities.
 * 
 * @author Vincent Privat
 */ public final class OAuthUtilities {  private static final Logger logger = LoggerFactory.getLogger(OAuthUtilities.class);  private OAuthUtilities() {  }  /**
     * Creates a new OAuth 1.0.a service.
     * 
     * @param apiKey OAuth API key
     * @param sharedSecret OAuth API secret
     * @param connectTimeoutMs connect timeout in milliseconds
     * @param readTimeoutMs read timeout in milliseconds
     *
     * @return OAuth 1.0.a service
     */ public static OAuth10aService createOAuthService(String apiKey, String sharedSecret, Integer connectTimeoutMs, Integer readTimeoutMs) { JDKHttpClientConfig config = JDKHttpClientConfig.defaultConfig(); if (connectTimeoutMs != null) { config.setConnectTimeout(connectTimeoutMs); } if (readTimeoutMs != null) { config.setReadTimeout(readTimeoutMs); } ServiceBuilder serviceBuilder = new ServiceBuilder(apiKey).apiSecret(sharedSecret).httpClientConfig(config);  if (Flickr.debugRequest) { serviceBuilder = serviceBuilder.debug(); }  return serviceBuilder.build(FlickrApi.instance()); }  /**
     * Signs the given OAuth request using the given OAuth service. 
     *
     * @param service OAuth 1.0.a service
     * @param request OAuth request
     * @param proxyCredentials optional proxy credentials, can be null
     */ public static void signRequest(OAuth10aService service, OAuthRequest request, String proxyCredentials) { Auth auth = RequestContext.getRequestContext().getAuth(); if (auth != null) { service.signRequest(new OAuth1AccessToken(auth.getToken(), auth.getTokenSecret()), request); }  if (proxyCredentials != null) { request.addHeader(""Proxy-Authorization"", ""Basic "" + proxyCredentials); }  if (Flickr.debugRequest) { logger.debug(""POST: { } "", request.getCompleteUrl()); } }  /**
     * Builds a normal POST request.
     *
     * @param parameters body parameters
     * @param url URL
     * @return OAuth request
     */ public static OAuthRequest buildNormalPostRequest(Map<String, ?> parameters, String url) { OAuthRequest request = new OAuthRequest(Verb.POST, url); parameters.entrySet().forEach(e -> request.addBodyParameter(e.getKey(), String.valueOf(e.getValue()))); return request; }  /**
     * Builds a multipart POST request.
     *
     * @param parameters QueryString parameters
     * @param url URL
     * @return OAuth request
     */ public static OAuthRequest buildMultipartRequest(Map<String, String> parameters, String url) { OAuthRequest request = new OAuthRequest(Verb.POST, url); String multipartBoundary = getMultipartBoundary(); request.initMultipartPayload(multipartBoundary); request.addHeader(""Content-Type"", ""multipart/form-data; boundary="" + multipartBoundary); parameters.entrySet().forEach(e -> request.addQuerystringParameter(e.getKey(), e.getValue())); return request; }  private static String getMultipartBoundary() { return ""---------------------------"" + UUID.randomUUID(); } }  "
src/main/java/com/flickr4java/flickr/util/StringUtilities.java,"
package com.flickr4java.flickr.util;

import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.regex.Pattern;

/**
 * String utility methods.
 * 
 * @author Anthony Eden
 * @version $Id: StringUtilities.java,v 1.5 2009/07/23 20:41:03 x-mago Exp $
 */
public class StringUtilities {
    public static final Pattern getterPattern = Pattern.compile(""^is|^get"");

    private StringUtilities() {

    }

    /**
     * Join the array of Strings using the specified delimiter.
     * 
     * @param s
     *            The String array
     * @param delimiter
     *            The delimiter String
     * @return The joined String
     */
    public static String join(String[] s, String delimiter) {
        return join(s, delimiter, false);
    }

    public static String join(String[] s, String delimiter, boolean doQuote) {
        return join(Arrays.asList(s), delimiter, doQuote);
    }

    /**
     * Join the Collection of Strings using the specified delimter and optionally quoting each
     * 
     * @param s
     *            The String collection
     * @param delimiter
     *            the delimiter String
     * @param doQuote
     *            whether or not to quote the Strings
     * @return The joined String
     */
    public static String join(Collection<String> s, String delimiter, boolean doQuote) {
        StringBuffer buffer = new StringBuffer();
        Iterator<String> iter = s.iterator();
        while (iter.hasNext()) {
            if (doQuote) {
                buffer.append(""\"""" + iter.next() + ""\"""");
            } else {
                buffer.append(iter.next());
            }
            if (iter.hasNext()) {
                buffer.append(delimiter);
            }
        }
        return buffer.toString();
    }

    /**
     * Join the Collection of Strings using the specified delimiter.
     * 
     * @param s
     *            The String collection
     * @param delimiter
     *            The delimiter String
     * @return The joined String
     */
    public static String join(Collection<String> s, String delimiter) {
        return join(s, delimiter, false);
    }

}
","package com.flickr4java.flickr.util; import java.util.Arrays; import java.util.Collection; import java.util.Iterator; import java.util.regex.Pattern; public class StringUtilities { public static final Pattern getterPattern = Pattern.compile(""^is|^get""); private StringUtilities() { } public static String join(String[] s, String delimiter) { return join(s, delimiter, false); } public static String join(String[] s, String delimiter, boolean doQuote) { return join(Arrays.asList(s), delimiter, doQuote); } public static String join(Collection<String> s, String delimiter, boolean doQuote) { StringBuffer buffer = new StringBuffer(); Iterator<String> iter = s.iterator(); while (iter.hasNext()) { if (doQuote) { buffer.append(""\"""" + iter.next() + ""\""""); } else { buffer.append(iter.next()); } if (iter.hasNext()) { buffer.append(delimiter); } } return buffer.toString(); } public static String join(Collection<String> s, String delimiter) { return join(s, delimiter, false); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.util; import java.util.Arrays; import java.util.Collection; import java.util.Iterator; import java.util.regex.Pattern; public class StringUtilities { public static final Pattern getterPattern = Pattern.compile(""^is|^get""); private StringUtilities() { } public static String join(String[] s, String delimiter) { return join(s, delimiter, false); } public static String join(String[] s, String delimiter, boolean doQuote) { return join(Arrays.asList(s), delimiter, doQuote); } public static String join(Collection<String> s, String delimiter, boolean doQuote) { StringBuffer buffer = new StringBuffer(); Iterator<String> iter = s.iterator(); while (iter.hasNext()) { if (doQuote) { buffer.append(""\"""" + iter.next() + ""\""""); } else { buffer.append(iter.next()); } if (iter.hasNext()) { buffer.append(delimiter); } } return buffer.toString(); } public static String join(Collection<String> s, String delimiter) { return join(s, delimiter, false); } } "," package com.flickr4java.flickr.util;  import java.util.Arrays; import java.util.Collection; import java.util.Iterator; import java.util.regex.Pattern;  /**
 * String utility methods.
 * 
 * @author Anthony Eden
 * @version $Id: StringUtilities.java,v 1.5 2009/07/23 20:41:03 x-mago Exp $
 */ public class StringUtilities { public static final Pattern getterPattern = Pattern.compile(""^is|^get"");  private StringUtilities() {  }  /**
     * Join the array of Strings using the specified delimiter.
     * 
     * @param s
     *            The String array
     * @param delimiter
     *            The delimiter String
     * @return The joined String
     */ public static String join(String[] s, String delimiter) { return join(s, delimiter, false); }  public static String join(String[] s, String delimiter, boolean doQuote) { return join(Arrays.asList(s), delimiter, doQuote); }  /**
     * Join the Collection of Strings using the specified delimter and optionally quoting each
     * 
     * @param s
     *            The String collection
     * @param delimiter
     *            the delimiter String
     * @param doQuote
     *            whether or not to quote the Strings
     * @return The joined String
     */ public static String join(Collection<String> s, String delimiter, boolean doQuote) { StringBuffer buffer = new StringBuffer(); Iterator<String> iter = s.iterator(); while (iter.hasNext()) { if (doQuote) { buffer.append(""\"""" + iter.next() + ""\""""); } else { buffer.append(iter.next()); } if (iter.hasNext()) { buffer.append(delimiter); } } return buffer.toString(); }  /**
     * Join the Collection of Strings using the specified delimiter.
     * 
     * @param s
     *            The String collection
     * @param delimiter
     *            The delimiter String
     * @return The joined String
     */ public static String join(Collection<String> s, String delimiter) { return join(s, delimiter, false); }  }  "
src/main/java/com/flickr4java/flickr/util/UrlUtilities.java,"

package com.flickr4java.flickr.util;

import java.io.UnsupportedEncodingException;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLEncoder;
import java.util.Map;

/** 
 * @author Anthony Eden 
 * @author Mike Chaberski
 */
public class UrlUtilities {

    public static final String UTF8 = ""UTF-8"";

    /**
     * Build a request URL.
     * 
     * @param host
     *            The host
     * @param port
     *            The port
     * @param path
     *            The path
     * @param parameters
     *            The parameters
     * @return The URL
     * @throws MalformedURLException
     * @deprecated use {@link #buildSecureUrl(java.lang.String, int, java.lang.String, java.util.Map) }
     */
    @Deprecated
    public static URL buildUrl(String host, int port, String path, Map<String, String> parameters) throws MalformedURLException {
        return buildUrl(""http"", port, path, parameters);
    }
    
    /**
     * Build a request URL using a given scheme.
     * 
     * @param scheme the scheme, either {@code http} or {@code https}
     * @param host
     *            The host
     * @param port
     *            The port
     * @param path
     *            The path
     * @param parameters
     *            The parameters
     * @return The URL
     * @throws MalformedURLException
     */
    public static URL buildUrl(String scheme, String host, int port, String path, Map<String, String> parameters) throws MalformedURLException {
        checkSchemeAndPort(scheme, port);
        StringBuilder buffer = new StringBuilder();
        if (!host.startsWith(scheme + ""://"")) {
            buffer.append(scheme).append(""://"");
        }
        buffer.append(host);
        if (port > 0) {
            buffer.append(':');
            buffer.append(port);
        }
        if (path == null) {
            path = ""/"";
        }
        buffer.append(path);

        if (!parameters.isEmpty()) {
            buffer.append('?');
        }
        int size = parameters.size();
        for (Map.Entry<String, String> entry : parameters.entrySet()) {
            buffer.append(entry.getKey());
            buffer.append('=');
            Object value = entry.getValue();
            if (value != null) {
                String string = value.toString();
                try {
                    string = URLEncoder.encode(string, UTF8);
                } catch (UnsupportedEncodingException e) {
                    // Should never happen, but just in case
                }
                buffer.append(string);
            }
            if (--size != 0) {
                buffer.append('&');
            }
        }

        /*
         * RequestContext requestContext = RequestContext.getRequestContext(); Auth auth = requestContext.getAuth(); if (auth != null &&
         * !ignoreMethod(getMethod(parameters))) { buffer.append(""&api_sig=""); buffer.append(AuthUtilities.getSignature(sharedSecret, parameters)); }
         */

        return new URL(buffer.toString());
    }

    /**
     * Build a request URL.
     * 
     * @param host
     *            The host
     * @param port
     *            The port
     * @param path
     *            The path
     * @param parameters
     *            The parameters
     * @return The URL
     * @throws MalformedURLException
     */
    public static URL buildSecureUrl(String host, int port, String path, Map<String, String> parameters) throws MalformedURLException {
        return buildUrl(""https"", host, port, path, parameters);
    }

    public static URL buildSecurePostUrl(String host, int port, String path) throws MalformedURLException {
        return buildPostUrl(""https"", host, port, path);
    }
    
    private static void checkScheme(String scheme) {
        if (scheme == null || !(""http"".equals(scheme) || ""https"".equals(scheme))) {
            throw new IllegalArgumentException(""scheme must be http or https"");
        }
    }
    
    private static void checkSchemeAndPort(String scheme, int port) {
        checkScheme(scheme);
        /*
         * Be liberal about accepting non-default ports, but strict
         * about mismatching scheme and default port.
         */
        if (""http"".equals(scheme) && port == 443) {
            throw new IllegalArgumentException(""port 443 is invalid with http scheme"");
        }
        if (""https"".equals(scheme) && port == 80) {
            throw new IllegalArgumentException(""port 80 is invalid with https scheme"");
        }
    }
    
    /**
     * Build a POST URL with {@code http} scheme.
     * @param host the host
     * @param port the port
     * @param path the path
     * @return
     * @throws MalformedURLException 
     */
    public static URL buildPostUrl(String host, int port, String path) throws MalformedURLException {
        return buildPostUrl(""http"", host, port, path);
    }
    
    public static URL buildPostUrl(String scheme, String host, int port, String path) throws MalformedURLException {
        checkSchemeAndPort(scheme, port);
        StringBuilder buffer = new StringBuilder();
        buffer.append(scheme).append(""://"");
        buffer.append(host);
        if (port > 0) {
            buffer.append(':');
            buffer.append(port);
        }
        if (path == null) {
            path = ""/"";
        }
        buffer.append(path);
        return new URL(buffer.toString());
    }

    /**
     * Construct the BuddyIconUrl with {@code http} scheme.
     * <p>
     * If none available, return the <a href=""http://www.flickr.com/images/buddyicon.jpg"">default</a>, or an URL assembled from farm, iconserver and nsid.
     * 
     * @see <a href=""http://flickr.com/services/api/misc.buddyicons.html"">Flickr Documentation</a>
     * @param iconFarm
     * @param iconServer
     * @param id
     * @return The BuddyIconUrl
     * @deprecated use {@link #createSecureBuddyIconUrl(int, int, java.lang.String) }
     */
    @Deprecated
    public static String createBuddyIconUrl(int iconFarm, int iconServer, String id) {
        return createBuddyIconUrl(""http"", iconFarm, iconServer, id);
    }
    
    /**
     * Construct the BuddyIconUrl with {@code https} scheme.
     * <p>
     * If none available, return the <a href=""https://www.flickr.com/images/buddyicon.jpg"">default</a>, or an URL assembled from farm, iconserver and nsid.
     * 
     * @see <a href=""http://flickr.com/services/api/misc.buddyicons.html"">Flickr Documentation</a>
     * @param iconFarm
     * @param iconServer
     * @param id
     * @return The BuddyIconUrl
     */
    public static String createSecureBuddyIconUrl(int iconFarm, int iconServer, String id) {
        return createBuddyIconUrl(""https"", iconFarm, iconServer, id);
    }
    
    public static String createBuddyIconUrl(String scheme, int iconFarm, int iconServer, String id) {
        checkScheme(scheme);
        /**
         * The default-URL, if the iconServer equals 0.
         */
        String iconUrl = scheme + ""://www.flickr.com/images/buddyicon.jpg"";
        if (iconServer > 0) {
            iconUrl = scheme + ""://farm"" + iconFarm + "".staticflickr.com/"" + iconServer + ""/buddyicons/"" + id + "".jpg"";
        }
        return iconUrl;
    }

}
","package com.flickr4java.flickr.util; import java.io.UnsupportedEncodingException; import java.net.MalformedURLException; import java.net.URL; import java.net.URLEncoder; import java.util.Map; public class UrlUtilities { public static final String UTF8 = ""UTF-8""; @Deprecated
    public static URL buildUrl(String host, int port, String path, Map<String, String> parameters) throws MalformedURLException { return buildUrl(""http"", port, path, parameters); } public static URL buildUrl(String scheme, String host, int port, String path, Map<String, String> parameters) throws MalformedURLException { checkSchemeAndPort(scheme, port); StringBuilder buffer = new StringBuilder(); } buffer.append(host); if (port > 0) { buffer.append(':'); buffer.append(port); } if (path == null) { path = ""/""; } buffer.append(path); if (!parameters.isEmpty()) { buffer.append('?'); } int size = parameters.size(); for (Map.Entry<String, String> entry : parameters.entrySet()) { buffer.append(entry.getKey()); buffer.append('='); Object value = entry.getValue(); if (value != null) { String string = value.toString(); try { string = URLEncoder.encode(string, UTF8); } catch (UnsupportedEncodingException e) { } buffer.append(string); } if (--size != 0) { buffer.append('&'); } } return new URL(buffer.toString()); } public static URL buildSecureUrl(String host, int port, String path, Map<String, String> parameters) throws MalformedURLException { return buildUrl(""https"", host, port, path, parameters); } public static URL buildSecurePostUrl(String host, int port, String path) throws MalformedURLException { return buildPostUrl(""https"", host, port, path); } private static void checkScheme(String scheme) { if (scheme == null || !(""http"".equals(scheme) || ""https"".equals(scheme))) { throw new IllegalArgumentException(""scheme must be http or https""); } } private static void checkSchemeAndPort(String scheme, int port) { checkScheme(scheme); if (""http"".equals(scheme) && port == 443) { throw new IllegalArgumentException(""port 443 is invalid with http scheme""); } if (""https"".equals(scheme) && port == 80) { throw new IllegalArgumentException(""port 80 is invalid with https scheme""); } } public static URL buildPostUrl(String host, int port, String path) throws MalformedURLException { return buildPostUrl(""http"", host, port, path); } public static URL buildPostUrl(String scheme, String host, int port, String path) throws MalformedURLException { checkSchemeAndPort(scheme, port); StringBuilder buffer = new StringBuilder(); buffer.append(host); if (port > 0) { buffer.append(':'); buffer.append(port); } if (path == null) { path = ""/""; } buffer.append(path); return new URL(buffer.toString()); } @Deprecated
    public static String createBuddyIconUrl(int iconFarm, int iconServer, String id) { return createBuddyIconUrl(""http"", iconFarm, iconServer, id); } public static String createSecureBuddyIconUrl(int iconFarm, int iconServer, String id) { return createBuddyIconUrl(""https"", iconFarm, iconServer, id); } public static String createBuddyIconUrl(String scheme, int iconFarm, int iconServer, String id) { checkScheme(scheme); if (iconServer > 0) { } return iconUrl; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.util; import java.io.UnsupportedEncodingException; import java.net.MalformedURLException; import java.net.URL; import java.net.URLEncoder; import java.util.Map; public class UrlUtilities { public static final String UTF8 = ""UTF-8""; @Deprecated
    public static URL buildUrl(String host, int port, String path, Map<String, String> parameters) throws MalformedURLException { return buildUrl(""http"", port, path, parameters); } public static URL buildUrl(String scheme, String host, int port, String path, Map<String, String> parameters) throws MalformedURLException { checkSchemeAndPort(scheme, port); StringBuilder buffer = new StringBuilder(); } buffer.append(host); if (port > 0) { buffer.append(':'); buffer.append(port); } if (path == null) { path = ""/""; } buffer.append(path); if (!parameters.isEmpty()) { buffer.append('?'); } int size = parameters.size(); for (Map.Entry<String, String> entry : parameters.entrySet()) { buffer.append(entry.getKey()); buffer.append('='); Object value = entry.getValue(); if (value != null) { String string = value.toString(); try { string = URLEncoder.encode(string, UTF8); } catch (UnsupportedEncodingException e) { } buffer.append(string); } if (--size != 0) { buffer.append('&'); } } return new URL(buffer.toString()); } public static URL buildSecureUrl(String host, int port, String path, Map<String, String> parameters) throws MalformedURLException { return buildUrl(""https"", host, port, path, parameters); } public static URL buildSecurePostUrl(String host, int port, String path) throws MalformedURLException { return buildPostUrl(""https"", host, port, path); } private static void checkScheme(String scheme) { if (scheme == null || !(""http"".equals(scheme) || ""https"".equals(scheme))) { throw new IllegalArgumentException(""scheme must be http or https""); } } private static void checkSchemeAndPort(String scheme, int port) { checkScheme(scheme); if (""http"".equals(scheme) && port == 443) { throw new IllegalArgumentException(""port 443 is invalid with http scheme""); } if (""https"".equals(scheme) && port == 80) { throw new IllegalArgumentException(""port 80 is invalid with https scheme""); } } public static URL buildPostUrl(String host, int port, String path) throws MalformedURLException { return buildPostUrl(""http"", host, port, path); } public static URL buildPostUrl(String scheme, String host, int port, String path) throws MalformedURLException { checkSchemeAndPort(scheme, port); StringBuilder buffer = new StringBuilder(); buffer.append(host); if (port > 0) { buffer.append(':'); buffer.append(port); } if (path == null) { path = ""/""; } buffer.append(path); return new URL(buffer.toString()); } @Deprecated
    public static String createBuddyIconUrl(int iconFarm, int iconServer, String id) { return createBuddyIconUrl(""http"", iconFarm, iconServer, id); } public static String createSecureBuddyIconUrl(int iconFarm, int iconServer, String id) { return createBuddyIconUrl(""https"", iconFarm, iconServer, id); } public static String createBuddyIconUrl(String scheme, int iconFarm, int iconServer, String id) { checkScheme(scheme); if (iconServer > 0) { } return iconUrl; } } ","
 package com.flickr4java.flickr.util;  import java.io.UnsupportedEncodingException; import java.net.MalformedURLException; import java.net.URL; import java.net.URLEncoder; import java.util.Map;  /** 
 * @author Anthony Eden 
 * @author Mike Chaberski
 */ public class UrlUtilities {  public static final String UTF8 = ""UTF-8"";  /**
     * Build a request URL.
     * 
     * @param host
     *            The host
     * @param port
     *            The port
     * @param path
     *            The path
     * @param parameters
     *            The parameters
     * @return The URL
     * @throws MalformedURLException
     * @deprecated use {@link #buildSecureUrl(java.lang.String, int, java.lang.String, java.util.Map) }
     */ @Deprecated
    public static URL buildUrl(String host, int port, String path, Map<String, String> parameters) throws MalformedURLException { return buildUrl(""http"", port, path, parameters); }      /**
     * Build a request URL using a given scheme.
     * 
     * @param scheme the scheme, either {@code http} or {@code https}
     * @param host
     *            The host
     * @param port
     *            The port
     * @param path
     *            The path
     * @param parameters
     *            The parameters
     * @return The URL
     * @throws MalformedURLException
     */ public static URL buildUrl(String scheme, String host, int port, String path, Map<String, String> parameters) throws MalformedURLException { checkSchemeAndPort(scheme, port); StringBuilder buffer = new StringBuilder(); //"")) { //""); } buffer.append(host); if (port > 0) { buffer.append(':'); buffer.append(port); } if (path == null) { path = ""/""; } buffer.append(path);  if (!parameters.isEmpty()) { buffer.append('?'); } int size = parameters.size(); for (Map.Entry<String, String> entry : parameters.entrySet()) { buffer.append(entry.getKey()); buffer.append('='); Object value = entry.getValue(); if (value != null) { String string = value.toString(); try { string = URLEncoder.encode(string, UTF8); } catch (UnsupportedEncodingException e) { // Should never happen, but just in case } buffer.append(string); } if (--size != 0) { buffer.append('&'); } }  /*
         * RequestContext requestContext = RequestContext.getRequestContext(); Auth auth = requestContext.getAuth(); if (auth != null &&
         * !ignoreMethod(getMethod(parameters))) { buffer.append(""&api_sig=""); buffer.append(AuthUtilities.getSignature(sharedSecret, parameters)); }
         */  return new URL(buffer.toString()); }  /**
     * Build a request URL.
     * 
     * @param host
     *            The host
     * @param port
     *            The port
     * @param path
     *            The path
     * @param parameters
     *            The parameters
     * @return The URL
     * @throws MalformedURLException
     */ public static URL buildSecureUrl(String host, int port, String path, Map<String, String> parameters) throws MalformedURLException { return buildUrl(""https"", host, port, path, parameters); }  public static URL buildSecurePostUrl(String host, int port, String path) throws MalformedURLException { return buildPostUrl(""https"", host, port, path); }      private static void checkScheme(String scheme) { if (scheme == null || !(""http"".equals(scheme) || ""https"".equals(scheme))) { throw new IllegalArgumentException(""scheme must be http or https""); } }      private static void checkSchemeAndPort(String scheme, int port) { checkScheme(scheme); /*
         * Be liberal about accepting non-default ports, but strict
         * about mismatching scheme and default port.
         */ if (""http"".equals(scheme) && port == 443) { throw new IllegalArgumentException(""port 443 is invalid with http scheme""); } if (""https"".equals(scheme) && port == 80) { throw new IllegalArgumentException(""port 80 is invalid with https scheme""); } }      /**
     * Build a POST URL with {@code http} scheme.
     * @param host the host
     * @param port the port
     * @param path the path
     * @return
     * @throws MalformedURLException 
     */ public static URL buildPostUrl(String host, int port, String path) throws MalformedURLException { return buildPostUrl(""http"", host, port, path); }      public static URL buildPostUrl(String scheme, String host, int port, String path) throws MalformedURLException { checkSchemeAndPort(scheme, port); StringBuilder buffer = new StringBuilder(); //""); buffer.append(host); if (port > 0) { buffer.append(':'); buffer.append(port); } if (path == null) { path = ""/""; } buffer.append(path); return new URL(buffer.toString()); }  /**
     * Construct the BuddyIconUrl with {@code http} scheme.
     * <p>
     * If none available, return the <a href=""http://www.flickr.com/images/buddyicon.jpg"">default</a>, or an URL assembled from farm, iconserver and nsid.
     * 
     * @see <a href=""http://flickr.com/services/api/misc.buddyicons.html"">Flickr Documentation</a>
     * @param iconFarm
     * @param iconServer
     * @param id
     * @return The BuddyIconUrl
     * @deprecated use {@link #createSecureBuddyIconUrl(int, int, java.lang.String) }
     */ @Deprecated
    public static String createBuddyIconUrl(int iconFarm, int iconServer, String id) { return createBuddyIconUrl(""http"", iconFarm, iconServer, id); }      /**
     * Construct the BuddyIconUrl with {@code https} scheme.
     * <p>
     * If none available, return the <a href=""https://www.flickr.com/images/buddyicon.jpg"">default</a>, or an URL assembled from farm, iconserver and nsid.
     * 
     * @see <a href=""http://flickr.com/services/api/misc.buddyicons.html"">Flickr Documentation</a>
     * @param iconFarm
     * @param iconServer
     * @param id
     * @return The BuddyIconUrl
     */ public static String createSecureBuddyIconUrl(int iconFarm, int iconServer, String id) { return createBuddyIconUrl(""https"", iconFarm, iconServer, id); }      public static String createBuddyIconUrl(String scheme, int iconFarm, int iconServer, String id) { checkScheme(scheme); /**
         * The default-URL, if the iconServer equals 0.
         */ //www.flickr.com/images/buddyicon.jpg""; if (iconServer > 0) { //farm"" + iconFarm + "".staticflickr.com/"" + iconServer + ""/buddyicons/"" + id + "".jpg""; } return iconUrl; }  }  "
src/main/java/com/flickr4java/flickr/util/XMLUtilities.java,"
package com.flickr4java.flickr.util;

import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

/**
 * @author Anthony Eden
 * @version $Id: XMLUtilities.java,v 1.9 2009/03/04 18:46:58 x-mago Exp $
 */
public class XMLUtilities {

    private XMLUtilities() {
    }

    public static Collection<Element> getChildElements(Node node) {
        List<Element> elements = new ArrayList<Element>();
        NodeList nodes = node.getChildNodes();
        for (int i = 0; i < nodes.getLength(); i++) {
            Node childNode = nodes.item(i);
            if (childNode instanceof Element) {
                elements.add((Element) childNode);
            }
        }
        return elements;
    }

    /**
     * Get the text value for the specified element. If the element is null, or the element's body is empty then this method will return null.
     * 
     * @param element
     *            The Element
     * @return The value String or null
     */
    public static String getValue(Element element) {
        if (element != null) {
            Node dataNode = element.getFirstChild();
            if (dataNode != null) {
                return ((Text) dataNode).getData();
            }
        }
        return null;
    }

    /**
     * Get the first child element with the given name.
     * 
     * @param element
     *            The parent element
     * @param name
     *            The child element name
     * @return The child element or null
     */
    public static Element getChild(Element element, String name) {
        return (Element) element.getElementsByTagName(name).item(0);
    }

    /**
     * Get the value of the fist child element with the given name.
     * 
     * @param element
     *            The parent element
     * @param name
     *            The child element name
     * @return The child element value or null
     */
    public static String getChildValue(Element element, String name) {
        return getValue(getChild(element, name));
    }

    public static int getIntAttribute(Element el, String name) {
        String s = el.getAttribute(name);
        if (s != null && s.length() > 0) {
            return Integer.parseInt(s);
        }
        return 0;
    }

    public static boolean getBooleanAttribute(Element el, String name) {
        String s = el.getAttribute(name);
        if (s == null || ""0"".equals(s)) {
            return false;
        }
        if (""1"".equals(s)) {
            return true;
        }
        return Boolean.getBoolean(s);
    }

}
","package com.flickr4java.flickr.util; import org.w3c.dom.Element; import org.w3c.dom.Node; import org.w3c.dom.NodeList; import org.w3c.dom.Text; import java.util.ArrayList; import java.util.Collection; import java.util.List; public class XMLUtilities { private XMLUtilities() { } public static Collection<Element> getChildElements(Node node) { List<Element> elements = new ArrayList<Element>(); NodeList nodes = node.getChildNodes(); for (int i = 0; i < nodes.getLength(); i++) { Node childNode = nodes.item(i); if (childNode instanceof Element) { elements.add((Element) childNode); } } return elements; } public static String getValue(Element element) { if (element != null) { Node dataNode = element.getFirstChild(); if (dataNode != null) { return ((Text) dataNode).getData(); } } return null; } public static Element getChild(Element element, String name) { return (Element) element.getElementsByTagName(name).item(0); } public static String getChildValue(Element element, String name) { return getValue(getChild(element, name)); } public static int getIntAttribute(Element el, String name) { String s = el.getAttribute(name); if (s != null && s.length() > 0) { return Integer.parseInt(s); } return 0; } public static boolean getBooleanAttribute(Element el, String name) { String s = el.getAttribute(name); if (s == null || ""0"".equals(s)) { return false; } if (""1"".equals(s)) { return true; } return Boolean.getBoolean(s); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.util; import org.w3c.dom.Element; import org.w3c.dom.Node; import org.w3c.dom.NodeList; import org.w3c.dom.Text; import java.util.ArrayList; import java.util.Collection; import java.util.List; public class XMLUtilities { private XMLUtilities() { } public static Collection<Element> getChildElements(Node node) { List<Element> elements = new ArrayList<Element>(); NodeList nodes = node.getChildNodes(); for (int i = 0; i < nodes.getLength(); i++) { Node childNode = nodes.item(i); if (childNode instanceof Element) { elements.add((Element) childNode); } } return elements; } public static String getValue(Element element) { if (element != null) { Node dataNode = element.getFirstChild(); if (dataNode != null) { return ((Text) dataNode).getData(); } } return null; } public static Element getChild(Element element, String name) { return (Element) element.getElementsByTagName(name).item(0); } public static String getChildValue(Element element, String name) { return getValue(getChild(element, name)); } public static int getIntAttribute(Element el, String name) { String s = el.getAttribute(name); if (s != null && s.length() > 0) { return Integer.parseInt(s); } return 0; } public static boolean getBooleanAttribute(Element el, String name) { String s = el.getAttribute(name); if (s == null || ""0"".equals(s)) { return false; } if (""1"".equals(s)) { return true; } return Boolean.getBoolean(s); } } "," package com.flickr4java.flickr.util;  import org.w3c.dom.Element; import org.w3c.dom.Node; import org.w3c.dom.NodeList; import org.w3c.dom.Text;  import java.util.ArrayList; import java.util.Collection; import java.util.List;  /**
 * @author Anthony Eden
 * @version $Id: XMLUtilities.java,v 1.9 2009/03/04 18:46:58 x-mago Exp $
 */ public class XMLUtilities {  private XMLUtilities() { }  public static Collection<Element> getChildElements(Node node) { List<Element> elements = new ArrayList<Element>(); NodeList nodes = node.getChildNodes(); for (int i = 0; i < nodes.getLength(); i++) { Node childNode = nodes.item(i); if (childNode instanceof Element) { elements.add((Element) childNode); } } return elements; }  /**
     * Get the text value for the specified element. If the element is null, or the element's body is empty then this method will return null.
     * 
     * @param element
     *            The Element
     * @return The value String or null
     */ public static String getValue(Element element) { if (element != null) { Node dataNode = element.getFirstChild(); if (dataNode != null) { return ((Text) dataNode).getData(); } } return null; }  /**
     * Get the first child element with the given name.
     * 
     * @param element
     *            The parent element
     * @param name
     *            The child element name
     * @return The child element or null
     */ public static Element getChild(Element element, String name) { return (Element) element.getElementsByTagName(name).item(0); }  /**
     * Get the value of the fist child element with the given name.
     * 
     * @param element
     *            The parent element
     * @param name
     *            The child element name
     * @return The child element value or null
     */ public static String getChildValue(Element element, String name) { return getValue(getChild(element, name)); }  public static int getIntAttribute(Element el, String name) { String s = el.getAttribute(name); if (s != null && s.length() > 0) { return Integer.parseInt(s); } return 0; }  public static boolean getBooleanAttribute(Element el, String name) { String s = el.getAttribute(name); if (s == null || ""0"".equals(s)) { return false; } if (""1"".equals(s)) { return true; } return Boolean.getBoolean(s); }  }  "
src/test/java/com/flickr4java/flickr/test/ActivityInterfaceTest.java,"package com.flickr4java.flickr.test;

import static org.junit.Assert.assertTrue;

import org.junit.Test;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.activity.ActivityInterface;
import com.flickr4java.flickr.activity.Item;
import com.flickr4java.flickr.activity.ItemList;

/**
 * 
 * @author mago
 * @version $Id: ActivityInterfaceTest.java,v 1.3 2009/06/30 18:48:59 x-mago Exp $
 */
public class ActivityInterfaceTest extends Flickr4JavaTest {

    @Test
    public void testUserComments() throws FlickrException {
        ActivityInterface actInterface = flickr.getActivityInterface();
        ItemList<Item> list = actInterface.userComments(10, 1);
        assertTrue(list.size() > 0);
    }

    @Test
    public void testUserPhotos() throws FlickrException {
        ActivityInterface actInterface = flickr.getActivityInterface();
        ItemList<Item> list = actInterface.userPhotos(10, 1, ""6000d"");
        assertTrue(list.size() > 0);
    }

    @Test
    public void testCheckTimeframeArg() {
        ActivityInterface actInterface = flickr.getActivityInterface();
        assertTrue(actInterface.checkTimeframeArg(""300d""));
    }
}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertTrue; import org.junit.Test; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.activity.ActivityInterface; import com.flickr4java.flickr.activity.Item; import com.flickr4java.flickr.activity.ItemList; public class ActivityInterfaceTest extends Flickr4JavaTest { @Test
    public void testUserComments() throws FlickrException { ActivityInterface actInterface = flickr.getActivityInterface(); ItemList<Item> list = actInterface.userComments(10, 1); assertTrue(list.size() > 0); } @Test
    public void testUserPhotos() throws FlickrException { ActivityInterface actInterface = flickr.getActivityInterface(); ItemList<Item> list = actInterface.userPhotos(10, 1, ""6000d""); assertTrue(list.size() > 0); } @Test
    public void testCheckTimeframeArg() { ActivityInterface actInterface = flickr.getActivityInterface(); assertTrue(actInterface.checkTimeframeArg(""300d"")); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertTrue; import org.junit.Test; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.activity.ActivityInterface; import com.flickr4java.flickr.activity.Item; import com.flickr4java.flickr.activity.ItemList; public class ActivityInterfaceTest extends Flickr4JavaTest { @Test
    public void testUserComments() throws FlickrException { ActivityInterface actInterface = flickr.getActivityInterface(); ItemList<Item> list = actInterface.userComments(10, 1); assertTrue(list.size() > 0); } @Test
    public void testUserPhotos() throws FlickrException { ActivityInterface actInterface = flickr.getActivityInterface(); ItemList<Item> list = actInterface.userPhotos(10, 1, ""6000d""); assertTrue(list.size() > 0); } @Test
    public void testCheckTimeframeArg() { ActivityInterface actInterface = flickr.getActivityInterface(); assertTrue(actInterface.checkTimeframeArg(""300d"")); } } ","package com.flickr4java.flickr.test;  import static org.junit.Assert.assertTrue;  import org.junit.Test;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.activity.ActivityInterface; import com.flickr4java.flickr.activity.Item; import com.flickr4java.flickr.activity.ItemList;  /**
 * 
 * @author mago
 * @version $Id: ActivityInterfaceTest.java,v 1.3 2009/06/30 18:48:59 x-mago Exp $
 */ public class ActivityInterfaceTest extends Flickr4JavaTest {  @Test
    public void testUserComments() throws FlickrException { ActivityInterface actInterface = flickr.getActivityInterface(); ItemList<Item> list = actInterface.userComments(10, 1); assertTrue(list.size() > 0); }  @Test
    public void testUserPhotos() throws FlickrException { ActivityInterface actInterface = flickr.getActivityInterface(); ItemList<Item> list = actInterface.userPhotos(10, 1, ""6000d""); assertTrue(list.size() > 0); }  @Test
    public void testCheckTimeframeArg() { ActivityInterface actInterface = flickr.getActivityInterface(); assertTrue(actInterface.checkTimeframeArg(""300d"")); } }  "
src/test/java/com/flickr4java/flickr/test/AuthInterfaceTest.java,"

package com.flickr4java.flickr.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.awt.Desktop;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Scanner;
import java.util.concurrent.ExecutionException;

import com.github.scribejava.core.model.OAuth1RequestToken;
import com.github.scribejava.core.model.OAuth1Token;
import org.junit.Ignore;
import org.junit.Test;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.auth.Auth;
import com.flickr4java.flickr.auth.AuthInterface;
import com.flickr4java.flickr.auth.Permission;

/**
 * @author Anthony Eden
 */
public class AuthInterfaceTest extends Flickr4JavaTest {

    @Test
    @Ignore
    // Ignored as test is interactive so would fail a build
    public void testAuthFlow() throws IOException, URISyntaxException, ExecutionException, InterruptedException, FlickrException {

        AuthInterface authInterface = flickr.getAuthInterface();

        OAuth1RequestToken requestToken = authInterface.getRequestToken();

        assertNotNull(requestToken);
        assertNotNull(requestToken.getToken());
        assertNotNull(requestToken.getTokenSecret());
        assertTrue(requestToken.getRawResponse().contains(""oauth_callback_confirmed=true""));

        String url = authInterface.getAuthorizationUrl(requestToken, Permission.READ);

        assertNotNull(url);
        assertEquals(
                String.format(""http://www.flickr.com/services/oauth/authorize?oauth_token=%s&perms=%s"", requestToken.getToken(), Permission.READ.toString()),
                url);

        Desktop desktop = Desktop.getDesktop();
        if (!desktop.isSupported(java.awt.Desktop.Action.BROWSE)) {
            System.out.println(""Paste this URL into your browser"");
            System.out.println(url);
        } else {
            URI uri = new URI(url);
            desktop.browse(uri);
        }

        Scanner in = new Scanner(System.in);
        System.out.println(""Enter the given authorization code provided by Flickr auth"");
        System.out.print("">>"");
        String code = in.nextLine();

        assertNotNull(code);

        OAuth1Token accessToken = authInterface.getAccessToken(requestToken, code);

        assertNotNull(accessToken);
        assertNotNull(accessToken.getToken());
        assertNotNull(accessToken.getTokenSecret());

        Auth checkedAuth = authInterface.checkToken(accessToken);
        assertNotNull(checkedAuth);
        assertEquals(accessToken.getToken(), checkedAuth.getToken());
        assertEquals(accessToken.getTokenSecret(), checkedAuth.getTokenSecret());
        assertEquals(Permission.READ, checkedAuth.getPermission());
        assertNotNull(checkedAuth.getUser());
        assertNotNull(checkedAuth.getUser().getUsername());
    }

    @Test
    @Ignore
    // Ignored as test is interactive so would fail a build
    public void testExchangeToken() throws FlickrException {

        AuthInterface authInterface = flickr.getAuthInterface();

        Scanner in = new Scanner(System.in);
        System.out.println(""Enter the Flickr auth token to exchange"");
        System.out.print("">>"");
        String flickrAuthToken = in.nextLine();

        OAuth1RequestToken oAuthToken = authInterface.exchangeAuthToken(flickrAuthToken);

        assertNotNull(oAuthToken);
        assertNotNull(oAuthToken.getToken());
        assertNotNull(oAuthToken.getTokenSecret());
    }
}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import java.awt.Desktop; import java.io.IOException; import java.net.URI; import java.net.URISyntaxException; import java.util.Scanner; import java.util.concurrent.ExecutionException; import com.github.scribejava.core.model.OAuth1RequestToken; import com.github.scribejava.core.model.OAuth1Token; import org.junit.Ignore; import org.junit.Test; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.auth.AuthInterface; import com.flickr4java.flickr.auth.Permission; public class AuthInterfaceTest extends Flickr4JavaTest { public void testAuthFlow() throws IOException, URISyntaxException, ExecutionException, InterruptedException, FlickrException { AuthInterface authInterface = flickr.getAuthInterface(); OAuth1RequestToken requestToken = authInterface.getRequestToken(); assertNotNull(requestToken); assertNotNull(requestToken.getToken()); assertNotNull(requestToken.getTokenSecret()); assertTrue(requestToken.getRawResponse().contains(""oauth_callback_confirmed=true"")); String url = authInterface.getAuthorizationUrl(requestToken, Permission.READ); assertNotNull(url); url); Desktop desktop = Desktop.getDesktop(); if (!desktop.isSupported(java.awt.Desktop.Action.BROWSE)) { System.out.println(""Paste this URL into your browser""); System.out.println(url); } else { URI uri = new URI(url); desktop.browse(uri); } Scanner in = new Scanner(System.in); System.out.println(""Enter the given authorization code provided by Flickr auth""); System.out.print("">>""); String code = in.nextLine(); assertNotNull(code); OAuth1Token accessToken = authInterface.getAccessToken(requestToken, code); assertNotNull(accessToken); assertNotNull(accessToken.getToken()); assertNotNull(accessToken.getTokenSecret()); Auth checkedAuth = authInterface.checkToken(accessToken); assertNotNull(checkedAuth); assertEquals(accessToken.getToken(), checkedAuth.getToken()); assertEquals(accessToken.getTokenSecret(), checkedAuth.getTokenSecret()); assertEquals(Permission.READ, checkedAuth.getPermission()); assertNotNull(checkedAuth.getUser()); assertNotNull(checkedAuth.getUser().getUsername()); } public void testExchangeToken() throws FlickrException { AuthInterface authInterface = flickr.getAuthInterface(); Scanner in = new Scanner(System.in); System.out.println(""Enter the Flickr auth token to exchange""); System.out.print("">>""); String flickrAuthToken = in.nextLine(); OAuth1RequestToken oAuthToken = authInterface.exchangeAuthToken(flickrAuthToken); assertNotNull(oAuthToken); assertNotNull(oAuthToken.getToken()); assertNotNull(oAuthToken.getTokenSecret()); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import java.awt.Desktop; import java.io.IOException; import java.net.URI; import java.net.URISyntaxException; import java.util.Scanner; import java.util.concurrent.ExecutionException; import com.github.scribejava.core.model.OAuth1RequestToken; import com.github.scribejava.core.model.OAuth1Token; import org.junit.Ignore; import org.junit.Test; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.auth.AuthInterface; import com.flickr4java.flickr.auth.Permission; public class AuthInterfaceTest extends Flickr4JavaTest { public void testAuthFlow() throws IOException, URISyntaxException, ExecutionException, InterruptedException, FlickrException { AuthInterface authInterface = flickr.getAuthInterface(); OAuth1RequestToken requestToken = authInterface.getRequestToken(); assertNotNull(requestToken); assertNotNull(requestToken.getToken()); assertNotNull(requestToken.getTokenSecret()); assertTrue(requestToken.getRawResponse().contains(""oauth_callback_confirmed=true"")); String url = authInterface.getAuthorizationUrl(requestToken, Permission.READ); assertNotNull(url); url); Desktop desktop = Desktop.getDesktop(); if (!desktop.isSupported(java.awt.Desktop.Action.BROWSE)) { System.out.println(""Paste this URL into your browser""); System.out.println(url); } else { URI uri = new URI(url); desktop.browse(uri); } Scanner in = new Scanner(System.in); System.out.println(""Enter the given authorization code provided by Flickr auth""); System.out.print("">>""); String code = in.nextLine(); assertNotNull(code); OAuth1Token accessToken = authInterface.getAccessToken(requestToken, code); assertNotNull(accessToken); assertNotNull(accessToken.getToken()); assertNotNull(accessToken.getTokenSecret()); Auth checkedAuth = authInterface.checkToken(accessToken); assertNotNull(checkedAuth); assertEquals(accessToken.getToken(), checkedAuth.getToken()); assertEquals(accessToken.getTokenSecret(), checkedAuth.getTokenSecret()); assertEquals(Permission.READ, checkedAuth.getPermission()); assertNotNull(checkedAuth.getUser()); assertNotNull(checkedAuth.getUser().getUsername()); } public void testExchangeToken() throws FlickrException { AuthInterface authInterface = flickr.getAuthInterface(); Scanner in = new Scanner(System.in); System.out.println(""Enter the Flickr auth token to exchange""); System.out.print("">>""); String flickrAuthToken = in.nextLine(); OAuth1RequestToken oAuthToken = authInterface.exchangeAuthToken(flickrAuthToken); assertNotNull(oAuthToken); assertNotNull(oAuthToken.getToken()); assertNotNull(oAuthToken.getTokenSecret()); } } ","
 package com.flickr4java.flickr.test;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue;  import java.awt.Desktop; import java.io.IOException; import java.net.URI; import java.net.URISyntaxException; import java.util.Scanner; import java.util.concurrent.ExecutionException;  import com.github.scribejava.core.model.OAuth1RequestToken; import com.github.scribejava.core.model.OAuth1Token; import org.junit.Ignore; import org.junit.Test;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.auth.AuthInterface; import com.flickr4java.flickr.auth.Permission;  /**
 * @author Anthony Eden
 */ public class AuthInterfaceTest extends Flickr4JavaTest {  // Ignored as test is interactive so would fail a build public void testAuthFlow() throws IOException, URISyntaxException, ExecutionException, InterruptedException, FlickrException {  AuthInterface authInterface = flickr.getAuthInterface();  OAuth1RequestToken requestToken = authInterface.getRequestToken();  assertNotNull(requestToken); assertNotNull(requestToken.getToken()); assertNotNull(requestToken.getTokenSecret()); assertTrue(requestToken.getRawResponse().contains(""oauth_callback_confirmed=true""));  String url = authInterface.getAuthorizationUrl(requestToken, Permission.READ);  assertNotNull(url); //www.flickr.com/services/oauth/authorize?oauth_token=%s&perms=%s"", requestToken.getToken(), Permission.READ.toString()), url);  Desktop desktop = Desktop.getDesktop(); if (!desktop.isSupported(java.awt.Desktop.Action.BROWSE)) { System.out.println(""Paste this URL into your browser""); System.out.println(url); } else { URI uri = new URI(url); desktop.browse(uri); }  Scanner in = new Scanner(System.in); System.out.println(""Enter the given authorization code provided by Flickr auth""); System.out.print("">>""); String code = in.nextLine();  assertNotNull(code);  OAuth1Token accessToken = authInterface.getAccessToken(requestToken, code);  assertNotNull(accessToken); assertNotNull(accessToken.getToken()); assertNotNull(accessToken.getTokenSecret());  Auth checkedAuth = authInterface.checkToken(accessToken); assertNotNull(checkedAuth); assertEquals(accessToken.getToken(), checkedAuth.getToken()); assertEquals(accessToken.getTokenSecret(), checkedAuth.getTokenSecret()); assertEquals(Permission.READ, checkedAuth.getPermission()); assertNotNull(checkedAuth.getUser()); assertNotNull(checkedAuth.getUser().getUsername()); }  // Ignored as test is interactive so would fail a build public void testExchangeToken() throws FlickrException {  AuthInterface authInterface = flickr.getAuthInterface();  Scanner in = new Scanner(System.in); System.out.println(""Enter the Flickr auth token to exchange""); System.out.print("">>""); String flickrAuthToken = in.nextLine();  OAuth1RequestToken oAuthToken = authInterface.exchangeAuthToken(flickrAuthToken);  assertNotNull(oAuthToken); assertNotNull(oAuthToken.getToken()); assertNotNull(oAuthToken.getTokenSecret()); } }  "
src/test/java/com/flickr4java/flickr/test/AuthUtilitiesTest.java,"package com.flickr4java.flickr.test;

import org.junit.Ignore;

/**
 * Test the AuthUtilities.
 * 
 * @author Anthony Eden
 */
@Ignore
public class AuthUtilitiesTest {

}
","package com.flickr4java.flickr.test; import org.junit.Ignore; @Ignore
public class AuthUtilitiesTest { }",0 0 0 0 0,"package com.flickr4java.flickr.test; import org.junit.Ignore; @Ignore
public class AuthUtilitiesTest { } ","package com.flickr4java.flickr.test;  import org.junit.Ignore;  /**
 * Test the AuthUtilities.
 * 
 * @author Anthony Eden
 */ @Ignore
public class AuthUtilitiesTest {  }  "
src/test/java/com/flickr4java/flickr/test/BlogsInterfaceTest.java,"

package com.flickr4java.flickr.test;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.blogs.Blog;
import com.flickr4java.flickr.blogs.BlogsInterface;
import com.flickr4java.flickr.blogs.Service;

import org.junit.Ignore;
import org.junit.Test;

import java.util.Collection;
import java.util.Iterator;

/**
 * @author Anthony Eden
 */
public class BlogsInterfaceTest extends Flickr4JavaTest {

    @Test
    public void testGetList() throws FlickrException {
        BlogsInterface blogsInterface = flickr.getBlogsInterface();
        Collection<Blog> blogs = blogsInterface.getList();
        assertNotNull(blogs);
    }

    @Test
    public void testGetServices() throws FlickrException {
        BlogsInterface blogsInterface = flickr.getBlogsInterface();
        Collection<Service> services = blogsInterface.getServices();
        Iterator<Service> it = services.iterator();
        boolean bloggerFound = false;
        while (it.hasNext()) {
            Service ser = it.next();
            if (ser.getId().equals(""beta.blogger.com"") && ser.getName().equals(""Blogger"")) {
                bloggerFound = true;
            }
            // System.out.println(ser.getId() + "" "" + ser.getName());
        }
        assertTrue(bloggerFound);
    }

    @Ignore
    @Test
    public void testPostImage() {
        // TODO: implement this test
    }

}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.blogs.Blog; import com.flickr4java.flickr.blogs.BlogsInterface; import com.flickr4java.flickr.blogs.Service; import org.junit.Ignore; import org.junit.Test; import java.util.Collection; import java.util.Iterator; public class BlogsInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetList() throws FlickrException { BlogsInterface blogsInterface = flickr.getBlogsInterface(); Collection<Blog> blogs = blogsInterface.getList(); assertNotNull(blogs); } @Test
    public void testGetServices() throws FlickrException { BlogsInterface blogsInterface = flickr.getBlogsInterface(); Collection<Service> services = blogsInterface.getServices(); Iterator<Service> it = services.iterator(); boolean bloggerFound = false; while (it.hasNext()) { Service ser = it.next(); if (ser.getId().equals(""beta.blogger.com"") && ser.getName().equals(""Blogger"")) { bloggerFound = true; } } assertTrue(bloggerFound); } @Ignore
    @Test
    public void testPostImage() { } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.blogs.Blog; import com.flickr4java.flickr.blogs.BlogsInterface; import com.flickr4java.flickr.blogs.Service; import org.junit.Ignore; import org.junit.Test; import java.util.Collection; import java.util.Iterator; public class BlogsInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetList() throws FlickrException { BlogsInterface blogsInterface = flickr.getBlogsInterface(); Collection<Blog> blogs = blogsInterface.getList(); assertNotNull(blogs); } @Test
    public void testGetServices() throws FlickrException { BlogsInterface blogsInterface = flickr.getBlogsInterface(); Collection<Service> services = blogsInterface.getServices(); Iterator<Service> it = services.iterator(); boolean bloggerFound = false; while (it.hasNext()) { Service ser = it.next(); if (ser.getId().equals(""beta.blogger.com"") && ser.getName().equals(""Blogger"")) { bloggerFound = true; } } assertTrue(bloggerFound); } @Ignore
    @Test
    public void testPostImage() { } } ","
 package com.flickr4java.flickr.test;  import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.blogs.Blog; import com.flickr4java.flickr.blogs.BlogsInterface; import com.flickr4java.flickr.blogs.Service;  import org.junit.Ignore; import org.junit.Test;  import java.util.Collection; import java.util.Iterator;  /**
 * @author Anthony Eden
 */ public class BlogsInterfaceTest extends Flickr4JavaTest {  @Test
    public void testGetList() throws FlickrException { BlogsInterface blogsInterface = flickr.getBlogsInterface(); Collection<Blog> blogs = blogsInterface.getList(); assertNotNull(blogs); }  @Test
    public void testGetServices() throws FlickrException { BlogsInterface blogsInterface = flickr.getBlogsInterface(); Collection<Service> services = blogsInterface.getServices(); Iterator<Service> it = services.iterator(); boolean bloggerFound = false; while (it.hasNext()) { Service ser = it.next(); if (ser.getId().equals(""beta.blogger.com"") && ser.getName().equals(""Blogger"")) { bloggerFound = true; } // System.out.println(ser.getId() + "" "" + ser.getName()); } assertTrue(bloggerFound); }  @Ignore
    @Test
    public void testPostImage() { // TODO: implement this test }  }  "
src/test/java/com/flickr4java/flickr/test/CamerasInterfaceTest.java,"package com.flickr4java.flickr.test;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import com.flickr4java.flickr.Flickr;
import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.cameras.Brand;
import com.flickr4java.flickr.cameras.Camera;
import com.flickr4java.flickr.cameras.CamerasInterface;

import org.junit.Test;

import java.util.Collection;

public class CamerasInterfaceTest extends Flickr4JavaTest {

    @Test
    public void testGetBrands() throws FlickrException {

        // not implementing much for tests here - flickr doesn't give us much to go on.
        CamerasInterface camInterface = flickr.getCamerasInterface();
        Collection<Brand> brands = camInterface.getBrands();
        assertNotNull(brands);
        assertTrue(brands.size() > 0);
    }

    @Test
    public void testGetBrandModels() throws FlickrException {

        // not implementing much for tests here - flickr doesn't give us much to go on.
        // the interface may not be final - the documented xml nodes don't correspond to what is in the xml
        CamerasInterface camInterface = flickr.getCamerasInterface();
        Flickr.debugStream = true;
        Collection<Camera> cams = camInterface.getBrandModels(""Canon"");
        assertNotNull(cams);
        assertTrue(cams.size() > 0);
        for (Camera cam : cams) {
            assertNotNull(cam.getId());
            assertNotNull(cam.getName());
            /*
             * assertNotNull(cam.getSmallImage()); assertNotNull(cam.getLargeImage()); assertNotNull(cam.getDetails().getMegapixels());
             * assertNotNull(cam.getDetails().getZoom()); assertNotNull(cam.getDetails().getLcdSize()); assertNotNull(cam.getDetails().getStorageType());
             */}
    }

}
","package com.flickr4java.flickr.test; public class CamerasInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetBrands() throws FlickrException { CamerasInterface camInterface = flickr.getCamerasInterface(); Collection<Brand> brands = camInterface.getBrands(); assertNotNull(brands); assertTrue(brands.size() > 0); } @Test
    public void testGetBrandModels() throws FlickrException { CamerasInterface camInterface = flickr.getCamerasInterface(); Flickr.debugStream = true; Collection<Camera> cams = camInterface.getBrandModels(""Canon""); assertNotNull(cams); assertTrue(cams.size() > 0); for (Camera cam : cams) { assertNotNull(cam.getId()); assertNotNull(cam.getName()); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; public class CamerasInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetBrands() throws FlickrException { CamerasInterface camInterface = flickr.getCamerasInterface(); Collection<Brand> brands = camInterface.getBrands(); assertNotNull(brands); assertTrue(brands.size() > 0); } @Test
    public void testGetBrandModels() throws FlickrException { CamerasInterface camInterface = flickr.getCamerasInterface(); Flickr.debugStream = true; Collection<Camera> cams = camInterface.getBrandModels(""Canon""); assertNotNull(cams); assertTrue(cams.size() > 0); for (Camera cam : cams) { assertNotNull(cam.getId()); assertNotNull(cam.getName()); } } ","package com.flickr4java.flickr.test; 
import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; 
import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.cameras.Brand; import com.flickr4java.flickr.cameras.Camera; import com.flickr4java.flickr.cameras.CamerasInterface; 
import org.junit.Test; 
import java.util.Collection;  public class CamerasInterfaceTest extends Flickr4JavaTest {  @Test
    public void testGetBrands() throws FlickrException {  // not implementing much for tests here - flickr doesn't give us much to go on. CamerasInterface camInterface = flickr.getCamerasInterface(); Collection<Brand> brands = camInterface.getBrands(); assertNotNull(brands); assertTrue(brands.size() > 0); }  @Test
    public void testGetBrandModels() throws FlickrException {  // not implementing much for tests here - flickr doesn't give us much to go on. // the interface may not be final - the documented xml nodes don't correspond to what is in the xml CamerasInterface camInterface = flickr.getCamerasInterface(); Flickr.debugStream = true; Collection<Camera> cams = camInterface.getBrandModels(""Canon""); assertNotNull(cams); assertTrue(cams.size() > 0); for (Camera cam : cams) { assertNotNull(cam.getId()); assertNotNull(cam.getName()); /*
             * assertNotNull(cam.getSmallImage()); assertNotNull(cam.getLargeImage()); assertNotNull(cam.getDetails().getMegapixels());
             * assertNotNull(cam.getDetails().getZoom()); assertNotNull(cam.getDetails().getLcdSize()); assertNotNull(cam.getDetails().getStorageType());
             */ }  }  "
src/test/java/com/flickr4java/flickr/test/CollectionsInterfaceTest.java,"package com.flickr4java.flickr.test;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.collections.Collection;
import com.flickr4java.flickr.collections.CollectionsInterface;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photosets.Photoset;

import org.junit.Test;

import java.util.List;

/**
 * @author Darren Greaves
 */
public class CollectionsInterfaceTest extends Flickr4JavaTest {

    @Test
    public void testGetInfo() throws FlickrException {
        CollectionsInterface iface = flickr.getCollectionsInterface();
        Collection collection = iface.getInfo(testProperties.getCollectionId());
        assertNotNull(collection);
        assertNotNull(collection.getId());
        assertNotNull(collection.getIconLarge());
        assertNotNull(collection.getIconSmall());
        assertNotNull(collection.getDateCreated());
        assertNotNull(collection.getDescription());
        assertNotNull(collection.getTitle());
        assertNotNull(collection.getServer());
        assertNotNull(collection.getSecret());

        List<Photo> photos = collection.getPhotos();
        assertNotNull(photos);
        for (Photo photo : photos) {
            assertNotNull(photo.getId());
        }
        assertTrue(collection.getChildCount() >= 1);
    }

    @Test
    public void testGetTreeNoUserId() throws FlickrException {
        CollectionsInterface iface = flickr.getCollectionsInterface();
        List<Collection> collections = iface.getTree(testProperties.getCollectionId(), null);

        assertNotNull(collections);

        for (Collection collection : collections) {
            assertNotNull(collection);
            assertNotNull(collection.getId());
            assertNotNull(collection.getIconLarge());
            assertNotNull(collection.getIconSmall());
            assertNotNull(collection.getDescription());
            assertNotNull(collection.getTitle());
            assertNull(collection.getServer());
            assertNull(collection.getSecret());

            List<Photo> photos = collection.getPhotos();
            assertNotNull(photos);
            assertTrue(photos.isEmpty());

            List<Photoset> photosets = collection.getPhotosets();
            assertNotNull(photosets);
            for (Photoset photoset : photosets) {
                assertNotNull(photoset.getId());
                assertNotNull(photoset.getTitle());
                assertNotNull(photoset.getDescription());
            }

            List<Collection> childCollections = collection.getCollections();
            for (Collection childCollection : childCollections) {
                assertNotNull(childCollection.getId());
                assertNotNull(childCollection.getIconLarge());
                assertNotNull(childCollection.getIconSmall());
                assertNotNull(childCollection.getDescription());
                assertNotNull(childCollection.getTitle());
            }
        }
    }

}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.collections.Collection; import com.flickr4java.flickr.collections.CollectionsInterface; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photosets.Photoset; import org.junit.Test; import java.util.List; public class CollectionsInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetInfo() throws FlickrException { CollectionsInterface iface = flickr.getCollectionsInterface(); Collection collection = iface.getInfo(testProperties.getCollectionId()); assertNotNull(collection); assertNotNull(collection.getId()); assertNotNull(collection.getIconLarge()); assertNotNull(collection.getIconSmall()); assertNotNull(collection.getDateCreated()); assertNotNull(collection.getDescription()); assertNotNull(collection.getTitle()); assertNotNull(collection.getServer()); assertNotNull(collection.getSecret()); List<Photo> photos = collection.getPhotos(); assertNotNull(photos); for (Photo photo : photos) { assertNotNull(photo.getId()); } assertTrue(collection.getChildCount() >= 1); } @Test
    public void testGetTreeNoUserId() throws FlickrException { CollectionsInterface iface = flickr.getCollectionsInterface(); List<Collection> collections = iface.getTree(testProperties.getCollectionId(), null); assertNotNull(collections); for (Collection collection : collections) { assertNotNull(collection); assertNotNull(collection.getId()); assertNotNull(collection.getIconLarge()); assertNotNull(collection.getIconSmall()); assertNotNull(collection.getDescription()); assertNotNull(collection.getTitle()); assertNull(collection.getServer()); assertNull(collection.getSecret()); List<Photo> photos = collection.getPhotos(); assertNotNull(photos); assertTrue(photos.isEmpty()); List<Photoset> photosets = collection.getPhotosets(); assertNotNull(photosets); for (Photoset photoset : photosets) { assertNotNull(photoset.getId()); assertNotNull(photoset.getTitle()); assertNotNull(photoset.getDescription()); } List<Collection> childCollections = collection.getCollections(); for (Collection childCollection : childCollections) { assertNotNull(childCollection.getId()); assertNotNull(childCollection.getIconLarge()); assertNotNull(childCollection.getIconSmall()); assertNotNull(childCollection.getDescription()); assertNotNull(childCollection.getTitle()); } } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.collections.Collection; import com.flickr4java.flickr.collections.CollectionsInterface; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photosets.Photoset; import org.junit.Test; import java.util.List; public class CollectionsInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetInfo() throws FlickrException { CollectionsInterface iface = flickr.getCollectionsInterface(); Collection collection = iface.getInfo(testProperties.getCollectionId()); assertNotNull(collection); assertNotNull(collection.getId()); assertNotNull(collection.getIconLarge()); assertNotNull(collection.getIconSmall()); assertNotNull(collection.getDateCreated()); assertNotNull(collection.getDescription()); assertNotNull(collection.getTitle()); assertNotNull(collection.getServer()); assertNotNull(collection.getSecret()); List<Photo> photos = collection.getPhotos(); assertNotNull(photos); for (Photo photo : photos) { assertNotNull(photo.getId()); } assertTrue(collection.getChildCount() >= 1); } @Test
    public void testGetTreeNoUserId() throws FlickrException { CollectionsInterface iface = flickr.getCollectionsInterface(); List<Collection> collections = iface.getTree(testProperties.getCollectionId(), null); assertNotNull(collections); for (Collection collection : collections) { assertNotNull(collection); assertNotNull(collection.getId()); assertNotNull(collection.getIconLarge()); assertNotNull(collection.getIconSmall()); assertNotNull(collection.getDescription()); assertNotNull(collection.getTitle()); assertNull(collection.getServer()); assertNull(collection.getSecret()); List<Photo> photos = collection.getPhotos(); assertNotNull(photos); assertTrue(photos.isEmpty()); List<Photoset> photosets = collection.getPhotosets(); assertNotNull(photosets); for (Photoset photoset : photosets) { assertNotNull(photoset.getId()); assertNotNull(photoset.getTitle()); assertNotNull(photoset.getDescription()); } List<Collection> childCollections = collection.getCollections(); for (Collection childCollection : childCollections) { assertNotNull(childCollection.getId()); assertNotNull(childCollection.getIconLarge()); assertNotNull(childCollection.getIconSmall()); assertNotNull(childCollection.getDescription()); assertNotNull(childCollection.getTitle()); } } } } ","package com.flickr4java.flickr.test;  import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.collections.Collection; import com.flickr4java.flickr.collections.CollectionsInterface; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photosets.Photoset;  import org.junit.Test;  import java.util.List;  /**
 * @author Darren Greaves
 */ public class CollectionsInterfaceTest extends Flickr4JavaTest {  @Test
    public void testGetInfo() throws FlickrException { CollectionsInterface iface = flickr.getCollectionsInterface(); Collection collection = iface.getInfo(testProperties.getCollectionId()); assertNotNull(collection); assertNotNull(collection.getId()); assertNotNull(collection.getIconLarge()); assertNotNull(collection.getIconSmall()); assertNotNull(collection.getDateCreated()); assertNotNull(collection.getDescription()); assertNotNull(collection.getTitle()); assertNotNull(collection.getServer()); assertNotNull(collection.getSecret());  List<Photo> photos = collection.getPhotos(); assertNotNull(photos); for (Photo photo : photos) { assertNotNull(photo.getId()); } assertTrue(collection.getChildCount() >= 1); }  @Test
    public void testGetTreeNoUserId() throws FlickrException { CollectionsInterface iface = flickr.getCollectionsInterface(); List<Collection> collections = iface.getTree(testProperties.getCollectionId(), null);  assertNotNull(collections);  for (Collection collection : collections) { assertNotNull(collection); assertNotNull(collection.getId()); assertNotNull(collection.getIconLarge()); assertNotNull(collection.getIconSmall()); assertNotNull(collection.getDescription()); assertNotNull(collection.getTitle()); assertNull(collection.getServer()); assertNull(collection.getSecret());  List<Photo> photos = collection.getPhotos(); assertNotNull(photos); assertTrue(photos.isEmpty());  List<Photoset> photosets = collection.getPhotosets(); assertNotNull(photosets); for (Photoset photoset : photosets) { assertNotNull(photoset.getId()); assertNotNull(photoset.getTitle()); assertNotNull(photoset.getDescription()); }  List<Collection> childCollections = collection.getCollections(); for (Collection childCollection : childCollections) { assertNotNull(childCollection.getId()); assertNotNull(childCollection.getIconLarge()); assertNotNull(childCollection.getIconSmall()); assertNotNull(childCollection.getDescription()); assertNotNull(childCollection.getTitle()); } } }  }  "
src/test/java/com/flickr4java/flickr/test/CommentsInterfaceTest.java,"package com.flickr4java.flickr.test;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import java.util.Iterator;
import java.util.List;

import org.junit.Test;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.photos.Extras;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoList;
import com.flickr4java.flickr.photos.comments.Comment;
import com.flickr4java.flickr.photos.comments.CommentsInterface;

/**
 * 
 * @author till (Till Krech) flickr:extranoise
 * @version $Id: CommentsInterfaceTest.java,v 1.7 2009/06/30 18:48:59 x-mago Exp $
 */
public class CommentsInterfaceTest extends Flickr4JavaTest {

    @Test
    public void testGetList() throws FlickrException {
        String photoId = ""245253195""; // http://www.flickr.com/photos/extranoise/245253195/
        CommentsInterface ci = flickr.getCommentsInterface();
        List<Comment> comments = ci.getList(photoId);
        assertNotNull(comments);
        assertTrue(comments.size() > 0);
        Iterator<Comment> commentsIterator = comments.iterator();

        while (commentsIterator.hasNext()) {
            Comment comment = (Comment) commentsIterator.next();
            assertNotNull(comment.getId());
            assertNotNull(comment.getAuthor());
            assertNotNull(comment.getAuthorName());
            assertNotNull(comment.getDateCreate());
            assertNotNull(comment.getPermaLink());
            assertNotNull(comment.getText());
        }
    }

    @Test
    public void testComment() throws FlickrException {
        String photoId = testProperties.getPhotoId(); // http://www.flickr.com/photos/javatest3/419231219/
        String txt1 = ""This is a test for the flickr java api"";
        String txt2 = ""This is an edited comment for the java flickr api"";
        CommentsInterface ci = flickr.getCommentsInterface();
        // add a comment
        String commentId = ci.addComment(photoId, txt1);
        // System.out.println(""Comment Id:"" + commentId);
        assertNotNull(commentId);
        assertTrue(commentId.length() > 0);

        // change the comment text and verify change
        ci.editComment(commentId, txt2);

        // delete the comment
        ci.deleteComment(commentId);
        Comment comment = findCommment(photoId, commentId);
        assertNull(comment);
    }

    // helper function to find a comment by it's id for a specified photo
    private Comment findCommment(String photoId, String commentId) throws FlickrException {
        CommentsInterface ci = flickr.getCommentsInterface();
        List<Comment> comments = ci.getList(photoId);
        Iterator<Comment> commentsIterator = comments.iterator();

        while (commentsIterator.hasNext()) {
            Comment comment = (Comment) commentsIterator.next();
            if (comment.getId().equals(commentId)) {
                return comment;
            }
        }
        return null;
    }

    @Test
    public void testGetRecentForContacts() throws FlickrException {
        CommentsInterface ci = flickr.getCommentsInterface();
        PhotoList<Photo> photos = ci.getRecentForContacts(null, null, Extras.ALL_EXTRAS, 50, 1);
        assertTrue(photos != null);
    }
}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import java.util.Iterator; import java.util.List; import org.junit.Test; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.photos.Extras; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.comments.Comment; import com.flickr4java.flickr.photos.comments.CommentsInterface; public class CommentsInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetList() throws FlickrException { String photoId = ""245253195""; CommentsInterface ci = flickr.getCommentsInterface(); List<Comment> comments = ci.getList(photoId); assertNotNull(comments); assertTrue(comments.size() > 0); Iterator<Comment> commentsIterator = comments.iterator(); while (commentsIterator.hasNext()) { Comment comment = (Comment) commentsIterator.next(); assertNotNull(comment.getId()); assertNotNull(comment.getAuthor()); assertNotNull(comment.getAuthorName()); assertNotNull(comment.getDateCreate()); assertNotNull(comment.getPermaLink()); assertNotNull(comment.getText()); } } @Test
    public void testComment() throws FlickrException { String photoId = testProperties.getPhotoId(); String txt1 = ""This is a test for the flickr java api""; String txt2 = ""This is an edited comment for the java flickr api""; CommentsInterface ci = flickr.getCommentsInterface(); String commentId = ci.addComment(photoId, txt1); assertNotNull(commentId); assertTrue(commentId.length() > 0); ci.editComment(commentId, txt2); ci.deleteComment(commentId); Comment comment = findCommment(photoId, commentId); assertNull(comment); } private Comment findCommment(String photoId, String commentId) throws FlickrException { CommentsInterface ci = flickr.getCommentsInterface(); List<Comment> comments = ci.getList(photoId); Iterator<Comment> commentsIterator = comments.iterator(); while (commentsIterator.hasNext()) { Comment comment = (Comment) commentsIterator.next(); if (comment.getId().equals(commentId)) { return comment; } } return null; } @Test
    public void testGetRecentForContacts() throws FlickrException { CommentsInterface ci = flickr.getCommentsInterface(); PhotoList<Photo> photos = ci.getRecentForContacts(null, null, Extras.ALL_EXTRAS, 50, 1); assertTrue(photos != null); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import java.util.Iterator; import java.util.List; import org.junit.Test; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.photos.Extras; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.comments.Comment; import com.flickr4java.flickr.photos.comments.CommentsInterface; public class CommentsInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetList() throws FlickrException { String photoId = ""245253195""; CommentsInterface ci = flickr.getCommentsInterface(); List<Comment> comments = ci.getList(photoId); assertNotNull(comments); assertTrue(comments.size() > 0); Iterator<Comment> commentsIterator = comments.iterator(); while (commentsIterator.hasNext()) { Comment comment = (Comment) commentsIterator.next(); assertNotNull(comment.getId()); assertNotNull(comment.getAuthor()); assertNotNull(comment.getAuthorName()); assertNotNull(comment.getDateCreate()); assertNotNull(comment.getPermaLink()); assertNotNull(comment.getText()); } } @Test
    public void testComment() throws FlickrException { String photoId = testProperties.getPhotoId(); String txt1 = ""This is a test for the flickr java api""; String txt2 = ""This is an edited comment for the java flickr api""; CommentsInterface ci = flickr.getCommentsInterface(); String commentId = ci.addComment(photoId, txt1); assertNotNull(commentId); assertTrue(commentId.length() > 0); ci.editComment(commentId, txt2); ci.deleteComment(commentId); Comment comment = findCommment(photoId, commentId); assertNull(comment); } private Comment findCommment(String photoId, String commentId) throws FlickrException { CommentsInterface ci = flickr.getCommentsInterface(); List<Comment> comments = ci.getList(photoId); Iterator<Comment> commentsIterator = comments.iterator(); while (commentsIterator.hasNext()) { Comment comment = (Comment) commentsIterator.next(); if (comment.getId().equals(commentId)) { return comment; } } return null; } @Test
    public void testGetRecentForContacts() throws FlickrException { CommentsInterface ci = flickr.getCommentsInterface(); PhotoList<Photo> photos = ci.getRecentForContacts(null, null, Extras.ALL_EXTRAS, 50, 1); assertTrue(photos != null); } } ","package com.flickr4java.flickr.test;  import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue;  import java.util.Iterator; import java.util.List;  import org.junit.Test;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.photos.Extras; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.comments.Comment; import com.flickr4java.flickr.photos.comments.CommentsInterface;  /**
 * 
 * @author till (Till Krech) flickr:extranoise
 * @version $Id: CommentsInterfaceTest.java,v 1.7 2009/06/30 18:48:59 x-mago Exp $
 */ public class CommentsInterfaceTest extends Flickr4JavaTest {  @Test
    public void testGetList() throws FlickrException { String photoId = ""245253195""; // http://www.flickr.com/photos/extranoise/245253195/ CommentsInterface ci = flickr.getCommentsInterface(); List<Comment> comments = ci.getList(photoId); assertNotNull(comments); assertTrue(comments.size() > 0); Iterator<Comment> commentsIterator = comments.iterator();  while (commentsIterator.hasNext()) { Comment comment = (Comment) commentsIterator.next(); assertNotNull(comment.getId()); assertNotNull(comment.getAuthor()); assertNotNull(comment.getAuthorName()); assertNotNull(comment.getDateCreate()); assertNotNull(comment.getPermaLink()); assertNotNull(comment.getText()); } }  @Test
    public void testComment() throws FlickrException { String photoId = testProperties.getPhotoId(); // http://www.flickr.com/photos/javatest3/419231219/ String txt1 = ""This is a test for the flickr java api""; String txt2 = ""This is an edited comment for the java flickr api""; CommentsInterface ci = flickr.getCommentsInterface(); // add a comment String commentId = ci.addComment(photoId, txt1); // System.out.println(""Comment Id:"" + commentId); assertNotNull(commentId); assertTrue(commentId.length() > 0);  // change the comment text and verify change ci.editComment(commentId, txt2);  // delete the comment ci.deleteComment(commentId); Comment comment = findCommment(photoId, commentId); assertNull(comment); }  // helper function to find a comment by it's id for a specified photo private Comment findCommment(String photoId, String commentId) throws FlickrException { CommentsInterface ci = flickr.getCommentsInterface(); List<Comment> comments = ci.getList(photoId); Iterator<Comment> commentsIterator = comments.iterator();  while (commentsIterator.hasNext()) { Comment comment = (Comment) commentsIterator.next(); if (comment.getId().equals(commentId)) { return comment; } } return null; }  @Test
    public void testGetRecentForContacts() throws FlickrException { CommentsInterface ci = flickr.getCommentsInterface(); PhotoList<Photo> photos = ci.getRecentForContacts(null, null, Extras.ALL_EXTRAS, 50, 1); assertTrue(photos != null); } }  "
src/test/java/com/flickr4java/flickr/test/CommonsInterfaceTest.java,"

package com.flickr4java.flickr.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.commons.CommonsInterface;
import com.flickr4java.flickr.commons.Institution;

import org.junit.Test;

import java.util.List;

/**
 * @author mago
 * @version $Id: CommonsInterfaceTest.java,v 1.1 2009/06/30 18:48:59 x-mago Exp $
 */
public class CommonsInterfaceTest extends Flickr4JavaTest {

    @Test
    public void testGetInstitutions() throws FlickrException {
        CommonsInterface iface = flickr.getCommonsInterface();
        List<Institution> list = iface.getInstitutions();
        assertNotNull(list);
        boolean museumFound = false;
        for (Institution inst : list) {
            if (inst.getName().equals(""The British Library"")) {
                assertEquals(1386975388000L, inst.getDateLaunch().getTime());
                assertEquals(""www.bl.uk"", inst.getSiteUrl());
                assertEquals(""https://www.bl.uk/about-us/terms-and-conditions/content-on-flickr-and-wikimedia-commons"", inst.getLicenseUrl());
                assertEquals(""http://flickr.com/photos/britishlibrary/"", inst.getFlickrUrl());
                museumFound = true;
            }
        }
        assertTrue(museumFound);
    }
}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.commons.CommonsInterface; import com.flickr4java.flickr.commons.Institution; import org.junit.Test; import java.util.List; public class CommonsInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetInstitutions() throws FlickrException { CommonsInterface iface = flickr.getCommonsInterface(); List<Institution> list = iface.getInstitutions(); assertNotNull(list); boolean museumFound = false; for (Institution inst : list) { if (inst.getName().equals(""The British Library"")) { assertEquals(1386975388000L, inst.getDateLaunch().getTime()); assertEquals(""www.bl.uk"", inst.getSiteUrl()); museumFound = true; } } assertTrue(museumFound); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.commons.CommonsInterface; import com.flickr4java.flickr.commons.Institution; import org.junit.Test; import java.util.List; public class CommonsInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetInstitutions() throws FlickrException { CommonsInterface iface = flickr.getCommonsInterface(); List<Institution> list = iface.getInstitutions(); assertNotNull(list); boolean museumFound = false; for (Institution inst : list) { if (inst.getName().equals(""The British Library"")) { assertEquals(1386975388000L, inst.getDateLaunch().getTime()); assertEquals(""www.bl.uk"", inst.getSiteUrl()); museumFound = true; } } assertTrue(museumFound); } } ","
 package com.flickr4java.flickr.test;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.commons.CommonsInterface; import com.flickr4java.flickr.commons.Institution;  import org.junit.Test;  import java.util.List;  /**
 * @author mago
 * @version $Id: CommonsInterfaceTest.java,v 1.1 2009/06/30 18:48:59 x-mago Exp $
 */ public class CommonsInterfaceTest extends Flickr4JavaTest {  @Test
    public void testGetInstitutions() throws FlickrException { CommonsInterface iface = flickr.getCommonsInterface(); List<Institution> list = iface.getInstitutions(); assertNotNull(list); boolean museumFound = false; for (Institution inst : list) { if (inst.getName().equals(""The British Library"")) { assertEquals(1386975388000L, inst.getDateLaunch().getTime()); assertEquals(""www.bl.uk"", inst.getSiteUrl()); //www.bl.uk/about-us/terms-and-conditions/content-on-flickr-and-wikimedia-commons"", inst.getLicenseUrl()); //flickr.com/photos/britishlibrary/"", inst.getFlickrUrl()); museumFound = true; } } assertTrue(museumFound); } }  "
src/test/java/com/flickr4java/flickr/test/CompletenessTest.java,"package com.flickr4java.flickr.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.reflection.ReflectionInterface;
import com.flickr4java.flickr.util.IOUtilities;

import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;

import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.util.Iterator;
import java.util.Properties;

/**
 * Tests the basic completeness of the api.
 * 
 * @author till (Till Krech) flickr:extranoise
 * 
 */
public class CompletenessTest extends Flickr4JavaTest {

    Properties replacements;

    @Override
    @Before
    public void setUp() throws FlickrException {
        super.setUp();
        InputStream in = null;
        try {
            in = getClass().getResourceAsStream(""/completenesstest.properties"");
            replacements = new Properties();
            replacements.load(in);
        } catch (IOException e) {
            fail(e.getMessage());
        } finally {
            IOUtilities.close(in);
        }

    }

    // Test disabled in normal circumstances - just enable when you want to test completeness
    @Ignore
    @Test
    public void testIfComplete() throws FlickrException {
        ReflectionInterface ri = flickr.getReflectionInterface();
        Iterator<String> mit = ri.getMethods().iterator();
        int notFound = 0;
        while (mit.hasNext()) {
            String method = mit.next();
            if (!checkMethod(method)) {
                notFound++;
            }
        }
        assertEquals(0, notFound);
    }

    private boolean checkMethod(String fullMethodName) {
        String repl = getReplacement(fullMethodName);
        String methodName;
        String fqClassName;
        if (repl != null) {
            if (""skip"".equals(repl)) {
                return true;
            }
            fqClassName = repl.substring(0, repl.lastIndexOf('.'));
            methodName = repl.substring(repl.lastIndexOf('.') + 1);
        } else {
            int dotIdx = fullMethodName.lastIndexOf('.');
            String pack = fullMethodName.substring(0, dotIdx);
            methodName = fullMethodName.substring(dotIdx + 1);
            dotIdx = pack.lastIndexOf('.');
            String candidate = pack.substring(dotIdx + 1);
            String javaPack = ""com.flickr4java."" + pack;
            String className = Character.toUpperCase(candidate.charAt(0)) + candidate.substring(1) + ""Interface"";
            fqClassName = javaPack + ""."" + className;
        }
        boolean found = false;
        try {
            Class<?> cl = Class.forName(fqClassName);
            Method[] javaMethods = cl.getMethods();
            for (Method javaMethod : javaMethods) {
                if (javaMethod.getName().equals(methodName)) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                System.out.println(""ATTENTION: Method not implemented in Flickr4Java: "" + fqClassName + ""."" + methodName);
            }
        } catch (ClassNotFoundException e) {
            System.out.println(""ATTENTION:  Class not implemented in Flickr4Java: ["" + fqClassName + ""] (Method: "" + methodName + "")"");
        }
        return found;
    }

    private String getReplacement(String fullMethodName) {
        String repl = replacements.getProperty(fullMethodName);
        if (repl == null) {
            String meth = fullMethodName.substring(fullMethodName.lastIndexOf('.') + 1);
            @SuppressWarnings(""rawtypes"")
            Iterator keys = replacements.keySet().iterator();
            while (keys.hasNext()) {
                String key = (String) keys.next();
                if (key.endsWith("".*"")) {
                    String keyPack = key.substring(0, key.length() - 2);
                    String methPack = fullMethodName.substring(0, fullMethodName.lastIndexOf('.'));
                    if (keyPack.equals(methPack)) {
                        String cls = replacements.getProperty(key);
                        if (cls.endsWith("".*"")) {
                            cls = cls.substring(0, cls.length() - 2);
                        }
                        repl = cls + ""."" + meth;
                        break;
                    }
                }
            }
        }
        return repl;
    }
}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.fail; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.reflection.ReflectionInterface; import com.flickr4java.flickr.util.IOUtilities; import org.junit.Before; import org.junit.Ignore; import org.junit.Test; import java.io.IOException; import java.io.InputStream; import java.lang.reflect.Method; import java.util.Iterator; import java.util.Properties; public class CompletenessTest extends Flickr4JavaTest { Properties replacements; @Override
    @Before
    public void setUp() throws FlickrException { super.setUp(); InputStream in = null; try { in = getClass().getResourceAsStream(""/completenesstest.properties""); replacements = new Properties(); replacements.load(in); } catch (IOException e) { fail(e.getMessage()); } finally { IOUtilities.close(in); } } @Ignore
    @Test
    public void testIfComplete() throws FlickrException { ReflectionInterface ri = flickr.getReflectionInterface(); Iterator<String> mit = ri.getMethods().iterator(); int notFound = 0; while (mit.hasNext()) { String method = mit.next(); if (!checkMethod(method)) { notFound++; } } assertEquals(0, notFound); } private boolean checkMethod(String fullMethodName) { String repl = getReplacement(fullMethodName); String methodName; String fqClassName; if (repl != null) { if (""skip"".equals(repl)) { return true; } fqClassName = repl.substring(0, repl.lastIndexOf('.')); methodName = repl.substring(repl.lastIndexOf('.') + 1); } else { int dotIdx = fullMethodName.lastIndexOf('.'); String pack = fullMethodName.substring(0, dotIdx); methodName = fullMethodName.substring(dotIdx + 1); dotIdx = pack.lastIndexOf('.'); String candidate = pack.substring(dotIdx + 1); String javaPack = ""com.flickr4java."" + pack; String className = Character.toUpperCase(candidate.charAt(0)) + candidate.substring(1) + ""Interface""; fqClassName = javaPack + ""."" + className; } boolean found = false; try { Class<?> cl = Class.forName(fqClassName); Method[] javaMethods = cl.getMethods(); for (Method javaMethod : javaMethods) { if (javaMethod.getName().equals(methodName)) { found = true; break; } } if (!found) { System.out.println(""ATTENTION: Method not implemented in Flickr4Java: "" + fqClassName + ""."" + methodName); } } catch (ClassNotFoundException e) { System.out.println(""ATTENTION:  Class not implemented in Flickr4Java: ["" + fqClassName + ""] (Method: "" + methodName + "")""); } return found; } private String getReplacement(String fullMethodName) { String repl = replacements.getProperty(fullMethodName); if (repl == null) { String meth = fullMethodName.substring(fullMethodName.lastIndexOf('.') + 1); @SuppressWarnings(""rawtypes"")
            Iterator keys = replacements.keySet().iterator(); while (keys.hasNext()) { String key = (String) keys.next(); if (key.endsWith("".*"")) { String keyPack = key.substring(0, key.length() - 2); String methPack = fullMethodName.substring(0, fullMethodName.lastIndexOf('.')); if (keyPack.equals(methPack)) { String cls = replacements.getProperty(key); if (cls.endsWith("".*"")) { cls = cls.substring(0, cls.length() - 2); } repl = cls + ""."" + meth; break; } } } } return repl; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.fail; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.reflection.ReflectionInterface; import com.flickr4java.flickr.util.IOUtilities; import org.junit.Before; import org.junit.Ignore; import org.junit.Test; import java.io.IOException; import java.io.InputStream; import java.lang.reflect.Method; import java.util.Iterator; import java.util.Properties; public class CompletenessTest extends Flickr4JavaTest { Properties replacements; @Override
    @Before
    public void setUp() throws FlickrException { super.setUp(); InputStream in = null; try { in = getClass().getResourceAsStream(""/completenesstest.properties""); replacements = new Properties(); replacements.load(in); } catch (IOException e) { fail(e.getMessage()); } finally { IOUtilities.close(in); } } @Ignore
    @Test
    public void testIfComplete() throws FlickrException { ReflectionInterface ri = flickr.getReflectionInterface(); Iterator<String> mit = ri.getMethods().iterator(); int notFound = 0; while (mit.hasNext()) { String method = mit.next(); if (!checkMethod(method)) { notFound++; } } assertEquals(0, notFound); } private boolean checkMethod(String fullMethodName) { String repl = getReplacement(fullMethodName); String methodName; String fqClassName; if (repl != null) { if (""skip"".equals(repl)) { return true; } fqClassName = repl.substring(0, repl.lastIndexOf('.')); methodName = repl.substring(repl.lastIndexOf('.') + 1); } else { int dotIdx = fullMethodName.lastIndexOf('.'); String pack = fullMethodName.substring(0, dotIdx); methodName = fullMethodName.substring(dotIdx + 1); dotIdx = pack.lastIndexOf('.'); String candidate = pack.substring(dotIdx + 1); String javaPack = ""com.flickr4java."" + pack; String className = Character.toUpperCase(candidate.charAt(0)) + candidate.substring(1) + ""Interface""; fqClassName = javaPack + ""."" + className; } boolean found = false; try { Class<?> cl = Class.forName(fqClassName); Method[] javaMethods = cl.getMethods(); for (Method javaMethod : javaMethods) { if (javaMethod.getName().equals(methodName)) { found = true; break; } } if (!found) { System.out.println(""ATTENTION: Method not implemented in Flickr4Java: "" + fqClassName + ""."" + methodName); } } catch (ClassNotFoundException e) { System.out.println(""ATTENTION:  Class not implemented in Flickr4Java: ["" + fqClassName + ""] (Method: "" + methodName + "")""); } return found; } private String getReplacement(String fullMethodName) { String repl = replacements.getProperty(fullMethodName); if (repl == null) { String meth = fullMethodName.substring(fullMethodName.lastIndexOf('.') + 1); @SuppressWarnings(""rawtypes"")
            Iterator keys = replacements.keySet().iterator(); while (keys.hasNext()) { String key = (String) keys.next(); if (key.endsWith("".*"")) { String keyPack = key.substring(0, key.length() - 2); String methPack = fullMethodName.substring(0, fullMethodName.lastIndexOf('.')); if (keyPack.equals(methPack)) { String cls = replacements.getProperty(key); if (cls.endsWith("".*"")) { cls = cls.substring(0, cls.length() - 2); } repl = cls + ""."" + meth; break; } } } } return repl; } } ","package com.flickr4java.flickr.test;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.fail;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.reflection.ReflectionInterface; import com.flickr4java.flickr.util.IOUtilities;  import org.junit.Before; import org.junit.Ignore; import org.junit.Test;  import java.io.IOException; import java.io.InputStream; import java.lang.reflect.Method; import java.util.Iterator; import java.util.Properties;  /**
 * Tests the basic completeness of the api.
 * 
 * @author till (Till Krech) flickr:extranoise
 * 
 */ public class CompletenessTest extends Flickr4JavaTest {  Properties replacements;  @Override
    @Before
    public void setUp() throws FlickrException { super.setUp(); InputStream in = null; try { in = getClass().getResourceAsStream(""/completenesstest.properties""); replacements = new Properties(); replacements.load(in); } catch (IOException e) { fail(e.getMessage()); } finally { IOUtilities.close(in); }  }  // Test disabled in normal circumstances - just enable when you want to test completeness @Ignore
    @Test
    public void testIfComplete() throws FlickrException { ReflectionInterface ri = flickr.getReflectionInterface(); Iterator<String> mit = ri.getMethods().iterator(); int notFound = 0; while (mit.hasNext()) { String method = mit.next(); if (!checkMethod(method)) { notFound++; } } assertEquals(0, notFound); }  private boolean checkMethod(String fullMethodName) { String repl = getReplacement(fullMethodName); String methodName; String fqClassName; if (repl != null) { if (""skip"".equals(repl)) { return true; } fqClassName = repl.substring(0, repl.lastIndexOf('.')); methodName = repl.substring(repl.lastIndexOf('.') + 1); } else { int dotIdx = fullMethodName.lastIndexOf('.'); String pack = fullMethodName.substring(0, dotIdx); methodName = fullMethodName.substring(dotIdx + 1); dotIdx = pack.lastIndexOf('.'); String candidate = pack.substring(dotIdx + 1); String javaPack = ""com.flickr4java."" + pack; String className = Character.toUpperCase(candidate.charAt(0)) + candidate.substring(1) + ""Interface""; fqClassName = javaPack + ""."" + className; } boolean found = false; try { Class<?> cl = Class.forName(fqClassName); Method[] javaMethods = cl.getMethods(); for (Method javaMethod : javaMethods) { if (javaMethod.getName().equals(methodName)) { found = true; break; } } if (!found) { System.out.println(""ATTENTION: Method not implemented in Flickr4Java: "" + fqClassName + ""."" + methodName); } } catch (ClassNotFoundException e) { System.out.println(""ATTENTION:  Class not implemented in Flickr4Java: ["" + fqClassName + ""] (Method: "" + methodName + "")""); } return found; }  private String getReplacement(String fullMethodName) { String repl = replacements.getProperty(fullMethodName); if (repl == null) { String meth = fullMethodName.substring(fullMethodName.lastIndexOf('.') + 1); @SuppressWarnings(""rawtypes"")
            Iterator keys = replacements.keySet().iterator(); while (keys.hasNext()) { String key = (String) keys.next(); if (key.endsWith("".*"")) { String keyPack = key.substring(0, key.length() - 2); String methPack = fullMethodName.substring(0, fullMethodName.lastIndexOf('.')); if (keyPack.equals(methPack)) { String cls = replacements.getProperty(key); if (cls.endsWith("".*"")) { cls = cls.substring(0, cls.length() - 2); } repl = cls + ""."" + meth; break; } } } } return repl; } }  "
src/test/java/com/flickr4java/flickr/test/ContactsInterfaceTest.java,"

package com.flickr4java.flickr.test;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.util.Collection;
import java.util.Iterator;

import org.junit.Test;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.contacts.Contact;
import com.flickr4java.flickr.contacts.ContactsInterface;

/**
 * @author Anthony Eden
 * @version $Id: ContactsInterfaceTest.java,v 1.9 2009/01/01 20:25:57 x-mago Exp $
 */
public class ContactsInterfaceTest extends Flickr4JavaTest {

    @Test
    public void testGetList() throws FlickrException {
        ContactsInterface iface = flickr.getContactsInterface();
        Collection<Contact> contacts = iface.getList();
        assertNotNull(contacts);
        assertTrue(""No Contacts. (You need to have contacts for this test to succceed)"", contacts.size() > 0);
        Iterator<Contact> it = contacts.iterator();
        for (int i = 0; it.hasNext() && i < 10; i++) {
            Contact contact = (Contact) it.next();
            assertNotNull(contact.getUsername());
            assertNotNull(contact.getRealName());
            assertNotNull(contact.getId());
            assertTrue(contact.getIconFarm() > 0);
            assertTrue(contact.getIconServer() > 0);
        }
    }

    @Test
    public void testGetPublicList() throws FlickrException {
        ContactsInterface iface = flickr.getContactsInterface();
        Collection<Contact> contacts = iface.getPublicList(testProperties.getNsid());
        assertNotNull(contacts);
        assertTrue(""No Contacts. (You need to have contacts for this test to succceed)"", contacts.size() > 0);
        Iterator<Contact> it = contacts.iterator();
        for (int i = 0; it.hasNext() && i < 10; i++) {
            Contact contact = (Contact) it.next();
            assertNotNull(contact.getUsername());
            assertNotNull(contact.getId());
            assertTrue(contact.getIconFarm() > 0);
            assertTrue(contact.getIconServer() > 0);
        }
    }

}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import java.util.Collection; import java.util.Iterator; import org.junit.Test; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.contacts.Contact; import com.flickr4java.flickr.contacts.ContactsInterface; public class ContactsInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetList() throws FlickrException { ContactsInterface iface = flickr.getContactsInterface(); Collection<Contact> contacts = iface.getList(); assertNotNull(contacts); assertTrue(""No Contacts. (You need to have contacts for this test to succceed)"", contacts.size() > 0); Iterator<Contact> it = contacts.iterator(); for (int i = 0; it.hasNext() && i < 10; i++) { Contact contact = (Contact) it.next(); assertNotNull(contact.getUsername()); assertNotNull(contact.getRealName()); assertNotNull(contact.getId()); assertTrue(contact.getIconFarm() > 0); assertTrue(contact.getIconServer() > 0); } } @Test
    public void testGetPublicList() throws FlickrException { ContactsInterface iface = flickr.getContactsInterface(); Collection<Contact> contacts = iface.getPublicList(testProperties.getNsid()); assertNotNull(contacts); assertTrue(""No Contacts. (You need to have contacts for this test to succceed)"", contacts.size() > 0); Iterator<Contact> it = contacts.iterator(); for (int i = 0; it.hasNext() && i < 10; i++) { Contact contact = (Contact) it.next(); assertNotNull(contact.getUsername()); assertNotNull(contact.getId()); assertTrue(contact.getIconFarm() > 0); assertTrue(contact.getIconServer() > 0); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import java.util.Collection; import java.util.Iterator; import org.junit.Test; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.contacts.Contact; import com.flickr4java.flickr.contacts.ContactsInterface; public class ContactsInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetList() throws FlickrException { ContactsInterface iface = flickr.getContactsInterface(); Collection<Contact> contacts = iface.getList(); assertNotNull(contacts); assertTrue(""No Contacts. (You need to have contacts for this test to succceed)"", contacts.size() > 0); Iterator<Contact> it = contacts.iterator(); for (int i = 0; it.hasNext() && i < 10; i++) { Contact contact = (Contact) it.next(); assertNotNull(contact.getUsername()); assertNotNull(contact.getRealName()); assertNotNull(contact.getId()); assertTrue(contact.getIconFarm() > 0); assertTrue(contact.getIconServer() > 0); } } @Test
    public void testGetPublicList() throws FlickrException { ContactsInterface iface = flickr.getContactsInterface(); Collection<Contact> contacts = iface.getPublicList(testProperties.getNsid()); assertNotNull(contacts); assertTrue(""No Contacts. (You need to have contacts for this test to succceed)"", contacts.size() > 0); Iterator<Contact> it = contacts.iterator(); for (int i = 0; it.hasNext() && i < 10; i++) { Contact contact = (Contact) it.next(); assertNotNull(contact.getUsername()); assertNotNull(contact.getId()); assertTrue(contact.getIconFarm() > 0); assertTrue(contact.getIconServer() > 0); } } } ","
 package com.flickr4java.flickr.test;  import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue;  import java.util.Collection; import java.util.Iterator;  import org.junit.Test;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.contacts.Contact; import com.flickr4java.flickr.contacts.ContactsInterface;  /**
 * @author Anthony Eden
 * @version $Id: ContactsInterfaceTest.java,v 1.9 2009/01/01 20:25:57 x-mago Exp $
 */ public class ContactsInterfaceTest extends Flickr4JavaTest {  @Test
    public void testGetList() throws FlickrException { ContactsInterface iface = flickr.getContactsInterface(); Collection<Contact> contacts = iface.getList(); assertNotNull(contacts); assertTrue(""No Contacts. (You need to have contacts for this test to succceed)"", contacts.size() > 0); Iterator<Contact> it = contacts.iterator(); for (int i = 0; it.hasNext() && i < 10; i++) { Contact contact = (Contact) it.next(); assertNotNull(contact.getUsername()); assertNotNull(contact.getRealName()); assertNotNull(contact.getId()); assertTrue(contact.getIconFarm() > 0); assertTrue(contact.getIconServer() > 0); } }  @Test
    public void testGetPublicList() throws FlickrException { ContactsInterface iface = flickr.getContactsInterface(); Collection<Contact> contacts = iface.getPublicList(testProperties.getNsid()); assertNotNull(contacts); assertTrue(""No Contacts. (You need to have contacts for this test to succceed)"", contacts.size() > 0); Iterator<Contact> it = contacts.iterator(); for (int i = 0; it.hasNext() && i < 10; i++) { Contact contact = (Contact) it.next(); assertNotNull(contact.getUsername()); assertNotNull(contact.getId()); assertTrue(contact.getIconFarm() > 0); assertTrue(contact.getIconServer() > 0); } }  }  "
src/test/java/com/flickr4java/flickr/test/FavoritesInterfaceTest.java,"

package com.flickr4java.flickr.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.favorites.FavoritesInterface;
import com.flickr4java.flickr.photos.Extras;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoContext;

import org.junit.Test;

import java.util.Collection;

/**
 * @author Anthony Eden
 * @version $Id: FavoritesInterfaceTest.java,v 1.8 2008/01/26 00:05:17 x-mago Exp $
 */
public class FavoritesInterfaceTest extends Flickr4JavaTest {

    @Test
    public void testGetList() throws FlickrException {
        FavoritesInterface iface = flickr.getFavoritesInterface();
        Collection<Photo> favorites = iface.getList(null, 15, 1, null);
        assertNotNull(favorites);
        assertFalse(favorites.isEmpty());
    }

    @Test
    public void testGetListWithExtras() throws FlickrException {
        FavoritesInterface iface = flickr.getFavoritesInterface();
        Collection<Photo> favorites = iface.getList(null, 15, 1, Extras.ALL_EXTRAS);
        assertNotNull(favorites);
        assertFalse(favorites.isEmpty());
    }

    @Test
    public void testGetPublicList() throws FlickrException {
        FavoritesInterface iface = flickr.getFavoritesInterface();
        Collection<Photo> favorites = iface.getPublicList(testProperties.getNsid(), 0, 0, null);
        assertNotNull(favorites);
        assertTrue(favorites.size() > 0);
    }

    @Test
    public void testAddAndRemove() throws FlickrException {
        String photoId = ""51144759448""; // Photo that doesn't belong to the test user's account
        FavoritesInterface iface = flickr.getFavoritesInterface();

        try {
            iface.remove(photoId);
        } catch (Exception e) {
            // running the remove in case it's there before the add
        }
        iface.add(photoId);  // No response to check

        iface.remove(photoId);
    }

    @Test
    public void testGetContext() throws FlickrException {
        FavoritesInterface iface = flickr.getFavoritesInterface();
        PhotoContext context = iface.getContext(""5844052737"", ""77348956@N00"");
        assertNotNull(context);
        assertEquals(""5602817067"", context.getPreviousPhoto().getId());
        assertEquals(""5844052415"", context.getNextPhoto().getId());
    }

}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.favorites.FavoritesInterface; import com.flickr4java.flickr.photos.Extras; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoContext; import org.junit.Test; import java.util.Collection; public class FavoritesInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetList() throws FlickrException { FavoritesInterface iface = flickr.getFavoritesInterface(); Collection<Photo> favorites = iface.getList(null, 15, 1, null); assertNotNull(favorites); assertFalse(favorites.isEmpty()); } @Test
    public void testGetListWithExtras() throws FlickrException { FavoritesInterface iface = flickr.getFavoritesInterface(); Collection<Photo> favorites = iface.getList(null, 15, 1, Extras.ALL_EXTRAS); assertNotNull(favorites); assertFalse(favorites.isEmpty()); } @Test
    public void testGetPublicList() throws FlickrException { FavoritesInterface iface = flickr.getFavoritesInterface(); Collection<Photo> favorites = iface.getPublicList(testProperties.getNsid(), 0, 0, null); assertNotNull(favorites); assertTrue(favorites.size() > 0); } @Test
    public void testAddAndRemove() throws FlickrException { String photoId = ""51144759448""; FavoritesInterface iface = flickr.getFavoritesInterface(); try { iface.remove(photoId); } catch (Exception e) { } iface.add(photoId); iface.remove(photoId); } @Test
    public void testGetContext() throws FlickrException { FavoritesInterface iface = flickr.getFavoritesInterface(); PhotoContext context = iface.getContext(""5844052737"", ""77348956@N00""); assertNotNull(context); assertEquals(""5602817067"", context.getPreviousPhoto().getId()); assertEquals(""5844052415"", context.getNextPhoto().getId()); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.favorites.FavoritesInterface; import com.flickr4java.flickr.photos.Extras; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoContext; import org.junit.Test; import java.util.Collection; public class FavoritesInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetList() throws FlickrException { FavoritesInterface iface = flickr.getFavoritesInterface(); Collection<Photo> favorites = iface.getList(null, 15, 1, null); assertNotNull(favorites); assertFalse(favorites.isEmpty()); } @Test
    public void testGetListWithExtras() throws FlickrException { FavoritesInterface iface = flickr.getFavoritesInterface(); Collection<Photo> favorites = iface.getList(null, 15, 1, Extras.ALL_EXTRAS); assertNotNull(favorites); assertFalse(favorites.isEmpty()); } @Test
    public void testGetPublicList() throws FlickrException { FavoritesInterface iface = flickr.getFavoritesInterface(); Collection<Photo> favorites = iface.getPublicList(testProperties.getNsid(), 0, 0, null); assertNotNull(favorites); assertTrue(favorites.size() > 0); } @Test
    public void testAddAndRemove() throws FlickrException { String photoId = ""51144759448""; FavoritesInterface iface = flickr.getFavoritesInterface(); try { iface.remove(photoId); } catch (Exception e) { } iface.add(photoId); iface.remove(photoId); } @Test
    public void testGetContext() throws FlickrException { FavoritesInterface iface = flickr.getFavoritesInterface(); PhotoContext context = iface.getContext(""5844052737"", ""77348956@N00""); assertNotNull(context); assertEquals(""5602817067"", context.getPreviousPhoto().getId()); assertEquals(""5844052415"", context.getNextPhoto().getId()); } } ","
 package com.flickr4java.flickr.test;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.favorites.FavoritesInterface; import com.flickr4java.flickr.photos.Extras; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoContext;  import org.junit.Test;  import java.util.Collection;  /**
 * @author Anthony Eden
 * @version $Id: FavoritesInterfaceTest.java,v 1.8 2008/01/26 00:05:17 x-mago Exp $
 */ public class FavoritesInterfaceTest extends Flickr4JavaTest {  @Test
    public void testGetList() throws FlickrException { FavoritesInterface iface = flickr.getFavoritesInterface(); Collection<Photo> favorites = iface.getList(null, 15, 1, null); assertNotNull(favorites); assertFalse(favorites.isEmpty()); }  @Test
    public void testGetListWithExtras() throws FlickrException { FavoritesInterface iface = flickr.getFavoritesInterface(); Collection<Photo> favorites = iface.getList(null, 15, 1, Extras.ALL_EXTRAS); assertNotNull(favorites); assertFalse(favorites.isEmpty()); }  @Test
    public void testGetPublicList() throws FlickrException { FavoritesInterface iface = flickr.getFavoritesInterface(); Collection<Photo> favorites = iface.getPublicList(testProperties.getNsid(), 0, 0, null); assertNotNull(favorites); assertTrue(favorites.size() > 0); }  @Test
    public void testAddAndRemove() throws FlickrException { String photoId = ""51144759448""; // Photo that doesn't belong to the test user's account FavoritesInterface iface = flickr.getFavoritesInterface();  try { iface.remove(photoId); } catch (Exception e) { // running the remove in case it's there before the add } iface.add(photoId); // No response to check  iface.remove(photoId); }  @Test
    public void testGetContext() throws FlickrException { FavoritesInterface iface = flickr.getFavoritesInterface(); PhotoContext context = iface.getContext(""5844052737"", ""77348956@N00""); assertNotNull(context); assertEquals(""5602817067"", context.getPreviousPhoto().getId()); assertEquals(""5844052415"", context.getNextPhoto().getId()); }  }  "
src/test/java/com/flickr4java/flickr/test/Flickr4JavaTest.java,"/**
 * @author acaplan
 */
package com.flickr4java.flickr.test;

import com.flickr4java.flickr.Flickr;
import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.IFlickr;
import com.flickr4java.flickr.REST;
import com.flickr4java.flickr.RequestContext;
import com.flickr4java.flickr.auth.Auth;
import com.flickr4java.flickr.auth.Permission;
import com.flickr4java.flickr.test.util.FlickrStub;
import com.flickr4java.flickr.test.util.TestProperties;
import com.flickr4java.flickr.test.util.TestPropertiesFactory;
import org.junit.Before;

/**
 * @author acaplan
 * 
 */
public class Flickr4JavaTest {

    protected IFlickr flickr;

    protected TestProperties testProperties;

    /**
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    @Before
    public void setUp() throws FlickrException {
        testProperties = TestPropertiesFactory.getTestProperties();

        if (testProperties.isRealFlickr()) {
            REST rest = new REST();
            rest.setHost(testProperties.getHost());

            flickr = new Flickr(testProperties.getApiKey(), testProperties.getSecret(), rest);

            setAuth(Permission.READ);
        } else {
            flickr = new FlickrStub();
        }
    }

    /**
     * Set auth parameters for API calls that need it.
     * 
     * @param perms
     */
    protected void setAuth(Permission perms) {
        Auth auth = new Auth();
        auth.setPermission(perms);
        auth.setToken(testProperties.getToken());
        auth.setTokenSecret(testProperties.getTokenSecret());

        RequestContext requestContext = RequestContext.getRequestContext();
        requestContext.setAuth(auth);
        flickr.setAuth(auth);
    }

    /**
     * Certain tests don't require authorization and calling with auth set may mask other errors.
     */
    protected void clearAuth() {
        RequestContext requestContext = RequestContext.getRequestContext();
        requestContext.setAuth(null);
    }

}
","package com.flickr4java.flickr.test; import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.IFlickr; import com.flickr4java.flickr.REST; import com.flickr4java.flickr.RequestContext; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.auth.Permission; import com.flickr4java.flickr.test.util.FlickrStub; import com.flickr4java.flickr.test.util.TestProperties; import com.flickr4java.flickr.test.util.TestPropertiesFactory; import org.junit.Before; public class Flickr4JavaTest { protected IFlickr flickr; protected TestProperties testProperties; @Before
    public void setUp() throws FlickrException { testProperties = TestPropertiesFactory.getTestProperties(); if (testProperties.isRealFlickr()) { REST rest = new REST(); rest.setHost(testProperties.getHost()); flickr = new Flickr(testProperties.getApiKey(), testProperties.getSecret(), rest); setAuth(Permission.READ); } else { flickr = new FlickrStub(); } } protected void setAuth(Permission perms) { Auth auth = new Auth(); auth.setPermission(perms); auth.setToken(testProperties.getToken()); auth.setTokenSecret(testProperties.getTokenSecret()); RequestContext requestContext = RequestContext.getRequestContext(); requestContext.setAuth(auth); flickr.setAuth(auth); } protected void clearAuth() { RequestContext requestContext = RequestContext.getRequestContext(); requestContext.setAuth(null); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.IFlickr; import com.flickr4java.flickr.REST; import com.flickr4java.flickr.RequestContext; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.auth.Permission; import com.flickr4java.flickr.test.util.FlickrStub; import com.flickr4java.flickr.test.util.TestProperties; import com.flickr4java.flickr.test.util.TestPropertiesFactory; import org.junit.Before; public class Flickr4JavaTest { protected IFlickr flickr; protected TestProperties testProperties; @Before
    public void setUp() throws FlickrException { testProperties = TestPropertiesFactory.getTestProperties(); if (testProperties.isRealFlickr()) { REST rest = new REST(); rest.setHost(testProperties.getHost()); flickr = new Flickr(testProperties.getApiKey(), testProperties.getSecret(), rest); setAuth(Permission.READ); } else { flickr = new FlickrStub(); } } protected void setAuth(Permission perms) { Auth auth = new Auth(); auth.setPermission(perms); auth.setToken(testProperties.getToken()); auth.setTokenSecret(testProperties.getTokenSecret()); RequestContext requestContext = RequestContext.getRequestContext(); requestContext.setAuth(auth); flickr.setAuth(auth); } protected void clearAuth() { RequestContext requestContext = RequestContext.getRequestContext(); requestContext.setAuth(null); } } ","/**
 * @author acaplan
 */ package com.flickr4java.flickr.test;  import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.IFlickr; import com.flickr4java.flickr.REST; import com.flickr4java.flickr.RequestContext; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.auth.Permission; import com.flickr4java.flickr.test.util.FlickrStub; import com.flickr4java.flickr.test.util.TestProperties; import com.flickr4java.flickr.test.util.TestPropertiesFactory; import org.junit.Before;  /**
 * @author acaplan
 * 
 */ public class Flickr4JavaTest {  protected IFlickr flickr;  protected TestProperties testProperties;  /**
     * @throws FlickrException if there was a problem connecting to Flickr
     */ @Before
    public void setUp() throws FlickrException { testProperties = TestPropertiesFactory.getTestProperties();  if (testProperties.isRealFlickr()) { REST rest = new REST(); rest.setHost(testProperties.getHost());  flickr = new Flickr(testProperties.getApiKey(), testProperties.getSecret(), rest);  setAuth(Permission.READ); } else { flickr = new FlickrStub(); } }  /**
     * Set auth parameters for API calls that need it.
     * 
     * @param perms
     */ protected void setAuth(Permission perms) { Auth auth = new Auth(); auth.setPermission(perms); auth.setToken(testProperties.getToken()); auth.setTokenSecret(testProperties.getTokenSecret());  RequestContext requestContext = RequestContext.getRequestContext(); requestContext.setAuth(auth); flickr.setAuth(auth); }  /**
     * Certain tests don't require authorization and calling with auth set may mask other errors.
     */ protected void clearAuth() { RequestContext requestContext = RequestContext.getRequestContext(); requestContext.setAuth(null); }  }  "
src/test/java/com/flickr4java/flickr/test/GalleriesInterfaceTest.java,"/**
 * @author acaplan
 */
package com.flickr4java.flickr.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.galleries.GalleriesInterface;
import com.flickr4java.flickr.galleries.Gallery;

import org.junit.After;
import org.junit.Ignore;
import org.junit.Test;

import java.util.List;

/**
 * @author acaplan
 * 
 */
public class GalleriesInterfaceTest extends Flickr4JavaTest {

    @After
    public void tearDown() {
        flickr = null;
    }

    @Test
    public void testGetList() throws FlickrException {
        GalleriesInterface iface = flickr.getGalleriesInterface();
        List<Gallery> galleries = iface.getList(testProperties.getNsid(), 10, 1);
        assertNotNull(galleries);
        assertFalse(galleries.isEmpty());
    }

    @Ignore
    @Test
    public void testCreate() throws FlickrException {
        GalleriesInterface iface = flickr.getGalleriesInterface();
        Gallery gallery = iface.create(""test_gallery"", ""test gallery"", ""2732893596"");
        assertNotNull(gallery);
        assertNotNull(gallery.getId());
        assertEquals(""test_gallery"", gallery.getTitle());
        assertEquals(""test gallery"", gallery.getDesc());
    }

    @Test
    public void testGetInfo() throws FlickrException {
        GalleriesInterface iface = flickr.getGalleriesInterface();
        Gallery gallery = iface.getInfo(""1979953-72157629277637049"");
        assertNotNull(gallery);
        assertEquals(""Motorcycle Pics"", gallery.getTitle());
    }
}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.galleries.GalleriesInterface; import com.flickr4java.flickr.galleries.Gallery; import org.junit.After; import org.junit.Ignore; import org.junit.Test; import java.util.List; public class GalleriesInterfaceTest extends Flickr4JavaTest { @After
    public void tearDown() { flickr = null; } @Test
    public void testGetList() throws FlickrException { GalleriesInterface iface = flickr.getGalleriesInterface(); List<Gallery> galleries = iface.getList(testProperties.getNsid(), 10, 1); assertNotNull(galleries); assertFalse(galleries.isEmpty()); } @Ignore
    @Test
    public void testCreate() throws FlickrException { GalleriesInterface iface = flickr.getGalleriesInterface(); Gallery gallery = iface.create(""test_gallery"", ""test gallery"", ""2732893596""); assertNotNull(gallery); assertNotNull(gallery.getId()); assertEquals(""test_gallery"", gallery.getTitle()); assertEquals(""test gallery"", gallery.getDesc()); } @Test
    public void testGetInfo() throws FlickrException { GalleriesInterface iface = flickr.getGalleriesInterface(); Gallery gallery = iface.getInfo(""1979953-72157629277637049""); assertNotNull(gallery); assertEquals(""Motorcycle Pics"", gallery.getTitle()); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.galleries.GalleriesInterface; import com.flickr4java.flickr.galleries.Gallery; import org.junit.After; import org.junit.Ignore; import org.junit.Test; import java.util.List; public class GalleriesInterfaceTest extends Flickr4JavaTest { @After
    public void tearDown() { flickr = null; } @Test
    public void testGetList() throws FlickrException { GalleriesInterface iface = flickr.getGalleriesInterface(); List<Gallery> galleries = iface.getList(testProperties.getNsid(), 10, 1); assertNotNull(galleries); assertFalse(galleries.isEmpty()); } @Ignore
    @Test
    public void testCreate() throws FlickrException { GalleriesInterface iface = flickr.getGalleriesInterface(); Gallery gallery = iface.create(""test_gallery"", ""test gallery"", ""2732893596""); assertNotNull(gallery); assertNotNull(gallery.getId()); assertEquals(""test_gallery"", gallery.getTitle()); assertEquals(""test gallery"", gallery.getDesc()); } @Test
    public void testGetInfo() throws FlickrException { GalleriesInterface iface = flickr.getGalleriesInterface(); Gallery gallery = iface.getInfo(""1979953-72157629277637049""); assertNotNull(gallery); assertEquals(""Motorcycle Pics"", gallery.getTitle()); } } ","/**
 * @author acaplan
 */ package com.flickr4java.flickr.test;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.galleries.GalleriesInterface; import com.flickr4java.flickr.galleries.Gallery;  import org.junit.After; import org.junit.Ignore; import org.junit.Test;  import java.util.List;  /**
 * @author acaplan
 * 
 */ public class GalleriesInterfaceTest extends Flickr4JavaTest {  @After
    public void tearDown() { flickr = null; }  @Test
    public void testGetList() throws FlickrException { GalleriesInterface iface = flickr.getGalleriesInterface(); List<Gallery> galleries = iface.getList(testProperties.getNsid(), 10, 1); assertNotNull(galleries); assertFalse(galleries.isEmpty()); }  @Ignore
    @Test
    public void testCreate() throws FlickrException { GalleriesInterface iface = flickr.getGalleriesInterface(); Gallery gallery = iface.create(""test_gallery"", ""test gallery"", ""2732893596""); assertNotNull(gallery); assertNotNull(gallery.getId()); assertEquals(""test_gallery"", gallery.getTitle()); assertEquals(""test gallery"", gallery.getDesc()); }  @Test
    public void testGetInfo() throws FlickrException { GalleriesInterface iface = flickr.getGalleriesInterface(); Gallery gallery = iface.getInfo(""1979953-72157629277637049""); assertNotNull(gallery); assertEquals(""Motorcycle Pics"", gallery.getTitle()); } }  "
src/test/java/com/flickr4java/flickr/test/GeoInterfaceTest.java,"package com.flickr4java.flickr.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import org.junit.Before;
import org.junit.Test;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.photos.GeoData;
import com.flickr4java.flickr.photos.geo.GeoInterface;
import com.flickr4java.flickr.photos.geo.GeoPermissions;

/**
 * 
 * @author till
 * @version $Id: GeoInterfaceTest.java,v 1.4 2008/01/28 23:01:45 x-mago Exp $
 */
public class GeoInterfaceTest extends Flickr4JavaTest {

    @Before
    public void setUp() throws FlickrException {
        super.setUp();
        setGeoParameters(testProperties.getGeoWritePhotoId());
    }

    @Test
    public void testGetLocation() throws FlickrException {
        String photoId = testProperties.getGeoWritePhotoId();
        GeoInterface geo = flickr.getPhotosInterface().getGeoInterface();
        GeoData location = geo.getLocation(photoId);
        assertNotNull(location);
        assertTrue(location.getLatitude() > 0);
        assertTrue(location.getLongitude() > 0);
        assertTrue(location.getAccuracy() >= 1);
        assertTrue(location.getAccuracy() <= 16);
    }

    @Test
    public void testGetPerms() throws FlickrException {
        String photoId = testProperties.getGeoWritePhotoId();
        GeoInterface geo = flickr.getPhotosInterface().getGeoInterface();
        GeoPermissions perms = geo.getPerms(photoId);
        assertNotNull(perms);
        assertTrue(perms.isPublic());
        assertFalse(perms.isContact());
        assertFalse(perms.isFriend());
        assertFalse(perms.isFamily());
    }

    @Test
    public void testSetLocation() throws FlickrException {
        String photoId = testProperties.getGeoWritePhotoId();
        GeoInterface geo = flickr.getPhotosInterface().getGeoInterface();
        GeoData location = new GeoData();
        location.setLatitude(23.34f);
        location.setLongitude(46.99f);
        location.setAccuracy(13);
        geo.setLocation(photoId, location);
        GeoData newLocation = geo.getLocation(photoId);
        assertEquals(location.getLatitude(), newLocation.getLatitude(), 0f);
        assertEquals(location.getLongitude(), newLocation.getLongitude(), 0f);
        assertEquals(location.getAccuracy(), newLocation.getAccuracy(), 0f);
        geo.removeLocation(photoId);
    }

    private void setGeoParameters(String photoId) {
        GeoInterface geo = flickr.getPhotosInterface().getGeoInterface();
        GeoData location = new GeoData();
        location.setLatitude(23.34f);
        location.setLongitude(46.99f);
        location.setAccuracy(13);
        try {
            geo.setLocation(photoId, location);
        } catch (FlickrException e) {
            fail(e.getMessage());
        }
    }

}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import org.junit.Before; import org.junit.Test; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.photos.GeoData; import com.flickr4java.flickr.photos.geo.GeoInterface; import com.flickr4java.flickr.photos.geo.GeoPermissions; public class GeoInterfaceTest extends Flickr4JavaTest { @Before
    public void setUp() throws FlickrException { super.setUp(); setGeoParameters(testProperties.getGeoWritePhotoId()); } @Test
    public void testGetLocation() throws FlickrException { String photoId = testProperties.getGeoWritePhotoId(); GeoInterface geo = flickr.getPhotosInterface().getGeoInterface(); GeoData location = geo.getLocation(photoId); assertNotNull(location); assertTrue(location.getLatitude() > 0); assertTrue(location.getLongitude() > 0); assertTrue(location.getAccuracy() >= 1); assertTrue(location.getAccuracy() <= 16); } @Test
    public void testGetPerms() throws FlickrException { String photoId = testProperties.getGeoWritePhotoId(); GeoInterface geo = flickr.getPhotosInterface().getGeoInterface(); GeoPermissions perms = geo.getPerms(photoId); assertNotNull(perms); assertTrue(perms.isPublic()); assertFalse(perms.isContact()); assertFalse(perms.isFriend()); assertFalse(perms.isFamily()); } @Test
    public void testSetLocation() throws FlickrException { String photoId = testProperties.getGeoWritePhotoId(); GeoInterface geo = flickr.getPhotosInterface().getGeoInterface(); GeoData location = new GeoData(); location.setLatitude(23.34f); location.setLongitude(46.99f); location.setAccuracy(13); geo.setLocation(photoId, location); GeoData newLocation = geo.getLocation(photoId); assertEquals(location.getLatitude(), newLocation.getLatitude(), 0f); assertEquals(location.getLongitude(), newLocation.getLongitude(), 0f); assertEquals(location.getAccuracy(), newLocation.getAccuracy(), 0f); geo.removeLocation(photoId); } private void setGeoParameters(String photoId) { GeoInterface geo = flickr.getPhotosInterface().getGeoInterface(); GeoData location = new GeoData(); location.setLatitude(23.34f); location.setLongitude(46.99f); location.setAccuracy(13); try { geo.setLocation(photoId, location); } catch (FlickrException e) { fail(e.getMessage()); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import org.junit.Before; import org.junit.Test; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.photos.GeoData; import com.flickr4java.flickr.photos.geo.GeoInterface; import com.flickr4java.flickr.photos.geo.GeoPermissions; public class GeoInterfaceTest extends Flickr4JavaTest { @Before
    public void setUp() throws FlickrException { super.setUp(); setGeoParameters(testProperties.getGeoWritePhotoId()); } @Test
    public void testGetLocation() throws FlickrException { String photoId = testProperties.getGeoWritePhotoId(); GeoInterface geo = flickr.getPhotosInterface().getGeoInterface(); GeoData location = geo.getLocation(photoId); assertNotNull(location); assertTrue(location.getLatitude() > 0); assertTrue(location.getLongitude() > 0); assertTrue(location.getAccuracy() >= 1); assertTrue(location.getAccuracy() <= 16); } @Test
    public void testGetPerms() throws FlickrException { String photoId = testProperties.getGeoWritePhotoId(); GeoInterface geo = flickr.getPhotosInterface().getGeoInterface(); GeoPermissions perms = geo.getPerms(photoId); assertNotNull(perms); assertTrue(perms.isPublic()); assertFalse(perms.isContact()); assertFalse(perms.isFriend()); assertFalse(perms.isFamily()); } @Test
    public void testSetLocation() throws FlickrException { String photoId = testProperties.getGeoWritePhotoId(); GeoInterface geo = flickr.getPhotosInterface().getGeoInterface(); GeoData location = new GeoData(); location.setLatitude(23.34f); location.setLongitude(46.99f); location.setAccuracy(13); geo.setLocation(photoId, location); GeoData newLocation = geo.getLocation(photoId); assertEquals(location.getLatitude(), newLocation.getLatitude(), 0f); assertEquals(location.getLongitude(), newLocation.getLongitude(), 0f); assertEquals(location.getAccuracy(), newLocation.getAccuracy(), 0f); geo.removeLocation(photoId); } private void setGeoParameters(String photoId) { GeoInterface geo = flickr.getPhotosInterface().getGeoInterface(); GeoData location = new GeoData(); location.setLatitude(23.34f); location.setLongitude(46.99f); location.setAccuracy(13); try { geo.setLocation(photoId, location); } catch (FlickrException e) { fail(e.getMessage()); } } } ","package com.flickr4java.flickr.test;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import org.junit.Before; import org.junit.Test;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.photos.GeoData; import com.flickr4java.flickr.photos.geo.GeoInterface; import com.flickr4java.flickr.photos.geo.GeoPermissions;  /**
 * 
 * @author till
 * @version $Id: GeoInterfaceTest.java,v 1.4 2008/01/28 23:01:45 x-mago Exp $
 */ public class GeoInterfaceTest extends Flickr4JavaTest {  @Before
    public void setUp() throws FlickrException { super.setUp(); setGeoParameters(testProperties.getGeoWritePhotoId()); }  @Test
    public void testGetLocation() throws FlickrException { String photoId = testProperties.getGeoWritePhotoId(); GeoInterface geo = flickr.getPhotosInterface().getGeoInterface(); GeoData location = geo.getLocation(photoId); assertNotNull(location); assertTrue(location.getLatitude() > 0); assertTrue(location.getLongitude() > 0); assertTrue(location.getAccuracy() >= 1); assertTrue(location.getAccuracy() <= 16); }  @Test
    public void testGetPerms() throws FlickrException { String photoId = testProperties.getGeoWritePhotoId(); GeoInterface geo = flickr.getPhotosInterface().getGeoInterface(); GeoPermissions perms = geo.getPerms(photoId); assertNotNull(perms); assertTrue(perms.isPublic()); assertFalse(perms.isContact()); assertFalse(perms.isFriend()); assertFalse(perms.isFamily()); }  @Test
    public void testSetLocation() throws FlickrException { String photoId = testProperties.getGeoWritePhotoId(); GeoInterface geo = flickr.getPhotosInterface().getGeoInterface(); GeoData location = new GeoData(); location.setLatitude(23.34f); location.setLongitude(46.99f); location.setAccuracy(13); geo.setLocation(photoId, location); GeoData newLocation = geo.getLocation(photoId); assertEquals(location.getLatitude(), newLocation.getLatitude(), 0f); assertEquals(location.getLongitude(), newLocation.getLongitude(), 0f); assertEquals(location.getAccuracy(), newLocation.getAccuracy(), 0f); geo.removeLocation(photoId); }  private void setGeoParameters(String photoId) { GeoInterface geo = flickr.getPhotosInterface().getGeoInterface(); GeoData location = new GeoData(); location.setLatitude(23.34f); location.setLongitude(46.99f); location.setAccuracy(13); try { geo.setLocation(photoId, location); } catch (FlickrException e) { fail(e.getMessage()); } }  }  "
src/test/java/com/flickr4java/flickr/test/GroupsInterfaceTest.java,"

package com.flickr4java.flickr.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.groups.Category;
import com.flickr4java.flickr.groups.Group;
import com.flickr4java.flickr.groups.GroupList;
import com.flickr4java.flickr.groups.GroupsInterface;
import com.flickr4java.flickr.groups.Subcategory;

import org.junit.Test;

import java.util.Collection;

/**
 * @author Anthony Eden
 */
public class GroupsInterfaceTest extends Flickr4JavaTest {

    public void deprecatedBrowse() throws FlickrException {
        GroupsInterface iface = flickr.getGroupsInterface();
        Category cat = iface.browse(null);
        assertNotNull(cat);
        assertEquals(""/"", cat.getName());
        // System.out.println(""category path: "" + cat.getPath());

        Collection<Group> groups = cat.getGroups();
        assertNotNull(groups);
        assertEquals(0, groups.size());
        // Iterator groupsIter = groups.iterator();
        // while (groupsIter.hasNext()) {
        // Group group = (Group) groupsIter.next();
        // System.out.println(""group id: "" + group.getId());
        // System.out.println(""group name: "" + group.getName());
        // }

        Collection<Subcategory> subcats = cat.getSubcategories();
        assertNotNull(subcats);
        assertTrue(subcats.size() > 0);
        // Iterator subcatsIter = subcats.iterator();
        // while (subcatsIter.hasNext()) {
        // Subcategory subcategory = (Subcategory) subcatsIter.next();
        // System.out.println(""subcat id: "" + subcategory.getId());
        // System.out.println(""subcat name: "" + subcategory.getName());
        // }
    }

    /*
     * It is not longer possible to browse the groups hierarchy
     * 
     * @Test public void testBrowseWithId() throws FlickrException { GroupsInterface iface = flickr.getGroupsInterface(); Category cat = iface.browse(""68""); //
     * browse the Flickr category assertNotNull(cat); assertEquals(""Flickr"", cat.getName()); assertNotNull(cat.getPath()); assertNotNull(cat.getPathIds());
     * 
     * Collection groups = cat.getGroups(); assertNotNull(groups); assertTrue(groups.size() > 0);
     * 
     * Collection subcats = cat.getSubcategories(); assertNotNull(subcats); assertTrue(subcats.size() > 0); // System.out.println(""category name: "" +
     * cat.getName()); }
     */

    @Test
    public void testGetInfo() throws FlickrException {
        GroupsInterface iface = flickr.getGroupsInterface();
        Group group = iface.getInfo(""34427469792@N01"");

        assertNotNull(group);
        assertEquals(""34427469792@N01"", group.getId());
        assertEquals(""FlickrCentral"", group.getName());
        assertTrue(group.getMembers() > 0);
        assertTrue(group.getSecureBuddyIconUrl().startsWith(""https://farm""));

        // System.out.println(""group members: "" + group.getMembers());
    }

    @Test
    public void testSearch() throws FlickrException {
        GroupsInterface iface = flickr.getGroupsInterface();
        GroupList<Group> groups = (GroupList<Group>) iface.search(""java"", 0, 0);
        assertTrue(groups.size() > 0);
        assertEquals(1, groups.getPage());
        assertTrue(groups.getPages() > 0);
        assertEquals(100, groups.getPerPage());
        assertTrue(groups.getTotal() > 0);
    }

    @Test
    public void testSearchPage() throws FlickrException {
        GroupsInterface iface = flickr.getGroupsInterface();
        GroupList<Group> groups = (GroupList<Group>) iface.search(""java"", 100, 1);
        assertTrue(groups.size() > 0);
        assertEquals(1, groups.getPage());
        assertTrue(groups.getPages() > 0);
        assertEquals(100, groups.getPerPage());
        assertTrue(groups.getTotal() > 0);
    }

    @Test
    public void testJoinLeave() throws FlickrException {
        GroupsInterface iface = flickr.getGroupsInterface();

        Group group = iface.getInfo(testProperties.getGroupId());
        int cntBeforeJoin = group.getMembers();
        try {
            iface.join(testProperties.getGroupId(), null);
            group = iface.getInfo(testProperties.getGroupId());
            int cntAfterJoin = group.getMembers();
            assertTrue(""Member count increased by 1"", cntBeforeJoin + 1 == cntAfterJoin);
        } catch (FlickrException e) {
            // Ignore if user is already in group
            if (!e.getErrorCode().equals(""4"")) {
                throw e;
            }
        }

        try {
            iface.leave(testProperties.getGroupId(), false);
            group = iface.getInfo(testProperties.getGroupId());
            int cntAfterLeave = group.getMembers();
            assertTrue(""Member count decreased by 1"", cntAfterLeave == cntBeforeJoin);
        } catch (FlickrException e) {
            // Ignore if user doesn't have delete permissions
            if (!e.getErrorCode().equals(""99"")) {
                throw e;
            }
        }

    }
}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.groups.Category; import com.flickr4java.flickr.groups.Group; import com.flickr4java.flickr.groups.GroupList; import com.flickr4java.flickr.groups.GroupsInterface; import com.flickr4java.flickr.groups.Subcategory; import org.junit.Test; import java.util.Collection; public class GroupsInterfaceTest extends Flickr4JavaTest { public void deprecatedBrowse() throws FlickrException { GroupsInterface iface = flickr.getGroupsInterface(); Category cat = iface.browse(null); assertNotNull(cat); assertEquals(""/"", cat.getName()); Collection<Group> groups = cat.getGroups(); assertNotNull(groups); assertEquals(0, groups.size()); Collection<Subcategory> subcats = cat.getSubcategories(); assertNotNull(subcats); assertTrue(subcats.size() > 0); } @Test
    public void testGetInfo() throws FlickrException { GroupsInterface iface = flickr.getGroupsInterface(); Group group = iface.getInfo(""34427469792@N01""); assertNotNull(group); assertEquals(""34427469792@N01"", group.getId()); assertEquals(""FlickrCentral"", group.getName()); assertTrue(group.getMembers() > 0); } @Test
    public void testSearch() throws FlickrException { GroupsInterface iface = flickr.getGroupsInterface(); GroupList<Group> groups = (GroupList<Group>) iface.search(""java"", 0, 0); assertTrue(groups.size() > 0); assertEquals(1, groups.getPage()); assertTrue(groups.getPages() > 0); assertEquals(100, groups.getPerPage()); assertTrue(groups.getTotal() > 0); } @Test
    public void testSearchPage() throws FlickrException { GroupsInterface iface = flickr.getGroupsInterface(); GroupList<Group> groups = (GroupList<Group>) iface.search(""java"", 100, 1); assertTrue(groups.size() > 0); assertEquals(1, groups.getPage()); assertTrue(groups.getPages() > 0); assertEquals(100, groups.getPerPage()); assertTrue(groups.getTotal() > 0); } @Test
    public void testJoinLeave() throws FlickrException { GroupsInterface iface = flickr.getGroupsInterface(); Group group = iface.getInfo(testProperties.getGroupId()); int cntBeforeJoin = group.getMembers(); try { iface.join(testProperties.getGroupId(), null); group = iface.getInfo(testProperties.getGroupId()); int cntAfterJoin = group.getMembers(); assertTrue(""Member count increased by 1"", cntBeforeJoin + 1 == cntAfterJoin); } catch (FlickrException e) { if (!e.getErrorCode().equals(""4"")) { throw e; } } try { iface.leave(testProperties.getGroupId(), false); group = iface.getInfo(testProperties.getGroupId()); int cntAfterLeave = group.getMembers(); assertTrue(""Member count decreased by 1"", cntAfterLeave == cntBeforeJoin); } catch (FlickrException e) { if (!e.getErrorCode().equals(""99"")) { throw e; } } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.groups.Category; import com.flickr4java.flickr.groups.Group; import com.flickr4java.flickr.groups.GroupList; import com.flickr4java.flickr.groups.GroupsInterface; import com.flickr4java.flickr.groups.Subcategory; import org.junit.Test; import java.util.Collection; public class GroupsInterfaceTest extends Flickr4JavaTest { public void deprecatedBrowse() throws FlickrException { GroupsInterface iface = flickr.getGroupsInterface(); Category cat = iface.browse(null); assertNotNull(cat); assertEquals(""/"", cat.getName()); Collection<Group> groups = cat.getGroups(); assertNotNull(groups); assertEquals(0, groups.size()); Collection<Subcategory> subcats = cat.getSubcategories(); assertNotNull(subcats); assertTrue(subcats.size() > 0); } @Test
    public void testGetInfo() throws FlickrException { GroupsInterface iface = flickr.getGroupsInterface(); Group group = iface.getInfo(""34427469792@N01""); assertNotNull(group); assertEquals(""34427469792@N01"", group.getId()); assertEquals(""FlickrCentral"", group.getName()); assertTrue(group.getMembers() > 0); } @Test
    public void testSearch() throws FlickrException { GroupsInterface iface = flickr.getGroupsInterface(); GroupList<Group> groups = (GroupList<Group>) iface.search(""java"", 0, 0); assertTrue(groups.size() > 0); assertEquals(1, groups.getPage()); assertTrue(groups.getPages() > 0); assertEquals(100, groups.getPerPage()); assertTrue(groups.getTotal() > 0); } @Test
    public void testSearchPage() throws FlickrException { GroupsInterface iface = flickr.getGroupsInterface(); GroupList<Group> groups = (GroupList<Group>) iface.search(""java"", 100, 1); assertTrue(groups.size() > 0); assertEquals(1, groups.getPage()); assertTrue(groups.getPages() > 0); assertEquals(100, groups.getPerPage()); assertTrue(groups.getTotal() > 0); } @Test
    public void testJoinLeave() throws FlickrException { GroupsInterface iface = flickr.getGroupsInterface(); Group group = iface.getInfo(testProperties.getGroupId()); int cntBeforeJoin = group.getMembers(); try { iface.join(testProperties.getGroupId(), null); group = iface.getInfo(testProperties.getGroupId()); int cntAfterJoin = group.getMembers(); assertTrue(""Member count increased by 1"", cntBeforeJoin + 1 == cntAfterJoin); } catch (FlickrException e) { if (!e.getErrorCode().equals(""4"")) { throw e; } } try { iface.leave(testProperties.getGroupId(), false); group = iface.getInfo(testProperties.getGroupId()); int cntAfterLeave = group.getMembers(); assertTrue(""Member count decreased by 1"", cntAfterLeave == cntBeforeJoin); } catch (FlickrException e) { if (!e.getErrorCode().equals(""99"")) { throw e; } } } } ","
 package com.flickr4java.flickr.test;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.groups.Category; import com.flickr4java.flickr.groups.Group; import com.flickr4java.flickr.groups.GroupList; import com.flickr4java.flickr.groups.GroupsInterface; import com.flickr4java.flickr.groups.Subcategory;  import org.junit.Test;  import java.util.Collection;  /**
 * @author Anthony Eden
 */ public class GroupsInterfaceTest extends Flickr4JavaTest {  public void deprecatedBrowse() throws FlickrException { GroupsInterface iface = flickr.getGroupsInterface(); Category cat = iface.browse(null); assertNotNull(cat); assertEquals(""/"", cat.getName()); // System.out.println(""category path: "" + cat.getPath());  Collection<Group> groups = cat.getGroups(); assertNotNull(groups); assertEquals(0, groups.size()); // Iterator groupsIter = groups.iterator(); // while (groupsIter.hasNext()) { // Group group = (Group) groupsIter.next(); // System.out.println(""group id: "" + group.getId()); // System.out.println(""group name: "" + group.getName()); // }  Collection<Subcategory> subcats = cat.getSubcategories(); assertNotNull(subcats); assertTrue(subcats.size() > 0); // Iterator subcatsIter = subcats.iterator(); // while (subcatsIter.hasNext()) { // Subcategory subcategory = (Subcategory) subcatsIter.next(); // System.out.println(""subcat id: "" + subcategory.getId()); // System.out.println(""subcat name: "" + subcategory.getName()); // } }  /*
     * It is not longer possible to browse the groups hierarchy
     * 
     * @Test public void testBrowseWithId() throws FlickrException { GroupsInterface iface = flickr.getGroupsInterface(); Category cat = iface.browse(""68""); //
     * browse the Flickr category assertNotNull(cat); assertEquals(""Flickr"", cat.getName()); assertNotNull(cat.getPath()); assertNotNull(cat.getPathIds());
     * 
     * Collection groups = cat.getGroups(); assertNotNull(groups); assertTrue(groups.size() > 0);
     * 
     * Collection subcats = cat.getSubcategories(); assertNotNull(subcats); assertTrue(subcats.size() > 0); // System.out.println(""category name: "" +
     * cat.getName()); }
     */  @Test
    public void testGetInfo() throws FlickrException { GroupsInterface iface = flickr.getGroupsInterface(); Group group = iface.getInfo(""34427469792@N01"");  assertNotNull(group); assertEquals(""34427469792@N01"", group.getId()); assertEquals(""FlickrCentral"", group.getName()); assertTrue(group.getMembers() > 0); //farm""));  // System.out.println(""group members: "" + group.getMembers()); }  @Test
    public void testSearch() throws FlickrException { GroupsInterface iface = flickr.getGroupsInterface(); GroupList<Group> groups = (GroupList<Group>) iface.search(""java"", 0, 0); assertTrue(groups.size() > 0); assertEquals(1, groups.getPage()); assertTrue(groups.getPages() > 0); assertEquals(100, groups.getPerPage()); assertTrue(groups.getTotal() > 0); }  @Test
    public void testSearchPage() throws FlickrException { GroupsInterface iface = flickr.getGroupsInterface(); GroupList<Group> groups = (GroupList<Group>) iface.search(""java"", 100, 1); assertTrue(groups.size() > 0); assertEquals(1, groups.getPage()); assertTrue(groups.getPages() > 0); assertEquals(100, groups.getPerPage()); assertTrue(groups.getTotal() > 0); }  @Test
    public void testJoinLeave() throws FlickrException { GroupsInterface iface = flickr.getGroupsInterface();  Group group = iface.getInfo(testProperties.getGroupId()); int cntBeforeJoin = group.getMembers(); try { iface.join(testProperties.getGroupId(), null); group = iface.getInfo(testProperties.getGroupId()); int cntAfterJoin = group.getMembers(); assertTrue(""Member count increased by 1"", cntBeforeJoin + 1 == cntAfterJoin); } catch (FlickrException e) { // Ignore if user is already in group if (!e.getErrorCode().equals(""4"")) { throw e; } }  try { iface.leave(testProperties.getGroupId(), false); group = iface.getInfo(testProperties.getGroupId()); int cntAfterLeave = group.getMembers(); assertTrue(""Member count decreased by 1"", cntAfterLeave == cntBeforeJoin); } catch (FlickrException e) { // Ignore if user doesn't have delete permissions if (!e.getErrorCode().equals(""99"")) { throw e; } }  } }  "
src/test/java/com/flickr4java/flickr/test/InterestingnessInterfaceTest.java,"package com.flickr4java.flickr.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.interestingness.InterestingnessInterface;
import com.flickr4java.flickr.photos.Extras;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoList;

import org.junit.Test;

/**
 * 
 * @version $Id: InterestingnessInterfaceTest.java,v 1.5 2008/01/28 23:01:45 x-mago Exp $
 */
public class InterestingnessInterfaceTest extends Flickr4JavaTest {

    /*
     * Test method for 'com.flickr4java.flickr.test.interestingness.InterestingnessInterface.getList(String, Set, int, int)'
     */
    @Test
    public void testGetListStringSetIntInt() throws FlickrException {
        assertNotNull(flickr);
        InterestingnessInterface ii = flickr.getInterestingnessInterface();
        assertNotNull(ii);
        PhotoList<Photo> list = ii.getList(""2006-09-11"", Extras.ALL_EXTRAS, 7, 9);
        assertNotNull(list);
        assertTrue(list.size() >= 1);
        assertTrue(list.getPage() >= 1);
        assertTrue(list.getPerPage() >= 1);
        assertTrue(list.getTotal() >= 1);
        assertTrue(list.get(0) instanceof Photo);
        Photo photo = list.get(1);
        assertNotNull(photo.getId());
        assertNotNull(photo.getLicense());
        assertNotNull(photo.getOwner());

        list = ii.getList(""2006-09-11"", null, 500, 1);
        assertNotNull(list);
        assertTrue(list.size() > 0);

        list = ii.getList((String) null, Extras.ALL_EXTRAS, 100, 1);
        assertNotNull(list);
        assertTrue(list.size() > 1);
        photo = list.get(0);
        for (int i = list.size() - 1; i >= 0; --i) {
            photo = list.get(i);
            if (photo.hasGeoData()) {
                // System.out.println(photo.getId() + "" "" + photo.getGeoData() + "" "" + photo.getUrl());
            }
        }
    }

    /*
     * Test method for 'com.flickr4java.flickr.test.interestingness.InterestingnessInterface.getList(Date, Set, int, int)'
     */
    @Test
    public void testGetListDateSetIntInt() {

    }

    /*
     * Test method for 'com.flickr4java.flickr.test.interestingness.InterestingnessInterface.getList()'
     */
    @Test
    public void testGetList() {

    }

}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.interestingness.InterestingnessInterface; import com.flickr4java.flickr.photos.Extras; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import org.junit.Test; public class InterestingnessInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetListStringSetIntInt() throws FlickrException { assertNotNull(flickr); InterestingnessInterface ii = flickr.getInterestingnessInterface(); assertNotNull(ii); PhotoList<Photo> list = ii.getList(""2006-09-11"", Extras.ALL_EXTRAS, 7, 9); assertNotNull(list); assertTrue(list.size() >= 1); assertTrue(list.getPage() >= 1); assertTrue(list.getPerPage() >= 1); assertTrue(list.getTotal() >= 1); assertTrue(list.get(0) instanceof Photo); Photo photo = list.get(1); assertNotNull(photo.getId()); assertNotNull(photo.getLicense()); assertNotNull(photo.getOwner()); list = ii.getList(""2006-09-11"", null, 500, 1); assertNotNull(list); assertTrue(list.size() > 0); list = ii.getList((String) null, Extras.ALL_EXTRAS, 100, 1); assertNotNull(list); assertTrue(list.size() > 1); photo = list.get(0); for (int i = list.size() - 1; i >= 0; --i) { photo = list.get(i); if (photo.hasGeoData()) { } } } @Test
    public void testGetListDateSetIntInt() { } @Test
    public void testGetList() { } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.interestingness.InterestingnessInterface; import com.flickr4java.flickr.photos.Extras; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import org.junit.Test; public class InterestingnessInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetListStringSetIntInt() throws FlickrException { assertNotNull(flickr); InterestingnessInterface ii = flickr.getInterestingnessInterface(); assertNotNull(ii); PhotoList<Photo> list = ii.getList(""2006-09-11"", Extras.ALL_EXTRAS, 7, 9); assertNotNull(list); assertTrue(list.size() >= 1); assertTrue(list.getPage() >= 1); assertTrue(list.getPerPage() >= 1); assertTrue(list.getTotal() >= 1); assertTrue(list.get(0) instanceof Photo); Photo photo = list.get(1); assertNotNull(photo.getId()); assertNotNull(photo.getLicense()); assertNotNull(photo.getOwner()); list = ii.getList(""2006-09-11"", null, 500, 1); assertNotNull(list); assertTrue(list.size() > 0); list = ii.getList((String) null, Extras.ALL_EXTRAS, 100, 1); assertNotNull(list); assertTrue(list.size() > 1); photo = list.get(0); for (int i = list.size() - 1; i >= 0; --i) { photo = list.get(i); if (photo.hasGeoData()) { } } } @Test
    public void testGetListDateSetIntInt() { } @Test
    public void testGetList() { } } ","package com.flickr4java.flickr.test;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.interestingness.InterestingnessInterface; import com.flickr4java.flickr.photos.Extras; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList;  import org.junit.Test;  /**
 * 
 * @version $Id: InterestingnessInterfaceTest.java,v 1.5 2008/01/28 23:01:45 x-mago Exp $
 */ public class InterestingnessInterfaceTest extends Flickr4JavaTest {  /*
     * Test method for 'com.flickr4java.flickr.test.interestingness.InterestingnessInterface.getList(String, Set, int, int)'
     */ @Test
    public void testGetListStringSetIntInt() throws FlickrException { assertNotNull(flickr); InterestingnessInterface ii = flickr.getInterestingnessInterface(); assertNotNull(ii); PhotoList<Photo> list = ii.getList(""2006-09-11"", Extras.ALL_EXTRAS, 7, 9); assertNotNull(list); assertTrue(list.size() >= 1); assertTrue(list.getPage() >= 1); assertTrue(list.getPerPage() >= 1); assertTrue(list.getTotal() >= 1); assertTrue(list.get(0) instanceof Photo); Photo photo = list.get(1); assertNotNull(photo.getId()); assertNotNull(photo.getLicense()); assertNotNull(photo.getOwner());  list = ii.getList(""2006-09-11"", null, 500, 1); assertNotNull(list); assertTrue(list.size() > 0);  list = ii.getList((String) null, Extras.ALL_EXTRAS, 100, 1); assertNotNull(list); assertTrue(list.size() > 1); photo = list.get(0); for (int i = list.size() - 1; i >= 0; --i) { photo = list.get(i); if (photo.hasGeoData()) { // System.out.println(photo.getId() + "" "" + photo.getGeoData() + "" "" + photo.getUrl()); } } }  /*
     * Test method for 'com.flickr4java.flickr.test.interestingness.InterestingnessInterface.getList(Date, Set, int, int)'
     */ @Test
    public void testGetListDateSetIntInt() {  }  /*
     * Test method for 'com.flickr4java.flickr.test.interestingness.InterestingnessInterface.getList()'
     */ @Test
    public void testGetList() {  }  }  "
src/test/java/com/flickr4java/flickr/test/LicensesInterfaceTest.java,"/*
 * Copyright (c) 2005 Your Corporation. All Rights Reserved.
 */

package com.flickr4java.flickr.test;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.util.Collection;

import org.junit.Test;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.photos.licenses.License;
import com.flickr4java.flickr.photos.licenses.LicensesInterface;

/**
 * @author Anthony Eden
 */
public class LicensesInterfaceTest extends Flickr4JavaTest {

    @Test
    public void testGetInfo() throws FlickrException {
        LicensesInterface iface = flickr.getLicensesInterface();
        Collection<License> licenses = iface.getInfo();
        assertNotNull(licenses);
        assertTrue(licenses.size() > 0);
        for (License license : licenses) {
            assertNotNull(license.getId());
            assertNotNull(license.getName());
            assertNotNull(license.getUrl());
        }
    }
}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import java.util.Collection; import org.junit.Test; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.photos.licenses.License; import com.flickr4java.flickr.photos.licenses.LicensesInterface; public class LicensesInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetInfo() throws FlickrException { LicensesInterface iface = flickr.getLicensesInterface(); Collection<License> licenses = iface.getInfo(); assertNotNull(licenses); assertTrue(licenses.size() > 0); for (License license : licenses) { assertNotNull(license.getId()); assertNotNull(license.getName()); assertNotNull(license.getUrl()); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import java.util.Collection; import org.junit.Test; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.photos.licenses.License; import com.flickr4java.flickr.photos.licenses.LicensesInterface; public class LicensesInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetInfo() throws FlickrException { LicensesInterface iface = flickr.getLicensesInterface(); Collection<License> licenses = iface.getInfo(); assertNotNull(licenses); assertTrue(licenses.size() > 0); for (License license : licenses) { assertNotNull(license.getId()); assertNotNull(license.getName()); assertNotNull(license.getUrl()); } } } ","/*
 * Copyright (c) 2005 Your Corporation. All Rights Reserved.
 */  package com.flickr4java.flickr.test;  import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue;  import java.util.Collection;  import org.junit.Test;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.photos.licenses.License; import com.flickr4java.flickr.photos.licenses.LicensesInterface;  /**
 * @author Anthony Eden
 */ public class LicensesInterfaceTest extends Flickr4JavaTest {  @Test
    public void testGetInfo() throws FlickrException { LicensesInterface iface = flickr.getLicensesInterface(); Collection<License> licenses = iface.getInfo(); assertNotNull(licenses); assertTrue(licenses.size() > 0); for (License license : licenses) { assertNotNull(license.getId()); assertNotNull(license.getName()); assertNotNull(license.getUrl()); } } }  "
src/test/java/com/flickr4java/flickr/test/MachinetagsInterfaceTest.java,"package com.flickr4java.flickr.test;

import static org.junit.Assert.assertTrue;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.machinetags.MachinetagsInterface;
import com.flickr4java.flickr.machinetags.Namespace;
import com.flickr4java.flickr.machinetags.NamespacesList;
import com.flickr4java.flickr.machinetags.Pair;
import com.flickr4java.flickr.machinetags.Predicate;
import com.flickr4java.flickr.machinetags.Value;

import org.junit.Test;

import java.util.Calendar;

/**
 * @author mago
 * @version $Id: MachinetagsInterfaceTest.java,v 1.2 2009/06/21 19:55:15 x-mago Exp $
 */
public class MachinetagsInterfaceTest extends Flickr4JavaTest {

    @Test
    public void testGetNamespaces() throws FlickrException {
        MachinetagsInterface machinetagsInterface = flickr.getMachinetagsInterface();
        String predicate = ""collection"";
        int page = 1;
        int perPage = 100;
        NamespacesList<Namespace> list = machinetagsInterface.getNamespaces(predicate, perPage, page);
        assertTrue(list.size() > 3);
        boolean contentFound = false;
        for (int i = 0; i < list.size(); i++) {
            Namespace ns = list.get(i);
            if (ns.getValue().equals(""content"")) {
                contentFound = true;
            }
        }
        assertTrue(contentFound);
    }

    @Test
    public void testGetPredicates() throws FlickrException {
        MachinetagsInterface machinetagsInterface = flickr.getMachinetagsInterface();
        String namespace = ""all"";
        int page = 1;
        int perPage = 100;
        NamespacesList<Predicate> list = machinetagsInterface.getPredicates(namespace, perPage, page);
        assertTrue(list.size() > 3);
        boolean contentFound = false;
        for (Predicate ns : list) {
            if (ns.getValue().equals(""groups"")) {
                contentFound = true;
            }
        }
        assertTrue(contentFound);
    }

    @Test
    public void testGetPairs() throws FlickrException {
        MachinetagsInterface machinetagsInterface = flickr.getMachinetagsInterface();
        String namespace = ""ceramics"";
        int page = 1;
        int perPage = 100;
        NamespacesList<Pair> list = machinetagsInterface.getPairs(namespace, null, perPage, page);
        assertTrue(list.size() > 3);
        boolean contentFound = false;
        for (Pair pair : list) {
            if (pair.getValue().equals(""ceramics:title"")) {
                contentFound = true;
            }
        }
        assertTrue(contentFound);
    }

    @Test
    public void testGetValues() throws FlickrException {
        MachinetagsInterface machinetagsInterface = flickr.getMachinetagsInterface();
        String namespace = ""ceramics"";
        String predicate = ""material"";
        int page = 1;
        int perPage = 100;
        NamespacesList<Value> list = machinetagsInterface.getValues(namespace, predicate, perPage, page);
        assertTrue(list.size() > 3);
        boolean contentFound = false;
        for (Value value : list) {
            if (value.getValue().equals(""porcelain"")) {
                contentFound = true;
            }
        }
        assertTrue(contentFound);
    }

    @Test
    public void testGetRecentValues() throws FlickrException {
        MachinetagsInterface machinetagsInterface = flickr.getMachinetagsInterface();
        String namespace = ""filmdev"";
        String predicate = ""recipe"";
        Calendar addedSince = Calendar.getInstance();
        addedSince.add(Calendar.YEAR, -10);
        NamespacesList<Value> list = machinetagsInterface.getRecentValues(namespace, predicate, addedSince.getTime());
        assertTrue(list.size() >= 3);
        boolean contentFound = false;
        for (Value value : list) {
            if (value.getValue().equals(""8040"")) {
                contentFound = true;
            }
        }
        assertTrue(contentFound);
    }
}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.machinetags.MachinetagsInterface; import com.flickr4java.flickr.machinetags.Namespace; import com.flickr4java.flickr.machinetags.NamespacesList; import com.flickr4java.flickr.machinetags.Pair; import com.flickr4java.flickr.machinetags.Predicate; import com.flickr4java.flickr.machinetags.Value; import org.junit.Test; import java.util.Calendar; public class MachinetagsInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetNamespaces() throws FlickrException { MachinetagsInterface machinetagsInterface = flickr.getMachinetagsInterface(); String predicate = ""collection""; int page = 1; int perPage = 100; NamespacesList<Namespace> list = machinetagsInterface.getNamespaces(predicate, perPage, page); assertTrue(list.size() > 3); boolean contentFound = false; for (int i = 0; i < list.size(); i++) { Namespace ns = list.get(i); if (ns.getValue().equals(""content"")) { contentFound = true; } } assertTrue(contentFound); } @Test
    public void testGetPredicates() throws FlickrException { MachinetagsInterface machinetagsInterface = flickr.getMachinetagsInterface(); String namespace = ""all""; int page = 1; int perPage = 100; NamespacesList<Predicate> list = machinetagsInterface.getPredicates(namespace, perPage, page); assertTrue(list.size() > 3); boolean contentFound = false; for (Predicate ns : list) { if (ns.getValue().equals(""groups"")) { contentFound = true; } } assertTrue(contentFound); } @Test
    public void testGetPairs() throws FlickrException { MachinetagsInterface machinetagsInterface = flickr.getMachinetagsInterface(); String namespace = ""ceramics""; int page = 1; int perPage = 100; NamespacesList<Pair> list = machinetagsInterface.getPairs(namespace, null, perPage, page); assertTrue(list.size() > 3); boolean contentFound = false; for (Pair pair : list) { if (pair.getValue().equals(""ceramics:title"")) { contentFound = true; } } assertTrue(contentFound); } @Test
    public void testGetValues() throws FlickrException { MachinetagsInterface machinetagsInterface = flickr.getMachinetagsInterface(); String namespace = ""ceramics""; String predicate = ""material""; int page = 1; int perPage = 100; NamespacesList<Value> list = machinetagsInterface.getValues(namespace, predicate, perPage, page); assertTrue(list.size() > 3); boolean contentFound = false; for (Value value : list) { if (value.getValue().equals(""porcelain"")) { contentFound = true; } } assertTrue(contentFound); } @Test
    public void testGetRecentValues() throws FlickrException { MachinetagsInterface machinetagsInterface = flickr.getMachinetagsInterface(); String namespace = ""filmdev""; String predicate = ""recipe""; Calendar addedSince = Calendar.getInstance(); addedSince.add(Calendar.YEAR, -10); NamespacesList<Value> list = machinetagsInterface.getRecentValues(namespace, predicate, addedSince.getTime()); assertTrue(list.size() >= 3); boolean contentFound = false; for (Value value : list) { if (value.getValue().equals(""8040"")) { contentFound = true; } } assertTrue(contentFound); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.machinetags.MachinetagsInterface; import com.flickr4java.flickr.machinetags.Namespace; import com.flickr4java.flickr.machinetags.NamespacesList; import com.flickr4java.flickr.machinetags.Pair; import com.flickr4java.flickr.machinetags.Predicate; import com.flickr4java.flickr.machinetags.Value; import org.junit.Test; import java.util.Calendar; public class MachinetagsInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetNamespaces() throws FlickrException { MachinetagsInterface machinetagsInterface = flickr.getMachinetagsInterface(); String predicate = ""collection""; int page = 1; int perPage = 100; NamespacesList<Namespace> list = machinetagsInterface.getNamespaces(predicate, perPage, page); assertTrue(list.size() > 3); boolean contentFound = false; for (int i = 0; i < list.size(); i++) { Namespace ns = list.get(i); if (ns.getValue().equals(""content"")) { contentFound = true; } } assertTrue(contentFound); } @Test
    public void testGetPredicates() throws FlickrException { MachinetagsInterface machinetagsInterface = flickr.getMachinetagsInterface(); String namespace = ""all""; int page = 1; int perPage = 100; NamespacesList<Predicate> list = machinetagsInterface.getPredicates(namespace, perPage, page); assertTrue(list.size() > 3); boolean contentFound = false; for (Predicate ns : list) { if (ns.getValue().equals(""groups"")) { contentFound = true; } } assertTrue(contentFound); } @Test
    public void testGetPairs() throws FlickrException { MachinetagsInterface machinetagsInterface = flickr.getMachinetagsInterface(); String namespace = ""ceramics""; int page = 1; int perPage = 100; NamespacesList<Pair> list = machinetagsInterface.getPairs(namespace, null, perPage, page); assertTrue(list.size() > 3); boolean contentFound = false; for (Pair pair : list) { if (pair.getValue().equals(""ceramics:title"")) { contentFound = true; } } assertTrue(contentFound); } @Test
    public void testGetValues() throws FlickrException { MachinetagsInterface machinetagsInterface = flickr.getMachinetagsInterface(); String namespace = ""ceramics""; String predicate = ""material""; int page = 1; int perPage = 100; NamespacesList<Value> list = machinetagsInterface.getValues(namespace, predicate, perPage, page); assertTrue(list.size() > 3); boolean contentFound = false; for (Value value : list) { if (value.getValue().equals(""porcelain"")) { contentFound = true; } } assertTrue(contentFound); } @Test
    public void testGetRecentValues() throws FlickrException { MachinetagsInterface machinetagsInterface = flickr.getMachinetagsInterface(); String namespace = ""filmdev""; String predicate = ""recipe""; Calendar addedSince = Calendar.getInstance(); addedSince.add(Calendar.YEAR, -10); NamespacesList<Value> list = machinetagsInterface.getRecentValues(namespace, predicate, addedSince.getTime()); assertTrue(list.size() >= 3); boolean contentFound = false; for (Value value : list) { if (value.getValue().equals(""8040"")) { contentFound = true; } } assertTrue(contentFound); } } ","package com.flickr4java.flickr.test;  import static org.junit.Assert.assertTrue;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.machinetags.MachinetagsInterface; import com.flickr4java.flickr.machinetags.Namespace; import com.flickr4java.flickr.machinetags.NamespacesList; import com.flickr4java.flickr.machinetags.Pair; import com.flickr4java.flickr.machinetags.Predicate; import com.flickr4java.flickr.machinetags.Value;  import org.junit.Test;  import java.util.Calendar;  /**
 * @author mago
 * @version $Id: MachinetagsInterfaceTest.java,v 1.2 2009/06/21 19:55:15 x-mago Exp $
 */ public class MachinetagsInterfaceTest extends Flickr4JavaTest {  @Test
    public void testGetNamespaces() throws FlickrException { MachinetagsInterface machinetagsInterface = flickr.getMachinetagsInterface(); String predicate = ""collection""; int page = 1; int perPage = 100; NamespacesList<Namespace> list = machinetagsInterface.getNamespaces(predicate, perPage, page); assertTrue(list.size() > 3); boolean contentFound = false; for (int i = 0; i < list.size(); i++) { Namespace ns = list.get(i); if (ns.getValue().equals(""content"")) { contentFound = true; } } assertTrue(contentFound); }  @Test
    public void testGetPredicates() throws FlickrException { MachinetagsInterface machinetagsInterface = flickr.getMachinetagsInterface(); String namespace = ""all""; int page = 1; int perPage = 100; NamespacesList<Predicate> list = machinetagsInterface.getPredicates(namespace, perPage, page); assertTrue(list.size() > 3); boolean contentFound = false; for (Predicate ns : list) { if (ns.getValue().equals(""groups"")) { contentFound = true; } } assertTrue(contentFound); }  @Test
    public void testGetPairs() throws FlickrException { MachinetagsInterface machinetagsInterface = flickr.getMachinetagsInterface(); String namespace = ""ceramics""; int page = 1; int perPage = 100; NamespacesList<Pair> list = machinetagsInterface.getPairs(namespace, null, perPage, page); assertTrue(list.size() > 3); boolean contentFound = false; for (Pair pair : list) { if (pair.getValue().equals(""ceramics:title"")) { contentFound = true; } } assertTrue(contentFound); }  @Test
    public void testGetValues() throws FlickrException { MachinetagsInterface machinetagsInterface = flickr.getMachinetagsInterface(); String namespace = ""ceramics""; String predicate = ""material""; int page = 1; int perPage = 100; NamespacesList<Value> list = machinetagsInterface.getValues(namespace, predicate, perPage, page); assertTrue(list.size() > 3); boolean contentFound = false; for (Value value : list) { if (value.getValue().equals(""porcelain"")) { contentFound = true; } } assertTrue(contentFound); }  @Test
    public void testGetRecentValues() throws FlickrException { MachinetagsInterface machinetagsInterface = flickr.getMachinetagsInterface(); String namespace = ""filmdev""; String predicate = ""recipe""; Calendar addedSince = Calendar.getInstance(); addedSince.add(Calendar.YEAR, -10); NamespacesList<Value> list = machinetagsInterface.getRecentValues(namespace, predicate, addedSince.getTime()); assertTrue(list.size() >= 3); boolean contentFound = false; for (Value value : list) { if (value.getValue().equals(""8040"")) { contentFound = true; } } assertTrue(contentFound); } }  "
src/test/java/com/flickr4java/flickr/test/MembersInterfaceTest.java,"

package com.flickr4java.flickr.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.groups.members.Member;
import com.flickr4java.flickr.groups.members.MembersInterface;
import com.flickr4java.flickr.groups.members.MembersList;

import org.junit.Test;

import java.util.HashSet;
import java.util.Set;

/**
 * @author mago
 * @version $Id: MembersInterfaceTest.java,v 1.3 2009/07/11 20:30:27 x-mago Exp $
 */
public class MembersInterfaceTest extends Flickr4JavaTest {

    @Test
    public void testGetList() throws FlickrException {
        MembersInterface iface = flickr.getMembersInterface();
        // Group: Urban fragments
        String id = testProperties.getGroupId();
        Set<String> memberTypes = new HashSet<String>();
        memberTypes.add(Member.TYPE_MEMBER);
        memberTypes.add(Member.TYPE_ADMIN);
        memberTypes.add(Member.TYPE_MODERATOR);
        MembersList<Member> list = iface.getList(id, memberTypes, 50, 1);
        assertNotNull(list);
        assertEquals(50, list.size());
        Member m = list.get(10);
        assertTrue(m.getId().indexOf(""@"") > 0);
        assertTrue(m.getUserName().length() > 0);
        assertTrue(m.getIconFarm() > -1);
        assertTrue(m.getIconServer() > -1);
    }
}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.groups.members.Member; import com.flickr4java.flickr.groups.members.MembersInterface; import com.flickr4java.flickr.groups.members.MembersList; import org.junit.Test; import java.util.HashSet; import java.util.Set; public class MembersInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetList() throws FlickrException { MembersInterface iface = flickr.getMembersInterface(); String id = testProperties.getGroupId(); Set<String> memberTypes = new HashSet<String>(); memberTypes.add(Member.TYPE_MEMBER); memberTypes.add(Member.TYPE_ADMIN); memberTypes.add(Member.TYPE_MODERATOR); MembersList<Member> list = iface.getList(id, memberTypes, 50, 1); assertNotNull(list); assertEquals(50, list.size()); Member m = list.get(10); assertTrue(m.getId().indexOf(""@"") > 0); assertTrue(m.getUserName().length() > 0); assertTrue(m.getIconFarm() > -1); assertTrue(m.getIconServer() > -1); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.groups.members.Member; import com.flickr4java.flickr.groups.members.MembersInterface; import com.flickr4java.flickr.groups.members.MembersList; import org.junit.Test; import java.util.HashSet; import java.util.Set; public class MembersInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetList() throws FlickrException { MembersInterface iface = flickr.getMembersInterface(); String id = testProperties.getGroupId(); Set<String> memberTypes = new HashSet<String>(); memberTypes.add(Member.TYPE_MEMBER); memberTypes.add(Member.TYPE_ADMIN); memberTypes.add(Member.TYPE_MODERATOR); MembersList<Member> list = iface.getList(id, memberTypes, 50, 1); assertNotNull(list); assertEquals(50, list.size()); Member m = list.get(10); assertTrue(m.getId().indexOf(""@"") > 0); assertTrue(m.getUserName().length() > 0); assertTrue(m.getIconFarm() > -1); assertTrue(m.getIconServer() > -1); } } ","
 package com.flickr4java.flickr.test;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.groups.members.Member; import com.flickr4java.flickr.groups.members.MembersInterface; import com.flickr4java.flickr.groups.members.MembersList;  import org.junit.Test;  import java.util.HashSet; import java.util.Set;  /**
 * @author mago
 * @version $Id: MembersInterfaceTest.java,v 1.3 2009/07/11 20:30:27 x-mago Exp $
 */ public class MembersInterfaceTest extends Flickr4JavaTest {  @Test
    public void testGetList() throws FlickrException { MembersInterface iface = flickr.getMembersInterface(); // Group: Urban fragments String id = testProperties.getGroupId(); Set<String> memberTypes = new HashSet<String>(); memberTypes.add(Member.TYPE_MEMBER); memberTypes.add(Member.TYPE_ADMIN); memberTypes.add(Member.TYPE_MODERATOR); MembersList<Member> list = iface.getList(id, memberTypes, 50, 1); assertNotNull(list); assertEquals(50, list.size()); Member m = list.get(10); assertTrue(m.getId().indexOf(""@"") > 0); assertTrue(m.getUserName().length() > 0); assertTrue(m.getIconFarm() > -1); assertTrue(m.getIconServer() > -1); } }  "
src/test/java/com/flickr4java/flickr/test/NotesInterfaceTest.java,"/**
 * @author acaplan
 */
package com.flickr4java.flickr.test;

import static org.junit.Assert.fail;

import org.junit.Ignore;
import org.junit.Test;

/**
 * @author acaplan
 * 
 */
public class NotesInterfaceTest extends Flickr4JavaTest {

    /**
     * Test method for {@link com.flickr4java.flickr.photos.notes.NotesInterface#add(java.lang.String, com.flickr4java.flickr.photos.Note)}.
     */
    @Ignore(""Haven't coded this yet"")
    @Test
    public void testAdd() {
        fail(""Not yet implemented"");
    }

    /**
     * Test method for {@link com.flickr4java.flickr.photos.notes.NotesInterface#delete(java.lang.String)}.
     */
    @Ignore(""Haven't coded this yet"")
    @Test
    public void testDelete() {
        fail(""Not yet implemented"");
    }

    /**
     * Test method for {@link com.flickr4java.flickr.photos.notes.NotesInterface#edit(com.flickr4java.flickr.photos.Note)}.
     */
    @Ignore(""Haven't coded this yet"")
    @Test
    public void testEdit() {
        fail(""Not yet implemented"");
    }

}
","package com.flickr4java.flickr.test; import static org.junit.Assert.fail; import org.junit.Ignore; import org.junit.Test; public class NotesInterfaceTest extends Flickr4JavaTest { @Ignore(""Haven't coded this yet"")
    @Test
    public void testAdd() { fail(""Not yet implemented""); } @Ignore(""Haven't coded this yet"")
    @Test
    public void testDelete() { fail(""Not yet implemented""); } @Ignore(""Haven't coded this yet"")
    @Test
    public void testEdit() { fail(""Not yet implemented""); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.fail; import org.junit.Ignore; import org.junit.Test; public class NotesInterfaceTest extends Flickr4JavaTest { @Ignore(""Haven't coded this yet"")
    @Test
    public void testAdd() { fail(""Not yet implemented""); } @Ignore(""Haven't coded this yet"")
    @Test
    public void testDelete() { fail(""Not yet implemented""); } @Ignore(""Haven't coded this yet"")
    @Test
    public void testEdit() { fail(""Not yet implemented""); } } ","/**
 * @author acaplan
 */ package com.flickr4java.flickr.test;  import static org.junit.Assert.fail;  import org.junit.Ignore; import org.junit.Test;  /**
 * @author acaplan
 * 
 */ public class NotesInterfaceTest extends Flickr4JavaTest {  /**
     * Test method for {@link com.flickr4java.flickr.photos.notes.NotesInterface#add(java.lang.String, com.flickr4java.flickr.photos.Note)}.
     */ @Ignore(""Haven't coded this yet"")
    @Test
    public void testAdd() { fail(""Not yet implemented""); }  /**
     * Test method for {@link com.flickr4java.flickr.photos.notes.NotesInterface#delete(java.lang.String)}.
     */ @Ignore(""Haven't coded this yet"")
    @Test
    public void testDelete() { fail(""Not yet implemented""); }  /**
     * Test method for {@link com.flickr4java.flickr.photos.notes.NotesInterface#edit(com.flickr4java.flickr.photos.Note)}.
     */ @Ignore(""Haven't coded this yet"")
    @Test
    public void testEdit() { fail(""Not yet implemented""); }  }  "
src/test/java/com/flickr4java/flickr/test/OAuthUtilitiesTest.java,"package com.flickr4java.flickr.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.junit.Test;

import com.flickr4java.flickr.util.OAuthUtilities;
import com.github.scribejava.apis.FlickrApi;
import com.github.scribejava.core.builder.ServiceBuilder;
import com.github.scribejava.core.model.OAuthRequest;
import com.github.scribejava.core.model.Parameter;
import com.github.scribejava.core.model.Verb;
import com.github.scribejava.core.oauth.OAuth10aService;

public class OAuthUtilitiesTest extends Flickr4JavaTest {

    @Test
    public void testCreateOAuthService() {
        OAuth10aService service = OAuthUtilities.createOAuthService(""foo"", ""bar"", null, null);
        assertEquals(""foo"", service.getApiKey());
        assertEquals(""bar"", service.getApiSecret());

        service = OAuthUtilities.createOAuthService(""foo"", ""bar"", 1, 2);
        assertEquals(""foo"", service.getApiKey());
        assertEquals(""bar"", service.getApiSecret());
    }

    @Test
    public void testSignRequest() {
        // No proxy credentials
        OAuth10aService service = new ServiceBuilder(""foo"").apiSecret(""bar"").build(FlickrApi.instance());
        OAuthRequest request = new OAuthRequest(Verb.GET, ""http://foobar"");
        assertTrue(request.getOauthParameters().isEmpty());
        OAuthUtilities.signRequest(service, request, null);
        assertNull(request.getHeaders().get(""Proxy-Authorization""));

        // proxy credentials
        service = new ServiceBuilder(""foo"").apiSecret(""bar"").build(FlickrApi.instance());
        request = new OAuthRequest(Verb.POST, ""http://foobar"");
        assertTrue(request.getOauthParameters().isEmpty());
        OAuthUtilities.signRequest(service, request, ""creds"");
        assertEquals(""Basic creds"", request.getHeaders().get(""Proxy-Authorization""));
    }

    @Test
    public void testBuildNormalPostRequest() {
        Map<String, String> params = new HashMap<>();
        params.put(""foo"", ""bar"");
        OAuthRequest request = OAuthUtilities.buildNormalPostRequest(params, ""http://foo"");
        List<Parameter> bodyParams = request.getBodyParams().getParams();
        assertEquals(1, bodyParams.size());
        assertEquals(new Parameter(""foo"", ""bar""), bodyParams.get(0));
    }

    @Test
    public void testBuildMultipartRequest() {
        Map<String, String> params = new HashMap<>();
        params.put(""foo"", ""bar"");
        OAuthRequest request = OAuthUtilities.buildMultipartRequest(params, ""http://foo"");
        List<Parameter> queryStringParams = request.getQueryStringParams().getParams();
        assertEquals(1, queryStringParams.size());
        assertEquals(new Parameter(""foo"", ""bar""), queryStringParams.get(0));
        String contentType = request.getHeaders().get(""Content-Type"");
        assertTrue(contentType, contentType.matches(
                ""multipart/form-data; boundary=---------------------------[a-f0-9]{8}(-[a-f0-9]{4}){4}[a-f0-9]{8}""));
    }
}
","package com.flickr4java.flickr.test; public class OAuthUtilitiesTest extends Flickr4JavaTest { @Test
    public void testCreateOAuthService() { OAuth10aService service = OAuthUtilities.createOAuthService(""foo"", ""bar"", null, null); assertEquals(""foo"", service.getApiKey()); assertEquals(""bar"", service.getApiSecret()); service = OAuthUtilities.createOAuthService(""foo"", ""bar"", 1, 2); assertEquals(""foo"", service.getApiKey()); assertEquals(""bar"", service.getApiSecret()); } @Test
    public void testSignRequest() { OAuth10aService service = new ServiceBuilder(""foo"").apiSecret(""bar"").build(FlickrApi.instance()); assertTrue(request.getOauthParameters().isEmpty()); OAuthUtilities.signRequest(service, request, null); assertNull(request.getHeaders().get(""Proxy-Authorization"")); service = new ServiceBuilder(""foo"").apiSecret(""bar"").build(FlickrApi.instance()); assertTrue(request.getOauthParameters().isEmpty()); OAuthUtilities.signRequest(service, request, ""creds""); assertEquals(""Basic creds"", request.getHeaders().get(""Proxy-Authorization"")); } @Test
    public void testBuildNormalPostRequest() { Map<String, String> params = new HashMap<>(); params.put(""foo"", ""bar""); List<Parameter> bodyParams = request.getBodyParams().getParams(); assertEquals(1, bodyParams.size()); assertEquals(new Parameter(""foo"", ""bar""), bodyParams.get(0)); } @Test
    public void testBuildMultipartRequest() { Map<String, String> params = new HashMap<>(); params.put(""foo"", ""bar""); List<Parameter> queryStringParams = request.getQueryStringParams().getParams(); assertEquals(1, queryStringParams.size()); assertEquals(new Parameter(""foo"", ""bar""), queryStringParams.get(0)); String contentType = request.getHeaders().get(""Content-Type""); assertTrue(contentType, contentType.matches(
                ""multipart/form-data; boundary=---------------------------[a-f0-9]{ 8} (-[a-f0-9]{ 4} ){ 4} [a-f0-9]{ 8} "")); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; public class OAuthUtilitiesTest extends Flickr4JavaTest { @Test
    public void testCreateOAuthService() { OAuth10aService service = OAuthUtilities.createOAuthService(""foo"", ""bar"", null, null); assertEquals(""foo"", service.getApiKey()); assertEquals(""bar"", service.getApiSecret()); service = OAuthUtilities.createOAuthService(""foo"", ""bar"", 1, 2); assertEquals(""foo"", service.getApiKey()); assertEquals(""bar"", service.getApiSecret()); } @Test
    public void testSignRequest() { OAuth10aService service = new ServiceBuilder(""foo"").apiSecret(""bar"").build(FlickrApi.instance()); assertTrue(request.getOauthParameters().isEmpty()); OAuthUtilities.signRequest(service, request, null); assertNull(request.getHeaders().get(""Proxy-Authorization"")); service = new ServiceBuilder(""foo"").apiSecret(""bar"").build(FlickrApi.instance()); assertTrue(request.getOauthParameters().isEmpty()); OAuthUtilities.signRequest(service, request, ""creds""); assertEquals(""Basic creds"", request.getHeaders().get(""Proxy-Authorization"")); } @Test
    public void testBuildNormalPostRequest() { Map<String, String> params = new HashMap<>(); params.put(""foo"", ""bar""); List<Parameter> bodyParams = request.getBodyParams().getParams(); assertEquals(1, bodyParams.size()); assertEquals(new Parameter(""foo"", ""bar""), bodyParams.get(0)); } @Test
    public void testBuildMultipartRequest() { Map<String, String> params = new HashMap<>(); params.put(""foo"", ""bar""); List<Parameter> queryStringParams = request.getQueryStringParams().getParams(); assertEquals(1, queryStringParams.size()); assertEquals(new Parameter(""foo"", ""bar""), queryStringParams.get(0)); String contentType = request.getHeaders().get(""Content-Type""); assertTrue(contentType, contentType.matches(
                ""multipart/form-data; boundary=---------------------------[a-f0-9]{ 8} (-[a-f0-9]{ 4} ){ 4} [a-f0-9]{ 8} "")); } } ","package com.flickr4java.flickr.test; 
import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; 
import java.util.HashMap; import java.util.List; import java.util.Map; 
import org.junit.Test; 
import com.flickr4java.flickr.util.OAuthUtilities; import com.github.scribejava.apis.FlickrApi; import com.github.scribejava.core.builder.ServiceBuilder; import com.github.scribejava.core.model.OAuthRequest; import com.github.scribejava.core.model.Parameter; import com.github.scribejava.core.model.Verb; import com.github.scribejava.core.oauth.OAuth10aService;  public class OAuthUtilitiesTest extends Flickr4JavaTest {  @Test
    public void testCreateOAuthService() { OAuth10aService service = OAuthUtilities.createOAuthService(""foo"", ""bar"", null, null); assertEquals(""foo"", service.getApiKey()); assertEquals(""bar"", service.getApiSecret());  service = OAuthUtilities.createOAuthService(""foo"", ""bar"", 1, 2); assertEquals(""foo"", service.getApiKey()); assertEquals(""bar"", service.getApiSecret()); }  @Test
    public void testSignRequest() { // No proxy credentials OAuth10aService service = new ServiceBuilder(""foo"").apiSecret(""bar"").build(FlickrApi.instance()); //foobar""); assertTrue(request.getOauthParameters().isEmpty()); OAuthUtilities.signRequest(service, request, null); assertNull(request.getHeaders().get(""Proxy-Authorization""));  // proxy credentials service = new ServiceBuilder(""foo"").apiSecret(""bar"").build(FlickrApi.instance()); //foobar""); assertTrue(request.getOauthParameters().isEmpty()); OAuthUtilities.signRequest(service, request, ""creds""); assertEquals(""Basic creds"", request.getHeaders().get(""Proxy-Authorization"")); }  @Test
    public void testBuildNormalPostRequest() { Map<String, String> params = new HashMap<>(); params.put(""foo"", ""bar""); //foo""); List<Parameter> bodyParams = request.getBodyParams().getParams(); assertEquals(1, bodyParams.size()); assertEquals(new Parameter(""foo"", ""bar""), bodyParams.get(0)); }  @Test
    public void testBuildMultipartRequest() { Map<String, String> params = new HashMap<>(); params.put(""foo"", ""bar""); //foo""); List<Parameter> queryStringParams = request.getQueryStringParams().getParams(); assertEquals(1, queryStringParams.size()); assertEquals(new Parameter(""foo"", ""bar""), queryStringParams.get(0)); String contentType = request.getHeaders().get(""Content-Type""); assertTrue(contentType, contentType.matches(
                ""multipart/form-data; boundary=---------------------------[a-f0-9]{ 8} (-[a-f0-9]{ 4} ){ 4} [a-f0-9]{ 8} "")); } }  "
src/test/java/com/flickr4java/flickr/test/ObjectTest.java,"package com.flickr4java.flickr.test;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import com.flickr4java.flickr.photos.Photo;

import org.junit.Test;

/**
 * 
 * @author mago
 * @version $Id: ObjectTest.java,v 1.1 2009/07/23 20:41:03 x-mago Exp $
 */
public class ObjectTest {
    /**
     * Testing the equals-implementation.
     * 
     * Don't test every single member, as they are covered in equals() by reflection. Emphasis on the child-objects.
     */
    @Test
    public void testPhoto() {
        Photo p1 = new Photo();
        Photo p2 = new Photo();
        assertTrue(p1.equals(p2));

        p1.setSecret(""secret"");
        assertFalse(p1.equals(p2));
        p2.setSecret(""secret"");
        assertTrue(p1.equals(p2));
    }
}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.photos.Photo; import org.junit.Test; public class ObjectTest { @Test
    public void testPhoto() { Photo p1 = new Photo(); Photo p2 = new Photo(); assertTrue(p1.equals(p2)); p1.setSecret(""secret""); assertFalse(p1.equals(p2)); p2.setSecret(""secret""); assertTrue(p1.equals(p2)); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.photos.Photo; import org.junit.Test; public class ObjectTest { @Test
    public void testPhoto() { Photo p1 = new Photo(); Photo p2 = new Photo(); assertTrue(p1.equals(p2)); p1.setSecret(""secret""); assertFalse(p1.equals(p2)); p2.setSecret(""secret""); assertTrue(p1.equals(p2)); } } ","package com.flickr4java.flickr.test;  import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue;  import com.flickr4java.flickr.photos.Photo;  import org.junit.Test;  /**
 * 
 * @author mago
 * @version $Id: ObjectTest.java,v 1.1 2009/07/23 20:41:03 x-mago Exp $
 */ public class ObjectTest { /**
     * Testing the equals-implementation.
     * 
     * Don't test every single member, as they are covered in equals() by reflection. Emphasis on the child-objects.
     */ @Test
    public void testPhoto() { Photo p1 = new Photo(); Photo p2 = new Photo(); assertTrue(p1.equals(p2));  p1.setSecret(""secret""); assertFalse(p1.equals(p2)); p2.setSecret(""secret""); assertTrue(p1.equals(p2)); } }  "
src/test/java/com/flickr4java/flickr/test/PandaInterfaceTest.java,"

package com.flickr4java.flickr.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.panda.Panda;
import com.flickr4java.flickr.panda.PandaInterface;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoList;

import org.junit.Test;

import java.util.ArrayList;

/**
 * @author mago
 * @version $Id: PandaInterfaceTest.java,v 1.1 2009/06/18 21:56:43 x-mago Exp $
 */
public class PandaInterfaceTest extends Flickr4JavaTest {

    @Test
    public void testGetList() throws FlickrException {
        PandaInterface iface = flickr.getPandaInterface();
        ArrayList<Panda> list = iface.getList();
        assertNotNull(list);
        Panda p = list.get(0);
        assertEquals(""ling ling"", p.getName());
        p = list.get(1);
        assertEquals(""hsing hsing"", p.getName());
        p = list.get(2);
        assertEquals(""wang wang"", p.getName());
    }

    @Test
    public void testGetPhotos() throws FlickrException {
        PandaInterface iface = flickr.getPandaInterface();
        Panda p = new Panda();
        p.setName(""ling ling"");
        PhotoList<Photo> list = iface.getPhotos(p, null, 1, 50);
        assertNotNull(list);
    }
}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.panda.Panda; import com.flickr4java.flickr.panda.PandaInterface; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import org.junit.Test; import java.util.ArrayList; public class PandaInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetList() throws FlickrException { PandaInterface iface = flickr.getPandaInterface(); ArrayList<Panda> list = iface.getList(); assertNotNull(list); Panda p = list.get(0); assertEquals(""ling ling"", p.getName()); p = list.get(1); assertEquals(""hsing hsing"", p.getName()); p = list.get(2); assertEquals(""wang wang"", p.getName()); } @Test
    public void testGetPhotos() throws FlickrException { PandaInterface iface = flickr.getPandaInterface(); Panda p = new Panda(); p.setName(""ling ling""); PhotoList<Photo> list = iface.getPhotos(p, null, 1, 50); assertNotNull(list); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.panda.Panda; import com.flickr4java.flickr.panda.PandaInterface; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import org.junit.Test; import java.util.ArrayList; public class PandaInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetList() throws FlickrException { PandaInterface iface = flickr.getPandaInterface(); ArrayList<Panda> list = iface.getList(); assertNotNull(list); Panda p = list.get(0); assertEquals(""ling ling"", p.getName()); p = list.get(1); assertEquals(""hsing hsing"", p.getName()); p = list.get(2); assertEquals(""wang wang"", p.getName()); } @Test
    public void testGetPhotos() throws FlickrException { PandaInterface iface = flickr.getPandaInterface(); Panda p = new Panda(); p.setName(""ling ling""); PhotoList<Photo> list = iface.getPhotos(p, null, 1, 50); assertNotNull(list); } } ","
 package com.flickr4java.flickr.test;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.panda.Panda; import com.flickr4java.flickr.panda.PandaInterface; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList;  import org.junit.Test;  import java.util.ArrayList;  /**
 * @author mago
 * @version $Id: PandaInterfaceTest.java,v 1.1 2009/06/18 21:56:43 x-mago Exp $
 */ public class PandaInterfaceTest extends Flickr4JavaTest {  @Test
    public void testGetList() throws FlickrException { PandaInterface iface = flickr.getPandaInterface(); ArrayList<Panda> list = iface.getList(); assertNotNull(list); Panda p = list.get(0); assertEquals(""ling ling"", p.getName()); p = list.get(1); assertEquals(""hsing hsing"", p.getName()); p = list.get(2); assertEquals(""wang wang"", p.getName()); }  @Test
    public void testGetPhotos() throws FlickrException { PandaInterface iface = flickr.getPandaInterface(); Panda p = new Panda(); p.setName(""ling ling""); PhotoList<Photo> list = iface.getPhotos(p, null, 1, 50); assertNotNull(list); } }  "
src/test/java/com/flickr4java/flickr/test/PeopleInterfaceTest.java,"

package com.flickr4java.flickr.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.groups.Group;
import com.flickr4java.flickr.groups.GroupList;
import com.flickr4java.flickr.people.PeopleInterface;
import com.flickr4java.flickr.people.PersonTag;
import com.flickr4java.flickr.people.PersonTagList;
import com.flickr4java.flickr.people.User;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoList;

import org.junit.Test;

import java.util.Collection;

/**
 * @author Anthony Eden
 * @version $Id: PeopleInterfaceTest.java,v 1.15 2010/07/12 19:11:30 x-mago Exp $
 */
public class PeopleInterfaceTest extends Flickr4JavaTest {

    @Test
    public void testFindByEmail() throws FlickrException {
        PeopleInterface iface = flickr.getPeopleInterface();
        User person = iface.findByEmail(testProperties.getEmail());
        assertNotNull(person);
        assertEquals(person.getId(), testProperties.getNsid());
        assertEquals(person.getUsername(), testProperties.getUsername());
    }

    @Test
    public void testFindByUsername() throws FlickrException {
        PeopleInterface iface = flickr.getPeopleInterface();
        User person = iface.findByUsername(testProperties.getUsername());
        assertNotNull(person);
        assertEquals(testProperties.getUsername(), person.getUsername());
        assertNotNull(person.getId());
    }

    @Test
    public void testGetInfo() throws FlickrException {
        PeopleInterface iface = flickr.getPeopleInterface();
        User person = iface.getInfo(testProperties.getNsid());
        assertNotNull(person);
        assertEquals(testProperties.getNsid(), person.getId());
        assertEquals(testProperties.getDisplayname(), person.getRealName());
        assertEquals(person.getMobileurl(), String.format(""https://www.flickr.com/photos/%s/"", testProperties.getUsername()));
        assertEquals(person.getPhotosurl(), String.format(""https://www.flickr.com/photos/%s/"", testProperties.getUsername()));
        assertEquals(person.getProfileurl(), String.format(""https://www.flickr.com/people/%s/"", testProperties.getUsername()));
        assertTrue(person.getSecureBuddyIconUrl().startsWith(""https://""));
        assertNotNull(person.getTimeZone());
        assertNotNull(person.getTimeZone().getTimeZoneId());
        assertNotNull(person.getTimeZone().getOffset());
        assertNotNull(person.getTimeZone().getLabel());
    }

    @Test
    public void testGetPublicGroups() throws FlickrException {
        PeopleInterface iface = flickr.getPeopleInterface();
        Collection<Group> groups = iface.getPublicGroups(testProperties.getNsid());
        assertNotNull(groups);
        assertTrue(groups.size() >= 1);
    }

    @Test
    public void testGetPublicPhotos() throws FlickrException {
        PeopleInterface iface = flickr.getPeopleInterface();
        PhotoList<Photo> photos = iface.getPublicPhotos(testProperties.getNsid(), 0, 0);
        assertNotNull(photos);
        assertTrue(photos.size() >= 1);
    }

    @Test
    public void testGetUploadStatus() throws FlickrException {
        PeopleInterface iface = flickr.getPeopleInterface();
        User usr = iface.getUploadStatus();
        assertNotNull(usr);
        assertTrue(usr.getBandwidthMax() > 0);

    }

    @Test
    public void testGetPhotos() throws FlickrException {
        PeopleInterface iface = flickr.getPeopleInterface();
        PhotoList<Photo> photos = iface.getPhotos(testProperties.getNsid(), null, null, null, null, null, null, null, null, 15, 1);
        assertNotNull(photos);
        assertTrue(photos.size() > 0);
    }

    @Test
    public void testGetPhotosOf() throws FlickrException {
        PeopleInterface iface = flickr.getPeopleInterface();
        PhotoList<Photo> photos = iface.getPhotosOf(testProperties.getNsid(), null, null, 10, 1);
        assertNotNull(photos);
        assertTrue(photos.size() > 0);
    }

    @Test
    public void testAddDelete() throws FlickrException {
        PeopleInterface iface = flickr.getPeopleInterface();
        PersonTagList<PersonTag> usrs = iface.getList(testProperties.getPhotoId());
        int size = usrs.size();
        try {
            iface.add(testProperties.getPhotoId(), testProperties.getNsid(), null);
        } finally {
            iface.delete(testProperties.getPhotoId(), testProperties.getNsid());
            usrs = iface.getList(testProperties.getPhotoId());
            assertNotNull(usrs);
            assertEquals(size, usrs.size());
        }
    }

    @Test
    public void testGetGroups() throws FlickrException {
        PeopleInterface iface = flickr.getPeopleInterface();
        GroupList<Group> g = iface.getGroups(testProperties.getNsid());
        assertNotNull(g);
    }
}
","package com.flickr4java.flickr.test; public class PeopleInterfaceTest extends Flickr4JavaTest { @Test
    public void testFindByEmail() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); User person = iface.findByEmail(testProperties.getEmail()); assertNotNull(person); assertEquals(person.getId(), testProperties.getNsid()); assertEquals(person.getUsername(), testProperties.getUsername()); } @Test
    public void testFindByUsername() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); User person = iface.findByUsername(testProperties.getUsername()); assertNotNull(person); assertEquals(testProperties.getUsername(), person.getUsername()); assertNotNull(person.getId()); } @Test
    public void testGetInfo() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); User person = iface.getInfo(testProperties.getNsid()); assertNotNull(person); assertEquals(testProperties.getNsid(), person.getId()); assertEquals(testProperties.getDisplayname(), person.getRealName()); assertNotNull(person.getTimeZone()); assertNotNull(person.getTimeZone().getTimeZoneId()); assertNotNull(person.getTimeZone().getOffset()); assertNotNull(person.getTimeZone().getLabel()); } @Test
    public void testGetPublicGroups() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); Collection<Group> groups = iface.getPublicGroups(testProperties.getNsid()); assertNotNull(groups); assertTrue(groups.size() >= 1); } @Test
    public void testGetPublicPhotos() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); PhotoList<Photo> photos = iface.getPublicPhotos(testProperties.getNsid(), 0, 0); assertNotNull(photos); assertTrue(photos.size() >= 1); } @Test
    public void testGetUploadStatus() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); User usr = iface.getUploadStatus(); assertNotNull(usr); assertTrue(usr.getBandwidthMax() > 0); } @Test
    public void testGetPhotos() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); PhotoList<Photo> photos = iface.getPhotos(testProperties.getNsid(), null, null, null, null, null, null, null, null, 15, 1); assertNotNull(photos); assertTrue(photos.size() > 0); } @Test
    public void testGetPhotosOf() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); PhotoList<Photo> photos = iface.getPhotosOf(testProperties.getNsid(), null, null, 10, 1); assertNotNull(photos); assertTrue(photos.size() > 0); } @Test
    public void testAddDelete() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); PersonTagList<PersonTag> usrs = iface.getList(testProperties.getPhotoId()); int size = usrs.size(); try { iface.add(testProperties.getPhotoId(), testProperties.getNsid(), null); } finally { iface.delete(testProperties.getPhotoId(), testProperties.getNsid()); usrs = iface.getList(testProperties.getPhotoId()); assertNotNull(usrs); assertEquals(size, usrs.size()); } } @Test
    public void testGetGroups() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); GroupList<Group> g = iface.getGroups(testProperties.getNsid()); assertNotNull(g); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; public class PeopleInterfaceTest extends Flickr4JavaTest { @Test
    public void testFindByEmail() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); User person = iface.findByEmail(testProperties.getEmail()); assertNotNull(person); assertEquals(person.getId(), testProperties.getNsid()); assertEquals(person.getUsername(), testProperties.getUsername()); } @Test
    public void testFindByUsername() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); User person = iface.findByUsername(testProperties.getUsername()); assertNotNull(person); assertEquals(testProperties.getUsername(), person.getUsername()); assertNotNull(person.getId()); } @Test
    public void testGetInfo() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); User person = iface.getInfo(testProperties.getNsid()); assertNotNull(person); assertEquals(testProperties.getNsid(), person.getId()); assertEquals(testProperties.getDisplayname(), person.getRealName()); assertNotNull(person.getTimeZone()); assertNotNull(person.getTimeZone().getTimeZoneId()); assertNotNull(person.getTimeZone().getOffset()); assertNotNull(person.getTimeZone().getLabel()); } @Test
    public void testGetPublicGroups() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); Collection<Group> groups = iface.getPublicGroups(testProperties.getNsid()); assertNotNull(groups); assertTrue(groups.size() >= 1); } @Test
    public void testGetPublicPhotos() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); PhotoList<Photo> photos = iface.getPublicPhotos(testProperties.getNsid(), 0, 0); assertNotNull(photos); assertTrue(photos.size() >= 1); } @Test
    public void testGetUploadStatus() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); User usr = iface.getUploadStatus(); assertNotNull(usr); assertTrue(usr.getBandwidthMax() > 0); } @Test
    public void testGetPhotos() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); PhotoList<Photo> photos = iface.getPhotos(testProperties.getNsid(), null, null, null, null, null, null, null, null, 15, 1); assertNotNull(photos); assertTrue(photos.size() > 0); } @Test
    public void testGetPhotosOf() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); PhotoList<Photo> photos = iface.getPhotosOf(testProperties.getNsid(), null, null, 10, 1); assertNotNull(photos); assertTrue(photos.size() > 0); } @Test
    public void testAddDelete() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); PersonTagList<PersonTag> usrs = iface.getList(testProperties.getPhotoId()); int size = usrs.size(); try { iface.add(testProperties.getPhotoId(), testProperties.getNsid(), null); } finally { iface.delete(testProperties.getPhotoId(), testProperties.getNsid()); usrs = iface.getList(testProperties.getPhotoId()); assertNotNull(usrs); assertEquals(size, usrs.size()); } } @Test
    public void testGetGroups() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); GroupList<Group> g = iface.getGroups(testProperties.getNsid()); assertNotNull(g); } } ","
 package com.flickr4java.flickr.test;  
import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; 
import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.groups.Group; import com.flickr4java.flickr.groups.GroupList; import com.flickr4java.flickr.people.PeopleInterface; import com.flickr4java.flickr.people.PersonTag; import com.flickr4java.flickr.people.PersonTagList; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; 
import org.junit.Test; 
import java.util.Collection;  public class PeopleInterfaceTest extends Flickr4JavaTest { /**
 * @author Anthony Eden
 * @version $Id: PeopleInterfaceTest.java,v 1.15 2010/07/12 19:11:30 x-mago Exp $
 */ @Test
    public void testFindByEmail() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); User person = iface.findByEmail(testProperties.getEmail()); assertNotNull(person); assertEquals(person.getId(), testProperties.getNsid()); assertEquals(person.getUsername(), testProperties.getUsername()); }  @Test
    public void testFindByUsername() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); User person = iface.findByUsername(testProperties.getUsername()); assertNotNull(person); assertEquals(testProperties.getUsername(), person.getUsername()); assertNotNull(person.getId()); }  @Test
    public void testGetInfo() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); User person = iface.getInfo(testProperties.getNsid()); assertNotNull(person); assertEquals(testProperties.getNsid(), person.getId()); assertEquals(testProperties.getDisplayname(), person.getRealName());  //www.flickr.com/photos/%s/"", testProperties.getUsername())); //www.flickr.com/photos/%s/"", testProperties.getUsername())); //www.flickr.com/people/%s/"", testProperties.getUsername())); assertNotNull(person.getTimeZone()); assertNotNull(person.getTimeZone().getTimeZoneId()); assertNotNull(person.getTimeZone().getOffset()); assertNotNull(person.getTimeZone().getLabel()); } //"")); @Test
    public void testGetPublicGroups() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); Collection<Group> groups = iface.getPublicGroups(testProperties.getNsid()); assertNotNull(groups); assertTrue(groups.size() >= 1); }  @Test
    public void testGetPublicPhotos() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); PhotoList<Photo> photos = iface.getPublicPhotos(testProperties.getNsid(), 0, 0); assertNotNull(photos); assertTrue(photos.size() >= 1); }  @Test
    public void testGetUploadStatus() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); User usr = iface.getUploadStatus(); assertNotNull(usr); assertTrue(usr.getBandwidthMax() > 0);  }  @Test
    public void testGetPhotos() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); PhotoList<Photo> photos = iface.getPhotos(testProperties.getNsid(), null, null, null, null, null, null, null, null, 15, 1); assertNotNull(photos); assertTrue(photos.size() > 0); }  @Test
    public void testGetPhotosOf() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); PhotoList<Photo> photos = iface.getPhotosOf(testProperties.getNsid(), null, null, 10, 1); assertNotNull(photos); assertTrue(photos.size() > 0); }  @Test
    public void testAddDelete() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); PersonTagList<PersonTag> usrs = iface.getList(testProperties.getPhotoId()); int size = usrs.size(); try { iface.add(testProperties.getPhotoId(), testProperties.getNsid(), null); } finally { iface.delete(testProperties.getPhotoId(), testProperties.getNsid()); usrs = iface.getList(testProperties.getPhotoId()); assertNotNull(usrs); assertEquals(size, usrs.size()); } }  @Test
    public void testGetGroups() throws FlickrException { PeopleInterface iface = flickr.getPeopleInterface(); GroupList<Group> g = iface.getGroups(testProperties.getNsid()); assertNotNull(g); } }  "
src/test/java/com/flickr4java/flickr/test/PhotosInterfaceTest.java,"

package com.flickr4java.flickr.test;

import com.flickr4java.flickr.Flickr;
import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.people.User;
import com.flickr4java.flickr.photos.Exif;
import com.flickr4java.flickr.photos.Permissions;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoContext;
import com.flickr4java.flickr.photos.PhotoList;
import com.flickr4java.flickr.photos.Photocount;
import com.flickr4java.flickr.photos.PhotosInterface;
import com.flickr4java.flickr.photos.SearchParameters;
import com.flickr4java.flickr.photos.Size;
import com.flickr4java.flickr.tags.Tag;
import org.junit.After;
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.util.*;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

/**
 * @author Anthony Eden
 * @version $Id: PhotosInterfaceTest.java,v 1.20 2009/07/23 21:49:35 x-mago Exp $
 */
public class PhotosInterfaceTest extends Flickr4JavaTest {

    private final File largeFile = new File(""out.large.jpg"");

    private final File mediumFile = new File(""out.medium.jpg"");

    private final File smallFile = new File(""out.small.jpg"");

    private final File smallSquareFile = new File(""out.smallsquare.jpg"");

    private final File thumbnailFile = new File(""out.thumbnail.jpg"");
    
    private List<Size> photoSizes;

    @Override
    public void setUp() throws FlickrException {
        super.setUp();
        preparePhotoSizes();
    }

    @After
    public void teardown() {

        largeFile.deleteOnExit();
        mediumFile.deleteOnExit();
        smallFile.deleteOnExit();
        smallSquareFile.deleteOnExit();
        thumbnailFile.deleteOnExit();
    }
    
    private void preparePhotoSizes() {
        photoSizes = new ArrayList<Size>();
        Size size = new Size();
        size.setLabel(""Thumbnail"");
        size.setWidth(""100"");
        size.setHeight(""75"");
        size.setSource(""urlThumb"");
        size.setUrl(""urlThumbPage"");
        photoSizes.add(size);
        size = new Size();
        size.setLabel(""Square"");
        size.setWidth(""75"");
        size.setHeight(""75"");
        size.setSource(""urlSquare"");
        size.setUrl(""urlSquarePage"");
        photoSizes.add(size);
        size = new Size();
        size.setLabel(""Small"");
        size.setWidth(""240"");
        size.setHeight(""180"");
        size.setSource(""urlSmall"");
        size.setUrl(""urlSmallPage"");
        photoSizes.add(size);
        size = new Size();
        size.setLabel(""Medium"");
        size.setWidth(""240"");
        size.setHeight(""180"");
        size.setSource(""urlMedium"");
        size.setUrl(""urlMediumPage"");
        photoSizes.add(size);
        size = new Size();
        size.setLabel(""Original"");
        size.setWidth(""240"");
        size.setHeight(""180"");
        size.setSource(""urlOriginal"");
        size.setUrl(""urlOriginalPage"");
        photoSizes.add(size);
        size = new Size();
        size.setLabel(""Large"");
        size.setWidth(""240"");
        size.setHeight(""180"");
        size.setSource(""urlLarge"");
        size.setUrl(""urlLargePage"");
        photoSizes.add(size);
        size = new Size();
        size.setLabel(""Large Square"");
        size.setWidth(""150"");
        size.setHeight(""150"");
        size.setSource(""urlSquareLarge"");
        size.setUrl(""urlSquareLargePage"");
        photoSizes.add(size);
        size = new Size();
        size.setLabel(""Small 320"");
        size.setWidth(""320"");
        size.setHeight(""240"");
        size.setSource(""urlSmall320"");
        size.setUrl(""urlSmall320Page"");
        photoSizes.add(size);
        size = new Size();
        size.setLabel(""Medium 640"");
        size.setWidth(""640"");
        size.setHeight(""320"");
        size.setSource(""urlMedium640"");
        size.setUrl(""urlMedium640Page"");
        photoSizes.add(size);
        size = new Size();
        size.setLabel(""Medium 800"");
        size.setWidth(""800"");
        size.setHeight(""500"");
        size.setSource(""urlMedium800"");
        size.setUrl(""urlMedium800Page"");
        photoSizes.add(size);
        size = new Size();
        size.setLabel(""Large 1600"");
        size.setWidth(""1600"");
        size.setHeight(""1024"");
        size.setSource(""urlLarge1600"");
        size.setUrl(""urlLarge1600Page"");
        photoSizes.add(size);
        size = new Size();
        size.setLabel(""Large 2048"");
        size.setWidth(""2048"");
        size.setHeight(""1600"");
        size.setSource(""urlLarge2048"");
        size.setUrl(""urlLarge2048Page"");
        photoSizes.add(size);
        size = new Size();
        size.setLabel(""Video Player"");
        size.setWidth(""320"");
        size.setHeight(""240"");
        size.setSource(""urlVideoPlayer"");
        size.setUrl(""urlVideoPlayerPage"");
        photoSizes.add(size);
        size = new Size();
        size.setLabel(""Site MP4"");
        size.setWidth(""320"");
        size.setHeight(""240"");
        size.setSource(""urlSiteMP4"");
        size.setUrl(""urlSiteMP4Page"");
        photoSizes.add(size);
        size = new Size();
        size.setLabel(""Video Original"");
        size.setWidth(""960"");
        size.setHeight(""720"");
        size.setSource(""urlVideoOriginal"");
        size.setUrl(""urlVideoOriginalPage"");
        photoSizes.add(size);
        size = new Size();
        size.setLabel(""Mobile MP4"");
        size.setWidth(""640"");
        size.setHeight(""360"");
        size.setSource(""urlMobileMP4"");
        size.setUrl(""urlMobileMP4Page"");
        photoSizes.add(size);
        size = new Size();
        size.setLabel(""HD MP4"");
        size.setWidth(""1280"");
        size.setHeight(""720"");
        size.setSource(""urlHDMP4"");
        size.setUrl(""urlHDMP4Page"");
        photoSizes.add(size);
    }

    @Test
    public void testAddAndRemoveTags() throws FlickrException {
        PhotosInterface iface = flickr.getPhotosInterface();
        String photoId = testProperties.getPhotoId();
        Photo photo = iface.getInfo(photoId, null);

        // Find number of existing tags
        int preCount = photo.getTags().size();

        // Add a tag
        String[] tagsToAdd = { ""test"" };
        iface.addTags(photoId, tagsToAdd);

        // Check that it was added
        photo = iface.getInfo(photoId, null);
        Collection<Tag> tags = photo.getTags();
        assertNotNull(tags);

        // Get the added tag's ID
        String tagId = null;
        for (Tag tag : tags) {
            if (tag.getValue().equals(""test"")) {
                tagId = tag.getId();
                break;
            }
        }

        // Remove and check that it was removed
        iface.removeTag(tagId);
        photo = iface.getInfo(photoId, null);
        tags = photo.getTags();
        assertNotNull(tags);
        assertEquals(preCount, tags.size());
    }

    @Test
    public void testGetInfo() throws FlickrException {
        PhotosInterface iface = flickr.getPhotosInterface();
        Photo photo = iface.getInfo(testProperties.getPhotoId(), null);
        assertNotNull(photo);
        assertNotNull(photo.getUrl());
        assertNotNull(photo.getTitle());
        assertNotNull(photo.getTitle());
        assertEquals(testProperties.getPhotoId(), photo.getId());
        assertNotNull(photo.getSecret());
        assertNotNull(photo.getServer());
        assertNotNull(photo.getFarm());
        assertEquals(""0"", photo.getLicense());
        assertEquals(""jpg"", photo.getOriginalFormat());
        // no pro, no original :-(
        assertEquals("""", photo.getIconServer());
        assertEquals("""", photo.getIconFarm());
        assertFalse(photo.isFavorite());
        // assertTrue(photo.getViews() > -1);

        User owner = photo.getOwner();
        assertEquals(testProperties.getNsid(), owner.getId());
        assertEquals(testProperties.getUsername(), owner.getUsername());

        List<Tag> tags = (List<Tag>) photo.getTags();
        assertEquals(""green"", (tags.get(0)).getValue());
        assertEquals(""grn"", (tags.get(1)).getValue());
    }

    @Test
    public void testGetContactsPhotos() throws FlickrException {
        PhotosInterface iface = flickr.getPhotosInterface();
        PhotoList<Photo> photos = iface.getContactsPhotos(0, false, false, false);
        assertNotNull(photos);
        assertTrue(photos.size() > 0);
    }

    @Test
    public void testGetContactsPublicPhotos() throws FlickrException {
        PhotosInterface iface = flickr.getPhotosInterface();
        PhotoList<Photo> photos = iface.getContactsPublicPhotos(testProperties.getNsid(), 0, false, false, false);
        assertNotNull(photos);
        assertTrue(photos.size() > 0);
    }

    @Test
    public void testGetContext() throws FlickrException {
        PhotosInterface iface = flickr.getPhotosInterface();
        PhotoContext photoContext = iface.getContext(testProperties.getPhotoId());
        assertNotNull(photoContext);
    }

    @Test
    public void testGetCounts() throws FlickrException {
        PhotosInterface iface = flickr.getPhotosInterface();
        Date[] dates = new Date[2];
        dates[0] = new Date(100000);
        dates[1] = new Date(); // now
        Collection<Photocount> counts = iface.getCounts(dates, null);
        assertNotNull(counts);

        for (Photocount photocount : counts) {
            assertNotNull(photocount);
        }
    }

    @Test
    public void testGetExif() throws FlickrException {
        PhotosInterface iface = flickr.getPhotosInterface();
        Collection<Exif> exifs = iface.getExif(testProperties.getPhotoId(), null);
        assertNotNull(exifs);
    }

    @Test
    public void testGetNotInSet() throws FlickrException {
        PhotosInterface iface = flickr.getPhotosInterface();
        PhotoList<Photo> photos = iface.getNotInSet(-1, -1);
        assertNotNull(photos);
    }

    @Test
    public void testGetPerms() throws FlickrException {
        PhotosInterface iface = flickr.getPhotosInterface();
        Permissions perms = iface.getPerms(testProperties.getPhotoId());
        assertNotNull(perms);
    }

    @Test
    public void testGetRecent() throws FlickrException {
        PhotosInterface iface = flickr.getPhotosInterface();
        Set<String> extras = new HashSet<String>();
        PhotoList<Photo> photos = iface.getRecent(extras, 0, 0);
        assertNotNull(photos);
    }

    @Test
    public void testGetSizes() throws FlickrException {
        PhotosInterface iface = flickr.getPhotosInterface();
        Collection<Size> sizes = iface.getSizes(testProperties.getPhotoId());
        assertNotNull(sizes);

        sizes.forEach(size -> assertNotNull(size.getLabelName()));
        Optional<Size> original = sizes.stream().filter(size -> size.getLabelName().equals(""Original"")).findFirst();
        assertTrue(original.isPresent());
    }

    @Test
    public void testGetUntagged() throws FlickrException {
        PhotosInterface iface = flickr.getPhotosInterface();
        PhotoList<Photo> photos = iface.getUntagged(0, 0);
        assertNotNull(photos);
    }

    @Test
    public void testSearch() throws FlickrException {
        PhotosInterface iface = flickr.getPhotosInterface();
        SearchParameters searchParams = new SearchParameters();
        searchParams.setUserId(testProperties.getNsid());
        PhotoList<Photo> photos = iface.search(searchParams, 33, 0);
        assertNotNull(photos);
        assertEquals(1, photos.getPage());
        assertTrue(photos.getPages() >= 1);
        assertTrue(photos.getPerPage() >= 1);
        assertTrue(photos.getTotal() >= 1);
    }

    @Test
    public void testBoundingBoxSearch() throws FlickrException {
        PhotosInterface iface = flickr.getPhotosInterface();
        SearchParameters searchParameters = new SearchParameters();
        searchParameters.setBBox(""-122.9"", ""45.0"", ""-122.0"", ""45.9"");
        PhotoList<Photo> photos = iface.search(searchParameters, -1, -1);
        assertNotNull(photos);
    }

    @Test
    public void testRadialGeoSearch() throws FlickrException {
        PhotosInterface iface = flickr.getPhotosInterface();
        SearchParameters searchParameters = new SearchParameters();
        searchParameters.setLatitude(""45.521694"");
        searchParameters.setLongitude(""-122.691806"");
        searchParameters.setRadius(2);
        searchParameters.setRadiusUnits(""km"");
        PhotoList<Photo> photos = iface.search(searchParameters, -1, -1);
        assertNotNull(photos);
    }

    @Test
    public void testTagSearch() throws FlickrException {
        PhotosInterface iface = flickr.getPhotosInterface();
        SearchParameters searchParameters = new SearchParameters();
        String[] tags = { ""flowers"" };
        searchParameters.setTags(tags);
        PhotoList<Photo> photos = iface.search(searchParameters, -1, -1);
        assertNotNull(photos);
    }

    @Test
    public void testSetContentType() throws FlickrException {
        PhotosInterface iface = flickr.getPhotosInterface();
        iface.setContentType(testProperties.getPhotoId(), Flickr.CONTENTTYPE_PHOTO);
    }

    @Test
    public void testSetDates() {

    }

    @Test
    public void testSetMeta() throws FlickrException {
        String newTitle = ""New Title"";
        PhotosInterface iface = flickr.getPhotosInterface();
        Photo photo = iface.getInfo(testProperties.getPhotoId(), null);
        String oldTitle = photo.getTitle();
        photo.setTitle(newTitle);
        iface.setMeta(photo.getId(), photo.getTitle(), null);
        iface.setMeta(photo.getId(), oldTitle, ""Description"");
    }

    @Test
    public void testSetSafetyLevel() throws FlickrException {
        PhotosInterface iface = flickr.getPhotosInterface();
        iface.setSafetyLevel(testProperties.getPhotoId(), Flickr.SAFETYLEVEL_SAFE, new Boolean(false));
    }

    @Test
    public void testSetTags() throws FlickrException {
        PhotosInterface iface = flickr.getPhotosInterface();
        String photoId = testProperties.getPhotoId();

        String[] tagsAfterRemove = {};
        iface.setTags(photoId, tagsAfterRemove);

        String[] tagsToAdd = { ""green"", ""grn"", ""grngrn"" };
        iface.setTags(photoId, tagsToAdd);

        Photo photo = iface.getInfo(photoId, null);
        Collection<Tag> tags = photo.getTags();
        assertNotNull(tags);
        assertEquals(3, tags.size());

        // String tagId = null;
        // Iterator tagsIter = tags.iterator();
        // TAG_LOOP: while (tagsIter.hasNext()) {
        // Tag tag = (Tag) tagsIter.next();
        // if (tag.getValue().equals(""test"")) {
        // tagId = tag.getId();
        // break TAG_LOOP;
        // }
        // }

    }

    @Test
    public void testGetSmallImage() throws FlickrException, IOException {
        PhotosInterface iface = flickr.getPhotosInterface();
        String photoId = testProperties.getPhotoId();
        Photo photo = iface.getInfo(photoId, null);
        assertNotNull(photo);
        assertEquals(photoId, photo.getId());
    }

    @Test
    public void testGetThumbnailImage() throws FlickrException, IOException {
        PhotosInterface iface = flickr.getPhotosInterface();
        String photoId = testProperties.getPhotoId();
        Photo photo = iface.getInfo(photoId, null);
        assertNotNull(photo);
        assertEquals(photoId, photo.getId());
    }

    @Test
    public void testGetSmallSquareImage() throws FlickrException, IOException {
        PhotosInterface iface = flickr.getPhotosInterface();
        String photoId = testProperties.getPhotoId();
        Photo photo = iface.getInfo(photoId, null);
        assertNotNull(photo);
        assertEquals(photoId, photo.getId());
    }

    @Test
    public void testGetMediumImage() throws FlickrException, IOException {
        PhotosInterface iface = flickr.getPhotosInterface();
        String photoId = testProperties.getPhotoId();
        Photo photo = iface.getInfo(photoId, null);
        assertNotNull(photo);
        assertEquals(photoId, photo.getId());
    }

    @Test
    public void testGetLargeImage() throws FlickrException, IOException {
        PhotosInterface iface = flickr.getPhotosInterface();
        String photoId = testProperties.getPhotoId();
        Photo photo = iface.getInfo(photoId, null);
        assertNotNull(photo);
        assertEquals(photoId, photo.getId());
    }

    @Test
    public void testGetPhoto() throws FlickrException {
        PhotosInterface iface = flickr.getPhotosInterface();
        String photoId = testProperties.getPhotoId();
        Photo photo = iface.getPhoto(photoId, null);
        assertNotNull(photo);
    }

    /**
     * Testing the generation of URLs and the overriding by setSizes().
     */
    @Test
    public void testSetSizes() {
        Photo p = new Photo();
        p.setId(""id"");
        p.setServer(""server"");
        p.setSecret(""secret"");
        p.setOriginalSecret(""osecret"");
        p.setFarm(""1"");

        assertEquals(""https://farm1.staticflickr.com/server/id_secret_m.jpg"", p.getSmallUrl());
        assertEquals(""https://farm1.staticflickr.com/server/id_secret_s.jpg"", p.getSmallSquareUrl());
        assertEquals(""https://farm1.staticflickr.com/server/id_secret_t.jpg"", p.getThumbnailUrl());
        assertEquals(""https://farm1.staticflickr.com/server/id_secret.jpg"", p.getMediumUrl());
        assertEquals(""https://farm1.staticflickr.com/server/id_secret_b.jpg"", p.getLargeUrl());
        assertEquals(""https://farm1.staticflickr.com/server/id_secret_q.jpg"", p.getSquareLargeUrl());
        assertEquals(""https://farm1.staticflickr.com/server/id_secret_n.jpg"", p.getSmall320Url());
        assertEquals(""https://farm1.staticflickr.com/server/id_secret_z.jpg"", p.getMedium640Url());
        assertEquals(""https://farm1.staticflickr.com/server/id_secret_c.jpg"", p.getMedium800Url());
        assertEquals(""https://farm1.staticflickr.com/server/id_secret_h.jpg"", p.getLarge1600Url());
        assertEquals(""https://farm1.staticflickr.com/server/id_secret_k.jpg"", p.getLarge2048Url());
        try {
            assertEquals(""https://farm1.staticflickr.com/server/id_osecret_o.jpg"", p.getOriginalUrl());
        } catch (FlickrException ex) {
        }
        // setSizes() to override the generated URLs.
        p.setSizes(photoSizes);
        assertEquals(""urlSmall"", p.getSmallUrl());
        assertEquals(""urlSquare"", p.getSmallSquareUrl());
        assertEquals(""urlThumb"", p.getThumbnailUrl());
        assertEquals(""urlMedium"", p.getMediumUrl());
        assertEquals(""urlLarge"", p.getLargeUrl());
        assertEquals(""urlSquareLarge"", p.getSquareLargeUrl());
        assertEquals(""urlSmall320"", p.getSmall320Url());
        assertEquals(""urlMedium640"", p.getMedium640Url());
        assertEquals(""urlMedium800"", p.getMedium800Url());
        assertEquals(""urlLarge1600"", p.getLarge1600Url());
        assertEquals(""urlLarge2048"", p.getLarge2048Url());
        assertEquals(""urlVideoPlayer"", p.getVideoPlayerUrl());
        assertEquals(""urlSiteMP4"", p.getSiteMP4Url());
        assertEquals(""urlVideoOriginal"", p.getVideoOriginalUrl());
        try {
            assertEquals(""urlOriginal"", p.getOriginalUrl());
        } catch (FlickrException ex) {
        }
    }
    
    @Test
    public void testGetAllSizes() {
        Photo p = new Photo();
        p.setSizes(photoSizes);
        
        List<Size> pSizes = new ArrayList<Size>(p.getSizes());
        
        for(Size s: pSizes) {
            assertNotNull(s);
        }
    }
}
","package com.flickr4java.flickr.test; public class PhotosInterfaceTest extends Flickr4JavaTest { private final File largeFile = new File(""out.large.jpg""); private final File mediumFile = new File(""out.medium.jpg""); private final File smallFile = new File(""out.small.jpg""); private final File smallSquareFile = new File(""out.smallsquare.jpg""); private final File thumbnailFile = new File(""out.thumbnail.jpg""); private List<Size> photoSizes; @Override
    public void setUp() throws FlickrException { super.setUp(); preparePhotoSizes(); } @After
    public void teardown() { largeFile.deleteOnExit(); mediumFile.deleteOnExit(); smallFile.deleteOnExit(); smallSquareFile.deleteOnExit(); thumbnailFile.deleteOnExit(); } private void preparePhotoSizes() { photoSizes = new ArrayList<Size>(); Size size = new Size(); size.setLabel(""Thumbnail""); size.setWidth(""100""); size.setHeight(""75""); size.setSource(""urlThumb""); size.setUrl(""urlThumbPage""); photoSizes.add(size); size = new Size(); size.setLabel(""Square""); size.setWidth(""75""); size.setHeight(""75""); size.setSource(""urlSquare""); size.setUrl(""urlSquarePage""); photoSizes.add(size); size = new Size(); size.setLabel(""Small""); size.setWidth(""240""); size.setHeight(""180""); size.setSource(""urlSmall""); size.setUrl(""urlSmallPage""); photoSizes.add(size); size = new Size(); size.setLabel(""Medium""); size.setWidth(""240""); size.setHeight(""180""); size.setSource(""urlMedium""); size.setUrl(""urlMediumPage""); photoSizes.add(size); size = new Size(); size.setLabel(""Original""); size.setWidth(""240""); size.setHeight(""180""); size.setSource(""urlOriginal""); size.setUrl(""urlOriginalPage""); photoSizes.add(size); size = new Size(); size.setLabel(""Large""); size.setWidth(""240""); size.setHeight(""180""); size.setSource(""urlLarge""); size.setUrl(""urlLargePage""); photoSizes.add(size); size = new Size(); size.setLabel(""Large Square""); size.setWidth(""150""); size.setHeight(""150""); size.setSource(""urlSquareLarge""); size.setUrl(""urlSquareLargePage""); photoSizes.add(size); size = new Size(); size.setLabel(""Small 320""); size.setWidth(""320""); size.setHeight(""240""); size.setSource(""urlSmall320""); size.setUrl(""urlSmall320Page""); photoSizes.add(size); size = new Size(); size.setLabel(""Medium 640""); size.setWidth(""640""); size.setHeight(""320""); size.setSource(""urlMedium640""); size.setUrl(""urlMedium640Page""); photoSizes.add(size); size = new Size(); size.setLabel(""Medium 800""); size.setWidth(""800""); size.setHeight(""500""); size.setSource(""urlMedium800""); size.setUrl(""urlMedium800Page""); photoSizes.add(size); size = new Size(); size.setLabel(""Large 1600""); size.setWidth(""1600""); size.setHeight(""1024""); size.setSource(""urlLarge1600""); size.setUrl(""urlLarge1600Page""); photoSizes.add(size); size = new Size(); size.setLabel(""Large 2048""); size.setWidth(""2048""); size.setHeight(""1600""); size.setSource(""urlLarge2048""); size.setUrl(""urlLarge2048Page""); photoSizes.add(size); size = new Size(); size.setLabel(""Video Player""); size.setWidth(""320""); size.setHeight(""240""); size.setSource(""urlVideoPlayer""); size.setUrl(""urlVideoPlayerPage""); photoSizes.add(size); size = new Size(); size.setLabel(""Site MP4""); size.setWidth(""320""); size.setHeight(""240""); size.setSource(""urlSiteMP4""); size.setUrl(""urlSiteMP4Page""); photoSizes.add(size); size = new Size(); size.setLabel(""Video Original""); size.setWidth(""960""); size.setHeight(""720""); size.setSource(""urlVideoOriginal""); size.setUrl(""urlVideoOriginalPage""); photoSizes.add(size); size = new Size(); size.setLabel(""Mobile MP4""); size.setWidth(""640""); size.setHeight(""360""); size.setSource(""urlMobileMP4""); size.setUrl(""urlMobileMP4Page""); photoSizes.add(size); size = new Size(); size.setLabel(""HD MP4""); size.setWidth(""1280""); size.setHeight(""720""); size.setSource(""urlHDMP4""); size.setUrl(""urlHDMP4Page""); photoSizes.add(size); } @Test
    public void testAddAndRemoveTags() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); String photoId = testProperties.getPhotoId(); Photo photo = iface.getInfo(photoId, null); int preCount = photo.getTags().size(); String[] tagsToAdd = { ""test"" } ; iface.addTags(photoId, tagsToAdd); photo = iface.getInfo(photoId, null); Collection<Tag> tags = photo.getTags(); assertNotNull(tags); String tagId = null; for (Tag tag : tags) { if (tag.getValue().equals(""test"")) { tagId = tag.getId(); break; } } iface.removeTag(tagId); photo = iface.getInfo(photoId, null); tags = photo.getTags(); assertNotNull(tags); assertEquals(preCount, tags.size()); } @Test
    public void testGetInfo() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); Photo photo = iface.getInfo(testProperties.getPhotoId(), null); assertNotNull(photo); assertNotNull(photo.getUrl()); assertNotNull(photo.getTitle()); assertNotNull(photo.getTitle()); assertEquals(testProperties.getPhotoId(), photo.getId()); assertNotNull(photo.getSecret()); assertNotNull(photo.getServer()); assertNotNull(photo.getFarm()); assertEquals(""0"", photo.getLicense()); assertEquals(""jpg"", photo.getOriginalFormat()); assertEquals("""", photo.getIconServer()); assertEquals("""", photo.getIconFarm()); assertFalse(photo.isFavorite()); User owner = photo.getOwner(); assertEquals(testProperties.getNsid(), owner.getId()); assertEquals(testProperties.getUsername(), owner.getUsername()); List<Tag> tags = (List<Tag>) photo.getTags(); assertEquals(""green"", (tags.get(0)).getValue()); assertEquals(""grn"", (tags.get(1)).getValue()); } @Test
    public void testGetContactsPhotos() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); PhotoList<Photo> photos = iface.getContactsPhotos(0, false, false, false); assertNotNull(photos); assertTrue(photos.size() > 0); } @Test
    public void testGetContactsPublicPhotos() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); PhotoList<Photo> photos = iface.getContactsPublicPhotos(testProperties.getNsid(), 0, false, false, false); assertNotNull(photos); assertTrue(photos.size() > 0); } @Test
    public void testGetContext() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); PhotoContext photoContext = iface.getContext(testProperties.getPhotoId()); assertNotNull(photoContext); } @Test
    public void testGetCounts() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); Date[] dates = new Date[2]; dates[0] = new Date(100000); dates[1] = new Date(); Collection<Photocount> counts = iface.getCounts(dates, null); assertNotNull(counts); for (Photocount photocount : counts) { assertNotNull(photocount); } } @Test
    public void testGetExif() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); Collection<Exif> exifs = iface.getExif(testProperties.getPhotoId(), null); assertNotNull(exifs); } @Test
    public void testGetNotInSet() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); PhotoList<Photo> photos = iface.getNotInSet(-1, -1); assertNotNull(photos); } @Test
    public void testGetPerms() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); Permissions perms = iface.getPerms(testProperties.getPhotoId()); assertNotNull(perms); } @Test
    public void testGetRecent() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); Set<String> extras = new HashSet<String>(); PhotoList<Photo> photos = iface.getRecent(extras, 0, 0); assertNotNull(photos); } @Test
    public void testGetSizes() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); Collection<Size> sizes = iface.getSizes(testProperties.getPhotoId()); assertNotNull(sizes); sizes.forEach(size -> assertNotNull(size.getLabelName())); Optional<Size> original = sizes.stream().filter(size -> size.getLabelName().equals(""Original"")).findFirst(); assertTrue(original.isPresent()); } @Test
    public void testGetUntagged() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); PhotoList<Photo> photos = iface.getUntagged(0, 0); assertNotNull(photos); } @Test
    public void testSearch() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); SearchParameters searchParams = new SearchParameters(); searchParams.setUserId(testProperties.getNsid()); PhotoList<Photo> photos = iface.search(searchParams, 33, 0); assertNotNull(photos); assertEquals(1, photos.getPage()); assertTrue(photos.getPages() >= 1); assertTrue(photos.getPerPage() >= 1); assertTrue(photos.getTotal() >= 1); } @Test
    public void testBoundingBoxSearch() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); SearchParameters searchParameters = new SearchParameters(); searchParameters.setBBox(""-122.9"", ""45.0"", ""-122.0"", ""45.9""); PhotoList<Photo> photos = iface.search(searchParameters, -1, -1); assertNotNull(photos); } @Test
    public void testRadialGeoSearch() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); SearchParameters searchParameters = new SearchParameters(); searchParameters.setLatitude(""45.521694""); searchParameters.setLongitude(""-122.691806""); searchParameters.setRadius(2); searchParameters.setRadiusUnits(""km""); PhotoList<Photo> photos = iface.search(searchParameters, -1, -1); assertNotNull(photos); } @Test
    public void testTagSearch() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); SearchParameters searchParameters = new SearchParameters(); String[] tags = { ""flowers"" } ; searchParameters.setTags(tags); PhotoList<Photo> photos = iface.search(searchParameters, -1, -1); assertNotNull(photos); } @Test
    public void testSetContentType() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); iface.setContentType(testProperties.getPhotoId(), Flickr.CONTENTTYPE_PHOTO); } @Test
    public void testSetDates() { } @Test
    public void testSetMeta() throws FlickrException { String newTitle = ""New Title""; PhotosInterface iface = flickr.getPhotosInterface(); Photo photo = iface.getInfo(testProperties.getPhotoId(), null); String oldTitle = photo.getTitle(); photo.setTitle(newTitle); iface.setMeta(photo.getId(), photo.getTitle(), null); iface.setMeta(photo.getId(), oldTitle, ""Description""); } @Test
    public void testSetSafetyLevel() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); iface.setSafetyLevel(testProperties.getPhotoId(), Flickr.SAFETYLEVEL_SAFE, new Boolean(false)); } @Test
    public void testSetTags() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); String photoId = testProperties.getPhotoId(); String[] tagsAfterRemove = { } ; iface.setTags(photoId, tagsAfterRemove); String[] tagsToAdd = { ""green"", ""grn"", ""grngrn"" } ; iface.setTags(photoId, tagsToAdd); Photo photo = iface.getInfo(photoId, null); Collection<Tag> tags = photo.getTags(); assertNotNull(tags); assertEquals(3, tags.size()); } @Test
    public void testGetSmallImage() throws FlickrException, IOException { PhotosInterface iface = flickr.getPhotosInterface(); String photoId = testProperties.getPhotoId(); Photo photo = iface.getInfo(photoId, null); assertNotNull(photo); assertEquals(photoId, photo.getId()); } @Test
    public void testGetThumbnailImage() throws FlickrException, IOException { PhotosInterface iface = flickr.getPhotosInterface(); String photoId = testProperties.getPhotoId(); Photo photo = iface.getInfo(photoId, null); assertNotNull(photo); assertEquals(photoId, photo.getId()); } @Test
    public void testGetSmallSquareImage() throws FlickrException, IOException { PhotosInterface iface = flickr.getPhotosInterface(); String photoId = testProperties.getPhotoId(); Photo photo = iface.getInfo(photoId, null); assertNotNull(photo); assertEquals(photoId, photo.getId()); } @Test
    public void testGetMediumImage() throws FlickrException, IOException { PhotosInterface iface = flickr.getPhotosInterface(); String photoId = testProperties.getPhotoId(); Photo photo = iface.getInfo(photoId, null); assertNotNull(photo); assertEquals(photoId, photo.getId()); } @Test
    public void testGetLargeImage() throws FlickrException, IOException { PhotosInterface iface = flickr.getPhotosInterface(); String photoId = testProperties.getPhotoId(); Photo photo = iface.getInfo(photoId, null); assertNotNull(photo); assertEquals(photoId, photo.getId()); } @Test
    public void testGetPhoto() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); String photoId = testProperties.getPhotoId(); Photo photo = iface.getPhoto(photoId, null); assertNotNull(photo); } @Test
    public void testSetSizes() { Photo p = new Photo(); p.setId(""id""); p.setServer(""server""); p.setSecret(""secret""); p.setOriginalSecret(""osecret""); p.setFarm(""1""); try { } catch (FlickrException ex) { } p.setSizes(photoSizes); assertEquals(""urlSmall"", p.getSmallUrl()); assertEquals(""urlSquare"", p.getSmallSquareUrl()); assertEquals(""urlThumb"", p.getThumbnailUrl()); assertEquals(""urlMedium"", p.getMediumUrl()); assertEquals(""urlLarge"", p.getLargeUrl()); assertEquals(""urlSquareLarge"", p.getSquareLargeUrl()); assertEquals(""urlSmall320"", p.getSmall320Url()); assertEquals(""urlMedium640"", p.getMedium640Url()); assertEquals(""urlMedium800"", p.getMedium800Url()); assertEquals(""urlLarge1600"", p.getLarge1600Url()); assertEquals(""urlLarge2048"", p.getLarge2048Url()); assertEquals(""urlVideoPlayer"", p.getVideoPlayerUrl()); assertEquals(""urlSiteMP4"", p.getSiteMP4Url()); assertEquals(""urlVideoOriginal"", p.getVideoOriginalUrl()); try { assertEquals(""urlOriginal"", p.getOriginalUrl()); } catch (FlickrException ex) { } } @Test
    public void testGetAllSizes() { Photo p = new Photo(); p.setSizes(photoSizes); List<Size> pSizes = new ArrayList<Size>(p.getSizes()); for(Size s: pSizes) { assertNotNull(s); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; public class PhotosInterfaceTest extends Flickr4JavaTest { private final File largeFile = new File(""out.large.jpg""); private final File mediumFile = new File(""out.medium.jpg""); private final File smallFile = new File(""out.small.jpg""); private final File smallSquareFile = new File(""out.smallsquare.jpg""); private final File thumbnailFile = new File(""out.thumbnail.jpg""); private List<Size> photoSizes; @Override
    public void setUp() throws FlickrException { super.setUp(); preparePhotoSizes(); } @After
    public void teardown() { largeFile.deleteOnExit(); mediumFile.deleteOnExit(); smallFile.deleteOnExit(); smallSquareFile.deleteOnExit(); thumbnailFile.deleteOnExit(); } private void preparePhotoSizes() { photoSizes = new ArrayList<Size>(); Size size = new Size(); size.setLabel(""Thumbnail""); size.setWidth(""100""); size.setHeight(""75""); size.setSource(""urlThumb""); size.setUrl(""urlThumbPage""); photoSizes.add(size); size = new Size(); size.setLabel(""Square""); size.setWidth(""75""); size.setHeight(""75""); size.setSource(""urlSquare""); size.setUrl(""urlSquarePage""); photoSizes.add(size); size = new Size(); size.setLabel(""Small""); size.setWidth(""240""); size.setHeight(""180""); size.setSource(""urlSmall""); size.setUrl(""urlSmallPage""); photoSizes.add(size); size = new Size(); size.setLabel(""Medium""); size.setWidth(""240""); size.setHeight(""180""); size.setSource(""urlMedium""); size.setUrl(""urlMediumPage""); photoSizes.add(size); size = new Size(); size.setLabel(""Original""); size.setWidth(""240""); size.setHeight(""180""); size.setSource(""urlOriginal""); size.setUrl(""urlOriginalPage""); photoSizes.add(size); size = new Size(); size.setLabel(""Large""); size.setWidth(""240""); size.setHeight(""180""); size.setSource(""urlLarge""); size.setUrl(""urlLargePage""); photoSizes.add(size); size = new Size(); size.setLabel(""Large Square""); size.setWidth(""150""); size.setHeight(""150""); size.setSource(""urlSquareLarge""); size.setUrl(""urlSquareLargePage""); photoSizes.add(size); size = new Size(); size.setLabel(""Small 320""); size.setWidth(""320""); size.setHeight(""240""); size.setSource(""urlSmall320""); size.setUrl(""urlSmall320Page""); photoSizes.add(size); size = new Size(); size.setLabel(""Medium 640""); size.setWidth(""640""); size.setHeight(""320""); size.setSource(""urlMedium640""); size.setUrl(""urlMedium640Page""); photoSizes.add(size); size = new Size(); size.setLabel(""Medium 800""); size.setWidth(""800""); size.setHeight(""500""); size.setSource(""urlMedium800""); size.setUrl(""urlMedium800Page""); photoSizes.add(size); size = new Size(); size.setLabel(""Large 1600""); size.setWidth(""1600""); size.setHeight(""1024""); size.setSource(""urlLarge1600""); size.setUrl(""urlLarge1600Page""); photoSizes.add(size); size = new Size(); size.setLabel(""Large 2048""); size.setWidth(""2048""); size.setHeight(""1600""); size.setSource(""urlLarge2048""); size.setUrl(""urlLarge2048Page""); photoSizes.add(size); size = new Size(); size.setLabel(""Video Player""); size.setWidth(""320""); size.setHeight(""240""); size.setSource(""urlVideoPlayer""); size.setUrl(""urlVideoPlayerPage""); photoSizes.add(size); size = new Size(); size.setLabel(""Site MP4""); size.setWidth(""320""); size.setHeight(""240""); size.setSource(""urlSiteMP4""); size.setUrl(""urlSiteMP4Page""); photoSizes.add(size); size = new Size(); size.setLabel(""Video Original""); size.setWidth(""960""); size.setHeight(""720""); size.setSource(""urlVideoOriginal""); size.setUrl(""urlVideoOriginalPage""); photoSizes.add(size); size = new Size(); size.setLabel(""Mobile MP4""); size.setWidth(""640""); size.setHeight(""360""); size.setSource(""urlMobileMP4""); size.setUrl(""urlMobileMP4Page""); photoSizes.add(size); size = new Size(); size.setLabel(""HD MP4""); size.setWidth(""1280""); size.setHeight(""720""); size.setSource(""urlHDMP4""); size.setUrl(""urlHDMP4Page""); photoSizes.add(size); } @Test
    public void testAddAndRemoveTags() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); String photoId = testProperties.getPhotoId(); Photo photo = iface.getInfo(photoId, null); int preCount = photo.getTags().size(); String[] tagsToAdd = { ""test"" } ; iface.addTags(photoId, tagsToAdd); photo = iface.getInfo(photoId, null); Collection<Tag> tags = photo.getTags(); assertNotNull(tags); String tagId = null; for (Tag tag : tags) { if (tag.getValue().equals(""test"")) { tagId = tag.getId(); break; } } iface.removeTag(tagId); photo = iface.getInfo(photoId, null); tags = photo.getTags(); assertNotNull(tags); assertEquals(preCount, tags.size()); } @Test
    public void testGetInfo() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); Photo photo = iface.getInfo(testProperties.getPhotoId(), null); assertNotNull(photo); assertNotNull(photo.getUrl()); assertNotNull(photo.getTitle()); assertNotNull(photo.getTitle()); assertEquals(testProperties.getPhotoId(), photo.getId()); assertNotNull(photo.getSecret()); assertNotNull(photo.getServer()); assertNotNull(photo.getFarm()); assertEquals(""0"", photo.getLicense()); assertEquals(""jpg"", photo.getOriginalFormat()); assertEquals("""", photo.getIconServer()); assertEquals("""", photo.getIconFarm()); assertFalse(photo.isFavorite()); User owner = photo.getOwner(); assertEquals(testProperties.getNsid(), owner.getId()); assertEquals(testProperties.getUsername(), owner.getUsername()); List<Tag> tags = (List<Tag>) photo.getTags(); assertEquals(""green"", (tags.get(0)).getValue()); assertEquals(""grn"", (tags.get(1)).getValue()); } @Test
    public void testGetContactsPhotos() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); PhotoList<Photo> photos = iface.getContactsPhotos(0, false, false, false); assertNotNull(photos); assertTrue(photos.size() > 0); } @Test
    public void testGetContactsPublicPhotos() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); PhotoList<Photo> photos = iface.getContactsPublicPhotos(testProperties.getNsid(), 0, false, false, false); assertNotNull(photos); assertTrue(photos.size() > 0); } @Test
    public void testGetContext() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); PhotoContext photoContext = iface.getContext(testProperties.getPhotoId()); assertNotNull(photoContext); } @Test
    public void testGetCounts() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); Date[] dates = new Date[2]; dates[0] = new Date(100000); dates[1] = new Date(); Collection<Photocount> counts = iface.getCounts(dates, null); assertNotNull(counts); for (Photocount photocount : counts) { assertNotNull(photocount); } } @Test
    public void testGetExif() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); Collection<Exif> exifs = iface.getExif(testProperties.getPhotoId(), null); assertNotNull(exifs); } @Test
    public void testGetNotInSet() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); PhotoList<Photo> photos = iface.getNotInSet(-1, -1); assertNotNull(photos); } @Test
    public void testGetPerms() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); Permissions perms = iface.getPerms(testProperties.getPhotoId()); assertNotNull(perms); } @Test
    public void testGetRecent() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); Set<String> extras = new HashSet<String>(); PhotoList<Photo> photos = iface.getRecent(extras, 0, 0); assertNotNull(photos); } @Test
    public void testGetSizes() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); Collection<Size> sizes = iface.getSizes(testProperties.getPhotoId()); assertNotNull(sizes); sizes.forEach(size -> assertNotNull(size.getLabelName())); Optional<Size> original = sizes.stream().filter(size -> size.getLabelName().equals(""Original"")).findFirst(); assertTrue(original.isPresent()); } @Test
    public void testGetUntagged() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); PhotoList<Photo> photos = iface.getUntagged(0, 0); assertNotNull(photos); } @Test
    public void testSearch() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); SearchParameters searchParams = new SearchParameters(); searchParams.setUserId(testProperties.getNsid()); PhotoList<Photo> photos = iface.search(searchParams, 33, 0); assertNotNull(photos); assertEquals(1, photos.getPage()); assertTrue(photos.getPages() >= 1); assertTrue(photos.getPerPage() >= 1); assertTrue(photos.getTotal() >= 1); } @Test
    public void testBoundingBoxSearch() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); SearchParameters searchParameters = new SearchParameters(); searchParameters.setBBox(""-122.9"", ""45.0"", ""-122.0"", ""45.9""); PhotoList<Photo> photos = iface.search(searchParameters, -1, -1); assertNotNull(photos); } @Test
    public void testRadialGeoSearch() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); SearchParameters searchParameters = new SearchParameters(); searchParameters.setLatitude(""45.521694""); searchParameters.setLongitude(""-122.691806""); searchParameters.setRadius(2); searchParameters.setRadiusUnits(""km""); PhotoList<Photo> photos = iface.search(searchParameters, -1, -1); assertNotNull(photos); } @Test
    public void testTagSearch() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); SearchParameters searchParameters = new SearchParameters(); String[] tags = { ""flowers"" } ; searchParameters.setTags(tags); PhotoList<Photo> photos = iface.search(searchParameters, -1, -1); assertNotNull(photos); } @Test
    public void testSetContentType() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); iface.setContentType(testProperties.getPhotoId(), Flickr.CONTENTTYPE_PHOTO); } @Test
    public void testSetDates() { } @Test
    public void testSetMeta() throws FlickrException { String newTitle = ""New Title""; PhotosInterface iface = flickr.getPhotosInterface(); Photo photo = iface.getInfo(testProperties.getPhotoId(), null); String oldTitle = photo.getTitle(); photo.setTitle(newTitle); iface.setMeta(photo.getId(), photo.getTitle(), null); iface.setMeta(photo.getId(), oldTitle, ""Description""); } @Test
    public void testSetSafetyLevel() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); iface.setSafetyLevel(testProperties.getPhotoId(), Flickr.SAFETYLEVEL_SAFE, new Boolean(false)); } @Test
    public void testSetTags() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); String photoId = testProperties.getPhotoId(); String[] tagsAfterRemove = { } ; iface.setTags(photoId, tagsAfterRemove); String[] tagsToAdd = { ""green"", ""grn"", ""grngrn"" } ; iface.setTags(photoId, tagsToAdd); Photo photo = iface.getInfo(photoId, null); Collection<Tag> tags = photo.getTags(); assertNotNull(tags); assertEquals(3, tags.size()); } @Test
    public void testGetSmallImage() throws FlickrException, IOException { PhotosInterface iface = flickr.getPhotosInterface(); String photoId = testProperties.getPhotoId(); Photo photo = iface.getInfo(photoId, null); assertNotNull(photo); assertEquals(photoId, photo.getId()); } @Test
    public void testGetThumbnailImage() throws FlickrException, IOException { PhotosInterface iface = flickr.getPhotosInterface(); String photoId = testProperties.getPhotoId(); Photo photo = iface.getInfo(photoId, null); assertNotNull(photo); assertEquals(photoId, photo.getId()); } @Test
    public void testGetSmallSquareImage() throws FlickrException, IOException { PhotosInterface iface = flickr.getPhotosInterface(); String photoId = testProperties.getPhotoId(); Photo photo = iface.getInfo(photoId, null); assertNotNull(photo); assertEquals(photoId, photo.getId()); } @Test
    public void testGetMediumImage() throws FlickrException, IOException { PhotosInterface iface = flickr.getPhotosInterface(); String photoId = testProperties.getPhotoId(); Photo photo = iface.getInfo(photoId, null); assertNotNull(photo); assertEquals(photoId, photo.getId()); } @Test
    public void testGetLargeImage() throws FlickrException, IOException { PhotosInterface iface = flickr.getPhotosInterface(); String photoId = testProperties.getPhotoId(); Photo photo = iface.getInfo(photoId, null); assertNotNull(photo); assertEquals(photoId, photo.getId()); } @Test
    public void testGetPhoto() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); String photoId = testProperties.getPhotoId(); Photo photo = iface.getPhoto(photoId, null); assertNotNull(photo); } @Test
    public void testSetSizes() { Photo p = new Photo(); p.setId(""id""); p.setServer(""server""); p.setSecret(""secret""); p.setOriginalSecret(""osecret""); p.setFarm(""1""); try { } catch (FlickrException ex) { } p.setSizes(photoSizes); assertEquals(""urlSmall"", p.getSmallUrl()); assertEquals(""urlSquare"", p.getSmallSquareUrl()); assertEquals(""urlThumb"", p.getThumbnailUrl()); assertEquals(""urlMedium"", p.getMediumUrl()); assertEquals(""urlLarge"", p.getLargeUrl()); assertEquals(""urlSquareLarge"", p.getSquareLargeUrl()); assertEquals(""urlSmall320"", p.getSmall320Url()); assertEquals(""urlMedium640"", p.getMedium640Url()); assertEquals(""urlMedium800"", p.getMedium800Url()); assertEquals(""urlLarge1600"", p.getLarge1600Url()); assertEquals(""urlLarge2048"", p.getLarge2048Url()); assertEquals(""urlVideoPlayer"", p.getVideoPlayerUrl()); assertEquals(""urlSiteMP4"", p.getSiteMP4Url()); assertEquals(""urlVideoOriginal"", p.getVideoOriginalUrl()); try { assertEquals(""urlOriginal"", p.getOriginalUrl()); } catch (FlickrException ex) { } } @Test
    public void testGetAllSizes() { Photo p = new Photo(); p.setSizes(photoSizes); List<Size> pSizes = new ArrayList<Size>(p.getSizes()); for(Size s: pSizes) { assertNotNull(s); } } } ","
 package com.flickr4java.flickr.test;  
import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.people.User; import com.flickr4java.flickr.photos.Exif; import com.flickr4java.flickr.photos.Permissions; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoContext; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.Photocount; import com.flickr4java.flickr.photos.PhotosInterface; import com.flickr4java.flickr.photos.SearchParameters; import com.flickr4java.flickr.photos.Size; import com.flickr4java.flickr.tags.Tag; import org.junit.After; import org.junit.Test; 
import java.io.File; import java.io.IOException; import java.util.*; 
import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue;  public class PhotosInterfaceTest extends Flickr4JavaTest { /**
 * @author Anthony Eden
 * @version $Id: PhotosInterfaceTest.java,v 1.20 2009/07/23 21:49:35 x-mago Exp $
 */ private final File largeFile = new File(""out.large.jpg"");  private final File mediumFile = new File(""out.medium.jpg"");  private final File smallFile = new File(""out.small.jpg"");  private final File smallSquareFile = new File(""out.smallsquare.jpg"");  private final File thumbnailFile = new File(""out.thumbnail.jpg"");  private List<Size> photoSizes;      @Override
    public void setUp() throws FlickrException { super.setUp(); preparePhotoSizes(); }  @After
    public void teardown() {  largeFile.deleteOnExit(); mediumFile.deleteOnExit(); smallFile.deleteOnExit(); smallSquareFile.deleteOnExit(); thumbnailFile.deleteOnExit(); }  private void preparePhotoSizes() { photoSizes = new ArrayList<Size>(); Size size = new Size(); size.setLabel(""Thumbnail""); size.setWidth(""100""); size.setHeight(""75""); size.setSource(""urlThumb""); size.setUrl(""urlThumbPage""); photoSizes.add(size); size = new Size(); size.setLabel(""Square""); size.setWidth(""75""); size.setHeight(""75""); size.setSource(""urlSquare""); size.setUrl(""urlSquarePage""); photoSizes.add(size); size = new Size(); size.setLabel(""Small""); size.setWidth(""240""); size.setHeight(""180""); size.setSource(""urlSmall""); size.setUrl(""urlSmallPage""); photoSizes.add(size); size = new Size(); size.setLabel(""Medium""); size.setWidth(""240""); size.setHeight(""180""); size.setSource(""urlMedium""); size.setUrl(""urlMediumPage""); photoSizes.add(size); size = new Size(); size.setLabel(""Original""); size.setWidth(""240""); size.setHeight(""180""); size.setSource(""urlOriginal""); size.setUrl(""urlOriginalPage""); photoSizes.add(size); size = new Size(); size.setLabel(""Large""); size.setWidth(""240""); size.setHeight(""180""); size.setSource(""urlLarge""); size.setUrl(""urlLargePage""); photoSizes.add(size); size = new Size(); size.setLabel(""Large Square""); size.setWidth(""150""); size.setHeight(""150""); size.setSource(""urlSquareLarge""); size.setUrl(""urlSquareLargePage""); photoSizes.add(size); size = new Size(); size.setLabel(""Small 320""); size.setWidth(""320""); size.setHeight(""240""); size.setSource(""urlSmall320""); size.setUrl(""urlSmall320Page""); photoSizes.add(size); size = new Size(); size.setLabel(""Medium 640""); size.setWidth(""640""); size.setHeight(""320""); size.setSource(""urlMedium640""); size.setUrl(""urlMedium640Page""); photoSizes.add(size); size = new Size(); size.setLabel(""Medium 800""); size.setWidth(""800""); size.setHeight(""500""); size.setSource(""urlMedium800""); size.setUrl(""urlMedium800Page""); photoSizes.add(size); size = new Size(); size.setLabel(""Large 1600""); size.setWidth(""1600""); size.setHeight(""1024""); size.setSource(""urlLarge1600""); size.setUrl(""urlLarge1600Page""); photoSizes.add(size); size = new Size(); size.setLabel(""Large 2048""); size.setWidth(""2048""); size.setHeight(""1600""); size.setSource(""urlLarge2048""); size.setUrl(""urlLarge2048Page""); photoSizes.add(size); size = new Size(); size.setLabel(""Video Player""); size.setWidth(""320""); size.setHeight(""240""); size.setSource(""urlVideoPlayer""); size.setUrl(""urlVideoPlayerPage""); photoSizes.add(size); size = new Size(); size.setLabel(""Site MP4""); size.setWidth(""320""); size.setHeight(""240""); size.setSource(""urlSiteMP4""); size.setUrl(""urlSiteMP4Page""); photoSizes.add(size); size = new Size(); size.setLabel(""Video Original""); size.setWidth(""960""); size.setHeight(""720""); size.setSource(""urlVideoOriginal""); size.setUrl(""urlVideoOriginalPage""); photoSizes.add(size); size = new Size(); size.setLabel(""Mobile MP4""); size.setWidth(""640""); size.setHeight(""360""); size.setSource(""urlMobileMP4""); size.setUrl(""urlMobileMP4Page""); photoSizes.add(size); size = new Size(); size.setLabel(""HD MP4""); size.setWidth(""1280""); size.setHeight(""720""); size.setSource(""urlHDMP4""); size.setUrl(""urlHDMP4Page""); photoSizes.add(size); }      @Test
    public void testAddAndRemoveTags() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); String photoId = testProperties.getPhotoId(); Photo photo = iface.getInfo(photoId, null);   int preCount = photo.getTags().size(); // Find number of existing tags  String[] tagsToAdd = { ""test"" } ; iface.addTags(photoId, tagsToAdd); // Add a tag  photo = iface.getInfo(photoId, null); Collection<Tag> tags = photo.getTags(); assertNotNull(tags); // Check that it was added  String tagId = null; for (Tag tag : tags) { if (tag.getValue().equals(""test"")) { tagId = tag.getId(); break; } } // Get the added tag's ID  iface.removeTag(tagId); photo = iface.getInfo(photoId, null); tags = photo.getTags(); assertNotNull(tags); assertEquals(preCount, tags.size()); } // Remove and check that it was removed @Test
    public void testGetInfo() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); Photo photo = iface.getInfo(testProperties.getPhotoId(), null); assertNotNull(photo); assertNotNull(photo.getUrl()); assertNotNull(photo.getTitle()); assertNotNull(photo.getTitle()); assertEquals(testProperties.getPhotoId(), photo.getId()); assertNotNull(photo.getSecret()); assertNotNull(photo.getServer()); assertNotNull(photo.getFarm()); assertEquals(""0"", photo.getLicense()); assertEquals(""jpg"", photo.getOriginalFormat());  assertEquals("""", photo.getIconServer()); assertEquals("""", photo.getIconFarm()); assertFalse(photo.isFavorite()); // no pro, no original :-( // assertTrue(photo.getViews() > -1); User owner = photo.getOwner(); assertEquals(testProperties.getNsid(), owner.getId()); assertEquals(testProperties.getUsername(), owner.getUsername());  List<Tag> tags = (List<Tag>) photo.getTags(); assertEquals(""green"", (tags.get(0)).getValue()); assertEquals(""grn"", (tags.get(1)).getValue()); }  @Test
    public void testGetContactsPhotos() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); PhotoList<Photo> photos = iface.getContactsPhotos(0, false, false, false); assertNotNull(photos); assertTrue(photos.size() > 0); }  @Test
    public void testGetContactsPublicPhotos() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); PhotoList<Photo> photos = iface.getContactsPublicPhotos(testProperties.getNsid(), 0, false, false, false); assertNotNull(photos); assertTrue(photos.size() > 0); }  @Test
    public void testGetContext() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); PhotoContext photoContext = iface.getContext(testProperties.getPhotoId()); assertNotNull(photoContext); }  @Test
    public void testGetCounts() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); Date[] dates = new Date[2]; dates[0] = new Date(100000); dates[1] = new Date();  Collection<Photocount> counts = iface.getCounts(dates, null); assertNotNull(counts); // now for (Photocount photocount : counts) { assertNotNull(photocount); } }  @Test
    public void testGetExif() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); Collection<Exif> exifs = iface.getExif(testProperties.getPhotoId(), null); assertNotNull(exifs); }  @Test
    public void testGetNotInSet() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); PhotoList<Photo> photos = iface.getNotInSet(-1, -1); assertNotNull(photos); }  @Test
    public void testGetPerms() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); Permissions perms = iface.getPerms(testProperties.getPhotoId()); assertNotNull(perms); }  @Test
    public void testGetRecent() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); Set<String> extras = new HashSet<String>(); PhotoList<Photo> photos = iface.getRecent(extras, 0, 0); assertNotNull(photos); }  @Test
    public void testGetSizes() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); Collection<Size> sizes = iface.getSizes(testProperties.getPhotoId()); assertNotNull(sizes);  sizes.forEach(size -> assertNotNull(size.getLabelName())); Optional<Size> original = sizes.stream().filter(size -> size.getLabelName().equals(""Original"")).findFirst(); assertTrue(original.isPresent()); }  @Test
    public void testGetUntagged() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); PhotoList<Photo> photos = iface.getUntagged(0, 0); assertNotNull(photos); }  @Test
    public void testSearch() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); SearchParameters searchParams = new SearchParameters(); searchParams.setUserId(testProperties.getNsid()); PhotoList<Photo> photos = iface.search(searchParams, 33, 0); assertNotNull(photos); assertEquals(1, photos.getPage()); assertTrue(photos.getPages() >= 1); assertTrue(photos.getPerPage() >= 1); assertTrue(photos.getTotal() >= 1); }  @Test
    public void testBoundingBoxSearch() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); SearchParameters searchParameters = new SearchParameters(); searchParameters.setBBox(""-122.9"", ""45.0"", ""-122.0"", ""45.9""); PhotoList<Photo> photos = iface.search(searchParameters, -1, -1); assertNotNull(photos); }  @Test
    public void testRadialGeoSearch() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); SearchParameters searchParameters = new SearchParameters(); searchParameters.setLatitude(""45.521694""); searchParameters.setLongitude(""-122.691806""); searchParameters.setRadius(2); searchParameters.setRadiusUnits(""km""); PhotoList<Photo> photos = iface.search(searchParameters, -1, -1); assertNotNull(photos); }  @Test
    public void testTagSearch() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); SearchParameters searchParameters = new SearchParameters(); String[] tags = { ""flowers"" } ; searchParameters.setTags(tags); PhotoList<Photo> photos = iface.search(searchParameters, -1, -1); assertNotNull(photos); }  @Test
    public void testSetContentType() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); iface.setContentType(testProperties.getPhotoId(), Flickr.CONTENTTYPE_PHOTO); }  @Test
    public void testSetDates() {  }  @Test
    public void testSetMeta() throws FlickrException { String newTitle = ""New Title""; PhotosInterface iface = flickr.getPhotosInterface(); Photo photo = iface.getInfo(testProperties.getPhotoId(), null); String oldTitle = photo.getTitle(); photo.setTitle(newTitle); iface.setMeta(photo.getId(), photo.getTitle(), null); iface.setMeta(photo.getId(), oldTitle, ""Description""); }  @Test
    public void testSetSafetyLevel() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); iface.setSafetyLevel(testProperties.getPhotoId(), Flickr.SAFETYLEVEL_SAFE, new Boolean(false)); }  @Test
    public void testSetTags() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); String photoId = testProperties.getPhotoId();  String[] tagsAfterRemove = { } ; iface.setTags(photoId, tagsAfterRemove);  String[] tagsToAdd = { ""green"", ""grn"", ""grngrn"" } ; iface.setTags(photoId, tagsToAdd);  Photo photo = iface.getInfo(photoId, null); Collection<Tag> tags = photo.getTags(); assertNotNull(tags); assertEquals(3, tags.size());   // String tagId = null; // Iterator tagsIter = tags.iterator(); // TAG_LOOP: while (tagsIter.hasNext()) { // Tag tag = (Tag) tagsIter.next(); // if (tag.getValue().equals(""test"")) { // tagId = tag.getId(); // break TAG_LOOP; // } // } }  @Test
    public void testGetSmallImage() throws FlickrException, IOException { PhotosInterface iface = flickr.getPhotosInterface(); String photoId = testProperties.getPhotoId(); Photo photo = iface.getInfo(photoId, null); assertNotNull(photo); assertEquals(photoId, photo.getId()); }  @Test
    public void testGetThumbnailImage() throws FlickrException, IOException { PhotosInterface iface = flickr.getPhotosInterface(); String photoId = testProperties.getPhotoId(); Photo photo = iface.getInfo(photoId, null); assertNotNull(photo); assertEquals(photoId, photo.getId()); }  @Test
    public void testGetSmallSquareImage() throws FlickrException, IOException { PhotosInterface iface = flickr.getPhotosInterface(); String photoId = testProperties.getPhotoId(); Photo photo = iface.getInfo(photoId, null); assertNotNull(photo); assertEquals(photoId, photo.getId()); }  @Test
    public void testGetMediumImage() throws FlickrException, IOException { PhotosInterface iface = flickr.getPhotosInterface(); String photoId = testProperties.getPhotoId(); Photo photo = iface.getInfo(photoId, null); assertNotNull(photo); assertEquals(photoId, photo.getId()); }  @Test
    public void testGetLargeImage() throws FlickrException, IOException { PhotosInterface iface = flickr.getPhotosInterface(); String photoId = testProperties.getPhotoId(); Photo photo = iface.getInfo(photoId, null); assertNotNull(photo); assertEquals(photoId, photo.getId()); }  @Test
    public void testGetPhoto() throws FlickrException { PhotosInterface iface = flickr.getPhotosInterface(); String photoId = testProperties.getPhotoId(); Photo photo = iface.getPhoto(photoId, null); assertNotNull(photo); }   @Test
    public void testSetSizes() { Photo p = new Photo(); p.setId(""id""); p.setServer(""server""); p.setSecret(""secret""); p.setOriginalSecret(""osecret""); p.setFarm(""1""); /**
     * Testing the generation of URLs and the overriding by setSizes().
     */  //farm1.staticflickr.com/server/id_secret_m.jpg"", p.getSmallUrl()); //farm1.staticflickr.com/server/id_secret_s.jpg"", p.getSmallSquareUrl()); //farm1.staticflickr.com/server/id_secret_t.jpg"", p.getThumbnailUrl()); //farm1.staticflickr.com/server/id_secret.jpg"", p.getMediumUrl()); //farm1.staticflickr.com/server/id_secret_b.jpg"", p.getLargeUrl()); //farm1.staticflickr.com/server/id_secret_q.jpg"", p.getSquareLargeUrl()); //farm1.staticflickr.com/server/id_secret_n.jpg"", p.getSmall320Url()); //farm1.staticflickr.com/server/id_secret_z.jpg"", p.getMedium640Url()); //farm1.staticflickr.com/server/id_secret_c.jpg"", p.getMedium800Url()); //farm1.staticflickr.com/server/id_secret_h.jpg"", p.getLarge1600Url()); try { //farm1.staticflickr.com/server/id_secret_k.jpg"", p.getLarge2048Url()); } catch (FlickrException ex) { } //farm1.staticflickr.com/server/id_osecret_o.jpg"", p.getOriginalUrl()); p.setSizes(photoSizes); assertEquals(""urlSmall"", p.getSmallUrl()); assertEquals(""urlSquare"", p.getSmallSquareUrl()); assertEquals(""urlThumb"", p.getThumbnailUrl()); assertEquals(""urlMedium"", p.getMediumUrl()); assertEquals(""urlLarge"", p.getLargeUrl()); assertEquals(""urlSquareLarge"", p.getSquareLargeUrl()); assertEquals(""urlSmall320"", p.getSmall320Url()); assertEquals(""urlMedium640"", p.getMedium640Url()); assertEquals(""urlMedium800"", p.getMedium800Url()); assertEquals(""urlLarge1600"", p.getLarge1600Url()); assertEquals(""urlLarge2048"", p.getLarge2048Url()); assertEquals(""urlVideoPlayer"", p.getVideoPlayerUrl()); assertEquals(""urlSiteMP4"", p.getSiteMP4Url()); assertEquals(""urlVideoOriginal"", p.getVideoOriginalUrl()); try { assertEquals(""urlOriginal"", p.getOriginalUrl()); } catch (FlickrException ex) { } } // setSizes() to override the generated URLs. @Test
    public void testGetAllSizes() { Photo p = new Photo(); p.setSizes(photoSizes);      List<Size> pSizes = new ArrayList<Size>(p.getSizes());          for(Size s: pSizes) { assertNotNull(s); } } }          "
src/test/java/com/flickr4java/flickr/test/PhotosetsInterfaceTest.java,"package com.flickr4java.flickr.test;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.auth.Permission;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoContext;
import com.flickr4java.flickr.photos.PhotoList;
import com.flickr4java.flickr.photosets.Photoset;
import com.flickr4java.flickr.photosets.Photosets;
import com.flickr4java.flickr.photosets.PhotosetsInterface;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Collection;
import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

/**
 * @author Anthony Eden
 */
public class PhotosetsInterfaceTest extends Flickr4JavaTest {

    private static Logger _log = LoggerFactory.getLogger(PhotosetsInterfaceTest.class);

    private Photoset testSet;

    private List<String> setPics;

    @Override
    @Before
    public void setUp() throws FlickrException {
        super.setUp();

        setPics = testProperties.getPhotosetPhotos();

        PhotosetsInterface iface = flickr.getPhotosetsInterface();
        testSet = iface.create(""PhotosetsInterfaceTest"", ""JUnit test, should be deleted"", setPics.get(0));
        iface.addPhoto(testSet.getId(), setPics.get(1));
        iface.addPhoto(testSet.getId(), setPics.get(2));
    }

    @After
    public void tearDown() throws FlickrException {
        setAuth(Permission.DELETE);

        PhotosetsInterface iface = flickr.getPhotosetsInterface();
        iface.delete(testSet.getId());
    }

    @Test
    public void testCreateAndDelete() throws FlickrException {
        PhotosetsInterface iface = flickr.getPhotosetsInterface();
        Photoset photoset = iface.create(""test"", ""A test photoset"", testProperties.getPhotoId());
        assertNotNull(photoset);
        assertNotNull(photoset.getId());
        assertNotNull(photoset.getUrl());
        iface.delete(photoset.getId());
    }

    @Test
    public void testEditMeta() {

    }

    @Test
    public void testEditPhotos() throws FlickrException {

        PhotosetsInterface iface = flickr.getPhotosetsInterface();

        iface.editPhotos(testSet.getId(), testProperties.getPhotoId(), setPics.toArray(new String[setPics.size()]));

        Photoset ps = iface.getInfo(testSet.getId());
        assertNotNull(ps);
        assertEquals(testProperties.getPhotoId(), ps.getPrimaryPhoto().getId());
        assertTrue(ps.getPhotoCount() >= 2);
    }

    @Test
    public void testGetContext() throws FlickrException {
        PhotosetsInterface iface = flickr.getPhotosetsInterface();
        PhotoContext photoContext = iface.getContext(testProperties.getPhotoId(), testProperties.getPhotosetId());
        Photo previousPhoto = photoContext.getPreviousPhoto();
        Photo nextPhoto = photoContext.getNextPhoto();
        assertNotNull(previousPhoto);
        assertNotNull(nextPhoto);
    }

    @Test
    public void testGetInfo() throws FlickrException {
        clearAuth();

        PhotosetsInterface iface = flickr.getPhotosetsInterface();
        Photoset photoset = iface.getInfo(testProperties.getPhotosetId());
        _log.debug(photoset.getUrl());
        assertNotNull(photoset);
        assertNotNull(photoset.getPrimaryPhoto());
        assertTrue(photoset.getPhotoCount() >= 1);
    }

    @Test
    public void testGetList() throws FlickrException {
        PhotosetsInterface iface = flickr.getPhotosetsInterface();
        Photosets photosets = iface.getList(testProperties.getNsid());
        assertNotNull(photosets);
        assertFalse(photosets.getPhotosets().isEmpty());
    }

    @Test
    public void testGetListWithExtras() throws FlickrException {
        PhotosetsInterface iface = flickr.getPhotosetsInterface();
        Photosets photosets = iface.getList(testProperties.getNsid(), ""last_update, owner_name"");
        assertNotNull(photosets);
        Collection<Photoset> photosetsList = photosets.getPhotosets();
        assertFalse(photosetsList.isEmpty());
        Photoset photoset = photosetsList.iterator().next();
        assertNotNull(photoset.getPrimaryPhoto().getLastUpdate());
        assertNotNull(photoset.getPrimaryPhoto().getOwner());
        assertNotNull(photoset.getPrimaryPhoto().getOwner().getUsername());
        assertTrue(photoset.getPrimaryPhoto().getOwner().getUsername().length() > 0);
    }

    @Test
    public void testGetPhotos() throws FlickrException {
        PhotosetsInterface iface = flickr.getPhotosetsInterface();
        PhotoList<Photo> photos = iface.getPhotos(testProperties.getPhotosetId(), 10, 1);
        assertNotNull(photos);
        assertTrue(photos.size() >= 1);
        assertNotNull(photos.get(0).getOwner().getUsername());
        assertNotNull(photos.get(0).getOwner().getId());
    }

    @Test
    public void testOrderSets() throws FlickrException {
        PhotosetsInterface iface = flickr.getPhotosetsInterface();
        String[] photosetIds = { testProperties.getPhotosetId() };
        iface.orderSets(photosetIds);
    }

    /*
     * @Test public void testRemovePhoto() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); String[] photosetIds =
     * {testProperties.getPhotoSetId()}; iface.orderSets(photosetIds); }
     */
    @Test
    public void testRemovePhotos() throws FlickrException {
        PhotosetsInterface iface = flickr.getPhotosetsInterface();
        Photoset photoset = iface.create(""test"", ""A test photoset"", testProperties.getPhotoId());

        PhotoList<Photo> photos = iface.getPhotos(photoset.getId(), 10, 1);
        assertNotNull(photos);

        iface.removePhoto(photoset.getId(), testProperties.getPhotoId());

        try {
            photos = iface.getPhotos(photoset.getId(), 10, 1);
        } catch (FlickrException e) {
            // photoset should be nuked when the only photo is removed from it
        }
    }
}
","package com.flickr4java.flickr.test; public class PhotosetsInterfaceTest extends Flickr4JavaTest { private static Logger _log = LoggerFactory.getLogger(PhotosetsInterfaceTest.class); private Photoset testSet; private List<String> setPics; @Override
    @Before
    public void setUp() throws FlickrException { super.setUp(); setPics = testProperties.getPhotosetPhotos(); PhotosetsInterface iface = flickr.getPhotosetsInterface(); testSet = iface.create(""PhotosetsInterfaceTest"", ""JUnit test, should be deleted"", setPics.get(0)); iface.addPhoto(testSet.getId(), setPics.get(1)); iface.addPhoto(testSet.getId(), setPics.get(2)); } @After
    public void tearDown() throws FlickrException { setAuth(Permission.DELETE); PhotosetsInterface iface = flickr.getPhotosetsInterface(); iface.delete(testSet.getId()); } @Test
    public void testCreateAndDelete() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); Photoset photoset = iface.create(""test"", ""A test photoset"", testProperties.getPhotoId()); assertNotNull(photoset); assertNotNull(photoset.getId()); assertNotNull(photoset.getUrl()); iface.delete(photoset.getId()); } @Test
    public void testEditMeta() { } @Test
    public void testEditPhotos() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); iface.editPhotos(testSet.getId(), testProperties.getPhotoId(), setPics.toArray(new String[setPics.size()])); Photoset ps = iface.getInfo(testSet.getId()); assertNotNull(ps); assertEquals(testProperties.getPhotoId(), ps.getPrimaryPhoto().getId()); assertTrue(ps.getPhotoCount() >= 2); } @Test
    public void testGetContext() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); PhotoContext photoContext = iface.getContext(testProperties.getPhotoId(), testProperties.getPhotosetId()); Photo previousPhoto = photoContext.getPreviousPhoto(); Photo nextPhoto = photoContext.getNextPhoto(); assertNotNull(previousPhoto); assertNotNull(nextPhoto); } @Test
    public void testGetInfo() throws FlickrException { clearAuth(); PhotosetsInterface iface = flickr.getPhotosetsInterface(); Photoset photoset = iface.getInfo(testProperties.getPhotosetId()); assertNotNull(photoset); assertNotNull(photoset.getPrimaryPhoto()); assertTrue(photoset.getPhotoCount() >= 1); } @Test
    public void testGetList() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); Photosets photosets = iface.getList(testProperties.getNsid()); assertNotNull(photosets); assertFalse(photosets.getPhotosets().isEmpty()); } @Test
    public void testGetListWithExtras() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); Photosets photosets = iface.getList(testProperties.getNsid(), ""last_update, owner_name""); assertNotNull(photosets); Collection<Photoset> photosetsList = photosets.getPhotosets(); assertFalse(photosetsList.isEmpty()); Photoset photoset = photosetsList.iterator().next(); assertNotNull(photoset.getPrimaryPhoto().getLastUpdate()); assertNotNull(photoset.getPrimaryPhoto().getOwner()); assertNotNull(photoset.getPrimaryPhoto().getOwner().getUsername()); assertTrue(photoset.getPrimaryPhoto().getOwner().getUsername().length() > 0); } @Test
    public void testGetPhotos() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); PhotoList<Photo> photos = iface.getPhotos(testProperties.getPhotosetId(), 10, 1); assertNotNull(photos); assertTrue(photos.size() >= 1); assertNotNull(photos.get(0).getOwner().getUsername()); assertNotNull(photos.get(0).getOwner().getId()); } @Test
    public void testOrderSets() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); String[] photosetIds = { testProperties.getPhotosetId() } ; iface.orderSets(photosetIds); } @Test
    public void testRemovePhotos() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); Photoset photoset = iface.create(""test"", ""A test photoset"", testProperties.getPhotoId()); PhotoList<Photo> photos = iface.getPhotos(photoset.getId(), 10, 1); assertNotNull(photos); iface.removePhoto(photoset.getId(), testProperties.getPhotoId()); try { photos = iface.getPhotos(photoset.getId(), 10, 1); } catch (FlickrException e) { } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; public class PhotosetsInterfaceTest extends Flickr4JavaTest { private static Logger _log = LoggerFactory.getLogger(PhotosetsInterfaceTest.class); private Photoset testSet; private List<String> setPics; @Override
    @Before
    public void setUp() throws FlickrException { super.setUp(); setPics = testProperties.getPhotosetPhotos(); PhotosetsInterface iface = flickr.getPhotosetsInterface(); testSet = iface.create(""PhotosetsInterfaceTest"", ""JUnit test, should be deleted"", setPics.get(0)); iface.addPhoto(testSet.getId(), setPics.get(1)); iface.addPhoto(testSet.getId(), setPics.get(2)); } @After
    public void tearDown() throws FlickrException { setAuth(Permission.DELETE); PhotosetsInterface iface = flickr.getPhotosetsInterface(); iface.delete(testSet.getId()); } @Test
    public void testCreateAndDelete() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); Photoset photoset = iface.create(""test"", ""A test photoset"", testProperties.getPhotoId()); assertNotNull(photoset); assertNotNull(photoset.getId()); assertNotNull(photoset.getUrl()); iface.delete(photoset.getId()); } @Test
    public void testEditMeta() { } @Test
    public void testEditPhotos() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); iface.editPhotos(testSet.getId(), testProperties.getPhotoId(), setPics.toArray(new String[setPics.size()])); Photoset ps = iface.getInfo(testSet.getId()); assertNotNull(ps); assertEquals(testProperties.getPhotoId(), ps.getPrimaryPhoto().getId()); assertTrue(ps.getPhotoCount() >= 2); } @Test
    public void testGetContext() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); PhotoContext photoContext = iface.getContext(testProperties.getPhotoId(), testProperties.getPhotosetId()); Photo previousPhoto = photoContext.getPreviousPhoto(); Photo nextPhoto = photoContext.getNextPhoto(); assertNotNull(previousPhoto); assertNotNull(nextPhoto); } @Test
    public void testGetInfo() throws FlickrException { clearAuth(); PhotosetsInterface iface = flickr.getPhotosetsInterface(); Photoset photoset = iface.getInfo(testProperties.getPhotosetId()); <FILL_ME> assertNotNull(photoset); assertNotNull(photoset.getPrimaryPhoto()); assertTrue(photoset.getPhotoCount() >= 1); } @Test
    public void testGetList() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); Photosets photosets = iface.getList(testProperties.getNsid()); assertNotNull(photosets); assertFalse(photosets.getPhotosets().isEmpty()); } @Test
    public void testGetListWithExtras() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); Photosets photosets = iface.getList(testProperties.getNsid(), ""last_update, owner_name""); assertNotNull(photosets); Collection<Photoset> photosetsList = photosets.getPhotosets(); assertFalse(photosetsList.isEmpty()); Photoset photoset = photosetsList.iterator().next(); assertNotNull(photoset.getPrimaryPhoto().getLastUpdate()); assertNotNull(photoset.getPrimaryPhoto().getOwner()); assertNotNull(photoset.getPrimaryPhoto().getOwner().getUsername()); assertTrue(photoset.getPrimaryPhoto().getOwner().getUsername().length() > 0); } @Test
    public void testGetPhotos() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); PhotoList<Photo> photos = iface.getPhotos(testProperties.getPhotosetId(), 10, 1); assertNotNull(photos); assertTrue(photos.size() >= 1); assertNotNull(photos.get(0).getOwner().getUsername()); assertNotNull(photos.get(0).getOwner().getId()); } @Test
    public void testOrderSets() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); String[] photosetIds = { testProperties.getPhotosetId() } ; iface.orderSets(photosetIds); } @Test
    public void testRemovePhotos() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); Photoset photoset = iface.create(""test"", ""A test photoset"", testProperties.getPhotoId()); PhotoList<Photo> photos = iface.getPhotos(photoset.getId(), 10, 1); assertNotNull(photos); iface.removePhoto(photoset.getId(), testProperties.getPhotoId()); try { photos = iface.getPhotos(photoset.getId(), 10, 1); } catch (FlickrException e) { } } } ","package com.flickr4java.flickr.test; 
import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.auth.Permission; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoContext; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photosets.Photoset; import com.flickr4java.flickr.photosets.Photosets; import com.flickr4java.flickr.photosets.PhotosetsInterface; import org.junit.After; import org.junit.Before; import org.junit.Test; import org.slf4j.Logger; import org.slf4j.LoggerFactory; 
import java.util.Collection; import java.util.List; 
import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue;  /**
 * @author Anthony Eden
 */ public class PhotosetsInterfaceTest extends Flickr4JavaTest {  private static Logger _log = LoggerFactory.getLogger(PhotosetsInterfaceTest.class);  private Photoset testSet;  private List<String> setPics;  @Override
    @Before
    public void setUp() throws FlickrException { super.setUp();  setPics = testProperties.getPhotosetPhotos();  PhotosetsInterface iface = flickr.getPhotosetsInterface(); testSet = iface.create(""PhotosetsInterfaceTest"", ""JUnit test, should be deleted"", setPics.get(0)); iface.addPhoto(testSet.getId(), setPics.get(1)); iface.addPhoto(testSet.getId(), setPics.get(2)); }  @After
    public void tearDown() throws FlickrException { setAuth(Permission.DELETE);  PhotosetsInterface iface = flickr.getPhotosetsInterface(); iface.delete(testSet.getId()); }  @Test
    public void testCreateAndDelete() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); Photoset photoset = iface.create(""test"", ""A test photoset"", testProperties.getPhotoId()); assertNotNull(photoset); assertNotNull(photoset.getId()); assertNotNull(photoset.getUrl()); iface.delete(photoset.getId()); }  @Test
    public void testEditMeta() {  }  @Test
    public void testEditPhotos() throws FlickrException {  PhotosetsInterface iface = flickr.getPhotosetsInterface();  iface.editPhotos(testSet.getId(), testProperties.getPhotoId(), setPics.toArray(new String[setPics.size()]));  Photoset ps = iface.getInfo(testSet.getId()); assertNotNull(ps); assertEquals(testProperties.getPhotoId(), ps.getPrimaryPhoto().getId()); assertTrue(ps.getPhotoCount() >= 2); }  @Test
    public void testGetContext() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); PhotoContext photoContext = iface.getContext(testProperties.getPhotoId(), testProperties.getPhotosetId()); Photo previousPhoto = photoContext.getPreviousPhoto(); Photo nextPhoto = photoContext.getNextPhoto(); assertNotNull(previousPhoto); assertNotNull(nextPhoto); }  @Test
    public void testGetInfo() throws FlickrException { clearAuth();  PhotosetsInterface iface = flickr.getPhotosetsInterface(); Photoset photoset = iface.getInfo(testProperties.getPhotosetId()); <FILL_ME> assertNotNull(photoset); assertNotNull(photoset.getPrimaryPhoto()); assertTrue(photoset.getPhotoCount() >= 1); }  @Test
    public void testGetList() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); Photosets photosets = iface.getList(testProperties.getNsid()); assertNotNull(photosets); assertFalse(photosets.getPhotosets().isEmpty()); }  @Test
    public void testGetListWithExtras() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); Photosets photosets = iface.getList(testProperties.getNsid(), ""last_update, owner_name""); assertNotNull(photosets); Collection<Photoset> photosetsList = photosets.getPhotosets(); assertFalse(photosetsList.isEmpty()); Photoset photoset = photosetsList.iterator().next(); assertNotNull(photoset.getPrimaryPhoto().getLastUpdate()); assertNotNull(photoset.getPrimaryPhoto().getOwner()); assertNotNull(photoset.getPrimaryPhoto().getOwner().getUsername()); assertTrue(photoset.getPrimaryPhoto().getOwner().getUsername().length() > 0); }  @Test
    public void testGetPhotos() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); PhotoList<Photo> photos = iface.getPhotos(testProperties.getPhotosetId(), 10, 1); assertNotNull(photos); assertTrue(photos.size() >= 1); assertNotNull(photos.get(0).getOwner().getUsername()); assertNotNull(photos.get(0).getOwner().getId()); }  @Test
    public void testOrderSets() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); String[] photosetIds = { testProperties.getPhotosetId() } ; iface.orderSets(photosetIds); }  /*
     * @Test public void testRemovePhoto() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); String[] photosetIds =
     * {testProperties.getPhotoSetId()}; iface.orderSets(photosetIds); }
     */ @Test
    public void testRemovePhotos() throws FlickrException { PhotosetsInterface iface = flickr.getPhotosetsInterface(); Photoset photoset = iface.create(""test"", ""A test photoset"", testProperties.getPhotoId());  PhotoList<Photo> photos = iface.getPhotos(photoset.getId(), 10, 1); assertNotNull(photos);  iface.removePhoto(photoset.getId(), testProperties.getPhotoId());  try { photos = iface.getPhotos(photoset.getId(), 10, 1); } catch (FlickrException e) { // photoset should be nuked when the only photo is removed from it } } }  "
src/test/java/com/flickr4java/flickr/test/PlacesInterfaceTest.java,"package com.flickr4java.flickr.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import com.flickr4java.flickr.Flickr;
import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.places.Location;
import com.flickr4java.flickr.places.Place;
import com.flickr4java.flickr.places.PlaceType;
import com.flickr4java.flickr.places.PlacesInterface;
import com.flickr4java.flickr.places.PlacesList;
import com.flickr4java.flickr.tags.Tag;

import org.junit.Ignore;
import org.junit.Test;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;

/**
 * Tests for the PlacesInterface.
 * 
 * @author mago
 * @version $Id: PlacesInterfaceTest.java,v 1.11 2009/07/11 20:30:27 x-mago Exp $
 */
public class PlacesInterfaceTest extends Flickr4JavaTest {
    String sfWoeId = ""2487956"";

    @Test
    @Ignore
    // This Flickr API method no longer seems to work correctly
    public void testFindByLonLat() throws FlickrException {
        PlacesInterface placesInterface = flickr.getPlacesInterface();
        PlacesList<Place> list = placesInterface.findByLatLon(52.524577D, 13.412247D, Flickr.ACCURACY_CITY);
        assertTrue(list.getTotal() == 1);
        Place place = list.get(0);
        assertNotNull(place.getPlaceType());
        assertNotNull(place.getWoeId());
        assertNotNull(place.getLatitude());
        assertNotNull(place.getLongitude());
    }

    @Test
    @Ignore
    // This Flickr API method no longer seems to work correctly
    public void testFindAlabama() throws FlickrException {
        PlacesInterface placesInterface = flickr.getPlacesInterface();
        PlacesList<Place> list = placesInterface.find(""Alabama"");
        Place place = list.get(0);
        assertEquals(""KSb302RTUb74OxqL"", place.getPlaceId());
        assertEquals(""/United+States/Alabama"", place.getPlaceUrl());
        assertEquals(Place.TYPE_REGION, place.getPlaceType());
    }

    @SuppressWarnings(""deprecation"")
    @Test
    @Ignore
    // This Flickr API method no longer seems to work correctly
    public void testResolvePlaceId() throws FlickrException {
        PlacesInterface placesInterface = flickr.getPlacesInterface();
        Location location = placesInterface.resolvePlaceId(""7.MJR8tTVrIO1EgB""); // SF
        placeAssertions(location);
    }

    @SuppressWarnings(""deprecation"")
    @Test
    @Ignore
    // This Flickr API method no longer seems to work correctly
    public void testResolvePlaceUrl() throws FlickrException {
        PlacesInterface placesInterface = flickr.getPlacesInterface();
        Location location = placesInterface.resolvePlaceURL(""/United+States/California/San+Francisco"");
        placeAssertions(location);
    }

    @Test
    @Ignore
    // This Flickr API method no longer seems to work correctly
    public void testGetChildrenWithPhotosPublic() throws FlickrException {
        PlacesInterface placesInterface = flickr.getPlacesInterface();
        String woeId = ""2487956"";
        String placeId = ""kH8dLOubBZRvX_YZ"";
        PlacesList<Place> list = placesInterface.getChildrenWithPhotosPublic(placeId, woeId);
        boolean presidioFound = false;
        for (Place place : list) {
            // System.out.println(place.getName());
            if (place.getPlaceId().equals(""7bgsk3lTWrhSWp2fUQ"")) {
                assertEquals(""Fisherman's Wharf, San Francisco, CA, US, United States"", place.getName());
                presidioFound = true;
            }
        }
        assertTrue(presidioFound);
        assertTrue(list.size() > 40);
    }

    @Test
    public void testGetInfo() throws FlickrException {
        PlacesInterface placesInterface = flickr.getPlacesInterface();
        String woeId = ""2487956"";
        String placeId = ""7.MJR8tTVrIO1EgB"";
        Location loc = placesInterface.getInfo(woeId, null);
        assertEquals(""San Francisco,"", loc.getName());
    }

    @Test
    @Ignore
    // This Flickr API method no longer seems to work correctly
    public void testGetInfoByUrl() throws FlickrException {
        PlacesInterface placesInterface = flickr.getPlacesInterface();
        String placeId = ""7.MJR8tTVrIO1EgB"";
        String url = ""/United+States/California/San+Francisco"";
        Location loc = placesInterface.getInfoByUrl(url);
        assertEquals(loc.getPlaceId(), placeId);
    }

    @Test
    public void testGetPlaceTypes() throws FlickrException {
        PlacesInterface placesInterface = flickr.getPlacesInterface();
        List<PlaceType> placeTypes = placesInterface.getPlaceTypes();
        boolean neighbourhoodFound = false;
        boolean regionFound = false;
        for (int i = 0; i < placeTypes.size(); i++) {
            PlaceType placeType = placeTypes.get(i);
            if (placeType.getPlaceTypeName().equals(""neighbourhood"") && placeType.getPlaceTypeId() == 22) {
                neighbourhoodFound = true;
            }
            if (placeType.getPlaceTypeName().equals(""region"") && placeType.getPlaceTypeId() == 8) {
                regionFound = true;
            }
            // System.out.println(placeType.getPlaceTypeName() + "" "" + placeType.getPlaceTypeId());
        }
        assertTrue(neighbourhoodFound);
        assertTrue(regionFound);
        assertTrue(placeTypes.size() > 5);
    }

    @Test
    public void testGetTopPlacesList() throws FlickrException {
        PlacesInterface placesInterface = flickr.getPlacesInterface();
        PlacesList<Place> places = placesInterface.getTopPlacesList(Place.TYPE_COUNTRY, null, null, sfWoeId);
        assertNotNull(places);
    }

    @Test
    @Ignore
    // This Flickr API method no longer seems to work correctly
    public void testPlacesForBoundingBox() throws FlickrException {
        PlacesInterface placesInterface = flickr.getPlacesInterface();
        String bbox = ""-122.42307100000001,37.773779,-122.381071,37.815779"";
        int placeType = Place.TYPE_LOCALITY;
        PlacesList<Place> places = placesInterface.placesForBoundingBox(placeType, bbox);
        assertTrue((places.size() > 0));
        Place place = places.get(0);
        assertNotNull(place.getWoeId());
        assertNotNull(place.getPlaceId());
        assertNotNull(place.getPlaceUrl());
        assertNotNull(place.getPlaceType());
    }

    @Test
    @Ignore
    // This Flickr API method no longer seems to work correctly
    public void testPlacesForContacts() throws FlickrException {
        PlacesInterface placesInterface = flickr.getPlacesInterface();
        int placeType = Place.TYPE_REGION;
        String placeId = null;
        String woeId = null;
        String threshold = null;
        String contacts = ""all"";
        PlacesList<Place> places = placesInterface.placesForContacts(placeType, placeId, woeId, threshold, contacts);
        assertTrue((places.size() > 0));
        for (int i = 0; i < places.size(); i++) {
            Place place = places.get(i);
            assertTrue(place.getPhotoCount() > 0);
            // System.out.println(place.getName() + "" "" + place.getPlaceUrl());
        }
    }

    @Test
    @Ignore
    // This Flickr API method no longer seems to work correctly
    public void testPlacesForTags() throws FlickrException {
        PlacesInterface placesInterface = flickr.getPlacesInterface();
        int placeTypeId = Place.TYPE_REGION;
        String placeId = null;
        String threshold = ""4"";
        String[] tags = { ""sunny"", ""urban"" };
        String tagMode = ""any"";
        String machineTags = null;
        String machineTagMode = null;
        Calendar minUploadDate = Calendar.getInstance();
        Calendar maxUploadDate = Calendar.getInstance();
        Calendar minTakenDate = Calendar.getInstance();
        Calendar maxTakenDate = Calendar.getInstance();
        minUploadDate.roll(Calendar.YEAR, -3);
        minTakenDate.roll(Calendar.YEAR, -3);
        PlacesList<Place> places = placesInterface.placesForTags(placeTypeId, sfWoeId, placeId, threshold, tags, tagMode, machineTags, machineTagMode,
                minUploadDate.getTime(), maxUploadDate.getTime(), minTakenDate.getTime(), maxTakenDate.getTime());
        assertTrue((places.size() == 1));
        Place place = places.get(0);
        assertEquals(""NsbUWfBTUb4mbyVu"", place.getPlaceId());
        assertEquals(Place.TYPE_REGION, place.getPlaceType());
        assertEquals(""/United+States/California"", place.getPlaceUrl());
    }

    @Test
    @Ignore
    // This Flickr API method no longer seems to work correctly
    public void testPlacesForUser() throws FlickrException {
        PlacesInterface placesInterface = flickr.getPlacesInterface();
        int placeType = Place.TYPE_REGION;
        String placeId = null;
        String woeId = null;
        String threshold = null;
        Calendar minUploadDate = Calendar.getInstance();
        Calendar maxUploadDate = Calendar.getInstance();
        Calendar minTakenDate = Calendar.getInstance();
        Calendar maxTakenDate = Calendar.getInstance();
        minUploadDate.roll(Calendar.YEAR, -10);
        minTakenDate.roll(Calendar.YEAR, -10);
        PlacesList<Place> places = placesInterface.placesForUser(placeType, woeId, placeId, threshold, minUploadDate.getTime(), maxUploadDate.getTime(),
                minTakenDate.getTime(), maxTakenDate.getTime());
        assertTrue((places.size() > 0));
        for (Place place : places) {
            assertNotNull(place);
        }
    }

    @Test
    public void testTagsForPlace() throws FlickrException {
        PlacesInterface placesInterface = flickr.getPlacesInterface();
        String placeId = null;
        Calendar minUploadDate = Calendar.getInstance();
        Calendar maxUploadDate = Calendar.getInstance();
        Calendar minTakenDate = Calendar.getInstance();
        Calendar maxTakenDate = Calendar.getInstance();
        minUploadDate.roll(Calendar.YEAR, -5);
        minTakenDate.roll(Calendar.YEAR, -5);
        ArrayList<Tag> tags = placesInterface.tagsForPlace(sfWoeId, placeId, minUploadDate.getTime(), maxUploadDate.getTime(), minTakenDate.getTime(),
                maxTakenDate.getTime());
        assertTrue((tags.size() > 0));
    }

    private void placeAssertions(Location location) {
        assertEquals(""7.MJR8tTVrIO1EgB"", location.getPlaceId());
        assertEquals(""/United+States/California/San+Francisco"", location.getPlaceUrl());
        assertEquals(""2487956"", location.getWoeId());
        assertNotNull(location.getLatitude());
        assertNotNull(location.getLongitude());
        assertNotNull(location.getPlaceType());

        assertEquals(""7.MJR8tTVrIO1EgB"", location.getLocality().getPlaceId());
        assertEquals(""San Francisco, California, United States"", location.getLocality().getName());
        assertEquals(""2487956"", location.getLocality().getWoeId());
        assertNotNull(location.getLocality().getLatitude());
        assertNotNull(location.getLocality().getLongitude());

        assertEquals("".7sOmlRQUL9nK.kMzA"", location.getCounty().getPlaceId());
        assertEquals(""San Francisco County, California, United States"", location.getCounty().getName());
        assertEquals(""12587707"", location.getCounty().getWoeId());
        assertEquals(37.767D, location.getCounty().getLatitude(), 0d);
        assertEquals(-122.443D, location.getCounty().getLongitude(), 0d);

        assertEquals(""NsbUWfBTUb4mbyVu"", location.getRegion().getPlaceId());
        assertEquals(""California, United States"", location.getRegion().getName());
        assertEquals(""2347563"", location.getRegion().getWoeId());
        assertEquals(37.271D, location.getRegion().getLatitude(), 0d);
        assertEquals(-119.270D, location.getRegion().getLongitude(), 0d);

        assertEquals(""nz.gsghTUb4c2WAecA"", location.getCountry().getPlaceId());
        assertEquals(""United States"", location.getCountry().getName());
        assertEquals(""23424977"", location.getCountry().getWoeId());
        assertEquals(37.167D, location.getCountry().getLatitude(), 0d);
        assertEquals(-95.845D, location.getCountry().getLongitude(), 0d);
    }
}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.places.Location; import com.flickr4java.flickr.places.Place; import com.flickr4java.flickr.places.PlaceType; import com.flickr4java.flickr.places.PlacesInterface; import com.flickr4java.flickr.places.PlacesList; import com.flickr4java.flickr.tags.Tag; import org.junit.Ignore; import org.junit.Test; import java.util.ArrayList; import java.util.Calendar; import java.util.List; public class PlacesInterfaceTest extends Flickr4JavaTest { String sfWoeId = ""2487956""; public void testFindByLonLat() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); PlacesList<Place> list = placesInterface.findByLatLon(52.524577D, 13.412247D, Flickr.ACCURACY_CITY); assertTrue(list.getTotal() == 1); Place place = list.get(0); assertNotNull(place.getPlaceType()); assertNotNull(place.getWoeId()); assertNotNull(place.getLatitude()); assertNotNull(place.getLongitude()); } public void testFindAlabama() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); PlacesList<Place> list = placesInterface.find(""Alabama""); Place place = list.get(0); assertEquals(""KSb302RTUb74OxqL"", place.getPlaceId()); assertEquals(""/United+States/Alabama"", place.getPlaceUrl()); assertEquals(Place.TYPE_REGION, place.getPlaceType()); } public void testResolvePlaceId() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); Location location = placesInterface.resolvePlaceId(""7.MJR8tTVrIO1EgB""); placeAssertions(location); } public void testResolvePlaceUrl() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); Location location = placesInterface.resolvePlaceURL(""/United+States/California/San+Francisco""); placeAssertions(location); } public void testGetChildrenWithPhotosPublic() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); String woeId = ""2487956""; String placeId = ""kH8dLOubBZRvX_YZ""; PlacesList<Place> list = placesInterface.getChildrenWithPhotosPublic(placeId, woeId); boolean presidioFound = false; for (Place place : list) { if (place.getPlaceId().equals(""7bgsk3lTWrhSWp2fUQ"")) { assertEquals(""Fisherman's Wharf, San Francisco, CA, US, United States"", place.getName()); presidioFound = true; } } assertTrue(presidioFound); assertTrue(list.size() > 40); } @Test
    public void testGetInfo() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); String woeId = ""2487956""; String placeId = ""7.MJR8tTVrIO1EgB""; Location loc = placesInterface.getInfo(woeId, null); assertEquals(""San Francisco,"", loc.getName()); } public void testGetInfoByUrl() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); String placeId = ""7.MJR8tTVrIO1EgB""; String url = ""/United+States/California/San+Francisco""; Location loc = placesInterface.getInfoByUrl(url); assertEquals(loc.getPlaceId(), placeId); } @Test
    public void testGetPlaceTypes() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); List<PlaceType> placeTypes = placesInterface.getPlaceTypes(); boolean neighbourhoodFound = false; boolean regionFound = false; for (int i = 0; i < placeTypes.size(); i++) { PlaceType placeType = placeTypes.get(i); if (placeType.getPlaceTypeName().equals(""neighbourhood"") && placeType.getPlaceTypeId() == 22) { neighbourhoodFound = true; } if (placeType.getPlaceTypeName().equals(""region"") && placeType.getPlaceTypeId() == 8) { regionFound = true; } } assertTrue(neighbourhoodFound); assertTrue(regionFound); assertTrue(placeTypes.size() > 5); } @Test
    public void testGetTopPlacesList() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); PlacesList<Place> places = placesInterface.getTopPlacesList(Place.TYPE_COUNTRY, null, null, sfWoeId); assertNotNull(places); } public void testPlacesForBoundingBox() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); String bbox = ""-122.42307100000001,37.773779,-122.381071,37.815779""; int placeType = Place.TYPE_LOCALITY; PlacesList<Place> places = placesInterface.placesForBoundingBox(placeType, bbox); assertTrue((places.size() > 0)); Place place = places.get(0); assertNotNull(place.getWoeId()); assertNotNull(place.getPlaceId()); assertNotNull(place.getPlaceUrl()); assertNotNull(place.getPlaceType()); } public void testPlacesForContacts() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); int placeType = Place.TYPE_REGION; String placeId = null; String woeId = null; String threshold = null; String contacts = ""all""; PlacesList<Place> places = placesInterface.placesForContacts(placeType, placeId, woeId, threshold, contacts); assertTrue((places.size() > 0)); for (int i = 0; i < places.size(); i++) { Place place = places.get(i); assertTrue(place.getPhotoCount() > 0); } } public void testPlacesForTags() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); int placeTypeId = Place.TYPE_REGION; String placeId = null; String threshold = ""4""; String[] tags = { ""sunny"", ""urban"" } ; String tagMode = ""any""; String machineTags = null; String machineTagMode = null; Calendar minUploadDate = Calendar.getInstance(); Calendar maxUploadDate = Calendar.getInstance(); Calendar minTakenDate = Calendar.getInstance(); Calendar maxTakenDate = Calendar.getInstance(); minUploadDate.roll(Calendar.YEAR, -3); minTakenDate.roll(Calendar.YEAR, -3); PlacesList<Place> places = placesInterface.placesForTags(placeTypeId, sfWoeId, placeId, threshold, tags, tagMode, machineTags, machineTagMode,
                minUploadDate.getTime(), maxUploadDate.getTime(), minTakenDate.getTime(), maxTakenDate.getTime()); assertTrue((places.size() == 1)); Place place = places.get(0); assertEquals(""NsbUWfBTUb4mbyVu"", place.getPlaceId()); assertEquals(Place.TYPE_REGION, place.getPlaceType()); assertEquals(""/United+States/California"", place.getPlaceUrl()); } public void testPlacesForUser() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); int placeType = Place.TYPE_REGION; String placeId = null; String woeId = null; String threshold = null; Calendar minUploadDate = Calendar.getInstance(); Calendar maxUploadDate = Calendar.getInstance(); Calendar minTakenDate = Calendar.getInstance(); Calendar maxTakenDate = Calendar.getInstance(); minUploadDate.roll(Calendar.YEAR, -10); minTakenDate.roll(Calendar.YEAR, -10); PlacesList<Place> places = placesInterface.placesForUser(placeType, woeId, placeId, threshold, minUploadDate.getTime(), maxUploadDate.getTime(),
                minTakenDate.getTime(), maxTakenDate.getTime()); assertTrue((places.size() > 0)); for (Place place : places) { assertNotNull(place); } } @Test
    public void testTagsForPlace() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); String placeId = null; Calendar minUploadDate = Calendar.getInstance(); Calendar maxUploadDate = Calendar.getInstance(); Calendar minTakenDate = Calendar.getInstance(); Calendar maxTakenDate = Calendar.getInstance(); minUploadDate.roll(Calendar.YEAR, -5); minTakenDate.roll(Calendar.YEAR, -5); ArrayList<Tag> tags = placesInterface.tagsForPlace(sfWoeId, placeId, minUploadDate.getTime(), maxUploadDate.getTime(), minTakenDate.getTime(),
                maxTakenDate.getTime()); assertTrue((tags.size() > 0)); } private void placeAssertions(Location location) { assertEquals(""7.MJR8tTVrIO1EgB"", location.getPlaceId()); assertEquals(""/United+States/California/San+Francisco"", location.getPlaceUrl()); assertEquals(""2487956"", location.getWoeId()); assertNotNull(location.getLatitude()); assertNotNull(location.getLongitude()); assertNotNull(location.getPlaceType()); assertEquals(""7.MJR8tTVrIO1EgB"", location.getLocality().getPlaceId()); assertEquals(""San Francisco, California, United States"", location.getLocality().getName()); assertEquals(""2487956"", location.getLocality().getWoeId()); assertNotNull(location.getLocality().getLatitude()); assertNotNull(location.getLocality().getLongitude()); assertEquals("".7sOmlRQUL9nK.kMzA"", location.getCounty().getPlaceId()); assertEquals(""San Francisco County, California, United States"", location.getCounty().getName()); assertEquals(""12587707"", location.getCounty().getWoeId()); assertEquals(37.767D, location.getCounty().getLatitude(), 0d); assertEquals(-122.443D, location.getCounty().getLongitude(), 0d); assertEquals(""NsbUWfBTUb4mbyVu"", location.getRegion().getPlaceId()); assertEquals(""California, United States"", location.getRegion().getName()); assertEquals(""2347563"", location.getRegion().getWoeId()); assertEquals(37.271D, location.getRegion().getLatitude(), 0d); assertEquals(-119.270D, location.getRegion().getLongitude(), 0d); assertEquals(""nz.gsghTUb4c2WAecA"", location.getCountry().getPlaceId()); assertEquals(""United States"", location.getCountry().getName()); assertEquals(""23424977"", location.getCountry().getWoeId()); assertEquals(37.167D, location.getCountry().getLatitude(), 0d); assertEquals(-95.845D, location.getCountry().getLongitude(), 0d); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.places.Location; import com.flickr4java.flickr.places.Place; import com.flickr4java.flickr.places.PlaceType; import com.flickr4java.flickr.places.PlacesInterface; import com.flickr4java.flickr.places.PlacesList; import com.flickr4java.flickr.tags.Tag; import org.junit.Ignore; import org.junit.Test; import java.util.ArrayList; import java.util.Calendar; import java.util.List; public class PlacesInterfaceTest extends Flickr4JavaTest { String sfWoeId = ""2487956""; public void testFindByLonLat() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); PlacesList<Place> list = placesInterface.findByLatLon(52.524577D, 13.412247D, Flickr.ACCURACY_CITY); assertTrue(list.getTotal() == 1); Place place = list.get(0); assertNotNull(place.getPlaceType()); assertNotNull(place.getWoeId()); assertNotNull(place.getLatitude()); assertNotNull(place.getLongitude()); } public void testFindAlabama() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); PlacesList<Place> list = placesInterface.find(""Alabama""); Place place = list.get(0); assertEquals(""KSb302RTUb74OxqL"", place.getPlaceId()); assertEquals(""/United+States/Alabama"", place.getPlaceUrl()); assertEquals(Place.TYPE_REGION, place.getPlaceType()); } public void testResolvePlaceId() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); Location location = placesInterface.resolvePlaceId(""7.MJR8tTVrIO1EgB""); placeAssertions(location); } public void testResolvePlaceUrl() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); Location location = placesInterface.resolvePlaceURL(""/United+States/California/San+Francisco""); placeAssertions(location); } public void testGetChildrenWithPhotosPublic() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); String woeId = ""2487956""; String placeId = ""kH8dLOubBZRvX_YZ""; PlacesList<Place> list = placesInterface.getChildrenWithPhotosPublic(placeId, woeId); boolean presidioFound = false; for (Place place : list) { if (place.getPlaceId().equals(""7bgsk3lTWrhSWp2fUQ"")) { assertEquals(""Fisherman's Wharf, San Francisco, CA, US, United States"", place.getName()); presidioFound = true; } } assertTrue(presidioFound); assertTrue(list.size() > 40); } @Test
    public void testGetInfo() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); String woeId = ""2487956""; String placeId = ""7.MJR8tTVrIO1EgB""; Location loc = placesInterface.getInfo(woeId, null); assertEquals(""San Francisco,"", loc.getName()); } public void testGetInfoByUrl() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); String placeId = ""7.MJR8tTVrIO1EgB""; String url = ""/United+States/California/San+Francisco""; Location loc = placesInterface.getInfoByUrl(url); assertEquals(loc.getPlaceId(), placeId); } @Test
    public void testGetPlaceTypes() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); List<PlaceType> placeTypes = placesInterface.getPlaceTypes(); boolean neighbourhoodFound = false; boolean regionFound = false; for (int i = 0; i < placeTypes.size(); i++) { PlaceType placeType = placeTypes.get(i); if (placeType.getPlaceTypeName().equals(""neighbourhood"") && placeType.getPlaceTypeId() == 22) { neighbourhoodFound = true; } if (placeType.getPlaceTypeName().equals(""region"") && placeType.getPlaceTypeId() == 8) { regionFound = true; } } assertTrue(neighbourhoodFound); assertTrue(regionFound); assertTrue(placeTypes.size() > 5); } @Test
    public void testGetTopPlacesList() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); PlacesList<Place> places = placesInterface.getTopPlacesList(Place.TYPE_COUNTRY, null, null, sfWoeId); assertNotNull(places); } public void testPlacesForBoundingBox() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); String bbox = ""-122.42307100000001,37.773779,-122.381071,37.815779""; int placeType = Place.TYPE_LOCALITY; PlacesList<Place> places = placesInterface.placesForBoundingBox(placeType, bbox); assertTrue((places.size() > 0)); Place place = places.get(0); assertNotNull(place.getWoeId()); assertNotNull(place.getPlaceId()); assertNotNull(place.getPlaceUrl()); assertNotNull(place.getPlaceType()); } public void testPlacesForContacts() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); int placeType = Place.TYPE_REGION; String placeId = null; String woeId = null; String threshold = null; String contacts = ""all""; PlacesList<Place> places = placesInterface.placesForContacts(placeType, placeId, woeId, threshold, contacts); assertTrue((places.size() > 0)); for (int i = 0; i < places.size(); i++) { Place place = places.get(i); assertTrue(place.getPhotoCount() > 0); } } public void testPlacesForTags() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); int placeTypeId = Place.TYPE_REGION; String placeId = null; String threshold = ""4""; String[] tags = { ""sunny"", ""urban"" } ; String tagMode = ""any""; String machineTags = null; String machineTagMode = null; Calendar minUploadDate = Calendar.getInstance(); Calendar maxUploadDate = Calendar.getInstance(); Calendar minTakenDate = Calendar.getInstance(); Calendar maxTakenDate = Calendar.getInstance(); minUploadDate.roll(Calendar.YEAR, -3); minTakenDate.roll(Calendar.YEAR, -3); PlacesList<Place> places = placesInterface.placesForTags(placeTypeId, sfWoeId, placeId, threshold, tags, tagMode, machineTags, machineTagMode,
                minUploadDate.getTime(), maxUploadDate.getTime(), minTakenDate.getTime(), maxTakenDate.getTime()); assertTrue((places.size() == 1)); Place place = places.get(0); assertEquals(""NsbUWfBTUb4mbyVu"", place.getPlaceId()); assertEquals(Place.TYPE_REGION, place.getPlaceType()); assertEquals(""/United+States/California"", place.getPlaceUrl()); } public void testPlacesForUser() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); int placeType = Place.TYPE_REGION; String placeId = null; String woeId = null; String threshold = null; Calendar minUploadDate = Calendar.getInstance(); Calendar maxUploadDate = Calendar.getInstance(); Calendar minTakenDate = Calendar.getInstance(); Calendar maxTakenDate = Calendar.getInstance(); minUploadDate.roll(Calendar.YEAR, -10); minTakenDate.roll(Calendar.YEAR, -10); PlacesList<Place> places = placesInterface.placesForUser(placeType, woeId, placeId, threshold, minUploadDate.getTime(), maxUploadDate.getTime(),
                minTakenDate.getTime(), maxTakenDate.getTime()); assertTrue((places.size() > 0)); for (Place place : places) { assertNotNull(place); } } @Test
    public void testTagsForPlace() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); String placeId = null; Calendar minUploadDate = Calendar.getInstance(); Calendar maxUploadDate = Calendar.getInstance(); Calendar minTakenDate = Calendar.getInstance(); Calendar maxTakenDate = Calendar.getInstance(); minUploadDate.roll(Calendar.YEAR, -5); minTakenDate.roll(Calendar.YEAR, -5); ArrayList<Tag> tags = placesInterface.tagsForPlace(sfWoeId, placeId, minUploadDate.getTime(), maxUploadDate.getTime(), minTakenDate.getTime(),
                maxTakenDate.getTime()); assertTrue((tags.size() > 0)); } private void placeAssertions(Location location) { assertEquals(""7.MJR8tTVrIO1EgB"", location.getPlaceId()); assertEquals(""/United+States/California/San+Francisco"", location.getPlaceUrl()); assertEquals(""2487956"", location.getWoeId()); assertNotNull(location.getLatitude()); assertNotNull(location.getLongitude()); assertNotNull(location.getPlaceType()); assertEquals(""7.MJR8tTVrIO1EgB"", location.getLocality().getPlaceId()); assertEquals(""San Francisco, California, United States"", location.getLocality().getName()); assertEquals(""2487956"", location.getLocality().getWoeId()); assertNotNull(location.getLocality().getLatitude()); assertNotNull(location.getLocality().getLongitude()); assertEquals("".7sOmlRQUL9nK.kMzA"", location.getCounty().getPlaceId()); assertEquals(""San Francisco County, California, United States"", location.getCounty().getName()); assertEquals(""12587707"", location.getCounty().getWoeId()); assertEquals(37.767D, location.getCounty().getLatitude(), 0d); assertEquals(-122.443D, location.getCounty().getLongitude(), 0d); assertEquals(""NsbUWfBTUb4mbyVu"", location.getRegion().getPlaceId()); assertEquals(""California, United States"", location.getRegion().getName()); assertEquals(""2347563"", location.getRegion().getWoeId()); assertEquals(37.271D, location.getRegion().getLatitude(), 0d); assertEquals(-119.270D, location.getRegion().getLongitude(), 0d); assertEquals(""nz.gsghTUb4c2WAecA"", location.getCountry().getPlaceId()); assertEquals(""United States"", location.getCountry().getName()); assertEquals(""23424977"", location.getCountry().getWoeId()); assertEquals(37.167D, location.getCountry().getLatitude(), 0d); assertEquals(-95.845D, location.getCountry().getLongitude(), 0d); } } ","package com.flickr4java.flickr.test;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue;  import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.places.Location; import com.flickr4java.flickr.places.Place; import com.flickr4java.flickr.places.PlaceType; import com.flickr4java.flickr.places.PlacesInterface; import com.flickr4java.flickr.places.PlacesList; import com.flickr4java.flickr.tags.Tag;  import org.junit.Ignore; import org.junit.Test;  import java.util.ArrayList; import java.util.Calendar; import java.util.List;  /**
 * Tests for the PlacesInterface.
 * 
 * @author mago
 * @version $Id: PlacesInterfaceTest.java,v 1.11 2009/07/11 20:30:27 x-mago Exp $
 */ public class PlacesInterfaceTest extends Flickr4JavaTest { String sfWoeId = ""2487956"";  // This Flickr API method no longer seems to work correctly public void testFindByLonLat() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); PlacesList<Place> list = placesInterface.findByLatLon(52.524577D, 13.412247D, Flickr.ACCURACY_CITY); assertTrue(list.getTotal() == 1); Place place = list.get(0); assertNotNull(place.getPlaceType()); assertNotNull(place.getWoeId()); assertNotNull(place.getLatitude()); assertNotNull(place.getLongitude()); }  // This Flickr API method no longer seems to work correctly public void testFindAlabama() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); PlacesList<Place> list = placesInterface.find(""Alabama""); Place place = list.get(0); assertEquals(""KSb302RTUb74OxqL"", place.getPlaceId()); assertEquals(""/United+States/Alabama"", place.getPlaceUrl()); assertEquals(Place.TYPE_REGION, place.getPlaceType()); }  // This Flickr API method no longer seems to work correctly public void testResolvePlaceId() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); Location location = placesInterface.resolvePlaceId(""7.MJR8tTVrIO1EgB""); // SF placeAssertions(location); }  // This Flickr API method no longer seems to work correctly public void testResolvePlaceUrl() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); Location location = placesInterface.resolvePlaceURL(""/United+States/California/San+Francisco""); placeAssertions(location); }  // This Flickr API method no longer seems to work correctly public void testGetChildrenWithPhotosPublic() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); String woeId = ""2487956""; String placeId = ""kH8dLOubBZRvX_YZ""; PlacesList<Place> list = placesInterface.getChildrenWithPhotosPublic(placeId, woeId); boolean presidioFound = false; for (Place place : list) { // System.out.println(place.getName()); if (place.getPlaceId().equals(""7bgsk3lTWrhSWp2fUQ"")) { assertEquals(""Fisherman's Wharf, San Francisco, CA, US, United States"", place.getName()); presidioFound = true; } } assertTrue(presidioFound); assertTrue(list.size() > 40); }  @Test
    public void testGetInfo() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); String woeId = ""2487956""; String placeId = ""7.MJR8tTVrIO1EgB""; Location loc = placesInterface.getInfo(woeId, null); assertEquals(""San Francisco,"", loc.getName()); }  // This Flickr API method no longer seems to work correctly public void testGetInfoByUrl() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); String placeId = ""7.MJR8tTVrIO1EgB""; String url = ""/United+States/California/San+Francisco""; Location loc = placesInterface.getInfoByUrl(url); assertEquals(loc.getPlaceId(), placeId); }  @Test
    public void testGetPlaceTypes() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); List<PlaceType> placeTypes = placesInterface.getPlaceTypes(); boolean neighbourhoodFound = false; boolean regionFound = false; for (int i = 0; i < placeTypes.size(); i++) { PlaceType placeType = placeTypes.get(i); if (placeType.getPlaceTypeName().equals(""neighbourhood"") && placeType.getPlaceTypeId() == 22) { neighbourhoodFound = true; } if (placeType.getPlaceTypeName().equals(""region"") && placeType.getPlaceTypeId() == 8) { regionFound = true; } // System.out.println(placeType.getPlaceTypeName() + "" "" + placeType.getPlaceTypeId()); } assertTrue(neighbourhoodFound); assertTrue(regionFound); assertTrue(placeTypes.size() > 5); }  @Test
    public void testGetTopPlacesList() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); PlacesList<Place> places = placesInterface.getTopPlacesList(Place.TYPE_COUNTRY, null, null, sfWoeId); assertNotNull(places); }  // This Flickr API method no longer seems to work correctly public void testPlacesForBoundingBox() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); String bbox = ""-122.42307100000001,37.773779,-122.381071,37.815779""; int placeType = Place.TYPE_LOCALITY; PlacesList<Place> places = placesInterface.placesForBoundingBox(placeType, bbox); assertTrue((places.size() > 0)); Place place = places.get(0); assertNotNull(place.getWoeId()); assertNotNull(place.getPlaceId()); assertNotNull(place.getPlaceUrl()); assertNotNull(place.getPlaceType()); }  // This Flickr API method no longer seems to work correctly public void testPlacesForContacts() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); int placeType = Place.TYPE_REGION; String placeId = null; String woeId = null; String threshold = null; String contacts = ""all""; PlacesList<Place> places = placesInterface.placesForContacts(placeType, placeId, woeId, threshold, contacts); assertTrue((places.size() > 0)); for (int i = 0; i < places.size(); i++) { Place place = places.get(i); assertTrue(place.getPhotoCount() > 0); // System.out.println(place.getName() + "" "" + place.getPlaceUrl()); } }  // This Flickr API method no longer seems to work correctly public void testPlacesForTags() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); int placeTypeId = Place.TYPE_REGION; String placeId = null; String threshold = ""4""; String[] tags = { ""sunny"", ""urban"" } ; String tagMode = ""any""; String machineTags = null; String machineTagMode = null; Calendar minUploadDate = Calendar.getInstance(); Calendar maxUploadDate = Calendar.getInstance(); Calendar minTakenDate = Calendar.getInstance(); Calendar maxTakenDate = Calendar.getInstance(); minUploadDate.roll(Calendar.YEAR, -3); minTakenDate.roll(Calendar.YEAR, -3); PlacesList<Place> places = placesInterface.placesForTags(placeTypeId, sfWoeId, placeId, threshold, tags, tagMode, machineTags, machineTagMode,
                minUploadDate.getTime(), maxUploadDate.getTime(), minTakenDate.getTime(), maxTakenDate.getTime()); assertTrue((places.size() == 1)); Place place = places.get(0); assertEquals(""NsbUWfBTUb4mbyVu"", place.getPlaceId()); assertEquals(Place.TYPE_REGION, place.getPlaceType()); assertEquals(""/United+States/California"", place.getPlaceUrl()); }  // This Flickr API method no longer seems to work correctly public void testPlacesForUser() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); int placeType = Place.TYPE_REGION; String placeId = null; String woeId = null; String threshold = null; Calendar minUploadDate = Calendar.getInstance(); Calendar maxUploadDate = Calendar.getInstance(); Calendar minTakenDate = Calendar.getInstance(); Calendar maxTakenDate = Calendar.getInstance(); minUploadDate.roll(Calendar.YEAR, -10); minTakenDate.roll(Calendar.YEAR, -10); PlacesList<Place> places = placesInterface.placesForUser(placeType, woeId, placeId, threshold, minUploadDate.getTime(), maxUploadDate.getTime(),
                minTakenDate.getTime(), maxTakenDate.getTime()); assertTrue((places.size() > 0)); for (Place place : places) { assertNotNull(place); } }  @Test
    public void testTagsForPlace() throws FlickrException { PlacesInterface placesInterface = flickr.getPlacesInterface(); String placeId = null; Calendar minUploadDate = Calendar.getInstance(); Calendar maxUploadDate = Calendar.getInstance(); Calendar minTakenDate = Calendar.getInstance(); Calendar maxTakenDate = Calendar.getInstance(); minUploadDate.roll(Calendar.YEAR, -5); minTakenDate.roll(Calendar.YEAR, -5); ArrayList<Tag> tags = placesInterface.tagsForPlace(sfWoeId, placeId, minUploadDate.getTime(), maxUploadDate.getTime(), minTakenDate.getTime(),
                maxTakenDate.getTime()); assertTrue((tags.size() > 0)); }  private void placeAssertions(Location location) { assertEquals(""7.MJR8tTVrIO1EgB"", location.getPlaceId()); assertEquals(""/United+States/California/San+Francisco"", location.getPlaceUrl()); assertEquals(""2487956"", location.getWoeId()); assertNotNull(location.getLatitude()); assertNotNull(location.getLongitude()); assertNotNull(location.getPlaceType());  assertEquals(""7.MJR8tTVrIO1EgB"", location.getLocality().getPlaceId()); assertEquals(""San Francisco, California, United States"", location.getLocality().getName()); assertEquals(""2487956"", location.getLocality().getWoeId()); assertNotNull(location.getLocality().getLatitude()); assertNotNull(location.getLocality().getLongitude());  assertEquals("".7sOmlRQUL9nK.kMzA"", location.getCounty().getPlaceId()); assertEquals(""San Francisco County, California, United States"", location.getCounty().getName()); assertEquals(""12587707"", location.getCounty().getWoeId()); assertEquals(37.767D, location.getCounty().getLatitude(), 0d); assertEquals(-122.443D, location.getCounty().getLongitude(), 0d);  assertEquals(""NsbUWfBTUb4mbyVu"", location.getRegion().getPlaceId()); assertEquals(""California, United States"", location.getRegion().getName()); assertEquals(""2347563"", location.getRegion().getWoeId()); assertEquals(37.271D, location.getRegion().getLatitude(), 0d); assertEquals(-119.270D, location.getRegion().getLongitude(), 0d);  assertEquals(""nz.gsghTUb4c2WAecA"", location.getCountry().getPlaceId()); assertEquals(""United States"", location.getCountry().getName()); assertEquals(""23424977"", location.getCountry().getWoeId()); assertEquals(37.167D, location.getCountry().getLatitude(), 0d); assertEquals(-95.845D, location.getCountry().getLongitude(), 0d); } }  "
src/test/java/com/flickr4java/flickr/test/PoolsInterfaceTest.java,"

package com.flickr4java.flickr.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.groups.Group;
import com.flickr4java.flickr.groups.pools.PoolsInterface;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoContext;

import org.junit.Test;

import java.util.Collection;

/**
 * @author Anthony Eden
 */
public class PoolsInterfaceTest extends Flickr4JavaTest {

    @Test
    public void testAddAndRemove() throws FlickrException {
        PoolsInterface iface = flickr.getPoolsInterface();
        String photoId = testProperties.getPhotoId();
        String groupId = testProperties.getTestGroupId();

        try {
            iface.add(photoId, groupId);
        } finally {
            iface.remove(photoId, groupId);
        }
    }

    @Test
    public void testGetGroups() throws FlickrException {
        PoolsInterface iface = flickr.getPoolsInterface();
        Collection<Group> groups = iface.getGroups();
        assertNotNull(groups);
        assertTrue(groups.size() >= 1);
    }

    @Test
    public void testGetPhotos() throws FlickrException {
        String groupId = testProperties.getTestGroupId();
        PoolsInterface iface = flickr.getPoolsInterface();
        Collection<Photo> photos = iface.getPhotos(groupId, null, 0, 0);
        assertNotNull(photos);
        assertEquals(0, photos.size());
    }

    @Test
    public void testGetContext() throws FlickrException {
        String groupId = testProperties.getTestGroupId();
        String photoId = testProperties.getPhotoId();
        PoolsInterface iface = flickr.getPoolsInterface();

        try {
            iface.add(photoId, groupId);
            PhotoContext photoContext = iface.getContext(photoId, groupId);
            assertNotNull(photoContext);
        } finally {
            iface.remove(photoId, groupId);
        }
    }
}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.groups.Group; import com.flickr4java.flickr.groups.pools.PoolsInterface; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoContext; import org.junit.Test; import java.util.Collection; public class PoolsInterfaceTest extends Flickr4JavaTest { @Test
    public void testAddAndRemove() throws FlickrException { PoolsInterface iface = flickr.getPoolsInterface(); String photoId = testProperties.getPhotoId(); String groupId = testProperties.getTestGroupId(); try { iface.add(photoId, groupId); } finally { iface.remove(photoId, groupId); } } @Test
    public void testGetGroups() throws FlickrException { PoolsInterface iface = flickr.getPoolsInterface(); Collection<Group> groups = iface.getGroups(); assertNotNull(groups); assertTrue(groups.size() >= 1); } @Test
    public void testGetPhotos() throws FlickrException { String groupId = testProperties.getTestGroupId(); PoolsInterface iface = flickr.getPoolsInterface(); Collection<Photo> photos = iface.getPhotos(groupId, null, 0, 0); assertNotNull(photos); assertEquals(0, photos.size()); } @Test
    public void testGetContext() throws FlickrException { String groupId = testProperties.getTestGroupId(); String photoId = testProperties.getPhotoId(); PoolsInterface iface = flickr.getPoolsInterface(); try { iface.add(photoId, groupId); PhotoContext photoContext = iface.getContext(photoId, groupId); assertNotNull(photoContext); } finally { iface.remove(photoId, groupId); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.groups.Group; import com.flickr4java.flickr.groups.pools.PoolsInterface; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoContext; import org.junit.Test; import java.util.Collection; public class PoolsInterfaceTest extends Flickr4JavaTest { @Test
    public void testAddAndRemove() throws FlickrException { PoolsInterface iface = flickr.getPoolsInterface(); String photoId = testProperties.getPhotoId(); String groupId = testProperties.getTestGroupId(); try { iface.add(photoId, groupId); } finally { iface.remove(photoId, groupId); } } @Test
    public void testGetGroups() throws FlickrException { PoolsInterface iface = flickr.getPoolsInterface(); Collection<Group> groups = iface.getGroups(); assertNotNull(groups); assertTrue(groups.size() >= 1); } @Test
    public void testGetPhotos() throws FlickrException { String groupId = testProperties.getTestGroupId(); PoolsInterface iface = flickr.getPoolsInterface(); Collection<Photo> photos = iface.getPhotos(groupId, null, 0, 0); assertNotNull(photos); assertEquals(0, photos.size()); } @Test
    public void testGetContext() throws FlickrException { String groupId = testProperties.getTestGroupId(); String photoId = testProperties.getPhotoId(); PoolsInterface iface = flickr.getPoolsInterface(); try { iface.add(photoId, groupId); PhotoContext photoContext = iface.getContext(photoId, groupId); assertNotNull(photoContext); } finally { iface.remove(photoId, groupId); } } } ","
 package com.flickr4java.flickr.test;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.groups.Group; import com.flickr4java.flickr.groups.pools.PoolsInterface; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoContext;  import org.junit.Test;  import java.util.Collection;  /**
 * @author Anthony Eden
 */ public class PoolsInterfaceTest extends Flickr4JavaTest {  @Test
    public void testAddAndRemove() throws FlickrException { PoolsInterface iface = flickr.getPoolsInterface(); String photoId = testProperties.getPhotoId(); String groupId = testProperties.getTestGroupId();  try { iface.add(photoId, groupId); } finally { iface.remove(photoId, groupId); } }  @Test
    public void testGetGroups() throws FlickrException { PoolsInterface iface = flickr.getPoolsInterface(); Collection<Group> groups = iface.getGroups(); assertNotNull(groups); assertTrue(groups.size() >= 1); }  @Test
    public void testGetPhotos() throws FlickrException { String groupId = testProperties.getTestGroupId(); PoolsInterface iface = flickr.getPoolsInterface(); Collection<Photo> photos = iface.getPhotos(groupId, null, 0, 0); assertNotNull(photos); assertEquals(0, photos.size()); }  @Test
    public void testGetContext() throws FlickrException { String groupId = testProperties.getTestGroupId(); String photoId = testProperties.getPhotoId(); PoolsInterface iface = flickr.getPoolsInterface();  try { iface.add(photoId, groupId); PhotoContext photoContext = iface.getContext(photoId, groupId); assertNotNull(photoContext); } finally { iface.remove(photoId, groupId); } } }  "
src/test/java/com/flickr4java/flickr/test/PrefsInterfaceTest.java,"package com.flickr4java.flickr.test;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

import com.flickr4java.flickr.Flickr;
import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.prefs.PrefsInterface;

/**
 * @author Martin Goebel
 * @version $Id: PrefsInterfaceTest.java,v 1.3 2008/06/28 22:30:04 x-mago Exp $
 */
public class PrefsInterfaceTest extends Flickr4JavaTest {

    @Test
    public void testGetContentType() throws FlickrException {
        PrefsInterface iface = flickr.getPrefsInterface();
        String type = iface.getContentType();
        assertTrue(type.equals(Flickr.CONTENTTYPE_OTHER) || type.equals(Flickr.CONTENTTYPE_PHOTO) || type.equals(Flickr.CONTENTTYPE_SCREENSHOT));
    }

    @Test
    public void testGetSafetyLevel() throws FlickrException {
        PrefsInterface iface = flickr.getPrefsInterface();
        String level = iface.getSafetyLevel();
        assertTrue(level.equals(Flickr.SAFETYLEVEL_SAFE) || level.equals(Flickr.SAFETYLEVEL_MODERATE) || level.equals(Flickr.SAFETYLEVEL_RESTRICTED));
    }

    @Test
    public void testGetHidden() throws FlickrException {
        PrefsInterface iface = flickr.getPrefsInterface();
        Boolean hidden = iface.getHidden();
        assertNotNull(hidden);
    }

    @Test
    public void testGetGeoPerms() throws FlickrException {
        PrefsInterface iface = flickr.getPrefsInterface();
        int geoPerm = iface.getGeoPerms();
        // check for known levels.
        if (geoPerm != Flickr.PRIVACY_LEVEL_NO_FILTER && geoPerm != Flickr.PRIVACY_LEVEL_FRIENDS && geoPerm != Flickr.PRIVACY_LEVEL_PUBLIC
                && geoPerm != Flickr.PRIVACY_LEVEL_PRIVATE && geoPerm != Flickr.PRIVACY_LEVEL_FRIENDS_FAMILY && geoPerm != Flickr.PRIVACY_LEVEL_FAMILY) {
            assertTrue(false);
        }
    }
}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import org.junit.Test; import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.prefs.PrefsInterface; public class PrefsInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetContentType() throws FlickrException { PrefsInterface iface = flickr.getPrefsInterface(); String type = iface.getContentType(); assertTrue(type.equals(Flickr.CONTENTTYPE_OTHER) || type.equals(Flickr.CONTENTTYPE_PHOTO) || type.equals(Flickr.CONTENTTYPE_SCREENSHOT)); } @Test
    public void testGetSafetyLevel() throws FlickrException { PrefsInterface iface = flickr.getPrefsInterface(); String level = iface.getSafetyLevel(); assertTrue(level.equals(Flickr.SAFETYLEVEL_SAFE) || level.equals(Flickr.SAFETYLEVEL_MODERATE) || level.equals(Flickr.SAFETYLEVEL_RESTRICTED)); } @Test
    public void testGetHidden() throws FlickrException { PrefsInterface iface = flickr.getPrefsInterface(); Boolean hidden = iface.getHidden(); assertNotNull(hidden); } @Test
    public void testGetGeoPerms() throws FlickrException { PrefsInterface iface = flickr.getPrefsInterface(); int geoPerm = iface.getGeoPerms(); if (geoPerm != Flickr.PRIVACY_LEVEL_NO_FILTER && geoPerm != Flickr.PRIVACY_LEVEL_FRIENDS && geoPerm != Flickr.PRIVACY_LEVEL_PUBLIC
                && geoPerm != Flickr.PRIVACY_LEVEL_PRIVATE && geoPerm != Flickr.PRIVACY_LEVEL_FRIENDS_FAMILY && geoPerm != Flickr.PRIVACY_LEVEL_FAMILY) { assertTrue(false); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import org.junit.Test; import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.prefs.PrefsInterface; public class PrefsInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetContentType() throws FlickrException { PrefsInterface iface = flickr.getPrefsInterface(); String type = iface.getContentType(); assertTrue(type.equals(Flickr.CONTENTTYPE_OTHER) || type.equals(Flickr.CONTENTTYPE_PHOTO) || type.equals(Flickr.CONTENTTYPE_SCREENSHOT)); } @Test
    public void testGetSafetyLevel() throws FlickrException { PrefsInterface iface = flickr.getPrefsInterface(); String level = iface.getSafetyLevel(); assertTrue(level.equals(Flickr.SAFETYLEVEL_SAFE) || level.equals(Flickr.SAFETYLEVEL_MODERATE) || level.equals(Flickr.SAFETYLEVEL_RESTRICTED)); } @Test
    public void testGetHidden() throws FlickrException { PrefsInterface iface = flickr.getPrefsInterface(); Boolean hidden = iface.getHidden(); assertNotNull(hidden); } @Test
    public void testGetGeoPerms() throws FlickrException { PrefsInterface iface = flickr.getPrefsInterface(); int geoPerm = iface.getGeoPerms(); if (geoPerm != Flickr.PRIVACY_LEVEL_NO_FILTER && geoPerm != Flickr.PRIVACY_LEVEL_FRIENDS && geoPerm != Flickr.PRIVACY_LEVEL_PUBLIC
                && geoPerm != Flickr.PRIVACY_LEVEL_PRIVATE && geoPerm != Flickr.PRIVACY_LEVEL_FRIENDS_FAMILY && geoPerm != Flickr.PRIVACY_LEVEL_FAMILY) { assertTrue(false); } } } ","package com.flickr4java.flickr.test;  import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue;  import org.junit.Test;  import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.prefs.PrefsInterface;  /**
 * @author Martin Goebel
 * @version $Id: PrefsInterfaceTest.java,v 1.3 2008/06/28 22:30:04 x-mago Exp $
 */ public class PrefsInterfaceTest extends Flickr4JavaTest {  @Test
    public void testGetContentType() throws FlickrException { PrefsInterface iface = flickr.getPrefsInterface(); String type = iface.getContentType(); assertTrue(type.equals(Flickr.CONTENTTYPE_OTHER) || type.equals(Flickr.CONTENTTYPE_PHOTO) || type.equals(Flickr.CONTENTTYPE_SCREENSHOT)); }  @Test
    public void testGetSafetyLevel() throws FlickrException { PrefsInterface iface = flickr.getPrefsInterface(); String level = iface.getSafetyLevel(); assertTrue(level.equals(Flickr.SAFETYLEVEL_SAFE) || level.equals(Flickr.SAFETYLEVEL_MODERATE) || level.equals(Flickr.SAFETYLEVEL_RESTRICTED)); }  @Test
    public void testGetHidden() throws FlickrException { PrefsInterface iface = flickr.getPrefsInterface(); Boolean hidden = iface.getHidden(); assertNotNull(hidden); }  @Test
    public void testGetGeoPerms() throws FlickrException { PrefsInterface iface = flickr.getPrefsInterface(); int geoPerm = iface.getGeoPerms(); // check for known levels. if (geoPerm != Flickr.PRIVACY_LEVEL_NO_FILTER && geoPerm != Flickr.PRIVACY_LEVEL_FRIENDS && geoPerm != Flickr.PRIVACY_LEVEL_PUBLIC
                && geoPerm != Flickr.PRIVACY_LEVEL_PRIVATE && geoPerm != Flickr.PRIVACY_LEVEL_FRIENDS_FAMILY && geoPerm != Flickr.PRIVACY_LEVEL_FAMILY) { assertTrue(false); } } }  "
src/test/java/com/flickr4java/flickr/test/ReflectionInterfaceTest.java,"/*
 * Copyright (c) 2005 Your Corporation. All Rights Reserved.
 */

package com.flickr4java.flickr.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import com.flickr4java.flickr.Flickr;
import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.reflection.Argument;
import com.flickr4java.flickr.reflection.Error;
import com.flickr4java.flickr.reflection.Method;
import com.flickr4java.flickr.reflection.ReflectionInterface;

import org.junit.Test;

import java.util.Collection;
import java.util.Iterator;

/**
 * @author Anthony Eden
 */
public class ReflectionInterfaceTest extends Flickr4JavaTest {

    @Test
    public void testGetMethodInfo_public() throws FlickrException {
        String methodName = ""flickr.interestingness.getList"";
        ReflectionInterface reflectionInterface = flickr.getReflectionInterface();
        Method method = reflectionInterface.getMethodInfo(methodName);
        assertNotNull(method);
        assertEquals(methodName, method.getName());
        assertFalse(method.needsSigning());
        assertEquals(0, method.getRequiredPerms());
        assertFalse(method.needsLogin());

        assertNotNull(method.getArguments());
        assertEquals(5, method.getArguments().size());
        Collection<Argument> args = method.getArguments();
        Iterator<Argument> argsIterator = args.iterator();

        Argument api_key = argsIterator.next();
        assertEquals(Flickr.API_KEY, api_key.getName());
        assertFalse(api_key.isOptional());
        assertNotNull(api_key.getDescription());

        Argument date = argsIterator.next();
        assertEquals(""date"", date.getName());
        assertTrue(date.isOptional());

        Argument extras = argsIterator.next();
        assertEquals(""extras"", extras.getName());
        assertTrue(extras.isOptional());

        Argument per_page = argsIterator.next();
        assertEquals(""per_page"", per_page.getName());
        assertTrue(per_page.isOptional());

        Argument page = argsIterator.next();
        assertEquals(""page"", page.getName());
        assertTrue(page.isOptional());

        Collection<Error> errors = method.getErrors();
        assertNotNull(errors);
        assertTrue(!errors.isEmpty());
        Iterator<Error> errorsIterator = errors.iterator();
        Error error = errorsIterator.next();
        assertNotNull(error);
        assertTrue(error.getCode() > 0);
        assertNotNull(error.getMessage());
        assertNotNull(error.getExplaination());
    }

    @Test
    public void testGetMethods() throws FlickrException {
        ReflectionInterface reflectionInterface = flickr.getReflectionInterface();
        Collection<String> methods = reflectionInterface.getMethods();
        assertNotNull(methods);
        assertTrue(""There are no methods in the method list"", methods.size() > 0);
        Iterator<String> methodsIterator = methods.iterator();
        boolean foundAddTags = false;
        boolean foundGetLocation = false;

        while (methodsIterator.hasNext()) {
            String methodName = methodsIterator.next();
            if (""flickr.photos.addTags"".equals(methodName)) {
                foundAddTags = true;
            }
            if (""flickr.photos.geo.getLocation"".equals(methodName)) {
                foundGetLocation = true;
            }
        }
        assertTrue(""Method \""flickr.photos.addTags\"" not found"", foundAddTags);
        assertTrue(""Method \""flickr.photos.geo.getLocation\"" not found"", foundGetLocation);
    }

}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.reflection.Argument; import com.flickr4java.flickr.reflection.Error; import com.flickr4java.flickr.reflection.Method; import com.flickr4java.flickr.reflection.ReflectionInterface; import org.junit.Test; import java.util.Collection; import java.util.Iterator; public class ReflectionInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetMethodInfo_public() throws FlickrException { String methodName = ""flickr.interestingness.getList""; ReflectionInterface reflectionInterface = flickr.getReflectionInterface(); Method method = reflectionInterface.getMethodInfo(methodName); assertNotNull(method); assertEquals(methodName, method.getName()); assertFalse(method.needsSigning()); assertEquals(0, method.getRequiredPerms()); assertFalse(method.needsLogin()); assertNotNull(method.getArguments()); assertEquals(5, method.getArguments().size()); Collection<Argument> args = method.getArguments(); Iterator<Argument> argsIterator = args.iterator(); Argument api_key = argsIterator.next(); assertEquals(Flickr.API_KEY, api_key.getName()); assertFalse(api_key.isOptional()); assertNotNull(api_key.getDescription()); Argument date = argsIterator.next(); assertEquals(""date"", date.getName()); assertTrue(date.isOptional()); Argument extras = argsIterator.next(); assertEquals(""extras"", extras.getName()); assertTrue(extras.isOptional()); Argument per_page = argsIterator.next(); assertEquals(""per_page"", per_page.getName()); assertTrue(per_page.isOptional()); Argument page = argsIterator.next(); assertEquals(""page"", page.getName()); assertTrue(page.isOptional()); Collection<Error> errors = method.getErrors(); assertNotNull(errors); assertTrue(!errors.isEmpty()); Iterator<Error> errorsIterator = errors.iterator(); Error error = errorsIterator.next(); assertNotNull(error); assertTrue(error.getCode() > 0); assertNotNull(error.getMessage()); assertNotNull(error.getExplaination()); } @Test
    public void testGetMethods() throws FlickrException { ReflectionInterface reflectionInterface = flickr.getReflectionInterface(); Collection<String> methods = reflectionInterface.getMethods(); assertNotNull(methods); assertTrue(""There are no methods in the method list"", methods.size() > 0); Iterator<String> methodsIterator = methods.iterator(); boolean foundAddTags = false; boolean foundGetLocation = false; while (methodsIterator.hasNext()) { String methodName = methodsIterator.next(); if (""flickr.photos.addTags"".equals(methodName)) { foundAddTags = true; } if (""flickr.photos.geo.getLocation"".equals(methodName)) { foundGetLocation = true; } } assertTrue(""Method \""flickr.photos.addTags\"" not found"", foundAddTags); assertTrue(""Method \""flickr.photos.geo.getLocation\"" not found"", foundGetLocation); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.reflection.Argument; import com.flickr4java.flickr.reflection.Error; import com.flickr4java.flickr.reflection.Method; import com.flickr4java.flickr.reflection.ReflectionInterface; import org.junit.Test; import java.util.Collection; import java.util.Iterator; public class ReflectionInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetMethodInfo_public() throws FlickrException { String methodName = ""flickr.interestingness.getList""; ReflectionInterface reflectionInterface = flickr.getReflectionInterface(); Method method = reflectionInterface.getMethodInfo(methodName); assertNotNull(method); assertEquals(methodName, method.getName()); assertFalse(method.needsSigning()); assertEquals(0, method.getRequiredPerms()); assertFalse(method.needsLogin()); assertNotNull(method.getArguments()); assertEquals(5, method.getArguments().size()); Collection<Argument> args = method.getArguments(); Iterator<Argument> argsIterator = args.iterator(); Argument api_key = argsIterator.next(); assertEquals(Flickr.API_KEY, api_key.getName()); assertFalse(api_key.isOptional()); assertNotNull(api_key.getDescription()); Argument date = argsIterator.next(); assertEquals(""date"", date.getName()); assertTrue(date.isOptional()); Argument extras = argsIterator.next(); assertEquals(""extras"", extras.getName()); assertTrue(extras.isOptional()); Argument per_page = argsIterator.next(); assertEquals(""per_page"", per_page.getName()); assertTrue(per_page.isOptional()); Argument page = argsIterator.next(); assertEquals(""page"", page.getName()); assertTrue(page.isOptional()); Collection<Error> errors = method.getErrors(); assertNotNull(errors); assertTrue(!errors.isEmpty()); Iterator<Error> errorsIterator = errors.iterator(); Error error = errorsIterator.next(); assertNotNull(error); assertTrue(error.getCode() > 0); assertNotNull(error.getMessage()); assertNotNull(error.getExplaination()); } @Test
    public void testGetMethods() throws FlickrException { ReflectionInterface reflectionInterface = flickr.getReflectionInterface(); Collection<String> methods = reflectionInterface.getMethods(); assertNotNull(methods); assertTrue(""There are no methods in the method list"", methods.size() > 0); Iterator<String> methodsIterator = methods.iterator(); boolean foundAddTags = false; boolean foundGetLocation = false; while (methodsIterator.hasNext()) { String methodName = methodsIterator.next(); if (""flickr.photos.addTags"".equals(methodName)) { foundAddTags = true; } if (""flickr.photos.geo.getLocation"".equals(methodName)) { foundGetLocation = true; } } assertTrue(""Method \""flickr.photos.addTags\"" not found"", foundAddTags); assertTrue(""Method \""flickr.photos.geo.getLocation\"" not found"", foundGetLocation); } } ","/*
 * Copyright (c) 2005 Your Corporation. All Rights Reserved.
 */  package com.flickr4java.flickr.test;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue;  import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.reflection.Argument; import com.flickr4java.flickr.reflection.Error; import com.flickr4java.flickr.reflection.Method; import com.flickr4java.flickr.reflection.ReflectionInterface;  import org.junit.Test;  import java.util.Collection; import java.util.Iterator;  /**
 * @author Anthony Eden
 */ public class ReflectionInterfaceTest extends Flickr4JavaTest {  @Test
    public void testGetMethodInfo_public() throws FlickrException { String methodName = ""flickr.interestingness.getList""; ReflectionInterface reflectionInterface = flickr.getReflectionInterface(); Method method = reflectionInterface.getMethodInfo(methodName); assertNotNull(method); assertEquals(methodName, method.getName()); assertFalse(method.needsSigning()); assertEquals(0, method.getRequiredPerms()); assertFalse(method.needsLogin());  assertNotNull(method.getArguments()); assertEquals(5, method.getArguments().size()); Collection<Argument> args = method.getArguments(); Iterator<Argument> argsIterator = args.iterator();  Argument api_key = argsIterator.next(); assertEquals(Flickr.API_KEY, api_key.getName()); assertFalse(api_key.isOptional()); assertNotNull(api_key.getDescription());  Argument date = argsIterator.next(); assertEquals(""date"", date.getName()); assertTrue(date.isOptional());  Argument extras = argsIterator.next(); assertEquals(""extras"", extras.getName()); assertTrue(extras.isOptional());  Argument per_page = argsIterator.next(); assertEquals(""per_page"", per_page.getName()); assertTrue(per_page.isOptional());  Argument page = argsIterator.next(); assertEquals(""page"", page.getName()); assertTrue(page.isOptional());  Collection<Error> errors = method.getErrors(); assertNotNull(errors); assertTrue(!errors.isEmpty()); Iterator<Error> errorsIterator = errors.iterator(); Error error = errorsIterator.next(); assertNotNull(error); assertTrue(error.getCode() > 0); assertNotNull(error.getMessage()); assertNotNull(error.getExplaination()); }  @Test
    public void testGetMethods() throws FlickrException { ReflectionInterface reflectionInterface = flickr.getReflectionInterface(); Collection<String> methods = reflectionInterface.getMethods(); assertNotNull(methods); assertTrue(""There are no methods in the method list"", methods.size() > 0); Iterator<String> methodsIterator = methods.iterator(); boolean foundAddTags = false; boolean foundGetLocation = false;  while (methodsIterator.hasNext()) { String methodName = methodsIterator.next(); if (""flickr.photos.addTags"".equals(methodName)) { foundAddTags = true; } if (""flickr.photos.geo.getLocation"".equals(methodName)) { foundGetLocation = true; } } assertTrue(""Method \""flickr.photos.addTags\"" not found"", foundAddTags); assertTrue(""Method \""flickr.photos.geo.getLocation\"" not found"", foundGetLocation); }  }  "
src/test/java/com/flickr4java/flickr/test/StatsInterfaceTest.java,"package com.flickr4java.flickr.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.stats.Csv;
import com.flickr4java.flickr.stats.Domain;
import com.flickr4java.flickr.stats.DomainList;
import com.flickr4java.flickr.stats.Referrer;
import com.flickr4java.flickr.stats.ReferrerList;
import com.flickr4java.flickr.stats.Stats;
import com.flickr4java.flickr.stats.StatsInterface;
import com.flickr4java.flickr.stats.StatsSort;
import com.flickr4java.flickr.stats.Totals;

import org.junit.Ignore;
import org.junit.Test;

import java.util.Date;
import java.util.List;

/**
 * @author Darren Greaves
 * 
 *         Most users don't have stats now so tests are set to disabled for now.
 */
@Ignore
public class StatsInterfaceTest extends Flickr4JavaTest {

    private final Date today = new Date();

    @Test
    public void testGetCollectionDomains() throws FlickrException {
        StatsInterface iface = flickr.getStatsInterface();
        DomainList domains = iface.getCollectionDomains(today, null, 50, 0);
        assertNotNull(domains);

        assertEquals(1, domains.getPage());
        assertEquals(50, domains.getPerPage());

        for (Domain domain : domains) {
            assertNotNull(domain.getName());
            assertNotNull(domain.getViews());
        }
    }

    @Test
    public void testGetCollectionReferrers() throws FlickrException {
        StatsInterface iface = flickr.getStatsInterface();
        ReferrerList referrers = iface.getCollectionReferrers(today, ""flickr.com"", null, 50, 0);
        assertNotNull(referrers);

        assertEquals(1, referrers.getPage());
        assertEquals(50, referrers.getPerPage());

        for (Referrer referrer : referrers) {
            assertNotNull(referrer.getUrl());
            assertNotNull(referrer.getViews());
        }
    }

    @Test
    public void testGetCollectionStats() throws FlickrException {
        StatsInterface iface = flickr.getStatsInterface();
        Stats stats = iface.getCollectionStats(testProperties.getCollectionUrlId(), today);
        assertNotNull(stats);

        assertTrue(stats.getViews() >= 0);
        assertTrue(stats.getFavorites() >= 0);
        assertTrue(stats.getComments() >= 0);
    }

    @Test
    public void testGetPhotoDomains() throws FlickrException {
        StatsInterface iface = flickr.getStatsInterface();
        DomainList domains = iface.getPhotoDomains(today, null, 50, 0);
        assertNotNull(domains);

        assertEquals(1, domains.getPage());
        assertEquals(50, domains.getPerPage());

        for (Domain domain : domains) {
            assertNotNull(domain.getName());
            assertNotNull(domain.getViews());
        }
    }

    @Test
    public void testGetPhotoReferrers() throws FlickrException {
        StatsInterface iface = flickr.getStatsInterface();
        ReferrerList referrers = iface.getPhotoReferrers(today, ""flickr.com"", null, 50, 0);
        assertNotNull(referrers);

        assertEquals(1, referrers.getPage());
        assertEquals(50, referrers.getPerPage());
        assertEquals(""flickr.com"", referrers.getName());

        for (Referrer referrer : referrers) {
            assertNotNull(referrer.getUrl());
            assertNotNull(referrer.getViews());
        }
    }

    @Test
    public void testGetPhotoStats() throws FlickrException {
        StatsInterface iface = flickr.getStatsInterface();
        Stats stats = iface.getPhotoStats(testProperties.getPhotoId(), today);
        assertNotNull(stats);

        assertTrue(stats.getViews() >= 0);
        assertTrue(stats.getFavorites() >= 0);
        assertTrue(stats.getComments() >= 0);
    }

    @Test
    public void testGetPhotosetDomains() throws FlickrException {
        StatsInterface iface = flickr.getStatsInterface();
        DomainList domains = iface.getPhotosetDomains(today, null, 50, 0);
        assertNotNull(domains);

        assertEquals(1, domains.getPage());
        assertEquals(50, domains.getPerPage());

        for (Domain domain : domains) {
            assertNotNull(domain.getName());
            assertNotNull(domain.getViews());
        }
    }

    @Test
    public void testGetPhotosetReferrers() throws FlickrException {
        StatsInterface iface = flickr.getStatsInterface();
        ReferrerList referrers = iface.getPhotosetReferrers(today, ""flickr.com"", null, 50, 0);
        assertNotNull(referrers);

        assertEquals(1, referrers.getPage());
        assertEquals(50, referrers.getPerPage());

        for (Referrer referrer : referrers) {
            assertNotNull(referrer.getUrl());
            assertNotNull(referrer.getViews());
        }
    }

    @Test
    public void testGetPhotosetStats() throws FlickrException {
        StatsInterface iface = flickr.getStatsInterface();
        Stats stats = iface.getPhotosetStats(testProperties.getPhotosetId(), today);
        assertNotNull(stats);

        assertTrue(stats.getViews() >= 0);
        assertTrue(stats.getFavorites() >= 0);
        assertTrue(stats.getComments() >= 0);
    }

    @Test
    public void testGetPhotostreamDomains() throws FlickrException {
        StatsInterface iface = flickr.getStatsInterface();
        DomainList domains = iface.getPhotostreamDomains(today, 50, 0);
        assertNotNull(domains);

        assertEquals(1, domains.getPage());
        assertEquals(50, domains.getPerPage());

        for (Domain domain : domains) {
            assertNotNull(domain.getName());
            assertNotNull(domain.getViews());
        }
    }

    @Test
    public void testGetPhotostreamReferrers() throws FlickrException {
        StatsInterface iface = flickr.getStatsInterface();
        ReferrerList referrers = iface.getPhotostreamReferrers(today, ""flickr.com"", 50, 0);
        assertNotNull(referrers);

        assertEquals(1, referrers.getPage());
        assertEquals(50, referrers.getPerPage());

        for (Referrer referrer : referrers) {
            assertNotNull(referrer.getUrl());
            assertNotNull(referrer.getViews());
        }
    }

    @Test
    public void testGetPhotostreamStats() throws FlickrException {
        StatsInterface iface = flickr.getStatsInterface();
        Stats stats = iface.getPhotostreamStats(today);
        assertNotNull(stats);

        assertTrue(stats.getViews() >= 0);
        assertTrue(stats.getFavorites() >= 0);
        assertTrue(stats.getComments() >= 0);
    }

    @Test
    public void testGetCsvFiles() throws FlickrException {
        StatsInterface iface = flickr.getStatsInterface();
        List<Csv> csvFiles = iface.getCSVFiles();
        assertNotNull(csvFiles);

        assertTrue(csvFiles.size() > 0);

        for (Csv csv : csvFiles) {
            assertNotNull(csv.getHref());
            assertNotNull(csv.getType());
            assertNotNull(csv.getDate());
        }

    }

    @Test
    public void testGetPopularPhotos() throws FlickrException {
        StatsInterface iface = flickr.getStatsInterface();
        List<Photo> photos = iface.getPopularPhotos(null, StatsSort.comments, 5, 0);

        assertNotNull(photos);

        assertTrue(photos.size() > 0);

        for (Photo photo : photos) {

            assertNotNull(photo.getId());
            assertNotNull(photo.getOwner());
            assertNotNull(photo.getSecret());
            assertNotNull(photo.getServer());
            assertNotNull(photo.getStats());

            // These may not pass for all photos
            assertTrue(photo.getStats().getComments() > 0);
            assertTrue(photo.getStats().getFavorites() > 0);
            assertTrue(photo.getStats().getViews() > 0);

        }
    }

    @Test
    public void testGetTotalViews() throws FlickrException {
        StatsInterface iface = flickr.getStatsInterface();
        Totals totals = iface.getTotalViews(null);

        assertNotNull(totals);

        assertTrue(totals.getTotal() > 0);
        assertTrue(totals.getPhotos() > 0);
        assertTrue(totals.getPhotostream() > 0);
        assertTrue(totals.getSets() > 0);
        assertTrue(totals.getCollections() > 0);

    }
}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.stats.Csv; import com.flickr4java.flickr.stats.Domain; import com.flickr4java.flickr.stats.DomainList; import com.flickr4java.flickr.stats.Referrer; import com.flickr4java.flickr.stats.ReferrerList; import com.flickr4java.flickr.stats.Stats; import com.flickr4java.flickr.stats.StatsInterface; import com.flickr4java.flickr.stats.StatsSort; import com.flickr4java.flickr.stats.Totals; import org.junit.Ignore; import org.junit.Test; import java.util.Date; import java.util.List; @Ignore
public class StatsInterfaceTest extends Flickr4JavaTest { private final Date today = new Date(); @Test
    public void testGetCollectionDomains() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); DomainList domains = iface.getCollectionDomains(today, null, 50, 0); assertNotNull(domains); assertEquals(1, domains.getPage()); assertEquals(50, domains.getPerPage()); for (Domain domain : domains) { assertNotNull(domain.getName()); assertNotNull(domain.getViews()); } } @Test
    public void testGetCollectionReferrers() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); ReferrerList referrers = iface.getCollectionReferrers(today, ""flickr.com"", null, 50, 0); assertNotNull(referrers); assertEquals(1, referrers.getPage()); assertEquals(50, referrers.getPerPage()); for (Referrer referrer : referrers) { assertNotNull(referrer.getUrl()); assertNotNull(referrer.getViews()); } } @Test
    public void testGetCollectionStats() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); Stats stats = iface.getCollectionStats(testProperties.getCollectionUrlId(), today); assertNotNull(stats); assertTrue(stats.getViews() >= 0); assertTrue(stats.getFavorites() >= 0); assertTrue(stats.getComments() >= 0); } @Test
    public void testGetPhotoDomains() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); DomainList domains = iface.getPhotoDomains(today, null, 50, 0); assertNotNull(domains); assertEquals(1, domains.getPage()); assertEquals(50, domains.getPerPage()); for (Domain domain : domains) { assertNotNull(domain.getName()); assertNotNull(domain.getViews()); } } @Test
    public void testGetPhotoReferrers() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); ReferrerList referrers = iface.getPhotoReferrers(today, ""flickr.com"", null, 50, 0); assertNotNull(referrers); assertEquals(1, referrers.getPage()); assertEquals(50, referrers.getPerPage()); assertEquals(""flickr.com"", referrers.getName()); for (Referrer referrer : referrers) { assertNotNull(referrer.getUrl()); assertNotNull(referrer.getViews()); } } @Test
    public void testGetPhotoStats() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); Stats stats = iface.getPhotoStats(testProperties.getPhotoId(), today); assertNotNull(stats); assertTrue(stats.getViews() >= 0); assertTrue(stats.getFavorites() >= 0); assertTrue(stats.getComments() >= 0); } @Test
    public void testGetPhotosetDomains() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); DomainList domains = iface.getPhotosetDomains(today, null, 50, 0); assertNotNull(domains); assertEquals(1, domains.getPage()); assertEquals(50, domains.getPerPage()); for (Domain domain : domains) { assertNotNull(domain.getName()); assertNotNull(domain.getViews()); } } @Test
    public void testGetPhotosetReferrers() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); ReferrerList referrers = iface.getPhotosetReferrers(today, ""flickr.com"", null, 50, 0); assertNotNull(referrers); assertEquals(1, referrers.getPage()); assertEquals(50, referrers.getPerPage()); for (Referrer referrer : referrers) { assertNotNull(referrer.getUrl()); assertNotNull(referrer.getViews()); } } @Test
    public void testGetPhotosetStats() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); Stats stats = iface.getPhotosetStats(testProperties.getPhotosetId(), today); assertNotNull(stats); assertTrue(stats.getViews() >= 0); assertTrue(stats.getFavorites() >= 0); assertTrue(stats.getComments() >= 0); } @Test
    public void testGetPhotostreamDomains() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); DomainList domains = iface.getPhotostreamDomains(today, 50, 0); assertNotNull(domains); assertEquals(1, domains.getPage()); assertEquals(50, domains.getPerPage()); for (Domain domain : domains) { assertNotNull(domain.getName()); assertNotNull(domain.getViews()); } } @Test
    public void testGetPhotostreamReferrers() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); ReferrerList referrers = iface.getPhotostreamReferrers(today, ""flickr.com"", 50, 0); assertNotNull(referrers); assertEquals(1, referrers.getPage()); assertEquals(50, referrers.getPerPage()); for (Referrer referrer : referrers) { assertNotNull(referrer.getUrl()); assertNotNull(referrer.getViews()); } } @Test
    public void testGetPhotostreamStats() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); Stats stats = iface.getPhotostreamStats(today); assertNotNull(stats); assertTrue(stats.getViews() >= 0); assertTrue(stats.getFavorites() >= 0); assertTrue(stats.getComments() >= 0); } @Test
    public void testGetCsvFiles() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); List<Csv> csvFiles = iface.getCSVFiles(); assertNotNull(csvFiles); assertTrue(csvFiles.size() > 0); for (Csv csv : csvFiles) { assertNotNull(csv.getHref()); assertNotNull(csv.getType()); assertNotNull(csv.getDate()); } } @Test
    public void testGetPopularPhotos() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); List<Photo> photos = iface.getPopularPhotos(null, StatsSort.comments, 5, 0); assertNotNull(photos); assertTrue(photos.size() > 0); for (Photo photo : photos) { assertNotNull(photo.getId()); assertNotNull(photo.getOwner()); assertNotNull(photo.getSecret()); assertNotNull(photo.getServer()); assertNotNull(photo.getStats()); assertTrue(photo.getStats().getComments() > 0); assertTrue(photo.getStats().getFavorites() > 0); assertTrue(photo.getStats().getViews() > 0); } } @Test
    public void testGetTotalViews() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); Totals totals = iface.getTotalViews(null); assertNotNull(totals); assertTrue(totals.getTotal() > 0); assertTrue(totals.getPhotos() > 0); assertTrue(totals.getPhotostream() > 0); assertTrue(totals.getSets() > 0); assertTrue(totals.getCollections() > 0); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.stats.Csv; import com.flickr4java.flickr.stats.Domain; import com.flickr4java.flickr.stats.DomainList; import com.flickr4java.flickr.stats.Referrer; import com.flickr4java.flickr.stats.ReferrerList; import com.flickr4java.flickr.stats.Stats; import com.flickr4java.flickr.stats.StatsInterface; import com.flickr4java.flickr.stats.StatsSort; import com.flickr4java.flickr.stats.Totals; import org.junit.Ignore; import org.junit.Test; import java.util.Date; import java.util.List; @Ignore
public class StatsInterfaceTest extends Flickr4JavaTest { private final Date today = new Date(); @Test
    public void testGetCollectionDomains() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); DomainList domains = iface.getCollectionDomains(today, null, 50, 0); assertNotNull(domains); assertEquals(1, domains.getPage()); assertEquals(50, domains.getPerPage()); for (Domain domain : domains) { assertNotNull(domain.getName()); assertNotNull(domain.getViews()); } } @Test
    public void testGetCollectionReferrers() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); ReferrerList referrers = iface.getCollectionReferrers(today, ""flickr.com"", null, 50, 0); assertNotNull(referrers); assertEquals(1, referrers.getPage()); assertEquals(50, referrers.getPerPage()); for (Referrer referrer : referrers) { assertNotNull(referrer.getUrl()); assertNotNull(referrer.getViews()); } } @Test
    public void testGetCollectionStats() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); Stats stats = iface.getCollectionStats(testProperties.getCollectionUrlId(), today); assertNotNull(stats); assertTrue(stats.getViews() >= 0); assertTrue(stats.getFavorites() >= 0); assertTrue(stats.getComments() >= 0); } @Test
    public void testGetPhotoDomains() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); DomainList domains = iface.getPhotoDomains(today, null, 50, 0); assertNotNull(domains); assertEquals(1, domains.getPage()); assertEquals(50, domains.getPerPage()); for (Domain domain : domains) { assertNotNull(domain.getName()); assertNotNull(domain.getViews()); } } @Test
    public void testGetPhotoReferrers() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); ReferrerList referrers = iface.getPhotoReferrers(today, ""flickr.com"", null, 50, 0); assertNotNull(referrers); assertEquals(1, referrers.getPage()); assertEquals(50, referrers.getPerPage()); assertEquals(""flickr.com"", referrers.getName()); for (Referrer referrer : referrers) { assertNotNull(referrer.getUrl()); assertNotNull(referrer.getViews()); } } @Test
    public void testGetPhotoStats() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); Stats stats = iface.getPhotoStats(testProperties.getPhotoId(), today); assertNotNull(stats); assertTrue(stats.getViews() >= 0); assertTrue(stats.getFavorites() >= 0); assertTrue(stats.getComments() >= 0); } @Test
    public void testGetPhotosetDomains() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); DomainList domains = iface.getPhotosetDomains(today, null, 50, 0); assertNotNull(domains); assertEquals(1, domains.getPage()); assertEquals(50, domains.getPerPage()); for (Domain domain : domains) { assertNotNull(domain.getName()); assertNotNull(domain.getViews()); } } @Test
    public void testGetPhotosetReferrers() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); ReferrerList referrers = iface.getPhotosetReferrers(today, ""flickr.com"", null, 50, 0); assertNotNull(referrers); assertEquals(1, referrers.getPage()); assertEquals(50, referrers.getPerPage()); for (Referrer referrer : referrers) { assertNotNull(referrer.getUrl()); assertNotNull(referrer.getViews()); } } @Test
    public void testGetPhotosetStats() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); Stats stats = iface.getPhotosetStats(testProperties.getPhotosetId(), today); assertNotNull(stats); assertTrue(stats.getViews() >= 0); assertTrue(stats.getFavorites() >= 0); assertTrue(stats.getComments() >= 0); } @Test
    public void testGetPhotostreamDomains() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); DomainList domains = iface.getPhotostreamDomains(today, 50, 0); assertNotNull(domains); assertEquals(1, domains.getPage()); assertEquals(50, domains.getPerPage()); for (Domain domain : domains) { assertNotNull(domain.getName()); assertNotNull(domain.getViews()); } } @Test
    public void testGetPhotostreamReferrers() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); ReferrerList referrers = iface.getPhotostreamReferrers(today, ""flickr.com"", 50, 0); assertNotNull(referrers); assertEquals(1, referrers.getPage()); assertEquals(50, referrers.getPerPage()); for (Referrer referrer : referrers) { assertNotNull(referrer.getUrl()); assertNotNull(referrer.getViews()); } } @Test
    public void testGetPhotostreamStats() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); Stats stats = iface.getPhotostreamStats(today); assertNotNull(stats); assertTrue(stats.getViews() >= 0); assertTrue(stats.getFavorites() >= 0); assertTrue(stats.getComments() >= 0); } @Test
    public void testGetCsvFiles() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); List<Csv> csvFiles = iface.getCSVFiles(); assertNotNull(csvFiles); assertTrue(csvFiles.size() > 0); for (Csv csv : csvFiles) { assertNotNull(csv.getHref()); assertNotNull(csv.getType()); assertNotNull(csv.getDate()); } } @Test
    public void testGetPopularPhotos() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); List<Photo> photos = iface.getPopularPhotos(null, StatsSort.comments, 5, 0); assertNotNull(photos); assertTrue(photos.size() > 0); for (Photo photo : photos) { assertNotNull(photo.getId()); assertNotNull(photo.getOwner()); assertNotNull(photo.getSecret()); assertNotNull(photo.getServer()); assertNotNull(photo.getStats()); assertTrue(photo.getStats().getComments() > 0); assertTrue(photo.getStats().getFavorites() > 0); assertTrue(photo.getStats().getViews() > 0); } } @Test
    public void testGetTotalViews() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); Totals totals = iface.getTotalViews(null); assertNotNull(totals); assertTrue(totals.getTotal() > 0); assertTrue(totals.getPhotos() > 0); assertTrue(totals.getPhotostream() > 0); assertTrue(totals.getSets() > 0); assertTrue(totals.getCollections() > 0); } } ","package com.flickr4java.flickr.test;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.stats.Csv; import com.flickr4java.flickr.stats.Domain; import com.flickr4java.flickr.stats.DomainList; import com.flickr4java.flickr.stats.Referrer; import com.flickr4java.flickr.stats.ReferrerList; import com.flickr4java.flickr.stats.Stats; import com.flickr4java.flickr.stats.StatsInterface; import com.flickr4java.flickr.stats.StatsSort; import com.flickr4java.flickr.stats.Totals;  import org.junit.Ignore; import org.junit.Test;  import java.util.Date; import java.util.List;  /**
 * @author Darren Greaves
 * 
 *         Most users don't have stats now so tests are set to disabled for now.
 */ @Ignore
public class StatsInterfaceTest extends Flickr4JavaTest {  private final Date today = new Date();  @Test
    public void testGetCollectionDomains() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); DomainList domains = iface.getCollectionDomains(today, null, 50, 0); assertNotNull(domains);  assertEquals(1, domains.getPage()); assertEquals(50, domains.getPerPage());  for (Domain domain : domains) { assertNotNull(domain.getName()); assertNotNull(domain.getViews()); } }  @Test
    public void testGetCollectionReferrers() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); ReferrerList referrers = iface.getCollectionReferrers(today, ""flickr.com"", null, 50, 0); assertNotNull(referrers);  assertEquals(1, referrers.getPage()); assertEquals(50, referrers.getPerPage());  for (Referrer referrer : referrers) { assertNotNull(referrer.getUrl()); assertNotNull(referrer.getViews()); } }  @Test
    public void testGetCollectionStats() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); Stats stats = iface.getCollectionStats(testProperties.getCollectionUrlId(), today); assertNotNull(stats);  assertTrue(stats.getViews() >= 0); assertTrue(stats.getFavorites() >= 0); assertTrue(stats.getComments() >= 0); }  @Test
    public void testGetPhotoDomains() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); DomainList domains = iface.getPhotoDomains(today, null, 50, 0); assertNotNull(domains);  assertEquals(1, domains.getPage()); assertEquals(50, domains.getPerPage());  for (Domain domain : domains) { assertNotNull(domain.getName()); assertNotNull(domain.getViews()); } }  @Test
    public void testGetPhotoReferrers() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); ReferrerList referrers = iface.getPhotoReferrers(today, ""flickr.com"", null, 50, 0); assertNotNull(referrers);  assertEquals(1, referrers.getPage()); assertEquals(50, referrers.getPerPage()); assertEquals(""flickr.com"", referrers.getName());  for (Referrer referrer : referrers) { assertNotNull(referrer.getUrl()); assertNotNull(referrer.getViews()); } }  @Test
    public void testGetPhotoStats() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); Stats stats = iface.getPhotoStats(testProperties.getPhotoId(), today); assertNotNull(stats);  assertTrue(stats.getViews() >= 0); assertTrue(stats.getFavorites() >= 0); assertTrue(stats.getComments() >= 0); }  @Test
    public void testGetPhotosetDomains() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); DomainList domains = iface.getPhotosetDomains(today, null, 50, 0); assertNotNull(domains);  assertEquals(1, domains.getPage()); assertEquals(50, domains.getPerPage());  for (Domain domain : domains) { assertNotNull(domain.getName()); assertNotNull(domain.getViews()); } }  @Test
    public void testGetPhotosetReferrers() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); ReferrerList referrers = iface.getPhotosetReferrers(today, ""flickr.com"", null, 50, 0); assertNotNull(referrers);  assertEquals(1, referrers.getPage()); assertEquals(50, referrers.getPerPage());  for (Referrer referrer : referrers) { assertNotNull(referrer.getUrl()); assertNotNull(referrer.getViews()); } }  @Test
    public void testGetPhotosetStats() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); Stats stats = iface.getPhotosetStats(testProperties.getPhotosetId(), today); assertNotNull(stats);  assertTrue(stats.getViews() >= 0); assertTrue(stats.getFavorites() >= 0); assertTrue(stats.getComments() >= 0); }  @Test
    public void testGetPhotostreamDomains() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); DomainList domains = iface.getPhotostreamDomains(today, 50, 0); assertNotNull(domains);  assertEquals(1, domains.getPage()); assertEquals(50, domains.getPerPage());  for (Domain domain : domains) { assertNotNull(domain.getName()); assertNotNull(domain.getViews()); } }  @Test
    public void testGetPhotostreamReferrers() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); ReferrerList referrers = iface.getPhotostreamReferrers(today, ""flickr.com"", 50, 0); assertNotNull(referrers);  assertEquals(1, referrers.getPage()); assertEquals(50, referrers.getPerPage());  for (Referrer referrer : referrers) { assertNotNull(referrer.getUrl()); assertNotNull(referrer.getViews()); } }  @Test
    public void testGetPhotostreamStats() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); Stats stats = iface.getPhotostreamStats(today); assertNotNull(stats);  assertTrue(stats.getViews() >= 0); assertTrue(stats.getFavorites() >= 0); assertTrue(stats.getComments() >= 0); }  @Test
    public void testGetCsvFiles() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); List<Csv> csvFiles = iface.getCSVFiles(); assertNotNull(csvFiles);  assertTrue(csvFiles.size() > 0);  for (Csv csv : csvFiles) { assertNotNull(csv.getHref()); assertNotNull(csv.getType()); assertNotNull(csv.getDate()); }  }  @Test
    public void testGetPopularPhotos() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); List<Photo> photos = iface.getPopularPhotos(null, StatsSort.comments, 5, 0);  assertNotNull(photos);  assertTrue(photos.size() > 0);  for (Photo photo : photos) {  assertNotNull(photo.getId()); assertNotNull(photo.getOwner()); assertNotNull(photo.getSecret()); assertNotNull(photo.getServer()); assertNotNull(photo.getStats());  // These may not pass for all photos assertTrue(photo.getStats().getComments() > 0); assertTrue(photo.getStats().getFavorites() > 0); assertTrue(photo.getStats().getViews() > 0);  } }  @Test
    public void testGetTotalViews() throws FlickrException { StatsInterface iface = flickr.getStatsInterface(); Totals totals = iface.getTotalViews(null);  assertNotNull(totals);  assertTrue(totals.getTotal() > 0); assertTrue(totals.getPhotos() > 0); assertTrue(totals.getPhotostream() > 0); assertTrue(totals.getSets() > 0); assertTrue(totals.getCollections() > 0);  } }  "
src/test/java/com/flickr4java/flickr/test/TagsInterfaceTest.java,"package com.flickr4java.flickr.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoList;
import com.flickr4java.flickr.tags.Cluster;
import com.flickr4java.flickr.tags.ClusterList;
import com.flickr4java.flickr.tags.HotlistTag;
import com.flickr4java.flickr.tags.RelatedTagsList;
import com.flickr4java.flickr.tags.Tag;
import com.flickr4java.flickr.tags.TagRaw;
import com.flickr4java.flickr.tags.TagsInterface;

import org.junit.Test;

import java.util.Collection;

/**
 * @author Anthony Eden
 */
public class TagsInterfaceTest extends Flickr4JavaTest {

    @Test
    public void testGetClusters() throws FlickrException {

        TagsInterface iface = flickr.getTagsInterface();
        ClusterList clusters = iface.getClusters(""api"");
        // System.out.println(""size "" + clusters.getClusters().get(2).getTags().size());
        assertTrue(clusters.getClusters().size() >= 3);
        Cluster cluster = clusters.getClusters().get(0);
        assertTrue(cluster.getTags().size() >= 1);
        cluster = clusters.getClusters().get(1);
        assertTrue(cluster.getTags().size() >= 1);
        cluster = clusters.getClusters().get(2);
        assertTrue(cluster.getTags().size() >= 1);
    }

    @Test
    public void testGetClusterPhotos() throws FlickrException {

        TagsInterface iface = flickr.getTagsInterface();
        PhotoList<Photo> photos = iface.getClusterPhotos(""ducati"", ""999-1098-848"");
        assertTrue(photos.getTotal() >= 20);
    }

    @Test
    public void testGetListPhoto() throws FlickrException {

        TagsInterface iface = flickr.getTagsInterface();
        Photo photo = iface.getListPhoto(testProperties.getPhotoId());
        assertNotNull(photo);
        assertEquals(testProperties.getPhotoId(), photo.getId());
        assertNotNull(photo.getTags());
        assertFalse(photo.getTags().isEmpty());
    }

    @Test
    public void testGetHotList() throws FlickrException {

        TagsInterface iface = flickr.getTagsInterface();
        Collection<HotlistTag> tags = iface.getHotList(""day"", 20);
        assertNotNull(tags);
        assertTrue(tags.size() > 1);
    }

    @Test
    public void testGetListUser() throws FlickrException {

        TagsInterface iface = flickr.getTagsInterface();
        Collection<Tag> tags = iface.getListUser(testProperties.getNsid());
        assertNotNull(tags);
        assertFalse(tags.isEmpty());
    }

    @Test
    public void testGetListUserRaw() throws FlickrException {

        TagsInterface iface = flickr.getTagsInterface();
        Collection<TagRaw> tags = iface.getListUserRaw();
        assertNotNull(tags);
        assertFalse(tags.isEmpty());
    }

    @Test
    public void testListUserPopular() throws FlickrException {

        TagsInterface iface = flickr.getTagsInterface();
        Collection<Tag> tags = iface.getListUserPopular(testProperties.getNsid());
        assertNotNull(tags);
        assertEquals(10, tags.size());
        for (Tag tag : tags) {
            assertNotNull(tag.getValue());
        }
    }

    @Test
    public void testGetRelated() throws FlickrException {

        TagsInterface iface = flickr.getTagsInterface();
        RelatedTagsList relatedTags = iface.getRelated(""flower"");
        assertNotNull(relatedTags);
        assertEquals(""flower"", relatedTags.getSource());
        assertTrue(""Number of related tags returned was 0"", relatedTags.size() > 0);
    }

}
","package com.flickr4java.flickr.test; public class TagsInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetClusters() throws FlickrException { TagsInterface iface = flickr.getTagsInterface(); ClusterList clusters = iface.getClusters(""api""); assertTrue(clusters.getClusters().size() >= 3); Cluster cluster = clusters.getClusters().get(0); assertTrue(cluster.getTags().size() >= 1); cluster = clusters.getClusters().get(1); assertTrue(cluster.getTags().size() >= 1); cluster = clusters.getClusters().get(2); assertTrue(cluster.getTags().size() >= 1); } @Test
    public void testGetClusterPhotos() throws FlickrException { TagsInterface iface = flickr.getTagsInterface(); PhotoList<Photo> photos = iface.getClusterPhotos(""ducati"", ""999-1098-848""); assertTrue(photos.getTotal() >= 20); } @Test
    public void testGetListPhoto() throws FlickrException { TagsInterface iface = flickr.getTagsInterface(); Photo photo = iface.getListPhoto(testProperties.getPhotoId()); assertNotNull(photo); assertEquals(testProperties.getPhotoId(), photo.getId()); assertNotNull(photo.getTags()); assertFalse(photo.getTags().isEmpty()); } @Test
    public void testGetHotList() throws FlickrException { TagsInterface iface = flickr.getTagsInterface(); Collection<HotlistTag> tags = iface.getHotList(""day"", 20); assertNotNull(tags); assertTrue(tags.size() > 1); } @Test
    public void testGetListUser() throws FlickrException { TagsInterface iface = flickr.getTagsInterface(); Collection<Tag> tags = iface.getListUser(testProperties.getNsid()); assertNotNull(tags); assertFalse(tags.isEmpty()); } @Test
    public void testGetListUserRaw() throws FlickrException { TagsInterface iface = flickr.getTagsInterface(); Collection<TagRaw> tags = iface.getListUserRaw(); assertNotNull(tags); assertFalse(tags.isEmpty()); } @Test
    public void testListUserPopular() throws FlickrException { TagsInterface iface = flickr.getTagsInterface(); Collection<Tag> tags = iface.getListUserPopular(testProperties.getNsid()); assertNotNull(tags); assertEquals(10, tags.size()); for (Tag tag : tags) { assertNotNull(tag.getValue()); } } @Test
    public void testGetRelated() throws FlickrException { TagsInterface iface = flickr.getTagsInterface(); RelatedTagsList relatedTags = iface.getRelated(""flower""); assertNotNull(relatedTags); assertEquals(""flower"", relatedTags.getSource()); assertTrue(""Number of related tags returned was 0"", relatedTags.size() > 0); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; public class TagsInterfaceTest extends Flickr4JavaTest { @Test
    public void testGetClusters() throws FlickrException { TagsInterface iface = flickr.getTagsInterface(); ClusterList clusters = iface.getClusters(""api""); assertTrue(clusters.getClusters().size() >= 3); Cluster cluster = clusters.getClusters().get(0); assertTrue(cluster.getTags().size() >= 1); cluster = clusters.getClusters().get(1); assertTrue(cluster.getTags().size() >= 1); cluster = clusters.getClusters().get(2); assertTrue(cluster.getTags().size() >= 1); } @Test
    public void testGetClusterPhotos() throws FlickrException { TagsInterface iface = flickr.getTagsInterface(); PhotoList<Photo> photos = iface.getClusterPhotos(""ducati"", ""999-1098-848""); assertTrue(photos.getTotal() >= 20); } @Test
    public void testGetListPhoto() throws FlickrException { TagsInterface iface = flickr.getTagsInterface(); Photo photo = iface.getListPhoto(testProperties.getPhotoId()); assertNotNull(photo); assertEquals(testProperties.getPhotoId(), photo.getId()); assertNotNull(photo.getTags()); assertFalse(photo.getTags().isEmpty()); } @Test
    public void testGetHotList() throws FlickrException { TagsInterface iface = flickr.getTagsInterface(); Collection<HotlistTag> tags = iface.getHotList(""day"", 20); assertNotNull(tags); assertTrue(tags.size() > 1); } @Test
    public void testGetListUser() throws FlickrException { TagsInterface iface = flickr.getTagsInterface(); Collection<Tag> tags = iface.getListUser(testProperties.getNsid()); assertNotNull(tags); assertFalse(tags.isEmpty()); } @Test
    public void testGetListUserRaw() throws FlickrException { TagsInterface iface = flickr.getTagsInterface(); Collection<TagRaw> tags = iface.getListUserRaw(); assertNotNull(tags); assertFalse(tags.isEmpty()); } @Test
    public void testListUserPopular() throws FlickrException { TagsInterface iface = flickr.getTagsInterface(); Collection<Tag> tags = iface.getListUserPopular(testProperties.getNsid()); assertNotNull(tags); assertEquals(10, tags.size()); for (Tag tag : tags) { assertNotNull(tag.getValue()); } } @Test
    public void testGetRelated() throws FlickrException { TagsInterface iface = flickr.getTagsInterface(); RelatedTagsList relatedTags = iface.getRelated(""flower""); assertNotNull(relatedTags); assertEquals(""flower"", relatedTags.getSource()); assertTrue(""Number of related tags returned was 0"", relatedTags.size() > 0); } } ","package com.flickr4java.flickr.test; 
import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; 
import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.tags.Cluster; import com.flickr4java.flickr.tags.ClusterList; import com.flickr4java.flickr.tags.HotlistTag; import com.flickr4java.flickr.tags.RelatedTagsList; import com.flickr4java.flickr.tags.Tag; import com.flickr4java.flickr.tags.TagRaw; import com.flickr4java.flickr.tags.TagsInterface; 
import org.junit.Test; 
import java.util.Collection;  /**
 * @author Anthony Eden
 */ public class TagsInterfaceTest extends Flickr4JavaTest {  @Test
    public void testGetClusters() throws FlickrException {  TagsInterface iface = flickr.getTagsInterface(); ClusterList clusters = iface.getClusters(""api""); // System.out.println(""size "" + clusters.getClusters().get(2).getTags().size()); assertTrue(clusters.getClusters().size() >= 3); Cluster cluster = clusters.getClusters().get(0); assertTrue(cluster.getTags().size() >= 1); cluster = clusters.getClusters().get(1); assertTrue(cluster.getTags().size() >= 1); cluster = clusters.getClusters().get(2); assertTrue(cluster.getTags().size() >= 1); }  @Test
    public void testGetClusterPhotos() throws FlickrException {  TagsInterface iface = flickr.getTagsInterface(); PhotoList<Photo> photos = iface.getClusterPhotos(""ducati"", ""999-1098-848""); assertTrue(photos.getTotal() >= 20); }  @Test
    public void testGetListPhoto() throws FlickrException {  TagsInterface iface = flickr.getTagsInterface(); Photo photo = iface.getListPhoto(testProperties.getPhotoId()); assertNotNull(photo); assertEquals(testProperties.getPhotoId(), photo.getId()); assertNotNull(photo.getTags()); assertFalse(photo.getTags().isEmpty()); }  @Test
    public void testGetHotList() throws FlickrException {  TagsInterface iface = flickr.getTagsInterface(); Collection<HotlistTag> tags = iface.getHotList(""day"", 20); assertNotNull(tags); assertTrue(tags.size() > 1); }  @Test
    public void testGetListUser() throws FlickrException {  TagsInterface iface = flickr.getTagsInterface(); Collection<Tag> tags = iface.getListUser(testProperties.getNsid()); assertNotNull(tags); assertFalse(tags.isEmpty()); }  @Test
    public void testGetListUserRaw() throws FlickrException {  TagsInterface iface = flickr.getTagsInterface(); Collection<TagRaw> tags = iface.getListUserRaw(); assertNotNull(tags); assertFalse(tags.isEmpty()); }  @Test
    public void testListUserPopular() throws FlickrException {  TagsInterface iface = flickr.getTagsInterface(); Collection<Tag> tags = iface.getListUserPopular(testProperties.getNsid()); assertNotNull(tags); assertEquals(10, tags.size()); for (Tag tag : tags) { assertNotNull(tag.getValue()); } }  @Test
    public void testGetRelated() throws FlickrException {  TagsInterface iface = flickr.getTagsInterface(); RelatedTagsList relatedTags = iface.getRelated(""flower""); assertNotNull(relatedTags); assertEquals(""flower"", relatedTags.getSource()); assertTrue(""Number of related tags returned was 0"", relatedTags.size() > 0); }  }  "
src/test/java/com/flickr4java/flickr/test/TestInterfaceTest.java,"

package com.flickr4java.flickr.test;

import static org.junit.Assert.assertNotNull;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.people.User;

import org.junit.Test;
import org.w3c.dom.Element;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

/**
 * @author Anthony Eden
 * @version $Id: TestInterfaceTest.java,v 1.6 2008/01/28 23:01:45 x-mago Exp $
 */
public class TestInterfaceTest extends Flickr4JavaTest {

    @Test
    public void testEcho() throws FlickrException {
        TestInterface iface = flickr.getTestInterface();
        Map<String, String> params = new HashMap<String, String>();
        params.put(""test"", ""test"");
        Collection<Element> results = iface.echo(params);
        assertNotNull(results);
    }

    @Test
    public void testLogin() throws FlickrException {
        TestInterface iface = flickr.getTestInterface();
        User user = iface.login();
        assertNotNull(user);
    }

}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertNotNull; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.people.User; import org.junit.Test; import org.w3c.dom.Element; import java.util.Collection; import java.util.HashMap; import java.util.Map; public class TestInterfaceTest extends Flickr4JavaTest { @Test
    public void testEcho() throws FlickrException { TestInterface iface = flickr.getTestInterface(); Map<String, String> params = new HashMap<String, String>(); params.put(""test"", ""test""); Collection<Element> results = iface.echo(params); assertNotNull(results); } @Test
    public void testLogin() throws FlickrException { TestInterface iface = flickr.getTestInterface(); User user = iface.login(); assertNotNull(user); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertNotNull; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.people.User; import org.junit.Test; import org.w3c.dom.Element; import java.util.Collection; import java.util.HashMap; import java.util.Map; public class TestInterfaceTest extends Flickr4JavaTest { @Test
    public void testEcho() throws FlickrException { TestInterface iface = flickr.getTestInterface(); Map<String, String> params = new HashMap<String, String>(); params.put(""test"", ""test""); Collection<Element> results = iface.echo(params); assertNotNull(results); } @Test
    public void testLogin() throws FlickrException { TestInterface iface = flickr.getTestInterface(); User user = iface.login(); assertNotNull(user); } } ","
 package com.flickr4java.flickr.test;  import static org.junit.Assert.assertNotNull;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.people.User;  import org.junit.Test; import org.w3c.dom.Element;  import java.util.Collection; import java.util.HashMap; import java.util.Map;  /**
 * @author Anthony Eden
 * @version $Id: TestInterfaceTest.java,v 1.6 2008/01/28 23:01:45 x-mago Exp $
 */ public class TestInterfaceTest extends Flickr4JavaTest {  @Test
    public void testEcho() throws FlickrException { TestInterface iface = flickr.getTestInterface(); Map<String, String> params = new HashMap<String, String>(); params.put(""test"", ""test""); Collection<Element> results = iface.echo(params); assertNotNull(results); }  @Test
    public void testLogin() throws FlickrException { TestInterface iface = flickr.getTestInterface(); User user = iface.login(); assertNotNull(user); }  }  "
src/test/java/com/flickr4java/flickr/test/UploaderTest.java,"package com.flickr4java.flickr.test;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.photos.PhotosInterface;
import com.flickr4java.flickr.uploader.UploadMetaData;
import com.flickr4java.flickr.uploader.Uploader;
import org.junit.Test;

import java.io.*;
import java.nio.file.Files;

import static org.junit.Assert.assertNotNull;

/**
 * @author Anthony Eden
 */
public class UploaderTest extends Flickr4JavaTest {

    private static final String DUMMY_PHOTO_ID = ""1234567890"";

    /**
     * Test photo uploading using a byte array.
     *
     * @throws IOException
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    @Test
    public void testUploadByteArray() throws IOException, FlickrException {
        File imageFile = new File(testProperties.getImageFile());
        Uploader uploader = flickr.getUploader();
        PhotosInterface pint = flickr.getPhotosInterface();

        if (testProperties.isRealFlickr()) {

            UploadMetaData metaData = buildPrivatePhotoMetadata();
            // check correct handling of escaped value
            metaData.setTitle(""óöä"");
            String photoId = uploader.upload(Files.readAllBytes(imageFile.toPath()), metaData);
            assertNotNull(photoId);
            try {
                pint.delete(photoId);
            } catch (FlickrException e) {
                // Ignore if user doesn't have delete permissions
                // This will leave a *private* photo in the test account's photostream!
                if (!e.getErrorCode().equals(""99"")) {
                    throw e;
                }

            }
        } else {
            UploadMetaData metaData = buildPrivatePhotoMetadata();
            String photoId = uploader.upload("""".getBytes(), metaData);
            assertNotNull(photoId);
        }
    }

    /**
     * Test photo upload using an InputStream.
     *
     * @throws IOException
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    @Test
    public void testUploadInputStream() throws IOException, FlickrException {
        File imageFile = new File(testProperties.getImageFile());
        Uploader uploader = flickr.getUploader();
        PhotosInterface pint = flickr.getPhotosInterface();

        if (testProperties.isRealFlickr()) {
            try (InputStream in = new FileInputStream(imageFile)) {
                UploadMetaData metaData = buildPrivatePhotoMetadata();
                metaData.setPublicFlag(false);
                // check correct handling of escaped value
                metaData.setTitle(""óöä"");
                String photoId = uploader.upload(in, metaData);
                assertNotNull(photoId);
                try {
                    pint.delete(photoId);
                } catch (FlickrException e) {
                    // Ignore if user doesn't have delete permissions
                    // This will leave a *private* photo in the test account's photostream!
                    if (!e.getErrorCode().equals(""99"")) {
                        throw e;
                    }
                }
            }
        } else {
            UploadMetaData metaData = buildPrivatePhotoMetadata();
            String photoId = uploader.upload("""".getBytes(), metaData);
            assertNotNull(photoId);
        }
    }

    /**
     * Test photo replace using an InputStream.
     *
     * @throws IOException
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    @Test
    public void testReplaceInputStream() throws IOException, FlickrException, InterruptedException {
        Uploader uploader = flickr.getUploader();
        PhotosInterface pint = flickr.getPhotosInterface();
        File imageFile = new File(testProperties.getImageFile());

        if (testProperties.isRealFlickr()) {
            String photoId;
            try (InputStream uploadIS = new FileInputStream(imageFile)) {

                // Upload a photo, which we'll replace, then delete
                UploadMetaData metaData = buildPrivatePhotoMetadata();
                photoId = uploader.upload(uploadIS, metaData);
            }

            // Fix some odd timing issue
            Thread.sleep(1500);

            try (InputStream replaceIS = new FileInputStream(imageFile)) {

                try {
                    photoId = uploader.replace(replaceIS, photoId, false);
                    assertNotNull(photoId);
                } catch (FlickrException e) {
                    // Error code 1 means test account is not pro so don't fail test because of that
                    if (!e.getErrorCode().equals(""1"")) {
                        throw e;
                    }
                }
                try {
                    pint.delete(photoId);
                } catch (FlickrException e) {
                    // Ignore if user doesn't have delete permissions
                    // This will leave a *private* photo in the test account's photostream!
                    if (!e.getErrorCode().equals(""99"")) {
                        throw e;
                    }
                }
            }
        } else {
            try (InputStream replaceIS = new ByteArrayInputStream("""".getBytes())) {
                String photoId = uploader.replace(replaceIS, DUMMY_PHOTO_ID, false);
                assertNotNull(photoId);
            }
        }
    }

    /**
     * Test photo replace using a byte array.
     *
     * @throws IOException
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    @Test
    public void testReplaceByteArray() throws IOException, FlickrException, InterruptedException {
        File imageFile = new File(testProperties.getImageFile());
        Uploader uploader = flickr.getUploader();
        PhotosInterface pint = flickr.getPhotosInterface();

        if (testProperties.isRealFlickr()) {

            // Upload a photo, which we'll replace, then delete
            UploadMetaData metaData = buildPrivatePhotoMetadata();
            String photoId = uploader.upload(Files.readAllBytes(imageFile.toPath()), metaData);

            // Fix some odd timing issue
            Thread.sleep(1500);

            try {
                photoId = uploader.replace(Files.readAllBytes(imageFile.toPath()), photoId, false);
                assertNotNull(photoId);
            } catch (FlickrException e) {
                // Error code 1 means test account is not pro so don't fail test because of that
                if (!e.getErrorCode().equals(""1"")) {
                    throw e;
                }
            }

            try {
                pint.delete(photoId);
            } catch (FlickrException e) {
                // Ignore if user doesn't have delete permissions
                // This will leave a *private* photo in the test account's photostream!
                if (!e.getErrorCode().equals(""99"")) {
                    throw e;
                }
            }
        } else {
            String photoId = uploader.replace("""".getBytes(), DUMMY_PHOTO_ID, false);
            assertNotNull(photoId);
        }
    }

    /**
     * Build {@link UploadMetaData} with public set to false so uploaded photos are private.
     *
     * @return
     */
    private UploadMetaData buildPrivatePhotoMetadata() {
        UploadMetaData uploadMetaData = new UploadMetaData();
        uploadMetaData.setPublicFlag(false);
        return uploadMetaData;
    }

}
","package com.flickr4java.flickr.test; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.photos.PhotosInterface; import com.flickr4java.flickr.uploader.UploadMetaData; import com.flickr4java.flickr.uploader.Uploader; import org.junit.Test; import java.io.*; import java.nio.file.Files; import static org.junit.Assert.assertNotNull; public class UploaderTest extends Flickr4JavaTest { private static final String DUMMY_PHOTO_ID = ""1234567890""; @Test
    public void testUploadByteArray() throws IOException, FlickrException { File imageFile = new File(testProperties.getImageFile()); Uploader uploader = flickr.getUploader(); PhotosInterface pint = flickr.getPhotosInterface(); if (testProperties.isRealFlickr()) { UploadMetaData metaData = buildPrivatePhotoMetadata(); metaData.setTitle(""óöä""); String photoId = uploader.upload(Files.readAllBytes(imageFile.toPath()), metaData); assertNotNull(photoId); try { pint.delete(photoId); } catch (FlickrException e) { if (!e.getErrorCode().equals(""99"")) { throw e; } } } else { UploadMetaData metaData = buildPrivatePhotoMetadata(); String photoId = uploader.upload("""".getBytes(), metaData); assertNotNull(photoId); } } @Test
    public void testUploadInputStream() throws IOException, FlickrException { File imageFile = new File(testProperties.getImageFile()); Uploader uploader = flickr.getUploader(); PhotosInterface pint = flickr.getPhotosInterface(); if (testProperties.isRealFlickr()) { try (InputStream in = new FileInputStream(imageFile)) { UploadMetaData metaData = buildPrivatePhotoMetadata(); metaData.setPublicFlag(false); metaData.setTitle(""óöä""); String photoId = uploader.upload(in, metaData); assertNotNull(photoId); try { pint.delete(photoId); } catch (FlickrException e) { if (!e.getErrorCode().equals(""99"")) { throw e; } } } } else { UploadMetaData metaData = buildPrivatePhotoMetadata(); String photoId = uploader.upload("""".getBytes(), metaData); assertNotNull(photoId); } } @Test
    public void testReplaceInputStream() throws IOException, FlickrException, InterruptedException { Uploader uploader = flickr.getUploader(); PhotosInterface pint = flickr.getPhotosInterface(); File imageFile = new File(testProperties.getImageFile()); if (testProperties.isRealFlickr()) { String photoId; try (InputStream uploadIS = new FileInputStream(imageFile)) { UploadMetaData metaData = buildPrivatePhotoMetadata(); photoId = uploader.upload(uploadIS, metaData); } Thread.sleep(1500); try (InputStream replaceIS = new FileInputStream(imageFile)) { try { photoId = uploader.replace(replaceIS, photoId, false); assertNotNull(photoId); } catch (FlickrException e) { if (!e.getErrorCode().equals(""1"")) { throw e; } } try { pint.delete(photoId); } catch (FlickrException e) { if (!e.getErrorCode().equals(""99"")) { throw e; } } } } else { try (InputStream replaceIS = new ByteArrayInputStream("""".getBytes())) { String photoId = uploader.replace(replaceIS, DUMMY_PHOTO_ID, false); assertNotNull(photoId); } } } @Test
    public void testReplaceByteArray() throws IOException, FlickrException, InterruptedException { File imageFile = new File(testProperties.getImageFile()); Uploader uploader = flickr.getUploader(); PhotosInterface pint = flickr.getPhotosInterface(); if (testProperties.isRealFlickr()) { UploadMetaData metaData = buildPrivatePhotoMetadata(); String photoId = uploader.upload(Files.readAllBytes(imageFile.toPath()), metaData); Thread.sleep(1500); try { photoId = uploader.replace(Files.readAllBytes(imageFile.toPath()), photoId, false); assertNotNull(photoId); } catch (FlickrException e) { if (!e.getErrorCode().equals(""1"")) { throw e; } } try { pint.delete(photoId); } catch (FlickrException e) { if (!e.getErrorCode().equals(""99"")) { throw e; } } } else { String photoId = uploader.replace("""".getBytes(), DUMMY_PHOTO_ID, false); assertNotNull(photoId); } } private UploadMetaData buildPrivatePhotoMetadata() { UploadMetaData uploadMetaData = new UploadMetaData(); uploadMetaData.setPublicFlag(false); return uploadMetaData; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.photos.PhotosInterface; import com.flickr4java.flickr.uploader.UploadMetaData; import com.flickr4java.flickr.uploader.Uploader; import org.junit.Test; import java.io.*; import java.nio.file.Files; import static org.junit.Assert.assertNotNull; public class UploaderTest extends Flickr4JavaTest { private static final String DUMMY_PHOTO_ID = ""1234567890""; @Test
    public void testUploadByteArray() throws IOException, FlickrException { File imageFile = new File(testProperties.getImageFile()); Uploader uploader = flickr.getUploader(); PhotosInterface pint = flickr.getPhotosInterface(); if (testProperties.isRealFlickr()) { UploadMetaData metaData = buildPrivatePhotoMetadata(); metaData.setTitle(""óöä""); String photoId = uploader.upload(Files.readAllBytes(imageFile.toPath()), metaData); assertNotNull(photoId); try { pint.delete(photoId); } catch (FlickrException e) { if (!e.getErrorCode().equals(""99"")) { throw e; } } } else { UploadMetaData metaData = buildPrivatePhotoMetadata(); String photoId = uploader.upload("""".getBytes(), metaData); assertNotNull(photoId); } } @Test
    public void testUploadInputStream() throws IOException, FlickrException { File imageFile = new File(testProperties.getImageFile()); Uploader uploader = flickr.getUploader(); PhotosInterface pint = flickr.getPhotosInterface(); if (testProperties.isRealFlickr()) { try (InputStream in = new FileInputStream(imageFile)) { UploadMetaData metaData = buildPrivatePhotoMetadata(); metaData.setPublicFlag(false); metaData.setTitle(""óöä""); String photoId = uploader.upload(in, metaData); assertNotNull(photoId); try { pint.delete(photoId); } catch (FlickrException e) { if (!e.getErrorCode().equals(""99"")) { throw e; } } } } else { UploadMetaData metaData = buildPrivatePhotoMetadata(); String photoId = uploader.upload("""".getBytes(), metaData); assertNotNull(photoId); } } @Test
    public void testReplaceInputStream() throws IOException, FlickrException, InterruptedException { Uploader uploader = flickr.getUploader(); PhotosInterface pint = flickr.getPhotosInterface(); File imageFile = new File(testProperties.getImageFile()); if (testProperties.isRealFlickr()) { String photoId; try (InputStream uploadIS = new FileInputStream(imageFile)) { UploadMetaData metaData = buildPrivatePhotoMetadata(); photoId = uploader.upload(uploadIS, metaData); } Thread.sleep(1500); try (InputStream replaceIS = new FileInputStream(imageFile)) { try { photoId = uploader.replace(replaceIS, photoId, false); assertNotNull(photoId); } catch (FlickrException e) { if (!e.getErrorCode().equals(""1"")) { throw e; } } try { pint.delete(photoId); } catch (FlickrException e) { if (!e.getErrorCode().equals(""99"")) { throw e; } } } } else { try (InputStream replaceIS = new ByteArrayInputStream("""".getBytes())) { String photoId = uploader.replace(replaceIS, DUMMY_PHOTO_ID, false); assertNotNull(photoId); } } } @Test
    public void testReplaceByteArray() throws IOException, FlickrException, InterruptedException { File imageFile = new File(testProperties.getImageFile()); Uploader uploader = flickr.getUploader(); PhotosInterface pint = flickr.getPhotosInterface(); if (testProperties.isRealFlickr()) { UploadMetaData metaData = buildPrivatePhotoMetadata(); String photoId = uploader.upload(Files.readAllBytes(imageFile.toPath()), metaData); Thread.sleep(1500); try { photoId = uploader.replace(Files.readAllBytes(imageFile.toPath()), photoId, false); assertNotNull(photoId); } catch (FlickrException e) { if (!e.getErrorCode().equals(""1"")) { throw e; } } try { pint.delete(photoId); } catch (FlickrException e) { if (!e.getErrorCode().equals(""99"")) { throw e; } } } else { String photoId = uploader.replace("""".getBytes(), DUMMY_PHOTO_ID, false); assertNotNull(photoId); } } private UploadMetaData buildPrivatePhotoMetadata() { UploadMetaData uploadMetaData = new UploadMetaData(); uploadMetaData.setPublicFlag(false); return uploadMetaData; } } ","package com.flickr4java.flickr.test;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.photos.PhotosInterface; import com.flickr4java.flickr.uploader.UploadMetaData; import com.flickr4java.flickr.uploader.Uploader; import org.junit.Test;  import java.io.*; import java.nio.file.Files;  import static org.junit.Assert.assertNotNull;  /**
 * @author Anthony Eden
 */ public class UploaderTest extends Flickr4JavaTest {  private static final String DUMMY_PHOTO_ID = ""1234567890"";  /**
     * Test photo uploading using a byte array.
     *
     * @throws IOException
     * @throws FlickrException if there was a problem connecting to Flickr
     */ @Test
    public void testUploadByteArray() throws IOException, FlickrException { File imageFile = new File(testProperties.getImageFile()); Uploader uploader = flickr.getUploader(); PhotosInterface pint = flickr.getPhotosInterface();  if (testProperties.isRealFlickr()) {  UploadMetaData metaData = buildPrivatePhotoMetadata(); // check correct handling of escaped value metaData.setTitle(""óöä""); String photoId = uploader.upload(Files.readAllBytes(imageFile.toPath()), metaData); assertNotNull(photoId); try { pint.delete(photoId); } catch (FlickrException e) { // Ignore if user doesn't have delete permissions // This will leave a *private* photo in the test account's photostream! if (!e.getErrorCode().equals(""99"")) { throw e; }  } } else { UploadMetaData metaData = buildPrivatePhotoMetadata(); String photoId = uploader.upload("""".getBytes(), metaData); assertNotNull(photoId); } }  /**
     * Test photo upload using an InputStream.
     *
     * @throws IOException
     * @throws FlickrException if there was a problem connecting to Flickr
     */ @Test
    public void testUploadInputStream() throws IOException, FlickrException { File imageFile = new File(testProperties.getImageFile()); Uploader uploader = flickr.getUploader(); PhotosInterface pint = flickr.getPhotosInterface();  if (testProperties.isRealFlickr()) { try (InputStream in = new FileInputStream(imageFile)) { UploadMetaData metaData = buildPrivatePhotoMetadata(); metaData.setPublicFlag(false); // check correct handling of escaped value metaData.setTitle(""óöä""); String photoId = uploader.upload(in, metaData); assertNotNull(photoId); try { pint.delete(photoId); } catch (FlickrException e) { // Ignore if user doesn't have delete permissions // This will leave a *private* photo in the test account's photostream! if (!e.getErrorCode().equals(""99"")) { throw e; } } } } else { UploadMetaData metaData = buildPrivatePhotoMetadata(); String photoId = uploader.upload("""".getBytes(), metaData); assertNotNull(photoId); } }  /**
     * Test photo replace using an InputStream.
     *
     * @throws IOException
     * @throws FlickrException if there was a problem connecting to Flickr
     */ @Test
    public void testReplaceInputStream() throws IOException, FlickrException, InterruptedException { Uploader uploader = flickr.getUploader(); PhotosInterface pint = flickr.getPhotosInterface(); File imageFile = new File(testProperties.getImageFile());  if (testProperties.isRealFlickr()) { String photoId; try (InputStream uploadIS = new FileInputStream(imageFile)) {  // Upload a photo, which we'll replace, then delete UploadMetaData metaData = buildPrivatePhotoMetadata(); photoId = uploader.upload(uploadIS, metaData); }  // Fix some odd timing issue Thread.sleep(1500);  try (InputStream replaceIS = new FileInputStream(imageFile)) {  try { photoId = uploader.replace(replaceIS, photoId, false); assertNotNull(photoId); } catch (FlickrException e) { // Error code 1 means test account is not pro so don't fail test because of that if (!e.getErrorCode().equals(""1"")) { throw e; } } try { pint.delete(photoId); } catch (FlickrException e) { // Ignore if user doesn't have delete permissions // This will leave a *private* photo in the test account's photostream! if (!e.getErrorCode().equals(""99"")) { throw e; } } } } else { try (InputStream replaceIS = new ByteArrayInputStream("""".getBytes())) { String photoId = uploader.replace(replaceIS, DUMMY_PHOTO_ID, false); assertNotNull(photoId); } } }  /**
     * Test photo replace using a byte array.
     *
     * @throws IOException
     * @throws FlickrException if there was a problem connecting to Flickr
     */ @Test
    public void testReplaceByteArray() throws IOException, FlickrException, InterruptedException { File imageFile = new File(testProperties.getImageFile()); Uploader uploader = flickr.getUploader(); PhotosInterface pint = flickr.getPhotosInterface();  if (testProperties.isRealFlickr()) {  // Upload a photo, which we'll replace, then delete UploadMetaData metaData = buildPrivatePhotoMetadata(); String photoId = uploader.upload(Files.readAllBytes(imageFile.toPath()), metaData);  // Fix some odd timing issue Thread.sleep(1500);  try { photoId = uploader.replace(Files.readAllBytes(imageFile.toPath()), photoId, false); assertNotNull(photoId); } catch (FlickrException e) { // Error code 1 means test account is not pro so don't fail test because of that if (!e.getErrorCode().equals(""1"")) { throw e; } }  try { pint.delete(photoId); } catch (FlickrException e) { // Ignore if user doesn't have delete permissions // This will leave a *private* photo in the test account's photostream! if (!e.getErrorCode().equals(""99"")) { throw e; } } } else { String photoId = uploader.replace("""".getBytes(), DUMMY_PHOTO_ID, false); assertNotNull(photoId); } }  /**
     * Build {@link UploadMetaData} with public set to false so uploaded photos are private.
     *
     * @return
     */ private UploadMetaData buildPrivatePhotoMetadata() { UploadMetaData uploadMetaData = new UploadMetaData(); uploadMetaData.setPublicFlag(false); return uploadMetaData; }  }  "
src/test/java/com/flickr4java/flickr/test/UrlsInterfaceTest.java,"package com.flickr4java.flickr.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.galleries.Gallery;
import com.flickr4java.flickr.groups.Group;
import com.flickr4java.flickr.urls.UrlsInterface;

import org.junit.Before;
import org.junit.Test;

/**
 * @author Anthony Eden
 */
public class UrlsInterfaceTest extends Flickr4JavaTest {

    @Override
    @Before
    public void setUp() throws FlickrException {
        super.setUp();
        clearAuth();
    }

    @Test
    public void testGetGroup() throws FlickrException {
        UrlsInterface iface = flickr.getUrlsInterface();
        String url = iface.getGroup(testProperties.getGroupId());
        assertEquals(""https://www.flickr.com/groups/central/"", url);
    }

    @Test
    public void testGetUserPhotos() throws FlickrException {
        UrlsInterface iface = flickr.getUrlsInterface();
        String url = iface.getUserPhotos(testProperties.getNsid());
        String username = testProperties.getUsername();
        assertEquals(String.format(""https://www.flickr.com/photos/%s/"", username), url);
    }

    @Test
    public void testGetUserProfile() throws FlickrException {
        UrlsInterface iface = flickr.getUrlsInterface();
        String url = iface.getUserProfile(testProperties.getNsid());
        String username = testProperties.getUsername();
        assertEquals(String.format(""https://www.flickr.com/people/%s/"", username), url);
    }

    @Test
    public void testLookupGroup() throws FlickrException {
        UrlsInterface iface = flickr.getUrlsInterface();
        Group group = iface.lookupGroup(""https://www.flickr.com/groups/central/"");
        assertEquals(""FlickrCentral"", group.getName());
        assertEquals(testProperties.getGroupId(), group.getId());
    }

    @Test
    public void testLookupUsernameByURL() throws FlickrException {
        UrlsInterface iface = flickr.getUrlsInterface();
        String username = testProperties.getUsername();
        String usernameOnFlickr = iface.lookupUsernameByURL(String.format(""https://www.flickr.com/people/%s/"", username));
        assertEquals(username, usernameOnFlickr);
    }

    @Test
    public void testLookupGallery() throws FlickrException {
        UrlsInterface iface = flickr.getUrlsInterface();

        Gallery gallery = iface.lookupGallery(String.format(""https://www.flickr.com/photos/%s/"",
                testProperties.getUsername() + ""/galleries/"" + testProperties.getGalleryId()));
        assertNotNull(gallery);
        assertTrue(gallery.getId().endsWith(testProperties.getGalleryId()));
    }

}
","package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.galleries.Gallery; import com.flickr4java.flickr.groups.Group; import com.flickr4java.flickr.urls.UrlsInterface; import org.junit.Before; import org.junit.Test; public class UrlsInterfaceTest extends Flickr4JavaTest { @Override
    @Before
    public void setUp() throws FlickrException { super.setUp(); clearAuth(); } @Test
    public void testGetGroup() throws FlickrException { UrlsInterface iface = flickr.getUrlsInterface(); String url = iface.getGroup(testProperties.getGroupId()); } @Test
    public void testGetUserPhotos() throws FlickrException { UrlsInterface iface = flickr.getUrlsInterface(); String url = iface.getUserPhotos(testProperties.getNsid()); String username = testProperties.getUsername(); } @Test
    public void testGetUserProfile() throws FlickrException { UrlsInterface iface = flickr.getUrlsInterface(); String url = iface.getUserProfile(testProperties.getNsid()); String username = testProperties.getUsername(); } @Test
    public void testLookupGroup() throws FlickrException { UrlsInterface iface = flickr.getUrlsInterface(); assertEquals(""FlickrCentral"", group.getName()); assertEquals(testProperties.getGroupId(), group.getId()); } @Test
    public void testLookupUsernameByURL() throws FlickrException { UrlsInterface iface = flickr.getUrlsInterface(); String username = testProperties.getUsername(); assertEquals(username, usernameOnFlickr); } @Test
    public void testLookupGallery() throws FlickrException { UrlsInterface iface = flickr.getUrlsInterface(); testProperties.getUsername() + ""/galleries/"" + testProperties.getGalleryId())); assertNotNull(gallery); assertTrue(gallery.getId().endsWith(testProperties.getGalleryId())); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.galleries.Gallery; import com.flickr4java.flickr.groups.Group; import com.flickr4java.flickr.urls.UrlsInterface; import org.junit.Before; import org.junit.Test; public class UrlsInterfaceTest extends Flickr4JavaTest { @Override
    @Before
    public void setUp() throws FlickrException { super.setUp(); clearAuth(); } @Test
    public void testGetGroup() throws FlickrException { UrlsInterface iface = flickr.getUrlsInterface(); String url = iface.getGroup(testProperties.getGroupId()); } @Test
    public void testGetUserPhotos() throws FlickrException { UrlsInterface iface = flickr.getUrlsInterface(); String url = iface.getUserPhotos(testProperties.getNsid()); String username = testProperties.getUsername(); } @Test
    public void testGetUserProfile() throws FlickrException { UrlsInterface iface = flickr.getUrlsInterface(); String url = iface.getUserProfile(testProperties.getNsid()); String username = testProperties.getUsername(); } @Test
    public void testLookupGroup() throws FlickrException { UrlsInterface iface = flickr.getUrlsInterface(); assertEquals(""FlickrCentral"", group.getName()); assertEquals(testProperties.getGroupId(), group.getId()); } @Test
    public void testLookupUsernameByURL() throws FlickrException { UrlsInterface iface = flickr.getUrlsInterface(); String username = testProperties.getUsername(); assertEquals(username, usernameOnFlickr); } @Test
    public void testLookupGallery() throws FlickrException { UrlsInterface iface = flickr.getUrlsInterface(); testProperties.getUsername() + ""/galleries/"" + testProperties.getGalleryId())); assertNotNull(gallery); assertTrue(gallery.getId().endsWith(testProperties.getGalleryId())); } } ","package com.flickr4java.flickr.test;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.galleries.Gallery; import com.flickr4java.flickr.groups.Group; import com.flickr4java.flickr.urls.UrlsInterface;  import org.junit.Before; import org.junit.Test;  /**
 * @author Anthony Eden
 */ public class UrlsInterfaceTest extends Flickr4JavaTest {  @Override
    @Before
    public void setUp() throws FlickrException { super.setUp(); clearAuth(); }  @Test
    public void testGetGroup() throws FlickrException { UrlsInterface iface = flickr.getUrlsInterface(); String url = iface.getGroup(testProperties.getGroupId()); //www.flickr.com/groups/central/"", url); }  @Test
    public void testGetUserPhotos() throws FlickrException { UrlsInterface iface = flickr.getUrlsInterface(); String url = iface.getUserPhotos(testProperties.getNsid()); String username = testProperties.getUsername(); //www.flickr.com/photos/%s/"", username), url); }  @Test
    public void testGetUserProfile() throws FlickrException { UrlsInterface iface = flickr.getUrlsInterface(); String url = iface.getUserProfile(testProperties.getNsid()); String username = testProperties.getUsername(); //www.flickr.com/people/%s/"", username), url); }  @Test
    public void testLookupGroup() throws FlickrException { UrlsInterface iface = flickr.getUrlsInterface(); //www.flickr.com/groups/central/""); assertEquals(""FlickrCentral"", group.getName()); assertEquals(testProperties.getGroupId(), group.getId()); }  @Test
    public void testLookupUsernameByURL() throws FlickrException { UrlsInterface iface = flickr.getUrlsInterface(); String username = testProperties.getUsername(); //www.flickr.com/people/%s/"", username)); assertEquals(username, usernameOnFlickr); }  @Test
    public void testLookupGallery() throws FlickrException { UrlsInterface iface = flickr.getUrlsInterface();  //www.flickr.com/photos/%s/"", testProperties.getUsername() + ""/galleries/"" + testProperties.getGalleryId())); assertNotNull(gallery); assertTrue(gallery.getId().endsWith(testProperties.getGalleryId())); }  }  "
src/main/java/com/flickr4java/flickr/groups/discuss/GroupDiscussInterface.java,"package com.flickr4java.flickr.groups.discuss;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.util.XMLUtilities;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.util.HashMap;
import java.util.Map;

/**
 * Group.Discuss Interface.
 *
 * @author Jonathan Willis
 */
public class GroupDiscussInterface {

    public static final String METHOD_TOPICS_GET_LIST = ""flickr.groups.discuss.topics.getList"";

    public static final String METHOD_TOPICS_GET_INFO = ""flickr.groups.discuss.topics.getInfo"";

    public static final String METHOD_REPLIES_GET_LIST = ""flickr.groups.discuss.replies.getList"";

    public static final String METHOD_REPLIES_GET_INFO = ""flickr.groups.discuss.replies.getInfo"";

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transportAPI;

    public GroupDiscussInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transportAPI;
    }

    /**
     * Get a list of topics from a group.
     * 
     * @param groupId
     *            Unique identifier of a group returns a list of topics for a given group {@link com.flickr4java.flickr.groups.Group}.
     * @param perPage
     *            Number of records per page.
     * @param page
     *            Result-section.
     * @return A group topic list
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see <a href=""http://www.flickr.com/services/api/flickr.groups.discuss.topics.getList.html"">API Documentation</a>
     */
    public TopicList<Topic> getTopicsList(String groupId, int perPage, int page) throws FlickrException {
        TopicList<Topic> topicList = new TopicList<Topic>();
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_TOPICS_GET_LIST);

        parameters.put(""group_id"", groupId);

        if (perPage > 0) {
            parameters.put(""per_page"", """" + perPage);
        }
        if (page > 0) {
            parameters.put(""page"", """" + page);
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element topicElements = response.getPayload();
        topicList.setPage(topicElements.getAttribute(""page""));
        topicList.setPages(topicElements.getAttribute(""pages""));
        topicList.setPerPage(topicElements.getAttribute(""perpage""));
        topicList.setTotal(topicElements.getAttribute(""total""));
        topicList.setGroupId(topicElements.getAttribute(""group_id""));
        topicList.setIconServer(Integer.parseInt(topicElements.getAttribute(""iconserver"")));
        topicList.setIconFarm(Integer.parseInt(topicElements.getAttribute(""iconfarm"")));
        topicList.setName(topicElements.getAttribute(""name""));
        topicList.setMembers(Integer.parseInt(topicElements.getAttribute(""members"")));
        topicList.setPrivacy(Integer.parseInt(topicElements.getAttribute(""privacy"")));
        topicList.setLanguage(topicElements.getAttribute(""lang""));
        topicList.setIsPoolModerated(""1"".equals(topicElements.getAttribute(""ispoolmoderated"")));

        NodeList topicNodes = topicElements.getElementsByTagName(""topic"");
        for (int i = 0; i < topicNodes.getLength(); i++) {
            Element element = (Element) topicNodes.item(i);
            topicList.add(parseTopic(element));
        }
        return topicList;
    }

    /**
     * Get info for a given topic
     * 
     * @param topicId
     *            Unique identifier of a topic for a given group {@link Topic}.
     * @return A group topic
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see <a href=""http://www.flickr.com/services/api/flickr.groups.discuss.topics.getInfo.html"">API Documentation</a>
     */
    public Topic getTopicInfo(String topicId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_TOPICS_GET_INFO);
        parameters.put(""topic_id"", topicId);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element topicElement = response.getPayload();

        return parseTopic(topicElement);
    }

    /**
     * Get list of replies
     * 
     * @param topicId
     *            Unique identifier of a topic for a given group {@link Topic}.
     * @return A reply object
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see <a href=""http://www.flickr.com/services/api/flickr.groups.discuss.replies.getList.html"">API Documentation</a>
     */
    public ReplyObject getReplyList(String topicId, int perPage, int page) throws FlickrException {
        ReplyList<Reply> reply = new ReplyList<Reply>();
        TopicList<Topic> topic = new TopicList<Topic>();
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_REPLIES_GET_LIST);

        parameters.put(""topic_id"", topicId);

        if (perPage > 0) {
            parameters.put(""per_page"", """" + perPage);
        }
        if (page > 0) {
            parameters.put(""page"", """" + page);
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element replyElements = response.getPayload();
        ReplyObject ro = new ReplyObject();
        NodeList replyNodes = replyElements.getElementsByTagName(""reply"");
        for (int i = 0; i < replyNodes.getLength(); i++) {
            Element replyNodeElement = (Element) replyNodes.item(i);
            // Element replyElement = XMLUtilities.getChild(replyNodeElement, ""reply"");
            reply.add(parseReply(replyNodeElement));
            ro.setReplyList(reply);

        }
        NodeList topicNodes = replyElements.getElementsByTagName(""topic"");
        for (int i = 0; i < topicNodes.getLength(); i++) {
            Element replyNodeElement = (Element) replyNodes.item(i);
            // Element topicElement = XMLUtilities.getChild(replyNodeElement, ""topic"");
            topic.add(parseTopic(replyNodeElement));
            ro.setTopicList(topic);
        }

        return ro;
    }

    /**
     * Get info for a given topic reply
     * 
     * @param topicId
     *            Unique identifier of a topic for a given group {@link Topic}.
     * @param replyId
     *            Unique identifier of a reply for a given topic {@link Reply}.
     * @return A group topic
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see <a href=""http://www.flickr.com/services/api/flickr.groups.discuss.replies.getInfo.html"">API Documentation</a>
     */
    public Reply getReplyInfo(String topicId, String replyId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_REPLIES_GET_INFO);
        parameters.put(""topic_id"", topicId);
        parameters.put(""reply_id"", replyId);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element replyElement = response.getPayload();

        return parseReply(replyElement);
    }

    private Topic parseTopic(Element tElement) {
        Topic topic = new Topic();
        topic.setAuthorId(tElement.getAttribute(""author""));
        topic.setAuthorname(tElement.getAttribute(""authorname""));
        topic.setIsCanDelete(""1"".equals(tElement.getAttribute(""can_delete"")));
        topic.setIsCanEdit(""1"".equals(tElement.getAttribute(""can_edit"")));
        topic.setIsCanReply(""1"".equals(tElement.getAttribute(""can_reply"")));
        if (!tElement.getAttribute(""count_replies"").equals("""")) {
            topic.setCountReplies(Integer.parseInt(tElement.getAttribute(""count_replies"")));
        }
        topic.setDatecreate(tElement.getAttribute(""datecreate""));
        topic.setDatelastpost(tElement.getAttribute(""datelastpost""));
        topic.setIconfarm(Integer.parseInt(tElement.getAttribute(""iconfarm"")));
        topic.setIconserver(Integer.parseInt(tElement.getAttribute(""iconserver"")));
        topic.setIsLocked(""1"".equals(tElement.getAttribute(""is_locked"")));
        topic.setMessage(XMLUtilities.getChildValue(tElement, ""message""));
        topic.setRole(tElement.getAttribute(""role""));
        topic.setIsSticky(""1"".equals(tElement.getAttribute(""is_sticky"")));
        topic.setSubject(tElement.getAttribute(""subject""));
        topic.setTopicId(tElement.getAttribute(""id""));
        topic.setIsPro(""1"".equals(tElement.getAttribute(""is_pro"")));
        topic.setLastReply(tElement.getAttribute(""last_reply""));
        return topic;
    }

    private Reply parseReply(Element rElement) {
        Reply reply = new Reply();
        reply.setAuthorId(rElement.getAttribute(""author""));
        reply.setAuthorname(rElement.getAttribute(""authorname""));
        reply.setIsCanDelete(""1"".equals(rElement.getAttribute(""can_delete"")));
        reply.setIsCanEdit(""1"".equals(rElement.getAttribute(""can_edit"")));
        reply.setDatecreate(rElement.getAttribute(""datecreate""));
        reply.setLastEdit(rElement.getAttribute(""lastedit""));
        reply.setIconfarm(Integer.parseInt(rElement.getAttribute(""iconfarm"")));
        reply.setIconserver(Integer.parseInt(rElement.getAttribute(""iconserver"")));
        reply.setMessage(XMLUtilities.getChildValue(rElement, ""message""));
        reply.setRole(rElement.getAttribute(""role""));
        reply.setReplyId(rElement.getAttribute(""id""));
        reply.setIsPro(""1"".equals(rElement.getAttribute(""is_pro"")));
        return reply;
    }

}
","package com.flickr4java.flickr.groups.discuss; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.HashMap; import java.util.Map; public class GroupDiscussInterface { public static final String METHOD_TOPICS_GET_LIST = ""flickr.groups.discuss.topics.getList""; public static final String METHOD_TOPICS_GET_INFO = ""flickr.groups.discuss.topics.getInfo""; public static final String METHOD_REPLIES_GET_LIST = ""flickr.groups.discuss.replies.getList""; public static final String METHOD_REPLIES_GET_INFO = ""flickr.groups.discuss.replies.getInfo""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public GroupDiscussInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public TopicList<Topic> getTopicsList(String groupId, int perPage, int page) throws FlickrException { TopicList<Topic> topicList = new TopicList<Topic>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_TOPICS_GET_LIST); parameters.put(""group_id"", groupId); if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element topicElements = response.getPayload(); topicList.setPage(topicElements.getAttribute(""page"")); topicList.setPages(topicElements.getAttribute(""pages"")); topicList.setPerPage(topicElements.getAttribute(""perpage"")); topicList.setTotal(topicElements.getAttribute(""total"")); topicList.setGroupId(topicElements.getAttribute(""group_id"")); topicList.setIconServer(Integer.parseInt(topicElements.getAttribute(""iconserver""))); topicList.setIconFarm(Integer.parseInt(topicElements.getAttribute(""iconfarm""))); topicList.setName(topicElements.getAttribute(""name"")); topicList.setMembers(Integer.parseInt(topicElements.getAttribute(""members""))); topicList.setPrivacy(Integer.parseInt(topicElements.getAttribute(""privacy""))); topicList.setLanguage(topicElements.getAttribute(""lang"")); topicList.setIsPoolModerated(""1"".equals(topicElements.getAttribute(""ispoolmoderated""))); NodeList topicNodes = topicElements.getElementsByTagName(""topic""); for (int i = 0; i < topicNodes.getLength(); i++) { Element element = (Element) topicNodes.item(i); topicList.add(parseTopic(element)); } return topicList; } public Topic getTopicInfo(String topicId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_TOPICS_GET_INFO); parameters.put(""topic_id"", topicId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element topicElement = response.getPayload(); return parseTopic(topicElement); } public ReplyObject getReplyList(String topicId, int perPage, int page) throws FlickrException { ReplyList<Reply> reply = new ReplyList<Reply>(); TopicList<Topic> topic = new TopicList<Topic>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REPLIES_GET_LIST); parameters.put(""topic_id"", topicId); if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element replyElements = response.getPayload(); ReplyObject ro = new ReplyObject(); NodeList replyNodes = replyElements.getElementsByTagName(""reply""); for (int i = 0; i < replyNodes.getLength(); i++) { Element replyNodeElement = (Element) replyNodes.item(i); reply.add(parseReply(replyNodeElement)); ro.setReplyList(reply); } NodeList topicNodes = replyElements.getElementsByTagName(""topic""); for (int i = 0; i < topicNodes.getLength(); i++) { Element replyNodeElement = (Element) replyNodes.item(i); topic.add(parseTopic(replyNodeElement)); ro.setTopicList(topic); } return ro; } public Reply getReplyInfo(String topicId, String replyId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REPLIES_GET_INFO); parameters.put(""topic_id"", topicId); parameters.put(""reply_id"", replyId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element replyElement = response.getPayload(); return parseReply(replyElement); } private Topic parseTopic(Element tElement) { Topic topic = new Topic(); topic.setAuthorId(tElement.getAttribute(""author"")); topic.setAuthorname(tElement.getAttribute(""authorname"")); topic.setIsCanDelete(""1"".equals(tElement.getAttribute(""can_delete""))); topic.setIsCanEdit(""1"".equals(tElement.getAttribute(""can_edit""))); topic.setIsCanReply(""1"".equals(tElement.getAttribute(""can_reply""))); if (!tElement.getAttribute(""count_replies"").equals("""")) { topic.setCountReplies(Integer.parseInt(tElement.getAttribute(""count_replies""))); } topic.setDatecreate(tElement.getAttribute(""datecreate"")); topic.setDatelastpost(tElement.getAttribute(""datelastpost"")); topic.setIconfarm(Integer.parseInt(tElement.getAttribute(""iconfarm""))); topic.setIconserver(Integer.parseInt(tElement.getAttribute(""iconserver""))); topic.setIsLocked(""1"".equals(tElement.getAttribute(""is_locked""))); topic.setMessage(XMLUtilities.getChildValue(tElement, ""message"")); topic.setRole(tElement.getAttribute(""role"")); topic.setIsSticky(""1"".equals(tElement.getAttribute(""is_sticky""))); topic.setSubject(tElement.getAttribute(""subject"")); topic.setTopicId(tElement.getAttribute(""id"")); topic.setIsPro(""1"".equals(tElement.getAttribute(""is_pro""))); topic.setLastReply(tElement.getAttribute(""last_reply"")); return topic; } private Reply parseReply(Element rElement) { Reply reply = new Reply(); reply.setAuthorId(rElement.getAttribute(""author"")); reply.setAuthorname(rElement.getAttribute(""authorname"")); reply.setIsCanDelete(""1"".equals(rElement.getAttribute(""can_delete""))); reply.setIsCanEdit(""1"".equals(rElement.getAttribute(""can_edit""))); reply.setDatecreate(rElement.getAttribute(""datecreate"")); reply.setLastEdit(rElement.getAttribute(""lastedit"")); reply.setIconfarm(Integer.parseInt(rElement.getAttribute(""iconfarm""))); reply.setIconserver(Integer.parseInt(rElement.getAttribute(""iconserver""))); reply.setMessage(XMLUtilities.getChildValue(rElement, ""message"")); reply.setRole(rElement.getAttribute(""role"")); reply.setReplyId(rElement.getAttribute(""id"")); reply.setIsPro(""1"".equals(rElement.getAttribute(""is_pro""))); return reply; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.groups.discuss; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.HashMap; import java.util.Map; public class GroupDiscussInterface { public static final String METHOD_TOPICS_GET_LIST = ""flickr.groups.discuss.topics.getList""; public static final String METHOD_TOPICS_GET_INFO = ""flickr.groups.discuss.topics.getInfo""; public static final String METHOD_REPLIES_GET_LIST = ""flickr.groups.discuss.replies.getList""; public static final String METHOD_REPLIES_GET_INFO = ""flickr.groups.discuss.replies.getInfo""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public GroupDiscussInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public TopicList<Topic> getTopicsList(String groupId, int perPage, int page) throws FlickrException { TopicList<Topic> topicList = new TopicList<Topic>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_TOPICS_GET_LIST); parameters.put(""group_id"", groupId); if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element topicElements = response.getPayload(); topicList.setPage(topicElements.getAttribute(""page"")); topicList.setPages(topicElements.getAttribute(""pages"")); topicList.setPerPage(topicElements.getAttribute(""perpage"")); topicList.setTotal(topicElements.getAttribute(""total"")); topicList.setGroupId(topicElements.getAttribute(""group_id"")); topicList.setIconServer(Integer.parseInt(topicElements.getAttribute(""iconserver""))); topicList.setIconFarm(Integer.parseInt(topicElements.getAttribute(""iconfarm""))); topicList.setName(topicElements.getAttribute(""name"")); topicList.setMembers(Integer.parseInt(topicElements.getAttribute(""members""))); topicList.setPrivacy(Integer.parseInt(topicElements.getAttribute(""privacy""))); topicList.setLanguage(topicElements.getAttribute(""lang"")); topicList.setIsPoolModerated(""1"".equals(topicElements.getAttribute(""ispoolmoderated""))); NodeList topicNodes = topicElements.getElementsByTagName(""topic""); for (int i = 0; i < topicNodes.getLength(); i++) { Element element = (Element) topicNodes.item(i); topicList.add(parseTopic(element)); } return topicList; } public Topic getTopicInfo(String topicId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_TOPICS_GET_INFO); parameters.put(""topic_id"", topicId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element topicElement = response.getPayload(); return parseTopic(topicElement); } public ReplyObject getReplyList(String topicId, int perPage, int page) throws FlickrException { ReplyList<Reply> reply = new ReplyList<Reply>(); TopicList<Topic> topic = new TopicList<Topic>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REPLIES_GET_LIST); parameters.put(""topic_id"", topicId); if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element replyElements = response.getPayload(); ReplyObject ro = new ReplyObject(); NodeList replyNodes = replyElements.getElementsByTagName(""reply""); for (int i = 0; i < replyNodes.getLength(); i++) { Element replyNodeElement = (Element) replyNodes.item(i); reply.add(parseReply(replyNodeElement)); ro.setReplyList(reply); } NodeList topicNodes = replyElements.getElementsByTagName(""topic""); for (int i = 0; i < topicNodes.getLength(); i++) { Element replyNodeElement = (Element) replyNodes.item(i); topic.add(parseTopic(replyNodeElement)); ro.setTopicList(topic); } return ro; } public Reply getReplyInfo(String topicId, String replyId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REPLIES_GET_INFO); parameters.put(""topic_id"", topicId); parameters.put(""reply_id"", replyId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element replyElement = response.getPayload(); return parseReply(replyElement); } private Topic parseTopic(Element tElement) { Topic topic = new Topic(); topic.setAuthorId(tElement.getAttribute(""author"")); topic.setAuthorname(tElement.getAttribute(""authorname"")); topic.setIsCanDelete(""1"".equals(tElement.getAttribute(""can_delete""))); topic.setIsCanEdit(""1"".equals(tElement.getAttribute(""can_edit""))); topic.setIsCanReply(""1"".equals(tElement.getAttribute(""can_reply""))); if (!tElement.getAttribute(""count_replies"").equals("""")) { topic.setCountReplies(Integer.parseInt(tElement.getAttribute(""count_replies""))); } topic.setDatecreate(tElement.getAttribute(""datecreate"")); topic.setDatelastpost(tElement.getAttribute(""datelastpost"")); topic.setIconfarm(Integer.parseInt(tElement.getAttribute(""iconfarm""))); topic.setIconserver(Integer.parseInt(tElement.getAttribute(""iconserver""))); topic.setIsLocked(""1"".equals(tElement.getAttribute(""is_locked""))); topic.setMessage(XMLUtilities.getChildValue(tElement, ""message"")); topic.setRole(tElement.getAttribute(""role"")); topic.setIsSticky(""1"".equals(tElement.getAttribute(""is_sticky""))); topic.setSubject(tElement.getAttribute(""subject"")); topic.setTopicId(tElement.getAttribute(""id"")); topic.setIsPro(""1"".equals(tElement.getAttribute(""is_pro""))); topic.setLastReply(tElement.getAttribute(""last_reply"")); return topic; } private Reply parseReply(Element rElement) { Reply reply = new Reply(); reply.setAuthorId(rElement.getAttribute(""author"")); reply.setAuthorname(rElement.getAttribute(""authorname"")); reply.setIsCanDelete(""1"".equals(rElement.getAttribute(""can_delete""))); reply.setIsCanEdit(""1"".equals(rElement.getAttribute(""can_edit""))); reply.setDatecreate(rElement.getAttribute(""datecreate"")); reply.setLastEdit(rElement.getAttribute(""lastedit"")); reply.setIconfarm(Integer.parseInt(rElement.getAttribute(""iconfarm""))); reply.setIconserver(Integer.parseInt(rElement.getAttribute(""iconserver""))); reply.setMessage(XMLUtilities.getChildValue(rElement, ""message"")); reply.setRole(rElement.getAttribute(""role"")); reply.setReplyId(rElement.getAttribute(""id"")); reply.setIsPro(""1"".equals(rElement.getAttribute(""is_pro""))); return reply; } } ","package com.flickr4java.flickr.groups.discuss;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.XMLUtilities;  import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import java.util.HashMap; import java.util.Map;  /**
 * Group.Discuss Interface.
 *
 * @author Jonathan Willis
 */ public class GroupDiscussInterface {  public static final String METHOD_TOPICS_GET_LIST = ""flickr.groups.discuss.topics.getList"";  public static final String METHOD_TOPICS_GET_INFO = ""flickr.groups.discuss.topics.getInfo"";  public static final String METHOD_REPLIES_GET_LIST = ""flickr.groups.discuss.replies.getList"";  public static final String METHOD_REPLIES_GET_INFO = ""flickr.groups.discuss.replies.getInfo"";  private final String apiKey;  private final String sharedSecret;  private final Transport transportAPI;  public GroupDiscussInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; }  /**
     * Get a list of topics from a group.
     * 
     * @param groupId
     *            Unique identifier of a group returns a list of topics for a given group {@link com.flickr4java.flickr.groups.Group}.
     * @param perPage
     *            Number of records per page.
     * @param page
     *            Result-section.
     * @return A group topic list
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see <a href=""http://www.flickr.com/services/api/flickr.groups.discuss.topics.getList.html"">API Documentation</a>
     */ public TopicList<Topic> getTopicsList(String groupId, int perPage, int page) throws FlickrException { TopicList<Topic> topicList = new TopicList<Topic>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_TOPICS_GET_LIST);  parameters.put(""group_id"", groupId);  if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element topicElements = response.getPayload(); topicList.setPage(topicElements.getAttribute(""page"")); topicList.setPages(topicElements.getAttribute(""pages"")); topicList.setPerPage(topicElements.getAttribute(""perpage"")); topicList.setTotal(topicElements.getAttribute(""total"")); topicList.setGroupId(topicElements.getAttribute(""group_id"")); topicList.setIconServer(Integer.parseInt(topicElements.getAttribute(""iconserver""))); topicList.setIconFarm(Integer.parseInt(topicElements.getAttribute(""iconfarm""))); topicList.setName(topicElements.getAttribute(""name"")); topicList.setMembers(Integer.parseInt(topicElements.getAttribute(""members""))); topicList.setPrivacy(Integer.parseInt(topicElements.getAttribute(""privacy""))); topicList.setLanguage(topicElements.getAttribute(""lang"")); topicList.setIsPoolModerated(""1"".equals(topicElements.getAttribute(""ispoolmoderated"")));  NodeList topicNodes = topicElements.getElementsByTagName(""topic""); for (int i = 0; i < topicNodes.getLength(); i++) { Element element = (Element) topicNodes.item(i); topicList.add(parseTopic(element)); } return topicList; }  /**
     * Get info for a given topic
     * 
     * @param topicId
     *            Unique identifier of a topic for a given group {@link Topic}.
     * @return A group topic
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see <a href=""http://www.flickr.com/services/api/flickr.groups.discuss.topics.getInfo.html"">API Documentation</a>
     */ public Topic getTopicInfo(String topicId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_TOPICS_GET_INFO); parameters.put(""topic_id"", topicId);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element topicElement = response.getPayload();  return parseTopic(topicElement); }  /**
     * Get list of replies
     * 
     * @param topicId
     *            Unique identifier of a topic for a given group {@link Topic}.
     * @return A reply object
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see <a href=""http://www.flickr.com/services/api/flickr.groups.discuss.replies.getList.html"">API Documentation</a>
     */ public ReplyObject getReplyList(String topicId, int perPage, int page) throws FlickrException { ReplyList<Reply> reply = new ReplyList<Reply>(); TopicList<Topic> topic = new TopicList<Topic>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REPLIES_GET_LIST);  parameters.put(""topic_id"", topicId);  if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element replyElements = response.getPayload(); ReplyObject ro = new ReplyObject(); NodeList replyNodes = replyElements.getElementsByTagName(""reply""); for (int i = 0; i < replyNodes.getLength(); i++) { Element replyNodeElement = (Element) replyNodes.item(i); // Element replyElement = XMLUtilities.getChild(replyNodeElement, ""reply""); reply.add(parseReply(replyNodeElement)); ro.setReplyList(reply);  } NodeList topicNodes = replyElements.getElementsByTagName(""topic""); for (int i = 0; i < topicNodes.getLength(); i++) { Element replyNodeElement = (Element) replyNodes.item(i); // Element topicElement = XMLUtilities.getChild(replyNodeElement, ""topic""); topic.add(parseTopic(replyNodeElement)); ro.setTopicList(topic); }  return ro; }  /**
     * Get info for a given topic reply
     * 
     * @param topicId
     *            Unique identifier of a topic for a given group {@link Topic}.
     * @param replyId
     *            Unique identifier of a reply for a given topic {@link Reply}.
     * @return A group topic
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see <a href=""http://www.flickr.com/services/api/flickr.groups.discuss.replies.getInfo.html"">API Documentation</a>
     */ public Reply getReplyInfo(String topicId, String replyId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REPLIES_GET_INFO); parameters.put(""topic_id"", topicId); parameters.put(""reply_id"", replyId);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element replyElement = response.getPayload();  return parseReply(replyElement); }  private Topic parseTopic(Element tElement) { Topic topic = new Topic(); topic.setAuthorId(tElement.getAttribute(""author"")); topic.setAuthorname(tElement.getAttribute(""authorname"")); topic.setIsCanDelete(""1"".equals(tElement.getAttribute(""can_delete""))); topic.setIsCanEdit(""1"".equals(tElement.getAttribute(""can_edit""))); topic.setIsCanReply(""1"".equals(tElement.getAttribute(""can_reply""))); if (!tElement.getAttribute(""count_replies"").equals("""")) { topic.setCountReplies(Integer.parseInt(tElement.getAttribute(""count_replies""))); } topic.setDatecreate(tElement.getAttribute(""datecreate"")); topic.setDatelastpost(tElement.getAttribute(""datelastpost"")); topic.setIconfarm(Integer.parseInt(tElement.getAttribute(""iconfarm""))); topic.setIconserver(Integer.parseInt(tElement.getAttribute(""iconserver""))); topic.setIsLocked(""1"".equals(tElement.getAttribute(""is_locked""))); topic.setMessage(XMLUtilities.getChildValue(tElement, ""message"")); topic.setRole(tElement.getAttribute(""role"")); topic.setIsSticky(""1"".equals(tElement.getAttribute(""is_sticky""))); topic.setSubject(tElement.getAttribute(""subject"")); topic.setTopicId(tElement.getAttribute(""id"")); topic.setIsPro(""1"".equals(tElement.getAttribute(""is_pro""))); topic.setLastReply(tElement.getAttribute(""last_reply"")); return topic; }  private Reply parseReply(Element rElement) { Reply reply = new Reply(); reply.setAuthorId(rElement.getAttribute(""author"")); reply.setAuthorname(rElement.getAttribute(""authorname"")); reply.setIsCanDelete(""1"".equals(rElement.getAttribute(""can_delete""))); reply.setIsCanEdit(""1"".equals(rElement.getAttribute(""can_edit""))); reply.setDatecreate(rElement.getAttribute(""datecreate"")); reply.setLastEdit(rElement.getAttribute(""lastedit"")); reply.setIconfarm(Integer.parseInt(rElement.getAttribute(""iconfarm""))); reply.setIconserver(Integer.parseInt(rElement.getAttribute(""iconserver""))); reply.setMessage(XMLUtilities.getChildValue(rElement, ""message"")); reply.setRole(rElement.getAttribute(""role"")); reply.setReplyId(rElement.getAttribute(""id"")); reply.setIsPro(""1"".equals(rElement.getAttribute(""is_pro""))); return reply; }  }  "
src/main/java/com/flickr4java/flickr/groups/discuss/Reply.java,"package com.flickr4java.flickr.groups.discuss;

public class Reply {

	private String replyId;
	private String authorId;
	private String authorname;
	private String role;
	private int iconserver;
	private int iconfarm;
	private boolean canEdit;
	private boolean canDelete;
	private String datecreate;
    private String message;
    private String lastEdit;
    private boolean isPro;
    
	public String getReplyId() {
		return replyId;
	}
	public void setReplyId(String replyId) {
		this.replyId = replyId;
	}
	public String getAuthorId() {
		return authorId;
	}
	public void setAuthorId(String authorId) {
		this.authorId = authorId;
	}
	public String getAuthorname() {
		return authorname;
	}
	public void setAuthorname(String authorname) {
		this.authorname = authorname;
	}
	public int getIconserver() {
		return iconserver;
	}
	public void setIconserver(int iconserver) {
		this.iconserver = iconserver;
	}
	public String getRole() {
		return role;
	}
	public void setRole(String role) {
		this.role = role;
	}
	public int getIconfarm() {
		return iconfarm;
	}
	public void setIconfarm(int iconfarm) {
		this.iconfarm = iconfarm;
	}
	public boolean isCanEdit() {
		return canEdit;
	}
	public void setIsCanEdit(boolean canEdit) {
		this.canEdit = canEdit;
	}
	public boolean isCanDelete() {
		return canDelete;
	}
	public void setIsCanDelete(boolean canDelete) {
		this.canDelete = canDelete;
	}
	public String getDatecreate() {
		return datecreate;
	}
	public void setDatecreate(String datecreate) {
		this.datecreate = datecreate;
	}
	public String getMessage() {
		return message;
	}
	public void setMessage(String message) {
		this.message = message;
	}
	public String getLastEdit() {
		return lastEdit;
	}
	public void setLastEdit(String lastEdit) {
		this.lastEdit = lastEdit;
	}
	public boolean isPro() {
		return isPro;
	}
	public void setIsPro(boolean isPro) {
		this.isPro = isPro;
	}
}
",package com.flickr4java.flickr.groups.discuss; public class Reply { private String replyId; private String authorId; private String authorname; private String role; private int iconserver; private int iconfarm; private boolean canEdit; private boolean canDelete; private String datecreate; private String message; private String lastEdit; private boolean isPro; public String getReplyId() { return replyId; } public void setReplyId(String replyId) { this.replyId = replyId; } public String getAuthorId() { return authorId; } public void setAuthorId(String authorId) { this.authorId = authorId; } public String getAuthorname() { return authorname; } public void setAuthorname(String authorname) { this.authorname = authorname; } public int getIconserver() { return iconserver; } public void setIconserver(int iconserver) { this.iconserver = iconserver; } public String getRole() { return role; } public void setRole(String role) { this.role = role; } public int getIconfarm() { return iconfarm; } public void setIconfarm(int iconfarm) { this.iconfarm = iconfarm; } public boolean isCanEdit() { return canEdit; } public void setIsCanEdit(boolean canEdit) { this.canEdit = canEdit; } public boolean isCanDelete() { return canDelete; } public void setIsCanDelete(boolean canDelete) { this.canDelete = canDelete; } public String getDatecreate() { return datecreate; } public void setDatecreate(String datecreate) { this.datecreate = datecreate; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } public String getLastEdit() { return lastEdit; } public void setLastEdit(String lastEdit) { this.lastEdit = lastEdit; } public boolean isPro() { return isPro; } public void setIsPro(boolean isPro) { this.isPro = isPro; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.groups.discuss; public class Reply { private String replyId; private String authorId; private String authorname; private String role; private int iconserver; private int iconfarm; private boolean canEdit; private boolean canDelete; private String datecreate; private String message; private String lastEdit; private boolean isPro; public String getReplyId() { return replyId; } public void setReplyId(String replyId) { this.replyId = replyId; } public String getAuthorId() { return authorId; } public void setAuthorId(String authorId) { this.authorId = authorId; } public String getAuthorname() { return authorname; } public void setAuthorname(String authorname) { this.authorname = authorname; } public int getIconserver() { return iconserver; } public void setIconserver(int iconserver) { this.iconserver = iconserver; } public String getRole() { return role; } public void setRole(String role) { this.role = role; } public int getIconfarm() { return iconfarm; } public void setIconfarm(int iconfarm) { this.iconfarm = iconfarm; } public boolean isCanEdit() { return canEdit; } public void setIsCanEdit(boolean canEdit) { this.canEdit = canEdit; } public boolean isCanDelete() { return canDelete; } public void setIsCanDelete(boolean canDelete) { this.canDelete = canDelete; } public String getDatecreate() { return datecreate; } public void setDatecreate(String datecreate) { this.datecreate = datecreate; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } public String getLastEdit() { return lastEdit; } public void setLastEdit(String lastEdit) { this.lastEdit = lastEdit; } public boolean isPro() { return isPro; } public void setIsPro(boolean isPro) { this.isPro = isPro; } } ,package com.flickr4java.flickr.groups.discuss;  public class Reply {  private String replyId; private String authorId; private String authorname; private String role; private int iconserver; private int iconfarm; private boolean canEdit; private boolean canDelete; private String datecreate; private String message; private String lastEdit; private boolean isPro;      public String getReplyId() { return replyId; } public void setReplyId(String replyId) { this.replyId = replyId; } public String getAuthorId() { return authorId; } public void setAuthorId(String authorId) { this.authorId = authorId; } public String getAuthorname() { return authorname; } public void setAuthorname(String authorname) { this.authorname = authorname; } public int getIconserver() { return iconserver; } public void setIconserver(int iconserver) { this.iconserver = iconserver; } public String getRole() { return role; } public void setRole(String role) { this.role = role; } public int getIconfarm() { return iconfarm; } public void setIconfarm(int iconfarm) { this.iconfarm = iconfarm; } public boolean isCanEdit() { return canEdit; } public void setIsCanEdit(boolean canEdit) { this.canEdit = canEdit; } public boolean isCanDelete() { return canDelete; } public void setIsCanDelete(boolean canDelete) { this.canDelete = canDelete; } public String getDatecreate() { return datecreate; } public void setDatecreate(String datecreate) { this.datecreate = datecreate; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } public String getLastEdit() { return lastEdit; } public void setLastEdit(String lastEdit) { this.lastEdit = lastEdit; } public boolean isPro() { return isPro; } public void setIsPro(boolean isPro) { this.isPro = isPro; } }  
src/main/java/com/flickr4java/flickr/groups/discuss/ReplyList.java,"package com.flickr4java.flickr.groups.discuss;

import java.util.ArrayList;

public class ReplyList<E> extends ArrayList<Reply> {

	/**
	 * 
	 */
	private static final long serialVersionUID = 2830506892011990291L;

}
",package com.flickr4java.flickr.groups.discuss; import java.util.ArrayList; public class ReplyList<E> extends ArrayList<Reply> { private static final long serialVersionUID = 2830506892011990291L; },0 0 0 0 0 0,package com.flickr4java.flickr.groups.discuss; import java.util.ArrayList; public class ReplyList<E> extends ArrayList<Reply> { private static final long serialVersionUID = 2830506892011990291L; } ,"package com.flickr4java.flickr.groups.discuss;  import java.util.ArrayList;  public class ReplyList<E> extends ArrayList<Reply> {  /**
	 * 
	 */ private static final long serialVersionUID = 2830506892011990291L;  }  "
src/main/java/com/flickr4java/flickr/groups/discuss/ReplyObject.java,"package com.flickr4java.flickr.groups.discuss;

import java.util.ArrayList;

public class ReplyObject {

	private ArrayList<Topic> topicList = new ArrayList<Topic>();
	private ArrayList<Reply> replyList = new ArrayList<Reply>();
	
	public ArrayList<Topic> getTopicList() {
		return topicList;
	}
	public void setTopicList(ArrayList<Topic> topicList) {
		this.topicList = topicList;
	}
	public ArrayList<Reply> getReplyList() {
		return replyList;
	}
	public void setReplyList(ArrayList<Reply> replyList) {
		this.replyList = replyList;
	}
	
	
	

}
",package com.flickr4java.flickr.groups.discuss; import java.util.ArrayList; public class ReplyObject { private ArrayList<Topic> topicList = new ArrayList<Topic>(); private ArrayList<Reply> replyList = new ArrayList<Reply>(); public ArrayList<Topic> getTopicList() { return topicList; } public void setTopicList(ArrayList<Topic> topicList) { this.topicList = topicList; } public ArrayList<Reply> getReplyList() { return replyList; } public void setReplyList(ArrayList<Reply> replyList) { this.replyList = replyList; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.groups.discuss; import java.util.ArrayList; public class ReplyObject { private ArrayList<Topic> topicList = new ArrayList<Topic>(); private ArrayList<Reply> replyList = new ArrayList<Reply>(); public ArrayList<Topic> getTopicList() { return topicList; } public void setTopicList(ArrayList<Topic> topicList) { this.topicList = topicList; } public ArrayList<Reply> getReplyList() { return replyList; } public void setReplyList(ArrayList<Reply> replyList) { this.replyList = replyList; } } ,"package com.flickr4java.flickr.groups.discuss;  import java.util.ArrayList;  public class ReplyObject {  private ArrayList<Topic> topicList = new ArrayList<Topic>(); private ArrayList<Reply> replyList = new ArrayList<Reply>(); 	 public ArrayList<Topic> getTopicList() { return topicList; } public void setTopicList(ArrayList<Topic> topicList) { this.topicList = topicList; } public ArrayList<Reply> getReplyList() { return replyList; } public void setReplyList(ArrayList<Reply> replyList) { this.replyList = replyList; } 	
	
	
 }  "
src/main/java/com/flickr4java/flickr/groups/discuss/Topic.java,"package com.flickr4java.flickr.groups.discuss;

public class Topic {

	private String topicId;
	private String subject;
	private String authorId;
	private String authorname;
	private String role;
	private int iconserver;
	private int iconfarm;
	private int countReplies;
	private boolean canEdit;
	private boolean canDelete;
	private boolean canReply;
	private boolean isSticky;
	private boolean isLocked;
	private String datecreate;
	private String datelastpost;
    private String message;
    private String lastReply = """";
    private boolean isPro;
    
	public String getTopicId() {
		return topicId;
	}
	public void setTopicId(String topicId) {
		this.topicId = topicId;
	}
	public String getSubject() {
		return subject;
	}
	public void setSubject(String subject) {
		this.subject = subject;
	}
	public String getAuthorId() {
		return authorId;
	}
	public void setAuthorId(String authorId) {
		this.authorId = authorId;
	}
	public String getAuthorname() {
		return authorname;
	}
	public void setAuthorname(String authorname) {
		this.authorname = authorname;
	}
	public String getRole() {
		return role;
	}
	public void setRole(String role) {
		this.role = role;
	}
	public int getIconserver() {
		return iconserver;
	}
	public void setIconserver(int iconserver) {
		this.iconserver = iconserver;
	}
	public int getIconfarm() {
		return iconfarm;
	}
	public void setIconfarm(int iconfarm) {
		this.iconfarm = iconfarm;
	}

	public boolean isCanEdit() {
		return canEdit;
	}
	public void setIsCanEdit(boolean canEdit) {
		this.canEdit = canEdit;
	}
	public boolean isCanDelete() {
		return canDelete;
	}
	public void setIsCanDelete(boolean canDelete) {
		this.canDelete = canDelete;
	}
	public boolean isCanReply() {
		return canReply;
	}
	public void setIsCanReply(boolean canReply) {
		this.canReply = canReply;
	}
	public boolean isSticky() {
		return isSticky;
	}
	public void setIsSticky(boolean isSticky) {
		this.isSticky = isSticky;
	}
	public boolean isLocked() {
		return isLocked;
	}
	public void setIsLocked(boolean isLocked) {
		this.isLocked = isLocked;
	}
	public String getDatecreate() {
		return datecreate;
	}
	public void setDatecreate(String datecreate) {
		this.datecreate = datecreate;
	}
	public String getDatelastpost() {
		return datelastpost;
	}
	public void setDatelastpost(String datelastpost) {
		this.datelastpost = datelastpost;
	}
	public String getMessage() {
		return message;
	}
	public void setMessage(String message) {
		this.message = message;
	}
	public int getCountReplies() {
		return countReplies;
	}
	public void setCountReplies(int countReplies) {
		this.countReplies = countReplies;
	}
	public String getLastReply() {
		return lastReply;
	}
	public void setLastReply(String lastReply) {
		this.lastReply = lastReply;
	}
	public boolean isPro() {
		return isPro;
	}
	public void setIsPro(boolean isPro) {
		this.isPro = isPro;
	}
	
}
","package com.flickr4java.flickr.groups.discuss; public class Topic { private String topicId; private String subject; private String authorId; private String authorname; private String role; private int iconserver; private int iconfarm; private int countReplies; private boolean canEdit; private boolean canDelete; private boolean canReply; private boolean isSticky; private boolean isLocked; private String datecreate; private String datelastpost; private String message; private String lastReply = """"; private boolean isPro; public String getTopicId() { return topicId; } public void setTopicId(String topicId) { this.topicId = topicId; } public String getSubject() { return subject; } public void setSubject(String subject) { this.subject = subject; } public String getAuthorId() { return authorId; } public void setAuthorId(String authorId) { this.authorId = authorId; } public String getAuthorname() { return authorname; } public void setAuthorname(String authorname) { this.authorname = authorname; } public String getRole() { return role; } public void setRole(String role) { this.role = role; } public int getIconserver() { return iconserver; } public void setIconserver(int iconserver) { this.iconserver = iconserver; } public int getIconfarm() { return iconfarm; } public void setIconfarm(int iconfarm) { this.iconfarm = iconfarm; } public boolean isCanEdit() { return canEdit; } public void setIsCanEdit(boolean canEdit) { this.canEdit = canEdit; } public boolean isCanDelete() { return canDelete; } public void setIsCanDelete(boolean canDelete) { this.canDelete = canDelete; } public boolean isCanReply() { return canReply; } public void setIsCanReply(boolean canReply) { this.canReply = canReply; } public boolean isSticky() { return isSticky; } public void setIsSticky(boolean isSticky) { this.isSticky = isSticky; } public boolean isLocked() { return isLocked; } public void setIsLocked(boolean isLocked) { this.isLocked = isLocked; } public String getDatecreate() { return datecreate; } public void setDatecreate(String datecreate) { this.datecreate = datecreate; } public String getDatelastpost() { return datelastpost; } public void setDatelastpost(String datelastpost) { this.datelastpost = datelastpost; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } public int getCountReplies() { return countReplies; } public void setCountReplies(int countReplies) { this.countReplies = countReplies; } public String getLastReply() { return lastReply; } public void setLastReply(String lastReply) { this.lastReply = lastReply; } public boolean isPro() { return isPro; } public void setIsPro(boolean isPro) { this.isPro = isPro; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.groups.discuss; public class Topic { private String topicId; private String subject; private String authorId; private String authorname; private String role; private int iconserver; private int iconfarm; private int countReplies; private boolean canEdit; private boolean canDelete; private boolean canReply; private boolean isSticky; private boolean isLocked; private String datecreate; private String datelastpost; private String message; private String lastReply = """"; private boolean isPro; public String getTopicId() { return topicId; } public void setTopicId(String topicId) { this.topicId = topicId; } public String getSubject() { return subject; } public void setSubject(String subject) { this.subject = subject; } public String getAuthorId() { return authorId; } public void setAuthorId(String authorId) { this.authorId = authorId; } public String getAuthorname() { return authorname; } public void setAuthorname(String authorname) { this.authorname = authorname; } public String getRole() { return role; } public void setRole(String role) { this.role = role; } public int getIconserver() { return iconserver; } public void setIconserver(int iconserver) { this.iconserver = iconserver; } public int getIconfarm() { return iconfarm; } public void setIconfarm(int iconfarm) { this.iconfarm = iconfarm; } public boolean isCanEdit() { return canEdit; } public void setIsCanEdit(boolean canEdit) { this.canEdit = canEdit; } public boolean isCanDelete() { return canDelete; } public void setIsCanDelete(boolean canDelete) { this.canDelete = canDelete; } public boolean isCanReply() { return canReply; } public void setIsCanReply(boolean canReply) { this.canReply = canReply; } public boolean isSticky() { return isSticky; } public void setIsSticky(boolean isSticky) { this.isSticky = isSticky; } public boolean isLocked() { return isLocked; } public void setIsLocked(boolean isLocked) { this.isLocked = isLocked; } public String getDatecreate() { return datecreate; } public void setDatecreate(String datecreate) { this.datecreate = datecreate; } public String getDatelastpost() { return datelastpost; } public void setDatelastpost(String datelastpost) { this.datelastpost = datelastpost; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } public int getCountReplies() { return countReplies; } public void setCountReplies(int countReplies) { this.countReplies = countReplies; } public String getLastReply() { return lastReply; } public void setLastReply(String lastReply) { this.lastReply = lastReply; } public boolean isPro() { return isPro; } public void setIsPro(boolean isPro) { this.isPro = isPro; } } ","package com.flickr4java.flickr.groups.discuss;  public class Topic {  private String topicId; private String subject; private String authorId; private String authorname; private String role; private int iconserver; private int iconfarm; private int countReplies; private boolean canEdit; private boolean canDelete; private boolean canReply; private boolean isSticky; private boolean isLocked; private String datecreate; private String datelastpost; private String message; private String lastReply = """"; private boolean isPro;      public String getTopicId() { return topicId; } public void setTopicId(String topicId) { this.topicId = topicId; } public String getSubject() { return subject; } public void setSubject(String subject) { this.subject = subject; } public String getAuthorId() { return authorId; } public void setAuthorId(String authorId) { this.authorId = authorId; } public String getAuthorname() { return authorname; } public void setAuthorname(String authorname) { this.authorname = authorname; } public String getRole() { return role; } public void setRole(String role) { this.role = role; } public int getIconserver() { return iconserver; } public void setIconserver(int iconserver) { this.iconserver = iconserver; } public int getIconfarm() { return iconfarm; } public void setIconfarm(int iconfarm) { this.iconfarm = iconfarm; }  public boolean isCanEdit() { return canEdit; } public void setIsCanEdit(boolean canEdit) { this.canEdit = canEdit; } public boolean isCanDelete() { return canDelete; } public void setIsCanDelete(boolean canDelete) { this.canDelete = canDelete; } public boolean isCanReply() { return canReply; } public void setIsCanReply(boolean canReply) { this.canReply = canReply; } public boolean isSticky() { return isSticky; } public void setIsSticky(boolean isSticky) { this.isSticky = isSticky; } public boolean isLocked() { return isLocked; } public void setIsLocked(boolean isLocked) { this.isLocked = isLocked; } public String getDatecreate() { return datecreate; } public void setDatecreate(String datecreate) { this.datecreate = datecreate; } public String getDatelastpost() { return datelastpost; } public void setDatelastpost(String datelastpost) { this.datelastpost = datelastpost; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } public int getCountReplies() { return countReplies; } public void setCountReplies(int countReplies) { this.countReplies = countReplies; } public String getLastReply() { return lastReply; } public void setLastReply(String lastReply) { this.lastReply = lastReply; } public boolean isPro() { return isPro; } public void setIsPro(boolean isPro) { this.isPro = isPro; } 	 }  "
src/main/java/com/flickr4java/flickr/groups/discuss/TopicList.java,"package com.flickr4java.flickr.groups.discuss;

import com.flickr4java.flickr.SearchResultList;

public class TopicList<E> extends  SearchResultList<Topic> {
    private static final long serialVersionUID = 617037681128L;
    private String groupId;
    private int iconServer;
    private int iconFarm;
    private String name;
    private int members;
    private int privacy;
    private String language;
    private boolean isPoolModerated;
    
	public int getIconServer() {
		return iconServer;
	}
	public void setIconServer(int iconServer) {
		this.iconServer = iconServer;
	}
	public String getGroupId() {
		return groupId;
	}
	public void setGroupId(String groupId) {
		this.groupId = groupId;
	}
	public int getIconFarm() {
		return iconFarm;
	}
	public void setIconFarm(int iconFarm) {
		this.iconFarm = iconFarm;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getMembers() {
		return members;
	}
	public void setMembers(int members) {
		this.members = members;
	}
	public int getPrivacy() {
		return privacy;
	}
	public void setPrivacy(int privacy) {
		this.privacy = privacy;
	}
	public String getLanguage() {
		return language;
	}
	public void setLanguage(String language) {
		this.language = language;
	}
	public boolean isPoolModerated() {
		return isPoolModerated;
	}
	public void setIsPoolModerated(boolean isPoolModerated) {
		this.isPoolModerated = isPoolModerated;
	}

}
",package com.flickr4java.flickr.groups.discuss; import com.flickr4java.flickr.SearchResultList; public class TopicList<E> extends  SearchResultList<Topic> { private static final long serialVersionUID = 617037681128L; private String groupId; private int iconServer; private int iconFarm; private String name; private int members; private int privacy; private String language; private boolean isPoolModerated; public int getIconServer() { return iconServer; } public void setIconServer(int iconServer) { this.iconServer = iconServer; } public String getGroupId() { return groupId; } public void setGroupId(String groupId) { this.groupId = groupId; } public int getIconFarm() { return iconFarm; } public void setIconFarm(int iconFarm) { this.iconFarm = iconFarm; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getMembers() { return members; } public void setMembers(int members) { this.members = members; } public int getPrivacy() { return privacy; } public void setPrivacy(int privacy) { this.privacy = privacy; } public String getLanguage() { return language; } public void setLanguage(String language) { this.language = language; } public boolean isPoolModerated() { return isPoolModerated; } public void setIsPoolModerated(boolean isPoolModerated) { this.isPoolModerated = isPoolModerated; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.groups.discuss; import com.flickr4java.flickr.SearchResultList; public class TopicList<E> extends  SearchResultList<Topic> { private static final long serialVersionUID = 617037681128L; private String groupId; private int iconServer; private int iconFarm; private String name; private int members; private int privacy; private String language; private boolean isPoolModerated; public int getIconServer() { return iconServer; } public void setIconServer(int iconServer) { this.iconServer = iconServer; } public String getGroupId() { return groupId; } public void setGroupId(String groupId) { this.groupId = groupId; } public int getIconFarm() { return iconFarm; } public void setIconFarm(int iconFarm) { this.iconFarm = iconFarm; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getMembers() { return members; } public void setMembers(int members) { this.members = members; } public int getPrivacy() { return privacy; } public void setPrivacy(int privacy) { this.privacy = privacy; } public String getLanguage() { return language; } public void setLanguage(String language) { this.language = language; } public boolean isPoolModerated() { return isPoolModerated; } public void setIsPoolModerated(boolean isPoolModerated) { this.isPoolModerated = isPoolModerated; } } ,package com.flickr4java.flickr.groups.discuss;  import com.flickr4java.flickr.SearchResultList;  public class TopicList<E> extends  SearchResultList<Topic> { private static final long serialVersionUID = 617037681128L; private String groupId; private int iconServer; private int iconFarm; private String name; private int members; private int privacy; private String language; private boolean isPoolModerated;      public int getIconServer() { return iconServer; } public void setIconServer(int iconServer) { this.iconServer = iconServer; } public String getGroupId() { return groupId; } public void setGroupId(String groupId) { this.groupId = groupId; } public int getIconFarm() { return iconFarm; } public void setIconFarm(int iconFarm) { this.iconFarm = iconFarm; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getMembers() { return members; } public void setMembers(int members) { this.members = members; } public int getPrivacy() { return privacy; } public void setPrivacy(int privacy) { this.privacy = privacy; } public String getLanguage() { return language; } public void setLanguage(String language) { this.language = language; } public boolean isPoolModerated() { return isPoolModerated; } public void setIsPoolModerated(boolean isPoolModerated) { this.isPoolModerated = isPoolModerated; }  }  
src/main/java/com/flickr4java/flickr/groups/members/Member.java,"package com.flickr4java.flickr.groups.members;

/**
 * Group-member.
 * 
 * @author mago
 * @version $Id: Member.java,v 1.3 2009/07/12 22:43:07 x-mago Exp $
 */

public class Member {

    private String id;

    private String userName;

    private int iconFarm = -1;

    private int iconServer = -1;

    private String memberType;

    public static final String TYPE_MEMBER = ""2"";

    public static final String TYPE_MODERATOR = ""3"";

    public static final String TYPE_ADMIN = ""4"";

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public int getIconFarm() {
        return iconFarm;
    }

    public void setIconFarm(String iconFarm) {
        if (iconFarm != null)
            setIconFarm(Integer.parseInt(iconFarm));
    }

    public void setIconFarm(int iconFarm) {
        this.iconFarm = iconFarm;
    }

    public int getIconServer() {
        return iconServer;
    }

    public void setIconServer(String iconServer) {
        if (iconServer != null)
            setIconServer(Integer.parseInt(iconServer));
    }

    public void setIconServer(int iconServer) {
        this.iconServer = iconServer;
    }

    public String getMemberType() {
        return memberType;
    }

    public void setMemberType(String memberType) {
        this.memberType = memberType;
    }
}
","package com.flickr4java.flickr.groups.members; public class Member { private String id; private String userName; private int iconFarm = -1; private int iconServer = -1; private String memberType; public static final String TYPE_MEMBER = ""2""; public static final String TYPE_MODERATOR = ""3""; public static final String TYPE_ADMIN = ""4""; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } public int getIconFarm() { return iconFarm; } public void setIconFarm(String iconFarm) { if (iconFarm != null)
            setIconFarm(Integer.parseInt(iconFarm)); } public void setIconFarm(int iconFarm) { this.iconFarm = iconFarm; } public int getIconServer() { return iconServer; } public void setIconServer(String iconServer) { if (iconServer != null)
            setIconServer(Integer.parseInt(iconServer)); } public void setIconServer(int iconServer) { this.iconServer = iconServer; } public String getMemberType() { return memberType; } public void setMemberType(String memberType) { this.memberType = memberType; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.groups.members; public class Member { private String id; private String userName; private int iconFarm = -1; private int iconServer = -1; private String memberType; public static final String TYPE_MEMBER = ""2""; public static final String TYPE_MODERATOR = ""3""; public static final String TYPE_ADMIN = ""4""; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } public int getIconFarm() { return iconFarm; } public void setIconFarm(String iconFarm) { if (iconFarm != null)
            setIconFarm(Integer.parseInt(iconFarm)); } public void setIconFarm(int iconFarm) { this.iconFarm = iconFarm; } public int getIconServer() { return iconServer; } public void setIconServer(String iconServer) { if (iconServer != null)
            setIconServer(Integer.parseInt(iconServer)); } public void setIconServer(int iconServer) { this.iconServer = iconServer; } public String getMemberType() { return memberType; } public void setMemberType(String memberType) { this.memberType = memberType; } } ","package com.flickr4java.flickr.groups.members;  /**
 * Group-member.
 * 
 * @author mago
 * @version $Id: Member.java,v 1.3 2009/07/12 22:43:07 x-mago Exp $
 */  public class Member {  private String id;  private String userName;  private int iconFarm = -1;  private int iconServer = -1;  private String memberType;  public static final String TYPE_MEMBER = ""2"";  public static final String TYPE_MODERATOR = ""3"";  public static final String TYPE_ADMIN = ""4"";  public String getId() { return id; }  public void setId(String id) { this.id = id; }  public String getUserName() { return userName; }  public void setUserName(String userName) { this.userName = userName; }  public int getIconFarm() { return iconFarm; }  public void setIconFarm(String iconFarm) { if (iconFarm != null)
            setIconFarm(Integer.parseInt(iconFarm)); }  public void setIconFarm(int iconFarm) { this.iconFarm = iconFarm; }  public int getIconServer() { return iconServer; }  public void setIconServer(String iconServer) { if (iconServer != null)
            setIconServer(Integer.parseInt(iconServer)); }  public void setIconServer(int iconServer) { this.iconServer = iconServer; }  public String getMemberType() { return memberType; }  public void setMemberType(String memberType) { this.memberType = memberType; } }  "
src/main/java/com/flickr4java/flickr/groups/members/MembersInterface.java,"package com.flickr4java.flickr.groups.members;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.util.StringUtilities;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * Members Interface.
 * 
 * @author mago
 * @version $Id: MembersInterface.java,v 1.1 2009/06/21 19:55:15 x-mago Exp $
 */
public class MembersInterface {
    public static final String METHOD_GET_LIST = ""flickr.groups.members.getList"";

    private String apiKey;

    private String sharedSecret;

    private Transport transportAPI;

    public MembersInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transportAPI;
    }

    /**
     * Get a list of the members of a group. The call must be signed on behalf of a Flickr member, and the ability to see the group membership will be
     * determined by the Flickr member's group privileges.
     * 
     * @param groupId
     *            Return a list of members for this group. The group must be viewable by the Flickr member on whose behalf the API call is made.
     * @param memberTypes
     *            A set of Membertypes as available as constants in {@link Member}.
     * @param perPage
     *            Number of records per page.
     * @param page
     *            Result-section.
     * @return A members-list
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see <a href=""http://www.flickr.com/services/api/flickr.groups.members.getList.html"">API Documentation</a>
     */
    public MembersList<Member> getList(String groupId, Set<String> memberTypes, int perPage, int page) throws FlickrException {
        MembersList<Member> members = new MembersList<Member>();
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_LIST);

        parameters.put(""group_id"", groupId);

        if (perPage > 0) {
            parameters.put(""per_page"", """" + perPage);
        }
        if (page > 0) {
            parameters.put(""page"", """" + page);
        }
        if (memberTypes != null) {
            parameters.put(""membertypes"", StringUtilities.join(memberTypes, "",""));
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element mElement = response.getPayload();
        members.setPage(mElement.getAttribute(""page""));
        members.setPages(mElement.getAttribute(""pages""));
        members.setPerPage(mElement.getAttribute(""perpage""));
        members.setTotal(mElement.getAttribute(""total""));

        NodeList mNodes = mElement.getElementsByTagName(""member"");
        for (int i = 0; i < mNodes.getLength(); i++) {
            Element element = (Element) mNodes.item(i);
            members.add(parseMember(element));
        }
        return members;
    }

    private Member parseMember(Element mElement) {
        Member member = new Member();
        member.setId(mElement.getAttribute(""nsid""));
        member.setUserName(mElement.getAttribute(""username""));
        member.setIconServer(mElement.getAttribute(""iconserver""));
        member.setIconFarm(mElement.getAttribute(""iconfarm""));
        member.setMemberType(mElement.getAttribute(""membertype""));
        return member;
    }
}
","package com.flickr4java.flickr.groups.members; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.StringUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.HashMap; import java.util.Map; import java.util.Set; public class MembersInterface { public static final String METHOD_GET_LIST = ""flickr.groups.members.getList""; private String apiKey; private String sharedSecret; private Transport transportAPI; public MembersInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public MembersList<Member> getList(String groupId, Set<String> memberTypes, int perPage, int page) throws FlickrException { MembersList<Member> members = new MembersList<Member>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); parameters.put(""group_id"", groupId); if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } if (memberTypes != null) { parameters.put(""membertypes"", StringUtilities.join(memberTypes, "","")); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element mElement = response.getPayload(); members.setPage(mElement.getAttribute(""page"")); members.setPages(mElement.getAttribute(""pages"")); members.setPerPage(mElement.getAttribute(""perpage"")); members.setTotal(mElement.getAttribute(""total"")); NodeList mNodes = mElement.getElementsByTagName(""member""); for (int i = 0; i < mNodes.getLength(); i++) { Element element = (Element) mNodes.item(i); members.add(parseMember(element)); } return members; } private Member parseMember(Element mElement) { Member member = new Member(); member.setId(mElement.getAttribute(""nsid"")); member.setUserName(mElement.getAttribute(""username"")); member.setIconServer(mElement.getAttribute(""iconserver"")); member.setIconFarm(mElement.getAttribute(""iconfarm"")); member.setMemberType(mElement.getAttribute(""membertype"")); return member; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.groups.members; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.StringUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.HashMap; import java.util.Map; import java.util.Set; public class MembersInterface { public static final String METHOD_GET_LIST = ""flickr.groups.members.getList""; private String apiKey; private String sharedSecret; private Transport transportAPI; public MembersInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public MembersList<Member> getList(String groupId, Set<String> memberTypes, int perPage, int page) throws FlickrException { MembersList<Member> members = new MembersList<Member>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); parameters.put(""group_id"", groupId); if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } if (memberTypes != null) { parameters.put(""membertypes"", StringUtilities.join(memberTypes, "","")); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element mElement = response.getPayload(); members.setPage(mElement.getAttribute(""page"")); members.setPages(mElement.getAttribute(""pages"")); members.setPerPage(mElement.getAttribute(""perpage"")); members.setTotal(mElement.getAttribute(""total"")); NodeList mNodes = mElement.getElementsByTagName(""member""); for (int i = 0; i < mNodes.getLength(); i++) { Element element = (Element) mNodes.item(i); members.add(parseMember(element)); } return members; } private Member parseMember(Element mElement) { Member member = new Member(); member.setId(mElement.getAttribute(""nsid"")); member.setUserName(mElement.getAttribute(""username"")); member.setIconServer(mElement.getAttribute(""iconserver"")); member.setIconFarm(mElement.getAttribute(""iconfarm"")); member.setMemberType(mElement.getAttribute(""membertype"")); return member; } } ","package com.flickr4java.flickr.groups.members;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.util.StringUtilities;  import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import java.util.HashMap; import java.util.Map; import java.util.Set;  /**
 * Members Interface.
 * 
 * @author mago
 * @version $Id: MembersInterface.java,v 1.1 2009/06/21 19:55:15 x-mago Exp $
 */ public class MembersInterface { public static final String METHOD_GET_LIST = ""flickr.groups.members.getList"";  private String apiKey;  private String sharedSecret;  private Transport transportAPI;  public MembersInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; }  /**
     * Get a list of the members of a group. The call must be signed on behalf of a Flickr member, and the ability to see the group membership will be
     * determined by the Flickr member's group privileges.
     * 
     * @param groupId
     *            Return a list of members for this group. The group must be viewable by the Flickr member on whose behalf the API call is made.
     * @param memberTypes
     *            A set of Membertypes as available as constants in {@link Member}.
     * @param perPage
     *            Number of records per page.
     * @param page
     *            Result-section.
     * @return A members-list
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see <a href=""http://www.flickr.com/services/api/flickr.groups.members.getList.html"">API Documentation</a>
     */ public MembersList<Member> getList(String groupId, Set<String> memberTypes, int perPage, int page) throws FlickrException { MembersList<Member> members = new MembersList<Member>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST);  parameters.put(""group_id"", groupId);  if (perPage > 0) { parameters.put(""per_page"", """" + perPage); } if (page > 0) { parameters.put(""page"", """" + page); } if (memberTypes != null) { parameters.put(""membertypes"", StringUtilities.join(memberTypes, "","")); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element mElement = response.getPayload(); members.setPage(mElement.getAttribute(""page"")); members.setPages(mElement.getAttribute(""pages"")); members.setPerPage(mElement.getAttribute(""perpage"")); members.setTotal(mElement.getAttribute(""total""));  NodeList mNodes = mElement.getElementsByTagName(""member""); for (int i = 0; i < mNodes.getLength(); i++) { Element element = (Element) mNodes.item(i); members.add(parseMember(element)); } return members; }  private Member parseMember(Element mElement) { Member member = new Member(); member.setId(mElement.getAttribute(""nsid"")); member.setUserName(mElement.getAttribute(""username"")); member.setIconServer(mElement.getAttribute(""iconserver"")); member.setIconFarm(mElement.getAttribute(""iconfarm"")); member.setMemberType(mElement.getAttribute(""membertype"")); return member; } }  "
src/main/java/com/flickr4java/flickr/groups/members/MembersList.java,"package com.flickr4java.flickr.groups.members;

import com.flickr4java.flickr.SearchResultList;

/**
 * List of Group-members.
 * 
 * @author mago
 * @version $Id: MembersList.java,v 1.1 2009/06/21 19:55:15 x-mago Exp $
 */
public class MembersList<E> extends SearchResultList<Member> {
    private static final long serialVersionUID = 617037681128L;
}
",package com.flickr4java.flickr.groups.members; import com.flickr4java.flickr.SearchResultList; public class MembersList<E> extends SearchResultList<Member> { private static final long serialVersionUID = 617037681128L; },0 0 0 0 0 0,package com.flickr4java.flickr.groups.members; import com.flickr4java.flickr.SearchResultList; public class MembersList<E> extends SearchResultList<Member> { private static final long serialVersionUID = 617037681128L; } ,"package com.flickr4java.flickr.groups.members;  import com.flickr4java.flickr.SearchResultList;  /**
 * List of Group-members.
 * 
 * @author mago
 * @version $Id: MembersList.java,v 1.1 2009/06/21 19:55:15 x-mago Exp $
 */ public class MembersList<E> extends SearchResultList<Member> { private static final long serialVersionUID = 617037681128L; }  "
src/main/java/com/flickr4java/flickr/groups/pools/PoolsInterface.java,"
package com.flickr4java.flickr.groups.pools;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.groups.Group;
import com.flickr4java.flickr.groups.GroupList;
import com.flickr4java.flickr.photos.Extras;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoContext;
import com.flickr4java.flickr.photos.PhotoList;
import com.flickr4java.flickr.photos.PhotoUtils;
import com.flickr4java.flickr.util.StringUtilities;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

/**
 * @author Anthony Eden
 * @version $Id: PoolsInterface.java,v 1.16 2011/07/02 19:00:59 x-mago Exp $
 */
public class PoolsInterface {

    private static Logger _log = LoggerFactory.getLogger(PoolsInterface.class);

    public static final String METHOD_ADD = ""flickr.groups.pools.add"";

    public static final String METHOD_GET_CONTEXT = ""flickr.groups.pools.getContext"";

    public static final String METHOD_GET_GROUPS = ""flickr.groups.pools.getGroups"";

    public static final String METHOD_GET_PHOTOS = ""flickr.groups.pools.getPhotos"";

    public static final String METHOD_REMOVE = ""flickr.groups.pools.remove"";

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transport;

    public PoolsInterface(String apiKey, String sharedSecret, Transport transport) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transport = transport;
    }

    /**
     * Add a photo to a group's pool.
     * 
     * @param photoId
     *            The photo ID
     * @param groupId
     *            The group ID
     */
    public void add(String photoId, String groupId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_ADD);

        parameters.put(""photo_id"", photoId);
        parameters.put(""group_id"", groupId);

        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Get the context for a photo in the group pool.
     * 
     * This method does not require authentication.
     * 
     * @param photoId
     *            The photo ID
     * @param groupId
     *            The group ID
     * @return The PhotoContext
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PhotoContext getContext(String photoId, String groupId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_CONTEXT);

        parameters.put(""photo_id"", photoId);
        parameters.put(""group_id"", groupId);

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Collection<Element> payload = response.getPayloadCollection();
        PhotoContext photoContext = new PhotoContext();
        for (Element element : payload) {
            String elementName = element.getTagName();
            if (elementName.equals(""prevphoto"")) {
                Photo photo = new Photo();
                photo.setId(element.getAttribute(""id""));
                photoContext.setPreviousPhoto(photo);
            } else if (elementName.equals(""nextphoto"")) {
                Photo photo = new Photo();
                photo.setId(element.getAttribute(""id""));
                photoContext.setNextPhoto(photo);
            } else if (!elementName.equals(""count"")) {
                _log.warn(""unsupported element name: "" + elementName);
            }
        }
        return photoContext;
    }

    /**
     * Get a collection of all of the user's groups.
     * 
     * @return A Collection of Group objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Collection<Group> getGroups() throws FlickrException {
        GroupList<Group> groups = new GroupList<Group>();

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_GROUPS);

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element groupsElement = response.getPayload();
        groups.setPage(groupsElement.getAttribute(""page""));
        groups.setPages(groupsElement.getAttribute(""pages""));
        groups.setPerPage(groupsElement.getAttribute(""perpage""));
        groups.setTotal(groupsElement.getAttribute(""total""));
        NodeList groupNodes = groupsElement.getElementsByTagName(""group"");
        for (int i = 0; i < groupNodes.getLength(); i++) {
            Element groupElement = (Element) groupNodes.item(i);
            Group group = new Group();
            group.setId(groupElement.getAttribute(""id""));
            group.setName(groupElement.getAttribute(""name""));
            group.setAdmin(""1"".equals(groupElement.getAttribute(""admin"")));
            group.setPrivacy(groupElement.getAttribute(""privacy""));
            group.setIconServer(groupElement.getAttribute(""iconserver""));
            group.setIconFarm(groupElement.getAttribute(""iconfarm""));
            group.setPhotoCount(groupElement.getAttribute(""photos""));
            groups.add(group);
        }
        return groups;
    }

    /**
     * Get the photos for the specified group pool, optionally filtering by taf.
     * 
     * This method does not require authentication.
     * 
     * @see com.flickr4java.flickr.photos.Extras
     * @param groupId
     *            The group ID
     * @param userId
     *            The user ID (may be null)
     * @param tags
     *            The optional tags (may be null)
     * @param extras
     *            Set of extra-attributes to include (may be null)
     * @param perPage
     *            The number of photos per page (0 to ignore)
     * @param page
     *            The page offset (0 to ignore)
     * @return A Collection of Photo objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PhotoList<Photo> getPhotos(String groupId, String userId, String[] tags, Set<String> extras, int perPage, int page) throws FlickrException {
        PhotoList<Photo> photos = new PhotoList<Photo>();

        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_PHOTOS);

        parameters.put(""group_id"", groupId);
        if (userId != null) {
            parameters.put(""user_id"", userId);
        }
        if (tags != null) {
            parameters.put(""tags"", StringUtilities.join(tags, "" ""));
        }
        if (perPage > 0) {
            parameters.put(""per_page"", String.valueOf(perPage));
        }
        if (page > 0) {
            parameters.put(""page"", String.valueOf(page));
        }

        if (extras != null) {
            StringBuffer sb = new StringBuffer();
            Iterator<String> it = extras.iterator();
            for (int i = 0; it.hasNext(); i++) {
                if (i > 0) {
                    sb.append("","");
                }
                sb.append(it.next());
            }
            parameters.put(Extras.KEY_EXTRAS, sb.toString());
        }

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element photosElement = response.getPayload();
        photos.setPage(photosElement.getAttribute(""page""));
        photos.setPages(photosElement.getAttribute(""pages""));
        photos.setPerPage(photosElement.getAttribute(""perpage""));
        photos.setTotal(photosElement.getAttribute(""total""));

        NodeList photoNodes = photosElement.getElementsByTagName(""photo"");
        for (int i = 0; i < photoNodes.getLength(); i++) {
            Element photoElement = (Element) photoNodes.item(i);
            photos.add(PhotoUtils.createPhoto(photoElement));
        }

        return photos;
    }

    /**
     * Convenience/Compatibility method.
     * 
     * This method does not require authentication.
     * 
     * @see com.flickr4java.flickr.photos.Extras
     * @param groupId
     *            The group ID
     * @param tags
     *            The optional tags (may be null)
     * @param extras
     *            Set of extra-attributes to include (may be null)
     * @param perPage
     *            The number of photos per page (0 to ignore)
     * @param page
     *            The page offset (0 to ignore)
     * @return A Collection of Photo objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PhotoList<Photo> getPhotos(String groupId, String[] tags, Set<String> extras, int perPage, int page) throws FlickrException {
        return getPhotos(groupId, null, tags, extras, perPage, page);
    }

    /**
     * Convenience/Compatibility method.
     * 
     * This method does not require authentication.
     * 
     * @see com.flickr4java.flickr.photos.Extras
     * @param groupId
     *            The group ID
     * @param tags
     *            The optional tags (may be null)
     * @param perPage
     *            The number of photos per page (0 to ignore)
     * @param page
     *            The page offset (0 to ignore)
     * @return A Collection of Photo objects
     */
    public PhotoList<Photo> getPhotos(String groupId, String[] tags, int perPage, int page) throws FlickrException {
        return getPhotos(groupId, tags, Extras.MIN_EXTRAS, perPage, page);
    }

    /**
     * Remove the specified photo from the group.
     * 
     * @param photoId
     *            The photo ID
     * @param groupId
     *            The group ID
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void remove(String photoId, String groupId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_REMOVE);

        parameters.put(""photo_id"", photoId);
        parameters.put(""group_id"", groupId);

        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

}
","package com.flickr4java.flickr.groups.pools; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.groups.Group; import com.flickr4java.flickr.groups.GroupList; import com.flickr4java.flickr.photos.Extras; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoContext; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.util.StringUtilities; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Set; public class PoolsInterface { private static Logger _log = LoggerFactory.getLogger(PoolsInterface.class); public static final String METHOD_ADD = ""flickr.groups.pools.add""; public static final String METHOD_GET_CONTEXT = ""flickr.groups.pools.getContext""; public static final String METHOD_GET_GROUPS = ""flickr.groups.pools.getGroups""; public static final String METHOD_GET_PHOTOS = ""flickr.groups.pools.getPhotos""; public static final String METHOD_REMOVE = ""flickr.groups.pools.remove""; private final String apiKey; private final String sharedSecret; private final Transport transport; public PoolsInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transport = transport; } public void add(String photoId, String groupId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD); parameters.put(""photo_id"", photoId); parameters.put(""group_id"", groupId); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public PhotoContext getContext(String photoId, String groupId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CONTEXT); parameters.put(""photo_id"", photoId); parameters.put(""group_id"", groupId); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Collection<Element> payload = response.getPayloadCollection(); PhotoContext photoContext = new PhotoContext(); for (Element element : payload) { String elementName = element.getTagName(); if (elementName.equals(""prevphoto"")) { Photo photo = new Photo(); photo.setId(element.getAttribute(""id"")); photoContext.setPreviousPhoto(photo); } else if (elementName.equals(""nextphoto"")) { Photo photo = new Photo(); photo.setId(element.getAttribute(""id"")); photoContext.setNextPhoto(photo); } else if (!elementName.equals(""count"")) { } } return photoContext; } public Collection<Group> getGroups() throws FlickrException { GroupList<Group> groups = new GroupList<Group>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_GROUPS); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element groupsElement = response.getPayload(); groups.setPage(groupsElement.getAttribute(""page"")); groups.setPages(groupsElement.getAttribute(""pages"")); groups.setPerPage(groupsElement.getAttribute(""perpage"")); groups.setTotal(groupsElement.getAttribute(""total"")); NodeList groupNodes = groupsElement.getElementsByTagName(""group""); for (int i = 0; i < groupNodes.getLength(); i++) { Element groupElement = (Element) groupNodes.item(i); Group group = new Group(); group.setId(groupElement.getAttribute(""id"")); group.setName(groupElement.getAttribute(""name"")); group.setAdmin(""1"".equals(groupElement.getAttribute(""admin""))); group.setPrivacy(groupElement.getAttribute(""privacy"")); group.setIconServer(groupElement.getAttribute(""iconserver"")); group.setIconFarm(groupElement.getAttribute(""iconfarm"")); group.setPhotoCount(groupElement.getAttribute(""photos"")); groups.add(group); } return groups; } public PhotoList<Photo> getPhotos(String groupId, String userId, String[] tags, Set<String> extras, int perPage, int page) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PHOTOS); parameters.put(""group_id"", groupId); if (userId != null) { parameters.put(""user_id"", userId); } if (tags != null) { parameters.put(""tags"", StringUtilities.join(tags, "" "")); } if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); } if (extras != null) { StringBuffer sb = new StringBuffer(); Iterator<String> it = extras.iterator(); for (int i = 0; it.hasNext(); i++) { if (i > 0) { sb.append("",""); } sb.append(it.next()); } parameters.put(Extras.KEY_EXTRAS, sb.toString()); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } public PhotoList<Photo> getPhotos(String groupId, String[] tags, Set<String> extras, int perPage, int page) throws FlickrException { return getPhotos(groupId, null, tags, extras, perPage, page); } public PhotoList<Photo> getPhotos(String groupId, String[] tags, int perPage, int page) throws FlickrException { return getPhotos(groupId, tags, Extras.MIN_EXTRAS, perPage, page); } public void remove(String photoId, String groupId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REMOVE); parameters.put(""photo_id"", photoId); parameters.put(""group_id"", groupId); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.groups.pools; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.groups.Group; import com.flickr4java.flickr.groups.GroupList; import com.flickr4java.flickr.photos.Extras; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoContext; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.util.StringUtilities; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Set; public class PoolsInterface { private static Logger _log = LoggerFactory.getLogger(PoolsInterface.class); public static final String METHOD_ADD = ""flickr.groups.pools.add""; public static final String METHOD_GET_CONTEXT = ""flickr.groups.pools.getContext""; public static final String METHOD_GET_GROUPS = ""flickr.groups.pools.getGroups""; public static final String METHOD_GET_PHOTOS = ""flickr.groups.pools.getPhotos""; public static final String METHOD_REMOVE = ""flickr.groups.pools.remove""; private final String apiKey; private final String sharedSecret; private final Transport transport; public PoolsInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transport = transport; } public void add(String photoId, String groupId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD); parameters.put(""photo_id"", photoId); parameters.put(""group_id"", groupId); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public PhotoContext getContext(String photoId, String groupId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CONTEXT); parameters.put(""photo_id"", photoId); parameters.put(""group_id"", groupId); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Collection<Element> payload = response.getPayloadCollection(); PhotoContext photoContext = new PhotoContext(); for (Element element : payload) { String elementName = element.getTagName(); if (elementName.equals(""prevphoto"")) { Photo photo = new Photo(); photo.setId(element.getAttribute(""id"")); photoContext.setPreviousPhoto(photo); } else if (elementName.equals(""nextphoto"")) { Photo photo = new Photo(); photo.setId(element.getAttribute(""id"")); photoContext.setNextPhoto(photo); } else if (!elementName.equals(""count"")) { <FILL_ME> } } return photoContext; } public Collection<Group> getGroups() throws FlickrException { GroupList<Group> groups = new GroupList<Group>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_GROUPS); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element groupsElement = response.getPayload(); groups.setPage(groupsElement.getAttribute(""page"")); groups.setPages(groupsElement.getAttribute(""pages"")); groups.setPerPage(groupsElement.getAttribute(""perpage"")); groups.setTotal(groupsElement.getAttribute(""total"")); NodeList groupNodes = groupsElement.getElementsByTagName(""group""); for (int i = 0; i < groupNodes.getLength(); i++) { Element groupElement = (Element) groupNodes.item(i); Group group = new Group(); group.setId(groupElement.getAttribute(""id"")); group.setName(groupElement.getAttribute(""name"")); group.setAdmin(""1"".equals(groupElement.getAttribute(""admin""))); group.setPrivacy(groupElement.getAttribute(""privacy"")); group.setIconServer(groupElement.getAttribute(""iconserver"")); group.setIconFarm(groupElement.getAttribute(""iconfarm"")); group.setPhotoCount(groupElement.getAttribute(""photos"")); groups.add(group); } return groups; } public PhotoList<Photo> getPhotos(String groupId, String userId, String[] tags, Set<String> extras, int perPage, int page) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PHOTOS); parameters.put(""group_id"", groupId); if (userId != null) { parameters.put(""user_id"", userId); } if (tags != null) { parameters.put(""tags"", StringUtilities.join(tags, "" "")); } if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); } if (extras != null) { StringBuffer sb = new StringBuffer(); Iterator<String> it = extras.iterator(); for (int i = 0; it.hasNext(); i++) { if (i > 0) { sb.append("",""); } sb.append(it.next()); } parameters.put(Extras.KEY_EXTRAS, sb.toString()); } Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } public PhotoList<Photo> getPhotos(String groupId, String[] tags, Set<String> extras, int perPage, int page) throws FlickrException { return getPhotos(groupId, null, tags, extras, perPage, page); } public PhotoList<Photo> getPhotos(String groupId, String[] tags, int perPage, int page) throws FlickrException { return getPhotos(groupId, tags, Extras.MIN_EXTRAS, perPage, page); } public void remove(String photoId, String groupId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REMOVE); parameters.put(""photo_id"", photoId); parameters.put(""group_id"", groupId); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } } "," package com.flickr4java.flickr.groups.pools;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.groups.Group; import com.flickr4java.flickr.groups.GroupList; import com.flickr4java.flickr.photos.Extras; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoContext; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.util.StringUtilities; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Set;  /**
 * @author Anthony Eden
 * @version $Id: PoolsInterface.java,v 1.16 2011/07/02 19:00:59 x-mago Exp $
 */ public class PoolsInterface {  private static Logger _log = LoggerFactory.getLogger(PoolsInterface.class);  public static final String METHOD_ADD = ""flickr.groups.pools.add"";  public static final String METHOD_GET_CONTEXT = ""flickr.groups.pools.getContext"";  public static final String METHOD_GET_GROUPS = ""flickr.groups.pools.getGroups"";  public static final String METHOD_GET_PHOTOS = ""flickr.groups.pools.getPhotos"";  public static final String METHOD_REMOVE = ""flickr.groups.pools.remove"";  private final String apiKey;  private final String sharedSecret;  private final Transport transport;  public PoolsInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transport = transport; }  /**
     * Add a photo to a group's pool.
     * 
     * @param photoId
     *            The photo ID
     * @param groupId
     *            The group ID
     */ public void add(String photoId, String groupId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD);  parameters.put(""photo_id"", photoId); parameters.put(""group_id"", groupId);  Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Get the context for a photo in the group pool.
     * 
     * This method does not require authentication.
     * 
     * @param photoId
     *            The photo ID
     * @param groupId
     *            The group ID
     * @return The PhotoContext
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PhotoContext getContext(String photoId, String groupId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_CONTEXT);  parameters.put(""photo_id"", photoId); parameters.put(""group_id"", groupId);  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Collection<Element> payload = response.getPayloadCollection(); PhotoContext photoContext = new PhotoContext(); for (Element element : payload) { String elementName = element.getTagName(); if (elementName.equals(""prevphoto"")) { Photo photo = new Photo(); photo.setId(element.getAttribute(""id"")); photoContext.setPreviousPhoto(photo); } else if (elementName.equals(""nextphoto"")) { Photo photo = new Photo(); photo.setId(element.getAttribute(""id"")); photoContext.setNextPhoto(photo); } else if (!elementName.equals(""count"")) { <FILL_ME> } } return photoContext; }  /**
     * Get a collection of all of the user's groups.
     * 
     * @return A Collection of Group objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Collection<Group> getGroups() throws FlickrException { GroupList<Group> groups = new GroupList<Group>();  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_GROUPS);  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element groupsElement = response.getPayload(); groups.setPage(groupsElement.getAttribute(""page"")); groups.setPages(groupsElement.getAttribute(""pages"")); groups.setPerPage(groupsElement.getAttribute(""perpage"")); groups.setTotal(groupsElement.getAttribute(""total"")); NodeList groupNodes = groupsElement.getElementsByTagName(""group""); for (int i = 0; i < groupNodes.getLength(); i++) { Element groupElement = (Element) groupNodes.item(i); Group group = new Group(); group.setId(groupElement.getAttribute(""id"")); group.setName(groupElement.getAttribute(""name"")); group.setAdmin(""1"".equals(groupElement.getAttribute(""admin""))); group.setPrivacy(groupElement.getAttribute(""privacy"")); group.setIconServer(groupElement.getAttribute(""iconserver"")); group.setIconFarm(groupElement.getAttribute(""iconfarm"")); group.setPhotoCount(groupElement.getAttribute(""photos"")); groups.add(group); } return groups; }  /**
     * Get the photos for the specified group pool, optionally filtering by taf.
     * 
     * This method does not require authentication.
     * 
     * @see com.flickr4java.flickr.photos.Extras
     * @param groupId
     *            The group ID
     * @param userId
     *            The user ID (may be null)
     * @param tags
     *            The optional tags (may be null)
     * @param extras
     *            Set of extra-attributes to include (may be null)
     * @param perPage
     *            The number of photos per page (0 to ignore)
     * @param page
     *            The page offset (0 to ignore)
     * @return A Collection of Photo objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PhotoList<Photo> getPhotos(String groupId, String userId, String[] tags, Set<String> extras, int perPage, int page) throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>();  Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PHOTOS);  parameters.put(""group_id"", groupId); if (userId != null) { parameters.put(""user_id"", userId); } if (tags != null) { parameters.put(""tags"", StringUtilities.join(tags, "" "")); } if (perPage > 0) { parameters.put(""per_page"", String.valueOf(perPage)); } if (page > 0) { parameters.put(""page"", String.valueOf(page)); }  if (extras != null) { StringBuffer sb = new StringBuffer(); Iterator<String> it = extras.iterator(); for (int i = 0; it.hasNext(); i++) { if (i > 0) { sb.append("",""); } sb.append(it.next()); } parameters.put(Extras.KEY_EXTRAS, sb.toString()); }  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total""));  NodeList photoNodes = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoNodes.getLength(); i++) { Element photoElement = (Element) photoNodes.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); }  return photos; }  /**
     * Convenience/Compatibility method.
     * 
     * This method does not require authentication.
     * 
     * @see com.flickr4java.flickr.photos.Extras
     * @param groupId
     *            The group ID
     * @param tags
     *            The optional tags (may be null)
     * @param extras
     *            Set of extra-attributes to include (may be null)
     * @param perPage
     *            The number of photos per page (0 to ignore)
     * @param page
     *            The page offset (0 to ignore)
     * @return A Collection of Photo objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PhotoList<Photo> getPhotos(String groupId, String[] tags, Set<String> extras, int perPage, int page) throws FlickrException { return getPhotos(groupId, null, tags, extras, perPage, page); }  /**
     * Convenience/Compatibility method.
     * 
     * This method does not require authentication.
     * 
     * @see com.flickr4java.flickr.photos.Extras
     * @param groupId
     *            The group ID
     * @param tags
     *            The optional tags (may be null)
     * @param perPage
     *            The number of photos per page (0 to ignore)
     * @param page
     *            The page offset (0 to ignore)
     * @return A Collection of Photo objects
     */ public PhotoList<Photo> getPhotos(String groupId, String[] tags, int perPage, int page) throws FlickrException { return getPhotos(groupId, tags, Extras.MIN_EXTRAS, perPage, page); }  /**
     * Remove the specified photo from the group.
     * 
     * @param photoId
     *            The photo ID
     * @param groupId
     *            The group ID
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void remove(String photoId, String groupId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REMOVE);  parameters.put(""photo_id"", photoId); parameters.put(""group_id"", groupId);  Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  }  "
src/main/java/com/flickr4java/flickr/photos/comments/Comment.java,"package com.flickr4java.flickr.photos.comments;

import java.util.Date;

/**
 * Encapsulated Photo comments.
 * 
 * @author till (Kill Krech) flickr:extranoise
 * @version $Id: Comment.java,v 1.2 2009/07/12 22:43:07 x-mago Exp $
 */
public class Comment {

    private String id;

    private String author;

    private String authorName;

    private Date dateCreate;

    private String permaLink;

    private String text;

    /**
     * @return the nsid of the comment author
     */
    public String getAuthor() {
        return author;
    }

    /**
     * Set the nsis of the comment author. Not to be called from user code. Will be set by querying flickr.
     * 
     * @param author
     *            nsid of the user
     */
    public void setAuthor(String author) {
        this.author = author;
    }

    /**
     * @return the name of the author of the comment
     */
    public String getAuthorName() {
        return authorName;
    }

    /**
     * Sets the commment author name. Not to be called from user code. Will be set by querying flickr.
     * 
     * @param authorName
     */
    public void setAuthorName(String authorName) {
        this.authorName = authorName;
    }

    /**
     * 
     * @return the date, when the comment was created
     */
    public Date getDateCreate() {
        return dateCreate;
    }

    /**
     * Sets the date when the comment was created. Not to be called from user code. Will be set by querying flickr.
     * 
     * @param dateCreate
     *            date,when the comment was created
     */
    public void setDateCreate(Date dateCreate) {
        this.dateCreate = dateCreate;
    }

    /**
     * @return the unique comment id
     */
    public String getId() {
        return id;
    }

    /**
     * Sets the unique id of the comment. Not to be called from user code. Will be set by querying flickr.
     * 
     * @param id
     *            unique comment id
     */
    public void setId(String id) {
        this.id = id;
    }

    /**
     * @return a link to the comment on the photo page.
     */
    public String getPermaLink() {
        return permaLink;
    }

    /**
     * sets the link to the comment on the photo page. Not to be called from user code. Will be set by querying flickr.
     */
    public void setPermaLink(String permaLink) {
        this.permaLink = permaLink;
    }

    /**
     * @return the text of the comment with possible HTML markup. Not to be called from user code. Will be set by querying flickr.
     */
    public String getText() {
        return text;
    }

    /**
     * sets the comment text.
     * 
     * @param text
     */
    public void setText(String text) {
        this.text = text;
    }
}
",package com.flickr4java.flickr.photos.comments; import java.util.Date; public class Comment { private String id; private String author; private String authorName; private Date dateCreate; private String permaLink; private String text; public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public String getAuthorName() { return authorName; } public void setAuthorName(String authorName) { this.authorName = authorName; } public Date getDateCreate() { return dateCreate; } public void setDateCreate(Date dateCreate) { this.dateCreate = dateCreate; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getPermaLink() { return permaLink; } public void setPermaLink(String permaLink) { this.permaLink = permaLink; } public String getText() { return text; } public void setText(String text) { this.text = text; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.photos.comments; import java.util.Date; public class Comment { private String id; private String author; private String authorName; private Date dateCreate; private String permaLink; private String text; public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public String getAuthorName() { return authorName; } public void setAuthorName(String authorName) { this.authorName = authorName; } public Date getDateCreate() { return dateCreate; } public void setDateCreate(Date dateCreate) { this.dateCreate = dateCreate; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getPermaLink() { return permaLink; } public void setPermaLink(String permaLink) { this.permaLink = permaLink; } public String getText() { return text; } public void setText(String text) { this.text = text; } } ,"package com.flickr4java.flickr.photos.comments;  import java.util.Date;  /**
 * Encapsulated Photo comments.
 * 
 * @author till (Kill Krech) flickr:extranoise
 * @version $Id: Comment.java,v 1.2 2009/07/12 22:43:07 x-mago Exp $
 */ public class Comment {  private String id;  private String author;  private String authorName;  private Date dateCreate;  private String permaLink;  private String text;  /**
     * @return the nsid of the comment author
     */ public String getAuthor() { return author; }  /**
     * Set the nsis of the comment author. Not to be called from user code. Will be set by querying flickr.
     * 
     * @param author
     *            nsid of the user
     */ public void setAuthor(String author) { this.author = author; }  /**
     * @return the name of the author of the comment
     */ public String getAuthorName() { return authorName; }  /**
     * Sets the commment author name. Not to be called from user code. Will be set by querying flickr.
     * 
     * @param authorName
     */ public void setAuthorName(String authorName) { this.authorName = authorName; }  /**
     * 
     * @return the date, when the comment was created
     */ public Date getDateCreate() { return dateCreate; }  /**
     * Sets the date when the comment was created. Not to be called from user code. Will be set by querying flickr.
     * 
     * @param dateCreate
     *            date,when the comment was created
     */ public void setDateCreate(Date dateCreate) { this.dateCreate = dateCreate; }  /**
     * @return the unique comment id
     */ public String getId() { return id; }  /**
     * Sets the unique id of the comment. Not to be called from user code. Will be set by querying flickr.
     * 
     * @param id
     *            unique comment id
     */ public void setId(String id) { this.id = id; }  /**
     * @return a link to the comment on the photo page.
     */ public String getPermaLink() { return permaLink; }  /**
     * sets the link to the comment on the photo page. Not to be called from user code. Will be set by querying flickr.
     */ public void setPermaLink(String permaLink) { this.permaLink = permaLink; }  /**
     * @return the text of the comment with possible HTML markup. Not to be called from user code. Will be set by querying flickr.
     */ public String getText() { return text; }  /**
     * sets the comment text.
     * 
     * @param text
     */ public void setText(String text) { this.text = text; } }  "
src/main/java/com/flickr4java/flickr/photos/comments/CommentsInterface.java,"package com.flickr4java.flickr.photos.comments;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoList;
import com.flickr4java.flickr.photos.PhotoUtils;
import com.flickr4java.flickr.photos.PhotosInterface;
import com.flickr4java.flickr.util.StringUtilities;
import com.flickr4java.flickr.util.XMLUtilities;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Work on Comments.
 * 
 * @author till (Till Krech) flickr:extranoise
 * @version $Id: CommentsInterface.java,v 1.4 2009/07/11 20:30:27 x-mago Exp $
 */
public class CommentsInterface {
    public static final String METHOD_ADD_COMMENT = ""flickr.photos.comments.addComment"";

    public static final String METHOD_DELETE_COMMENT = ""flickr.photos.comments.deleteComment"";

    public static final String METHOD_EDIT_COMMENT = ""flickr.photos.comments.editComment"";

    public static final String METHOD_GET_LIST = ""flickr.photos.comments.getList"";

    public static final String METHOD_GET_RECENT = ""flickr.photos.comments.getRecentForContacts"";

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transportAPI;

    public CommentsInterface(String apiKey, String sharedSecret, Transport transport) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transport;
    }

    /**
     * Add comment to a photo as the currently authenticated user.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param photoId
     *            The id of the photo to add a comment to.
     * @param commentText
     *            Text of the comment.
     * @return a unique comment id.
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public String addComment(String photoId, String commentText) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_ADD_COMMENT);

        parameters.put(""photo_id"", photoId);
        parameters.put(""comment_text"", commentText);

        // Note: This method requires an HTTP POST request.
        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element commentElement = response.getPayload();
        return commentElement.getAttribute(""id"");
    }

    /**
     * Delete a comment as the currently authenticated user.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param commentId
     *            The id of the comment to delete.
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void deleteComment(String commentId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_DELETE_COMMENT);

        parameters.put(""comment_id"", commentId);

        // Note: This method requires an HTTP POST request.
        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        // This method has no specific response - It returns an empty
        // sucess response if it completes without error.
    }

    /**
     * Edit the text of a comment as the currently authenticated user.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param commentId
     *            The id of the comment to edit.
     * @param commentText
     *            Update the comment to this text.
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void editComment(String commentId, String commentText) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_EDIT_COMMENT);

        parameters.put(""comment_id"", commentId);
        parameters.put(""comment_text"", commentText);

        // Note: This method requires an HTTP POST request.
        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        // This method has no specific response - It returns an empty
        // sucess response if it completes without error.
    }

    /**
     * Returns the comments for a photo.
     * 
     * This method does not require authentication.
     * 
     * @param photoId
     *            The id of the photo to fetch comments for.
     * @return a List of {@link Comment} objects.
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public List<Comment> getList(String photoId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_LIST);
        parameters.put(""photo_id"", photoId);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        List<Comment> comments = new ArrayList<Comment>();
        Element commentsElement = response.getPayload();
        NodeList commentNodes = commentsElement.getElementsByTagName(""comment"");
        int n = commentNodes.getLength();
        for (int i = 0; i < n; i++) {
            Comment comment = new Comment();
            Element commentElement = (Element) commentNodes.item(i);
            comment.setId(commentElement.getAttribute(""id""));
            comment.setAuthor(commentElement.getAttribute(""author""));
            comment.setAuthorName(commentElement.getAttribute(""authorname""));
            comment.setPermaLink(commentElement.getAttribute(""permalink""));
            long unixTime = 0;
            try {
                unixTime = Long.parseLong(commentElement.getAttribute(""datecreate""));
            } catch (NumberFormatException e) {
                // what shall we do?
                e.printStackTrace();
            }
            comment.setDateCreate(new Date(unixTime * 1000L));
            comment.setPermaLink(commentElement.getAttribute(""permalink""));
            comment.setText(XMLUtilities.getValue(commentElement));
            comments.add(comment);
        }
        return comments;
    }

    /**
     * <p>
     * Returns the list of photos belonging to your contacts that have been commented on recently.
     * </p>
     * 
     * <p>
     * There is an emphasis on the recent part with this method, which is fancy-talk for ""in the last hour"".
     * </p>
     * 
     * <p>
     * It is not meant to be a general purpose, get all the comments ever, but rather a quick and easy way to bubble up photos that people are talking about
     * (""about"") now.
     * </p>
     * 
     * <p>
     * It has the added bonus / side-effect of bubbling up photos a person may have missed because they were uploaded before the photo owner was made a contact
     * or the business of life got in the way.
     * </p>
     * 
     * This method requires authentication with 'read' permission.
     * 
     * @param lastComment
     *            Limits the resultset to photos that have been commented on since this date. The default, and maximum, offset is (1) hour. Optional, can be
     *            null.
     * @param contactsFilter
     *            A list of contact NSIDs to limit the scope of the query to. Optional, can be null.
     * @param extras
     *            A list of extra information to fetch for each returned record. Optional, can be null.
     * @param perPage
     *            The number of photos per page.
     * @param page
     *            The page offset.
     * @return List of photos
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public PhotoList<Photo> getRecentForContacts(Date lastComment, ArrayList<String> contactsFilter, Set<String> extras, int perPage, int page)
            throws FlickrException {
        PhotoList<Photo> photos = new PhotoList<Photo>();
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", PhotosInterface.METHOD_GET_NOT_IN_SET);

        if (lastComment != null) {
            parameters.put(""last_comment"", String.valueOf(lastComment.getTime() / 1000L));
        }

        if (extras != null && !extras.isEmpty()) {
            parameters.put(""extras"", StringUtilities.join(extras, "",""));
        }

        if (contactsFilter != null && !contactsFilter.isEmpty()) {
            parameters.put(""contacts_filter"", StringUtilities.join(contactsFilter, "",""));
        }

        if (perPage > 0) {
            parameters.put(""per_page"", Integer.toString(perPage));
        }
        if (page > 0) {
            parameters.put(""page"", Integer.toString(page));
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element photosElement = response.getPayload();
        photos.setPage(photosElement.getAttribute(""page""));
        photos.setPages(photosElement.getAttribute(""pages""));
        photos.setPerPage(photosElement.getAttribute(""perpage""));
        photos.setTotal(photosElement.getAttribute(""total""));

        NodeList photoElements = photosElement.getElementsByTagName(""photo"");
        for (int i = 0; i < photoElements.getLength(); i++) {
            Element photoElement = (Element) photoElements.item(i);
            photos.add(PhotoUtils.createPhoto(photoElement));
        }
        return photos;
    }
}
","package com.flickr4java.flickr.photos.comments; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.photos.PhotosInterface; import com.flickr4java.flickr.util.StringUtilities; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.ArrayList; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Set; public class CommentsInterface { public static final String METHOD_ADD_COMMENT = ""flickr.photos.comments.addComment""; public static final String METHOD_DELETE_COMMENT = ""flickr.photos.comments.deleteComment""; public static final String METHOD_EDIT_COMMENT = ""flickr.photos.comments.editComment""; public static final String METHOD_GET_LIST = ""flickr.photos.comments.getList""; public static final String METHOD_GET_RECENT = ""flickr.photos.comments.getRecentForContacts""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public CommentsInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transport; } public String addComment(String photoId, String commentText) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD_COMMENT); parameters.put(""photo_id"", photoId); parameters.put(""comment_text"", commentText); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element commentElement = response.getPayload(); return commentElement.getAttribute(""id""); } public void deleteComment(String commentId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_DELETE_COMMENT); parameters.put(""comment_id"", commentId); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void editComment(String commentId, String commentText) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT_COMMENT); parameters.put(""comment_id"", commentId); parameters.put(""comment_text"", commentText); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public List<Comment> getList(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); parameters.put(""photo_id"", photoId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } List<Comment> comments = new ArrayList<Comment>(); Element commentsElement = response.getPayload(); NodeList commentNodes = commentsElement.getElementsByTagName(""comment""); int n = commentNodes.getLength(); for (int i = 0; i < n; i++) { Comment comment = new Comment(); Element commentElement = (Element) commentNodes.item(i); comment.setId(commentElement.getAttribute(""id"")); comment.setAuthor(commentElement.getAttribute(""author"")); comment.setAuthorName(commentElement.getAttribute(""authorname"")); comment.setPermaLink(commentElement.getAttribute(""permalink"")); long unixTime = 0; try { unixTime = Long.parseLong(commentElement.getAttribute(""datecreate"")); } catch (NumberFormatException e) { e.printStackTrace(); } comment.setDateCreate(new Date(unixTime * 1000L)); comment.setPermaLink(commentElement.getAttribute(""permalink"")); comment.setText(XMLUtilities.getValue(commentElement)); comments.add(comment); } return comments; } public PhotoList<Photo> getRecentForContacts(Date lastComment, ArrayList<String> contactsFilter, Set<String> extras, int perPage, int page)
            throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", PhotosInterface.METHOD_GET_NOT_IN_SET); if (lastComment != null) { parameters.put(""last_comment"", String.valueOf(lastComment.getTime() / 1000L)); } if (extras != null && !extras.isEmpty()) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (contactsFilter != null && !contactsFilter.isEmpty()) { parameters.put(""contacts_filter"", StringUtilities.join(contactsFilter, "","")); } if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoElements = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoElements.getLength(); i++) { Element photoElement = (Element) photoElements.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.photos.comments; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.photos.PhotosInterface; import com.flickr4java.flickr.util.StringUtilities; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.ArrayList; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Set; public class CommentsInterface { public static final String METHOD_ADD_COMMENT = ""flickr.photos.comments.addComment""; public static final String METHOD_DELETE_COMMENT = ""flickr.photos.comments.deleteComment""; public static final String METHOD_EDIT_COMMENT = ""flickr.photos.comments.editComment""; public static final String METHOD_GET_LIST = ""flickr.photos.comments.getList""; public static final String METHOD_GET_RECENT = ""flickr.photos.comments.getRecentForContacts""; private final String apiKey; private final String sharedSecret; private final Transport transportAPI; public CommentsInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transport; } public String addComment(String photoId, String commentText) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD_COMMENT); parameters.put(""photo_id"", photoId); parameters.put(""comment_text"", commentText); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element commentElement = response.getPayload(); return commentElement.getAttribute(""id""); } public void deleteComment(String commentId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_DELETE_COMMENT); parameters.put(""comment_id"", commentId); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void editComment(String commentId, String commentText) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT_COMMENT); parameters.put(""comment_id"", commentId); parameters.put(""comment_text"", commentText); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public List<Comment> getList(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); parameters.put(""photo_id"", photoId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } List<Comment> comments = new ArrayList<Comment>(); Element commentsElement = response.getPayload(); NodeList commentNodes = commentsElement.getElementsByTagName(""comment""); int n = commentNodes.getLength(); for (int i = 0; i < n; i++) { Comment comment = new Comment(); Element commentElement = (Element) commentNodes.item(i); comment.setId(commentElement.getAttribute(""id"")); comment.setAuthor(commentElement.getAttribute(""author"")); comment.setAuthorName(commentElement.getAttribute(""authorname"")); comment.setPermaLink(commentElement.getAttribute(""permalink"")); long unixTime = 0; try { unixTime = Long.parseLong(commentElement.getAttribute(""datecreate"")); } catch (NumberFormatException e) { e.printStackTrace(); } comment.setDateCreate(new Date(unixTime * 1000L)); comment.setPermaLink(commentElement.getAttribute(""permalink"")); comment.setText(XMLUtilities.getValue(commentElement)); comments.add(comment); } return comments; } public PhotoList<Photo> getRecentForContacts(Date lastComment, ArrayList<String> contactsFilter, Set<String> extras, int perPage, int page)
            throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", PhotosInterface.METHOD_GET_NOT_IN_SET); if (lastComment != null) { parameters.put(""last_comment"", String.valueOf(lastComment.getTime() / 1000L)); } if (extras != null && !extras.isEmpty()) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (contactsFilter != null && !contactsFilter.isEmpty()) { parameters.put(""contacts_filter"", StringUtilities.join(contactsFilter, "","")); } if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoElements = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoElements.getLength(); i++) { Element photoElement = (Element) photoElements.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } } ","package com.flickr4java.flickr.photos.comments;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.photos.PhotosInterface; import com.flickr4java.flickr.util.StringUtilities; import com.flickr4java.flickr.util.XMLUtilities;  import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import java.util.ArrayList; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Set;  /**
 * Work on Comments.
 * 
 * @author till (Till Krech) flickr:extranoise
 * @version $Id: CommentsInterface.java,v 1.4 2009/07/11 20:30:27 x-mago Exp $
 */ public class CommentsInterface { public static final String METHOD_ADD_COMMENT = ""flickr.photos.comments.addComment"";  public static final String METHOD_DELETE_COMMENT = ""flickr.photos.comments.deleteComment"";  public static final String METHOD_EDIT_COMMENT = ""flickr.photos.comments.editComment"";  public static final String METHOD_GET_LIST = ""flickr.photos.comments.getList"";  public static final String METHOD_GET_RECENT = ""flickr.photos.comments.getRecentForContacts"";  private final String apiKey;  private final String sharedSecret;  private final Transport transportAPI;  public CommentsInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transport; }  /**
     * Add comment to a photo as the currently authenticated user.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param photoId
     *            The id of the photo to add a comment to.
     * @param commentText
     *            Text of the comment.
     * @return a unique comment id.
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public String addComment(String photoId, String commentText) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD_COMMENT);  parameters.put(""photo_id"", photoId); parameters.put(""comment_text"", commentText);  // Note: This method requires an HTTP POST request. Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element commentElement = response.getPayload(); return commentElement.getAttribute(""id""); }  /**
     * Delete a comment as the currently authenticated user.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param commentId
     *            The id of the comment to delete.
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void deleteComment(String commentId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_DELETE_COMMENT);  parameters.put(""comment_id"", commentId);  // Note: This method requires an HTTP POST request. Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } // This method has no specific response - It returns an empty // sucess response if it completes without error. }  /**
     * Edit the text of a comment as the currently authenticated user.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param commentId
     *            The id of the comment to edit.
     * @param commentText
     *            Update the comment to this text.
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void editComment(String commentId, String commentText) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT_COMMENT);  parameters.put(""comment_id"", commentId); parameters.put(""comment_text"", commentText);  // Note: This method requires an HTTP POST request. Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } // This method has no specific response - It returns an empty // sucess response if it completes without error. }  /**
     * Returns the comments for a photo.
     * 
     * This method does not require authentication.
     * 
     * @param photoId
     *            The id of the photo to fetch comments for.
     * @return a List of {@link Comment} objects.
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public List<Comment> getList(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); parameters.put(""photo_id"", photoId);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } List<Comment> comments = new ArrayList<Comment>(); Element commentsElement = response.getPayload(); NodeList commentNodes = commentsElement.getElementsByTagName(""comment""); int n = commentNodes.getLength(); for (int i = 0; i < n; i++) { Comment comment = new Comment(); Element commentElement = (Element) commentNodes.item(i); comment.setId(commentElement.getAttribute(""id"")); comment.setAuthor(commentElement.getAttribute(""author"")); comment.setAuthorName(commentElement.getAttribute(""authorname"")); comment.setPermaLink(commentElement.getAttribute(""permalink"")); long unixTime = 0; try { unixTime = Long.parseLong(commentElement.getAttribute(""datecreate"")); } catch (NumberFormatException e) { // what shall we do? e.printStackTrace(); } comment.setDateCreate(new Date(unixTime * 1000L)); comment.setPermaLink(commentElement.getAttribute(""permalink"")); comment.setText(XMLUtilities.getValue(commentElement)); comments.add(comment); } return comments; }  /**
     * <p>
     * Returns the list of photos belonging to your contacts that have been commented on recently.
     * </p>
     * 
     * <p>
     * There is an emphasis on the recent part with this method, which is fancy-talk for ""in the last hour"".
     * </p>
     * 
     * <p>
     * It is not meant to be a general purpose, get all the comments ever, but rather a quick and easy way to bubble up photos that people are talking about
     * (""about"") now.
     * </p>
     * 
     * <p>
     * It has the added bonus / side-effect of bubbling up photos a person may have missed because they were uploaded before the photo owner was made a contact
     * or the business of life got in the way.
     * </p>
     * 
     * This method requires authentication with 'read' permission.
     * 
     * @param lastComment
     *            Limits the resultset to photos that have been commented on since this date. The default, and maximum, offset is (1) hour. Optional, can be
     *            null.
     * @param contactsFilter
     *            A list of contact NSIDs to limit the scope of the query to. Optional, can be null.
     * @param extras
     *            A list of extra information to fetch for each returned record. Optional, can be null.
     * @param perPage
     *            The number of photos per page.
     * @param page
     *            The page offset.
     * @return List of photos
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public PhotoList<Photo> getRecentForContacts(Date lastComment, ArrayList<String> contactsFilter, Set<String> extras, int perPage, int page)
            throws FlickrException { PhotoList<Photo> photos = new PhotoList<Photo>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", PhotosInterface.METHOD_GET_NOT_IN_SET);  if (lastComment != null) { parameters.put(""last_comment"", String.valueOf(lastComment.getTime() / 1000L)); }  if (extras != null && !extras.isEmpty()) { parameters.put(""extras"", StringUtilities.join(extras, "","")); }  if (contactsFilter != null && !contactsFilter.isEmpty()) { parameters.put(""contacts_filter"", StringUtilities.join(contactsFilter, "","")); }  if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total""));  NodeList photoElements = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoElements.getLength(); i++) { Element photoElement = (Element) photoElements.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } }  "
src/main/java/com/flickr4java/flickr/photos/geo/GeoInterface.java,"package com.flickr4java.flickr.photos.geo;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.photos.GeoData;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoList;
import com.flickr4java.flickr.photos.PhotoUtils;
import com.flickr4java.flickr.util.StringUtilities;
import com.flickr4java.flickr.util.XMLUtilities;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * Access to the flickr.photos.geo methods.
 * 
 * @author till (Till Krech - flickr:extranoise)
 * @version $Id: GeoInterface.java,v 1.5 2009/07/22 22:39:36 x-mago Exp $
 */
public class GeoInterface {
    public static final String METHOD_GET_LOCATION = ""flickr.photos.geo.getLocation"";

    public static final String METHOD_GET_PERMS = ""flickr.photos.geo.getPerms"";

    public static final String METHOD_REMOVE_LOCATION = ""flickr.photos.geo.removeLocation"";

    public static final String METHOD_SET_LOCATION = ""flickr.photos.geo.setLocation"";

    public static final String METHOD_SET_PERMS = ""flickr.photos.geo.setPerms"";

    public static final String METHOD_BATCH_CORRECT_LOCATION = ""flickr.photos.geo.batchCorrectLocation"";

    public static final String METHOD_CORRECT_LOCATION = ""flickr.photos.geo.correctLocation"";

    public static final String METHOD_PHOTOS_FOR_LOCATION = ""flickr.photos.geo.photosForLocation"";

    public static final String METHOD_SET_CONTEXT = ""flickr.photos.geo.setContext"";

    private final String apiKey;

    private final String sharedSecret;

    private final Transport transport;

    public GeoInterface(String apiKey, String sharedSecret, Transport transport) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transport = transport;
    }

    /**
     * Get the geo data (latitude and longitude and the accuracy level) for a photo.
     * 
     * This method does not require authentication.
     * 
     * @param photoId
     *            reqired photo id, not null
     * @return Geo Data, if the photo has it.
     * @throws FlickrException if there was a problem connecting to Flickr
     *             if photo id is invalid, if photo has no geodata or if any other error has been reported in the response.
     */
    public GeoData getLocation(String photoId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_LOCATION);
        parameters.put(""photo_id"", photoId);

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        // response:
        // <photo id=""123"">
        // <location latitude=""-17.685895"" longitude=""-63.36914"" accuracy=""6"" />
        // </photo>

        Element photoElement = response.getPayload();

        Element locationElement = XMLUtilities.getChild(photoElement, ""location"");
        String latStr = locationElement.getAttribute(""latitude"");
        String lonStr = locationElement.getAttribute(""longitude"");
        String accStr = locationElement.getAttribute(""accuracy"");
        // I ignore the id attribute. should be the same as the given
        // photo id.
        GeoData geoData = new GeoData(lonStr, latStr, accStr);
        return geoData;
    }

    /**
     * Get permissions for who may view geo data for a photo.
     * 
     * This method requires authentication with 'read' permission.
     * 
     * @param photoId
     *            reqired photo id, not null
     * @return the permissions
     * @throws FlickrException if there was a problem connecting to Flickr
     *             if photo id is invalid, if photo has no geodata or if any other error has been reported in the response.
     */
    public GeoPermissions getPerms(String photoId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_PERMS);
        parameters.put(""photo_id"", photoId);

        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        // response:
        // <perms id=""240935723"" ispublic=""1"" iscontact=""0"" isfriend=""0"" isfamily=""0""/>
        GeoPermissions perms = new GeoPermissions();
        Element permsElement = response.getPayload();
        perms.setPublic(""1"".equals(permsElement.getAttribute(""ispublic"")));
        perms.setContact(""1"".equals(permsElement.getAttribute(""iscontact"")));
        perms.setFriend(""1"".equals(permsElement.getAttribute(""isfriend"")));
        perms.setFamily(""1"".equals(permsElement.getAttribute(""isfamily"")));
        perms.setId(permsElement.getAttribute(""id""));
        // I ignore the id attribute. should be the same as the given
        // photo id.
        return perms;
    }

    /**
     * Removes the geo data associated with a photo.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void removeLocation(String photoId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_REMOVE_LOCATION);
        parameters.put(""photo_id"", photoId);

        // Note: This method requires an HTTP POST request.
        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        // This method has no specific response - It returns an empty sucess response
        // if it completes without error.
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Sets the geo data (latitude and longitude and, optionally, the accuracy level) for a photo. Before users may assign location data to a photo they must
     * define who, by default, may view that information. Users can edit this preference at <a href=""http://www.flickr.com/account/geo/privacy/"">flickr</a>. If
     * a user has not set this preference, the API method will return an error.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param photoId
     *            The id of the photo to cet permissions for.
     * @param location
     *            geo data with optional accuracy (1-16), accuracy 0 to use the default.
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void setLocation(String photoId, GeoData location) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_SET_LOCATION);

        parameters.put(""photo_id"", photoId);
        parameters.put(""lat"", String.valueOf(location.getLatitude()));
        parameters.put(""lon"", String.valueOf(location.getLongitude()));
        int accuracy = location.getAccuracy();
        if (accuracy > 0) {
            parameters.put(""accuracy"", String.valueOf(location.getAccuracy()));
        }

        // Note: This method requires an HTTP POST request.
        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        // This method has no specific response - It returns an empty sucess response
        // if it completes without error.
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Set the permission for who may view the geo data associated with a photo.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param photoId
     *            The id of the photo to set permissions for.
     * @param perms
     *            Permissions, who can see the geo data of this photo
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void setPerms(String photoId, GeoPermissions perms) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_SET_PERMS);
        parameters.put(""photo_id"", photoId);
        parameters.put(""is_public"", perms.isPublic() ? ""1"" : ""0"");
        parameters.put(""is_contact"", perms.isContact() ? ""1"" : ""0"");
        parameters.put(""is_friend"", perms.isFriend() ? ""1"" : ""0"");
        parameters.put(""is_family"", perms.isFamily() ? ""1"" : ""0"");

        // Note: This method requires an HTTP POST request.
        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        // This method has no specific response - It returns an empty sucess response
        // if it completes without error.
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Correct the places hierarchy for all the photos for a user at a given latitude, longitude and accuracy.
     * <p>
     * 
     * Batch corrections are processed in a delayed queue so it may take a few minutes before the changes are reflected in a user's photos.
     * 
     * @param location
     *            The latitude/longitude and accuracy of the photos to be update.
     * @param placeId
     *            A Flickr Places ID. (While optional, you must pass either a valid Places ID or a WOE ID.)
     * @param woeId
     *            A Where On Earth (WOE) ID. (While optional, you must pass either a valid Places ID or a WOE ID.)
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void batchCorrectLocation(GeoData location, String placeId, String woeId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_BATCH_CORRECT_LOCATION);

        if (placeId != null) {
            parameters.put(""place_id"", placeId);
        }
        if (woeId != null) {
            parameters.put(""woe_id"", woeId);
        }
        parameters.put(""lat"", Float.toString(location.getLatitude()));
        parameters.put(""lon"", Float.toString(location.getLongitude()));
        parameters.put(""accuracy"", Integer.toString(location.getAccuracy()));

        // Note: This method requires an HTTP POST request.
        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        // This method has no specific response - It returns an empty sucess response
        // if it completes without error.
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * 
     * @param photoId
     *            Photo id (required).
     * @param placeId
     *            A Flickr Places ID. (While optional, you must pass either a valid Places ID or a WOE ID.)
     * @param woeId
     *            A Where On Earth (WOE) ID. (While optional, you must pass either a valid Places ID or a WOE ID.)
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void correctLocation(String photoId, String placeId, String woeId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_CORRECT_LOCATION);

        parameters.put(""photo_id"", photoId);
        if (placeId != null) {
            parameters.put(""place_id"", placeId);
        }
        if (woeId != null) {
            parameters.put(""woe_id"", woeId);
        }

        // Note: This method requires an HTTP POST request.
        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        // This method has no specific response - It returns an empty sucess response
        // if it completes without error.
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Return a list of photos for a user at a specific latitude, longitude and accuracy.
     * 
     * @param location
     * @param extras
     * @param perPage
     * @param page
     * @return The collection of Photo objects
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see com.flickr4java.flickr.photos.Extras
     */
    public PhotoList<Photo> photosForLocation(GeoData location, Set<String> extras, int perPage, int page) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        PhotoList<Photo> photos = new PhotoList<Photo>();
        parameters.put(""method"", METHOD_PHOTOS_FOR_LOCATION);

        if (extras.size() > 0) {
            parameters.put(""extras"", StringUtilities.join(extras, "",""));
        }
        if (perPage > 0) {
            parameters.put(""per_page"", Integer.toString(perPage));
        }
        if (page > 0) {
            parameters.put(""page"", Integer.toString(page));
        }
        parameters.put(""lat"", Float.toString(location.getLatitude()));
        parameters.put(""lon"", Float.toString(location.getLongitude()));
        parameters.put(""accuracy"", Integer.toString(location.getAccuracy()));
        Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        Element photosElement = response.getPayload();
        photos.setPage(photosElement.getAttribute(""page""));
        photos.setPages(photosElement.getAttribute(""pages""));
        photos.setPerPage(photosElement.getAttribute(""perpage""));
        photos.setTotal(photosElement.getAttribute(""total""));

        NodeList photoElements = photosElement.getElementsByTagName(""photo"");
        for (int i = 0; i < photoElements.getLength(); i++) {
            Element photoElement = (Element) photoElements.item(i);
            photos.add(PhotoUtils.createPhoto(photoElement));
        }
        return photos;
    }

    /**
     * Indicate the state of a photo's geotagginess beyond latitude and longitude.
     * <p>
     * 
     * Note : photos passed to this method must already be geotagged (using the {@link GeoInterface#setLocation(String, GeoData)} method).
     * 
     * @param photoId
     *            Photo id (required).
     * @param context
     *            Context is a numeric value representing the photo's geotagginess beyond latitude and longitude. For example, you may wish to indicate that a
     *            photo was taken ""indoors"" (1) or ""outdoors"" (2).
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void setContext(String photoId, int context) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_SET_CONTEXT);

        parameters.put(""photo_id"", photoId);
        parameters.put(""context"", """" + context);

        // Note: This method requires an HTTP POST request.
        Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret);
        // This method has no specific response - It returns an empty sucess response
        // if it completes without error.
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

}
","package com.flickr4java.flickr.photos.geo; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.GeoData; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.util.StringUtilities; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.HashMap; import java.util.Map; import java.util.Set; public class GeoInterface { public static final String METHOD_GET_LOCATION = ""flickr.photos.geo.getLocation""; public static final String METHOD_GET_PERMS = ""flickr.photos.geo.getPerms""; public static final String METHOD_REMOVE_LOCATION = ""flickr.photos.geo.removeLocation""; public static final String METHOD_SET_LOCATION = ""flickr.photos.geo.setLocation""; public static final String METHOD_SET_PERMS = ""flickr.photos.geo.setPerms""; public static final String METHOD_BATCH_CORRECT_LOCATION = ""flickr.photos.geo.batchCorrectLocation""; public static final String METHOD_CORRECT_LOCATION = ""flickr.photos.geo.correctLocation""; public static final String METHOD_PHOTOS_FOR_LOCATION = ""flickr.photos.geo.photosForLocation""; public static final String METHOD_SET_CONTEXT = ""flickr.photos.geo.setContext""; private final String apiKey; private final String sharedSecret; private final Transport transport; public GeoInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transport = transport; } public GeoData getLocation(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LOCATION); parameters.put(""photo_id"", photoId); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photoElement = response.getPayload(); Element locationElement = XMLUtilities.getChild(photoElement, ""location""); String latStr = locationElement.getAttribute(""latitude""); String lonStr = locationElement.getAttribute(""longitude""); String accStr = locationElement.getAttribute(""accuracy""); GeoData geoData = new GeoData(lonStr, latStr, accStr); return geoData; } public GeoPermissions getPerms(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PERMS); parameters.put(""photo_id"", photoId); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } GeoPermissions perms = new GeoPermissions(); Element permsElement = response.getPayload(); perms.setPublic(""1"".equals(permsElement.getAttribute(""ispublic""))); perms.setContact(""1"".equals(permsElement.getAttribute(""iscontact""))); perms.setFriend(""1"".equals(permsElement.getAttribute(""isfriend""))); perms.setFamily(""1"".equals(permsElement.getAttribute(""isfamily""))); perms.setId(permsElement.getAttribute(""id"")); return perms; } public void removeLocation(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REMOVE_LOCATION); parameters.put(""photo_id"", photoId); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void setLocation(String photoId, GeoData location) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_LOCATION); parameters.put(""photo_id"", photoId); parameters.put(""lat"", String.valueOf(location.getLatitude())); parameters.put(""lon"", String.valueOf(location.getLongitude())); int accuracy = location.getAccuracy(); if (accuracy > 0) { parameters.put(""accuracy"", String.valueOf(location.getAccuracy())); } Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void setPerms(String photoId, GeoPermissions perms) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_PERMS); parameters.put(""photo_id"", photoId); parameters.put(""is_public"", perms.isPublic() ? ""1"" : ""0""); parameters.put(""is_contact"", perms.isContact() ? ""1"" : ""0""); parameters.put(""is_friend"", perms.isFriend() ? ""1"" : ""0""); parameters.put(""is_family"", perms.isFamily() ? ""1"" : ""0""); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void batchCorrectLocation(GeoData location, String placeId, String woeId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_BATCH_CORRECT_LOCATION); if (placeId != null) { parameters.put(""place_id"", placeId); } if (woeId != null) { parameters.put(""woe_id"", woeId); } parameters.put(""lat"", Float.toString(location.getLatitude())); parameters.put(""lon"", Float.toString(location.getLongitude())); parameters.put(""accuracy"", Integer.toString(location.getAccuracy())); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void correctLocation(String photoId, String placeId, String woeId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_CORRECT_LOCATION); parameters.put(""photo_id"", photoId); if (placeId != null) { parameters.put(""place_id"", placeId); } if (woeId != null) { parameters.put(""woe_id"", woeId); } Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public PhotoList<Photo> photosForLocation(GeoData location, Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PhotoList<Photo> photos = new PhotoList<Photo>(); parameters.put(""method"", METHOD_PHOTOS_FOR_LOCATION); if (extras.size() > 0) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); } parameters.put(""lat"", Float.toString(location.getLatitude())); parameters.put(""lon"", Float.toString(location.getLongitude())); parameters.put(""accuracy"", Integer.toString(location.getAccuracy())); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoElements = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoElements.getLength(); i++) { Element photoElement = (Element) photoElements.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } public void setContext(String photoId, int context) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_CONTEXT); parameters.put(""photo_id"", photoId); parameters.put(""context"", """" + context); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.photos.geo; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.GeoData; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.util.StringUtilities; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.HashMap; import java.util.Map; import java.util.Set; public class GeoInterface { public static final String METHOD_GET_LOCATION = ""flickr.photos.geo.getLocation""; public static final String METHOD_GET_PERMS = ""flickr.photos.geo.getPerms""; public static final String METHOD_REMOVE_LOCATION = ""flickr.photos.geo.removeLocation""; public static final String METHOD_SET_LOCATION = ""flickr.photos.geo.setLocation""; public static final String METHOD_SET_PERMS = ""flickr.photos.geo.setPerms""; public static final String METHOD_BATCH_CORRECT_LOCATION = ""flickr.photos.geo.batchCorrectLocation""; public static final String METHOD_CORRECT_LOCATION = ""flickr.photos.geo.correctLocation""; public static final String METHOD_PHOTOS_FOR_LOCATION = ""flickr.photos.geo.photosForLocation""; public static final String METHOD_SET_CONTEXT = ""flickr.photos.geo.setContext""; private final String apiKey; private final String sharedSecret; private final Transport transport; public GeoInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transport = transport; } public GeoData getLocation(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LOCATION); parameters.put(""photo_id"", photoId); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photoElement = response.getPayload(); Element locationElement = XMLUtilities.getChild(photoElement, ""location""); String latStr = locationElement.getAttribute(""latitude""); String lonStr = locationElement.getAttribute(""longitude""); String accStr = locationElement.getAttribute(""accuracy""); GeoData geoData = new GeoData(lonStr, latStr, accStr); return geoData; } public GeoPermissions getPerms(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PERMS); parameters.put(""photo_id"", photoId); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } GeoPermissions perms = new GeoPermissions(); Element permsElement = response.getPayload(); perms.setPublic(""1"".equals(permsElement.getAttribute(""ispublic""))); perms.setContact(""1"".equals(permsElement.getAttribute(""iscontact""))); perms.setFriend(""1"".equals(permsElement.getAttribute(""isfriend""))); perms.setFamily(""1"".equals(permsElement.getAttribute(""isfamily""))); perms.setId(permsElement.getAttribute(""id"")); return perms; } public void removeLocation(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REMOVE_LOCATION); parameters.put(""photo_id"", photoId); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void setLocation(String photoId, GeoData location) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_LOCATION); parameters.put(""photo_id"", photoId); parameters.put(""lat"", String.valueOf(location.getLatitude())); parameters.put(""lon"", String.valueOf(location.getLongitude())); int accuracy = location.getAccuracy(); if (accuracy > 0) { parameters.put(""accuracy"", String.valueOf(location.getAccuracy())); } Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void setPerms(String photoId, GeoPermissions perms) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_PERMS); parameters.put(""photo_id"", photoId); parameters.put(""is_public"", perms.isPublic() ? ""1"" : ""0""); parameters.put(""is_contact"", perms.isContact() ? ""1"" : ""0""); parameters.put(""is_friend"", perms.isFriend() ? ""1"" : ""0""); parameters.put(""is_family"", perms.isFamily() ? ""1"" : ""0""); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void batchCorrectLocation(GeoData location, String placeId, String woeId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_BATCH_CORRECT_LOCATION); if (placeId != null) { parameters.put(""place_id"", placeId); } if (woeId != null) { parameters.put(""woe_id"", woeId); } parameters.put(""lat"", Float.toString(location.getLatitude())); parameters.put(""lon"", Float.toString(location.getLongitude())); parameters.put(""accuracy"", Integer.toString(location.getAccuracy())); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void correctLocation(String photoId, String placeId, String woeId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_CORRECT_LOCATION); parameters.put(""photo_id"", photoId); if (placeId != null) { parameters.put(""place_id"", placeId); } if (woeId != null) { parameters.put(""woe_id"", woeId); } Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public PhotoList<Photo> photosForLocation(GeoData location, Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PhotoList<Photo> photos = new PhotoList<Photo>(); parameters.put(""method"", METHOD_PHOTOS_FOR_LOCATION); if (extras.size() > 0) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); } parameters.put(""lat"", Float.toString(location.getLatitude())); parameters.put(""lon"", Float.toString(location.getLongitude())); parameters.put(""accuracy"", Integer.toString(location.getAccuracy())); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total"")); NodeList photoElements = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoElements.getLength(); i++) { Element photoElement = (Element) photoElements.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; } public void setContext(String photoId, int context) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_CONTEXT); parameters.put(""photo_id"", photoId); parameters.put(""context"", """" + context); Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } } ","package com.flickr4java.flickr.photos.geo;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.GeoData; import com.flickr4java.flickr.photos.Photo; import com.flickr4java.flickr.photos.PhotoList; import com.flickr4java.flickr.photos.PhotoUtils; import com.flickr4java.flickr.util.StringUtilities; import com.flickr4java.flickr.util.XMLUtilities;  import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import java.util.HashMap; import java.util.Map; import java.util.Set;  /**
 * Access to the flickr.photos.geo methods.
 * 
 * @author till (Till Krech - flickr:extranoise)
 * @version $Id: GeoInterface.java,v 1.5 2009/07/22 22:39:36 x-mago Exp $
 */ public class GeoInterface { public static final String METHOD_GET_LOCATION = ""flickr.photos.geo.getLocation"";  public static final String METHOD_GET_PERMS = ""flickr.photos.geo.getPerms"";  public static final String METHOD_REMOVE_LOCATION = ""flickr.photos.geo.removeLocation"";  public static final String METHOD_SET_LOCATION = ""flickr.photos.geo.setLocation"";  public static final String METHOD_SET_PERMS = ""flickr.photos.geo.setPerms"";  public static final String METHOD_BATCH_CORRECT_LOCATION = ""flickr.photos.geo.batchCorrectLocation"";  public static final String METHOD_CORRECT_LOCATION = ""flickr.photos.geo.correctLocation"";  public static final String METHOD_PHOTOS_FOR_LOCATION = ""flickr.photos.geo.photosForLocation"";  public static final String METHOD_SET_CONTEXT = ""flickr.photos.geo.setContext"";  private final String apiKey;  private final String sharedSecret;  private final Transport transport;  public GeoInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transport = transport; }  /**
     * Get the geo data (latitude and longitude and the accuracy level) for a photo.
     * 
     * This method does not require authentication.
     * 
     * @param photoId
     *            reqired photo id, not null
     * @return Geo Data, if the photo has it.
     * @throws FlickrException if there was a problem connecting to Flickr
     *             if photo id is invalid, if photo has no geodata or if any other error has been reported in the response.
     */ public GeoData getLocation(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LOCATION); parameters.put(""photo_id"", photoId);  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } // response: // <photo id=""123""> // <location latitude=""-17.685895"" longitude=""-63.36914"" accuracy=""6"" /> // </photo>  Element photoElement = response.getPayload();  Element locationElement = XMLUtilities.getChild(photoElement, ""location""); String latStr = locationElement.getAttribute(""latitude""); String lonStr = locationElement.getAttribute(""longitude""); String accStr = locationElement.getAttribute(""accuracy""); // I ignore the id attribute. should be the same as the given // photo id. GeoData geoData = new GeoData(lonStr, latStr, accStr); return geoData; }  /**
     * Get permissions for who may view geo data for a photo.
     * 
     * This method requires authentication with 'read' permission.
     * 
     * @param photoId
     *            reqired photo id, not null
     * @return the permissions
     * @throws FlickrException if there was a problem connecting to Flickr
     *             if photo id is invalid, if photo has no geodata or if any other error has been reported in the response.
     */ public GeoPermissions getPerms(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_PERMS); parameters.put(""photo_id"", photoId);  Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } // response: // <perms id=""240935723"" ispublic=""1"" iscontact=""0"" isfriend=""0"" isfamily=""0""/> GeoPermissions perms = new GeoPermissions(); Element permsElement = response.getPayload(); perms.setPublic(""1"".equals(permsElement.getAttribute(""ispublic""))); perms.setContact(""1"".equals(permsElement.getAttribute(""iscontact""))); perms.setFriend(""1"".equals(permsElement.getAttribute(""isfriend""))); perms.setFamily(""1"".equals(permsElement.getAttribute(""isfamily""))); perms.setId(permsElement.getAttribute(""id"")); // I ignore the id attribute. should be the same as the given // photo id. return perms; }  /**
     * Removes the geo data associated with a photo.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void removeLocation(String photoId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_REMOVE_LOCATION); parameters.put(""photo_id"", photoId);  // Note: This method requires an HTTP POST request. Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); // This method has no specific response - It returns an empty sucess response // if it completes without error. if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Sets the geo data (latitude and longitude and, optionally, the accuracy level) for a photo. Before users may assign location data to a photo they must
     * define who, by default, may view that information. Users can edit this preference at <a href=""http://www.flickr.com/account/geo/privacy/"">flickr</a>. If
     * a user has not set this preference, the API method will return an error.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param photoId
     *            The id of the photo to cet permissions for.
     * @param location
     *            geo data with optional accuracy (1-16), accuracy 0 to use the default.
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void setLocation(String photoId, GeoData location) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_LOCATION);  parameters.put(""photo_id"", photoId); parameters.put(""lat"", String.valueOf(location.getLatitude())); parameters.put(""lon"", String.valueOf(location.getLongitude())); int accuracy = location.getAccuracy(); if (accuracy > 0) { parameters.put(""accuracy"", String.valueOf(location.getAccuracy())); }  // Note: This method requires an HTTP POST request. Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); // This method has no specific response - It returns an empty sucess response // if it completes without error. if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Set the permission for who may view the geo data associated with a photo.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param photoId
     *            The id of the photo to set permissions for.
     * @param perms
     *            Permissions, who can see the geo data of this photo
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void setPerms(String photoId, GeoPermissions perms) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_PERMS); parameters.put(""photo_id"", photoId); parameters.put(""is_public"", perms.isPublic() ? ""1"" : ""0""); parameters.put(""is_contact"", perms.isContact() ? ""1"" : ""0""); parameters.put(""is_friend"", perms.isFriend() ? ""1"" : ""0""); parameters.put(""is_family"", perms.isFamily() ? ""1"" : ""0"");  // Note: This method requires an HTTP POST request. Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); // This method has no specific response - It returns an empty sucess response // if it completes without error. if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Correct the places hierarchy for all the photos for a user at a given latitude, longitude and accuracy.
     * <p>
     * 
     * Batch corrections are processed in a delayed queue so it may take a few minutes before the changes are reflected in a user's photos.
     * 
     * @param location
     *            The latitude/longitude and accuracy of the photos to be update.
     * @param placeId
     *            A Flickr Places ID. (While optional, you must pass either a valid Places ID or a WOE ID.)
     * @param woeId
     *            A Where On Earth (WOE) ID. (While optional, you must pass either a valid Places ID or a WOE ID.)
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void batchCorrectLocation(GeoData location, String placeId, String woeId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_BATCH_CORRECT_LOCATION);  if (placeId != null) { parameters.put(""place_id"", placeId); } if (woeId != null) { parameters.put(""woe_id"", woeId); } parameters.put(""lat"", Float.toString(location.getLatitude())); parameters.put(""lon"", Float.toString(location.getLongitude())); parameters.put(""accuracy"", Integer.toString(location.getAccuracy()));  // Note: This method requires an HTTP POST request. Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); // This method has no specific response - It returns an empty sucess response // if it completes without error. if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * 
     * @param photoId
     *            Photo id (required).
     * @param placeId
     *            A Flickr Places ID. (While optional, you must pass either a valid Places ID or a WOE ID.)
     * @param woeId
     *            A Where On Earth (WOE) ID. (While optional, you must pass either a valid Places ID or a WOE ID.)
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void correctLocation(String photoId, String placeId, String woeId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_CORRECT_LOCATION);  parameters.put(""photo_id"", photoId); if (placeId != null) { parameters.put(""place_id"", placeId); } if (woeId != null) { parameters.put(""woe_id"", woeId); }  // Note: This method requires an HTTP POST request. Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); // This method has no specific response - It returns an empty sucess response // if it completes without error. if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Return a list of photos for a user at a specific latitude, longitude and accuracy.
     * 
     * @param location
     * @param extras
     * @param perPage
     * @param page
     * @return The collection of Photo objects
     * @throws FlickrException if there was a problem connecting to Flickr
     * @see com.flickr4java.flickr.photos.Extras
     */ public PhotoList<Photo> photosForLocation(GeoData location, Set<String> extras, int perPage, int page) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); PhotoList<Photo> photos = new PhotoList<Photo>(); parameters.put(""method"", METHOD_PHOTOS_FOR_LOCATION);  if (extras.size() > 0) { parameters.put(""extras"", StringUtilities.join(extras, "","")); } if (perPage > 0) { parameters.put(""per_page"", Integer.toString(perPage)); } if (page > 0) { parameters.put(""page"", Integer.toString(page)); } parameters.put(""lat"", Float.toString(location.getLatitude())); parameters.put(""lon"", Float.toString(location.getLongitude())); parameters.put(""accuracy"", Integer.toString(location.getAccuracy())); Response response = transport.get(transport.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element photosElement = response.getPayload(); photos.setPage(photosElement.getAttribute(""page"")); photos.setPages(photosElement.getAttribute(""pages"")); photos.setPerPage(photosElement.getAttribute(""perpage"")); photos.setTotal(photosElement.getAttribute(""total""));  NodeList photoElements = photosElement.getElementsByTagName(""photo""); for (int i = 0; i < photoElements.getLength(); i++) { Element photoElement = (Element) photoElements.item(i); photos.add(PhotoUtils.createPhoto(photoElement)); } return photos; }  /**
     * Indicate the state of a photo's geotagginess beyond latitude and longitude.
     * <p>
     * 
     * Note : photos passed to this method must already be geotagged (using the {@link GeoInterface#setLocation(String, GeoData)} method).
     * 
     * @param photoId
     *            Photo id (required).
     * @param context
     *            Context is a numeric value representing the photo's geotagginess beyond latitude and longitude. For example, you may wish to indicate that a
     *            photo was taken ""indoors"" (1) or ""outdoors"" (2).
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void setContext(String photoId, int context) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_CONTEXT);  parameters.put(""photo_id"", photoId); parameters.put(""context"", """" + context);  // Note: This method requires an HTTP POST request. Response response = transport.post(transport.getPath(), parameters, apiKey, sharedSecret); // This method has no specific response - It returns an empty sucess response // if it completes without error. if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  }  "
src/main/java/com/flickr4java/flickr/photos/geo/GeoPermissions.java,"package com.flickr4java.flickr.photos.geo;

/**
 * Simple encapsulation of viewing permissions for geo data.
 * 
 * @author till (Till Krech - flickr:extranoise)
 * 
 */
public class GeoPermissions {
    private static final long serialVersionUID = 12L;

    private boolean pub;

    private boolean contact;

    private boolean friend;

    private boolean family;
    
    private String id;

    /**
     * @return true if contacts may see the geo data
     */
    public boolean isContact() {
        return contact;
    }

    /**
     * enables / disables viewing of geo data by contacs.
     * 
     * @param enable
     *            true enables / false diables
     */
    public void setContact(boolean enable) {
        this.contact = enable;
    }

    /**
     * @return true if ""family members"" may see the geo data
     */
    public boolean isFamily() {
        return family;
    }

    /**
     * enables / disables viewing of geo data by ""family members"".
     * 
     * @param enable
     *            true enables / false diables
     */
    public void setFamily(boolean enable) {
        this.family = enable;
    }

    /**
     * @return true if ""friends"" may see the geo data
     */
    public boolean isFriend() {
        return friend;
    }

    /**
     * enables / disables viewing of geo data by ""friends"".
     * 
     * @param enable
     *            true enables / false diables
     */
    public void setFriend(boolean enable) {
        this.friend = enable;
    }

    /**
     * @return true if anyone may see the geo data
     */
    public boolean isPublic() {
        return pub;
    }

    /**
     * enables / disables viewing of geo data by any one.
     * 
     * @param enable
     *            true enables / false diables
     */
    public void setPublic(boolean enable) {
        this.pub = enable;
    }
    
	/**
	 * @return the the photo_id
	 */
	public String getId() {
		return id;
	}

	/**
	* @param id the photo_id
	*/
	public void setId(String id) {
		this.id = id;
	}
}
",package com.flickr4java.flickr.photos.geo; public class GeoPermissions { private static final long serialVersionUID = 12L; private boolean pub; private boolean contact; private boolean friend; private boolean family; private String id; public boolean isContact() { return contact; } public void setContact(boolean enable) { this.contact = enable; } public boolean isFamily() { return family; } public void setFamily(boolean enable) { this.family = enable; } public boolean isFriend() { return friend; } public void setFriend(boolean enable) { this.friend = enable; } public boolean isPublic() { return pub; } public void setPublic(boolean enable) { this.pub = enable; } public String getId() { return id; } public void setId(String id) { this.id = id; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.photos.geo; public class GeoPermissions { private static final long serialVersionUID = 12L; private boolean pub; private boolean contact; private boolean friend; private boolean family; private String id; public boolean isContact() { return contact; } public void setContact(boolean enable) { this.contact = enable; } public boolean isFamily() { return family; } public void setFamily(boolean enable) { this.family = enable; } public boolean isFriend() { return friend; } public void setFriend(boolean enable) { this.friend = enable; } public boolean isPublic() { return pub; } public void setPublic(boolean enable) { this.pub = enable; } public String getId() { return id; } public void setId(String id) { this.id = id; } } ,"package com.flickr4java.flickr.photos.geo;  /**
 * Simple encapsulation of viewing permissions for geo data.
 * 
 * @author till (Till Krech - flickr:extranoise)
 * 
 */ public class GeoPermissions { private static final long serialVersionUID = 12L;  private boolean pub;  private boolean contact;  private boolean friend;  private boolean family;      private String id;  /**
     * @return true if contacts may see the geo data
     */ public boolean isContact() { return contact; }  /**
     * enables / disables viewing of geo data by contacs.
     * 
     * @param enable
     *            true enables / false diables
     */ public void setContact(boolean enable) { this.contact = enable; }  /**
     * @return true if ""family members"" may see the geo data
     */ public boolean isFamily() { return family; }  /**
     * enables / disables viewing of geo data by ""family members"".
     * 
     * @param enable
     *            true enables / false diables
     */ public void setFamily(boolean enable) { this.family = enable; }  /**
     * @return true if ""friends"" may see the geo data
     */ public boolean isFriend() { return friend; }  /**
     * enables / disables viewing of geo data by ""friends"".
     * 
     * @param enable
     *            true enables / false diables
     */ public void setFriend(boolean enable) { this.friend = enable; }  /**
     * @return true if anyone may see the geo data
     */ public boolean isPublic() { return pub; }  /**
     * enables / disables viewing of geo data by any one.
     * 
     * @param enable
     *            true enables / false diables
     */ public void setPublic(boolean enable) { this.pub = enable; }      /**
	 * @return the the photo_id
	 */ public String getId() { return id; }  /**
	* @param id the photo_id
	*/ public void setId(String id) { this.id = id; } }  "
src/main/java/com/flickr4java/flickr/photos/licenses/License.java,"

package com.flickr4java.flickr.photos.licenses;

/**
 * @author Anthony Eden
 */
public class License {
    private static final long serialVersionUID = 12L;

    private String id;

    private String name;

    private String url;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

}
",package com.flickr4java.flickr.photos.licenses; public class License { private static final long serialVersionUID = 12L; private String id; private String name; private String url; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.photos.licenses; public class License { private static final long serialVersionUID = 12L; private String id; private String name; private String url; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } } ,"
 package com.flickr4java.flickr.photos.licenses;  /**
 * @author Anthony Eden
 */ public class License { private static final long serialVersionUID = 12L;  private String id;  private String name;  private String url;  public String getId() { return id; }  public void setId(String id) { this.id = id; }  public String getName() { return name; }  public void setName(String name) { this.name = name; }  public String getUrl() { return url; }  public void setUrl(String url) { this.url = url; }  }  "
src/main/java/com/flickr4java/flickr/photos/licenses/LicensesInterface.java,"

package com.flickr4java.flickr.photos.licenses;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Interface for working with copyright licenses.
 * 
 * @author Anthony Eden
 */
public class LicensesInterface {

    public static final String METHOD_GET_INFO = ""flickr.photos.licenses.getInfo"";

    public static final String METHOD_SET_LICENSE = ""flickr.photos.licenses.setLicense"";

    private String apiKey;

    private String sharedSecret;

    private Transport transportAPI;

    public LicensesInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transportAPI;
    }

    /**
     * Fetches a list of available photo licenses for Flickr.
     * 
     * This method does not require authentication.
     * 
     * @return A collection of License objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public Collection<License> getInfo() throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_INFO);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        List<License> licenses = new ArrayList<License>();
        Element licensesElement = response.getPayload();
        NodeList licenseElements = licensesElement.getElementsByTagName(""license"");
        for (int i = 0; i < licenseElements.getLength(); i++) {
            Element licenseElement = (Element) licenseElements.item(i);
            License license = new License();
            license.setId(licenseElement.getAttribute(""id""));
            license.setName(licenseElement.getAttribute(""name""));
            license.setUrl(licenseElement.getAttribute(""url""));
            licenses.add(license);
        }
        return licenses;
    }

    /**
     * Sets the license for a photo.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param photoId
     *            The photo to update the license for.
     * @param licenseId
     *            The license to apply, or 0 (zero) to remove the current license.
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void setLicense(String photoId, int licenseId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_SET_LICENSE);
        parameters.put(""photo_id"", photoId);
        parameters.put(""license_id"", Integer.toString(licenseId));

        // Note: This method requires an HTTP POST request.
        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        // This method has no specific response - It returns an empty sucess response if it completes without error.

    }

}
","package com.flickr4java.flickr.photos.licenses; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.List; import java.util.Map; public class LicensesInterface { public static final String METHOD_GET_INFO = ""flickr.photos.licenses.getInfo""; public static final String METHOD_SET_LICENSE = ""flickr.photos.licenses.setLicense""; private String apiKey; private String sharedSecret; private Transport transportAPI; public LicensesInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public Collection<License> getInfo() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } List<License> licenses = new ArrayList<License>(); Element licensesElement = response.getPayload(); NodeList licenseElements = licensesElement.getElementsByTagName(""license""); for (int i = 0; i < licenseElements.getLength(); i++) { Element licenseElement = (Element) licenseElements.item(i); License license = new License(); license.setId(licenseElement.getAttribute(""id"")); license.setName(licenseElement.getAttribute(""name"")); license.setUrl(licenseElement.getAttribute(""url"")); licenses.add(license); } return licenses; } public void setLicense(String photoId, int licenseId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_LICENSE); parameters.put(""photo_id"", photoId); parameters.put(""license_id"", Integer.toString(licenseId)); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.photos.licenses; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.List; import java.util.Map; public class LicensesInterface { public static final String METHOD_GET_INFO = ""flickr.photos.licenses.getInfo""; public static final String METHOD_SET_LICENSE = ""flickr.photos.licenses.setLicense""; private String apiKey; private String sharedSecret; private Transport transportAPI; public LicensesInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public Collection<License> getInfo() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } List<License> licenses = new ArrayList<License>(); Element licensesElement = response.getPayload(); NodeList licenseElements = licensesElement.getElementsByTagName(""license""); for (int i = 0; i < licenseElements.getLength(); i++) { Element licenseElement = (Element) licenseElements.item(i); License license = new License(); license.setId(licenseElement.getAttribute(""id"")); license.setName(licenseElement.getAttribute(""name"")); license.setUrl(licenseElement.getAttribute(""url"")); licenses.add(license); } return licenses; } public void setLicense(String photoId, int licenseId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_LICENSE); parameters.put(""photo_id"", photoId); parameters.put(""license_id"", Integer.toString(licenseId)); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } } ","
 package com.flickr4java.flickr.photos.licenses;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport;  import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.List; import java.util.Map;  /**
 * Interface for working with copyright licenses.
 * 
 * @author Anthony Eden
 */ public class LicensesInterface {  public static final String METHOD_GET_INFO = ""flickr.photos.licenses.getInfo"";  public static final String METHOD_SET_LICENSE = ""flickr.photos.licenses.setLicense"";  private String apiKey;  private String sharedSecret;  private Transport transportAPI;  public LicensesInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; }  /**
     * Fetches a list of available photo licenses for Flickr.
     * 
     * This method does not require authentication.
     * 
     * @return A collection of License objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public Collection<License> getInfo() throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_INFO);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } List<License> licenses = new ArrayList<License>(); Element licensesElement = response.getPayload(); NodeList licenseElements = licensesElement.getElementsByTagName(""license""); for (int i = 0; i < licenseElements.getLength(); i++) { Element licenseElement = (Element) licenseElements.item(i); License license = new License(); license.setId(licenseElement.getAttribute(""id"")); license.setName(licenseElement.getAttribute(""name"")); license.setUrl(licenseElement.getAttribute(""url"")); licenses.add(license); } return licenses; }  /**
     * Sets the license for a photo.
     * 
     * This method requires authentication with 'write' permission.
     * 
     * @param photoId
     *            The photo to update the license for.
     * @param licenseId
     *            The license to apply, or 0 (zero) to remove the current license.
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void setLicense(String photoId, int licenseId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SET_LICENSE); parameters.put(""photo_id"", photoId); parameters.put(""license_id"", Integer.toString(licenseId));  // Note: This method requires an HTTP POST request. Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } // This method has no specific response - It returns an empty sucess response if it completes without error.  }  }  "
src/main/java/com/flickr4java/flickr/photos/notes/NotesInterface.java,"

package com.flickr4java.flickr.photos.notes;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.photos.Note;

import org.w3c.dom.Element;

import java.awt.Rectangle;
import java.util.HashMap;
import java.util.Map;

/**
 * @author Anthony Eden
 */
public class NotesInterface {

    public static final String METHOD_ADD = ""flickr.photos.notes.add"";

    public static final String METHOD_DELETE = ""flickr.photos.notes.delete"";

    public static final String METHOD_EDIT = ""flickr.photos.notes.edit"";

    private String apiKey;

    private String sharedSecret;

    private Transport transportAPI;

    public NotesInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transportAPI;
    }

    /**
     * Add a note to a photo. The Note object bounds and text must be specified.
     * 
     * @param photoId
     *            The photo ID
     * @param note
     *            The Note object
     * @return The updated Note object
     */
    public Note add(String photoId, Note note) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_ADD);

        parameters.put(""photo_id"", photoId);
        Rectangle bounds = note.getBounds();
        if (bounds != null) {
            parameters.put(""note_x"", String.valueOf(bounds.x));
            parameters.put(""note_y"", String.valueOf(bounds.y));
            parameters.put(""note_w"", String.valueOf(bounds.width));
            parameters.put(""note_h"", String.valueOf(bounds.height));
        }
        String text = note.getText();
        if (text != null) {
            parameters.put(""note_text"", text);
        }

        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element noteElement = response.getPayload();
        note.setId(noteElement.getAttribute(""id""));
        return note;
    }

    /**
     * Delete the specified note.
     * 
     * @param noteId
     *            The node ID
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void delete(String noteId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_DELETE);

        parameters.put(""note_id"", noteId);

        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Update a note.
     * 
     * @param note
     *            The Note to update
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void edit(Note note) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_EDIT);

        parameters.put(""note_id"", note.getId());
        Rectangle bounds = note.getBounds();
        if (bounds != null) {
            parameters.put(""note_x"", String.valueOf(bounds.x));
            parameters.put(""note_y"", String.valueOf(bounds.y));
            parameters.put(""note_w"", String.valueOf(bounds.width));
            parameters.put(""note_h"", String.valueOf(bounds.height));
        }
        String text = note.getText();
        if (text != null) {
            parameters.put(""note_text"", text);
        }

        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

}
","package com.flickr4java.flickr.photos.notes; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.Note; import org.w3c.dom.Element; import java.awt.Rectangle; import java.util.HashMap; import java.util.Map; public class NotesInterface { public static final String METHOD_ADD = ""flickr.photos.notes.add""; public static final String METHOD_DELETE = ""flickr.photos.notes.delete""; public static final String METHOD_EDIT = ""flickr.photos.notes.edit""; private String apiKey; private String sharedSecret; private Transport transportAPI; public NotesInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public Note add(String photoId, Note note) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD); parameters.put(""photo_id"", photoId); Rectangle bounds = note.getBounds(); if (bounds != null) { parameters.put(""note_x"", String.valueOf(bounds.x)); parameters.put(""note_y"", String.valueOf(bounds.y)); parameters.put(""note_w"", String.valueOf(bounds.width)); parameters.put(""note_h"", String.valueOf(bounds.height)); } String text = note.getText(); if (text != null) { parameters.put(""note_text"", text); } Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element noteElement = response.getPayload(); note.setId(noteElement.getAttribute(""id"")); return note; } public void delete(String noteId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_DELETE); parameters.put(""note_id"", noteId); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void edit(Note note) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT); parameters.put(""note_id"", note.getId()); Rectangle bounds = note.getBounds(); if (bounds != null) { parameters.put(""note_x"", String.valueOf(bounds.x)); parameters.put(""note_y"", String.valueOf(bounds.y)); parameters.put(""note_w"", String.valueOf(bounds.width)); parameters.put(""note_h"", String.valueOf(bounds.height)); } String text = note.getText(); if (text != null) { parameters.put(""note_text"", text); } Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.photos.notes; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.Note; import org.w3c.dom.Element; import java.awt.Rectangle; import java.util.HashMap; import java.util.Map; public class NotesInterface { public static final String METHOD_ADD = ""flickr.photos.notes.add""; public static final String METHOD_DELETE = ""flickr.photos.notes.delete""; public static final String METHOD_EDIT = ""flickr.photos.notes.edit""; private String apiKey; private String sharedSecret; private Transport transportAPI; public NotesInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public Note add(String photoId, Note note) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD); parameters.put(""photo_id"", photoId); Rectangle bounds = note.getBounds(); if (bounds != null) { parameters.put(""note_x"", String.valueOf(bounds.x)); parameters.put(""note_y"", String.valueOf(bounds.y)); parameters.put(""note_w"", String.valueOf(bounds.width)); parameters.put(""note_h"", String.valueOf(bounds.height)); } String text = note.getText(); if (text != null) { parameters.put(""note_text"", text); } Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element noteElement = response.getPayload(); note.setId(noteElement.getAttribute(""id"")); return note; } public void delete(String noteId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_DELETE); parameters.put(""note_id"", noteId); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void edit(Note note) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT); parameters.put(""note_id"", note.getId()); Rectangle bounds = note.getBounds(); if (bounds != null) { parameters.put(""note_x"", String.valueOf(bounds.x)); parameters.put(""note_y"", String.valueOf(bounds.y)); parameters.put(""note_w"", String.valueOf(bounds.width)); parameters.put(""note_h"", String.valueOf(bounds.height)); } String text = note.getText(); if (text != null) { parameters.put(""note_text"", text); } Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } } ","
 package com.flickr4java.flickr.photos.notes;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.Note;  import org.w3c.dom.Element;  import java.awt.Rectangle; import java.util.HashMap; import java.util.Map;  /**
 * @author Anthony Eden
 */ public class NotesInterface {  public static final String METHOD_ADD = ""flickr.photos.notes.add"";  public static final String METHOD_DELETE = ""flickr.photos.notes.delete"";  public static final String METHOD_EDIT = ""flickr.photos.notes.edit"";  private String apiKey;  private String sharedSecret;  private Transport transportAPI;  public NotesInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; }  /**
     * Add a note to a photo. The Note object bounds and text must be specified.
     * 
     * @param photoId
     *            The photo ID
     * @param note
     *            The Note object
     * @return The updated Note object
     */ public Note add(String photoId, Note note) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD);  parameters.put(""photo_id"", photoId); Rectangle bounds = note.getBounds(); if (bounds != null) { parameters.put(""note_x"", String.valueOf(bounds.x)); parameters.put(""note_y"", String.valueOf(bounds.y)); parameters.put(""note_w"", String.valueOf(bounds.width)); parameters.put(""note_h"", String.valueOf(bounds.height)); } String text = note.getText(); if (text != null) { parameters.put(""note_text"", text); }  Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element noteElement = response.getPayload(); note.setId(noteElement.getAttribute(""id"")); return note; }  /**
     * Delete the specified note.
     * 
     * @param noteId
     *            The node ID
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void delete(String noteId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_DELETE);  parameters.put(""note_id"", noteId);  Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Update a note.
     * 
     * @param note
     *            The Note to update
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void edit(Note note) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT);  parameters.put(""note_id"", note.getId()); Rectangle bounds = note.getBounds(); if (bounds != null) { parameters.put(""note_x"", String.valueOf(bounds.x)); parameters.put(""note_y"", String.valueOf(bounds.y)); parameters.put(""note_w"", String.valueOf(bounds.width)); parameters.put(""note_h"", String.valueOf(bounds.height)); } String text = note.getText(); if (text != null) { parameters.put(""note_text"", text); }  Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  }  "
src/main/java/com/flickr4java/flickr/photos/people/PeopleInterface.java,"/**
 * @author acaplan
 */
package com.flickr4java.flickr.photos.people;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.people.PersonTag;
import com.flickr4java.flickr.people.PersonTagList;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.awt.Rectangle;
import java.util.HashMap;
import java.util.Map;

/**
 * @author acaplan
 * 
 */
public class PeopleInterface {

    private String apiKey;

    private String sharedSecret;

    private Transport transportAPI;

    public PeopleInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transportAPI;
    }

    public static final String METHOD_ADD = ""flickr.photos.people.add"";

    public static final String METHOD_DELETE = ""flickr.photos.people.delete"";

    public static final String METHOD_DELETE_COORDS = ""flickr.photos.people.deleteCoords"";

    public static final String METHOD_EDIT_COORDS = ""flickr.photos.people.editCoords"";

    public static final String METHOD_GET_LIST = ""flickr.photos.people.getList"";

    /**
     * Add the given person to the photo. Optionally, send in co-ordinates
     * 
     * @param photoId
     * @param userId
     * @param bounds
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void add(String photoId, String userId, Rectangle bounds) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_ADD);

        parameters.put(""photo_id"", photoId);
        parameters.put(""user_id"", userId);
        if (bounds != null) {
            parameters.put(""person_x"", bounds.x);
            parameters.put(""person_y"", bounds.y);
            parameters.put(""person_w"", bounds.width);
            parameters.put(""person_h"", bounds.height);
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Delete the person from the photo
     * 
     * @param photoId
     * @param userId
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void delete(String photoId, String userId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_DELETE);

        parameters.put(""photo_id"", photoId);
        parameters.put(""user_id"", userId);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Delete the co-ordinates that the user is shown in
     * 
     * @param photoId
     * @param userId
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void deleteCoords(String photoId, String userId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_DELETE_COORDS);

        parameters.put(""photo_id"", photoId);
        parameters.put(""user_id"", userId);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    /**
     * Edit the co-ordinates that the user shows in
     * 
     * @param photoId
     * @param userId
     * @param bounds
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void editCoords(String photoId, String userId, Rectangle bounds) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_EDIT_COORDS);

        parameters.put(""photo_id"", photoId);
        parameters.put(""user_id"", userId);
        parameters.put(""person_x"", bounds.x);
        parameters.put(""person_y"", bounds.y);
        parameters.put(""person_w"", bounds.width);
        parameters.put(""person_h"", bounds.height);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    	public PersonTagList<PersonTag> getList(String photoId) throws FlickrException{
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_LIST);

        parameters.put(""photo_id"", photoId);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        // @TODO this isn't a complete list ...
        Element usersElement = response.getPayload();
        PersonTagList<PersonTag> pt = new PersonTagList<PersonTag>();
        pt.setTotal(Integer.parseInt(usersElement.getAttribute(""total"")));
        pt.setHeight(Integer.parseInt(usersElement.getAttribute(""photo_height"")));
        pt.setWidth(Integer.parseInt(usersElement.getAttribute(""photo_width"")));
        NodeList usernodes = usersElement.getElementsByTagName(""person"");
        for (int i = 0; i < usernodes.getLength(); i++) {
            Element userElement = (Element) usernodes.item(i);

            PersonTag user = new PersonTag();
            user.setId(userElement.getAttribute(""nsid""));
            user.setUsername(userElement.getAttribute(""username""));
            user.setIconFarm(Integer.parseInt(userElement.getAttribute(""iconfarm"")));
            user.setIconServer(Integer.parseInt(userElement.getAttribute(""iconserver"")));
            user.setRealName(userElement.getAttribute(""realname""));
            user.setAddedById(userElement.getAttribute(""added_by""));
            user.setPathAlias(userElement.getAttribute(""path_alias""));
            if(!userElement.getAttribute(""x"").equals("""")){
	            user.setX(Integer.parseInt(userElement.getAttribute(""x"")));
	            user.setY(Integer.parseInt(userElement.getAttribute(""y"")));
	            user.setW(Integer.parseInt(userElement.getAttribute(""w"")));
	            user.setH(Integer.parseInt(userElement.getAttribute(""h"")));
            }
        }
        return pt;

    }
}
","package com.flickr4java.flickr.photos.people; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.people.PersonTag; import com.flickr4java.flickr.people.PersonTagList; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.awt.Rectangle; import java.util.HashMap; import java.util.Map; public class PeopleInterface { private String apiKey; private String sharedSecret; private Transport transportAPI; public PeopleInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public static final String METHOD_ADD = ""flickr.photos.people.add""; public static final String METHOD_DELETE = ""flickr.photos.people.delete""; public static final String METHOD_DELETE_COORDS = ""flickr.photos.people.deleteCoords""; public static final String METHOD_EDIT_COORDS = ""flickr.photos.people.editCoords""; public static final String METHOD_GET_LIST = ""flickr.photos.people.getList""; public void add(String photoId, String userId, Rectangle bounds) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD); parameters.put(""photo_id"", photoId); parameters.put(""user_id"", userId); if (bounds != null) { parameters.put(""person_x"", bounds.x); parameters.put(""person_y"", bounds.y); parameters.put(""person_w"", bounds.width); parameters.put(""person_h"", bounds.height); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void delete(String photoId, String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_DELETE); parameters.put(""photo_id"", photoId); parameters.put(""user_id"", userId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void deleteCoords(String photoId, String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_DELETE_COORDS); parameters.put(""photo_id"", photoId); parameters.put(""user_id"", userId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void editCoords(String photoId, String userId, Rectangle bounds) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT_COORDS); parameters.put(""photo_id"", photoId); parameters.put(""user_id"", userId); parameters.put(""person_x"", bounds.x); parameters.put(""person_y"", bounds.y); parameters.put(""person_w"", bounds.width); parameters.put(""person_h"", bounds.height); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public PersonTagList<PersonTag> getList(String photoId) throws FlickrException{ Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); parameters.put(""photo_id"", photoId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element usersElement = response.getPayload(); PersonTagList<PersonTag> pt = new PersonTagList<PersonTag>(); pt.setTotal(Integer.parseInt(usersElement.getAttribute(""total""))); pt.setHeight(Integer.parseInt(usersElement.getAttribute(""photo_height""))); pt.setWidth(Integer.parseInt(usersElement.getAttribute(""photo_width""))); NodeList usernodes = usersElement.getElementsByTagName(""person""); for (int i = 0; i < usernodes.getLength(); i++) { Element userElement = (Element) usernodes.item(i); PersonTag user = new PersonTag(); user.setId(userElement.getAttribute(""nsid"")); user.setUsername(userElement.getAttribute(""username"")); user.setIconFarm(Integer.parseInt(userElement.getAttribute(""iconfarm""))); user.setIconServer(Integer.parseInt(userElement.getAttribute(""iconserver""))); user.setRealName(userElement.getAttribute(""realname"")); user.setAddedById(userElement.getAttribute(""added_by"")); user.setPathAlias(userElement.getAttribute(""path_alias"")); if(!userElement.getAttribute(""x"").equals("""")){ user.setX(Integer.parseInt(userElement.getAttribute(""x""))); user.setY(Integer.parseInt(userElement.getAttribute(""y""))); user.setW(Integer.parseInt(userElement.getAttribute(""w""))); user.setH(Integer.parseInt(userElement.getAttribute(""h""))); } } return pt; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.photos.people; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.people.PersonTag; import com.flickr4java.flickr.people.PersonTagList; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.awt.Rectangle; import java.util.HashMap; import java.util.Map; public class PeopleInterface { private String apiKey; private String sharedSecret; private Transport transportAPI; public PeopleInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public static final String METHOD_ADD = ""flickr.photos.people.add""; public static final String METHOD_DELETE = ""flickr.photos.people.delete""; public static final String METHOD_DELETE_COORDS = ""flickr.photos.people.deleteCoords""; public static final String METHOD_EDIT_COORDS = ""flickr.photos.people.editCoords""; public static final String METHOD_GET_LIST = ""flickr.photos.people.getList""; public void add(String photoId, String userId, Rectangle bounds) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD); parameters.put(""photo_id"", photoId); parameters.put(""user_id"", userId); if (bounds != null) { parameters.put(""person_x"", bounds.x); parameters.put(""person_y"", bounds.y); parameters.put(""person_w"", bounds.width); parameters.put(""person_h"", bounds.height); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void delete(String photoId, String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_DELETE); parameters.put(""photo_id"", photoId); parameters.put(""user_id"", userId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void deleteCoords(String photoId, String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_DELETE_COORDS); parameters.put(""photo_id"", photoId); parameters.put(""user_id"", userId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void editCoords(String photoId, String userId, Rectangle bounds) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT_COORDS); parameters.put(""photo_id"", photoId); parameters.put(""user_id"", userId); parameters.put(""person_x"", bounds.x); parameters.put(""person_y"", bounds.y); parameters.put(""person_w"", bounds.width); parameters.put(""person_h"", bounds.height); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public PersonTagList<PersonTag> getList(String photoId) throws FlickrException{ Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); parameters.put(""photo_id"", photoId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element usersElement = response.getPayload(); PersonTagList<PersonTag> pt = new PersonTagList<PersonTag>(); pt.setTotal(Integer.parseInt(usersElement.getAttribute(""total""))); pt.setHeight(Integer.parseInt(usersElement.getAttribute(""photo_height""))); pt.setWidth(Integer.parseInt(usersElement.getAttribute(""photo_width""))); NodeList usernodes = usersElement.getElementsByTagName(""person""); for (int i = 0; i < usernodes.getLength(); i++) { Element userElement = (Element) usernodes.item(i); PersonTag user = new PersonTag(); user.setId(userElement.getAttribute(""nsid"")); user.setUsername(userElement.getAttribute(""username"")); user.setIconFarm(Integer.parseInt(userElement.getAttribute(""iconfarm""))); user.setIconServer(Integer.parseInt(userElement.getAttribute(""iconserver""))); user.setRealName(userElement.getAttribute(""realname"")); user.setAddedById(userElement.getAttribute(""added_by"")); user.setPathAlias(userElement.getAttribute(""path_alias"")); if(!userElement.getAttribute(""x"").equals("""")){ user.setX(Integer.parseInt(userElement.getAttribute(""x""))); user.setY(Integer.parseInt(userElement.getAttribute(""y""))); user.setW(Integer.parseInt(userElement.getAttribute(""w""))); user.setH(Integer.parseInt(userElement.getAttribute(""h""))); } } return pt; } } ","/**
 * @author acaplan
 */ package com.flickr4java.flickr.photos.people;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.people.PersonTag; import com.flickr4java.flickr.people.PersonTagList;  import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import java.awt.Rectangle; import java.util.HashMap; import java.util.Map;  /**
 * @author acaplan
 * 
 */ public class PeopleInterface {  private String apiKey;  private String sharedSecret;  private Transport transportAPI;  public PeopleInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; }  public static final String METHOD_ADD = ""flickr.photos.people.add"";  public static final String METHOD_DELETE = ""flickr.photos.people.delete"";  public static final String METHOD_DELETE_COORDS = ""flickr.photos.people.deleteCoords"";  public static final String METHOD_EDIT_COORDS = ""flickr.photos.people.editCoords"";  public static final String METHOD_GET_LIST = ""flickr.photos.people.getList"";  /**
     * Add the given person to the photo. Optionally, send in co-ordinates
     * 
     * @param photoId
     * @param userId
     * @param bounds
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void add(String photoId, String userId, Rectangle bounds) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD);  parameters.put(""photo_id"", photoId); parameters.put(""user_id"", userId); if (bounds != null) { parameters.put(""person_x"", bounds.x); parameters.put(""person_y"", bounds.y); parameters.put(""person_w"", bounds.width); parameters.put(""person_h"", bounds.height); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Delete the person from the photo
     * 
     * @param photoId
     * @param userId
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void delete(String photoId, String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_DELETE);  parameters.put(""photo_id"", photoId); parameters.put(""user_id"", userId);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Delete the co-ordinates that the user is shown in
     * 
     * @param photoId
     * @param userId
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void deleteCoords(String photoId, String userId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_DELETE_COORDS);  parameters.put(""photo_id"", photoId); parameters.put(""user_id"", userId);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  /**
     * Edit the co-ordinates that the user shows in
     * 
     * @param photoId
     * @param userId
     * @param bounds
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void editCoords(String photoId, String userId, Rectangle bounds) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT_COORDS);  parameters.put(""photo_id"", photoId); parameters.put(""user_id"", userId); parameters.put(""person_x"", bounds.x); parameters.put(""person_y"", bounds.y); parameters.put(""person_w"", bounds.width); parameters.put(""person_h"", bounds.height);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  public PersonTagList<PersonTag> getList(String photoId) throws FlickrException{ Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST);  parameters.put(""photo_id"", photoId);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  // @TODO this isn't a complete list ... Element usersElement = response.getPayload(); PersonTagList<PersonTag> pt = new PersonTagList<PersonTag>(); pt.setTotal(Integer.parseInt(usersElement.getAttribute(""total""))); pt.setHeight(Integer.parseInt(usersElement.getAttribute(""photo_height""))); pt.setWidth(Integer.parseInt(usersElement.getAttribute(""photo_width""))); NodeList usernodes = usersElement.getElementsByTagName(""person""); for (int i = 0; i < usernodes.getLength(); i++) { Element userElement = (Element) usernodes.item(i);  PersonTag user = new PersonTag(); user.setId(userElement.getAttribute(""nsid"")); user.setUsername(userElement.getAttribute(""username"")); user.setIconFarm(Integer.parseInt(userElement.getAttribute(""iconfarm""))); user.setIconServer(Integer.parseInt(userElement.getAttribute(""iconserver""))); user.setRealName(userElement.getAttribute(""realname"")); user.setAddedById(userElement.getAttribute(""added_by"")); user.setPathAlias(userElement.getAttribute(""path_alias"")); if(!userElement.getAttribute(""x"").equals("""")){ user.setX(Integer.parseInt(userElement.getAttribute(""x""))); user.setY(Integer.parseInt(userElement.getAttribute(""y""))); user.setW(Integer.parseInt(userElement.getAttribute(""w""))); user.setH(Integer.parseInt(userElement.getAttribute(""h""))); } } return pt;  } }  "
src/main/java/com/flickr4java/flickr/photos/suggestions/Suggestion.java,"package com.flickr4java.flickr.photos.suggestions;

import com.flickr4java.flickr.places.Location;

public class Suggestion {
	
	private String suggestionId;
	private String photoId;
	private String dateSuggested;
	private String suggestorId;
	private String suggestorUsername;
	private String note;
	private Location location;
	
	public String getSuggestionId() {
		return suggestionId;
	}
	public void setSuggestionId(String suggestionId) {
		this.suggestionId = suggestionId;
	}
	public String getPhotoId() {
		return photoId;
	}
	public void setPhotoId(String photoId) {
		this.photoId = photoId;
	}
	public String getDateSuggested() {
		return dateSuggested;
	}
	public void setDateSuggested(String dateSuggested) {
		this.dateSuggested = dateSuggested;
	}
	public String getSuggestorId() {
		return suggestorId;
	}
	public void setSuggestorId(String suggestorId) {
		this.suggestorId = suggestorId;
	}
	public String getSuggestorUsername() {
		return suggestorUsername;
	}
	public void setSuggestorUsername(String suggestorUsername) {
		this.suggestorUsername = suggestorUsername;
	}
	public String getNote() {
		return note;
	}
	public void setNote(String note) {
		this.note = note;
	}
	public Location getLocation() {
		return location;
	}
	public void setLocation(Location location) {
		this.location = location;
	}

}
",package com.flickr4java.flickr.photos.suggestions; import com.flickr4java.flickr.places.Location; public class Suggestion { private String suggestionId; private String photoId; private String dateSuggested; private String suggestorId; private String suggestorUsername; private String note; private Location location; public String getSuggestionId() { return suggestionId; } public void setSuggestionId(String suggestionId) { this.suggestionId = suggestionId; } public String getPhotoId() { return photoId; } public void setPhotoId(String photoId) { this.photoId = photoId; } public String getDateSuggested() { return dateSuggested; } public void setDateSuggested(String dateSuggested) { this.dateSuggested = dateSuggested; } public String getSuggestorId() { return suggestorId; } public void setSuggestorId(String suggestorId) { this.suggestorId = suggestorId; } public String getSuggestorUsername() { return suggestorUsername; } public void setSuggestorUsername(String suggestorUsername) { this.suggestorUsername = suggestorUsername; } public String getNote() { return note; } public void setNote(String note) { this.note = note; } public Location getLocation() { return location; } public void setLocation(Location location) { this.location = location; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.photos.suggestions; import com.flickr4java.flickr.places.Location; public class Suggestion { private String suggestionId; private String photoId; private String dateSuggested; private String suggestorId; private String suggestorUsername; private String note; private Location location; public String getSuggestionId() { return suggestionId; } public void setSuggestionId(String suggestionId) { this.suggestionId = suggestionId; } public String getPhotoId() { return photoId; } public void setPhotoId(String photoId) { this.photoId = photoId; } public String getDateSuggested() { return dateSuggested; } public void setDateSuggested(String dateSuggested) { this.dateSuggested = dateSuggested; } public String getSuggestorId() { return suggestorId; } public void setSuggestorId(String suggestorId) { this.suggestorId = suggestorId; } public String getSuggestorUsername() { return suggestorUsername; } public void setSuggestorUsername(String suggestorUsername) { this.suggestorUsername = suggestorUsername; } public String getNote() { return note; } public void setNote(String note) { this.note = note; } public Location getLocation() { return location; } public void setLocation(Location location) { this.location = location; } } ,package com.flickr4java.flickr.photos.suggestions;  import com.flickr4java.flickr.places.Location;  public class Suggestion { 	 private String suggestionId; private String photoId; private String dateSuggested; private String suggestorId; private String suggestorUsername; private String note; private Location location; 	 public String getSuggestionId() { return suggestionId; } public void setSuggestionId(String suggestionId) { this.suggestionId = suggestionId; } public String getPhotoId() { return photoId; } public void setPhotoId(String photoId) { this.photoId = photoId; } public String getDateSuggested() { return dateSuggested; } public void setDateSuggested(String dateSuggested) { this.dateSuggested = dateSuggested; } public String getSuggestorId() { return suggestorId; } public void setSuggestorId(String suggestorId) { this.suggestorId = suggestorId; } public String getSuggestorUsername() { return suggestorUsername; } public void setSuggestorUsername(String suggestorUsername) { this.suggestorUsername = suggestorUsername; } public String getNote() { return note; } public void setNote(String note) { this.note = note; } public Location getLocation() { return location; } public void setLocation(Location location) { this.location = location; }  }  
src/main/java/com/flickr4java/flickr/photos/suggestions/SuggestionList.java,"package com.flickr4java.flickr.photos.suggestions;

import java.util.ArrayList;

public class SuggestionList<E> extends ArrayList<Suggestion>{

	/**
	 * 
	 */
	private static final long serialVersionUID = -791184866429373856L;
	private int total;
	private int perPage;
	private int page;
	
	public int getTotal() {
		return total;
	}
	public void setTotal(int total) {
		this.total = total;
	}
	public int getPerPage() {
		return perPage;
	}
	public void setPerPage(int perPage) {
		this.perPage = perPage;
	}
	public int getPage() {
		return page;
	}
	public void setPage(int page) {
		this.page = page;
	}

}
",package com.flickr4java.flickr.photos.suggestions; import java.util.ArrayList; public class SuggestionList<E> extends ArrayList<Suggestion>{ private static final long serialVersionUID = -791184866429373856L; private int total; private int perPage; private int page; public int getTotal() { return total; } public void setTotal(int total) { this.total = total; } public int getPerPage() { return perPage; } public void setPerPage(int perPage) { this.perPage = perPage; } public int getPage() { return page; } public void setPage(int page) { this.page = page; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.photos.suggestions; import java.util.ArrayList; public class SuggestionList<E> extends ArrayList<Suggestion>{ private static final long serialVersionUID = -791184866429373856L; private int total; private int perPage; private int page; public int getTotal() { return total; } public void setTotal(int total) { this.total = total; } public int getPerPage() { return perPage; } public void setPerPage(int perPage) { this.perPage = perPage; } public int getPage() { return page; } public void setPage(int page) { this.page = page; } } ,"package com.flickr4java.flickr.photos.suggestions;  import java.util.ArrayList;  public class SuggestionList<E> extends ArrayList<Suggestion>{  /**
	 * 
	 */ private static final long serialVersionUID = -791184866429373856L; private int total; private int perPage; private int page; 	 public int getTotal() { return total; } public void setTotal(int total) { this.total = total; } public int getPerPage() { return perPage; } public void setPerPage(int perPage) { this.perPage = perPage; } public int getPage() { return page; } public void setPage(int page) { this.page = page; }  }  "
src/main/java/com/flickr4java/flickr/photos/suggestions/SuggestionsInterface.java,"/**
 * @author acaplan
 */
package com.flickr4java.flickr.photos.suggestions;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import com.flickr4java.flickr.Flickr;
import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.groups.Group;
import com.flickr4java.flickr.groups.GroupList;
import com.flickr4java.flickr.places.Location;
import com.flickr4java.flickr.places.Place;
import com.flickr4java.flickr.util.XMLUtilities;

/**
 * @author acaplan
 * 
 */
public class SuggestionsInterface {

    public static final String METHOD_APPROVE_SUGGESTION = ""flickr.photos.suggestions.approveSuggestion"";

    public static final String METHOD_REJECT_SUGGESTION = ""flickr.photos.suggestions.rejectSuggestion"";

    public static final String METHOD_REMOVE_SUGGESTION = ""flickr.photos.suggestions.removeSuggestion"";

    public static final String METHOD_SUGGEST_LOCATION = ""flickr.photos.suggestions.suggestLocation"";

    public static final String METHOD_GET_LIST = ""flickr.photos.suggestions.getList"";

    private String apiKey;

    private String sharedSecret;

    private Transport transportAPI;

    public SuggestionsInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transportAPI;
    }

    public void approveSuggestion(String suggestionId) throws FlickrException {
        act(suggestionId, METHOD_APPROVE_SUGGESTION);
    }

    public void rejectSuggestion(String suggestionId) throws FlickrException {
        act(suggestionId, METHOD_REJECT_SUGGESTION);
    }

    public void removeSuggestion(String suggestionId) throws FlickrException {
        act(suggestionId, METHOD_REMOVE_SUGGESTION);
    }

    private void act(String suggestionId, String method) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", method);
        parameters.put(""suggestion_id"", suggestionId);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    public void suggestLocation(String photoId, double lat, double lon, int accuracy, String woe_id, String place_id, String note) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_SUGGEST_LOCATION);

        parameters.put(""photo_id"", photoId);
        parameters.put(""lat"", lat);
        parameters.put(""lon"", lon);
        if (accuracy > 0 && accuracy <= 16) {
            parameters.put(""accuracy"", accuracy);
        }
        if (woe_id != null) {
            parameters.put(""woe_id"", woe_id);
        }
        if (place_id != null) {
            parameters.put(""place_id"", place_id);
        }
        if (note != null) {
            parameters.put(""note"", note);
        }

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

    public SuggestionList<Suggestion> getList(String photoId) throws FlickrException {
    	SuggestionList<Suggestion> suggestionList = new SuggestionList<Suggestion>();
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_LIST);

        parameters.put(""photo_id"", photoId);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        Element suggestionsElement = response.getPayload();
        
        suggestionList.setPage(XMLUtilities.getIntAttribute(suggestionsElement, ""page""));
        suggestionList.setPerPage(XMLUtilities.getIntAttribute(suggestionsElement, ""perpage""));
        suggestionList.setTotal(XMLUtilities.getIntAttribute(suggestionsElement, ""total""));
        
        NodeList suggestionNodes = suggestionsElement.getElementsByTagName(""suggestion"");
        for (int i = 0; i < suggestionNodes.getLength(); i++) {
            Element suggestionElement = (Element) suggestionNodes.item(i);
            Suggestion suggestion = new Suggestion();
            suggestion.setSuggestionId(suggestionElement.getAttribute(""id""));
            suggestion.setPhotoId(suggestionElement.getAttribute(""photo_id""));
            suggestion.setDateSuggested(suggestionElement.getAttribute(""date_suggested""));
            suggestion.setNote(XMLUtilities.getChild(suggestionElement, ""note"").getTextContent());
            
            Element suggestedElement = XMLUtilities.getChild(suggestionElement, ""suggested_by"");
            suggestion.setSuggestorUsername(suggestedElement.getAttribute(""username""));
            suggestion.setSuggestorId(suggestedElement.getAttribute(""nsid""));
            
            Element locationElement = XMLUtilities.getChild(suggestionElement, ""location"");
            Location location = new Location();
            location.setLatitude(Double.parseDouble(locationElement.getAttribute(""latitude"")));
            location.setLongitude(Double.parseDouble(locationElement.getAttribute(""longitude"")));
            location.setWoeId(locationElement.getAttribute(""woeid""));
            location.setAccuracy(Integer.parseInt(locationElement.getAttribute(""accuracy"")));
            
            Element regionElement = XMLUtilities.getChild(locationElement, ""region"");
            if(regionElement != null){
	            Place placeReg = new Place();
	            placeReg.setPlaceId(regionElement.getAttribute(""place_id""));
	            placeReg.setWoeId(regionElement.getAttribute(""woeid""));
	            location.setRegion(placeReg);
            }
            
            Element countryElement = XMLUtilities.getChild(locationElement, ""country"");
            if(countryElement != null){
	            Place placeCtry = new Place();
	            placeCtry.setPlaceId(countryElement.getAttribute(""place_id""));
	            placeCtry.setWoeId(countryElement.getAttribute(""woeid""));
	            location.setCountry(placeCtry);
            }

            Element countyElement = XMLUtilities.getChild(locationElement, ""county"");
            if(countyElement != null){
	            Place placeCnty = new Place();
	            placeCnty.setPlaceId(countyElement.getAttribute(""place_id""));
	            placeCnty.setWoeId(countyElement.getAttribute(""woeid""));
	            location.setCounty(placeCnty);
            }
            
            suggestion.setLocation(location);
            suggestionList.add(suggestion);
        }
        return suggestionList;

    }

}
","package com.flickr4java.flickr.photos.suggestions; import java.util.HashMap; import java.util.List; import java.util.Map; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.groups.Group; import com.flickr4java.flickr.groups.GroupList; import com.flickr4java.flickr.places.Location; import com.flickr4java.flickr.places.Place; import com.flickr4java.flickr.util.XMLUtilities; public class SuggestionsInterface { public static final String METHOD_APPROVE_SUGGESTION = ""flickr.photos.suggestions.approveSuggestion""; public static final String METHOD_REJECT_SUGGESTION = ""flickr.photos.suggestions.rejectSuggestion""; public static final String METHOD_REMOVE_SUGGESTION = ""flickr.photos.suggestions.removeSuggestion""; public static final String METHOD_SUGGEST_LOCATION = ""flickr.photos.suggestions.suggestLocation""; public static final String METHOD_GET_LIST = ""flickr.photos.suggestions.getList""; private String apiKey; private String sharedSecret; private Transport transportAPI; public SuggestionsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public void approveSuggestion(String suggestionId) throws FlickrException { act(suggestionId, METHOD_APPROVE_SUGGESTION); } public void rejectSuggestion(String suggestionId) throws FlickrException { act(suggestionId, METHOD_REJECT_SUGGESTION); } public void removeSuggestion(String suggestionId) throws FlickrException { act(suggestionId, METHOD_REMOVE_SUGGESTION); } private void act(String suggestionId, String method) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", method); parameters.put(""suggestion_id"", suggestionId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void suggestLocation(String photoId, double lat, double lon, int accuracy, String woe_id, String place_id, String note) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SUGGEST_LOCATION); parameters.put(""photo_id"", photoId); parameters.put(""lat"", lat); parameters.put(""lon"", lon); if (accuracy > 0 && accuracy <= 16) { parameters.put(""accuracy"", accuracy); } if (woe_id != null) { parameters.put(""woe_id"", woe_id); } if (place_id != null) { parameters.put(""place_id"", place_id); } if (note != null) { parameters.put(""note"", note); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public SuggestionList<Suggestion> getList(String photoId) throws FlickrException { SuggestionList<Suggestion> suggestionList = new SuggestionList<Suggestion>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); parameters.put(""photo_id"", photoId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element suggestionsElement = response.getPayload(); suggestionList.setPage(XMLUtilities.getIntAttribute(suggestionsElement, ""page"")); suggestionList.setPerPage(XMLUtilities.getIntAttribute(suggestionsElement, ""perpage"")); suggestionList.setTotal(XMLUtilities.getIntAttribute(suggestionsElement, ""total"")); NodeList suggestionNodes = suggestionsElement.getElementsByTagName(""suggestion""); for (int i = 0; i < suggestionNodes.getLength(); i++) { Element suggestionElement = (Element) suggestionNodes.item(i); Suggestion suggestion = new Suggestion(); suggestion.setSuggestionId(suggestionElement.getAttribute(""id"")); suggestion.setPhotoId(suggestionElement.getAttribute(""photo_id"")); suggestion.setDateSuggested(suggestionElement.getAttribute(""date_suggested"")); suggestion.setNote(XMLUtilities.getChild(suggestionElement, ""note"").getTextContent()); Element suggestedElement = XMLUtilities.getChild(suggestionElement, ""suggested_by""); suggestion.setSuggestorUsername(suggestedElement.getAttribute(""username"")); suggestion.setSuggestorId(suggestedElement.getAttribute(""nsid"")); Element locationElement = XMLUtilities.getChild(suggestionElement, ""location""); Location location = new Location(); location.setLatitude(Double.parseDouble(locationElement.getAttribute(""latitude""))); location.setLongitude(Double.parseDouble(locationElement.getAttribute(""longitude""))); location.setWoeId(locationElement.getAttribute(""woeid"")); location.setAccuracy(Integer.parseInt(locationElement.getAttribute(""accuracy""))); Element regionElement = XMLUtilities.getChild(locationElement, ""region""); if(regionElement != null){ Place placeReg = new Place(); placeReg.setPlaceId(regionElement.getAttribute(""place_id"")); placeReg.setWoeId(regionElement.getAttribute(""woeid"")); location.setRegion(placeReg); } Element countryElement = XMLUtilities.getChild(locationElement, ""country""); if(countryElement != null){ Place placeCtry = new Place(); placeCtry.setPlaceId(countryElement.getAttribute(""place_id"")); placeCtry.setWoeId(countryElement.getAttribute(""woeid"")); location.setCountry(placeCtry); } Element countyElement = XMLUtilities.getChild(locationElement, ""county""); if(countyElement != null){ Place placeCnty = new Place(); placeCnty.setPlaceId(countyElement.getAttribute(""place_id"")); placeCnty.setWoeId(countyElement.getAttribute(""woeid"")); location.setCounty(placeCnty); } suggestion.setLocation(location); suggestionList.add(suggestion); } return suggestionList; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.photos.suggestions; import java.util.HashMap; import java.util.List; import java.util.Map; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.groups.Group; import com.flickr4java.flickr.groups.GroupList; import com.flickr4java.flickr.places.Location; import com.flickr4java.flickr.places.Place; import com.flickr4java.flickr.util.XMLUtilities; public class SuggestionsInterface { public static final String METHOD_APPROVE_SUGGESTION = ""flickr.photos.suggestions.approveSuggestion""; public static final String METHOD_REJECT_SUGGESTION = ""flickr.photos.suggestions.rejectSuggestion""; public static final String METHOD_REMOVE_SUGGESTION = ""flickr.photos.suggestions.removeSuggestion""; public static final String METHOD_SUGGEST_LOCATION = ""flickr.photos.suggestions.suggestLocation""; public static final String METHOD_GET_LIST = ""flickr.photos.suggestions.getList""; private String apiKey; private String sharedSecret; private Transport transportAPI; public SuggestionsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public void approveSuggestion(String suggestionId) throws FlickrException { act(suggestionId, METHOD_APPROVE_SUGGESTION); } public void rejectSuggestion(String suggestionId) throws FlickrException { act(suggestionId, METHOD_REJECT_SUGGESTION); } public void removeSuggestion(String suggestionId) throws FlickrException { act(suggestionId, METHOD_REMOVE_SUGGESTION); } private void act(String suggestionId, String method) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", method); parameters.put(""suggestion_id"", suggestionId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void suggestLocation(String photoId, double lat, double lon, int accuracy, String woe_id, String place_id, String note) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SUGGEST_LOCATION); parameters.put(""photo_id"", photoId); parameters.put(""lat"", lat); parameters.put(""lon"", lon); if (accuracy > 0 && accuracy <= 16) { parameters.put(""accuracy"", accuracy); } if (woe_id != null) { parameters.put(""woe_id"", woe_id); } if (place_id != null) { parameters.put(""place_id"", place_id); } if (note != null) { parameters.put(""note"", note); } Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public SuggestionList<Suggestion> getList(String photoId) throws FlickrException { SuggestionList<Suggestion> suggestionList = new SuggestionList<Suggestion>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); parameters.put(""photo_id"", photoId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element suggestionsElement = response.getPayload(); suggestionList.setPage(XMLUtilities.getIntAttribute(suggestionsElement, ""page"")); suggestionList.setPerPage(XMLUtilities.getIntAttribute(suggestionsElement, ""perpage"")); suggestionList.setTotal(XMLUtilities.getIntAttribute(suggestionsElement, ""total"")); NodeList suggestionNodes = suggestionsElement.getElementsByTagName(""suggestion""); for (int i = 0; i < suggestionNodes.getLength(); i++) { Element suggestionElement = (Element) suggestionNodes.item(i); Suggestion suggestion = new Suggestion(); suggestion.setSuggestionId(suggestionElement.getAttribute(""id"")); suggestion.setPhotoId(suggestionElement.getAttribute(""photo_id"")); suggestion.setDateSuggested(suggestionElement.getAttribute(""date_suggested"")); suggestion.setNote(XMLUtilities.getChild(suggestionElement, ""note"").getTextContent()); Element suggestedElement = XMLUtilities.getChild(suggestionElement, ""suggested_by""); suggestion.setSuggestorUsername(suggestedElement.getAttribute(""username"")); suggestion.setSuggestorId(suggestedElement.getAttribute(""nsid"")); Element locationElement = XMLUtilities.getChild(suggestionElement, ""location""); Location location = new Location(); location.setLatitude(Double.parseDouble(locationElement.getAttribute(""latitude""))); location.setLongitude(Double.parseDouble(locationElement.getAttribute(""longitude""))); location.setWoeId(locationElement.getAttribute(""woeid"")); location.setAccuracy(Integer.parseInt(locationElement.getAttribute(""accuracy""))); Element regionElement = XMLUtilities.getChild(locationElement, ""region""); if(regionElement != null){ Place placeReg = new Place(); placeReg.setPlaceId(regionElement.getAttribute(""place_id"")); placeReg.setWoeId(regionElement.getAttribute(""woeid"")); location.setRegion(placeReg); } Element countryElement = XMLUtilities.getChild(locationElement, ""country""); if(countryElement != null){ Place placeCtry = new Place(); placeCtry.setPlaceId(countryElement.getAttribute(""place_id"")); placeCtry.setWoeId(countryElement.getAttribute(""woeid"")); location.setCountry(placeCtry); } Element countyElement = XMLUtilities.getChild(locationElement, ""county""); if(countyElement != null){ Place placeCnty = new Place(); placeCnty.setPlaceId(countyElement.getAttribute(""place_id"")); placeCnty.setWoeId(countyElement.getAttribute(""woeid"")); location.setCounty(placeCnty); } suggestion.setLocation(location); suggestionList.add(suggestion); } return suggestionList; } } ","/**
 * @author acaplan
 */ package com.flickr4java.flickr.photos.suggestions;  import java.util.HashMap; import java.util.List; import java.util.Map;  import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.groups.Group; import com.flickr4java.flickr.groups.GroupList; import com.flickr4java.flickr.places.Location; import com.flickr4java.flickr.places.Place; import com.flickr4java.flickr.util.XMLUtilities;  /**
 * @author acaplan
 * 
 */ public class SuggestionsInterface {  public static final String METHOD_APPROVE_SUGGESTION = ""flickr.photos.suggestions.approveSuggestion"";  public static final String METHOD_REJECT_SUGGESTION = ""flickr.photos.suggestions.rejectSuggestion"";  public static final String METHOD_REMOVE_SUGGESTION = ""flickr.photos.suggestions.removeSuggestion"";  public static final String METHOD_SUGGEST_LOCATION = ""flickr.photos.suggestions.suggestLocation"";  public static final String METHOD_GET_LIST = ""flickr.photos.suggestions.getList"";  private String apiKey;  private String sharedSecret;  private Transport transportAPI;  public SuggestionsInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; }  public void approveSuggestion(String suggestionId) throws FlickrException { act(suggestionId, METHOD_APPROVE_SUGGESTION); }  public void rejectSuggestion(String suggestionId) throws FlickrException { act(suggestionId, METHOD_REJECT_SUGGESTION); }  public void removeSuggestion(String suggestionId) throws FlickrException { act(suggestionId, METHOD_REMOVE_SUGGESTION); }  private void act(String suggestionId, String method) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", method); parameters.put(""suggestion_id"", suggestionId);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  public void suggestLocation(String photoId, double lat, double lon, int accuracy, String woe_id, String place_id, String note) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_SUGGEST_LOCATION);  parameters.put(""photo_id"", photoId); parameters.put(""lat"", lat); parameters.put(""lon"", lon); if (accuracy > 0 && accuracy <= 16) { parameters.put(""accuracy"", accuracy); } if (woe_id != null) { parameters.put(""woe_id"", woe_id); } if (place_id != null) { parameters.put(""place_id"", place_id); } if (note != null) { parameters.put(""note"", note); }  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  public SuggestionList<Suggestion> getList(String photoId) throws FlickrException { SuggestionList<Suggestion> suggestionList = new SuggestionList<Suggestion>(); Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST);  parameters.put(""photo_id"", photoId);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  Element suggestionsElement = response.getPayload();          suggestionList.setPage(XMLUtilities.getIntAttribute(suggestionsElement, ""page"")); suggestionList.setPerPage(XMLUtilities.getIntAttribute(suggestionsElement, ""perpage"")); suggestionList.setTotal(XMLUtilities.getIntAttribute(suggestionsElement, ""total""));          NodeList suggestionNodes = suggestionsElement.getElementsByTagName(""suggestion""); for (int i = 0; i < suggestionNodes.getLength(); i++) { Element suggestionElement = (Element) suggestionNodes.item(i); Suggestion suggestion = new Suggestion(); suggestion.setSuggestionId(suggestionElement.getAttribute(""id"")); suggestion.setPhotoId(suggestionElement.getAttribute(""photo_id"")); suggestion.setDateSuggested(suggestionElement.getAttribute(""date_suggested"")); suggestion.setNote(XMLUtilities.getChild(suggestionElement, ""note"").getTextContent());              Element suggestedElement = XMLUtilities.getChild(suggestionElement, ""suggested_by""); suggestion.setSuggestorUsername(suggestedElement.getAttribute(""username"")); suggestion.setSuggestorId(suggestedElement.getAttribute(""nsid""));              Element locationElement = XMLUtilities.getChild(suggestionElement, ""location""); Location location = new Location(); location.setLatitude(Double.parseDouble(locationElement.getAttribute(""latitude""))); location.setLongitude(Double.parseDouble(locationElement.getAttribute(""longitude""))); location.setWoeId(locationElement.getAttribute(""woeid"")); location.setAccuracy(Integer.parseInt(locationElement.getAttribute(""accuracy"")));              Element regionElement = XMLUtilities.getChild(locationElement, ""region""); if(regionElement != null){ Place placeReg = new Place(); placeReg.setPlaceId(regionElement.getAttribute(""place_id"")); placeReg.setWoeId(regionElement.getAttribute(""woeid"")); location.setRegion(placeReg); }              Element countryElement = XMLUtilities.getChild(locationElement, ""country""); if(countryElement != null){ Place placeCtry = new Place(); placeCtry.setPlaceId(countryElement.getAttribute(""place_id"")); placeCtry.setWoeId(countryElement.getAttribute(""woeid"")); location.setCountry(placeCtry); }  Element countyElement = XMLUtilities.getChild(locationElement, ""county""); if(countyElement != null){ Place placeCnty = new Place(); placeCnty.setPlaceId(countyElement.getAttribute(""place_id"")); placeCnty.setWoeId(countyElement.getAttribute(""woeid"")); location.setCounty(placeCnty); }              suggestion.setLocation(location); suggestionList.add(suggestion); } return suggestionList;  }  }  "
src/main/java/com/flickr4java/flickr/photos/transform/TransformInterface.java,"

package com.flickr4java.flickr.photos.transform;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;

import java.util.HashMap;
import java.util.Map;

/**
 * @author Anthony Eden
 * @version $Id: TransformInterface.java,v 1.6 2008/01/28 23:01:44 x-mago Exp $
 */
public class TransformInterface {

    public static final String METHOD_ROTATE = ""flickr.photos.transform.rotate"";

    private String apiKey;

    private String sharedSecret;

    private Transport transportAPI;

    public TransformInterface(String apiKey, String sharedSecret, Transport transportAPI) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transportAPI;
    }

    /**
     * Rotate the specified photo. The only allowed values for degrees are 90, 180 and 270.
     * 
     * @param photoId
     *            The photo ID
     * @param degrees
     *            The degrees to rotate (90, 170 or 270)
     */
    public void rotate(String photoId, int degrees) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_ROTATE);

        parameters.put(""photo_id"", photoId);
        parameters.put(""degrees"", String.valueOf(degrees));

        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    }

}
","package com.flickr4java.flickr.photos.transform; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import java.util.HashMap; import java.util.Map; public class TransformInterface { public static final String METHOD_ROTATE = ""flickr.photos.transform.rotate""; private String apiKey; private String sharedSecret; private Transport transportAPI; public TransformInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public void rotate(String photoId, int degrees) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ROTATE); parameters.put(""photo_id"", photoId); parameters.put(""degrees"", String.valueOf(degrees)); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.photos.transform; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import java.util.HashMap; import java.util.Map; public class TransformInterface { public static final String METHOD_ROTATE = ""flickr.photos.transform.rotate""; private String apiKey; private String sharedSecret; private Transport transportAPI; public TransformInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; } public void rotate(String photoId, int degrees) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ROTATE); parameters.put(""photo_id"", photoId); parameters.put(""degrees"", String.valueOf(degrees)); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } } ","
 package com.flickr4java.flickr.photos.transform;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport;  import java.util.HashMap; import java.util.Map;  /**
 * @author Anthony Eden
 * @version $Id: TransformInterface.java,v 1.6 2008/01/28 23:01:44 x-mago Exp $
 */ public class TransformInterface {  public static final String METHOD_ROTATE = ""flickr.photos.transform.rotate"";  private String apiKey;  private String sharedSecret;  private Transport transportAPI;  public TransformInterface(String apiKey, String sharedSecret, Transport transportAPI) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transportAPI; }  /**
     * Rotate the specified photo. The only allowed values for degrees are 90, 180 and 270.
     * 
     * @param photoId
     *            The photo ID
     * @param degrees
     *            The degrees to rotate (90, 170 or 270)
     */ public void rotate(String photoId, int degrees) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ROTATE);  parameters.put(""photo_id"", photoId); parameters.put(""degrees"", String.valueOf(degrees));  Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } }  }  "
src/main/java/com/flickr4java/flickr/photos/upload/Ticket.java,"package com.flickr4java.flickr.photos.upload;

/**
 * Photo upload ticket.
 * <p>
 * The ticketId attribute contains the ticket id.<br>
 * If the ticket wasn't found, the invalid attribute is set.<br>
 * The status of the ticket is passed in the status attribute;
 * <p>
 * 0 means not completed,<br>
 * 1 means completed and<br>
 * 2 means the ticket failed (indicating there was a problem converting the file).
 * <p>
 * When the status is 1, the photo id is passed in the photoid attribute. The photo id can then be used as with the synchronous upload API.
 * 
 * @author till (Till Krech) extranoise:flickr
 * @version $Id: Ticket.java,v 1.2 2007/11/02 21:46:52 x-mago Exp $
 */
public class Ticket {
    public static final int UNCOMPLETED = 0;

    public static final int COMPLETED = 1;

    public static final int FAILED = 2;

    private String ticketId;

    private boolean invalid;

    private String photoId;

    private int status;

    public boolean isInvalid() {
        return invalid;
    }

    public void setInvalid(boolean invalid) {
        this.invalid = invalid;
    }

    public String getPhotoId() {
        return photoId;
    }

    public void setPhotoId(String photoId) {
        this.photoId = photoId;
    }

    public String getTicketId() {
        return ticketId;
    }

    public void setTicketId(String ticketId) {
        this.ticketId = ticketId;
    }

    public int getStatus() {
        return status;
    }

    public void setStatus(int complete) {
        this.status = complete;
    }

    public boolean hasCompleted() {
        return status == COMPLETED;
    }

    public boolean hasFailed() {
        return status == FAILED;
    }

    public boolean isBusy() {
        return status == UNCOMPLETED;
    }

}
",package com.flickr4java.flickr.photos.upload; public class Ticket { public static final int UNCOMPLETED = 0; public static final int COMPLETED = 1; public static final int FAILED = 2; private String ticketId; private boolean invalid; private String photoId; private int status; public boolean isInvalid() { return invalid; } public void setInvalid(boolean invalid) { this.invalid = invalid; } public String getPhotoId() { return photoId; } public void setPhotoId(String photoId) { this.photoId = photoId; } public String getTicketId() { return ticketId; } public void setTicketId(String ticketId) { this.ticketId = ticketId; } public int getStatus() { return status; } public void setStatus(int complete) { this.status = complete; } public boolean hasCompleted() { return status == COMPLETED; } public boolean hasFailed() { return status == FAILED; } public boolean isBusy() { return status == UNCOMPLETED; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.photos.upload; public class Ticket { public static final int UNCOMPLETED = 0; public static final int COMPLETED = 1; public static final int FAILED = 2; private String ticketId; private boolean invalid; private String photoId; private int status; public boolean isInvalid() { return invalid; } public void setInvalid(boolean invalid) { this.invalid = invalid; } public String getPhotoId() { return photoId; } public void setPhotoId(String photoId) { this.photoId = photoId; } public String getTicketId() { return ticketId; } public void setTicketId(String ticketId) { this.ticketId = ticketId; } public int getStatus() { return status; } public void setStatus(int complete) { this.status = complete; } public boolean hasCompleted() { return status == COMPLETED; } public boolean hasFailed() { return status == FAILED; } public boolean isBusy() { return status == UNCOMPLETED; } } ,"package com.flickr4java.flickr.photos.upload;  /**
 * Photo upload ticket.
 * <p>
 * The ticketId attribute contains the ticket id.<br>
 * If the ticket wasn't found, the invalid attribute is set.<br>
 * The status of the ticket is passed in the status attribute;
 * <p>
 * 0 means not completed,<br>
 * 1 means completed and<br>
 * 2 means the ticket failed (indicating there was a problem converting the file).
 * <p>
 * When the status is 1, the photo id is passed in the photoid attribute. The photo id can then be used as with the synchronous upload API.
 * 
 * @author till (Till Krech) extranoise:flickr
 * @version $Id: Ticket.java,v 1.2 2007/11/02 21:46:52 x-mago Exp $
 */ public class Ticket { public static final int UNCOMPLETED = 0;  public static final int COMPLETED = 1;  public static final int FAILED = 2;  private String ticketId;  private boolean invalid;  private String photoId;  private int status;  public boolean isInvalid() { return invalid; }  public void setInvalid(boolean invalid) { this.invalid = invalid; }  public String getPhotoId() { return photoId; }  public void setPhotoId(String photoId) { this.photoId = photoId; }  public String getTicketId() { return ticketId; }  public void setTicketId(String ticketId) { this.ticketId = ticketId; }  public int getStatus() { return status; }  public void setStatus(int complete) { this.status = complete; }  public boolean hasCompleted() { return status == COMPLETED; }  public boolean hasFailed() { return status == FAILED; }  public boolean isBusy() { return status == UNCOMPLETED; }  }  "
src/main/java/com/flickr4java/flickr/photos/upload/UploadInterface.java,"package com.flickr4java.flickr.photos.upload;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Checks the status of asynchronous photo upload tickets.
 * 
 * @author till (Till Krech) extranoise:flickr
 * @version $Id: UploadInterface.java,v 1.3 2008/01/28 23:01:45 x-mago Exp $
 */
public class UploadInterface {
    public static final String METHOD_CHECK_TICKETS = ""flickr.photos.upload.checkTickets"";

    private String apiKey;

    private String sharedSecret;

    private Transport transportAPI;

    public UploadInterface(String apiKey, String sharedSecret, Transport transport) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transport;
    }

    /**
     * Checks the status of one or more asynchronous photo upload tickets. This method does not require authentication.
     * 
     * @param tickets
     *            a set of ticket ids (Strings) or {@link Ticket} objects containing ids
     * @return a list of {@link Ticket} objects.
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public List<Ticket> checkTickets(Set<String> tickets) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_CHECK_TICKETS);

        StringBuffer sb = new StringBuffer();
        Iterator<String> it = tickets.iterator();
        while (it.hasNext()) {
            if (sb.length() > 0) {
                sb.append("","");
            }
            Object obj = it.next();
            if (obj instanceof Ticket) {
                sb.append(((Ticket) obj).getTicketId());
            } else {
                sb.append(obj);
            }
        }
        parameters.put(""tickets"", sb.toString());

        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }

        // <uploader>
        // <ticket id=""128"" complete=""1"" photoid=""2995"" />
        // <ticket id=""129"" complete=""0"" />
        // <ticket id=""130"" complete=""2"" />
        // <ticket id=""131"" invalid=""1"" />
        // </uploader>

        List<Ticket> list = new ArrayList<Ticket>();
        Element uploaderElement = response.getPayload();
        NodeList ticketNodes = uploaderElement.getElementsByTagName(""ticket"");
        int n = ticketNodes.getLength();
        for (int i = 0; i < n; i++) {
            Element ticketElement = (Element) ticketNodes.item(i);
            String id = ticketElement.getAttribute(""id"");
            String complete = ticketElement.getAttribute(""complete"");
            boolean invalid = ""1"".equals(ticketElement.getAttribute(""invalid""));
            String photoId = ticketElement.getAttribute(""photoid"");
            Ticket info = new Ticket();
            info.setTicketId(id);
            info.setInvalid(invalid);
            info.setStatus(Integer.parseInt(complete));
            info.setPhotoId(photoId);
            list.add(info);
        }
        return list;
    }

}
","package com.flickr4java.flickr.photos.upload; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.ArrayList; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; public class UploadInterface { public static final String METHOD_CHECK_TICKETS = ""flickr.photos.upload.checkTickets""; private String apiKey; private String sharedSecret; private Transport transportAPI; public UploadInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transport; } public List<Ticket> checkTickets(Set<String> tickets) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_CHECK_TICKETS); StringBuffer sb = new StringBuffer(); Iterator<String> it = tickets.iterator(); while (it.hasNext()) { if (sb.length() > 0) { sb.append("",""); } Object obj = it.next(); if (obj instanceof Ticket) { sb.append(((Ticket) obj).getTicketId()); } else { sb.append(obj); } } parameters.put(""tickets"", sb.toString()); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } List<Ticket> list = new ArrayList<Ticket>(); Element uploaderElement = response.getPayload(); NodeList ticketNodes = uploaderElement.getElementsByTagName(""ticket""); int n = ticketNodes.getLength(); for (int i = 0; i < n; i++) { Element ticketElement = (Element) ticketNodes.item(i); String id = ticketElement.getAttribute(""id""); String complete = ticketElement.getAttribute(""complete""); boolean invalid = ""1"".equals(ticketElement.getAttribute(""invalid"")); String photoId = ticketElement.getAttribute(""photoid""); Ticket info = new Ticket(); info.setTicketId(id); info.setInvalid(invalid); info.setStatus(Integer.parseInt(complete)); info.setPhotoId(photoId); list.add(info); } return list; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.photos.upload; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.ArrayList; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; public class UploadInterface { public static final String METHOD_CHECK_TICKETS = ""flickr.photos.upload.checkTickets""; private String apiKey; private String sharedSecret; private Transport transportAPI; public UploadInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transport; } public List<Ticket> checkTickets(Set<String> tickets) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_CHECK_TICKETS); StringBuffer sb = new StringBuffer(); Iterator<String> it = tickets.iterator(); while (it.hasNext()) { if (sb.length() > 0) { sb.append("",""); } Object obj = it.next(); if (obj instanceof Ticket) { sb.append(((Ticket) obj).getTicketId()); } else { sb.append(obj); } } parameters.put(""tickets"", sb.toString()); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } List<Ticket> list = new ArrayList<Ticket>(); Element uploaderElement = response.getPayload(); NodeList ticketNodes = uploaderElement.getElementsByTagName(""ticket""); int n = ticketNodes.getLength(); for (int i = 0; i < n; i++) { Element ticketElement = (Element) ticketNodes.item(i); String id = ticketElement.getAttribute(""id""); String complete = ticketElement.getAttribute(""complete""); boolean invalid = ""1"".equals(ticketElement.getAttribute(""invalid"")); String photoId = ticketElement.getAttribute(""photoid""); Ticket info = new Ticket(); info.setTicketId(id); info.setInvalid(invalid); info.setStatus(Integer.parseInt(complete)); info.setPhotoId(photoId); list.add(info); } return list; } } ","package com.flickr4java.flickr.photos.upload;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport;  import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import java.util.ArrayList; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set;  /**
 * Checks the status of asynchronous photo upload tickets.
 * 
 * @author till (Till Krech) extranoise:flickr
 * @version $Id: UploadInterface.java,v 1.3 2008/01/28 23:01:45 x-mago Exp $
 */ public class UploadInterface { public static final String METHOD_CHECK_TICKETS = ""flickr.photos.upload.checkTickets"";  private String apiKey;  private String sharedSecret;  private Transport transportAPI;  public UploadInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transport; }  /**
     * Checks the status of one or more asynchronous photo upload tickets. This method does not require authentication.
     * 
     * @param tickets
     *            a set of ticket ids (Strings) or {@link Ticket} objects containing ids
     * @return a list of {@link Ticket} objects.
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public List<Ticket> checkTickets(Set<String> tickets) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_CHECK_TICKETS);  StringBuffer sb = new StringBuffer(); Iterator<String> it = tickets.iterator(); while (it.hasNext()) { if (sb.length() > 0) { sb.append("",""); } Object obj = it.next(); if (obj instanceof Ticket) { sb.append(((Ticket) obj).getTicketId()); } else { sb.append(obj); } } parameters.put(""tickets"", sb.toString());  Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); }  // <uploader> // <ticket id=""128"" complete=""1"" photoid=""2995"" /> // <ticket id=""129"" complete=""0"" /> // <ticket id=""130"" complete=""2"" /> // <ticket id=""131"" invalid=""1"" /> // </uploader>  List<Ticket> list = new ArrayList<Ticket>(); Element uploaderElement = response.getPayload(); NodeList ticketNodes = uploaderElement.getElementsByTagName(""ticket""); int n = ticketNodes.getLength(); for (int i = 0; i < n; i++) { Element ticketElement = (Element) ticketNodes.item(i); String id = ticketElement.getAttribute(""id""); String complete = ticketElement.getAttribute(""complete""); boolean invalid = ""1"".equals(ticketElement.getAttribute(""invalid"")); String photoId = ticketElement.getAttribute(""photoid""); Ticket info = new Ticket(); info.setTicketId(id); info.setInvalid(invalid); info.setStatus(Integer.parseInt(complete)); info.setPhotoId(photoId); list.add(info); } return list; }  }  "
src/main/java/com/flickr4java/flickr/photosets/comments/PhotosetsCommentsInterface.java,"package com.flickr4java.flickr.photosets.comments;

import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.Response;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.photos.comments.Comment;
import com.flickr4java.flickr.util.XMLUtilities;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Access to the <b>flickr.photosets.comments</b> methods.
 * 
 * @author till (Till Krech) flickr:extranoise
 * @version $Id: PhotosetsCommentsInterface.java,v 1.3 2009/07/11 20:30:27 x-mago Exp $
 */
public class PhotosetsCommentsInterface {
    public static final String METHOD_ADD_COMMENT = ""flickr.photosets.comments.addComment"";

    public static final String METHOD_DELETE_COMMENT = ""flickr.photosets.comments.deleteComment"";

    public static final String METHOD_EDIT_COMMENT = ""flickr.photosets.comments.editComment"";

    public static final String METHOD_GET_LIST = ""flickr.photosets.comments.getList"";

    private String apiKey;

    private String sharedSecret;

    private Transport transportAPI;

    public PhotosetsCommentsInterface(String apiKey, String sharedSecret, Transport transport) {
        this.apiKey = apiKey;
        this.sharedSecret = sharedSecret;
        this.transportAPI = transport;
    }

    /**
     * Add a comment to a photoset. This method requires authentication with 'write' permission.
     * 
     * @param photosetId
     *            The id of the photoset to add a comment to.
     * @param commentText
     *            Text of the comment
     * @return the comment id
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public String addComment(String photosetId, String commentText) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_ADD_COMMENT);

        parameters.put(""photoset_id"", photosetId);
        parameters.put(""comment_text"", commentText);

        // Note: This method requires an HTTP POST request.
        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        // response:
        // <comment id=""97777-12492-72057594037942601"" />
        Element commentElement = response.getPayload();
        return commentElement.getAttribute(""id"");
    }

    /**
     * Delete a photoset comment as the currently authenticated user.
     * 
     * @param commentId
     *            The id of the comment to delete from a photoset.
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void deleteComment(String commentId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_DELETE_COMMENT);

        parameters.put(""comment_id"", commentId);

        // Note: This method requires an HTTP POST request.
        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        // This method has no specific response - It returns an empty sucess response if it completes without error.
    }

    /**
     * Edit the text of a comment as the currently authenticated user. This method requires authentication with 'write' permission.
     * 
     * @param commentId
     *            The id of the comment to edit.
     * @param commentText
     *            Update the comment to this text.
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public void editComment(String commentId, String commentText) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_EDIT_COMMENT);

        parameters.put(""comment_id"", commentId);
        parameters.put(""comment_text"", commentText);

        // Note: This method requires an HTTP POST request.
        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        // This method has no specific response - It returns an empty sucess response if it completes without error.
    }

    /**
     * Returns the comments for a photoset.
     * 
     * This method does not require authentication.
     * 
     * @param photosetId
     *            The id of the photoset to fetch comments for.
     * @return a list of {@link Comment} objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */
    public List<Comment> getList(String photosetId) throws FlickrException {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_GET_LIST);

        parameters.put(""photoset_id"", photosetId);

        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
        // response:
        // <comments photoset_id=""72157594152539675"">
        // <comment
        // id=""2534725-72157594152539675-72157594172966066""
        // author=""99589152@N00""
        // authorname=""ortrun""
        // datecreate=""1150905040""
        // permalink=""http://www.flickr.com/photos/extranoise/sets/72157594152539675/comments#comment72157594172966066"">
        // really unreal!
        // </comment>
        // <comment
        // id=""2534725-72157594152539675-72157594176993150""
        // author=""47093120@N00""
        // authorname=""nis.jensen""
        // datecreate=""1151259227""
        // permalink=""http://www.flickr.com/photos/extranoise/sets/72157594152539675/comments#comment72157594176993150"">
        // Wow - you're better than most - this was a great view - i'll just take it again!
        // </comment>
        // <comment
        // id=""2534725-72157594152539675-72157594176996639""
        // author=""47093120@N00""
        // authorname=""nis.jensen""
        // datecreate=""1151259453""
        // permalink=""http://www.flickr.com/photos/extranoise/sets/72157594152539675/comments#comment72157594176996639"">
        // Second it's even better!!!!
        // </comment>
        // </comments>
        List<Comment> comments = new ArrayList<Comment>();
        Element commentsElement = response.getPayload();
        NodeList commentNodes = commentsElement.getElementsByTagName(""comment"");
        int n = commentNodes.getLength();
        for (int i = 0; i < n; i++) {
            Comment comment = new Comment();
            Element commentElement = (Element) commentNodes.item(i);
            comment.setId(commentElement.getAttribute(""id""));
            comment.setAuthor(commentElement.getAttribute(""author""));
            comment.setAuthorName(commentElement.getAttribute(""authorname""));
            comment.setPermaLink(commentElement.getAttribute(""permalink""));
            long unixTime = 0;
            try {
                unixTime = Long.parseLong(commentElement.getAttribute(""datecreate""));
            } catch (NumberFormatException e) {
                // what shall we do?
                e.printStackTrace();
            }
            comment.setDateCreate(new Date(unixTime * 1000L));
            comment.setText(XMLUtilities.getValue(commentElement));
            comments.add(comment);
        }
        return comments;
    }

}
","package com.flickr4java.flickr.photosets.comments; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.comments.Comment; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.ArrayList; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map; public class PhotosetsCommentsInterface { public static final String METHOD_ADD_COMMENT = ""flickr.photosets.comments.addComment""; public static final String METHOD_DELETE_COMMENT = ""flickr.photosets.comments.deleteComment""; public static final String METHOD_EDIT_COMMENT = ""flickr.photosets.comments.editComment""; public static final String METHOD_GET_LIST = ""flickr.photosets.comments.getList""; private String apiKey; private String sharedSecret; private Transport transportAPI; public PhotosetsCommentsInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transport; } public String addComment(String photosetId, String commentText) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD_COMMENT); parameters.put(""photoset_id"", photosetId); parameters.put(""comment_text"", commentText); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element commentElement = response.getPayload(); return commentElement.getAttribute(""id""); } public void deleteComment(String commentId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_DELETE_COMMENT); parameters.put(""comment_id"", commentId); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void editComment(String commentId, String commentText) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT_COMMENT); parameters.put(""comment_id"", commentId); parameters.put(""comment_text"", commentText); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public List<Comment> getList(String photosetId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); parameters.put(""photoset_id"", photosetId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } List<Comment> comments = new ArrayList<Comment>(); Element commentsElement = response.getPayload(); NodeList commentNodes = commentsElement.getElementsByTagName(""comment""); int n = commentNodes.getLength(); for (int i = 0; i < n; i++) { Comment comment = new Comment(); Element commentElement = (Element) commentNodes.item(i); comment.setId(commentElement.getAttribute(""id"")); comment.setAuthor(commentElement.getAttribute(""author"")); comment.setAuthorName(commentElement.getAttribute(""authorname"")); comment.setPermaLink(commentElement.getAttribute(""permalink"")); long unixTime = 0; try { unixTime = Long.parseLong(commentElement.getAttribute(""datecreate"")); } catch (NumberFormatException e) { e.printStackTrace(); } comment.setDateCreate(new Date(unixTime * 1000L)); comment.setText(XMLUtilities.getValue(commentElement)); comments.add(comment); } return comments; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.photosets.comments; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.comments.Comment; import com.flickr4java.flickr.util.XMLUtilities; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.util.ArrayList; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map; public class PhotosetsCommentsInterface { public static final String METHOD_ADD_COMMENT = ""flickr.photosets.comments.addComment""; public static final String METHOD_DELETE_COMMENT = ""flickr.photosets.comments.deleteComment""; public static final String METHOD_EDIT_COMMENT = ""flickr.photosets.comments.editComment""; public static final String METHOD_GET_LIST = ""flickr.photosets.comments.getList""; private String apiKey; private String sharedSecret; private Transport transportAPI; public PhotosetsCommentsInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transport; } public String addComment(String photosetId, String commentText) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD_COMMENT); parameters.put(""photoset_id"", photosetId); parameters.put(""comment_text"", commentText); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } Element commentElement = response.getPayload(); return commentElement.getAttribute(""id""); } public void deleteComment(String commentId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_DELETE_COMMENT); parameters.put(""comment_id"", commentId); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public void editComment(String commentId, String commentText) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT_COMMENT); parameters.put(""comment_id"", commentId); parameters.put(""comment_text"", commentText); Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } } public List<Comment> getList(String photosetId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST); parameters.put(""photoset_id"", photosetId); Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } List<Comment> comments = new ArrayList<Comment>(); Element commentsElement = response.getPayload(); NodeList commentNodes = commentsElement.getElementsByTagName(""comment""); int n = commentNodes.getLength(); for (int i = 0; i < n; i++) { Comment comment = new Comment(); Element commentElement = (Element) commentNodes.item(i); comment.setId(commentElement.getAttribute(""id"")); comment.setAuthor(commentElement.getAttribute(""author"")); comment.setAuthorName(commentElement.getAttribute(""authorname"")); comment.setPermaLink(commentElement.getAttribute(""permalink"")); long unixTime = 0; try { unixTime = Long.parseLong(commentElement.getAttribute(""datecreate"")); } catch (NumberFormatException e) { e.printStackTrace(); } comment.setDateCreate(new Date(unixTime * 1000L)); comment.setText(XMLUtilities.getValue(commentElement)); comments.add(comment); } return comments; } } ","package com.flickr4java.flickr.photosets.comments;  import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.Response; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.photos.comments.Comment; import com.flickr4java.flickr.util.XMLUtilities;  import org.w3c.dom.Element; import org.w3c.dom.NodeList;  import java.util.ArrayList; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map;  /**
 * Access to the <b>flickr.photosets.comments</b> methods.
 * 
 * @author till (Till Krech) flickr:extranoise
 * @version $Id: PhotosetsCommentsInterface.java,v 1.3 2009/07/11 20:30:27 x-mago Exp $
 */ public class PhotosetsCommentsInterface { public static final String METHOD_ADD_COMMENT = ""flickr.photosets.comments.addComment"";  public static final String METHOD_DELETE_COMMENT = ""flickr.photosets.comments.deleteComment"";  public static final String METHOD_EDIT_COMMENT = ""flickr.photosets.comments.editComment"";  public static final String METHOD_GET_LIST = ""flickr.photosets.comments.getList"";  private String apiKey;  private String sharedSecret;  private Transport transportAPI;  public PhotosetsCommentsInterface(String apiKey, String sharedSecret, Transport transport) { this.apiKey = apiKey; this.sharedSecret = sharedSecret; this.transportAPI = transport; }  /**
     * Add a comment to a photoset. This method requires authentication with 'write' permission.
     * 
     * @param photosetId
     *            The id of the photoset to add a comment to.
     * @param commentText
     *            Text of the comment
     * @return the comment id
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public String addComment(String photosetId, String commentText) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_ADD_COMMENT);  parameters.put(""photoset_id"", photosetId); parameters.put(""comment_text"", commentText);  // Note: This method requires an HTTP POST request. Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } // response: // <comment id=""97777-12492-72057594037942601"" /> Element commentElement = response.getPayload(); return commentElement.getAttribute(""id""); }  /**
     * Delete a photoset comment as the currently authenticated user.
     * 
     * @param commentId
     *            The id of the comment to delete from a photoset.
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void deleteComment(String commentId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_DELETE_COMMENT);  parameters.put(""comment_id"", commentId);  // Note: This method requires an HTTP POST request. Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } // This method has no specific response - It returns an empty sucess response if it completes without error. }  /**
     * Edit the text of a comment as the currently authenticated user. This method requires authentication with 'write' permission.
     * 
     * @param commentId
     *            The id of the comment to edit.
     * @param commentText
     *            Update the comment to this text.
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public void editComment(String commentId, String commentText) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_EDIT_COMMENT);  parameters.put(""comment_id"", commentId); parameters.put(""comment_text"", commentText);  // Note: This method requires an HTTP POST request. Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } // This method has no specific response - It returns an empty sucess response if it completes without error. }  /**
     * Returns the comments for a photoset.
     * 
     * This method does not require authentication.
     * 
     * @param photosetId
     *            The id of the photoset to fetch comments for.
     * @return a list of {@link Comment} objects
     * @throws FlickrException if there was a problem connecting to Flickr
     */ public List<Comment> getList(String photosetId) throws FlickrException { Map<String, Object> parameters = new HashMap<String, Object>(); parameters.put(""method"", METHOD_GET_LIST);  parameters.put(""photoset_id"", photosetId);  Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret); if (response.isError()) { throw new FlickrException(response.getErrorCode(), response.getErrorMessage()); } // response: // <comments photoset_id=""72157594152539675""> // <comment // id=""2534725-72157594152539675-72157594172966066"" // author=""99589152@N00"" // authorname=""ortrun"" // datecreate=""1150905040"" // permalink=""http://www.flickr.com/photos/extranoise/sets/72157594152539675/comments#comment72157594172966066""> // really unreal! // </comment> // <comment // id=""2534725-72157594152539675-72157594176993150"" // author=""47093120@N00"" // authorname=""nis.jensen"" // datecreate=""1151259227"" // permalink=""http://www.flickr.com/photos/extranoise/sets/72157594152539675/comments#comment72157594176993150""> // Wow - you're better than most - this was a great view - i'll just take it again! // </comment> // <comment // id=""2534725-72157594152539675-72157594176996639"" // author=""47093120@N00"" // authorname=""nis.jensen"" // datecreate=""1151259453"" // permalink=""http://www.flickr.com/photos/extranoise/sets/72157594152539675/comments#comment72157594176996639""> // Second it's even better!!!! // </comment> // </comments> List<Comment> comments = new ArrayList<Comment>(); Element commentsElement = response.getPayload(); NodeList commentNodes = commentsElement.getElementsByTagName(""comment""); int n = commentNodes.getLength(); for (int i = 0; i < n; i++) { Comment comment = new Comment(); Element commentElement = (Element) commentNodes.item(i); comment.setId(commentElement.getAttribute(""id"")); comment.setAuthor(commentElement.getAttribute(""author"")); comment.setAuthorName(commentElement.getAttribute(""authorname"")); comment.setPermaLink(commentElement.getAttribute(""permalink"")); long unixTime = 0; try { unixTime = Long.parseLong(commentElement.getAttribute(""datecreate"")); } catch (NumberFormatException e) { // what shall we do? e.printStackTrace(); } comment.setDateCreate(new Date(unixTime * 1000L)); comment.setText(XMLUtilities.getValue(commentElement)); comments.add(comment); } return comments; }  }  "
src/test/java/com/flickr4java/flickr/test/util/FileTestProperties.java,"package com.flickr4java.flickr.test.util;

import com.flickr4java.flickr.FlickrRuntimeException;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Properties;

/**
 * Wrapper for test properties.
 * 
 * @author Darren Greaves Copyright (c) 2012 Darren Greaves.
 */
public class FileTestProperties implements TestProperties {

    private String host;

    private String apiKey;

    private String secret;

    private String token;

    private String tokenSecret;

    private String nsid;

    private String email;

    private String username;

    private String displayname;

    private String groupId;

    private String testGroupId;

    private String photoId;

    private String photosetId;

    private String collectionId;

    private String collectionUrlId;

    private String imageFile;

    private String geoWritePhotoId;

    private String galleryId;

    private final List<String> photosetPhotos;

    public FileTestProperties(File propertiesFile) {
        photosetPhotos = new ArrayList<>();
        Properties properties = load(propertiesFile);
        populate(properties);
    }

    private Properties load(File propertiesFile) {
        Properties properties = new Properties();

        try (InputStream in = new FileInputStream(propertiesFile)) {
            properties.load(in);
        } catch (IOException e) {
            throw new FlickrRuntimeException(""Problem loading properties"", e);
        }

        return properties;
    }

    /**
     * 
     * @param properties
     */
    private void populate(Properties properties) {
        host = properties.getProperty(""host"");
        apiKey = properties.getProperty(""apiKey"");
        secret = properties.getProperty(""secret"");
        token = properties.getProperty(""token"");
        tokenSecret = properties.getProperty(""tokensecret"");
        nsid = properties.getProperty(""nsid"");
        email = properties.getProperty(""email"");
        displayname = properties.getProperty(""displayname"");
        username = properties.getProperty(""username"");
        groupId = properties.getProperty(""groupid"");
        testGroupId = properties.getProperty(""testgroupid"");
        photoId = properties.getProperty(""photoid"");
        photosetId = properties.getProperty(""photosetid"");
        collectionId = properties.getProperty(""collectionid"");
        collectionUrlId = properties.getProperty(""collectionurlid"");
        imageFile = properties.getProperty(""imagefile"");
        galleryId = properties.getProperty(""galleryid"");
        geoWritePhotoId = properties.getProperty(""geo.write.photoid"");

        String photosetPhotosCSV = properties.getProperty(""photosetphotos"");
        String[] photosetPhotos = photosetPhotosCSV != null ? photosetPhotosCSV.split("","") : new String[0];
        for (String photosetPhoto : photosetPhotos) {
            this.photosetPhotos.add(photosetPhoto.trim());
        }
        Collections.sort(this.photosetPhotos);
    }

    @Override
    public String getHost() {
        return host;
    }

    @Override
    public String getApiKey() {
        return apiKey;
    }

    @Override
    public String getSecret() {
        return secret;
    }

    @Override
    public String getToken() {
        return token;
    }

    @Override
    public String getTokenSecret() {
        return tokenSecret;
    }

    @Override
    public String getNsid() {
        return nsid;
    }

    @Override
    public String getEmail() {
        return email;
    }

    @Override
    public String getUsername() {
        return username;
    }

    @Override
    public String getGroupId() {
        return groupId;
    }

    @Override
    public String getTestGroupId() {
        return testGroupId;
    }

    @Override
    public String getPhotoId() {
        return photoId;
    }

    @Override
    public String getPhotosetId() {
        return photosetId;
    }

    @Override
    public String getImageFile() {
        return imageFile;
    }

    @Override
    public String getGeoWritePhotoId() {
        return geoWritePhotoId;
    }

    @Override
    public String getCollectionId() {
        return collectionId;
    }

    @Override
    public String getCollectionUrlId() {
        return collectionUrlId;
    }

    @Override
    public String getGalleryId() {
        return galleryId;
    }

    @Override
    public String getDisplayname() {
        return displayname;
    }

    @Override
    public List<String> getPhotosetPhotos() {
        return photosetPhotos;
    }

    @Override
    public boolean isRealFlickr() {
        return true;
    }

}
","package com.flickr4java.flickr.test.util; public class FileTestProperties implements TestProperties { private String host; private String apiKey; private String secret; private String token; private String tokenSecret; private String nsid; private String email; private String username; private String displayname; private String groupId; private String testGroupId; private String photoId; private String photosetId; private String collectionId; private String collectionUrlId; private String imageFile; private String geoWritePhotoId; private String galleryId; private final List<String> photosetPhotos; public FileTestProperties(File propertiesFile) { photosetPhotos = new ArrayList<>(); Properties properties = load(propertiesFile); populate(properties); } private Properties load(File propertiesFile) { Properties properties = new Properties(); try (InputStream in = new FileInputStream(propertiesFile)) { properties.load(in); } catch (IOException e) { throw new FlickrRuntimeException(""Problem loading properties"", e); } return properties; } private void populate(Properties properties) { host = properties.getProperty(""host""); apiKey = properties.getProperty(""apiKey""); secret = properties.getProperty(""secret""); token = properties.getProperty(""token""); tokenSecret = properties.getProperty(""tokensecret""); nsid = properties.getProperty(""nsid""); email = properties.getProperty(""email""); displayname = properties.getProperty(""displayname""); username = properties.getProperty(""username""); groupId = properties.getProperty(""groupid""); testGroupId = properties.getProperty(""testgroupid""); photoId = properties.getProperty(""photoid""); photosetId = properties.getProperty(""photosetid""); collectionId = properties.getProperty(""collectionid""); collectionUrlId = properties.getProperty(""collectionurlid""); imageFile = properties.getProperty(""imagefile""); galleryId = properties.getProperty(""galleryid""); geoWritePhotoId = properties.getProperty(""geo.write.photoid""); String photosetPhotosCSV = properties.getProperty(""photosetphotos""); String[] photosetPhotos = photosetPhotosCSV != null ? photosetPhotosCSV.split("","") : new String[0]; for (String photosetPhoto : photosetPhotos) { this.photosetPhotos.add(photosetPhoto.trim()); } Collections.sort(this.photosetPhotos); } @Override
    public String getHost() { return host; } @Override
    public String getApiKey() { return apiKey; } @Override
    public String getSecret() { return secret; } @Override
    public String getToken() { return token; } @Override
    public String getTokenSecret() { return tokenSecret; } @Override
    public String getNsid() { return nsid; } @Override
    public String getEmail() { return email; } @Override
    public String getUsername() { return username; } @Override
    public String getGroupId() { return groupId; } @Override
    public String getTestGroupId() { return testGroupId; } @Override
    public String getPhotoId() { return photoId; } @Override
    public String getPhotosetId() { return photosetId; } @Override
    public String getImageFile() { return imageFile; } @Override
    public String getGeoWritePhotoId() { return geoWritePhotoId; } @Override
    public String getCollectionId() { return collectionId; } @Override
    public String getCollectionUrlId() { return collectionUrlId; } @Override
    public String getGalleryId() { return galleryId; } @Override
    public String getDisplayname() { return displayname; } @Override
    public List<String> getPhotosetPhotos() { return photosetPhotos; } @Override
    public boolean isRealFlickr() { return true; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test.util; public class FileTestProperties implements TestProperties { private String host; private String apiKey; private String secret; private String token; private String tokenSecret; private String nsid; private String email; private String username; private String displayname; private String groupId; private String testGroupId; private String photoId; private String photosetId; private String collectionId; private String collectionUrlId; private String imageFile; private String geoWritePhotoId; private String galleryId; private final List<String> photosetPhotos; public FileTestProperties(File propertiesFile) { photosetPhotos = new ArrayList<>(); Properties properties = load(propertiesFile); populate(properties); } private Properties load(File propertiesFile) { Properties properties = new Properties(); try (InputStream in = new FileInputStream(propertiesFile)) { properties.load(in); } catch (IOException e) { throw new FlickrRuntimeException(""Problem loading properties"", e); } return properties; } private void populate(Properties properties) { host = properties.getProperty(""host""); apiKey = properties.getProperty(""apiKey""); secret = properties.getProperty(""secret""); token = properties.getProperty(""token""); tokenSecret = properties.getProperty(""tokensecret""); nsid = properties.getProperty(""nsid""); email = properties.getProperty(""email""); displayname = properties.getProperty(""displayname""); username = properties.getProperty(""username""); groupId = properties.getProperty(""groupid""); testGroupId = properties.getProperty(""testgroupid""); photoId = properties.getProperty(""photoid""); photosetId = properties.getProperty(""photosetid""); collectionId = properties.getProperty(""collectionid""); collectionUrlId = properties.getProperty(""collectionurlid""); imageFile = properties.getProperty(""imagefile""); galleryId = properties.getProperty(""galleryid""); geoWritePhotoId = properties.getProperty(""geo.write.photoid""); String photosetPhotosCSV = properties.getProperty(""photosetphotos""); String[] photosetPhotos = photosetPhotosCSV != null ? photosetPhotosCSV.split("","") : new String[0]; for (String photosetPhoto : photosetPhotos) { this.photosetPhotos.add(photosetPhoto.trim()); } Collections.sort(this.photosetPhotos); } @Override
    public String getHost() { return host; } @Override
    public String getApiKey() { return apiKey; } @Override
    public String getSecret() { return secret; } @Override
    public String getToken() { return token; } @Override
    public String getTokenSecret() { return tokenSecret; } @Override
    public String getNsid() { return nsid; } @Override
    public String getEmail() { return email; } @Override
    public String getUsername() { return username; } @Override
    public String getGroupId() { return groupId; } @Override
    public String getTestGroupId() { return testGroupId; } @Override
    public String getPhotoId() { return photoId; } @Override
    public String getPhotosetId() { return photosetId; } @Override
    public String getImageFile() { return imageFile; } @Override
    public String getGeoWritePhotoId() { return geoWritePhotoId; } @Override
    public String getCollectionId() { return collectionId; } @Override
    public String getCollectionUrlId() { return collectionUrlId; } @Override
    public String getGalleryId() { return galleryId; } @Override
    public String getDisplayname() { return displayname; } @Override
    public List<String> getPhotosetPhotos() { return photosetPhotos; } @Override
    public boolean isRealFlickr() { return true; } } ","package com.flickr4java.flickr.test.util; 
import com.flickr4java.flickr.FlickrRuntimeException; 
import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Properties;  /**
 * Wrapper for test properties.
 * 
 * @author Darren Greaves Copyright (c) 2012 Darren Greaves.
 */ public class FileTestProperties implements TestProperties {  private String host;  private String apiKey;  private String secret;  private String token;  private String tokenSecret;  private String nsid;  private String email;  private String username;  private String displayname;  private String groupId;  private String testGroupId;  private String photoId;  private String photosetId;  private String collectionId;  private String collectionUrlId;  private String imageFile;  private String geoWritePhotoId;  private String galleryId;  private final List<String> photosetPhotos;  public FileTestProperties(File propertiesFile) { photosetPhotos = new ArrayList<>(); Properties properties = load(propertiesFile); populate(properties); }  private Properties load(File propertiesFile) { Properties properties = new Properties();  try (InputStream in = new FileInputStream(propertiesFile)) { properties.load(in); } catch (IOException e) { throw new FlickrRuntimeException(""Problem loading properties"", e); }  return properties; }  /**
     * 
     * @param properties
     */ private void populate(Properties properties) { host = properties.getProperty(""host""); apiKey = properties.getProperty(""apiKey""); secret = properties.getProperty(""secret""); token = properties.getProperty(""token""); tokenSecret = properties.getProperty(""tokensecret""); nsid = properties.getProperty(""nsid""); email = properties.getProperty(""email""); displayname = properties.getProperty(""displayname""); username = properties.getProperty(""username""); groupId = properties.getProperty(""groupid""); testGroupId = properties.getProperty(""testgroupid""); photoId = properties.getProperty(""photoid""); photosetId = properties.getProperty(""photosetid""); collectionId = properties.getProperty(""collectionid""); collectionUrlId = properties.getProperty(""collectionurlid""); imageFile = properties.getProperty(""imagefile""); galleryId = properties.getProperty(""galleryid""); geoWritePhotoId = properties.getProperty(""geo.write.photoid"");  String photosetPhotosCSV = properties.getProperty(""photosetphotos""); String[] photosetPhotos = photosetPhotosCSV != null ? photosetPhotosCSV.split("","") : new String[0]; for (String photosetPhoto : photosetPhotos) { this.photosetPhotos.add(photosetPhoto.trim()); } Collections.sort(this.photosetPhotos); }  @Override
    public String getHost() { return host; }  @Override
    public String getApiKey() { return apiKey; }  @Override
    public String getSecret() { return secret; }  @Override
    public String getToken() { return token; }  @Override
    public String getTokenSecret() { return tokenSecret; }  @Override
    public String getNsid() { return nsid; }  @Override
    public String getEmail() { return email; }  @Override
    public String getUsername() { return username; }  @Override
    public String getGroupId() { return groupId; }  @Override
    public String getTestGroupId() { return testGroupId; }  @Override
    public String getPhotoId() { return photoId; }  @Override
    public String getPhotosetId() { return photosetId; }  @Override
    public String getImageFile() { return imageFile; }  @Override
    public String getGeoWritePhotoId() { return geoWritePhotoId; }  @Override
    public String getCollectionId() { return collectionId; }  @Override
    public String getCollectionUrlId() { return collectionUrlId; }  @Override
    public String getGalleryId() { return galleryId; }  @Override
    public String getDisplayname() { return displayname; }  @Override
    public List<String> getPhotosetPhotos() { return photosetPhotos; }  @Override
    public boolean isRealFlickr() { return true; }  }  "
src/test/java/com/flickr4java/flickr/test/util/FlickrStub.java,"
package com.flickr4java.flickr.test.util;

import com.flickr4java.flickr.IFlickr;
import com.flickr4java.flickr.Transport;
import com.flickr4java.flickr.activity.ActivityInterface;
import com.flickr4java.flickr.auth.Auth;
import com.flickr4java.flickr.auth.AuthInterface;
import com.flickr4java.flickr.blogs.BlogsInterface;
import com.flickr4java.flickr.cameras.CamerasInterface;
import com.flickr4java.flickr.collections.CollectionsInterface;
import com.flickr4java.flickr.commons.CommonsInterface;
import com.flickr4java.flickr.contacts.ContactsInterface;
import com.flickr4java.flickr.favorites.FavoritesInterface;
import com.flickr4java.flickr.galleries.GalleriesInterface;
import com.flickr4java.flickr.groups.GroupsInterface;
import com.flickr4java.flickr.groups.discuss.GroupDiscussInterface;
import com.flickr4java.flickr.groups.members.MembersInterface;
import com.flickr4java.flickr.groups.pools.PoolsInterface;
import com.flickr4java.flickr.interestingness.InterestingnessInterface;
import com.flickr4java.flickr.machinetags.MachinetagsInterface;
import com.flickr4java.flickr.panda.PandaInterface;
import com.flickr4java.flickr.people.PeopleInterface;
import com.flickr4java.flickr.photos.PhotosInterface;
import com.flickr4java.flickr.photos.comments.CommentsInterface;
import com.flickr4java.flickr.photos.geo.GeoInterface;
import com.flickr4java.flickr.photos.licenses.LicensesInterface;
import com.flickr4java.flickr.photos.notes.NotesInterface;
import com.flickr4java.flickr.photos.suggestions.SuggestionsInterface;
import com.flickr4java.flickr.photos.transform.TransformInterface;
import com.flickr4java.flickr.photos.upload.UploadInterface;
import com.flickr4java.flickr.photosets.PhotosetsInterface;
import com.flickr4java.flickr.photosets.comments.PhotosetsCommentsInterface;
import com.flickr4java.flickr.places.PlacesInterface;
import com.flickr4java.flickr.prefs.PrefsInterface;
import com.flickr4java.flickr.reflection.ReflectionInterface;
import com.flickr4java.flickr.stats.StatsInterface;
import com.flickr4java.flickr.tags.TagsInterface;
import com.flickr4java.flickr.test.TestInterface;
import com.flickr4java.flickr.uploader.Uploader;
import com.flickr4java.flickr.urls.UrlsInterface;

/**
 * Stubbed entry point for the Flickr4Java API. This class is used to acquire Interface classes which wrap the Flickr API.
 *
 */
public class FlickrStub implements IFlickr {

    private String apiKey;

    private String sharedSecret;

    private Transport transport;

    private Auth auth;

    private AuthInterface authInterface;

    private ActivityInterface activityInterface;

    private BlogsInterface blogsInterface;

    private CommentsInterface commentsInterface;

    private CommonsInterface commonsInterface;

    private ContactsInterface contactsInterface;

    private FavoritesInterface favoritesInterface;

    private GeoInterface geoInterface;

    private GroupsInterface groupsInterface;

    private InterestingnessInterface interestingnessInterface;

    private LicensesInterface licensesInterface;

    private MembersInterface membersInterface;

    private MachinetagsInterface machinetagsInterface;

    private NotesInterface notesInterface;

    private PandaInterface pandaInterface;

    private PoolsInterface poolsInterface;

    private PeopleInterface peopleInterface;

    private PhotosInterface photosInterface;

    private PhotosetsCommentsInterface photosetsCommentsInterface;

    private PhotosetsInterface photosetsInterface;

    private CollectionsInterface collectionsInterface;

    private PlacesInterface placesInterface;

    private PrefsInterface prefsInterface;

    private ReflectionInterface reflectionInterface;

    private TagsInterface tagsInterface;

    private TestInterface testInterface;

    private TransformInterface transformInterface;

    private UploadInterface uploadInterface;

    private Uploader uploader;

    private UrlsInterface urlsInterface;

    private GalleriesInterface galleriesInterface;

    private StatsInterface statsInterface;

    private CamerasInterface cameraInterface;

    private SuggestionsInterface suggestionsInterface;

    private GroupDiscussInterface discussionInterface;

    /**
     * Construct a new stubbed Flickr instance.
     *
     */
    public FlickrStub() {
        transport = new TransportStub();
    }

    /**
     * Get the API key.
     * 
     * @return The API key
     */
    public String getApiKey() {
        return apiKey;
    }

    /**
     * Set the API key to use which must not be null.
     * 
     * @param apiKey
     *            The API key which cannot be null
     */
    public void setApiKey(String apiKey) {
        if (apiKey == null) {
            throw new IllegalArgumentException(""API key must not be null"");
        }
        this.apiKey = apiKey;
    }

    public void setAuth(Auth auth) {
        this.auth = auth;
    }

    /**
     * Get the Auth-object.
     * 
     * @return The Auth-object
     */
    public Auth getAuth() {
        return auth;
    }

    /**
     * Get the Shared-Secret.
     * 
     * @return The Shared-Secret
     */
    public String getSharedSecret() {
        return sharedSecret;
    }

    /**
     * Set the Shared-Secret to use which must not be null.
     * 
     * @param sharedSecret
     *            The Shared-Secret which cannot be null
     */
    public void setSharedSecret(String sharedSecret) {
        if (sharedSecret == null) {
            throw new IllegalArgumentException(""Shared-Secret must not be null"");
        }
        this.sharedSecret = sharedSecret;
    }

    /**
     * Get the Transport interface.
     * 
     * @return The Tranport interface
     */
    public Transport getTransport() {
        return transport;
    }

    /**
     * Set the Transport which must not be null.
     * 
     * @param transport
     */
    public void setTransport(Transport transport) {
        if (transport == null) {
            throw new IllegalArgumentException(""Transport must not be null"");
        }
        this.transport = transport;
    }

    /**
     * Get the AuthInterface.
     * 
     * @return The AuthInterface
     */
    public AuthInterface getAuthInterface() {
        if (authInterface == null) {
            authInterface = new AuthInterface(apiKey, sharedSecret, transport);
        }
        return authInterface;
    }

    /**
     * Get the ActivityInterface.
     * 
     * @return The ActivityInterface
     */
    public ActivityInterface getActivityInterface() {
        if (activityInterface == null) {
            activityInterface = new ActivityInterface(apiKey, sharedSecret, transport);
        }
        return activityInterface;
    }

    public BlogsInterface getBlogsInterface() {
        if (blogsInterface == null) {
            blogsInterface = new BlogsInterface(apiKey, sharedSecret, transport);
        }
        return blogsInterface;
    }

    public CommentsInterface getCommentsInterface() {
        if (commentsInterface == null) {
            commentsInterface = new CommentsInterface(apiKey, sharedSecret, transport);
        }
        return commentsInterface;
    }

    public CommonsInterface getCommonsInterface() {
        if (commonsInterface == null) {
            commonsInterface = new CommonsInterface(apiKey, sharedSecret, transport);
        }
        return commonsInterface;
    }

    public ContactsInterface getContactsInterface() {
        if (contactsInterface == null) {
            contactsInterface = new ContactsInterface(apiKey, sharedSecret, transport);
        }
        return contactsInterface;
    }

    public FavoritesInterface getFavoritesInterface() {
        if (favoritesInterface == null) {
            favoritesInterface = new FavoritesInterface(apiKey, sharedSecret, transport);
        }
        return favoritesInterface;
    }

    public GeoInterface getGeoInterface() {
        if (geoInterface == null) {
            geoInterface = new GeoInterface(apiKey, sharedSecret, transport);
        }
        return geoInterface;
    }

    public GroupsInterface getGroupsInterface() {
        if (groupsInterface == null) {
            groupsInterface = new GroupsInterface(apiKey, sharedSecret, transport);
        }
        return groupsInterface;
    }

    /**
     * @return the interface to the flickr.interestingness methods
     */
    public InterestingnessInterface getInterestingnessInterface() {
        if (interestingnessInterface == null) {
            interestingnessInterface = new InterestingnessInterface(apiKey, sharedSecret, transport);
        }
        return interestingnessInterface;
    }

    public LicensesInterface getLicensesInterface() {
        if (licensesInterface == null) {
            licensesInterface = new LicensesInterface(apiKey, sharedSecret, transport);
        }
        return licensesInterface;
    }

    public MachinetagsInterface getMachinetagsInterface() {
        if (machinetagsInterface == null) {
            machinetagsInterface = new MachinetagsInterface(apiKey, sharedSecret, transport);
        }
        return machinetagsInterface;
    }

    public MembersInterface getMembersInterface() {
        if (membersInterface == null) {
            membersInterface = new MembersInterface(apiKey, sharedSecret, transport);
        }
        return membersInterface;
    }

    public NotesInterface getNotesInterface() {
        if (notesInterface == null) {
            notesInterface = new NotesInterface(apiKey, sharedSecret, transport);
        }
        return notesInterface;
    }

    public PandaInterface getPandaInterface() {
        if (pandaInterface == null) {
            pandaInterface = new PandaInterface(apiKey, sharedSecret, transport);
        }
        return pandaInterface;
    }

    public PoolsInterface getPoolsInterface() {
        if (poolsInterface == null) {
            poolsInterface = new PoolsInterface(apiKey, sharedSecret, transport);
        }
        return poolsInterface;
    }

    public PeopleInterface getPeopleInterface() {
        if (peopleInterface == null) {
            peopleInterface = new PeopleInterface(apiKey, sharedSecret, transport);
        }
        return peopleInterface;
    }

    public PhotosInterface getPhotosInterface() {
        if (photosInterface == null) {
            photosInterface = new PhotosInterface(apiKey, sharedSecret, transport);
        }
        return photosInterface;
    }

    public PhotosetsCommentsInterface getPhotosetsCommentsInterface() {
        if (photosetsCommentsInterface == null) {
            photosetsCommentsInterface = new PhotosetsCommentsInterface(apiKey, sharedSecret, transport);
        }
        return photosetsCommentsInterface;
    }

    public PhotosetsInterface getPhotosetsInterface() {
        if (photosetsInterface == null) {
            photosetsInterface = new PhotosetsInterface(apiKey, sharedSecret, transport);
        }
        return photosetsInterface;
    }

    public CollectionsInterface getCollectionsInterface() {
        if (collectionsInterface == null) {
            collectionsInterface = new CollectionsInterface(apiKey, sharedSecret, transport);
        }
        return collectionsInterface;
    }

    public PlacesInterface getPlacesInterface() {
        if (placesInterface == null) {
            placesInterface = new PlacesInterface(apiKey, sharedSecret, transport);
        }
        return placesInterface;
    }

    public PrefsInterface getPrefsInterface() {
        if (prefsInterface == null) {
            prefsInterface = new PrefsInterface(apiKey, sharedSecret, transport);
        }
        return prefsInterface;
    }

    public ReflectionInterface getReflectionInterface() {
        if (reflectionInterface == null) {
            reflectionInterface = new ReflectionInterface(apiKey, sharedSecret, transport);
        }
        return reflectionInterface;
    }

    /**
     * Get the TagsInterface for working with Flickr Tags.
     * 
     * @return The TagsInterface
     */
    public TagsInterface getTagsInterface() {
        if (tagsInterface == null) {
            tagsInterface = new TagsInterface(apiKey, sharedSecret, transport);
        }
        return tagsInterface;
    }

    public TestInterface getTestInterface() {
        if (testInterface == null) {
            testInterface = new TestInterface(apiKey, sharedSecret, transport);
        }
        return testInterface;
    }

    public TransformInterface getTransformInterface() {
        if (transformInterface == null) {
            transformInterface = new TransformInterface(apiKey, sharedSecret, transport);
        }
        return transformInterface;
    }

    public UploadInterface getUploadInterface() {
        if (uploadInterface == null) {
            uploadInterface = new UploadInterface(apiKey, sharedSecret, transport);
        }
        return uploadInterface;
    }

    public Uploader getUploader() {
        if (uploader == null) {
            Transport uploadTransport = new TransportStub();
            uploader = new Uploader(apiKey, sharedSecret, uploadTransport);
        }
        return uploader;
    }

    public UrlsInterface getUrlsInterface() {
        if (urlsInterface == null) {
            urlsInterface = new UrlsInterface(apiKey, sharedSecret, transport);
        }
        return urlsInterface;
    }

    public GalleriesInterface getGalleriesInterface() {
        if (galleriesInterface == null) {
            galleriesInterface = new GalleriesInterface(apiKey, sharedSecret, transport);
        }
        return galleriesInterface;
    }

    public StatsInterface getStatsInterface() {
        if (statsInterface == null) {
            statsInterface = new StatsInterface(apiKey, sharedSecret, transport);
        }
        return statsInterface;
    }

    public CamerasInterface getCamerasInterface() {
        if (cameraInterface == null) {
            cameraInterface = new CamerasInterface(apiKey, sharedSecret, transport);
        }
        return cameraInterface;
    }

    /**
     * Get the SuggestionsInterface.
     * 
     * @return The SuggestionsInterface
     */
    public SuggestionsInterface getSuggestionsInterface() {
        if (suggestionsInterface == null) {
            suggestionsInterface = new SuggestionsInterface(apiKey, sharedSecret, transport);
        }
        return suggestionsInterface;
    }

    /**
     * Get the GroupDiscussInterface.
     * 
     * @return The GroupDiscussInterface
     */

    public GroupDiscussInterface getDiscussionInterface() {
        if (discussionInterface == null) {
            discussionInterface = new GroupDiscussInterface(apiKey, sharedSecret, transport);
        }
        return discussionInterface;
    }

}
","package com.flickr4java.flickr.test.util; public class FlickrStub implements IFlickr { private String apiKey; private String sharedSecret; private Transport transport; private Auth auth; private AuthInterface authInterface; private ActivityInterface activityInterface; private BlogsInterface blogsInterface; private CommentsInterface commentsInterface; private CommonsInterface commonsInterface; private ContactsInterface contactsInterface; private FavoritesInterface favoritesInterface; private GeoInterface geoInterface; private GroupsInterface groupsInterface; private InterestingnessInterface interestingnessInterface; private LicensesInterface licensesInterface; private MembersInterface membersInterface; private MachinetagsInterface machinetagsInterface; private NotesInterface notesInterface; private PandaInterface pandaInterface; private PoolsInterface poolsInterface; private PeopleInterface peopleInterface; private PhotosInterface photosInterface; private PhotosetsCommentsInterface photosetsCommentsInterface; private PhotosetsInterface photosetsInterface; private CollectionsInterface collectionsInterface; private PlacesInterface placesInterface; private PrefsInterface prefsInterface; private ReflectionInterface reflectionInterface; private TagsInterface tagsInterface; private TestInterface testInterface; private TransformInterface transformInterface; private UploadInterface uploadInterface; private Uploader uploader; private UrlsInterface urlsInterface; private GalleriesInterface galleriesInterface; private StatsInterface statsInterface; private CamerasInterface cameraInterface; private SuggestionsInterface suggestionsInterface; private GroupDiscussInterface discussionInterface; public FlickrStub() { transport = new TransportStub(); } public String getApiKey() { return apiKey; } public void setApiKey(String apiKey) { if (apiKey == null) { throw new IllegalArgumentException(""API key must not be null""); } this.apiKey = apiKey; } public void setAuth(Auth auth) { this.auth = auth; } public Auth getAuth() { return auth; } public String getSharedSecret() { return sharedSecret; } public void setSharedSecret(String sharedSecret) { if (sharedSecret == null) { throw new IllegalArgumentException(""Shared-Secret must not be null""); } this.sharedSecret = sharedSecret; } public Transport getTransport() { return transport; } public void setTransport(Transport transport) { if (transport == null) { throw new IllegalArgumentException(""Transport must not be null""); } this.transport = transport; } public AuthInterface getAuthInterface() { if (authInterface == null) { authInterface = new AuthInterface(apiKey, sharedSecret, transport); } return authInterface; } public ActivityInterface getActivityInterface() { if (activityInterface == null) { activityInterface = new ActivityInterface(apiKey, sharedSecret, transport); } return activityInterface; } public BlogsInterface getBlogsInterface() { if (blogsInterface == null) { blogsInterface = new BlogsInterface(apiKey, sharedSecret, transport); } return blogsInterface; } public CommentsInterface getCommentsInterface() { if (commentsInterface == null) { commentsInterface = new CommentsInterface(apiKey, sharedSecret, transport); } return commentsInterface; } public CommonsInterface getCommonsInterface() { if (commonsInterface == null) { commonsInterface = new CommonsInterface(apiKey, sharedSecret, transport); } return commonsInterface; } public ContactsInterface getContactsInterface() { if (contactsInterface == null) { contactsInterface = new ContactsInterface(apiKey, sharedSecret, transport); } return contactsInterface; } public FavoritesInterface getFavoritesInterface() { if (favoritesInterface == null) { favoritesInterface = new FavoritesInterface(apiKey, sharedSecret, transport); } return favoritesInterface; } public GeoInterface getGeoInterface() { if (geoInterface == null) { geoInterface = new GeoInterface(apiKey, sharedSecret, transport); } return geoInterface; } public GroupsInterface getGroupsInterface() { if (groupsInterface == null) { groupsInterface = new GroupsInterface(apiKey, sharedSecret, transport); } return groupsInterface; } public InterestingnessInterface getInterestingnessInterface() { if (interestingnessInterface == null) { interestingnessInterface = new InterestingnessInterface(apiKey, sharedSecret, transport); } return interestingnessInterface; } public LicensesInterface getLicensesInterface() { if (licensesInterface == null) { licensesInterface = new LicensesInterface(apiKey, sharedSecret, transport); } return licensesInterface; } public MachinetagsInterface getMachinetagsInterface() { if (machinetagsInterface == null) { machinetagsInterface = new MachinetagsInterface(apiKey, sharedSecret, transport); } return machinetagsInterface; } public MembersInterface getMembersInterface() { if (membersInterface == null) { membersInterface = new MembersInterface(apiKey, sharedSecret, transport); } return membersInterface; } public NotesInterface getNotesInterface() { if (notesInterface == null) { notesInterface = new NotesInterface(apiKey, sharedSecret, transport); } return notesInterface; } public PandaInterface getPandaInterface() { if (pandaInterface == null) { pandaInterface = new PandaInterface(apiKey, sharedSecret, transport); } return pandaInterface; } public PoolsInterface getPoolsInterface() { if (poolsInterface == null) { poolsInterface = new PoolsInterface(apiKey, sharedSecret, transport); } return poolsInterface; } public PeopleInterface getPeopleInterface() { if (peopleInterface == null) { peopleInterface = new PeopleInterface(apiKey, sharedSecret, transport); } return peopleInterface; } public PhotosInterface getPhotosInterface() { if (photosInterface == null) { photosInterface = new PhotosInterface(apiKey, sharedSecret, transport); } return photosInterface; } public PhotosetsCommentsInterface getPhotosetsCommentsInterface() { if (photosetsCommentsInterface == null) { photosetsCommentsInterface = new PhotosetsCommentsInterface(apiKey, sharedSecret, transport); } return photosetsCommentsInterface; } public PhotosetsInterface getPhotosetsInterface() { if (photosetsInterface == null) { photosetsInterface = new PhotosetsInterface(apiKey, sharedSecret, transport); } return photosetsInterface; } public CollectionsInterface getCollectionsInterface() { if (collectionsInterface == null) { collectionsInterface = new CollectionsInterface(apiKey, sharedSecret, transport); } return collectionsInterface; } public PlacesInterface getPlacesInterface() { if (placesInterface == null) { placesInterface = new PlacesInterface(apiKey, sharedSecret, transport); } return placesInterface; } public PrefsInterface getPrefsInterface() { if (prefsInterface == null) { prefsInterface = new PrefsInterface(apiKey, sharedSecret, transport); } return prefsInterface; } public ReflectionInterface getReflectionInterface() { if (reflectionInterface == null) { reflectionInterface = new ReflectionInterface(apiKey, sharedSecret, transport); } return reflectionInterface; } public TagsInterface getTagsInterface() { if (tagsInterface == null) { tagsInterface = new TagsInterface(apiKey, sharedSecret, transport); } return tagsInterface; } public TestInterface getTestInterface() { if (testInterface == null) { testInterface = new TestInterface(apiKey, sharedSecret, transport); } return testInterface; } public TransformInterface getTransformInterface() { if (transformInterface == null) { transformInterface = new TransformInterface(apiKey, sharedSecret, transport); } return transformInterface; } public UploadInterface getUploadInterface() { if (uploadInterface == null) { uploadInterface = new UploadInterface(apiKey, sharedSecret, transport); } return uploadInterface; } public Uploader getUploader() { if (uploader == null) { Transport uploadTransport = new TransportStub(); uploader = new Uploader(apiKey, sharedSecret, uploadTransport); } return uploader; } public UrlsInterface getUrlsInterface() { if (urlsInterface == null) { urlsInterface = new UrlsInterface(apiKey, sharedSecret, transport); } return urlsInterface; } public GalleriesInterface getGalleriesInterface() { if (galleriesInterface == null) { galleriesInterface = new GalleriesInterface(apiKey, sharedSecret, transport); } return galleriesInterface; } public StatsInterface getStatsInterface() { if (statsInterface == null) { statsInterface = new StatsInterface(apiKey, sharedSecret, transport); } return statsInterface; } public CamerasInterface getCamerasInterface() { if (cameraInterface == null) { cameraInterface = new CamerasInterface(apiKey, sharedSecret, transport); } return cameraInterface; } public SuggestionsInterface getSuggestionsInterface() { if (suggestionsInterface == null) { suggestionsInterface = new SuggestionsInterface(apiKey, sharedSecret, transport); } return suggestionsInterface; } public GroupDiscussInterface getDiscussionInterface() { if (discussionInterface == null) { discussionInterface = new GroupDiscussInterface(apiKey, sharedSecret, transport); } return discussionInterface; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test.util; public class FlickrStub implements IFlickr { private String apiKey; private String sharedSecret; private Transport transport; private Auth auth; private AuthInterface authInterface; private ActivityInterface activityInterface; private BlogsInterface blogsInterface; private CommentsInterface commentsInterface; private CommonsInterface commonsInterface; private ContactsInterface contactsInterface; private FavoritesInterface favoritesInterface; private GeoInterface geoInterface; private GroupsInterface groupsInterface; private InterestingnessInterface interestingnessInterface; private LicensesInterface licensesInterface; private MembersInterface membersInterface; private MachinetagsInterface machinetagsInterface; private NotesInterface notesInterface; private PandaInterface pandaInterface; private PoolsInterface poolsInterface; private PeopleInterface peopleInterface; private PhotosInterface photosInterface; private PhotosetsCommentsInterface photosetsCommentsInterface; private PhotosetsInterface photosetsInterface; private CollectionsInterface collectionsInterface; private PlacesInterface placesInterface; private PrefsInterface prefsInterface; private ReflectionInterface reflectionInterface; private TagsInterface tagsInterface; private TestInterface testInterface; private TransformInterface transformInterface; private UploadInterface uploadInterface; private Uploader uploader; private UrlsInterface urlsInterface; private GalleriesInterface galleriesInterface; private StatsInterface statsInterface; private CamerasInterface cameraInterface; private SuggestionsInterface suggestionsInterface; private GroupDiscussInterface discussionInterface; public FlickrStub() { transport = new TransportStub(); } public String getApiKey() { return apiKey; } public void setApiKey(String apiKey) { if (apiKey == null) { throw new IllegalArgumentException(""API key must not be null""); } this.apiKey = apiKey; } public void setAuth(Auth auth) { this.auth = auth; } public Auth getAuth() { return auth; } public String getSharedSecret() { return sharedSecret; } public void setSharedSecret(String sharedSecret) { if (sharedSecret == null) { throw new IllegalArgumentException(""Shared-Secret must not be null""); } this.sharedSecret = sharedSecret; } public Transport getTransport() { return transport; } public void setTransport(Transport transport) { if (transport == null) { throw new IllegalArgumentException(""Transport must not be null""); } this.transport = transport; } public AuthInterface getAuthInterface() { if (authInterface == null) { authInterface = new AuthInterface(apiKey, sharedSecret, transport); } return authInterface; } public ActivityInterface getActivityInterface() { if (activityInterface == null) { activityInterface = new ActivityInterface(apiKey, sharedSecret, transport); } return activityInterface; } public BlogsInterface getBlogsInterface() { if (blogsInterface == null) { blogsInterface = new BlogsInterface(apiKey, sharedSecret, transport); } return blogsInterface; } public CommentsInterface getCommentsInterface() { if (commentsInterface == null) { commentsInterface = new CommentsInterface(apiKey, sharedSecret, transport); } return commentsInterface; } public CommonsInterface getCommonsInterface() { if (commonsInterface == null) { commonsInterface = new CommonsInterface(apiKey, sharedSecret, transport); } return commonsInterface; } public ContactsInterface getContactsInterface() { if (contactsInterface == null) { contactsInterface = new ContactsInterface(apiKey, sharedSecret, transport); } return contactsInterface; } public FavoritesInterface getFavoritesInterface() { if (favoritesInterface == null) { favoritesInterface = new FavoritesInterface(apiKey, sharedSecret, transport); } return favoritesInterface; } public GeoInterface getGeoInterface() { if (geoInterface == null) { geoInterface = new GeoInterface(apiKey, sharedSecret, transport); } return geoInterface; } public GroupsInterface getGroupsInterface() { if (groupsInterface == null) { groupsInterface = new GroupsInterface(apiKey, sharedSecret, transport); } return groupsInterface; } public InterestingnessInterface getInterestingnessInterface() { if (interestingnessInterface == null) { interestingnessInterface = new InterestingnessInterface(apiKey, sharedSecret, transport); } return interestingnessInterface; } public LicensesInterface getLicensesInterface() { if (licensesInterface == null) { licensesInterface = new LicensesInterface(apiKey, sharedSecret, transport); } return licensesInterface; } public MachinetagsInterface getMachinetagsInterface() { if (machinetagsInterface == null) { machinetagsInterface = new MachinetagsInterface(apiKey, sharedSecret, transport); } return machinetagsInterface; } public MembersInterface getMembersInterface() { if (membersInterface == null) { membersInterface = new MembersInterface(apiKey, sharedSecret, transport); } return membersInterface; } public NotesInterface getNotesInterface() { if (notesInterface == null) { notesInterface = new NotesInterface(apiKey, sharedSecret, transport); } return notesInterface; } public PandaInterface getPandaInterface() { if (pandaInterface == null) { pandaInterface = new PandaInterface(apiKey, sharedSecret, transport); } return pandaInterface; } public PoolsInterface getPoolsInterface() { if (poolsInterface == null) { poolsInterface = new PoolsInterface(apiKey, sharedSecret, transport); } return poolsInterface; } public PeopleInterface getPeopleInterface() { if (peopleInterface == null) { peopleInterface = new PeopleInterface(apiKey, sharedSecret, transport); } return peopleInterface; } public PhotosInterface getPhotosInterface() { if (photosInterface == null) { photosInterface = new PhotosInterface(apiKey, sharedSecret, transport); } return photosInterface; } public PhotosetsCommentsInterface getPhotosetsCommentsInterface() { if (photosetsCommentsInterface == null) { photosetsCommentsInterface = new PhotosetsCommentsInterface(apiKey, sharedSecret, transport); } return photosetsCommentsInterface; } public PhotosetsInterface getPhotosetsInterface() { if (photosetsInterface == null) { photosetsInterface = new PhotosetsInterface(apiKey, sharedSecret, transport); } return photosetsInterface; } public CollectionsInterface getCollectionsInterface() { if (collectionsInterface == null) { collectionsInterface = new CollectionsInterface(apiKey, sharedSecret, transport); } return collectionsInterface; } public PlacesInterface getPlacesInterface() { if (placesInterface == null) { placesInterface = new PlacesInterface(apiKey, sharedSecret, transport); } return placesInterface; } public PrefsInterface getPrefsInterface() { if (prefsInterface == null) { prefsInterface = new PrefsInterface(apiKey, sharedSecret, transport); } return prefsInterface; } public ReflectionInterface getReflectionInterface() { if (reflectionInterface == null) { reflectionInterface = new ReflectionInterface(apiKey, sharedSecret, transport); } return reflectionInterface; } public TagsInterface getTagsInterface() { if (tagsInterface == null) { tagsInterface = new TagsInterface(apiKey, sharedSecret, transport); } return tagsInterface; } public TestInterface getTestInterface() { if (testInterface == null) { testInterface = new TestInterface(apiKey, sharedSecret, transport); } return testInterface; } public TransformInterface getTransformInterface() { if (transformInterface == null) { transformInterface = new TransformInterface(apiKey, sharedSecret, transport); } return transformInterface; } public UploadInterface getUploadInterface() { if (uploadInterface == null) { uploadInterface = new UploadInterface(apiKey, sharedSecret, transport); } return uploadInterface; } public Uploader getUploader() { if (uploader == null) { Transport uploadTransport = new TransportStub(); uploader = new Uploader(apiKey, sharedSecret, uploadTransport); } return uploader; } public UrlsInterface getUrlsInterface() { if (urlsInterface == null) { urlsInterface = new UrlsInterface(apiKey, sharedSecret, transport); } return urlsInterface; } public GalleriesInterface getGalleriesInterface() { if (galleriesInterface == null) { galleriesInterface = new GalleriesInterface(apiKey, sharedSecret, transport); } return galleriesInterface; } public StatsInterface getStatsInterface() { if (statsInterface == null) { statsInterface = new StatsInterface(apiKey, sharedSecret, transport); } return statsInterface; } public CamerasInterface getCamerasInterface() { if (cameraInterface == null) { cameraInterface = new CamerasInterface(apiKey, sharedSecret, transport); } return cameraInterface; } public SuggestionsInterface getSuggestionsInterface() { if (suggestionsInterface == null) { suggestionsInterface = new SuggestionsInterface(apiKey, sharedSecret, transport); } return suggestionsInterface; } public GroupDiscussInterface getDiscussionInterface() { if (discussionInterface == null) { discussionInterface = new GroupDiscussInterface(apiKey, sharedSecret, transport); } return discussionInterface; } } "," package com.flickr4java.flickr.test.util; 
import com.flickr4java.flickr.IFlickr; import com.flickr4java.flickr.Transport; import com.flickr4java.flickr.activity.ActivityInterface; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.auth.AuthInterface; import com.flickr4java.flickr.blogs.BlogsInterface; import com.flickr4java.flickr.cameras.CamerasInterface; import com.flickr4java.flickr.collections.CollectionsInterface; import com.flickr4java.flickr.commons.CommonsInterface; import com.flickr4java.flickr.contacts.ContactsInterface; import com.flickr4java.flickr.favorites.FavoritesInterface; import com.flickr4java.flickr.galleries.GalleriesInterface; import com.flickr4java.flickr.groups.GroupsInterface; import com.flickr4java.flickr.groups.discuss.GroupDiscussInterface; import com.flickr4java.flickr.groups.members.MembersInterface; import com.flickr4java.flickr.groups.pools.PoolsInterface; import com.flickr4java.flickr.interestingness.InterestingnessInterface; import com.flickr4java.flickr.machinetags.MachinetagsInterface; import com.flickr4java.flickr.panda.PandaInterface; import com.flickr4java.flickr.people.PeopleInterface; import com.flickr4java.flickr.photos.PhotosInterface; import com.flickr4java.flickr.photos.comments.CommentsInterface; import com.flickr4java.flickr.photos.geo.GeoInterface; import com.flickr4java.flickr.photos.licenses.LicensesInterface; import com.flickr4java.flickr.photos.notes.NotesInterface; import com.flickr4java.flickr.photos.suggestions.SuggestionsInterface; import com.flickr4java.flickr.photos.transform.TransformInterface; import com.flickr4java.flickr.photos.upload.UploadInterface; import com.flickr4java.flickr.photosets.PhotosetsInterface; import com.flickr4java.flickr.photosets.comments.PhotosetsCommentsInterface; import com.flickr4java.flickr.places.PlacesInterface; import com.flickr4java.flickr.prefs.PrefsInterface; import com.flickr4java.flickr.reflection.ReflectionInterface; import com.flickr4java.flickr.stats.StatsInterface; import com.flickr4java.flickr.tags.TagsInterface; import com.flickr4java.flickr.test.TestInterface; import com.flickr4java.flickr.uploader.Uploader; import com.flickr4java.flickr.urls.UrlsInterface;  /**
 * Stubbed entry point for the Flickr4Java API. This class is used to acquire Interface classes which wrap the Flickr API.
 *
 */ public class FlickrStub implements IFlickr {  private String apiKey;  private String sharedSecret;  private Transport transport;  private Auth auth;  private AuthInterface authInterface;  private ActivityInterface activityInterface;  private BlogsInterface blogsInterface;  private CommentsInterface commentsInterface;  private CommonsInterface commonsInterface;  private ContactsInterface contactsInterface;  private FavoritesInterface favoritesInterface;  private GeoInterface geoInterface;  private GroupsInterface groupsInterface;  private InterestingnessInterface interestingnessInterface;  private LicensesInterface licensesInterface;  private MembersInterface membersInterface;  private MachinetagsInterface machinetagsInterface;  private NotesInterface notesInterface;  private PandaInterface pandaInterface;  private PoolsInterface poolsInterface;  private PeopleInterface peopleInterface;  private PhotosInterface photosInterface;  private PhotosetsCommentsInterface photosetsCommentsInterface;  private PhotosetsInterface photosetsInterface;  private CollectionsInterface collectionsInterface;  private PlacesInterface placesInterface;  private PrefsInterface prefsInterface;  private ReflectionInterface reflectionInterface;  private TagsInterface tagsInterface;  private TestInterface testInterface;  private TransformInterface transformInterface;  private UploadInterface uploadInterface;  private Uploader uploader;  private UrlsInterface urlsInterface;  private GalleriesInterface galleriesInterface;  private StatsInterface statsInterface;  private CamerasInterface cameraInterface;  private SuggestionsInterface suggestionsInterface;  private GroupDiscussInterface discussionInterface;  /**
     * Construct a new stubbed Flickr instance.
     *
     */ public FlickrStub() { transport = new TransportStub(); }  /**
     * Get the API key.
     * 
     * @return The API key
     */ public String getApiKey() { return apiKey; }  /**
     * Set the API key to use which must not be null.
     * 
     * @param apiKey
     *            The API key which cannot be null
     */ public void setApiKey(String apiKey) { if (apiKey == null) { throw new IllegalArgumentException(""API key must not be null""); } this.apiKey = apiKey; }  public void setAuth(Auth auth) { this.auth = auth; }  /**
     * Get the Auth-object.
     * 
     * @return The Auth-object
     */ public Auth getAuth() { return auth; }  /**
     * Get the Shared-Secret.
     * 
     * @return The Shared-Secret
     */ public String getSharedSecret() { return sharedSecret; }  /**
     * Set the Shared-Secret to use which must not be null.
     * 
     * @param sharedSecret
     *            The Shared-Secret which cannot be null
     */ public void setSharedSecret(String sharedSecret) { if (sharedSecret == null) { throw new IllegalArgumentException(""Shared-Secret must not be null""); } this.sharedSecret = sharedSecret; }  /**
     * Get the Transport interface.
     * 
     * @return The Tranport interface
     */ public Transport getTransport() { return transport; }  /**
     * Set the Transport which must not be null.
     * 
     * @param transport
     */ public void setTransport(Transport transport) { if (transport == null) { throw new IllegalArgumentException(""Transport must not be null""); } this.transport = transport; }  /**
     * Get the AuthInterface.
     * 
     * @return The AuthInterface
     */ public AuthInterface getAuthInterface() { if (authInterface == null) { authInterface = new AuthInterface(apiKey, sharedSecret, transport); } return authInterface; }  /**
     * Get the ActivityInterface.
     * 
     * @return The ActivityInterface
     */ public ActivityInterface getActivityInterface() { if (activityInterface == null) { activityInterface = new ActivityInterface(apiKey, sharedSecret, transport); } return activityInterface; }  public BlogsInterface getBlogsInterface() { if (blogsInterface == null) { blogsInterface = new BlogsInterface(apiKey, sharedSecret, transport); } return blogsInterface; }  public CommentsInterface getCommentsInterface() { if (commentsInterface == null) { commentsInterface = new CommentsInterface(apiKey, sharedSecret, transport); } return commentsInterface; }  public CommonsInterface getCommonsInterface() { if (commonsInterface == null) { commonsInterface = new CommonsInterface(apiKey, sharedSecret, transport); } return commonsInterface; }  public ContactsInterface getContactsInterface() { if (contactsInterface == null) { contactsInterface = new ContactsInterface(apiKey, sharedSecret, transport); } return contactsInterface; }  public FavoritesInterface getFavoritesInterface() { if (favoritesInterface == null) { favoritesInterface = new FavoritesInterface(apiKey, sharedSecret, transport); } return favoritesInterface; }  public GeoInterface getGeoInterface() { if (geoInterface == null) { geoInterface = new GeoInterface(apiKey, sharedSecret, transport); } return geoInterface; }  public GroupsInterface getGroupsInterface() { if (groupsInterface == null) { groupsInterface = new GroupsInterface(apiKey, sharedSecret, transport); } return groupsInterface; }  /**
     * @return the interface to the flickr.interestingness methods
     */ public InterestingnessInterface getInterestingnessInterface() { if (interestingnessInterface == null) { interestingnessInterface = new InterestingnessInterface(apiKey, sharedSecret, transport); } return interestingnessInterface; }  public LicensesInterface getLicensesInterface() { if (licensesInterface == null) { licensesInterface = new LicensesInterface(apiKey, sharedSecret, transport); } return licensesInterface; }  public MachinetagsInterface getMachinetagsInterface() { if (machinetagsInterface == null) { machinetagsInterface = new MachinetagsInterface(apiKey, sharedSecret, transport); } return machinetagsInterface; }  public MembersInterface getMembersInterface() { if (membersInterface == null) { membersInterface = new MembersInterface(apiKey, sharedSecret, transport); } return membersInterface; }  public NotesInterface getNotesInterface() { if (notesInterface == null) { notesInterface = new NotesInterface(apiKey, sharedSecret, transport); } return notesInterface; }  public PandaInterface getPandaInterface() { if (pandaInterface == null) { pandaInterface = new PandaInterface(apiKey, sharedSecret, transport); } return pandaInterface; }  public PoolsInterface getPoolsInterface() { if (poolsInterface == null) { poolsInterface = new PoolsInterface(apiKey, sharedSecret, transport); } return poolsInterface; }  public PeopleInterface getPeopleInterface() { if (peopleInterface == null) { peopleInterface = new PeopleInterface(apiKey, sharedSecret, transport); } return peopleInterface; }  public PhotosInterface getPhotosInterface() { if (photosInterface == null) { photosInterface = new PhotosInterface(apiKey, sharedSecret, transport); } return photosInterface; }  public PhotosetsCommentsInterface getPhotosetsCommentsInterface() { if (photosetsCommentsInterface == null) { photosetsCommentsInterface = new PhotosetsCommentsInterface(apiKey, sharedSecret, transport); } return photosetsCommentsInterface; }  public PhotosetsInterface getPhotosetsInterface() { if (photosetsInterface == null) { photosetsInterface = new PhotosetsInterface(apiKey, sharedSecret, transport); } return photosetsInterface; }  public CollectionsInterface getCollectionsInterface() { if (collectionsInterface == null) { collectionsInterface = new CollectionsInterface(apiKey, sharedSecret, transport); } return collectionsInterface; }  public PlacesInterface getPlacesInterface() { if (placesInterface == null) { placesInterface = new PlacesInterface(apiKey, sharedSecret, transport); } return placesInterface; }  public PrefsInterface getPrefsInterface() { if (prefsInterface == null) { prefsInterface = new PrefsInterface(apiKey, sharedSecret, transport); } return prefsInterface; }  public ReflectionInterface getReflectionInterface() { if (reflectionInterface == null) { reflectionInterface = new ReflectionInterface(apiKey, sharedSecret, transport); } return reflectionInterface; }  /**
     * Get the TagsInterface for working with Flickr Tags.
     * 
     * @return The TagsInterface
     */ public TagsInterface getTagsInterface() { if (tagsInterface == null) { tagsInterface = new TagsInterface(apiKey, sharedSecret, transport); } return tagsInterface; }  public TestInterface getTestInterface() { if (testInterface == null) { testInterface = new TestInterface(apiKey, sharedSecret, transport); } return testInterface; }  public TransformInterface getTransformInterface() { if (transformInterface == null) { transformInterface = new TransformInterface(apiKey, sharedSecret, transport); } return transformInterface; }  public UploadInterface getUploadInterface() { if (uploadInterface == null) { uploadInterface = new UploadInterface(apiKey, sharedSecret, transport); } return uploadInterface; }  public Uploader getUploader() { if (uploader == null) { Transport uploadTransport = new TransportStub(); uploader = new Uploader(apiKey, sharedSecret, uploadTransport); } return uploader; }  public UrlsInterface getUrlsInterface() { if (urlsInterface == null) { urlsInterface = new UrlsInterface(apiKey, sharedSecret, transport); } return urlsInterface; }  public GalleriesInterface getGalleriesInterface() { if (galleriesInterface == null) { galleriesInterface = new GalleriesInterface(apiKey, sharedSecret, transport); } return galleriesInterface; }  public StatsInterface getStatsInterface() { if (statsInterface == null) { statsInterface = new StatsInterface(apiKey, sharedSecret, transport); } return statsInterface; }  public CamerasInterface getCamerasInterface() { if (cameraInterface == null) { cameraInterface = new CamerasInterface(apiKey, sharedSecret, transport); } return cameraInterface; }  /**
     * Get the SuggestionsInterface.
     * 
     * @return The SuggestionsInterface
     */ public SuggestionsInterface getSuggestionsInterface() { if (suggestionsInterface == null) { suggestionsInterface = new SuggestionsInterface(apiKey, sharedSecret, transport); } return suggestionsInterface; }  /**
     * Get the GroupDiscussInterface.
     * 
     * @return The GroupDiscussInterface
     */  public GroupDiscussInterface getDiscussionInterface() { if (discussionInterface == null) { discussionInterface = new GroupDiscussInterface(apiKey, sharedSecret, transport); } return discussionInterface; }  }  "
src/test/java/com/flickr4java/flickr/test/util/Setup.java,"package com.flickr4java.flickr.test.util;

import com.flickr4java.flickr.Flickr;
import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.REST;
import com.flickr4java.flickr.auth.Auth;
import com.flickr4java.flickr.auth.AuthInterface;
import com.flickr4java.flickr.auth.Permission;
import com.github.scribejava.core.model.OAuth1RequestToken;
import com.github.scribejava.core.model.OAuth1Token;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Properties;
import java.util.Scanner;

public class Setup {

    public static void main(String[] args) {
        System.out.println(""Flickr4Java: Set up integration test environment"");
        try {
            new Setup();
        } catch (IOException | FlickrException e) {
            e.printStackTrace();
        }
    }

    public Setup() throws IOException, FlickrException {
        String propertiesFile = ""src/test/resources/setup.properties"";
        Properties properties = new Properties();
        properties.load(new FileInputStream(propertiesFile));

        Flickr flickr = new Flickr(properties.getProperty(""apiKey""), properties.getProperty(""secret""), new REST());
        Flickr.debugStream = false;
        AuthInterface authInterface = flickr.getAuthInterface();

        Scanner scanner = new Scanner(System.in);

        OAuth1RequestToken requestToken = authInterface.getRequestToken();

        String url = authInterface.getAuthorizationUrl(requestToken, Permission.DELETE);
        System.out.println(""Follow this URL to authorise yourself on Flickr"");
        System.out.println(url);
        System.out.println(""Paste in the token it gives you:"");
        System.out.print("">> "");

        String tokenKey = scanner.nextLine().trim();

        OAuth1Token accessToken = authInterface.getAccessToken(requestToken, tokenKey);
        System.out.println(""Authentication success"");

        Auth auth = authInterface.checkToken(accessToken);

        properties.setProperty(""token"", accessToken.getToken());
        properties.setProperty(""tokensecret"", accessToken.getTokenSecret());
        properties.store(new FileOutputStream(propertiesFile), """");

        // This token can be used until the user revokes it.
        System.out.println(""Access token - token  = "" + accessToken.getToken());
        System.out.println(""             - secret = "" + accessToken.getTokenSecret());
        System.out.println(""(These have been saved to the properties file.)"");
        System.out.println(""Realname: "" + auth.getUser().getRealName());
        System.out.println(""Username: "" + auth.getUser().getUsername());
        System.out.println(""Permission: "" + auth.getPermission().getType());
    }
}
","package com.flickr4java.flickr.test.util; public class Setup { public static void main(String[] args) { System.out.println(""Flickr4Java: Set up integration test environment""); try { new Setup(); } catch (IOException | FlickrException e) { e.printStackTrace(); } } public Setup() throws IOException, FlickrException { String propertiesFile = ""src/test/resources/setup.properties""; Properties properties = new Properties(); properties.load(new FileInputStream(propertiesFile)); Flickr flickr = new Flickr(properties.getProperty(""apiKey""), properties.getProperty(""secret""), new REST()); Flickr.debugStream = false; AuthInterface authInterface = flickr.getAuthInterface(); Scanner scanner = new Scanner(System.in); OAuth1RequestToken requestToken = authInterface.getRequestToken(); String url = authInterface.getAuthorizationUrl(requestToken, Permission.DELETE); System.out.println(""Follow this URL to authorise yourself on Flickr""); System.out.println(url); System.out.println(""Paste in the token it gives you:""); System.out.print("">> ""); String tokenKey = scanner.nextLine().trim(); OAuth1Token accessToken = authInterface.getAccessToken(requestToken, tokenKey); System.out.println(""Authentication success""); Auth auth = authInterface.checkToken(accessToken); properties.setProperty(""token"", accessToken.getToken()); properties.setProperty(""tokensecret"", accessToken.getTokenSecret()); properties.store(new FileOutputStream(propertiesFile), """"); System.out.println(""Access token - token  = "" + accessToken.getToken()); System.out.println(""             - secret = "" + accessToken.getTokenSecret()); System.out.println(""(These have been saved to the properties file.)""); System.out.println(""Realname: "" + auth.getUser().getRealName()); System.out.println(""Username: "" + auth.getUser().getUsername()); System.out.println(""Permission: "" + auth.getPermission().getType()); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test.util; public class Setup { public static void main(String[] args) { System.out.println(""Flickr4Java: Set up integration test environment""); try { new Setup(); } catch (IOException | FlickrException e) { e.printStackTrace(); } } public Setup() throws IOException, FlickrException { String propertiesFile = ""src/test/resources/setup.properties""; Properties properties = new Properties(); properties.load(new FileInputStream(propertiesFile)); Flickr flickr = new Flickr(properties.getProperty(""apiKey""), properties.getProperty(""secret""), new REST()); Flickr.debugStream = false; AuthInterface authInterface = flickr.getAuthInterface(); Scanner scanner = new Scanner(System.in); OAuth1RequestToken requestToken = authInterface.getRequestToken(); String url = authInterface.getAuthorizationUrl(requestToken, Permission.DELETE); System.out.println(""Follow this URL to authorise yourself on Flickr""); System.out.println(url); System.out.println(""Paste in the token it gives you:""); System.out.print("">> ""); String tokenKey = scanner.nextLine().trim(); OAuth1Token accessToken = authInterface.getAccessToken(requestToken, tokenKey); System.out.println(""Authentication success""); Auth auth = authInterface.checkToken(accessToken); properties.setProperty(""token"", accessToken.getToken()); properties.setProperty(""tokensecret"", accessToken.getTokenSecret()); properties.store(new FileOutputStream(propertiesFile), """"); System.out.println(""Access token - token  = "" + accessToken.getToken()); System.out.println(""             - secret = "" + accessToken.getTokenSecret()); System.out.println(""(These have been saved to the properties file.)""); System.out.println(""Realname: "" + auth.getUser().getRealName()); System.out.println(""Username: "" + auth.getUser().getUsername()); System.out.println(""Permission: "" + auth.getPermission().getType()); } } ","package com.flickr4java.flickr.test.util; 
import com.flickr4java.flickr.Flickr; import com.flickr4java.flickr.FlickrException; import com.flickr4java.flickr.REST; import com.flickr4java.flickr.auth.Auth; import com.flickr4java.flickr.auth.AuthInterface; import com.flickr4java.flickr.auth.Permission; import com.github.scribejava.core.model.OAuth1RequestToken; import com.github.scribejava.core.model.OAuth1Token; 
import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.util.Properties; import java.util.Scanner;  public class Setup {  public static void main(String[] args) { System.out.println(""Flickr4Java: Set up integration test environment""); try { new Setup(); } catch (IOException | FlickrException e) { e.printStackTrace(); } }  public Setup() throws IOException, FlickrException { String propertiesFile = ""src/test/resources/setup.properties""; Properties properties = new Properties(); properties.load(new FileInputStream(propertiesFile));  Flickr flickr = new Flickr(properties.getProperty(""apiKey""), properties.getProperty(""secret""), new REST()); Flickr.debugStream = false; AuthInterface authInterface = flickr.getAuthInterface();  Scanner scanner = new Scanner(System.in);  OAuth1RequestToken requestToken = authInterface.getRequestToken();  String url = authInterface.getAuthorizationUrl(requestToken, Permission.DELETE); System.out.println(""Follow this URL to authorise yourself on Flickr""); System.out.println(url); System.out.println(""Paste in the token it gives you:""); System.out.print("">> "");  String tokenKey = scanner.nextLine().trim();  OAuth1Token accessToken = authInterface.getAccessToken(requestToken, tokenKey); System.out.println(""Authentication success"");  Auth auth = authInterface.checkToken(accessToken);  properties.setProperty(""token"", accessToken.getToken()); properties.setProperty(""tokensecret"", accessToken.getTokenSecret()); properties.store(new FileOutputStream(propertiesFile), """");  // This token can be used until the user revokes it. System.out.println(""Access token - token  = "" + accessToken.getToken()); System.out.println(""             - secret = "" + accessToken.getTokenSecret()); System.out.println(""(These have been saved to the properties file.)""); System.out.println(""Realname: "" + auth.getUser().getRealName()); System.out.println(""Username: "" + auth.getUser().getUsername()); System.out.println(""Permission: "" + auth.getPermission().getType()); } }  "
src/test/java/com/flickr4java/flickr/test/util/StubTestProperties.java,"package com.flickr4java.flickr.test.util;

import java.util.Arrays;
import java.util.List;

/**
 * TestProperties for stubbed out unit tests.
 *
 * Values are not sent to Flickr so don't have to be real.
 */
public class StubTestProperties implements TestProperties {

    @Override
    public String getHost() {
        return ""localhost"";
    }

    @Override
    public String getApiKey() {
        return ""FAKE_API_KEY"";
    }

    @Override
    public String getSecret() {
        return ""FAKE_SECRET"";
    }

    @Override
    public String getToken() {
        return ""FAKE_TOKEN"";
    }

    @Override
    public String getTokenSecret() {
        return ""FAKE_TOKEN_SECRET"";
    }

    @Override
    public String getNsid() {
        return ""24573443@N04"";
    }

    @Override
    public String getEmail() {
        return ""EMAIL"";
    }

    @Override
    public String getUsername() {
        return ""boncey_test"";
    }

    @Override
    public String getGroupId() {
        return ""34427469792@N01"";
    }

    @Override
    public String getTestGroupId() {
        return ""12345"";
    }

    @Override
    public String getPhotoId() {
        return ""5628095432"";
    }

    @Override
    public String getPhotosetId() {
        return ""12345"";
    }

    @Override
    public String getImageFile() {
        return ""FILE"";
    }

    @Override
    public String getGeoWritePhotoId() {
        return ""12345"";
    }

    @Override
    public String getCollectionId() {
        return ""12345"";
    }

    @Override
    public String getCollectionUrlId() {
        return ""12345"";
    }

    @Override
    public String getGalleryId() {
        return ""72157634925210101"";
    }

    @Override
    public String getDisplayname() {
        return ""Darren Greaves"";
    }

    @Override
    public List<String> getPhotosetPhotos() {
        return Arrays.asList(""5628122182"", ""5628111146"", ""4169948514"");
    }

    @Override
    public boolean isRealFlickr() {
        return false;
    }
}
","package com.flickr4java.flickr.test.util; public class StubTestProperties implements TestProperties { @Override
    public String getHost() { return ""localhost""; } @Override
    public String getApiKey() { return ""FAKE_API_KEY""; } @Override
    public String getSecret() { return ""FAKE_SECRET""; } @Override
    public String getToken() { return ""FAKE_TOKEN""; } @Override
    public String getTokenSecret() { return ""FAKE_TOKEN_SECRET""; } @Override
    public String getNsid() { return ""24573443@N04""; } @Override
    public String getEmail() { return ""EMAIL""; } @Override
    public String getUsername() { return ""boncey_test""; } @Override
    public String getGroupId() { return ""34427469792@N01""; } @Override
    public String getTestGroupId() { return ""12345""; } @Override
    public String getPhotoId() { return ""5628095432""; } @Override
    public String getPhotosetId() { return ""12345""; } @Override
    public String getImageFile() { return ""FILE""; } @Override
    public String getGeoWritePhotoId() { return ""12345""; } @Override
    public String getCollectionId() { return ""12345""; } @Override
    public String getCollectionUrlId() { return ""12345""; } @Override
    public String getGalleryId() { return ""72157634925210101""; } @Override
    public String getDisplayname() { return ""Darren Greaves""; } @Override
    public List<String> getPhotosetPhotos() { return Arrays.asList(""5628122182"", ""5628111146"", ""4169948514""); } @Override
    public boolean isRealFlickr() { return false; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test.util; public class StubTestProperties implements TestProperties { @Override
    public String getHost() { return ""localhost""; } @Override
    public String getApiKey() { return ""FAKE_API_KEY""; } @Override
    public String getSecret() { return ""FAKE_SECRET""; } @Override
    public String getToken() { return ""FAKE_TOKEN""; } @Override
    public String getTokenSecret() { return ""FAKE_TOKEN_SECRET""; } @Override
    public String getNsid() { return ""24573443@N04""; } @Override
    public String getEmail() { return ""EMAIL""; } @Override
    public String getUsername() { return ""boncey_test""; } @Override
    public String getGroupId() { return ""34427469792@N01""; } @Override
    public String getTestGroupId() { return ""12345""; } @Override
    public String getPhotoId() { return ""5628095432""; } @Override
    public String getPhotosetId() { return ""12345""; } @Override
    public String getImageFile() { return ""FILE""; } @Override
    public String getGeoWritePhotoId() { return ""12345""; } @Override
    public String getCollectionId() { return ""12345""; } @Override
    public String getCollectionUrlId() { return ""12345""; } @Override
    public String getGalleryId() { return ""72157634925210101""; } @Override
    public String getDisplayname() { return ""Darren Greaves""; } @Override
    public List<String> getPhotosetPhotos() { return Arrays.asList(""5628122182"", ""5628111146"", ""4169948514""); } @Override
    public boolean isRealFlickr() { return false; } } ","package com.flickr4java.flickr.test.util; 
import java.util.Arrays; import java.util.List;  /**
 * TestProperties for stubbed out unit tests.
 *
 * Values are not sent to Flickr so don't have to be real.
 */ public class StubTestProperties implements TestProperties {  @Override
    public String getHost() { return ""localhost""; }  @Override
    public String getApiKey() { return ""FAKE_API_KEY""; }  @Override
    public String getSecret() { return ""FAKE_SECRET""; }  @Override
    public String getToken() { return ""FAKE_TOKEN""; }  @Override
    public String getTokenSecret() { return ""FAKE_TOKEN_SECRET""; }  @Override
    public String getNsid() { return ""24573443@N04""; }  @Override
    public String getEmail() { return ""EMAIL""; }  @Override
    public String getUsername() { return ""boncey_test""; }  @Override
    public String getGroupId() { return ""34427469792@N01""; }  @Override
    public String getTestGroupId() { return ""12345""; }  @Override
    public String getPhotoId() { return ""5628095432""; }  @Override
    public String getPhotosetId() { return ""12345""; }  @Override
    public String getImageFile() { return ""FILE""; }  @Override
    public String getGeoWritePhotoId() { return ""12345""; }  @Override
    public String getCollectionId() { return ""12345""; }  @Override
    public String getCollectionUrlId() { return ""12345""; }  @Override
    public String getGalleryId() { return ""72157634925210101""; }  @Override
    public String getDisplayname() { return ""Darren Greaves""; }  @Override
    public List<String> getPhotosetPhotos() { return Arrays.asList(""5628122182"", ""5628111146"", ""4169948514""); }  @Override
    public boolean isRealFlickr() { return false; } }  "
src/test/java/com/flickr4java/flickr/test/util/TestProperties.java,"package com.flickr4java.flickr.test.util;

import java.util.List;

public interface TestProperties {
    String getHost();

    String getApiKey();

    String getSecret();

    String getToken();

    String getTokenSecret();

    String getNsid();

    String getEmail();

    String getUsername();

    String getGroupId();

    String getTestGroupId();

    String getPhotoId();

    String getPhotosetId();

    String getImageFile();

    String getGeoWritePhotoId();

    String getCollectionId();

    String getCollectionUrlId();

    String getGalleryId();

    String getDisplayname();

    List<String> getPhotosetPhotos();

    boolean isRealFlickr();
}
",package com.flickr4java.flickr.test.util; public interface TestProperties { String getHost(); String getApiKey(); String getSecret(); String getToken(); String getTokenSecret(); String getNsid(); String getEmail(); String getUsername(); String getGroupId(); String getTestGroupId(); String getPhotoId(); String getPhotosetId(); String getImageFile(); String getGeoWritePhotoId(); String getCollectionId(); String getCollectionUrlId(); String getGalleryId(); String getDisplayname(); List<String> getPhotosetPhotos(); boolean isRealFlickr(); },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package com.flickr4java.flickr.test.util; public interface TestProperties { String getHost(); String getApiKey(); String getSecret(); String getToken(); String getTokenSecret(); String getNsid(); String getEmail(); String getUsername(); String getGroupId(); String getTestGroupId(); String getPhotoId(); String getPhotosetId(); String getImageFile(); String getGeoWritePhotoId(); String getCollectionId(); String getCollectionUrlId(); String getGalleryId(); String getDisplayname(); List<String> getPhotosetPhotos(); boolean isRealFlickr(); } ,"package com.flickr4java.flickr.test.util; 
import java.util.List;  public interface TestProperties { String getHost();  String getApiKey();  String getSecret();  String getToken();  String getTokenSecret();  String getNsid();  String getEmail();  String getUsername();  String getGroupId();  String getTestGroupId();  String getPhotoId();  String getPhotosetId();  String getImageFile();  String getGeoWritePhotoId();  String getCollectionId();  String getCollectionUrlId();  String getGalleryId();  String getDisplayname();  List<String> getPhotosetPhotos();  boolean isRealFlickr(); }  "
src/test/java/com/flickr4java/flickr/test/util/TestPropertiesFactory.java,"package com.flickr4java.flickr.test.util;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.net.URL;
import java.nio.file.Paths;
import java.util.Optional;

public class TestPropertiesFactory {

    /**
     * Logger.
     */
    private static Logger _log = LoggerFactory.getLogger(TestPropertiesFactory.class);


    public static TestProperties getTestProperties() {

        TestPropertiesFactory factory = new TestPropertiesFactory();
        Optional<File> fileOptional = factory.findPropertyFile();

        TestProperties testProperties;
        if (fileOptional.isPresent()) {
            testProperties = new FileTestProperties(fileOptional.get());
        } else {
            testProperties = new StubTestProperties();
        }

        return testProperties;
    }

    private Optional<File> findPropertyFile() {
        Optional<File> fileOptional = Optional.empty();
        String setupPropertiesPath = System.getenv(""SETUP_PROPERTIES_PATH"");

        try {
            if (setupPropertiesPath != null && setupPropertiesPath.length() > 0) {
                _log.info(""Using properties file at '{}'"", setupPropertiesPath);
                File properties = new File(setupPropertiesPath);
                fileOptional = properties.exists() ? Optional.of(properties) : Optional.empty();
            } else {
                URL resource = this.getClass().getResource(""/setup.properties"");
                if (resource != null) {
                    fileOptional = Optional.of(Paths.get(resource.toURI()).toFile());
                    _log.info(""Using properties file /setup.properties from classpath"");
                }
            }
        } catch (Exception e) {
            _log.warn(""Unable to load properties file"", e);
            fileOptional = Optional.empty();
        }

        return fileOptional;
    }

}
","package com.flickr4java.flickr.test.util; public class TestPropertiesFactory { private static Logger _log = LoggerFactory.getLogger(TestPropertiesFactory.class); public static TestProperties getTestProperties() { TestPropertiesFactory factory = new TestPropertiesFactory(); Optional<File> fileOptional = factory.findPropertyFile(); TestProperties testProperties; if (fileOptional.isPresent()) { testProperties = new FileTestProperties(fileOptional.get()); } else { testProperties = new StubTestProperties(); } return testProperties; } private Optional<File> findPropertyFile() { Optional<File> fileOptional = Optional.empty(); String setupPropertiesPath = System.getenv(""SETUP_PROPERTIES_PATH""); try { if (setupPropertiesPath != null && setupPropertiesPath.length() > 0) { _log.info(""Using properties file at '{ } '"", setupPropertiesPath); File properties = new File(setupPropertiesPath); fileOptional = properties.exists() ? Optional.of(properties) : Optional.empty(); } else { URL resource = this.getClass().getResource(""/setup.properties""); if (resource != null) { fileOptional = Optional.of(Paths.get(resource.toURI()).toFile()); } } } catch (Exception e) { fileOptional = Optional.empty(); } return fileOptional; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0,"package com.flickr4java.flickr.test.util; public class TestPropertiesFactory { private static Logger _log = LoggerFactory.getLogger(TestPropertiesFactory.class); public static TestProperties getTestProperties() { TestPropertiesFactory factory = new TestPropertiesFactory(); Optional<File> fileOptional = factory.findPropertyFile(); TestProperties testProperties; if (fileOptional.isPresent()) { testProperties = new FileTestProperties(fileOptional.get()); } else { testProperties = new StubTestProperties(); } return testProperties; } private Optional<File> findPropertyFile() { Optional<File> fileOptional = Optional.empty(); String setupPropertiesPath = System.getenv(""SETUP_PROPERTIES_PATH""); try { if (setupPropertiesPath != null && setupPropertiesPath.length() > 0) { _log.info(""Using properties file at '{ } '"", setupPropertiesPath); File properties = new File(setupPropertiesPath); fileOptional = properties.exists() ? Optional.of(properties) : Optional.empty(); } else { URL resource = this.getClass().getResource(""/setup.properties""); if (resource != null) { fileOptional = Optional.of(Paths.get(resource.toURI()).toFile()); <FILL_ME> } } } catch (Exception e) { <FILL_ME> fileOptional = Optional.empty(); } return fileOptional; } } ","package com.flickr4java.flickr.test.util; 
import org.slf4j.Logger; import org.slf4j.LoggerFactory; 
import java.io.File; import java.net.URL; import java.nio.file.Paths; import java.util.Optional;  public class TestPropertiesFactory {  /**
     * Logger.
     */ private static Logger _log = LoggerFactory.getLogger(TestPropertiesFactory.class); 
 public static TestProperties getTestProperties() {  TestPropertiesFactory factory = new TestPropertiesFactory(); Optional<File> fileOptional = factory.findPropertyFile();  TestProperties testProperties; if (fileOptional.isPresent()) { testProperties = new FileTestProperties(fileOptional.get()); } else { testProperties = new StubTestProperties(); }  return testProperties; }  private Optional<File> findPropertyFile() { Optional<File> fileOptional = Optional.empty(); String setupPropertiesPath = System.getenv(""SETUP_PROPERTIES_PATH"");  try { if (setupPropertiesPath != null && setupPropertiesPath.length() > 0) { _log.info(""Using properties file at '{ } '"", setupPropertiesPath); File properties = new File(setupPropertiesPath); fileOptional = properties.exists() ? Optional.of(properties) : Optional.empty(); } else { URL resource = this.getClass().getResource(""/setup.properties""); if (resource != null) { fileOptional = Optional.of(Paths.get(resource.toURI()).toFile()); <FILL_ME> } } } catch (Exception e) { <FILL_ME> fileOptional = Optional.empty(); }  return fileOptional; }  }  "
src/test/java/com/flickr4java/flickr/test/util/TransportStub.java,"package com.flickr4java.flickr.test.util;

import com.flickr4java.flickr.*;
import com.flickr4java.flickr.uploader.Payload;
import com.flickr4java.flickr.uploader.UploadMetaData;
import com.flickr4java.flickr.uploader.UploaderResponse;
import org.w3c.dom.Document;
import org.xml.sax.InputSource;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.StringReader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Map;

public class TransportStub extends Transport {

    private final DocumentBuilder builder;

    public TransportStub() {
        DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance();
        try {
            builder = builderFactory.newDocumentBuilder();
        } catch (ParserConfigurationException e) {
            throw new FlickrRuntimeException(e);
        }
    }

    @Override
    public Response get(String path, Map<String, Object> parameters, String apiKey, String sharedSecret) {
        return loadResponseFromFile(parameters.get(""method""), ""get"");
    }

    @Override
    public Response post(String path, Map<String, Object> parameters, String apiKey, String sharedSecret) {
        return loadResponseFromFile(parameters.get(""method""), ""post"");
    }

    @Override
    public Response postMultiPart(String path, UploadMetaData parameters, Payload payload, String apiKey, String sharedSecret) {
        return loadMulitpartResponseFromFile(""upload"", ""post"");
    }

    @Override
    public Response getNonOAuth(String path, Map<String, String> parameters) {
        return null;
    }

    private Response loadResponseFromFile(Object flickrMethod, String httpMethod) {
        RESTResponse response;
        String filename = String.format(""/payloads/%s/%s.xml"", httpMethod, flickrMethod);
        try {
            Path filePath = Paths.get(this.getClass().getResource(filename).toURI());
            String strXml = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);
            Document document = builder.parse(new InputSource(new StringReader(strXml)));

            response = new RESTResponse();
            response.parse(document);
        } catch (Exception e) {
            throw new FlickrRuntimeException(e);
        }

        return response;
    }

    private Response loadMulitpartResponseFromFile(Object flickrMethod, String httpMethod) {
        UploaderResponse response;
        String filename = String.format(""/payloads/%s/%s.xml"", httpMethod, flickrMethod);
        try {
            Path filePath = Paths.get(this.getClass().getResource(filename).toURI());
            String strXml = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);
            Document document = builder.parse(new InputSource(new StringReader(strXml)));

            response = new UploaderResponse();
            response.parse(document);
        } catch (Exception e) {
            throw new FlickrRuntimeException(e);
        }

        return response;
    }
}
","package com.flickr4java.flickr.test.util; public class TransportStub extends Transport { private final DocumentBuilder builder; public TransportStub() { DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance(); try { builder = builderFactory.newDocumentBuilder(); } catch (ParserConfigurationException e) { throw new FlickrRuntimeException(e); } } @Override
    public Response get(String path, Map<String, Object> parameters, String apiKey, String sharedSecret) { return loadResponseFromFile(parameters.get(""method""), ""get""); } @Override
    public Response post(String path, Map<String, Object> parameters, String apiKey, String sharedSecret) { return loadResponseFromFile(parameters.get(""method""), ""post""); } @Override
    public Response postMultiPart(String path, UploadMetaData parameters, Payload payload, String apiKey, String sharedSecret) { return loadMulitpartResponseFromFile(""upload"", ""post""); } @Override
    public Response getNonOAuth(String path, Map<String, String> parameters) { return null; } private Response loadResponseFromFile(Object flickrMethod, String httpMethod) { RESTResponse response; String filename = String.format(""/payloads/%s/%s.xml"", httpMethod, flickrMethod); try { Path filePath = Paths.get(this.getClass().getResource(filename).toURI()); String strXml = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8); Document document = builder.parse(new InputSource(new StringReader(strXml))); response = new RESTResponse(); response.parse(document); } catch (Exception e) { throw new FlickrRuntimeException(e); } return response; } private Response loadMulitpartResponseFromFile(Object flickrMethod, String httpMethod) { UploaderResponse response; String filename = String.format(""/payloads/%s/%s.xml"", httpMethod, flickrMethod); try { Path filePath = Paths.get(this.getClass().getResource(filename).toURI()); String strXml = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8); Document document = builder.parse(new InputSource(new StringReader(strXml))); response = new UploaderResponse(); response.parse(document); } catch (Exception e) { throw new FlickrRuntimeException(e); } return response; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.flickr4java.flickr.test.util; public class TransportStub extends Transport { private final DocumentBuilder builder; public TransportStub() { DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance(); try { builder = builderFactory.newDocumentBuilder(); } catch (ParserConfigurationException e) { throw new FlickrRuntimeException(e); } } @Override
    public Response get(String path, Map<String, Object> parameters, String apiKey, String sharedSecret) { return loadResponseFromFile(parameters.get(""method""), ""get""); } @Override
    public Response post(String path, Map<String, Object> parameters, String apiKey, String sharedSecret) { return loadResponseFromFile(parameters.get(""method""), ""post""); } @Override
    public Response postMultiPart(String path, UploadMetaData parameters, Payload payload, String apiKey, String sharedSecret) { return loadMulitpartResponseFromFile(""upload"", ""post""); } @Override
    public Response getNonOAuth(String path, Map<String, String> parameters) { return null; } private Response loadResponseFromFile(Object flickrMethod, String httpMethod) { RESTResponse response; String filename = String.format(""/payloads/%s/%s.xml"", httpMethod, flickrMethod); try { Path filePath = Paths.get(this.getClass().getResource(filename).toURI()); String strXml = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8); Document document = builder.parse(new InputSource(new StringReader(strXml))); response = new RESTResponse(); response.parse(document); } catch (Exception e) { throw new FlickrRuntimeException(e); } return response; } private Response loadMulitpartResponseFromFile(Object flickrMethod, String httpMethod) { UploaderResponse response; String filename = String.format(""/payloads/%s/%s.xml"", httpMethod, flickrMethod); try { Path filePath = Paths.get(this.getClass().getResource(filename).toURI()); String strXml = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8); Document document = builder.parse(new InputSource(new StringReader(strXml))); response = new UploaderResponse(); response.parse(document); } catch (Exception e) { throw new FlickrRuntimeException(e); } return response; } } ","package com.flickr4java.flickr.test.util; 
import com.flickr4java.flickr.*; import com.flickr4java.flickr.uploader.Payload; import com.flickr4java.flickr.uploader.UploadMetaData; import com.flickr4java.flickr.uploader.UploaderResponse; import org.w3c.dom.Document; import org.xml.sax.InputSource; 
import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import java.io.StringReader; import java.nio.charset.StandardCharsets; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.util.Map;  public class TransportStub extends Transport {  private final DocumentBuilder builder;  public TransportStub() { DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance(); try { builder = builderFactory.newDocumentBuilder(); } catch (ParserConfigurationException e) { throw new FlickrRuntimeException(e); } }  @Override
    public Response get(String path, Map<String, Object> parameters, String apiKey, String sharedSecret) { return loadResponseFromFile(parameters.get(""method""), ""get""); }  @Override
    public Response post(String path, Map<String, Object> parameters, String apiKey, String sharedSecret) { return loadResponseFromFile(parameters.get(""method""), ""post""); }  @Override
    public Response postMultiPart(String path, UploadMetaData parameters, Payload payload, String apiKey, String sharedSecret) { return loadMulitpartResponseFromFile(""upload"", ""post""); }  @Override
    public Response getNonOAuth(String path, Map<String, String> parameters) { return null; }  private Response loadResponseFromFile(Object flickrMethod, String httpMethod) { RESTResponse response; String filename = String.format(""/payloads/%s/%s.xml"", httpMethod, flickrMethod); try { Path filePath = Paths.get(this.getClass().getResource(filename).toURI()); String strXml = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8); Document document = builder.parse(new InputSource(new StringReader(strXml)));  response = new RESTResponse(); response.parse(document); } catch (Exception e) { throw new FlickrRuntimeException(e); }  return response; }  private Response loadMulitpartResponseFromFile(Object flickrMethod, String httpMethod) { UploaderResponse response; String filename = String.format(""/payloads/%s/%s.xml"", httpMethod, flickrMethod); try { Path filePath = Paths.get(this.getClass().getResource(filename).toURI()); String strXml = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8); Document document = builder.parse(new InputSource(new StringReader(strXml)));  response = new UploaderResponse(); response.parse(document); } catch (Exception e) { throw new FlickrRuntimeException(e); }  return response; } }  "
