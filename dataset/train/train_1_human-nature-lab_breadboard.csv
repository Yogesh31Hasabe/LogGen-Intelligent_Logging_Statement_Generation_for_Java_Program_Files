file_name,original_file_content,Input,Label,Output,OriginalWithPlaceholder
app/Global.java,"import com.avaje.ebean.Ebean;
import com.avaje.ebean.SqlRow;
import controllers.LanguageController;
import models.*;
import org.apache.commons.io.FileUtils;
import play.Play;
import play.Application;
import play.GlobalSettings;
import play.Logger;
import play.db.DB;
import play.libs.F;
import play.libs.Yaml;
import play.mvc.Action;
import play.mvc.Http;

import java.io.*;
import java.lang.reflect.Method;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.UUID;

public class Global extends GlobalSettings {

  static Process process = null;

  @Override
  public void onStart(Application app) {

    String sql = ""select count(*) as table_count from information_schema.tables where table_name = 'breadboard_version';"";
    SqlRow versionTableCount = Ebean.createSqlQuery(sql).findUnique();
    String count = versionTableCount.getString(""table_count"");

    // If the breadboard_version table doesn't exist we're < v2.3
    if (count.equals(""0"")) {

      // Create the breadboard_version table
      sql = ""create table breadboard_version ( version varchar(255) ); "";
      Ebean.createSqlUpdate(sql).execute();
      // Update the version
      String version = play.Play.application().configuration().getString(""application.version"");
      sql = ""insert into breadboard_version values ('"" + version + ""'); "";
      Ebean.createSqlUpdate(sql).execute();

      // Create the languages table
      sql = ""create table if not exists languages ( id bigint not null, code varchar(8), name varchar(255), "" +
          ""constraint pk_language primary key (id) ); "";
      Ebean.createSqlUpdate(sql).execute();

      // Create the experiment_languages table
      sql = ""create table if not exists experiments_languages "" +
          ""( experiments_id bigint not null, languages_id bigint not null, "" +
          ""foreign key (experiments_id) references experiments(id), "" +
          ""foreign key (languages_id) references languages(id) );"";
      Ebean.createSqlUpdate(sql).execute();

      // Create the translations table
      sql = ""create table if not exists translations ( id bigint not null, html text, content_id bigint not null, languages_id bigint not null,"" +
          ""foreign key (content_id) references content(id),"" +
          ""foreign key (languages_id) references languages(id),"" +
          ""constraint pk_translations primary key (id) ); "";
      Ebean.createSqlUpdate(sql).execute();

      // Add the auto increment sequences
      sql = ""create sequence if not exists languages_seq; "";
      Ebean.createSqlUpdate(sql).execute();
      sql = ""create sequence if not exists experiments_languages_seq; "";
      Ebean.createSqlUpdate(sql).execute();
      sql = ""create sequence if not exists translations_seq; "";
      Ebean.createSqlUpdate(sql).execute();

      // Add the uid column to experiments
      sql = ""alter table experiments add column if not exists uid varchar(255); "";
      Ebean.createSqlUpdate(sql).execute();

      // Add default language column to users
      sql = ""alter table users add column if not exists default_language_id bigint; "";
      Ebean.createSqlUpdate(sql).execute();

      sql = ""alter table users add constraint fk_default_language_languages "" +
          ""foreign key (default_language_id) references languages (id) "" +
          ""on delete restrict on update restrict; "";
      Ebean.createSqlUpdate(sql).execute();

      sql = ""create index if not exists ix_users_default_language on users (default_language_id); "";
      Ebean.createSqlUpdate(sql).execute();

      // Changes to support new AMT dialog
      sql = ""alter table amt_assignments add column if not exists bonus_amount varchar(255); "";
      Ebean.createSqlUpdate(sql).execute();

      sql = ""alter table amt_hits alter column experiment_instance_id set null; "";
      Ebean.createSqlUpdate(sql).execute();

      // Additional schema changes for older versions of breadboard pre v2.1
      sql = ""alter table experiments add column if not exists client_graph text; "";
      Ebean.createSqlUpdate(sql).execute();
      sql = ""alter table experiments add column if not exists client_html text; "";
      Ebean.createSqlUpdate(sql).execute();

      // Messages table
      sql = ""create table messages (\n"" +
          ""  id                        bigint not null,\n"" +
          ""  message_uid               varchar(36),\n"" +
          ""  message_title             varchar(255),\n"" +
          ""  message_html              text,\n"" +
          ""  priority                  tinyint,\n"" +
          ""  auto_open                 bit,\n"" +
          ""  created_at                timestamp,\n"" +
          ""  dismissed_at              timestamp\n"" +
          "");\n"";
      Ebean.createSqlUpdate(sql).execute();

      // Migrate data
      LanguageController.seedLanguages();

      Language english = Language.findByIso3(""eng"");
      if (english == null) {
        Logger.debug(""Unable to find english in languages."");
        english = Language.findAll().get(0);
      }

      for (User user : User.findAll()) {
        user.defaultLanguage = english;
        user.save();
      }

      for (Experiment experiment : Experiment.findAll()) {
        experiment.languages.add(english);
        experiment.uid = UUID.randomUUID().toString();

        try {
          File experimentDirectory = new File(Play.application().path().toString() + ""/experiments/"" + experiment.name + ""_v2.2"");
          FileUtils.writeStringToFile(new File(experimentDirectory, ""client.html""), experiment.clientHtml);
          FileUtils.writeStringToFile(new File(experimentDirectory, ""client-graph.js""), experiment.clientGraph);
          experiment.clientGraph = Experiment.defaultClientGraph();
          experiment.clientHtml = Experiment.defaultClientHTML();
        } catch (IOException ioe) {
          Logger.error(""Error backing up v2.2 client.html and client.js to experiments directory"");
        }

        experiment.save();
      }

      for (Content content : Content.findAll()) {
        Translation translation = new Translation();
        translation.language = english;
        translation.setHtml(content.html);
        content.translations.add(translation);
        content.save();
      }

      // TODO: Add message telling user what was done
      // TODO: Load v2.3 version notes as message from file system

      // Upgrade to version 2.4.0
      version2Point4Upgrade();
    } else {
      // The breadboard_version table exists, let's check if we're v2.3 or v2.4
      sql = ""select version from breadboard_version limit 1;"";
      SqlRow versionString = Ebean.createSqlQuery(sql).findUnique();
      String version = versionString != null ? versionString.getString(""version"") : """";
      if (version.equals(""v2.3.0"") || version.equals(""v2.3.1"")) {
        // Add v2.4.0 fields
        version2Point4Upgrade();
      } // Otherwise, no upgrade needed
    }
  }

  private void version2Point4Upgrade() {
    // Changes to support Experiment fileMode
    String sql = ""alter table experiments add column if not exists file_mode bit default 0;"";
    Ebean.createSqlUpdate(sql).execute();
  }

  @Override
  public void onStop(Application app){
    if(process != null){
      process.destroy();
    }
  }

  @Override
  public Action onRequest(Http.Request request, Method actionMethod) {
    return super.onRequest(request, actionMethod);
  }

  static class InitialData {
    public static void insert(Application app) {
      Logger.info(""Importing initial data:"");

      @SuppressWarnings(""unchecked"")
      Map<String, List<Object>> all = (Map<String, List<Object>>) Yaml.load(""initial-data.yml"");

      if (Ebean.find(Experiment.class).findRowCount() == 0) {
        Logger.info(""\t importing Experiment"");
        Collection allExperiments = all.get(""experiments"");
        Ebean.save(allExperiments);

        resetSeq(""experiments"", ""experiments_seq"");
      }

      if (Ebean.find(User.class).findRowCount() == 0) {
        Logger.info(""\t importing User"");
        Ebean.save(all.get(""users""));

        for (Object user : all.get(""users"")) {
          Ebean.saveManyToManyAssociations(user, ""ownedExperiments"");
        }
      }

    }

    /**
     * This is used to reset the auto generated sequence for the h2 database.
     * This is useful because after the initial-data is loaded, the tables' auto generated values are not setting
     * to the right value which is causing #11 in the issue tracker.
     *
     * @param tableName
     * @param seqName
     */
    private static void resetSeq(String tableName, String seqName) {
      Connection connection = DB.getConnection();
      Statement selectStatement = null;

      Long maxId = null;
      try {
        selectStatement = connection.createStatement();
        ResultSet rs = selectStatement.executeQuery(""select max(id) from "" + tableName + "";"");
        while (rs.next()) {
          maxId = rs.getLong(1);
        }

      } catch (SQLException e) {
        Logger.error(""Unable to get the current max id."", e);
      } finally {
        if (selectStatement != null) {
          try {
            selectStatement.close();
          } catch (SQLException e) {
            Logger.error(""Unable to close the statement."", e);
          }
        }
      }

      if (maxId != null) {
        Statement statement = null;
        try {
          statement = connection.createStatement();
          statement.execute(""ALTER SEQUENCE "" + seqName + "" RESTART WITH "" + (maxId + 1) + "";"");
        } catch (SQLException e) {
          Logger.error(""Unable to alter the sequence."", e);
        } finally {
          if (statement != null) {
            try {
              statement.close();
            } catch (SQLException e) {
              Logger.error(""Unable to close the statement."", e);
            }
          }
          try {
            connection.close();
          } catch (SQLException e) {
            Logger.error(""Unable to close the connection."", e);
          }
        }
      }
    }
  }
}","public class Global extends GlobalSettings { static Process process = null; @Override
  public void onStart(Application app) { String sql = ""select count(*) as table_count from information_schema.tables where table_name = 'breadboard_version'; ""; SqlRow versionTableCount = Ebean.createSqlQuery(sql).findUnique(); String count = versionTableCount.getString(""table_count""); if (count.equals(""0"")) { sql = ""create table breadboard_version ( version varchar(255) ); ""; Ebean.createSqlUpdate(sql).execute(); String version = play.Play.application().configuration().getString(""application.version""); sql = ""insert into breadboard_version values ('"" + version + ""'); ""; Ebean.createSqlUpdate(sql).execute(); sql = ""create table if not exists languages ( id bigint not null, code varchar(8), name varchar(255), "" +
          ""constraint pk_language primary key (id) ); ""; Ebean.createSqlUpdate(sql).execute(); sql = ""create table if not exists experiments_languages "" +
          ""( experiments_id bigint not null, languages_id bigint not null, "" +
          ""foreign key (experiments_id) references experiments(id), "" +
          ""foreign key (languages_id) references languages(id) ); ""; Ebean.createSqlUpdate(sql).execute(); sql = ""create table if not exists translations ( id bigint not null, html text, content_id bigint not null, languages_id bigint not null,"" +
          ""foreign key (content_id) references content(id),"" +
          ""foreign key (languages_id) references languages(id),"" +
          ""constraint pk_translations primary key (id) ); ""; Ebean.createSqlUpdate(sql).execute(); sql = ""create sequence if not exists languages_seq; ""; Ebean.createSqlUpdate(sql).execute(); sql = ""create sequence if not exists experiments_languages_seq; ""; Ebean.createSqlUpdate(sql).execute(); sql = ""create sequence if not exists translations_seq; ""; Ebean.createSqlUpdate(sql).execute(); sql = ""alter table experiments add column if not exists uid varchar(255); ""; Ebean.createSqlUpdate(sql).execute(); sql = ""alter table users add column if not exists default_language_id bigint; ""; Ebean.createSqlUpdate(sql).execute(); sql = ""alter table users add constraint fk_default_language_languages "" +
          ""foreign key (default_language_id) references languages (id) "" +
          ""on delete restrict on update restrict; ""; Ebean.createSqlUpdate(sql).execute(); sql = ""create index if not exists ix_users_default_language on users (default_language_id); ""; Ebean.createSqlUpdate(sql).execute(); sql = ""alter table amt_assignments add column if not exists bonus_amount varchar(255); ""; Ebean.createSqlUpdate(sql).execute(); sql = ""alter table amt_hits alter column experiment_instance_id set null; ""; Ebean.createSqlUpdate(sql).execute(); sql = ""alter table experiments add column if not exists client_graph text; ""; Ebean.createSqlUpdate(sql).execute(); sql = ""alter table experiments add column if not exists client_html text; ""; Ebean.createSqlUpdate(sql).execute(); sql = ""create table messages (\n"" +
          ""  id                        bigint not null,\n"" +
          ""  message_uid               varchar(36),\n"" +
          ""  message_title             varchar(255),\n"" +
          ""  message_html              text,\n"" +
          ""  priority                  tinyint,\n"" +
          ""  auto_open                 bit,\n"" +
          ""  created_at                timestamp,\n"" +
          ""  dismissed_at              timestamp\n"" +
          ""); \n""; Ebean.createSqlUpdate(sql).execute(); LanguageController.seedLanguages(); Language english = Language.findByIso3(""eng""); if (english == null) { english = Language.findAll().get(0); } for (User user : User.findAll()) { user.defaultLanguage = english; user.save(); } for (Experiment experiment : Experiment.findAll()) { experiment.languages.add(english); experiment.uid = UUID.randomUUID().toString(); try { File experimentDirectory = new File(Play.application().path().toString() + ""/experiments/"" + experiment.name + ""_v2.2""); FileUtils.writeStringToFile(new File(experimentDirectory, ""client.html""), experiment.clientHtml); FileUtils.writeStringToFile(new File(experimentDirectory, ""client-graph.js""), experiment.clientGraph); experiment.clientGraph = Experiment.defaultClientGraph(); experiment.clientHtml = Experiment.defaultClientHTML(); } catch (IOException ioe) { } experiment.save(); } for (Content content : Content.findAll()) { Translation translation = new Translation(); translation.language = english; translation.setHtml(content.html); content.translations.add(translation); content.save(); } version2Point4Upgrade(); } else { sql = ""select version from breadboard_version limit 1; ""; SqlRow versionString = Ebean.createSqlQuery(sql).findUnique(); String version = versionString != null ? versionString.getString(""version"") : """"; if (version.equals(""v2.3.0"") || version.equals(""v2.3.1"")) { version2Point4Upgrade(); } } } private void version2Point4Upgrade() { String sql = ""alter table experiments add column if not exists file_mode bit default 0; ""; Ebean.createSqlUpdate(sql).execute(); } @Override
  public void onStop(Application app){ if(process != null){ process.destroy(); } } @Override
  public Action onRequest(Http.Request request, Method actionMethod) { return super.onRequest(request, actionMethod); } static class InitialData { public static void insert(Application app) { @SuppressWarnings(""unchecked"")
      Map<String, List<Object>> all = (Map<String, List<Object>>) Yaml.load(""initial-data.yml""); if (Ebean.find(Experiment.class).findRowCount() == 0) { Collection allExperiments = all.get(""experiments""); Ebean.save(allExperiments); resetSeq(""experiments"", ""experiments_seq""); } if (Ebean.find(User.class).findRowCount() == 0) { Ebean.save(all.get(""users"")); for (Object user : all.get(""users"")) { Ebean.saveManyToManyAssociations(user, ""ownedExperiments""); } } } private static void resetSeq(String tableName, String seqName) { Connection connection = DB.getConnection(); Statement selectStatement = null; Long maxId = null; try { selectStatement = connection.createStatement(); ResultSet rs = selectStatement.executeQuery(""select max(id) from "" + tableName + ""; ""); while (rs.next()) { maxId = rs.getLong(1); } } catch (SQLException e) { } finally { if (selectStatement != null) { try { selectStatement.close(); } catch (SQLException e) { } } } if (maxId != null) { Statement statement = null; try { statement = connection.createStatement(); statement.execute(""ALTER SEQUENCE "" + seqName + "" RESTART WITH "" + (maxId + 1) + ""; ""); } catch (SQLException e) { } finally { if (statement != null) { try { statement.close(); } catch (SQLException e) { } } try { connection.close(); } catch (SQLException e) { } } } } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0,"public class Global extends GlobalSettings { static Process process = null; @Override
  public void onStart(Application app) { String sql = ""select count(*) as table_count from information_schema.tables where table_name = 'breadboard_version'; ""; SqlRow versionTableCount = Ebean.createSqlQuery(sql).findUnique(); String count = versionTableCount.getString(""table_count""); if (count.equals(""0"")) { sql = ""create table breadboard_version ( version varchar(255) ); ""; Ebean.createSqlUpdate(sql).execute(); String version = play.Play.application().configuration().getString(""application.version""); sql = ""insert into breadboard_version values ('"" + version + ""'); ""; Ebean.createSqlUpdate(sql).execute(); sql = ""create table if not exists languages ( id bigint not null, code varchar(8), name varchar(255), "" +
          ""constraint pk_language primary key (id) ); ""; Ebean.createSqlUpdate(sql).execute(); sql = ""create table if not exists experiments_languages "" +
          ""( experiments_id bigint not null, languages_id bigint not null, "" +
          ""foreign key (experiments_id) references experiments(id), "" +
          ""foreign key (languages_id) references languages(id) ); ""; Ebean.createSqlUpdate(sql).execute(); sql = ""create table if not exists translations ( id bigint not null, html text, content_id bigint not null, languages_id bigint not null,"" +
          ""foreign key (content_id) references content(id),"" +
          ""foreign key (languages_id) references languages(id),"" +
          ""constraint pk_translations primary key (id) ); ""; Ebean.createSqlUpdate(sql).execute(); sql = ""create sequence if not exists languages_seq; ""; Ebean.createSqlUpdate(sql).execute(); sql = ""create sequence if not exists experiments_languages_seq; ""; Ebean.createSqlUpdate(sql).execute(); sql = ""create sequence if not exists translations_seq; ""; Ebean.createSqlUpdate(sql).execute(); sql = ""alter table experiments add column if not exists uid varchar(255); ""; Ebean.createSqlUpdate(sql).execute(); sql = ""alter table users add column if not exists default_language_id bigint; ""; Ebean.createSqlUpdate(sql).execute(); sql = ""alter table users add constraint fk_default_language_languages "" +
          ""foreign key (default_language_id) references languages (id) "" +
          ""on delete restrict on update restrict; ""; Ebean.createSqlUpdate(sql).execute(); sql = ""create index if not exists ix_users_default_language on users (default_language_id); ""; Ebean.createSqlUpdate(sql).execute(); sql = ""alter table amt_assignments add column if not exists bonus_amount varchar(255); ""; Ebean.createSqlUpdate(sql).execute(); sql = ""alter table amt_hits alter column experiment_instance_id set null; ""; Ebean.createSqlUpdate(sql).execute(); sql = ""alter table experiments add column if not exists client_graph text; ""; Ebean.createSqlUpdate(sql).execute(); sql = ""alter table experiments add column if not exists client_html text; ""; Ebean.createSqlUpdate(sql).execute(); sql = ""create table messages (\n"" +
          ""  id                        bigint not null,\n"" +
          ""  message_uid               varchar(36),\n"" +
          ""  message_title             varchar(255),\n"" +
          ""  message_html              text,\n"" +
          ""  priority                  tinyint,\n"" +
          ""  auto_open                 bit,\n"" +
          ""  created_at                timestamp,\n"" +
          ""  dismissed_at              timestamp\n"" +
          ""); \n""; Ebean.createSqlUpdate(sql).execute(); LanguageController.seedLanguages(); Language english = Language.findByIso3(""eng""); if (english == null) { <FILL_ME> english = Language.findAll().get(0); } for (User user : User.findAll()) { user.defaultLanguage = english; user.save(); } for (Experiment experiment : Experiment.findAll()) { experiment.languages.add(english); experiment.uid = UUID.randomUUID().toString(); try { File experimentDirectory = new File(Play.application().path().toString() + ""/experiments/"" + experiment.name + ""_v2.2""); FileUtils.writeStringToFile(new File(experimentDirectory, ""client.html""), experiment.clientHtml); FileUtils.writeStringToFile(new File(experimentDirectory, ""client-graph.js""), experiment.clientGraph); experiment.clientGraph = Experiment.defaultClientGraph(); experiment.clientHtml = Experiment.defaultClientHTML(); } catch (IOException ioe) { <FILL_ME> } experiment.save(); } for (Content content : Content.findAll()) { Translation translation = new Translation(); translation.language = english; translation.setHtml(content.html); content.translations.add(translation); content.save(); } version2Point4Upgrade(); } else { sql = ""select version from breadboard_version limit 1; ""; SqlRow versionString = Ebean.createSqlQuery(sql).findUnique(); String version = versionString != null ? versionString.getString(""version"") : """"; if (version.equals(""v2.3.0"") || version.equals(""v2.3.1"")) { version2Point4Upgrade(); } } } private void version2Point4Upgrade() { String sql = ""alter table experiments add column if not exists file_mode bit default 0; ""; Ebean.createSqlUpdate(sql).execute(); } @Override
  public void onStop(Application app){ if(process != null){ process.destroy(); } } @Override
  public Action onRequest(Http.Request request, Method actionMethod) { return super.onRequest(request, actionMethod); } static class InitialData { public static void insert(Application app) { <FILL_ME> @SuppressWarnings(""unchecked"")
      Map<String, List<Object>> all = (Map<String, List<Object>>) Yaml.load(""initial-data.yml""); if (Ebean.find(Experiment.class).findRowCount() == 0) { <FILL_ME> Collection allExperiments = all.get(""experiments""); Ebean.save(allExperiments); resetSeq(""experiments"", ""experiments_seq""); } if (Ebean.find(User.class).findRowCount() == 0) { <FILL_ME> Ebean.save(all.get(""users"")); for (Object user : all.get(""users"")) { Ebean.saveManyToManyAssociations(user, ""ownedExperiments""); } } } private static void resetSeq(String tableName, String seqName) { Connection connection = DB.getConnection(); Statement selectStatement = null; Long maxId = null; try { selectStatement = connection.createStatement(); ResultSet rs = selectStatement.executeQuery(""select max(id) from "" + tableName + ""; ""); while (rs.next()) { maxId = rs.getLong(1); } } catch (SQLException e) { <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> } finally { if (selectStatement != null) { try { selectStatement.close(); } catch (SQLException e) { } } } if (maxId != null) { Statement statement = null; try { statement = connection.createStatement(); statement.execute(""ALTER SEQUENCE "" + seqName + "" RESTART WITH "" + (maxId + 1) + ""; ""); } catch (SQLException e) { } finally { if (statement != null) { try { statement.close(); } catch (SQLException e) { } } try { connection.close(); } catch (SQLException e) { } } } } } }","import com.avaje.ebean.Ebean; import com.avaje.ebean.SqlRow; import controllers.LanguageController; import models.*; import org.apache.commons.io.FileUtils; import play.Play; import play.Application; import play.GlobalSettings; import play.Logger; import play.db.DB; import play.libs.F; import play.libs.Yaml; import play.mvc.Action; import play.mvc.Http; 
import java.io.*; import java.lang.reflect.Method; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.util.Collection; import java.util.List; import java.util.Map; import java.util.UUID;  public class Global extends GlobalSettings {  static Process process = null;  @Override
  public void onStart(Application app) {  String sql = ""select count(*) as table_count from information_schema.tables where table_name = 'breadboard_version'; ""; SqlRow versionTableCount = Ebean.createSqlQuery(sql).findUnique(); String count = versionTableCount.getString(""table_count"");  // If the breadboard_version table doesn't exist we're < v2.3 if (count.equals(""0"")) {  // Create the breadboard_version table sql = ""create table breadboard_version ( version varchar(255) ); ""; Ebean.createSqlUpdate(sql).execute(); // Update the version String version = play.Play.application().configuration().getString(""application.version""); sql = ""insert into breadboard_version values ('"" + version + ""'); ""; Ebean.createSqlUpdate(sql).execute();  // Create the languages table sql = ""create table if not exists languages ( id bigint not null, code varchar(8), name varchar(255), "" +
          ""constraint pk_language primary key (id) ); ""; Ebean.createSqlUpdate(sql).execute();  // Create the experiment_languages table sql = ""create table if not exists experiments_languages "" +
          ""( experiments_id bigint not null, languages_id bigint not null, "" +
          ""foreign key (experiments_id) references experiments(id), "" +
          ""foreign key (languages_id) references languages(id) ); ""; Ebean.createSqlUpdate(sql).execute();  // Create the translations table sql = ""create table if not exists translations ( id bigint not null, html text, content_id bigint not null, languages_id bigint not null,"" +
          ""foreign key (content_id) references content(id),"" +
          ""foreign key (languages_id) references languages(id),"" +
          ""constraint pk_translations primary key (id) ); ""; Ebean.createSqlUpdate(sql).execute();  // Add the auto increment sequences sql = ""create sequence if not exists languages_seq; ""; Ebean.createSqlUpdate(sql).execute(); sql = ""create sequence if not exists experiments_languages_seq; ""; Ebean.createSqlUpdate(sql).execute(); sql = ""create sequence if not exists translations_seq; ""; Ebean.createSqlUpdate(sql).execute();  // Add the uid column to experiments sql = ""alter table experiments add column if not exists uid varchar(255); ""; Ebean.createSqlUpdate(sql).execute();  // Add default language column to users sql = ""alter table users add column if not exists default_language_id bigint; ""; Ebean.createSqlUpdate(sql).execute();  sql = ""alter table users add constraint fk_default_language_languages "" +
          ""foreign key (default_language_id) references languages (id) "" +
          ""on delete restrict on update restrict; ""; Ebean.createSqlUpdate(sql).execute();  sql = ""create index if not exists ix_users_default_language on users (default_language_id); ""; Ebean.createSqlUpdate(sql).execute();  // Changes to support new AMT dialog sql = ""alter table amt_assignments add column if not exists bonus_amount varchar(255); ""; Ebean.createSqlUpdate(sql).execute();  sql = ""alter table amt_hits alter column experiment_instance_id set null; ""; Ebean.createSqlUpdate(sql).execute();  // Additional schema changes for older versions of breadboard pre v2.1 sql = ""alter table experiments add column if not exists client_graph text; ""; Ebean.createSqlUpdate(sql).execute(); sql = ""alter table experiments add column if not exists client_html text; ""; Ebean.createSqlUpdate(sql).execute();  // Messages table sql = ""create table messages (\n"" +
          ""  id                        bigint not null,\n"" +
          ""  message_uid               varchar(36),\n"" +
          ""  message_title             varchar(255),\n"" +
          ""  message_html              text,\n"" +
          ""  priority                  tinyint,\n"" +
          ""  auto_open                 bit,\n"" +
          ""  created_at                timestamp,\n"" +
          ""  dismissed_at              timestamp\n"" +
          ""); \n""; Ebean.createSqlUpdate(sql).execute();  // Migrate data LanguageController.seedLanguages();  Language english = Language.findByIso3(""eng""); if (english == null) { <FILL_ME> english = Language.findAll().get(0); }  for (User user : User.findAll()) { user.defaultLanguage = english; user.save(); }  for (Experiment experiment : Experiment.findAll()) { experiment.languages.add(english); experiment.uid = UUID.randomUUID().toString();  try { File experimentDirectory = new File(Play.application().path().toString() + ""/experiments/"" + experiment.name + ""_v2.2""); FileUtils.writeStringToFile(new File(experimentDirectory, ""client.html""), experiment.clientHtml); FileUtils.writeStringToFile(new File(experimentDirectory, ""client-graph.js""), experiment.clientGraph); experiment.clientGraph = Experiment.defaultClientGraph(); experiment.clientHtml = Experiment.defaultClientHTML(); } catch (IOException ioe) { <FILL_ME> }  experiment.save(); }  for (Content content : Content.findAll()) { Translation translation = new Translation(); translation.language = english; translation.setHtml(content.html); content.translations.add(translation); content.save(); }  // TODO: Add message telling user what was done // TODO: Load v2.3 version notes as message from file system  // Upgrade to version 2.4.0 version2Point4Upgrade(); } else { // The breadboard_version table exists, let's check if we're v2.3 or v2.4 sql = ""select version from breadboard_version limit 1; ""; SqlRow versionString = Ebean.createSqlQuery(sql).findUnique(); String version = versionString != null ? versionString.getString(""version"") : """"; if (version.equals(""v2.3.0"") || version.equals(""v2.3.1"")) { // Add v2.4.0 fields version2Point4Upgrade(); } // Otherwise, no upgrade needed } }  private void version2Point4Upgrade() { // Changes to support Experiment fileMode String sql = ""alter table experiments add column if not exists file_mode bit default 0; ""; Ebean.createSqlUpdate(sql).execute(); }  @Override
  public void onStop(Application app){ if(process != null){ process.destroy(); } }  @Override
  public Action onRequest(Http.Request request, Method actionMethod) { return super.onRequest(request, actionMethod); }  static class InitialData { public static void insert(Application app) { <FILL_ME>  @SuppressWarnings(""unchecked"")
      Map<String, List<Object>> all = (Map<String, List<Object>>) Yaml.load(""initial-data.yml"");  if (Ebean.find(Experiment.class).findRowCount() == 0) { <FILL_ME> Collection allExperiments = all.get(""experiments""); Ebean.save(allExperiments);  resetSeq(""experiments"", ""experiments_seq""); }  if (Ebean.find(User.class).findRowCount() == 0) { <FILL_ME> Ebean.save(all.get(""users""));  for (Object user : all.get(""users"")) { Ebean.saveManyToManyAssociations(user, ""ownedExperiments""); } }  }  /**
     * This is used to reset the auto generated sequence for the h2 database.
     * This is useful because after the initial-data is loaded, the tables' auto generated values are not setting
     * to the right value which is causing #11 in the issue tracker.
     *
     * @param tableName
     * @param seqName
     */ private static void resetSeq(String tableName, String seqName) { Connection connection = DB.getConnection(); Statement selectStatement = null;  Long maxId = null; try { selectStatement = connection.createStatement(); ResultSet rs = selectStatement.executeQuery(""select max(id) from "" + tableName + ""; ""); while (rs.next()) { maxId = rs.getLong(1); }  } catch (SQLException e) { <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> } finally { if (selectStatement != null) { try { selectStatement.close(); } catch (SQLException e) { } } }  if (maxId != null) { Statement statement = null; try { statement = connection.createStatement(); statement.execute(""ALTER SEQUENCE "" + seqName + "" RESTART WITH "" + (maxId + 1) + ""; ""); } catch (SQLException e) { } finally { if (statement != null) { try { statement.close(); } catch (SQLException e) { } } try { connection.close(); } catch (SQLException e) { } } } } } }"
app/actors/ClientUpdateActor.java,"package actors;

import actors.ClientUpdateActorProtocol.ClientUpdate;
import akka.actor.UntypedActor;
import models.Client;
import play.Logger;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

public class ClientUpdateActor extends UntypedActor {
  private static DateFormat dateFormat;

  public ClientUpdateActor() {
    dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
  }

  @Override
  public void onReceive(Object message) {
    if (message instanceof ClientUpdate) {
      ClientUpdate clientUpdate = (ClientUpdate) message;

      clientUpdate.graphChangedListener.incrementUpdateIteration();
      Long updateIteration = clientUpdate.graphChangedListener.getUpdateIteration();
      if (updateIteration % 10 == 0) {
        Logger.debug(dateFormat.format(new Date()) + "" - c.UpdateGraph:"" + updateIteration);
      }

      for(Client c : clientUpdate.graphChangedListener.getClientListeners().values()) {
        //Logger.debug(dateFormat.format(new Date()) + "" - Client update ("" + c.id + "")"");
        if (clientUpdate.graphChangedListener.getGraph().getVertex(c.id) != null) {
          try {
            c.updateGraph(clientUpdate.graphChangedListener.getGraph().getVertex(c.id));
          } catch (Exception e) {
            Logger.debug(""Caught exception in ClientUpdateTask: "" + e.getLocalizedMessage());
          }
        } else {
          //Logger.debug(dateFormat.format(new Date()) + "" - clientUpdate.graph.getVertex(c.id) == null"");
          //Logger.debug(dateFormat.format(new Date()) + "" - clientUpdate.graph = "" + clientUpdate.graphChangedListener.getGraph());
          //Logger.debug(dateFormat.format(new Date()) + "" - c.id = "" + c.id);
        }
      }
    }
  }
}

","package actors; public class ClientUpdateActor extends UntypedActor { private static DateFormat dateFormat; public ClientUpdateActor() { dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); } @Override
  public void onReceive(Object message) { if (message instanceof ClientUpdate) { ClientUpdate clientUpdate = (ClientUpdate) message; clientUpdate.graphChangedListener.incrementUpdateIteration(); Long updateIteration = clientUpdate.graphChangedListener.getUpdateIteration(); if (updateIteration % 10 == 0) { } for(Client c : clientUpdate.graphChangedListener.getClientListeners().values()) { if (clientUpdate.graphChangedListener.getGraph().getVertex(c.id) != null) { try { c.updateGraph(clientUpdate.graphChangedListener.getGraph().getVertex(c.id)); } catch (Exception e) { } } else { } } } } }",0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0,"package actors; public class ClientUpdateActor extends UntypedActor { private static DateFormat dateFormat; public ClientUpdateActor() { dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); } @Override
  public void onReceive(Object message) { if (message instanceof ClientUpdate) { ClientUpdate clientUpdate = (ClientUpdate) message; clientUpdate.graphChangedListener.incrementUpdateIteration(); Long updateIteration = clientUpdate.graphChangedListener.getUpdateIteration(); if (updateIteration % 10 == 0) { <FILL_ME> } for(Client c : clientUpdate.graphChangedListener.getClientListeners().values()) { if (clientUpdate.graphChangedListener.getGraph().getVertex(c.id) != null) { try { c.updateGraph(clientUpdate.graphChangedListener.getGraph().getVertex(c.id)); } catch (Exception e) { <FILL_ME> } } else { } } } } } ","package actors; 
import actors.ClientUpdateActorProtocol.ClientUpdate; import akka.actor.UntypedActor; import models.Client; import play.Logger; 
import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.Date;  public class ClientUpdateActor extends UntypedActor { private static DateFormat dateFormat;  public ClientUpdateActor() { dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); }  @Override
  public void onReceive(Object message) { if (message instanceof ClientUpdate) { ClientUpdate clientUpdate = (ClientUpdate) message;  clientUpdate.graphChangedListener.incrementUpdateIteration(); Long updateIteration = clientUpdate.graphChangedListener.getUpdateIteration(); if (updateIteration % 10 == 0) { <FILL_ME> }  for(Client c : clientUpdate.graphChangedListener.getClientListeners().values()) { //Logger.debug(dateFormat.format(new Date()) + "" - Client update ("" + c.id + "")""); if (clientUpdate.graphChangedListener.getGraph().getVertex(c.id) != null) { try { c.updateGraph(clientUpdate.graphChangedListener.getGraph().getVertex(c.id)); } catch (Exception e) { <FILL_ME> } } else { //Logger.debug(dateFormat.format(new Date()) + "" - clientUpdate.graph.getVertex(c.id) == null""); //Logger.debug(dateFormat.format(new Date()) + "" - clientUpdate.graph = "" + clientUpdate.graphChangedListener.getGraph()); //Logger.debug(dateFormat.format(new Date()) + "" - c.id = "" + c.id); } } } } } 
 "
app/actors/ClientUpdateActorProtocol.java,"package actors;

import models.IteratedBreadboardGraphChangedListener;

public class ClientUpdateActorProtocol {
  public static class ClientUpdate {
    public final IteratedBreadboardGraphChangedListener graphChangedListener;

    public ClientUpdate(IteratedBreadboardGraphChangedListener graphChangedListener) {
      this.graphChangedListener = graphChangedListener;
    }
  }
}

",package actors; public class ClientUpdateActorProtocol { public static class ClientUpdate { public final IteratedBreadboardGraphChangedListener graphChangedListener; public ClientUpdate(IteratedBreadboardGraphChangedListener graphChangedListener) { this.graphChangedListener = graphChangedListener; } } },0 0 0 0 0 0 0 0 0 0,package actors; public class ClientUpdateActorProtocol { public static class ClientUpdate { public final IteratedBreadboardGraphChangedListener graphChangedListener; public ClientUpdate(IteratedBreadboardGraphChangedListener graphChangedListener) { this.graphChangedListener = graphChangedListener; } } } ,"package actors; 
import models.IteratedBreadboardGraphChangedListener;  public class ClientUpdateActorProtocol { public static class ClientUpdate { public final IteratedBreadboardGraphChangedListener graphChangedListener;  public ClientUpdate(IteratedBreadboardGraphChangedListener graphChangedListener) { this.graphChangedListener = graphChangedListener; } } } 
 "
app/actors/FileWatcherActor.java,"package actors;

import actors.FileWatcherActorProtocol.FileWatch;
import akka.actor.UntypedActor;
import models.Admin;
import models.FileWatcher;
import org.apache.commons.io.FileUtils;
import play.Logger;

import java.io.IOException;
import java.nio.file.*;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;
import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;
import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;

public class FileWatcherActor extends UntypedActor {
  private static DateFormat dateFormat;

  public FileWatcherActor() {
    dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
  }


  @Override
  public void onReceive(Object message) {
    if (message instanceof FileWatch) {
      FileWatcher fileWatcher = ((FileWatch) message).fileWatcher;

      // If fileMode for the selected experiment is false, do nothing
      /* TODO: if there are multiple admins listening, they could each be watching different experiments which is weird in the context of a single file watcher */
      // if ( fileWatcher.getAdminListeners().isEmpty() || fileWatcher.getAdminListeners().get(0).getUser().selectedExperiment == null || (! fileWatcher.getAdminListeners().get(0).getUser().selectedExperiment.getFileMode()) ) {
      //  return;
      //}
      fileWatcher.incrementUpdateIteration();
      Long updateIteration = fileWatcher.getUpdateIteration();
      if (updateIteration % 100 == 0) {
        Logger.debug(dateFormat.format(new Date()) + "" - FileWatch:"" + updateIteration);
      }

      WatchKey watchKey;
      boolean changed = false;
      watchKey = fileWatcher.getWatcher().poll();
      if (watchKey == null) {
        return;
      }

      Path dir = fileWatcher.getWatchKeys().get(watchKey);
      if (dir == null) {
        Logger.error(""Event triggered from watchKey not registered properly."");
        return;
      }

      for (WatchEvent<?> event: watchKey.pollEvents()) {
        WatchEvent<Path> ev = (WatchEvent<Path>) event;
        Path name = ev.context();
        Path child = dir.resolve(name);
        Logger.debug(child.toString());
        String selectedExperimentDirectory = (fileWatcher.getAdminListeners().get(0).getUser().selectedExperiment == null) ? """" : fileWatcher.getAdminListeners().get(0).getUser().selectedExperiment.getDirectoryName();
        boolean selectedExperimentChanged = child.toString().contains(selectedExperimentDirectory);

        if (ev.kind() == ENTRY_CREATE && child.toFile().isDirectory()) {
          // new directory, need to watch it
          try {
            fileWatcher.registerRecursive(child);
          } catch (IOException ioe) {
            Logger.error(""Unable to watch directory "" + child.toFile().getPath() + "" check the permissions."");
          }
          Logger.debug(""DIRECTORY ENTRY_CREATE"");
        } else if ((ev.kind() == ENTRY_CREATE || ev.kind() == ENTRY_MODIFY) && child.toFile().isFile() && selectedExperimentChanged) {
          // A file was modified or created in the selected experiment directory, update the admin
          changed = true;
          if (child.toFile().getParent().endsWith(""/Steps"")) {
            // Step was modified or created, send to ScriptEngine
            try {
              String stepContents = FileUtils.readFileToString(child.toFile());
              fileWatcher.loadStep(stepContents, fileWatcher.getAdminListeners().get(0).getOut(), child.getFileName().toString());
            } catch (IOException ioe) {
              Logger.error(""Unable to read contents of Step "" + child.getFileName().toString() + "" check your permissions."");
            }
          }
          Logger.debug(""FILE ENTRY_MODIFY || ENTRY_CREATE"");
        } else if (ev.kind() == ENTRY_DELETE) {
          Logger.debug(""ENTRY_DELETE"");
        }
      }

      if (changed) {
        // Something was changed, let's update all admin listeners
        for(Admin a : fileWatcher.getAdminListeners()) {
          a.update();
        }
      }

      boolean valid = watchKey.reset();
      if (!valid) {
        fileWatcher.getWatchKeys().remove(watchKey);
        Logger.debug(""Watched directory was deleted."");
      }
    }
  }
}

","package actors; public class FileWatcherActor extends UntypedActor { private static DateFormat dateFormat; public FileWatcherActor() { dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); } @Override
  public void onReceive(Object message) { if (message instanceof FileWatch) { FileWatcher fileWatcher = ((FileWatch) message).fileWatcher; fileWatcher.incrementUpdateIteration(); Long updateIteration = fileWatcher.getUpdateIteration(); if (updateIteration % 100 == 0) { } WatchKey watchKey; boolean changed = false; watchKey = fileWatcher.getWatcher().poll(); if (watchKey == null) { return; } Path dir = fileWatcher.getWatchKeys().get(watchKey); if (dir == null) { return; } for (WatchEvent<?> event: watchKey.pollEvents()) { WatchEvent<Path> ev = (WatchEvent<Path>) event; Path name = ev.context(); Path child = dir.resolve(name); String selectedExperimentDirectory = (fileWatcher.getAdminListeners().get(0).getUser().selectedExperiment == null) ? """" : fileWatcher.getAdminListeners().get(0).getUser().selectedExperiment.getDirectoryName(); boolean selectedExperimentChanged = child.toString().contains(selectedExperimentDirectory); if (ev.kind() == ENTRY_CREATE && child.toFile().isDirectory()) { try { fileWatcher.registerRecursive(child); } catch (IOException ioe) { } } else if ((ev.kind() == ENTRY_CREATE || ev.kind() == ENTRY_MODIFY) && child.toFile().isFile() && selectedExperimentChanged) { changed = true; if (child.toFile().getParent().endsWith(""/Steps"")) { try { String stepContents = FileUtils.readFileToString(child.toFile()); fileWatcher.loadStep(stepContents, fileWatcher.getAdminListeners().get(0).getOut(), child.getFileName().toString()); } catch (IOException ioe) { } } } else if (ev.kind() == ENTRY_DELETE) { } } if (changed) { for(Admin a : fileWatcher.getAdminListeners()) { a.update(); } } boolean valid = watchKey.reset(); if (!valid) { fileWatcher.getWatchKeys().remove(watchKey); } } } }",0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0,"package actors; public class FileWatcherActor extends UntypedActor { private static DateFormat dateFormat; public FileWatcherActor() { dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); } <FILL_ME> <FILL_ME> @Override
  public void onReceive(Object message) { if (message instanceof FileWatch) { FileWatcher fileWatcher = ((FileWatch) message).fileWatcher; fileWatcher.incrementUpdateIteration(); Long updateIteration = fileWatcher.getUpdateIteration(); if (updateIteration % 100 == 0) { <FILL_ME> } WatchKey watchKey; boolean changed = false; watchKey = fileWatcher.getWatcher().poll(); if (watchKey == null) { return; } Path dir = fileWatcher.getWatchKeys().get(watchKey); if (dir == null) { <FILL_ME> return; } for (WatchEvent<?> event: watchKey.pollEvents()) { WatchEvent<Path> ev = (WatchEvent<Path>) event; Path name = ev.context(); Path child = dir.resolve(name); <FILL_ME> String selectedExperimentDirectory = (fileWatcher.getAdminListeners().get(0).getUser().selectedExperiment == null) ? """" : fileWatcher.getAdminListeners().get(0).getUser().selectedExperiment.getDirectoryName(); boolean selectedExperimentChanged = child.toString().contains(selectedExperimentDirectory); if (ev.kind() == ENTRY_CREATE && child.toFile().isDirectory()) { try { fileWatcher.registerRecursive(child); } catch (IOException ioe) { <FILL_ME> <FILL_ME> } } else if ((ev.kind() == ENTRY_CREATE || ev.kind() == ENTRY_MODIFY) && child.toFile().isFile() && selectedExperimentChanged) { changed = true; if (child.toFile().getParent().endsWith(""/Steps"")) { try { String stepContents = FileUtils.readFileToString(child.toFile()); fileWatcher.loadStep(stepContents, fileWatcher.getAdminListeners().get(0).getOut(), child.getFileName().toString()); } catch (IOException ioe) { } } } else if (ev.kind() == ENTRY_DELETE) { <FILL_ME> } } if (changed) { for(Admin a : fileWatcher.getAdminListeners()) { a.update(); } } boolean valid = watchKey.reset(); if (!valid) { fileWatcher.getWatchKeys().remove(watchKey); <FILL_ME> } } } } ","package actors; 
import actors.FileWatcherActorProtocol.FileWatch; import akka.actor.UntypedActor; import models.Admin; import models.FileWatcher; import org.apache.commons.io.FileUtils; import play.Logger; 
import java.io.IOException; import java.nio.file.*; import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.Date; 
import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE; import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE; import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;  public class FileWatcherActor extends UntypedActor { private static DateFormat dateFormat;  public FileWatcherActor() { dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); } <FILL_ME> <FILL_ME> 
 @Override
  public void onReceive(Object message) { if (message instanceof FileWatch) { FileWatcher fileWatcher = ((FileWatch) message).fileWatcher;   // If fileMode for the selected experiment is false, do nothing /* TODO: if there are multiple admins listening, they could each be watching different experiments which is weird in the context of a single file watcher */ // if ( fileWatcher.getAdminListeners().isEmpty() || fileWatcher.getAdminListeners().get(0).getUser().selectedExperiment == null || (! fileWatcher.getAdminListeners().get(0).getUser().selectedExperiment.getFileMode()) ) { //  return; fileWatcher.incrementUpdateIteration(); Long updateIteration = fileWatcher.getUpdateIteration(); if (updateIteration % 100 == 0) { <FILL_ME> } //} WatchKey watchKey; boolean changed = false; watchKey = fileWatcher.getWatcher().poll(); if (watchKey == null) { return; }  Path dir = fileWatcher.getWatchKeys().get(watchKey); if (dir == null) { <FILL_ME> return; }  for (WatchEvent<?> event: watchKey.pollEvents()) { WatchEvent<Path> ev = (WatchEvent<Path>) event; Path name = ev.context(); Path child = dir.resolve(name); <FILL_ME> String selectedExperimentDirectory = (fileWatcher.getAdminListeners().get(0).getUser().selectedExperiment == null) ? """" : fileWatcher.getAdminListeners().get(0).getUser().selectedExperiment.getDirectoryName(); boolean selectedExperimentChanged = child.toString().contains(selectedExperimentDirectory);  if (ev.kind() == ENTRY_CREATE && child.toFile().isDirectory()) {  try { fileWatcher.registerRecursive(child); } catch (IOException ioe) { <FILL_ME> <FILL_ME> } } else if ((ev.kind() == ENTRY_CREATE || ev.kind() == ENTRY_MODIFY) && child.toFile().isFile() && selectedExperimentChanged) { // new directory, need to watch it changed = true; if (child.toFile().getParent().endsWith(""/Steps"")) { // A file was modified or created in the selected experiment directory, update the admin try { String stepContents = FileUtils.readFileToString(child.toFile()); fileWatcher.loadStep(stepContents, fileWatcher.getAdminListeners().get(0).getOut(), child.getFileName().toString()); } catch (IOException ioe) { } } } else if (ev.kind() == ENTRY_DELETE) { <FILL_ME> } } // Step was modified or created, send to ScriptEngine if (changed) {  for(Admin a : fileWatcher.getAdminListeners()) { a.update(); } } // Something was changed, let's update all admin listeners boolean valid = watchKey.reset(); if (!valid) { fileWatcher.getWatchKeys().remove(watchKey); <FILL_ME> } } } }  "
app/actors/FileWatcherActorProtocol.java,"package actors;

import models.FileWatcher;

public class FileWatcherActorProtocol {
  public static class FileWatch {
    final FileWatcher fileWatcher;
    public FileWatch(FileWatcher fileWatcher) {
      this.fileWatcher = fileWatcher;
    }
  }
}

",package actors; public class FileWatcherActorProtocol { public static class FileWatch { final FileWatcher fileWatcher; public FileWatch(FileWatcher fileWatcher) { this.fileWatcher = fileWatcher; } } },0 0 0 0 0 0 0 0 0 0,package actors; public class FileWatcherActorProtocol { public static class FileWatch { final FileWatcher fileWatcher; public FileWatch(FileWatcher fileWatcher) { this.fileWatcher = fileWatcher; } } } ,"package actors; 
import models.FileWatcher;  public class FileWatcherActorProtocol { public static class FileWatch { final FileWatcher fileWatcher; public FileWatch(FileWatcher fileWatcher) { this.fileWatcher = fileWatcher; } } } 
 "
app/controllers/AMTAdmin.java,"package controllers;

import com.amazonaws.AmazonClientException;
import com.amazonaws.AmazonServiceException;
import com.amazonaws.auth.AWSStaticCredentialsProvider;
import com.amazonaws.auth.BasicAWSCredentials;
import com.amazonaws.client.builder.AwsClientBuilder;
import com.amazonaws.services.mturk.AmazonMTurk;
import com.amazonaws.services.mturk.AmazonMTurkClientBuilder;
import com.amazonaws.services.mturk.model.*;
import com.amazonaws.services.mturk.model.Locale;
import com.amazonaws.services.mturk.model.QualificationRequirement;
import com.avaje.ebean.*;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import models.*;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.IOUtils;
import play.Logger;
import play.Play;
import play.libs.*;
import play.mvc.Controller;
import play.mvc.Http;
import play.mvc.Result;
import play.mvc.Security;

import java.io.*;
import java.lang.reflect.Type;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.*;

public class AMTAdmin extends Controller {
  private static final String PRODUCTION_ENDPOINT = ""mturk-requester.us-east-1.amazonaws.com"";
  private static final String SANDBOX_ENDPOINT = ""mturk-requester-sandbox.us-east-1.amazonaws.com"";
  private static final String SIGNING_REGION = ""us-east-1"";
  private static final String SECRET_KEY = Play.application().configuration().getString(""amt.secretKey"");
  private static final String ACCESS_KEY = Play.application().configuration().getString(""amt.accessKey"");
  private static final String PARTICIPANT_QUALIFICATION_PREFIX = ""breadboard_participant_"";

  @Security.Authenticated(Secured.class)
  public static Result getAccountBalance(Boolean sandbox) {
    if (SECRET_KEY == null || ACCESS_KEY == null) {
      return badRequest(""No AWS keys provided"");
    }
    try {
      AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY));
      AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials);
      builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION));
      AmazonMTurk mTurk = builder.build();
      GetAccountBalanceRequest getAccountBalanceRequest= new GetAccountBalanceRequest();
      GetAccountBalanceResult getAccountBalanceResult = mTurk.getAccountBalance(getAccountBalanceRequest);
      String availableBalance = getAccountBalanceResult.getAvailableBalance();
      String onHoldBalance = getAccountBalanceResult.getOnHoldBalance();
      ObjectNode returnJson = Json.newObject();
      returnJson.put(""availableBalance"", availableBalance);
      returnJson.put(""onHoldBalance"", onHoldBalance);
      return ok(returnJson);
    } catch (AmazonServiceException ase) {
      return badRequest(ase.getMessage());
    } catch (AmazonClientException ace) {
      return internalServerError(ace.getMessage());
    }
  }

  private static class JsonWorker {
    public String workerId;
    public List<ObjectNode> assignments = new ArrayList<>();
    public int nCompleted = 0;

    JsonWorker(String id) {
      workerId = id;
    }

    public ObjectNode toJson() {
      ObjectNode worker = Json.newObject();
      worker.put(""id"", workerId);
      worker.put(""nAssignments"", assignments.size());
      worker.put(""assignmentsCompleted"", nCompleted);
      ArrayNode jsonAssignments = worker.putArray(""assignments"");
      jsonAssignments.addAll(assignments);
      return worker;
    }
  }

  @Security.Authenticated(Secured.class)
  public static Result addQualificationType(String experimentUid, Boolean sandbox) {
    if (SECRET_KEY == null || ACCESS_KEY == null) {
      return badRequest(""No AWS keys provided"");
    }

    Experiment experiment = Experiment.findByUid(experimentUid);

    if (experiment == null) {
      return badRequest(""Invalid experiment UID."");
    }

    try {
      AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY));
      AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials);
      builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION));
      AmazonMTurk mTurk = builder.build();

      String qualificationName = PARTICIPANT_QUALIFICATION_PREFIX + experimentUid;
      String reason = ""You previously participated in this experiment."";
      // Create a new qualification type
      CreateQualificationTypeRequest createQualificationTypeRequest = new CreateQualificationTypeRequest()
          .withName(qualificationName)
          .withDescription(reason)
          .withQualificationTypeStatus(QualificationTypeStatus.Active);
      CreateQualificationTypeResult createQualificationTypeResult = mTurk.createQualificationType(createQualificationTypeRequest);
      QualificationType qualificationType = createQualificationTypeResult.getQualificationType();

      ObjectNode qualificationTypeJson = Json.newObject();

      TimeZone tz = TimeZone.getTimeZone(""UTC"");
      DateFormat df = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm'Z'"");
      df.setTimeZone(tz);

      qualificationTypeJson.put(""experimentUid"", experimentUid);
      qualificationTypeJson.put(""experimentName"", experiment.name);
      qualificationTypeJson.put(""creationTime"", df.format(qualificationType.getCreationTime()));
      qualificationTypeJson.put(""description"", qualificationType.getDescription());
      qualificationTypeJson.put(""isRequestable"", qualificationType.getIsRequestable());
      qualificationTypeJson.put(""keywords"", qualificationType.getKeywords());
      qualificationTypeJson.put(""name"", qualificationType.getName());
      qualificationTypeJson.put(""qualificationTypeId"", qualificationType.getQualificationTypeId());
      qualificationTypeJson.put(""qualificationTypeStatus"", qualificationType.getQualificationTypeStatus());
      qualificationTypeJson.put(""autoGranted"", qualificationType.getAutoGranted());

      return ok(qualificationTypeJson);
    } catch (AmazonServiceException ase) {
      return badRequest(ase.getMessage());
    } catch (AmazonClientException ace) {
      return internalServerError(ace.getMessage());
    }
  }

  public static QualificationType getQualificationTypeByName(String qualificationName, Boolean sandbox) {
    if (SECRET_KEY == null || ACCESS_KEY == null) {
      return null;
    }

    try {
      AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY));
      AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials);
      builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION));
      AmazonMTurk mTurk = builder.build();

      ListQualificationTypesRequest listQualificationTypesRequest = new ListQualificationTypesRequest()
          .withMaxResults(1)
          .withMustBeOwnedByCaller(false)
          .withMustBeRequestable(false)
          .withQuery(qualificationName);

      ListQualificationTypesResult listQualificationTypesResult = mTurk.listQualificationTypes(listQualificationTypesRequest);
      List<QualificationType> qualificationTypes = listQualificationTypesResult.getQualificationTypes();

      if (qualificationTypes.isEmpty()) {
        return null;
      }

      return qualificationTypes.get(0);
    } catch (AmazonServiceException ase) {
      return null;
    } catch (AmazonClientException ace) {
      return null;
    }
  }

  @Security.Authenticated(Secured.class)
  public static Result listQualificationTypes(Boolean sandbox) {
    if (SECRET_KEY == null || ACCESS_KEY == null) {
      return badRequest(""No AWS keys provided"");
    }

    try {
      AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY));
      AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials);
      builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION));
      AmazonMTurk mTurk = builder.build();

      List<ExperimentQualificationType> experimentQualificationTypes = new ArrayList<ExperimentQualificationType>();

      for (Experiment experiment: Experiment.findAll()) {
        ListQualificationTypesRequest listQualificationTypesRequest = new ListQualificationTypesRequest()
            .withMaxResults(1)
            .withMustBeOwnedByCaller(true)
            .withMustBeRequestable(false)
            .withQuery(PARTICIPANT_QUALIFICATION_PREFIX + experiment.uid);

        ListQualificationTypesResult listQualificationTypesResult = mTurk.listQualificationTypes(listQualificationTypesRequest);
        List<QualificationType> qualificationType = listQualificationTypesResult.getQualificationTypes();
        ExperimentQualificationType experimentQualificationType = new ExperimentQualificationType();

        if (!qualificationType.isEmpty()) {
          experimentQualificationType.qualificationType = qualificationType.get(0);
        }
        experimentQualificationType.experiment = experiment;

        experimentQualificationTypes.add(experimentQualificationType);
      }

      ObjectNode returnJson = Json.newObject();
      ArrayNode qualificationTypesJson = returnJson.putArray(""qualificationTypes"");

      TimeZone tz = TimeZone.getTimeZone(""UTC"");
      DateFormat df = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm'Z'"");
      df.setTimeZone(tz);

      for (ExperimentQualificationType experimentQualificationType : experimentQualificationTypes) {
        QualificationType qualificationType = experimentQualificationType.qualificationType;
        Experiment experiment = experimentQualificationType.experiment;

        ObjectNode qualificationTypeJson = Json.newObject();

        qualificationTypeJson.put(""label"", experiment.name + "" participant"");
        qualificationTypeJson.put(""experimentUid"", experiment.uid);
        qualificationTypeJson.put(""experimentName"", experiment.name);
        qualificationTypeJson.put(""creationTime"", (qualificationType == null) ? null : df.format(qualificationType.getCreationTime()));
        qualificationTypeJson.put(""description"", (qualificationType == null) ? null : qualificationType.getDescription());
        qualificationTypeJson.put(""isRequestable"", (qualificationType == null) ? null : qualificationType.getIsRequestable());
        qualificationTypeJson.put(""keywords"", (qualificationType == null) ? null : qualificationType.getKeywords());
        qualificationTypeJson.put(""name"", (qualificationType == null) ? null : qualificationType.getName());
        qualificationTypeJson.put(""qualificationTypeId"", (qualificationType == null) ? null : qualificationType.getQualificationTypeId());
        qualificationTypeJson.put(""qualificationTypeStatus"", (qualificationType == null) ? null : qualificationType.getQualificationTypeStatus());
        qualificationTypeJson.put(""autoGranted"", (qualificationType == null) ? null : qualificationType.getAutoGranted());
        qualificationTypesJson.add(qualificationTypeJson);
      }
      returnJson.put(""rows"", experimentQualificationTypes.size());

      return ok(returnJson);
    } catch (AmazonServiceException ase) {
      return badRequest(ase.getMessage());
    } catch (AmazonClientException ace) {
      return internalServerError(ace.getMessage());
    }
  }

  @Security.Authenticated(Secured.class)
  public static Result getExperimentQualificationTypeId(String experimentUid, Boolean sandbox) {
    if (SECRET_KEY == null || ACCESS_KEY == null) {
      return badRequest(""No AWS keys provided"");
    }

    QualificationType qualificationType = getQualificationTypeByName(PARTICIPANT_QUALIFICATION_PREFIX + experimentUid, sandbox);
    if (qualificationType == null) {
      try {
        AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY));
        AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials);
        builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION));
        AmazonMTurk mTurk = builder.build();

        String qualificationName = PARTICIPANT_QUALIFICATION_PREFIX + experimentUid;
        String reason = ""You previously participated in this experiment."";
        // Create a new qualification type
        CreateQualificationTypeRequest createQualificationTypeRequest = new CreateQualificationTypeRequest()
            .withName(qualificationName)
            .withDescription(reason)
            .withQualificationTypeStatus(QualificationTypeStatus.Active);
        CreateQualificationTypeResult createQualificationTypeResult = mTurk.createQualificationType(createQualificationTypeRequest);
        qualificationType = createQualificationTypeResult.getQualificationType();
      } catch (AmazonServiceException ase) {
        return badRequest(ase.getMessage());
      } catch (AmazonClientException ace) {
        return internalServerError(ace.getMessage());
      }
    }

    ObjectNode returnJson = Json.newObject();
    returnJson.put(""qualificationTypeId"", qualificationType.getQualificationTypeId());
    return ok(returnJson);
  }

  @Security.Authenticated(Secured.class)
  public static Result assignParticipantQualification(Boolean sandbox) {
    if (SECRET_KEY == null || ACCESS_KEY == null) {
      return badRequest(""No AWS keys provided"");
    }
    String workerId = null;
    String qualificationTypeId = null;
    JsonNode json = request().body().asJson();
    if(json == null) {
      return badRequest(""Expecting Json data"");
    } else {
      workerId = json.findPath(""workerId"").textValue();
      qualificationTypeId = json.findPath(""qualificationTypeId"").textValue();
    }

    if (workerId == null) {
      return badRequest(""Please provide an AMT worker ID."");
    }

    if (qualificationTypeId == null) {
      return badRequest(""Please provide a qualification type ID."");
    }

    try {
      AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY));
      AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials);
      builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION));
      AmazonMTurk mTurk = builder.build();

      AssociateQualificationWithWorkerRequest associateQualificationWithWorkerRequest = new AssociateQualificationWithWorkerRequest()
          .withQualificationTypeId(qualificationTypeId)
          .withIntegerValue(1)
          .withSendNotification(false)
          .withWorkerId(workerId);

      mTurk.associateQualificationWithWorker(associateQualificationWithWorkerRequest);
      return ok();
    } catch (AmazonServiceException ase) {
      return badRequest(ase.getMessage());
    } catch (AmazonClientException ace) {
      return internalServerError(ace.getMessage());
    }
  }

  @Security.Authenticated(Secured.class)
  public static Result removeParticipantQualification(Boolean sandbox) {
    if (SECRET_KEY == null || ACCESS_KEY == null) {
      return badRequest(""No AWS keys provided"");
    }
    String workerId = null;
    String qualificationTypeId = null;
    JsonNode json = request().body().asJson();
    if(json == null) {
      return badRequest(""Expecting Json data"");
    } else {
      workerId = json.findPath(""workerId"").textValue();
      qualificationTypeId = json.findPath(""qualificationTypeId"").textValue();
    }

    if (workerId == null) {
      return badRequest(""Please provide an AMT worker ID."");
    }

    if (qualificationTypeId == null) {
      return badRequest(""Please provide a qualification type ID."");
    }

    try {
      AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY));
      AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials);
      builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION));
      AmazonMTurk mTurk = builder.build();

      DisassociateQualificationFromWorkerRequest disassociateQualificationFromWorkerRequest = new DisassociateQualificationFromWorkerRequest()
          .withQualificationTypeId(qualificationTypeId)
          .withWorkerId(workerId);

      mTurk.disassociateQualificationFromWorker(disassociateQualificationFromWorkerRequest);
      return ok();
    } catch (AmazonServiceException ase) {
      return badRequest(ase.getMessage());
    } catch (AmazonClientException ace) {
      return internalServerError(ace.getMessage());
    }
  }

  @Security.Authenticated(Secured.class)
  public static Result getQualificationScore(Boolean sandbox) {
    if (SECRET_KEY == null || ACCESS_KEY == null) {
      return badRequest(""No AWS keys provided"");
    }
    String workerId = null;
    String qualificationTypeId = null;
    JsonNode json = request().body().asJson();
    if(json == null) {
      return badRequest(""Expecting Json data"");
    } else {
      workerId = json.findPath(""workerId"").textValue();
      qualificationTypeId = json.findPath(""qualificationTypeId"").textValue();
    }

    if (workerId == null) {
      return badRequest(""Please provide an AMT worker ID."");
    }

    if (qualificationTypeId == null) {
      return badRequest(""Please provide a qualification type ID."");
    }

    try {
      AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY));
      AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials);
      builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION));
      AmazonMTurk mTurk = builder.build();

      GetQualificationScoreRequest getQualificationScoreRequest = new GetQualificationScoreRequest()
          .withQualificationTypeId(qualificationTypeId)
          .withWorkerId(workerId);

      GetQualificationScoreResult qualificationScoreResult = mTurk.getQualificationScore(getQualificationScoreRequest);
      Qualification qualification = qualificationScoreResult.getQualification();

      TimeZone tz = TimeZone.getTimeZone(""UTC"");
      DateFormat df = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm'Z'"");
      df.setTimeZone(tz);

      ObjectNode returnJson = Json.newObject();

      if (qualification == null) {
        returnJson.put(""status"", ""None"");
      } else {
        returnJson.put(""grantTime"", df.format(qualification.getGrantTime()));
        returnJson.put(""integerValue"", qualification.getIntegerValue());
        if (qualification.getLocaleValue() != null) {
          returnJson.put(""localeValue"", qualification.getLocaleValue().toString());
        }
        returnJson.put(""qualificationTypeId"", qualification.getQualificationTypeId());
        returnJson.put(""status"", qualification.getStatus());
        returnJson.put(""workerId"", qualification.getWorkerId());
      }
      return ok(returnJson);
    } catch (AmazonServiceException ase) {
      ObjectNode returnJson = Json.newObject();
      returnJson.put(""status"", ""None"");
      return ok(returnJson);
      //return badRequest(ase.getMessage());
    } catch (AmazonClientException ace) {
      return internalServerError(ace.getMessage());
    }
  }

  @Security.Authenticated(Secured.class)
  public static Result importAMTWorkers(Long experimentId, Boolean sandbox) {
    Http.MultipartFormData body = request().body().asMultipartFormData();
    Long maxUploadSize = play.Play.application().configuration().getLong(""maxUploadSize"", 50L * 1024L * 1024L);

    // Validate Content-Length header
    try {
      Long fileSize = Long.parseLong(request().getHeader(""Content-Length""), 10);
      if (fileSize > maxUploadSize) {
        return badRequest(""Uploaded file is too large"");
      }
    } catch(Exception e){
      return badRequest(""Upload was malformed"");
    }

    // Validate the size of the file
    Http.MultipartFormData.FilePart filePart = body.getFile(""file"");
    File workerCsvFile = filePart.getFile();

    Experiment experiment = Experiment.findById(experimentId);

    // Validate the other data
    if(experiment == null){
      return badRequest(""Invalid experiment ID"");
    }

    if(workerCsvFile.length() > maxUploadSize){
      return badRequest(""Uploaded file is too large"");
    }

    try {
      Reader in = new FileReader(workerCsvFile);
      try {
        Date now = new Date();
        String importTitle = ""IMPORTED_"" + experimentId + ""_"" + now.getTime();
        // Add a fake Experiment Instance
        ExperimentInstance instance = new ExperimentInstance(importTitle, experiment);
        experiment.instances.add(instance);
        experiment.save();

        // Add a fake AMTHit for the import
        AMTHit amtHit = new AMTHit();
        amtHit.creationDate = now;
        amtHit.requestId = ""IMPORTED"";
        amtHit.isValid = ""true"";
        amtHit.hitId = ""IMPORTED_"" + experimentId + ""_"" + now.getTime();
        amtHit.title = ""IMPORTED INTO "" + experiment.name + "" AT "" + now.getTime();
        amtHit.description = ""This is a fake HIT created by breadboard when importing AMT Worker IDs to prevent repeat play."";
        amtHit.lifetimeInSeconds = ""0"";
        amtHit.tutorialTime = ""0"";
        amtHit.maxAssignments = ""0"";
        amtHit.externalURL = ""IMPORTED"";
        amtHit.reward = ""0"";
        amtHit.disallowPrevious = ""none"";
        amtHit.sandbox = sandbox;
        amtHit.setExtended(false);
        amtHit.experimentInstance = instance;
        amtHit.save();

        int assignmentIndex = 0;
        CSVFormat format = CSVFormat.DEFAULT;
        for (CSVRecord record : format.parse(in)) {
          String workerId = record.get(0);
          Logger.debug(""workerId = "" + workerId);
          AMTWorker amtWorker = AMTWorker.findByWorkerId(workerId);
          if (amtWorker == null) {
            amtWorker = new AMTWorker();
            amtWorker.workerId = workerId;
            amtWorker.score = """";
            amtWorker.completion = """";
            amtWorker.amtHit = amtHit;
            amtWorker.save();
          }

          // Add an assignment for the current experiment and mark it as completed
          AMTAssignment amtAssignment = new AMTAssignment();
          amtAssignment.assignmentId = ""IMPORTED_"" + experimentId + ""_"" + now.getTime() + ""_"" + (++assignmentIndex);
          amtAssignment.workerId = workerId;
          amtAssignment.assignmentCompleted = true;
          amtAssignment.assignmentStatus = ""IMPORTED"";
          amtAssignment.autoApprovalTime = ""IMPORTED"";
          amtAssignment.acceptTime = null;
          amtAssignment.submitTime = null;
          amtAssignment.answer = """";
          amtAssignment.score = """";
          amtAssignment.reason = ""IMPORTED"";
          amtAssignment.completion = """";
          amtAssignment.bonusAmount = """";
          amtAssignment.bonusGranted = false;
          amtAssignment.workerBlocked = false;
          amtAssignment.qualificationAssigned = false;
          amtAssignment.amtHit = amtHit;
          amtAssignment.save();
        }
      } finally {
        in.close();
      }
    } catch (IOException ioe) {
      return badRequest(""Error reading uploaded file"");
    }

    return ok();
  }

  @Security.Authenticated(Secured.class)
  public static Result disassociateQualificationFromWorker(String qualificationTypeId, Boolean sandbox) {
    if (SECRET_KEY == null || ACCESS_KEY == null) {
      return badRequest(""No AWS keys provided"");
    }

    String workerId;
    JsonNode json = request().body().asJson();
    if(json == null) {
      return badRequest(""Expecting Json data"");
    } else {
      workerId = json.findPath(""workerId"").textValue();
    }

    if (workerId == null) {
      return badRequest(""Please provide an AMT worker ID."");
    }

    try {
      AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY));
      AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials);
      builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION));
      AmazonMTurk mTurk = builder.build();
      DisassociateQualificationFromWorkerRequest disassociateQualificationFromWorkerRequest = new DisassociateQualificationFromWorkerRequest()
          .withQualificationTypeId(qualificationTypeId)
          .withWorkerId(workerId)
          .withReason(""Allowing re-participation in this experiment type."");

      mTurk.disassociateQualificationFromWorker(disassociateQualificationFromWorkerRequest);

      return ok();
    } catch (AmazonServiceException ase) {
      return badRequest(ase.getMessage());
    } catch (AmazonClientException ace) {
      return internalServerError(ace.getMessage());
    }
  }

  @Security.Authenticated(Secured.class)
  public static Result listWorkersWithQualificationType(String qualificationTypeId, Integer maxResults, String nextToken, Boolean sandbox) {
    if (SECRET_KEY == null || ACCESS_KEY == null) {
      return badRequest(""No AWS keys provided"");
    }
    try {
      AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY));
      AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials);
      builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION));
      AmazonMTurk mTurk = builder.build();
      ListWorkersWithQualificationTypeRequest listWorkersWithQualificationTypeRequest = new ListWorkersWithQualificationTypeRequest()
          .withQualificationTypeId(qualificationTypeId)
          .withMaxResults((maxResults == null) ? 20 : maxResults)
          .withStatus(QualificationStatus.Granted);

      if (nextToken != null) listWorkersWithQualificationTypeRequest.setNextToken(nextToken);
      ListWorkersWithQualificationTypeResult listWorkersWithQualificationTypeResult = mTurk.listWorkersWithQualificationType(listWorkersWithQualificationTypeRequest);
      List<Qualification> qualifications = listWorkersWithQualificationTypeResult.getQualifications();

      ObjectNode returnJson = Json.newObject();
      ArrayNode qualificationsJson = returnJson.putArray(""qualifications"");
      TimeZone tz = TimeZone.getTimeZone(""UTC"");
      DateFormat df = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm'Z'"");
      df.setTimeZone(tz);

      for (Qualification qualification : qualifications) {
        ObjectNode qualificationJson = Json.newObject();
        qualificationJson.put(""qualificationTypeId"", qualification.getQualificationTypeId());
        qualificationJson.put(""grantTime"", df.format(qualification.getGrantTime()));
        qualificationJson.put(""integerValue"", qualification.getIntegerValue());
        qualificationJson.put(""status"", qualification.getStatus());
        qualificationJson.put(""workerId"", qualification.getWorkerId());
        qualificationsJson.add(qualificationJson);
      }
      returnJson.put(""rows"", listWorkersWithQualificationTypeResult.getNumResults());
      returnJson.put(""nextToken"", listWorkersWithQualificationTypeResult.getNextToken());

      return ok(returnJson);
    } catch (AmazonServiceException ase) {
      return badRequest(ase.getMessage());
    } catch (AmazonClientException ace) {
      return internalServerError(ace.getMessage());
    }
  }

  @Security.Authenticated(Secured.class)
  public static Result getAMTWorkers(Long experimentId, Boolean sandbox, Integer limit, Integer offset, String search) {
    HashMap<String, JsonWorker> amtWorkerAssignments = new HashMap<>();
    ObjectNode returnJson = Json.newObject();

    /*
    Experiment experiment = Experiment.findById(experimentId);

    if (experiment == null) {
      return badRequest(""Invalid experiment ID"");
    }
    */
    // TODO: There is a bug in the interaction between distinct and limit in H2 1.3.172,
    // Need to upgrade to latest version of H2 to return exactly limit workers
    // should be fixed in a commit here:
    // https://github.com/h2database/h2database/pull/578/files
    //""(select distinct worker_id from amt_assignments "" +

    // Return all workers with their assignments and names and UIDs of experiments

    String workerCountSql = ""select count(distinct worker_id) as worker_count from amt_assignments "" +
        "" where worker_id like CONCAT(:search, '%')"" +
        "" and worker_id in "" +
        ""(select worker_id from amt_assignments "" +
        "" where amt_hit_id in "" +
        ""(select id from amt_hits where sandbox = :sandbox));"";

    SqlRow sqlRow = Ebean.createSqlQuery(workerCountSql)
        .setParameter(""search"", search)
        .setParameter(""sandbox"", (sandbox) ? 1 : 0)
        .findUnique();
    Long workerCount = sqlRow.getLong(""worker_count"");

    String workerIdSql = ""select distinct worker_id from amt_assignments "" +
        "" where worker_id like CONCAT(:search, '%')"" +
        "" and worker_id in "" +
        ""(select worker_id from amt_assignments "" +
        "" where amt_hit_id in "" +
        ""(select id from amt_hits where sandbox = :sandbox))"" +
        "" order by worker_id limit :limit offset :offset"";

    //"" where worker_id like ':search%'"" +
    /*
    String sql = ""select * from amt_assignments "" +
        ""where worker_id in "" +
        ""(select worker_id from amt_assignments "" +
        "" where worker_id like CONCAT(:search, '%')"" +
        "" and amt_hit_id in "" +
        ""(select id from amt_hits where sandbox = :sandbox and experiment_instance_id in "" +
        ""(select id from experiment_instances where experiment_id = :experimentId)) "" +
        ""order by worker_id limit :limit offset :offset) order by worker_id;"";
       */

     SqlQuery sqlQuery = Ebean.createSqlQuery(workerIdSql)
        .setParameter(""limit"", limit)
        .setParameter(""offset"", offset)
        .setParameter(""search"", search)
        .setParameter(""sandbox"", (sandbox) ? 1 : 0);

     //Logger.debug(sqlQuery.toString());

      List<SqlRow> workerIds = sqlQuery.findList();

      returnJson.put(""total"", workerCount);
      returnJson.put(""offset"", offset);
      returnJson.put(""limit"", limit);

      // This is necessary because of the bug regarding distinct + limit
    int endI = Math.min(limit, workerIds.size());
    for (int i = 0; i < endI; i++) {
      SqlRow row = workerIds.get(i);
      String workerId = row.getString(""worker_id"");
      List<AMTAssignment> assignments = AMTAssignment.find
          .where()
          .eq(""worker_id"", workerId)
          .findList();

      if (! amtWorkerAssignments.containsKey(workerId)) {
        amtWorkerAssignments.put(workerId, new JsonWorker(workerId));
      }

      JsonWorker jsonWorker = amtWorkerAssignments.get(workerId);
      for (AMTAssignment assignment : assignments) {
        AMTHit hit = assignment.amtHit;
        ExperimentInstance instance = hit.experimentInstance;
        Experiment experiment = (instance == null) ? null : instance.experiment;

        String experimentName = (experiment == null) ? """" : experiment.name;
        Long eId = (experiment == null) ? -1L : experiment.id;
        String eUid = (experiment == null) ? """" : experiment.uid;

        Boolean assignmentCompleted = assignment.assignmentCompleted;;
        if (assignmentCompleted != null && assignmentCompleted) jsonWorker.nCompleted++;

        ObjectNode amtAssignment = Json.newObject();

        amtAssignment.put(""id"", assignment.id);
        amtAssignment.put(""assignmentId"", assignment.assignmentId);
        amtAssignment.put(""workerId"", workerId);
        amtAssignment.put(""assignmentStatus"", assignment.assignmentStatus);
        amtAssignment.put(""autoApprovalTime"", assignment.autoApprovalTime);
        amtAssignment.put(""acceptTime"", assignment.acceptTime);
        amtAssignment.put(""submitTime"", assignment.submitTime);
        amtAssignment.put(""answer"", assignment.answer);
        amtAssignment.put(""score"", assignment.score);
        amtAssignment.put(""reason"", assignment.reason);
        amtAssignment.put(""completion"", assignment.completion);
        amtAssignment.put(""assignmentCompleted"", assignmentCompleted);
        amtAssignment.put(""bonusGranted"", assignment.bonusGranted);
        amtAssignment.put(""bonusAmount"", assignment.bonusAmount);
        amtAssignment.put(""workerBlocked"", assignment.workerBlocked);
        amtAssignment.put(""qualificationAssigned"", assignment.qualificationAssigned);
        amtAssignment.put(""experimentName"", experimentName);
        amtAssignment.put(""experimentUid"", eUid);
        amtAssignment.put(""experimentId"", eId);

        jsonWorker.assignments.add(amtAssignment);
      }

    }

    ArrayNode amtWorkersJson = returnJson.putArray(""amtWorkers"");

    for (JsonWorker jsonWorker : amtWorkerAssignments.values()) {
      amtWorkersJson.add(jsonWorker.toJson());
    }
    returnJson.put(""rows"", amtWorkerAssignments.size());

    /*
    for (Map.Entry<String, List<ObjectNode>> entry : amtWorkerAssignments.entrySet()) {
      ObjectNode worker = Json.newObject();
      int nCompleted = 0;
      worker.put(""id"", entry.getKey());
      worker.put(""nAssignments"", entry.getValue().size());
      ArrayNode workerAssignments = worker.putArray(""assignments"");
      for (AMTAssignment assignment : entry.getValue()) {
        if (assignment != null) {
          if (assignment.assignmentCompleted != null && assignment.assignmentCompleted) nCompleted++;
          workerAssignments.add(assignment.toJson());
        }
      }
      worker.put(""assignmentsCompleted"", nCompleted);
      amtWorkersJson.add(worker);
    }
    */

    return ok(returnJson);
  }

  @Security.Authenticated(Secured.class)
  public static Result listHITs(String nextToken, Integer maxResults, Boolean sandbox) {
    if (SECRET_KEY == null || ACCESS_KEY == null) {
      return badRequest(""No AWS keys provided"");
    }
    try {
      AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY));
      AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials);
      builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION));
      AmazonMTurk mTurk = builder.build();
      ListHITsRequest listHITsRequest = new ListHITsRequest().withMaxResults((maxResults == null) ? 20 : maxResults);
      if (nextToken != null) listHITsRequest.setNextToken(nextToken);
      ListHITsResult hitResults = mTurk.listHITs(listHITsRequest);
      List<HIT> hits = hitResults.getHITs();

      // Update amt_hits table
      for (HIT hit : hits) {
        AMTHit amtHit = AMTHit.findByHitId(hit.getHITId());
        if (amtHit == null) {
          amtHit = new AMTHit();
        }
        amtHit.hitId = hit.getHITId();
        amtHit.creationDate = hit.getCreationTime();
        amtHit.title = hit.getTitle();
        amtHit.description = hit.getDescription();
        amtHit.maxAssignments = hit.getMaxAssignments().toString();
        amtHit.reward = hit.getReward();
        amtHit.sandbox = sandbox;
        amtHit.save();
      }

      String next = hitResults.getNextToken();
      ObjectNode returnJson = Json.newObject();
      returnJson.put(""hits"", Json.toJson(hits));
      returnJson.put(""nextToken"", next);
      return ok(returnJson);
    } catch (AmazonServiceException ase) {
      return badRequest(ase.getMessage());
    } catch (AmazonClientException ace) {
      return internalServerError(ace.getMessage());
    }
  }

  @Security.Authenticated(Secured.class)
  public static Result listAssignmentsForHIT(String hitId, Integer maxResults, String nextToken, Boolean sandbox) {
    if (SECRET_KEY == null || ACCESS_KEY == null) {
      return badRequest(""No AWS keys provided"");
    }
    try {
      AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY));
      AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials);
      builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION));
      AmazonMTurk mTurk = builder.build();
      ListAssignmentsForHITRequest listAssignmentsForHITRequest = new ListAssignmentsForHITRequest().withMaxResults(maxResults).withHITId(hitId);
      ObjectNode returnJson = Json.newObject();
      ArrayNode jsonAssignments = returnJson.putArray(""assignments"");
      if (nextToken != null) listAssignmentsForHITRequest.setNextToken(nextToken);
      ListAssignmentsForHITResult assignmentResults = mTurk.listAssignmentsForHIT(listAssignmentsForHITRequest);
      List<Assignment> assignments = assignmentResults.getAssignments();

      TimeZone tz = TimeZone.getTimeZone(""UTC"");
      DateFormat df = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm'Z'"");
      df.setTimeZone(tz);

      // Update amt_assignments table
      for (Assignment assignment : assignments) {
        AMTHit hit = AMTHit.findByHitId(assignment.getHITId());
        AMTAssignment amtAssignment = hit.getAMTAssignmentById(assignment.getAssignmentId());
        boolean update = true;
        if (amtAssignment == null) {
          amtAssignment = new AMTAssignment();
          // Default to incomplete, require checking completed box to prevent repeat play
          amtAssignment.assignmentCompleted = false;
          update = false;
        }
        amtAssignment.amtHit = hit;
        amtAssignment.assignmentId = assignment.getAssignmentId();
        amtAssignment.workerId = assignment.getWorkerId();
        amtAssignment.assignmentStatus = assignment.getAssignmentStatus();
        amtAssignment.autoApprovalTime = assignment.getAutoApprovalTime().toString();
        amtAssignment.acceptTime = (assignment.getAcceptTime() == null) ? null :  df.format(assignment.getAcceptTime());
        amtAssignment.submitTime = (assignment.getSubmitTime() == null) ? null :  df.format(assignment.getSubmitTime());
        amtAssignment.answer = assignment.getAnswer();

        if (!update) {
          hit.amtAssignments.add(amtAssignment);
        }
        hit.save();

        ObjectNode jsonAssignment = Json.newObject();
        jsonAssignment.put(""assignmentId"", amtAssignment.assignmentId);
        jsonAssignment.put(""workerId"", amtAssignment.workerId);
        jsonAssignment.put(""approvalTime"", (assignment.getApprovalTime() == null) ? null : df.format(assignment.getApprovalTime()));
        jsonAssignment.put(""rejectionTime"", (assignment.getRejectionTime() == null) ? null : df.format(assignment.getRejectionTime()));
        jsonAssignment.put(""answer"", amtAssignment.answer);
        jsonAssignment.put(""assignmentCompleted"", amtAssignment.assignmentCompleted);

        jsonAssignments.add(jsonAssignment);
      }

      String token = assignmentResults.getNextToken();
      returnJson.put(""nextToken"", token);
      return ok(returnJson);
    } catch (AmazonServiceException ase) {
      return badRequest(ase.getMessage());
    } catch (AmazonClientException ace) {
      return internalServerError(ace.getMessage());
    }
  }

  @Security.Authenticated(Secured.class)
  public static Result listBonusPaymentsForHIT(String hitId, Integer maxResults, String nextToken, Boolean sandbox) {
    if (SECRET_KEY == null || ACCESS_KEY == null) {
      return badRequest(""No AWS keys provided"");
    }
    try {
      AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY));
      AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials);
      builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION));
      AmazonMTurk mTurk = builder.build();
      ListBonusPaymentsRequest listBonusPaymentsRequest = new ListBonusPaymentsRequest().withMaxResults(maxResults).withHITId(hitId);
      if (nextToken != null) listBonusPaymentsRequest.setNextToken(nextToken);
      ListBonusPaymentsResult bonusPaymentsResults = mTurk.listBonusPayments(listBonusPaymentsRequest);
      List<BonusPayment> bonusPayments = bonusPaymentsResults.getBonusPayments();
      // Update amt_assignments table
      for (BonusPayment bonusPayment : bonusPayments) {
        AMTAssignment amtAssignment = AMTAssignment.findByAssignmentId(bonusPayment.getAssignmentId());
        if (amtAssignment != null) {
          amtAssignment.bonusGranted = true;
          amtAssignment.bonusAmount = bonusPayment.getBonusAmount();
          amtAssignment.save();
        }
      }
      String token = bonusPaymentsResults.getNextToken();
      ObjectNode returnJson = Json.newObject();
      returnJson.put(""bonusPayments"", Json.toJson(bonusPayments));
      returnJson.put(""nextToken"", token);
      return ok(returnJson);
    } catch (AmazonServiceException ase) {
      return badRequest(ase.getMessage());
    } catch (AmazonClientException ace) {
      return internalServerError(ace.getMessage());
    }
  }

  @Security.Authenticated(Secured.class)
  public static Result approveAssignment(String assignmentId, Boolean sandbox) {
    if (SECRET_KEY == null || ACCESS_KEY == null) {
      return badRequest(""No AWS keys provided"");
    }
    try {
      AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY));
      AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials);
      builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION));
      AmazonMTurk mTurk = builder.build();
      ApproveAssignmentRequest approveAssignmentRequest= new ApproveAssignmentRequest().withAssignmentId(assignmentId);
      mTurk.approveAssignment(approveAssignmentRequest);
      return ok();
    } catch (AmazonServiceException ase) {
      return badRequest(ase.getMessage());
    } catch (AmazonClientException ace) {
      return internalServerError(ace.getMessage());
    }
  }

  @Security.Authenticated(Secured.class)
  public static Result rejectAssignment(String assignmentId, Boolean sandbox) {
    if (SECRET_KEY == null || ACCESS_KEY == null) {
      return badRequest(""No AWS keys provided"");
    }
    String requesterFeedback = null;
    JsonNode json = request().body().asJson();
    if(json == null) {
      return badRequest(""Expecting Json data"");
    } else {
      requesterFeedback = json.findPath(""requesterFeedback"").textValue();
    }

    if (requesterFeedback == null) {
      return badRequest(""Please provide requester feedback."");
    }
    try {
      AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY));
      AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials);
      builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION));
      AmazonMTurk mTurk = builder.build();
      RejectAssignmentRequest rejectAssignmentRequest= new RejectAssignmentRequest()
          .withAssignmentId(assignmentId)
          .withRequesterFeedback(requesterFeedback);
      mTurk.rejectAssignment(rejectAssignmentRequest);
      return ok();
    } catch (AmazonServiceException ase) {
      return badRequest(ase.getMessage());
    } catch (AmazonClientException ace) {
      return internalServerError(ace.getMessage());
    }
  }

  @Security.Authenticated(Secured.class)
  public static Result sendBonus(String assignmentId, Boolean sandbox) {
    if (SECRET_KEY == null || ACCESS_KEY == null) {
      return badRequest(""No AWS keys provided"");
    }
    String bonusAmount = null;
    String reason = null;
    String workerId = null;
    JsonNode json = request().body().asJson();
    if(json == null) {
      return badRequest(""Expecting Json data"");
    } else {
      bonusAmount = json.findPath(""bonusAmount"").textValue();
      reason = json.findPath(""reason"").textValue();
      workerId = json.findPath(""workerId"").textValue();
    }

    if (bonusAmount == null || reason == null || workerId == null) {
      return badRequest(""Please provide workerId, bonusAmount, and reason."");
    }
    try {
      AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY));
      AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials);
      builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION));
      AmazonMTurk mTurk = builder.build();
      SendBonusRequest sendBonusRequest= new SendBonusRequest().withAssignmentId(assignmentId).withBonusAmount(bonusAmount).withReason(reason).withWorkerId(workerId);
      mTurk.sendBonus(sendBonusRequest);
      return ok();
    } catch (AmazonServiceException ase) {
      return badRequest(ase.getMessage());
    } catch (AmazonClientException ace) {
      return internalServerError(ace.getMessage());
    }
  }

  @Security.Authenticated(Secured.class)
  public static Result updateAssignmentCompleted(String assignmentId) {
    if (SECRET_KEY == null || ACCESS_KEY == null) {
      return badRequest(""No AWS keys provided"");
    }
    String completedText;

    JsonNode json = request().body().asJson();

    if(json == null) {
      return badRequest(""Expecting Json data"");
    } else {
      completedText = json.findPath(""completed"").asText();
    }

    if (completedText == null || (!(completedText.matches(""(?i)0|1|true|false"")))) {
      return badRequest(""Please provide completed as a boolean value (0, 1, true, false)."");
    }

    AMTAssignment amtAssignment = AMTAssignment.findByAssignmentId(assignmentId);

    if (amtAssignment == null) {
      return badRequest(""Invalid Assignment ID."");
    }

    Boolean completed = (completedText.matches(""(?i)1|true""));

    amtAssignment.assignmentCompleted = completed;
    amtAssignment.save();

    return ok();
  }

  @Security.Authenticated(Secured.class)
  public static Result createHIT(Boolean sandbox) {
    if (SECRET_KEY == null || ACCESS_KEY == null) {
      return badRequest(""No AWS keys provided"");
    }
    String title;
    String description;
    String reward;
    Integer maxAssignments;
    Long hitLifetime;
    Long tutorialTime;
    Long assignmentDuration;
    String keywords;
    String disallowPrevious;
    String experimentId;
    String experimentInstanceId;
    BBQualificationRequirement[] qualificationRequirements = null;

    JsonNode json = request().body().asJson();
    if (json == null) {
      return badRequest(""Expecting Json data"");
    } else {
      title = json.findPath(""title"").textValue();
      description = json.findPath(""description"").textValue();
      reward = json.findPath(""reward"").textValue();
      maxAssignments = json.findPath(""maxAssignments"").asInt(-1);
      hitLifetime = json.findPath(""hitLifetime"").asLong(-1L);
      tutorialTime = json.findPath(""tutorialTime"").asLong(-1L);
      assignmentDuration = json.findPath(""assignmentDuration"").asLong(-1L);
      keywords = json.findPath(""keywords"").textValue();
      disallowPrevious = json.findPath(""disallowPrevious"").textValue();
      experimentId = json.findPath(""experimentId"").textValue();
      experimentInstanceId = json.findPath(""experimentInstanceId"").textValue();
      Logger.debug(""qualificationRequirements.asText() = "" + json.findPath(""qualificationRequirements"").toString());
      try {
        qualificationRequirements = new ObjectMapper().readValue(json.findPath(""qualificationRequirements"").toString(), BBQualificationRequirement[].class);
      } catch(IOException ioe) {}
    }


    if (title == null || description == null || reward == null || maxAssignments < 0 || hitLifetime < 0 || tutorialTime < 0 || assignmentDuration < 0 || keywords == null || disallowPrevious == null || experimentId == null || experimentInstanceId == null) {
      return badRequest(""Please provide experiment ID, experiment instance ID, title, description, reward, max assignments, hit lifetime, tutorial time, assignment duration, keywords, and allow repeat play option."");
    }


    String rootURL = play.Play.application().configuration().getString(""breadboard.rootUrl"");
    String gameURL = String.format(""/game/%1$s/%2$s/amt"", experimentId, experimentInstanceId);
    String externalURL = rootURL + gameURL;
    Integer frameHeight = play.Play.application().configuration().getInt(""breadboard.amtFrameHeight"");
    String question = ""<ExternalQuestion xmlns=\""http://mechanicalturk.amazonaws.com/AWSMechanicalTurkDataSchemas/2006-07-14/ExternalQuestion.xsd\"">\n"" +
        ""  <ExternalURL>"" + externalURL + ""</ExternalURL>\n"" +
        ""  <FrameHeight>"" + frameHeight + ""</FrameHeight>\n"" +
        ""</ExternalQuestion>"";

    try {
      AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY));
      AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials);
      builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION));
      AmazonMTurk mTurk = builder.build();

      Experiment experiment = Experiment.findById(Long.parseLong(experimentId));
      String experimentName = experiment.name;
      if (experimentName.length() > 120) experimentName = experimentName.substring(0, 120) + ""..."";
      String annotation = ""{\""experimentType\"":\""breadboard\"",\""experimentUid\"":\"""" + experiment.uid + ""\"",\""experimentName\"":\"""" + experimentName + ""\""}"";

      // Create HIT
      CreateHITRequest createHITRequest = new CreateHITRequest()
          .withQuestion(question)
          .withTitle(title)
          .withDescription(description)
          .withMaxAssignments(maxAssignments)
          .withLifetimeInSeconds(hitLifetime)
          .withAssignmentDurationInSeconds(assignmentDuration)
          .withKeywords(keywords)
          .withReward(reward)
          .withRequesterAnnotation(annotation);

      if (qualificationRequirements != null) {
        Logger.debug(""qualificationRequirements = "" + ((qualificationRequirements != null) ? qualificationRequirements : ""qualificationRequirements is null""));
      }

      List<QualificationRequirement> qualificationRequirementList = new ArrayList<>();
      for (BBQualificationRequirement bbQualificationRequirement : qualificationRequirements) {
        List<Locale> locales = new ArrayList<>();
        for (BBLocale bbLocale : bbQualificationRequirement.locales) {
          Locale locale = new Locale()
              .withCountry(bbLocale.country.trim());
          if (!bbLocale.subdivision.trim().isEmpty()) {
              locale.setSubdivision(bbLocale.subdivision.trim());
          }
          locales.add(locale);
        }
        List<Integer> integerValues = new ArrayList<>();
        for (String integerString : bbQualificationRequirement.integerValues.split("","")) {
          try {
            Integer integerValue = Integer.parseInt(integerString.trim());
            integerValues.add(integerValue);
          } catch (NumberFormatException nfe) {}
        }

        String qualificationTypeId = bbQualificationRequirement.selectedQualificationType.qualificationTypeId;

        if (qualificationTypeId.equals(""OTHER_EXPERIMENT"")) {
          String experimentUid = bbQualificationRequirement.otherExperiment;
          String qualificationName = PARTICIPANT_QUALIFICATION_PREFIX + experimentUid;
          QualificationType qualificationType = getQualificationTypeByName(qualificationName, sandbox);
          if (qualificationType != null) {
            qualificationTypeId = qualificationType.getQualificationTypeId();
          }
        }

        QualificationRequirement qualificationRequirement = new QualificationRequirement()
            .withActionsGuarded(bbQualificationRequirement.actionsGuarded)
            .withComparator(bbQualificationRequirement.comparator)
            .withQualificationTypeId(qualificationTypeId);

        if (!locales.isEmpty()) {
          qualificationRequirement.setLocaleValues(locales);
        }

        if (!integerValues.isEmpty()) {
          qualificationRequirement.setIntegerValues(integerValues);
        }

        qualificationRequirementList.add(qualificationRequirement);
      }

      if (!qualificationRequirementList.isEmpty()) {
        createHITRequest.setQualificationRequirements(qualificationRequirementList);
      }

      Logger.debug(""createHitRequest = "" + createHITRequest.toString());

      CreateHITResult createHITResult = mTurk.createHIT(createHITRequest);
      HIT hit = createHITResult.getHIT();
      AMTHit amtHit = new AMTHit();
      amtHit.hitId = hit.getHITId();
      amtHit.description = hit.getDescription();
      amtHit.lifetimeInSeconds = hitLifetime.toString();
      amtHit.tutorialTime = tutorialTime.toString();
      amtHit.maxAssignments = hit.getMaxAssignments().toString();
      amtHit.externalURL = externalURL;
      amtHit.reward = hit.getReward();
      amtHit.title = hit.getTitle();
      amtHit.disallowPrevious = disallowPrevious;
      amtHit.sandbox = sandbox;

      ExperimentInstance experimentInstance = ExperimentInstance.findById(Long.parseLong(experimentInstanceId));
      experimentInstance.amtHits.add(amtHit);
      experimentInstance.save();

      return ok(amtHit.toJson());
    } catch (AmazonServiceException ase) {
      return badRequest(ase.getMessage());
    } catch (AmazonClientException ace) {
      return internalServerError(ace.getMessage());
    }
  }

  @Security.Authenticated(Secured.class)
  public static Result createDummyHit(Boolean sandbox) {
    if (SECRET_KEY == null || ACCESS_KEY == null) {
      return badRequest(""No AWS keys provided"");
    }
    String workerId = null;
    String reason = null;
    String reward = null;
    String paymentHitHtml = getDummyHitHTML();
    if (paymentHitHtml == null) {
      return badRequest(""Unable to read 'payment-hit.html' or 'default-payment-hit.html' file in conf/defaults directory."");
    }
    JsonNode json = request().body().asJson();
    if(json == null) {
      return badRequest(""Expecting Json data"");
    } else {
      workerId = json.findPath(""workerId"").textValue();
      reason = json.findPath(""reason"").textValue();
      reward = json.findPath(""reward"").textValue();
    }

    if (workerId == null || reason == null || reward == null) {
      return badRequest(""Please provide workerId, reason, and reward."");
    }

    try {
      AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY));
      AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials);
      builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION));
      AmazonMTurk mTurk = builder.build();

      // Create a qualification for the worker
      String qualificationName = new Date().getTime() + ""_"" + workerId;
      CreateQualificationTypeRequest createQualificationTypeRequest = new CreateQualificationTypeRequest()
          .withName(qualificationName)
          .withDescription(reason)
          .withQualificationTypeStatus(QualificationTypeStatus.Active);
      CreateQualificationTypeResult createQualificationTypeResult = mTurk.createQualificationType(createQualificationTypeRequest);

      AssociateQualificationWithWorkerRequest associateQualificationWithWorkerRequest = new AssociateQualificationWithWorkerRequest()
          .withQualificationTypeId(createQualificationTypeResult.getQualificationType().getQualificationTypeId())
          .withIntegerValue(1)
          .withWorkerId(workerId);

      mTurk.associateQualificationWithWorker(associateQualificationWithWorkerRequest);

      QualificationRequirement qualificationRequirement = new QualificationRequirement()
          .withQualificationTypeId(createQualificationTypeResult.getQualificationType().getQualificationTypeId())
          .withRequiredToPreview(true)
          .withComparator(""EqualTo"")
          .withIntegerValues(1);

      // Create Dummy/Payment HIT
      CreateHITRequest createHITRequest = new CreateHITRequest()
          .withTitle(""HIT for "" + workerId)
          .withDescription(reason)
          .withMaxAssignments(1)
          .withQuestion(paymentHitHtml)
          .withQualificationRequirements(qualificationRequirement)
          .withLifetimeInSeconds(31536000L)
          .withAssignmentDurationInSeconds(5400L)
          .withKeywords(workerId)
          .withReward(reward);

      mTurk.createHIT(createHITRequest);

      return ok();
    } catch (AmazonServiceException ase) {
      return badRequest(ase.getMessage());
    } catch (AmazonClientException ace) {
      return internalServerError(ace.getMessage());
    }
  }

  private static String getDummyHitHTML() {
    String returnString = null;
    InputStream paymentHitHtml = Play.application().resourceAsStream(""defaults/payment-hit.html"");
    if (paymentHitHtml == null) paymentHitHtml = Play.application().resourceAsStream(""defaults/default-payment-hit.html"");
    if (paymentHitHtml == null) return null;
    try {
      returnString = ""<HTMLQuestion xmlns=\""http://mechanicalturk.amazonaws.com/AWSMechanicalTurkDataSchemas/2011-11-11/HTMLQuestion.xsd\"">\n"" +
                     ""  <HTMLContent><![CDATA["" +
                     IOUtils.toString(paymentHitHtml) +
                     ""]]>\n"" +
                     ""  </HTMLContent>\n"" +
                     ""  <FrameHeight>600</FrameHeight>\n"" +
                     ""</HTMLQuestion>"";
    } catch (IOException ioe) { }
    return returnString;
  }

  private static class ExperimentQualificationType {
    public QualificationType qualificationType;
    public Experiment experiment;
  }

  private static class BBQualificationRequirement {
    public String actionsGuarded;
    public String comparator;
    public String integerValues;
    public List<BBLocale> locales;
    public String otherExperiment;
    public BBQualificationType selectedQualificationType;
  }

  private static class BBQualificationType {
    public String label;
    public String qualificationTypeId;
    public String experimentUid;
    public String experimentName;
    public String creationTime;
    public String description;
    public Boolean isRequestable;
    public Boolean autoGranted;
    public String keywords;
    public String name;
    public String qualificationTypeStatus;
  }

  private static class BBLocale {
    public String country;
    public String subdivision;
  }
}
","package controllers; public class AMTAdmin extends Controller { private static final String PRODUCTION_ENDPOINT = ""mturk-requester.us-east-1.amazonaws.com""; private static final String SANDBOX_ENDPOINT = ""mturk-requester-sandbox.us-east-1.amazonaws.com""; private static final String SIGNING_REGION = ""us-east-1""; private static final String SECRET_KEY = Play.application().configuration().getString(""amt.secretKey""); private static final String ACCESS_KEY = Play.application().configuration().getString(""amt.accessKey""); private static final String PARTICIPANT_QUALIFICATION_PREFIX = ""breadboard_participant_""; @Security.Authenticated(Secured.class)
  public static Result getAccountBalance(Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); GetAccountBalanceRequest getAccountBalanceRequest= new GetAccountBalanceRequest(); GetAccountBalanceResult getAccountBalanceResult = mTurk.getAccountBalance(getAccountBalanceRequest); String availableBalance = getAccountBalanceResult.getAvailableBalance(); String onHoldBalance = getAccountBalanceResult.getOnHoldBalance(); ObjectNode returnJson = Json.newObject(); returnJson.put(""availableBalance"", availableBalance); returnJson.put(""onHoldBalance"", onHoldBalance); return ok(returnJson); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } private static class JsonWorker { public String workerId; public List<ObjectNode> assignments = new ArrayList<>(); public int nCompleted = 0; JsonWorker(String id) { workerId = id; } public ObjectNode toJson() { ObjectNode worker = Json.newObject(); worker.put(""id"", workerId); worker.put(""nAssignments"", assignments.size()); worker.put(""assignmentsCompleted"", nCompleted); ArrayNode jsonAssignments = worker.putArray(""assignments""); jsonAssignments.addAll(assignments); return worker; } } @Security.Authenticated(Secured.class)
  public static Result addQualificationType(String experimentUid, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } Experiment experiment = Experiment.findByUid(experimentUid); if (experiment == null) { return badRequest(""Invalid experiment UID.""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); String qualificationName = PARTICIPANT_QUALIFICATION_PREFIX + experimentUid; String reason = ""You previously participated in this experiment.""; CreateQualificationTypeRequest createQualificationTypeRequest = new CreateQualificationTypeRequest()
          .withName(qualificationName)
          .withDescription(reason)
          .withQualificationTypeStatus(QualificationTypeStatus.Active); CreateQualificationTypeResult createQualificationTypeResult = mTurk.createQualificationType(createQualificationTypeRequest); QualificationType qualificationType = createQualificationTypeResult.getQualificationType(); ObjectNode qualificationTypeJson = Json.newObject(); TimeZone tz = TimeZone.getTimeZone(""UTC""); DateFormat df = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm'Z'""); df.setTimeZone(tz); qualificationTypeJson.put(""experimentUid"", experimentUid); qualificationTypeJson.put(""experimentName"", experiment.name); qualificationTypeJson.put(""creationTime"", df.format(qualificationType.getCreationTime())); qualificationTypeJson.put(""description"", qualificationType.getDescription()); qualificationTypeJson.put(""isRequestable"", qualificationType.getIsRequestable()); qualificationTypeJson.put(""keywords"", qualificationType.getKeywords()); qualificationTypeJson.put(""name"", qualificationType.getName()); qualificationTypeJson.put(""qualificationTypeId"", qualificationType.getQualificationTypeId()); qualificationTypeJson.put(""qualificationTypeStatus"", qualificationType.getQualificationTypeStatus()); qualificationTypeJson.put(""autoGranted"", qualificationType.getAutoGranted()); return ok(qualificationTypeJson); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } public static QualificationType getQualificationTypeByName(String qualificationName, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return null; } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); ListQualificationTypesRequest listQualificationTypesRequest = new ListQualificationTypesRequest()
          .withMaxResults(1)
          .withMustBeOwnedByCaller(false)
          .withMustBeRequestable(false)
          .withQuery(qualificationName); ListQualificationTypesResult listQualificationTypesResult = mTurk.listQualificationTypes(listQualificationTypesRequest); List<QualificationType> qualificationTypes = listQualificationTypesResult.getQualificationTypes(); if (qualificationTypes.isEmpty()) { return null; } return qualificationTypes.get(0); } catch (AmazonServiceException ase) { return null; } catch (AmazonClientException ace) { return null; } } @Security.Authenticated(Secured.class)
  public static Result listQualificationTypes(Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); List<ExperimentQualificationType> experimentQualificationTypes = new ArrayList<ExperimentQualificationType>(); for (Experiment experiment: Experiment.findAll()) { ListQualificationTypesRequest listQualificationTypesRequest = new ListQualificationTypesRequest()
            .withMaxResults(1)
            .withMustBeOwnedByCaller(true)
            .withMustBeRequestable(false)
            .withQuery(PARTICIPANT_QUALIFICATION_PREFIX + experiment.uid); ListQualificationTypesResult listQualificationTypesResult = mTurk.listQualificationTypes(listQualificationTypesRequest); List<QualificationType> qualificationType = listQualificationTypesResult.getQualificationTypes(); ExperimentQualificationType experimentQualificationType = new ExperimentQualificationType(); if (!qualificationType.isEmpty()) { experimentQualificationType.qualificationType = qualificationType.get(0); } experimentQualificationType.experiment = experiment; experimentQualificationTypes.add(experimentQualificationType); } ObjectNode returnJson = Json.newObject(); ArrayNode qualificationTypesJson = returnJson.putArray(""qualificationTypes""); TimeZone tz = TimeZone.getTimeZone(""UTC""); DateFormat df = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm'Z'""); df.setTimeZone(tz); for (ExperimentQualificationType experimentQualificationType : experimentQualificationTypes) { QualificationType qualificationType = experimentQualificationType.qualificationType; Experiment experiment = experimentQualificationType.experiment; ObjectNode qualificationTypeJson = Json.newObject(); qualificationTypeJson.put(""label"", experiment.name + "" participant""); qualificationTypeJson.put(""experimentUid"", experiment.uid); qualificationTypeJson.put(""experimentName"", experiment.name); qualificationTypeJson.put(""creationTime"", (qualificationType == null) ? null : df.format(qualificationType.getCreationTime())); qualificationTypeJson.put(""description"", (qualificationType == null) ? null : qualificationType.getDescription()); qualificationTypeJson.put(""isRequestable"", (qualificationType == null) ? null : qualificationType.getIsRequestable()); qualificationTypeJson.put(""keywords"", (qualificationType == null) ? null : qualificationType.getKeywords()); qualificationTypeJson.put(""name"", (qualificationType == null) ? null : qualificationType.getName()); qualificationTypeJson.put(""qualificationTypeId"", (qualificationType == null) ? null : qualificationType.getQualificationTypeId()); qualificationTypeJson.put(""qualificationTypeStatus"", (qualificationType == null) ? null : qualificationType.getQualificationTypeStatus()); qualificationTypeJson.put(""autoGranted"", (qualificationType == null) ? null : qualificationType.getAutoGranted()); qualificationTypesJson.add(qualificationTypeJson); } returnJson.put(""rows"", experimentQualificationTypes.size()); return ok(returnJson); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result getExperimentQualificationTypeId(String experimentUid, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } QualificationType qualificationType = getQualificationTypeByName(PARTICIPANT_QUALIFICATION_PREFIX + experimentUid, sandbox); if (qualificationType == null) { try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); String qualificationName = PARTICIPANT_QUALIFICATION_PREFIX + experimentUid; String reason = ""You previously participated in this experiment.""; CreateQualificationTypeRequest createQualificationTypeRequest = new CreateQualificationTypeRequest()
            .withName(qualificationName)
            .withDescription(reason)
            .withQualificationTypeStatus(QualificationTypeStatus.Active); CreateQualificationTypeResult createQualificationTypeResult = mTurk.createQualificationType(createQualificationTypeRequest); qualificationType = createQualificationTypeResult.getQualificationType(); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } ObjectNode returnJson = Json.newObject(); returnJson.put(""qualificationTypeId"", qualificationType.getQualificationTypeId()); return ok(returnJson); } @Security.Authenticated(Secured.class)
  public static Result assignParticipantQualification(Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String workerId = null; String qualificationTypeId = null; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { workerId = json.findPath(""workerId"").textValue(); qualificationTypeId = json.findPath(""qualificationTypeId"").textValue(); } if (workerId == null) { return badRequest(""Please provide an AMT worker ID.""); } if (qualificationTypeId == null) { return badRequest(""Please provide a qualification type ID.""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); AssociateQualificationWithWorkerRequest associateQualificationWithWorkerRequest = new AssociateQualificationWithWorkerRequest()
          .withQualificationTypeId(qualificationTypeId)
          .withIntegerValue(1)
          .withSendNotification(false)
          .withWorkerId(workerId); mTurk.associateQualificationWithWorker(associateQualificationWithWorkerRequest); return ok(); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result removeParticipantQualification(Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String workerId = null; String qualificationTypeId = null; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { workerId = json.findPath(""workerId"").textValue(); qualificationTypeId = json.findPath(""qualificationTypeId"").textValue(); } if (workerId == null) { return badRequest(""Please provide an AMT worker ID.""); } if (qualificationTypeId == null) { return badRequest(""Please provide a qualification type ID.""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); DisassociateQualificationFromWorkerRequest disassociateQualificationFromWorkerRequest = new DisassociateQualificationFromWorkerRequest()
          .withQualificationTypeId(qualificationTypeId)
          .withWorkerId(workerId); mTurk.disassociateQualificationFromWorker(disassociateQualificationFromWorkerRequest); return ok(); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result getQualificationScore(Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String workerId = null; String qualificationTypeId = null; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { workerId = json.findPath(""workerId"").textValue(); qualificationTypeId = json.findPath(""qualificationTypeId"").textValue(); } if (workerId == null) { return badRequest(""Please provide an AMT worker ID.""); } if (qualificationTypeId == null) { return badRequest(""Please provide a qualification type ID.""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); GetQualificationScoreRequest getQualificationScoreRequest = new GetQualificationScoreRequest()
          .withQualificationTypeId(qualificationTypeId)
          .withWorkerId(workerId); GetQualificationScoreResult qualificationScoreResult = mTurk.getQualificationScore(getQualificationScoreRequest); Qualification qualification = qualificationScoreResult.getQualification(); TimeZone tz = TimeZone.getTimeZone(""UTC""); DateFormat df = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm'Z'""); df.setTimeZone(tz); ObjectNode returnJson = Json.newObject(); if (qualification == null) { returnJson.put(""status"", ""None""); } else { returnJson.put(""grantTime"", df.format(qualification.getGrantTime())); returnJson.put(""integerValue"", qualification.getIntegerValue()); if (qualification.getLocaleValue() != null) { returnJson.put(""localeValue"", qualification.getLocaleValue().toString()); } returnJson.put(""qualificationTypeId"", qualification.getQualificationTypeId()); returnJson.put(""status"", qualification.getStatus()); returnJson.put(""workerId"", qualification.getWorkerId()); } return ok(returnJson); } catch (AmazonServiceException ase) { ObjectNode returnJson = Json.newObject(); returnJson.put(""status"", ""None""); return ok(returnJson); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result importAMTWorkers(Long experimentId, Boolean sandbox) { Http.MultipartFormData body = request().body().asMultipartFormData(); Long maxUploadSize = play.Play.application().configuration().getLong(""maxUploadSize"", 50L * 1024L * 1024L); try { Long fileSize = Long.parseLong(request().getHeader(""Content-Length""), 10); if (fileSize > maxUploadSize) { return badRequest(""Uploaded file is too large""); } } catch(Exception e){ return badRequest(""Upload was malformed""); } Http.MultipartFormData.FilePart filePart = body.getFile(""file""); File workerCsvFile = filePart.getFile(); Experiment experiment = Experiment.findById(experimentId); if(experiment == null){ return badRequest(""Invalid experiment ID""); } if(workerCsvFile.length() > maxUploadSize){ return badRequest(""Uploaded file is too large""); } try { Reader in = new FileReader(workerCsvFile); try { Date now = new Date(); String importTitle = ""IMPORTED_"" + experimentId + ""_"" + now.getTime(); ExperimentInstance instance = new ExperimentInstance(importTitle, experiment); experiment.instances.add(instance); experiment.save(); AMTHit amtHit = new AMTHit(); amtHit.creationDate = now; amtHit.requestId = ""IMPORTED""; amtHit.isValid = ""true""; amtHit.hitId = ""IMPORTED_"" + experimentId + ""_"" + now.getTime(); amtHit.title = ""IMPORTED INTO "" + experiment.name + "" AT "" + now.getTime(); amtHit.description = ""This is a fake HIT created by breadboard when importing AMT Worker IDs to prevent repeat play.""; amtHit.lifetimeInSeconds = ""0""; amtHit.tutorialTime = ""0""; amtHit.maxAssignments = ""0""; amtHit.externalURL = ""IMPORTED""; amtHit.reward = ""0""; amtHit.disallowPrevious = ""none""; amtHit.sandbox = sandbox; amtHit.setExtended(false); amtHit.experimentInstance = instance; amtHit.save(); int assignmentIndex = 0; CSVFormat format = CSVFormat.DEFAULT; for (CSVRecord record : format.parse(in)) { String workerId = record.get(0); AMTWorker amtWorker = AMTWorker.findByWorkerId(workerId); if (amtWorker == null) { amtWorker = new AMTWorker(); amtWorker.workerId = workerId; amtWorker.score = """"; amtWorker.completion = """"; amtWorker.amtHit = amtHit; amtWorker.save(); } AMTAssignment amtAssignment = new AMTAssignment(); amtAssignment.assignmentId = ""IMPORTED_"" + experimentId + ""_"" + now.getTime() + ""_"" + (++assignmentIndex); amtAssignment.workerId = workerId; amtAssignment.assignmentCompleted = true; amtAssignment.assignmentStatus = ""IMPORTED""; amtAssignment.autoApprovalTime = ""IMPORTED""; amtAssignment.acceptTime = null; amtAssignment.submitTime = null; amtAssignment.answer = """"; amtAssignment.score = """"; amtAssignment.reason = ""IMPORTED""; amtAssignment.completion = """"; amtAssignment.bonusAmount = """"; amtAssignment.bonusGranted = false; amtAssignment.workerBlocked = false; amtAssignment.qualificationAssigned = false; amtAssignment.amtHit = amtHit; amtAssignment.save(); } } finally { in.close(); } } catch (IOException ioe) { return badRequest(""Error reading uploaded file""); } return ok(); } @Security.Authenticated(Secured.class)
  public static Result disassociateQualificationFromWorker(String qualificationTypeId, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String workerId; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { workerId = json.findPath(""workerId"").textValue(); } if (workerId == null) { return badRequest(""Please provide an AMT worker ID.""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); DisassociateQualificationFromWorkerRequest disassociateQualificationFromWorkerRequest = new DisassociateQualificationFromWorkerRequest()
          .withQualificationTypeId(qualificationTypeId)
          .withWorkerId(workerId)
          .withReason(""Allowing re-participation in this experiment type.""); mTurk.disassociateQualificationFromWorker(disassociateQualificationFromWorkerRequest); return ok(); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result listWorkersWithQualificationType(String qualificationTypeId, Integer maxResults, String nextToken, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); ListWorkersWithQualificationTypeRequest listWorkersWithQualificationTypeRequest = new ListWorkersWithQualificationTypeRequest()
          .withQualificationTypeId(qualificationTypeId)
          .withMaxResults((maxResults == null) ? 20 : maxResults)
          .withStatus(QualificationStatus.Granted); if (nextToken != null) listWorkersWithQualificationTypeRequest.setNextToken(nextToken); ListWorkersWithQualificationTypeResult listWorkersWithQualificationTypeResult = mTurk.listWorkersWithQualificationType(listWorkersWithQualificationTypeRequest); List<Qualification> qualifications = listWorkersWithQualificationTypeResult.getQualifications(); ObjectNode returnJson = Json.newObject(); ArrayNode qualificationsJson = returnJson.putArray(""qualifications""); TimeZone tz = TimeZone.getTimeZone(""UTC""); DateFormat df = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm'Z'""); df.setTimeZone(tz); for (Qualification qualification : qualifications) { ObjectNode qualificationJson = Json.newObject(); qualificationJson.put(""qualificationTypeId"", qualification.getQualificationTypeId()); qualificationJson.put(""grantTime"", df.format(qualification.getGrantTime())); qualificationJson.put(""integerValue"", qualification.getIntegerValue()); qualificationJson.put(""status"", qualification.getStatus()); qualificationJson.put(""workerId"", qualification.getWorkerId()); qualificationsJson.add(qualificationJson); } returnJson.put(""rows"", listWorkersWithQualificationTypeResult.getNumResults()); returnJson.put(""nextToken"", listWorkersWithQualificationTypeResult.getNextToken()); return ok(returnJson); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result getAMTWorkers(Long experimentId, Boolean sandbox, Integer limit, Integer offset, String search) { HashMap<String, JsonWorker> amtWorkerAssignments = new HashMap<>(); ObjectNode returnJson = Json.newObject(); String workerCountSql = ""select count(distinct worker_id) as worker_count from amt_assignments "" +
        "" where worker_id like CONCAT(:search, '%')"" +
        "" and worker_id in "" +
        ""(select worker_id from amt_assignments "" +
        "" where amt_hit_id in "" +
        ""(select id from amt_hits where sandbox = :sandbox)); ""; SqlRow sqlRow = Ebean.createSqlQuery(workerCountSql)
        .setParameter(""search"", search)
        .setParameter(""sandbox"", (sandbox) ? 1 : 0)
        .findUnique(); Long workerCount = sqlRow.getLong(""worker_count""); String workerIdSql = ""select distinct worker_id from amt_assignments "" +
        "" where worker_id like CONCAT(:search, '%')"" +
        "" and worker_id in "" +
        ""(select worker_id from amt_assignments "" +
        "" where amt_hit_id in "" +
        ""(select id from amt_hits where sandbox = :sandbox))"" +
        "" order by worker_id limit :limit offset :offset""; SqlQuery sqlQuery = Ebean.createSqlQuery(workerIdSql)
        .setParameter(""limit"", limit)
        .setParameter(""offset"", offset)
        .setParameter(""search"", search)
        .setParameter(""sandbox"", (sandbox) ? 1 : 0); List<SqlRow> workerIds = sqlQuery.findList(); returnJson.put(""total"", workerCount); returnJson.put(""offset"", offset); returnJson.put(""limit"", limit); int endI = Math.min(limit, workerIds.size()); for (int i = 0; i < endI; i++) { SqlRow row = workerIds.get(i); String workerId = row.getString(""worker_id""); List<AMTAssignment> assignments = AMTAssignment.find
          .where()
          .eq(""worker_id"", workerId)
          .findList(); if (! amtWorkerAssignments.containsKey(workerId)) { amtWorkerAssignments.put(workerId, new JsonWorker(workerId)); } JsonWorker jsonWorker = amtWorkerAssignments.get(workerId); for (AMTAssignment assignment : assignments) { AMTHit hit = assignment.amtHit; ExperimentInstance instance = hit.experimentInstance; Experiment experiment = (instance == null) ? null : instance.experiment; String experimentName = (experiment == null) ? """" : experiment.name; Long eId = (experiment == null) ? -1L : experiment.id; String eUid = (experiment == null) ? """" : experiment.uid; Boolean assignmentCompleted = assignment.assignmentCompleted; ; if (assignmentCompleted != null && assignmentCompleted) jsonWorker.nCompleted++; ObjectNode amtAssignment = Json.newObject(); amtAssignment.put(""id"", assignment.id); amtAssignment.put(""assignmentId"", assignment.assignmentId); amtAssignment.put(""workerId"", workerId); amtAssignment.put(""assignmentStatus"", assignment.assignmentStatus); amtAssignment.put(""autoApprovalTime"", assignment.autoApprovalTime); amtAssignment.put(""acceptTime"", assignment.acceptTime); amtAssignment.put(""submitTime"", assignment.submitTime); amtAssignment.put(""answer"", assignment.answer); amtAssignment.put(""score"", assignment.score); amtAssignment.put(""reason"", assignment.reason); amtAssignment.put(""completion"", assignment.completion); amtAssignment.put(""assignmentCompleted"", assignmentCompleted); amtAssignment.put(""bonusGranted"", assignment.bonusGranted); amtAssignment.put(""bonusAmount"", assignment.bonusAmount); amtAssignment.put(""workerBlocked"", assignment.workerBlocked); amtAssignment.put(""qualificationAssigned"", assignment.qualificationAssigned); amtAssignment.put(""experimentName"", experimentName); amtAssignment.put(""experimentUid"", eUid); amtAssignment.put(""experimentId"", eId); jsonWorker.assignments.add(amtAssignment); } } ArrayNode amtWorkersJson = returnJson.putArray(""amtWorkers""); for (JsonWorker jsonWorker : amtWorkerAssignments.values()) { amtWorkersJson.add(jsonWorker.toJson()); } returnJson.put(""rows"", amtWorkerAssignments.size()); return ok(returnJson); } @Security.Authenticated(Secured.class)
  public static Result listHITs(String nextToken, Integer maxResults, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); ListHITsRequest listHITsRequest = new ListHITsRequest().withMaxResults((maxResults == null) ? 20 : maxResults); if (nextToken != null) listHITsRequest.setNextToken(nextToken); ListHITsResult hitResults = mTurk.listHITs(listHITsRequest); List<HIT> hits = hitResults.getHITs(); for (HIT hit : hits) { AMTHit amtHit = AMTHit.findByHitId(hit.getHITId()); if (amtHit == null) { amtHit = new AMTHit(); } amtHit.hitId = hit.getHITId(); amtHit.creationDate = hit.getCreationTime(); amtHit.title = hit.getTitle(); amtHit.description = hit.getDescription(); amtHit.maxAssignments = hit.getMaxAssignments().toString(); amtHit.reward = hit.getReward(); amtHit.sandbox = sandbox; amtHit.save(); } String next = hitResults.getNextToken(); ObjectNode returnJson = Json.newObject(); returnJson.put(""hits"", Json.toJson(hits)); returnJson.put(""nextToken"", next); return ok(returnJson); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result listAssignmentsForHIT(String hitId, Integer maxResults, String nextToken, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); ListAssignmentsForHITRequest listAssignmentsForHITRequest = new ListAssignmentsForHITRequest().withMaxResults(maxResults).withHITId(hitId); ObjectNode returnJson = Json.newObject(); ArrayNode jsonAssignments = returnJson.putArray(""assignments""); if (nextToken != null) listAssignmentsForHITRequest.setNextToken(nextToken); ListAssignmentsForHITResult assignmentResults = mTurk.listAssignmentsForHIT(listAssignmentsForHITRequest); List<Assignment> assignments = assignmentResults.getAssignments(); TimeZone tz = TimeZone.getTimeZone(""UTC""); DateFormat df = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm'Z'""); df.setTimeZone(tz); for (Assignment assignment : assignments) { AMTHit hit = AMTHit.findByHitId(assignment.getHITId()); AMTAssignment amtAssignment = hit.getAMTAssignmentById(assignment.getAssignmentId()); boolean update = true; if (amtAssignment == null) { amtAssignment = new AMTAssignment(); amtAssignment.assignmentCompleted = false; update = false; } amtAssignment.amtHit = hit; amtAssignment.assignmentId = assignment.getAssignmentId(); amtAssignment.workerId = assignment.getWorkerId(); amtAssignment.assignmentStatus = assignment.getAssignmentStatus(); amtAssignment.autoApprovalTime = assignment.getAutoApprovalTime().toString(); amtAssignment.acceptTime = (assignment.getAcceptTime() == null) ? null :  df.format(assignment.getAcceptTime()); amtAssignment.submitTime = (assignment.getSubmitTime() == null) ? null :  df.format(assignment.getSubmitTime()); amtAssignment.answer = assignment.getAnswer(); if (!update) { hit.amtAssignments.add(amtAssignment); } hit.save(); ObjectNode jsonAssignment = Json.newObject(); jsonAssignment.put(""assignmentId"", amtAssignment.assignmentId); jsonAssignment.put(""workerId"", amtAssignment.workerId); jsonAssignment.put(""approvalTime"", (assignment.getApprovalTime() == null) ? null : df.format(assignment.getApprovalTime())); jsonAssignment.put(""rejectionTime"", (assignment.getRejectionTime() == null) ? null : df.format(assignment.getRejectionTime())); jsonAssignment.put(""answer"", amtAssignment.answer); jsonAssignment.put(""assignmentCompleted"", amtAssignment.assignmentCompleted); jsonAssignments.add(jsonAssignment); } String token = assignmentResults.getNextToken(); returnJson.put(""nextToken"", token); return ok(returnJson); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result listBonusPaymentsForHIT(String hitId, Integer maxResults, String nextToken, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); ListBonusPaymentsRequest listBonusPaymentsRequest = new ListBonusPaymentsRequest().withMaxResults(maxResults).withHITId(hitId); if (nextToken != null) listBonusPaymentsRequest.setNextToken(nextToken); ListBonusPaymentsResult bonusPaymentsResults = mTurk.listBonusPayments(listBonusPaymentsRequest); List<BonusPayment> bonusPayments = bonusPaymentsResults.getBonusPayments(); for (BonusPayment bonusPayment : bonusPayments) { AMTAssignment amtAssignment = AMTAssignment.findByAssignmentId(bonusPayment.getAssignmentId()); if (amtAssignment != null) { amtAssignment.bonusGranted = true; amtAssignment.bonusAmount = bonusPayment.getBonusAmount(); amtAssignment.save(); } } String token = bonusPaymentsResults.getNextToken(); ObjectNode returnJson = Json.newObject(); returnJson.put(""bonusPayments"", Json.toJson(bonusPayments)); returnJson.put(""nextToken"", token); return ok(returnJson); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result approveAssignment(String assignmentId, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); ApproveAssignmentRequest approveAssignmentRequest= new ApproveAssignmentRequest().withAssignmentId(assignmentId); mTurk.approveAssignment(approveAssignmentRequest); return ok(); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result rejectAssignment(String assignmentId, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String requesterFeedback = null; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { requesterFeedback = json.findPath(""requesterFeedback"").textValue(); } if (requesterFeedback == null) { return badRequest(""Please provide requester feedback.""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); RejectAssignmentRequest rejectAssignmentRequest= new RejectAssignmentRequest()
          .withAssignmentId(assignmentId)
          .withRequesterFeedback(requesterFeedback); mTurk.rejectAssignment(rejectAssignmentRequest); return ok(); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result sendBonus(String assignmentId, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String bonusAmount = null; String reason = null; String workerId = null; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { bonusAmount = json.findPath(""bonusAmount"").textValue(); reason = json.findPath(""reason"").textValue(); workerId = json.findPath(""workerId"").textValue(); } if (bonusAmount == null || reason == null || workerId == null) { return badRequest(""Please provide workerId, bonusAmount, and reason.""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); SendBonusRequest sendBonusRequest= new SendBonusRequest().withAssignmentId(assignmentId).withBonusAmount(bonusAmount).withReason(reason).withWorkerId(workerId); mTurk.sendBonus(sendBonusRequest); return ok(); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result updateAssignmentCompleted(String assignmentId) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String completedText; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { completedText = json.findPath(""completed"").asText(); } if (completedText == null || (!(completedText.matches(""(?i)0|1|true|false"")))) { return badRequest(""Please provide completed as a boolean value (0, 1, true, false).""); } AMTAssignment amtAssignment = AMTAssignment.findByAssignmentId(assignmentId); if (amtAssignment == null) { return badRequest(""Invalid Assignment ID.""); } Boolean completed = (completedText.matches(""(?i)1|true"")); amtAssignment.assignmentCompleted = completed; amtAssignment.save(); return ok(); } @Security.Authenticated(Secured.class)
  public static Result createHIT(Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String title; String description; String reward; Integer maxAssignments; Long hitLifetime; Long tutorialTime; Long assignmentDuration; String keywords; String disallowPrevious; String experimentId; String experimentInstanceId; BBQualificationRequirement[] qualificationRequirements = null; JsonNode json = request().body().asJson(); if (json == null) { return badRequest(""Expecting Json data""); } else { title = json.findPath(""title"").textValue(); description = json.findPath(""description"").textValue(); reward = json.findPath(""reward"").textValue(); maxAssignments = json.findPath(""maxAssignments"").asInt(-1); hitLifetime = json.findPath(""hitLifetime"").asLong(-1L); tutorialTime = json.findPath(""tutorialTime"").asLong(-1L); assignmentDuration = json.findPath(""assignmentDuration"").asLong(-1L); keywords = json.findPath(""keywords"").textValue(); disallowPrevious = json.findPath(""disallowPrevious"").textValue(); experimentId = json.findPath(""experimentId"").textValue(); experimentInstanceId = json.findPath(""experimentInstanceId"").textValue(); try { qualificationRequirements = new ObjectMapper().readValue(json.findPath(""qualificationRequirements"").toString(), BBQualificationRequirement[].class); } catch(IOException ioe) { } } if (title == null || description == null || reward == null || maxAssignments < 0 || hitLifetime < 0 || tutorialTime < 0 || assignmentDuration < 0 || keywords == null || disallowPrevious == null || experimentId == null || experimentInstanceId == null) { return badRequest(""Please provide experiment ID, experiment instance ID, title, description, reward, max assignments, hit lifetime, tutorial time, assignment duration, keywords, and allow repeat play option.""); } String rootURL = play.Play.application().configuration().getString(""breadboard.rootUrl""); String gameURL = String.format(""/game/%1$s/%2$s/amt"", experimentId, experimentInstanceId); String externalURL = rootURL + gameURL; Integer frameHeight = play.Play.application().configuration().getInt(""breadboard.amtFrameHeight""); ""  <ExternalURL>"" + externalURL + ""</ExternalURL>\n"" +
        ""  <FrameHeight>"" + frameHeight + ""</FrameHeight>\n"" +
        ""</ExternalQuestion>""; try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); Experiment experiment = Experiment.findById(Long.parseLong(experimentId)); String experimentName = experiment.name; if (experimentName.length() > 120) experimentName = experimentName.substring(0, 120) + ""...""; String annotation = ""{ \""experimentType\"":\""breadboard\"",\""experimentUid\"":\"""" + experiment.uid + ""\"",\""experimentName\"":\"""" + experimentName + ""\""} ""; CreateHITRequest createHITRequest = new CreateHITRequest()
          .withQuestion(question)
          .withTitle(title)
          .withDescription(description)
          .withMaxAssignments(maxAssignments)
          .withLifetimeInSeconds(hitLifetime)
          .withAssignmentDurationInSeconds(assignmentDuration)
          .withKeywords(keywords)
          .withReward(reward)
          .withRequesterAnnotation(annotation); if (qualificationRequirements != null) { } List<QualificationRequirement> qualificationRequirementList = new ArrayList<>(); for (BBQualificationRequirement bbQualificationRequirement : qualificationRequirements) { List<Locale> locales = new ArrayList<>(); for (BBLocale bbLocale : bbQualificationRequirement.locales) { Locale locale = new Locale()
              .withCountry(bbLocale.country.trim()); if (!bbLocale.subdivision.trim().isEmpty()) { locale.setSubdivision(bbLocale.subdivision.trim()); } locales.add(locale); } List<Integer> integerValues = new ArrayList<>(); for (String integerString : bbQualificationRequirement.integerValues.split("","")) { try { Integer integerValue = Integer.parseInt(integerString.trim()); integerValues.add(integerValue); } catch (NumberFormatException nfe) { } } String qualificationTypeId = bbQualificationRequirement.selectedQualificationType.qualificationTypeId; if (qualificationTypeId.equals(""OTHER_EXPERIMENT"")) { String experimentUid = bbQualificationRequirement.otherExperiment; String qualificationName = PARTICIPANT_QUALIFICATION_PREFIX + experimentUid; QualificationType qualificationType = getQualificationTypeByName(qualificationName, sandbox); if (qualificationType != null) { qualificationTypeId = qualificationType.getQualificationTypeId(); } } QualificationRequirement qualificationRequirement = new QualificationRequirement()
            .withActionsGuarded(bbQualificationRequirement.actionsGuarded)
            .withComparator(bbQualificationRequirement.comparator)
            .withQualificationTypeId(qualificationTypeId); if (!locales.isEmpty()) { qualificationRequirement.setLocaleValues(locales); } if (!integerValues.isEmpty()) { qualificationRequirement.setIntegerValues(integerValues); } qualificationRequirementList.add(qualificationRequirement); } if (!qualificationRequirementList.isEmpty()) { createHITRequest.setQualificationRequirements(qualificationRequirementList); } CreateHITResult createHITResult = mTurk.createHIT(createHITRequest); HIT hit = createHITResult.getHIT(); AMTHit amtHit = new AMTHit(); amtHit.hitId = hit.getHITId(); amtHit.description = hit.getDescription(); amtHit.lifetimeInSeconds = hitLifetime.toString(); amtHit.tutorialTime = tutorialTime.toString(); amtHit.maxAssignments = hit.getMaxAssignments().toString(); amtHit.externalURL = externalURL; amtHit.reward = hit.getReward(); amtHit.title = hit.getTitle(); amtHit.disallowPrevious = disallowPrevious; amtHit.sandbox = sandbox; ExperimentInstance experimentInstance = ExperimentInstance.findById(Long.parseLong(experimentInstanceId)); experimentInstance.amtHits.add(amtHit); experimentInstance.save(); return ok(amtHit.toJson()); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result createDummyHit(Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String workerId = null; String reason = null; String reward = null; String paymentHitHtml = getDummyHitHTML(); if (paymentHitHtml == null) { return badRequest(""Unable to read 'payment-hit.html' or 'default-payment-hit.html' file in conf/defaults directory.""); } JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { workerId = json.findPath(""workerId"").textValue(); reason = json.findPath(""reason"").textValue(); reward = json.findPath(""reward"").textValue(); } if (workerId == null || reason == null || reward == null) { return badRequest(""Please provide workerId, reason, and reward.""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); String qualificationName = new Date().getTime() + ""_"" + workerId; CreateQualificationTypeRequest createQualificationTypeRequest = new CreateQualificationTypeRequest()
          .withName(qualificationName)
          .withDescription(reason)
          .withQualificationTypeStatus(QualificationTypeStatus.Active); CreateQualificationTypeResult createQualificationTypeResult = mTurk.createQualificationType(createQualificationTypeRequest); AssociateQualificationWithWorkerRequest associateQualificationWithWorkerRequest = new AssociateQualificationWithWorkerRequest()
          .withQualificationTypeId(createQualificationTypeResult.getQualificationType().getQualificationTypeId())
          .withIntegerValue(1)
          .withWorkerId(workerId); mTurk.associateQualificationWithWorker(associateQualificationWithWorkerRequest); QualificationRequirement qualificationRequirement = new QualificationRequirement()
          .withQualificationTypeId(createQualificationTypeResult.getQualificationType().getQualificationTypeId())
          .withRequiredToPreview(true)
          .withComparator(""EqualTo"")
          .withIntegerValues(1); CreateHITRequest createHITRequest = new CreateHITRequest()
          .withTitle(""HIT for "" + workerId)
          .withDescription(reason)
          .withMaxAssignments(1)
          .withQuestion(paymentHitHtml)
          .withQualificationRequirements(qualificationRequirement)
          .withLifetimeInSeconds(31536000L)
          .withAssignmentDurationInSeconds(5400L)
          .withKeywords(workerId)
          .withReward(reward); mTurk.createHIT(createHITRequest); return ok(); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } private static String getDummyHitHTML() { String returnString = null; InputStream paymentHitHtml = Play.application().resourceAsStream(""defaults/payment-hit.html""); if (paymentHitHtml == null) paymentHitHtml = Play.application().resourceAsStream(""defaults/default-payment-hit.html""); if (paymentHitHtml == null) return null; try { ""  <HTMLContent><![CDATA["" +
                     IOUtils.toString(paymentHitHtml) +
                     ""]]>\n"" +
                     ""  </HTMLContent>\n"" +
                     ""  <FrameHeight>600</FrameHeight>\n"" +
                     ""</HTMLQuestion>""; } catch (IOException ioe) { } return returnString; } private static class ExperimentQualificationType { public QualificationType qualificationType; public Experiment experiment; } private static class BBQualificationRequirement { public String actionsGuarded; public String comparator; public String integerValues; public List<BBLocale> locales; public String otherExperiment; public BBQualificationType selectedQualificationType; } private static class BBQualificationType { public String label; public String qualificationTypeId; public String experimentUid; public String experimentName; public String creationTime; public String description; public Boolean isRequestable; public Boolean autoGranted; public String keywords; public String name; public String qualificationTypeStatus; } private static class BBLocale { public String country; public String subdivision; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package controllers; public class AMTAdmin extends Controller { private static final String PRODUCTION_ENDPOINT = ""mturk-requester.us-east-1.amazonaws.com""; private static final String SANDBOX_ENDPOINT = ""mturk-requester-sandbox.us-east-1.amazonaws.com""; private static final String SIGNING_REGION = ""us-east-1""; private static final String SECRET_KEY = Play.application().configuration().getString(""amt.secretKey""); private static final String ACCESS_KEY = Play.application().configuration().getString(""amt.accessKey""); private static final String PARTICIPANT_QUALIFICATION_PREFIX = ""breadboard_participant_""; @Security.Authenticated(Secured.class)
  public static Result getAccountBalance(Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } <FILL_ME> try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); GetAccountBalanceRequest getAccountBalanceRequest= new GetAccountBalanceRequest(); GetAccountBalanceResult getAccountBalanceResult = mTurk.getAccountBalance(getAccountBalanceRequest); String availableBalance = getAccountBalanceResult.getAvailableBalance(); String onHoldBalance = getAccountBalanceResult.getOnHoldBalance(); ObjectNode returnJson = Json.newObject(); returnJson.put(""availableBalance"", availableBalance); returnJson.put(""onHoldBalance"", onHoldBalance); return ok(returnJson); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } private static class JsonWorker { public String workerId; public List<ObjectNode> assignments = new ArrayList<>(); public int nCompleted = 0; JsonWorker(String id) { workerId = id; } public ObjectNode toJson() { ObjectNode worker = Json.newObject(); worker.put(""id"", workerId); worker.put(""nAssignments"", assignments.size()); worker.put(""assignmentsCompleted"", nCompleted); ArrayNode jsonAssignments = worker.putArray(""assignments""); jsonAssignments.addAll(assignments); return worker; } } @Security.Authenticated(Secured.class)
  public static Result addQualificationType(String experimentUid, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } Experiment experiment = Experiment.findByUid(experimentUid); if (experiment == null) { return badRequest(""Invalid experiment UID.""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); String qualificationName = PARTICIPANT_QUALIFICATION_PREFIX + experimentUid; String reason = ""You previously participated in this experiment.""; CreateQualificationTypeRequest createQualificationTypeRequest = new CreateQualificationTypeRequest()
          .withName(qualificationName)
          .withDescription(reason)
          .withQualificationTypeStatus(QualificationTypeStatus.Active); CreateQualificationTypeResult createQualificationTypeResult = mTurk.createQualificationType(createQualificationTypeRequest); QualificationType qualificationType = createQualificationTypeResult.getQualificationType(); ObjectNode qualificationTypeJson = Json.newObject(); TimeZone tz = TimeZone.getTimeZone(""UTC""); DateFormat df = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm'Z'""); df.setTimeZone(tz); qualificationTypeJson.put(""experimentUid"", experimentUid); qualificationTypeJson.put(""experimentName"", experiment.name); qualificationTypeJson.put(""creationTime"", df.format(qualificationType.getCreationTime())); qualificationTypeJson.put(""description"", qualificationType.getDescription()); qualificationTypeJson.put(""isRequestable"", qualificationType.getIsRequestable()); qualificationTypeJson.put(""keywords"", qualificationType.getKeywords()); qualificationTypeJson.put(""name"", qualificationType.getName()); qualificationTypeJson.put(""qualificationTypeId"", qualificationType.getQualificationTypeId()); qualificationTypeJson.put(""qualificationTypeStatus"", qualificationType.getQualificationTypeStatus()); qualificationTypeJson.put(""autoGranted"", qualificationType.getAutoGranted()); return ok(qualificationTypeJson); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } public static QualificationType getQualificationTypeByName(String qualificationName, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return null; } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); ListQualificationTypesRequest listQualificationTypesRequest = new ListQualificationTypesRequest()
          .withMaxResults(1)
          .withMustBeOwnedByCaller(false)
          .withMustBeRequestable(false)
          .withQuery(qualificationName); ListQualificationTypesResult listQualificationTypesResult = mTurk.listQualificationTypes(listQualificationTypesRequest); List<QualificationType> qualificationTypes = listQualificationTypesResult.getQualificationTypes(); if (qualificationTypes.isEmpty()) { return null; } return qualificationTypes.get(0); } catch (AmazonServiceException ase) { return null; } catch (AmazonClientException ace) { return null; } } @Security.Authenticated(Secured.class)
  public static Result listQualificationTypes(Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); List<ExperimentQualificationType> experimentQualificationTypes = new ArrayList<ExperimentQualificationType>(); for (Experiment experiment: Experiment.findAll()) { ListQualificationTypesRequest listQualificationTypesRequest = new ListQualificationTypesRequest()
            .withMaxResults(1)
            .withMustBeOwnedByCaller(true)
            .withMustBeRequestable(false)
            .withQuery(PARTICIPANT_QUALIFICATION_PREFIX + experiment.uid); ListQualificationTypesResult listQualificationTypesResult = mTurk.listQualificationTypes(listQualificationTypesRequest); List<QualificationType> qualificationType = listQualificationTypesResult.getQualificationTypes(); ExperimentQualificationType experimentQualificationType = new ExperimentQualificationType(); if (!qualificationType.isEmpty()) { experimentQualificationType.qualificationType = qualificationType.get(0); } experimentQualificationType.experiment = experiment; experimentQualificationTypes.add(experimentQualificationType); } ObjectNode returnJson = Json.newObject(); ArrayNode qualificationTypesJson = returnJson.putArray(""qualificationTypes""); TimeZone tz = TimeZone.getTimeZone(""UTC""); DateFormat df = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm'Z'""); df.setTimeZone(tz); for (ExperimentQualificationType experimentQualificationType : experimentQualificationTypes) { QualificationType qualificationType = experimentQualificationType.qualificationType; Experiment experiment = experimentQualificationType.experiment; ObjectNode qualificationTypeJson = Json.newObject(); qualificationTypeJson.put(""label"", experiment.name + "" participant""); qualificationTypeJson.put(""experimentUid"", experiment.uid); qualificationTypeJson.put(""experimentName"", experiment.name); qualificationTypeJson.put(""creationTime"", (qualificationType == null) ? null : df.format(qualificationType.getCreationTime())); qualificationTypeJson.put(""description"", (qualificationType == null) ? null : qualificationType.getDescription()); qualificationTypeJson.put(""isRequestable"", (qualificationType == null) ? null : qualificationType.getIsRequestable()); qualificationTypeJson.put(""keywords"", (qualificationType == null) ? null : qualificationType.getKeywords()); qualificationTypeJson.put(""name"", (qualificationType == null) ? null : qualificationType.getName()); qualificationTypeJson.put(""qualificationTypeId"", (qualificationType == null) ? null : qualificationType.getQualificationTypeId()); qualificationTypeJson.put(""qualificationTypeStatus"", (qualificationType == null) ? null : qualificationType.getQualificationTypeStatus()); qualificationTypeJson.put(""autoGranted"", (qualificationType == null) ? null : qualificationType.getAutoGranted()); qualificationTypesJson.add(qualificationTypeJson); } returnJson.put(""rows"", experimentQualificationTypes.size()); return ok(returnJson); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result getExperimentQualificationTypeId(String experimentUid, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } QualificationType qualificationType = getQualificationTypeByName(PARTICIPANT_QUALIFICATION_PREFIX + experimentUid, sandbox); if (qualificationType == null) { try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); String qualificationName = PARTICIPANT_QUALIFICATION_PREFIX + experimentUid; String reason = ""You previously participated in this experiment.""; CreateQualificationTypeRequest createQualificationTypeRequest = new CreateQualificationTypeRequest()
            .withName(qualificationName)
            .withDescription(reason)
            .withQualificationTypeStatus(QualificationTypeStatus.Active); CreateQualificationTypeResult createQualificationTypeResult = mTurk.createQualificationType(createQualificationTypeRequest); qualificationType = createQualificationTypeResult.getQualificationType(); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } ObjectNode returnJson = Json.newObject(); returnJson.put(""qualificationTypeId"", qualificationType.getQualificationTypeId()); return ok(returnJson); } @Security.Authenticated(Secured.class)
  public static Result assignParticipantQualification(Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String workerId = null; String qualificationTypeId = null; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { workerId = json.findPath(""workerId"").textValue(); qualificationTypeId = json.findPath(""qualificationTypeId"").textValue(); } if (workerId == null) { return badRequest(""Please provide an AMT worker ID.""); } if (qualificationTypeId == null) { return badRequest(""Please provide a qualification type ID.""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); AssociateQualificationWithWorkerRequest associateQualificationWithWorkerRequest = new AssociateQualificationWithWorkerRequest()
          .withQualificationTypeId(qualificationTypeId)
          .withIntegerValue(1)
          .withSendNotification(false)
          .withWorkerId(workerId); mTurk.associateQualificationWithWorker(associateQualificationWithWorkerRequest); return ok(); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result removeParticipantQualification(Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String workerId = null; String qualificationTypeId = null; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { workerId = json.findPath(""workerId"").textValue(); qualificationTypeId = json.findPath(""qualificationTypeId"").textValue(); } if (workerId == null) { return badRequest(""Please provide an AMT worker ID.""); } if (qualificationTypeId == null) { return badRequest(""Please provide a qualification type ID.""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); DisassociateQualificationFromWorkerRequest disassociateQualificationFromWorkerRequest = new DisassociateQualificationFromWorkerRequest()
          .withQualificationTypeId(qualificationTypeId)
          .withWorkerId(workerId); mTurk.disassociateQualificationFromWorker(disassociateQualificationFromWorkerRequest); return ok(); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result getQualificationScore(Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String workerId = null; String qualificationTypeId = null; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { workerId = json.findPath(""workerId"").textValue(); qualificationTypeId = json.findPath(""qualificationTypeId"").textValue(); } if (workerId == null) { return badRequest(""Please provide an AMT worker ID.""); } if (qualificationTypeId == null) { return badRequest(""Please provide a qualification type ID.""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); GetQualificationScoreRequest getQualificationScoreRequest = new GetQualificationScoreRequest()
          .withQualificationTypeId(qualificationTypeId)
          .withWorkerId(workerId); GetQualificationScoreResult qualificationScoreResult = mTurk.getQualificationScore(getQualificationScoreRequest); Qualification qualification = qualificationScoreResult.getQualification(); TimeZone tz = TimeZone.getTimeZone(""UTC""); DateFormat df = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm'Z'""); df.setTimeZone(tz); ObjectNode returnJson = Json.newObject(); if (qualification == null) { returnJson.put(""status"", ""None""); } else { returnJson.put(""grantTime"", df.format(qualification.getGrantTime())); returnJson.put(""integerValue"", qualification.getIntegerValue()); if (qualification.getLocaleValue() != null) { returnJson.put(""localeValue"", qualification.getLocaleValue().toString()); } returnJson.put(""qualificationTypeId"", qualification.getQualificationTypeId()); returnJson.put(""status"", qualification.getStatus()); returnJson.put(""workerId"", qualification.getWorkerId()); } return ok(returnJson); } catch (AmazonServiceException ase) { ObjectNode returnJson = Json.newObject(); returnJson.put(""status"", ""None""); return ok(returnJson); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result importAMTWorkers(Long experimentId, Boolean sandbox) { Http.MultipartFormData body = request().body().asMultipartFormData(); Long maxUploadSize = play.Play.application().configuration().getLong(""maxUploadSize"", 50L * 1024L * 1024L); try { Long fileSize = Long.parseLong(request().getHeader(""Content-Length""), 10); if (fileSize > maxUploadSize) { return badRequest(""Uploaded file is too large""); } } catch(Exception e){ return badRequest(""Upload was malformed""); } Http.MultipartFormData.FilePart filePart = body.getFile(""file""); File workerCsvFile = filePart.getFile(); Experiment experiment = Experiment.findById(experimentId); if(experiment == null){ return badRequest(""Invalid experiment ID""); } if(workerCsvFile.length() > maxUploadSize){ return badRequest(""Uploaded file is too large""); } try { Reader in = new FileReader(workerCsvFile); try { Date now = new Date(); String importTitle = ""IMPORTED_"" + experimentId + ""_"" + now.getTime(); ExperimentInstance instance = new ExperimentInstance(importTitle, experiment); experiment.instances.add(instance); experiment.save(); AMTHit amtHit = new AMTHit(); amtHit.creationDate = now; amtHit.requestId = ""IMPORTED""; amtHit.isValid = ""true""; amtHit.hitId = ""IMPORTED_"" + experimentId + ""_"" + now.getTime(); amtHit.title = ""IMPORTED INTO "" + experiment.name + "" AT "" + now.getTime(); amtHit.description = ""This is a fake HIT created by breadboard when importing AMT Worker IDs to prevent repeat play.""; amtHit.lifetimeInSeconds = ""0""; amtHit.tutorialTime = ""0""; amtHit.maxAssignments = ""0""; amtHit.externalURL = ""IMPORTED""; amtHit.reward = ""0""; amtHit.disallowPrevious = ""none""; amtHit.sandbox = sandbox; amtHit.setExtended(false); amtHit.experimentInstance = instance; amtHit.save(); int assignmentIndex = 0; CSVFormat format = CSVFormat.DEFAULT; for (CSVRecord record : format.parse(in)) { String workerId = record.get(0); <FILL_ME> AMTWorker amtWorker = AMTWorker.findByWorkerId(workerId); if (amtWorker == null) { amtWorker = new AMTWorker(); amtWorker.workerId = workerId; amtWorker.score = """"; amtWorker.completion = """"; amtWorker.amtHit = amtHit; amtWorker.save(); } AMTAssignment amtAssignment = new AMTAssignment(); amtAssignment.assignmentId = ""IMPORTED_"" + experimentId + ""_"" + now.getTime() + ""_"" + (++assignmentIndex); amtAssignment.workerId = workerId; amtAssignment.assignmentCompleted = true; amtAssignment.assignmentStatus = ""IMPORTED""; amtAssignment.autoApprovalTime = ""IMPORTED""; amtAssignment.acceptTime = null; amtAssignment.submitTime = null; amtAssignment.answer = """"; amtAssignment.score = """"; amtAssignment.reason = ""IMPORTED""; amtAssignment.completion = """"; amtAssignment.bonusAmount = """"; amtAssignment.bonusGranted = false; amtAssignment.workerBlocked = false; amtAssignment.qualificationAssigned = false; amtAssignment.amtHit = amtHit; amtAssignment.save(); } } finally { in.close(); } } catch (IOException ioe) { return badRequest(""Error reading uploaded file""); } return ok(); } @Security.Authenticated(Secured.class)
  public static Result disassociateQualificationFromWorker(String qualificationTypeId, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String workerId; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { workerId = json.findPath(""workerId"").textValue(); } if (workerId == null) { return badRequest(""Please provide an AMT worker ID.""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); DisassociateQualificationFromWorkerRequest disassociateQualificationFromWorkerRequest = new DisassociateQualificationFromWorkerRequest()
          .withQualificationTypeId(qualificationTypeId)
          .withWorkerId(workerId)
          .withReason(""Allowing re-participation in this experiment type.""); mTurk.disassociateQualificationFromWorker(disassociateQualificationFromWorkerRequest); return ok(); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result listWorkersWithQualificationType(String qualificationTypeId, Integer maxResults, String nextToken, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); ListWorkersWithQualificationTypeRequest listWorkersWithQualificationTypeRequest = new ListWorkersWithQualificationTypeRequest()
          .withQualificationTypeId(qualificationTypeId)
          .withMaxResults((maxResults == null) ? 20 : maxResults)
          .withStatus(QualificationStatus.Granted); if (nextToken != null) listWorkersWithQualificationTypeRequest.setNextToken(nextToken); ListWorkersWithQualificationTypeResult listWorkersWithQualificationTypeResult = mTurk.listWorkersWithQualificationType(listWorkersWithQualificationTypeRequest); List<Qualification> qualifications = listWorkersWithQualificationTypeResult.getQualifications(); ObjectNode returnJson = Json.newObject(); ArrayNode qualificationsJson = returnJson.putArray(""qualifications""); TimeZone tz = TimeZone.getTimeZone(""UTC""); DateFormat df = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm'Z'""); df.setTimeZone(tz); for (Qualification qualification : qualifications) { ObjectNode qualificationJson = Json.newObject(); qualificationJson.put(""qualificationTypeId"", qualification.getQualificationTypeId()); qualificationJson.put(""grantTime"", df.format(qualification.getGrantTime())); qualificationJson.put(""integerValue"", qualification.getIntegerValue()); qualificationJson.put(""status"", qualification.getStatus()); qualificationJson.put(""workerId"", qualification.getWorkerId()); qualificationsJson.add(qualificationJson); } returnJson.put(""rows"", listWorkersWithQualificationTypeResult.getNumResults()); returnJson.put(""nextToken"", listWorkersWithQualificationTypeResult.getNextToken()); return ok(returnJson); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result getAMTWorkers(Long experimentId, Boolean sandbox, Integer limit, Integer offset, String search) { HashMap<String, JsonWorker> amtWorkerAssignments = new HashMap<>(); ObjectNode returnJson = Json.newObject(); String workerCountSql = ""select count(distinct worker_id) as worker_count from amt_assignments "" +
        "" where worker_id like CONCAT(:search, '%')"" +
        "" and worker_id in "" +
        ""(select worker_id from amt_assignments "" +
        "" where amt_hit_id in "" +
        ""(select id from amt_hits where sandbox = :sandbox)); ""; SqlRow sqlRow = Ebean.createSqlQuery(workerCountSql)
        .setParameter(""search"", search)
        .setParameter(""sandbox"", (sandbox) ? 1 : 0)
        .findUnique(); Long workerCount = sqlRow.getLong(""worker_count""); String workerIdSql = ""select distinct worker_id from amt_assignments "" +
        "" where worker_id like CONCAT(:search, '%')"" +
        "" and worker_id in "" +
        ""(select worker_id from amt_assignments "" +
        "" where amt_hit_id in "" +
        ""(select id from amt_hits where sandbox = :sandbox))"" +
        "" order by worker_id limit :limit offset :offset""; SqlQuery sqlQuery = Ebean.createSqlQuery(workerIdSql)
        .setParameter(""limit"", limit)
        .setParameter(""offset"", offset)
        .setParameter(""search"", search)
        .setParameter(""sandbox"", (sandbox) ? 1 : 0); List<SqlRow> workerIds = sqlQuery.findList(); returnJson.put(""total"", workerCount); returnJson.put(""offset"", offset); returnJson.put(""limit"", limit); int endI = Math.min(limit, workerIds.size()); for (int i = 0; i < endI; i++) { SqlRow row = workerIds.get(i); String workerId = row.getString(""worker_id""); List<AMTAssignment> assignments = AMTAssignment.find
          .where()
          .eq(""worker_id"", workerId)
          .findList(); if (! amtWorkerAssignments.containsKey(workerId)) { amtWorkerAssignments.put(workerId, new JsonWorker(workerId)); } JsonWorker jsonWorker = amtWorkerAssignments.get(workerId); for (AMTAssignment assignment : assignments) { AMTHit hit = assignment.amtHit; ExperimentInstance instance = hit.experimentInstance; Experiment experiment = (instance == null) ? null : instance.experiment; String experimentName = (experiment == null) ? """" : experiment.name; Long eId = (experiment == null) ? -1L : experiment.id; String eUid = (experiment == null) ? """" : experiment.uid; Boolean assignmentCompleted = assignment.assignmentCompleted; ; if (assignmentCompleted != null && assignmentCompleted) jsonWorker.nCompleted++; ObjectNode amtAssignment = Json.newObject(); amtAssignment.put(""id"", assignment.id); amtAssignment.put(""assignmentId"", assignment.assignmentId); amtAssignment.put(""workerId"", workerId); amtAssignment.put(""assignmentStatus"", assignment.assignmentStatus); amtAssignment.put(""autoApprovalTime"", assignment.autoApprovalTime); amtAssignment.put(""acceptTime"", assignment.acceptTime); amtAssignment.put(""submitTime"", assignment.submitTime); amtAssignment.put(""answer"", assignment.answer); amtAssignment.put(""score"", assignment.score); amtAssignment.put(""reason"", assignment.reason); amtAssignment.put(""completion"", assignment.completion); amtAssignment.put(""assignmentCompleted"", assignmentCompleted); amtAssignment.put(""bonusGranted"", assignment.bonusGranted); amtAssignment.put(""bonusAmount"", assignment.bonusAmount); amtAssignment.put(""workerBlocked"", assignment.workerBlocked); amtAssignment.put(""qualificationAssigned"", assignment.qualificationAssigned); amtAssignment.put(""experimentName"", experimentName); amtAssignment.put(""experimentUid"", eUid); amtAssignment.put(""experimentId"", eId); jsonWorker.assignments.add(amtAssignment); } } ArrayNode amtWorkersJson = returnJson.putArray(""amtWorkers""); for (JsonWorker jsonWorker : amtWorkerAssignments.values()) { amtWorkersJson.add(jsonWorker.toJson()); } returnJson.put(""rows"", amtWorkerAssignments.size()); return ok(returnJson); } @Security.Authenticated(Secured.class)
  public static Result listHITs(String nextToken, Integer maxResults, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); ListHITsRequest listHITsRequest = new ListHITsRequest().withMaxResults((maxResults == null) ? 20 : maxResults); if (nextToken != null) listHITsRequest.setNextToken(nextToken); ListHITsResult hitResults = mTurk.listHITs(listHITsRequest); List<HIT> hits = hitResults.getHITs(); for (HIT hit : hits) { AMTHit amtHit = AMTHit.findByHitId(hit.getHITId()); if (amtHit == null) { amtHit = new AMTHit(); } amtHit.hitId = hit.getHITId(); amtHit.creationDate = hit.getCreationTime(); amtHit.title = hit.getTitle(); amtHit.description = hit.getDescription(); amtHit.maxAssignments = hit.getMaxAssignments().toString(); amtHit.reward = hit.getReward(); amtHit.sandbox = sandbox; amtHit.save(); } String next = hitResults.getNextToken(); ObjectNode returnJson = Json.newObject(); returnJson.put(""hits"", Json.toJson(hits)); returnJson.put(""nextToken"", next); return ok(returnJson); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result listAssignmentsForHIT(String hitId, Integer maxResults, String nextToken, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); ListAssignmentsForHITRequest listAssignmentsForHITRequest = new ListAssignmentsForHITRequest().withMaxResults(maxResults).withHITId(hitId); ObjectNode returnJson = Json.newObject(); ArrayNode jsonAssignments = returnJson.putArray(""assignments""); if (nextToken != null) listAssignmentsForHITRequest.setNextToken(nextToken); ListAssignmentsForHITResult assignmentResults = mTurk.listAssignmentsForHIT(listAssignmentsForHITRequest); List<Assignment> assignments = assignmentResults.getAssignments(); TimeZone tz = TimeZone.getTimeZone(""UTC""); DateFormat df = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm'Z'""); df.setTimeZone(tz); for (Assignment assignment : assignments) { AMTHit hit = AMTHit.findByHitId(assignment.getHITId()); AMTAssignment amtAssignment = hit.getAMTAssignmentById(assignment.getAssignmentId()); boolean update = true; if (amtAssignment == null) { amtAssignment = new AMTAssignment(); amtAssignment.assignmentCompleted = false; update = false; } amtAssignment.amtHit = hit; amtAssignment.assignmentId = assignment.getAssignmentId(); amtAssignment.workerId = assignment.getWorkerId(); amtAssignment.assignmentStatus = assignment.getAssignmentStatus(); amtAssignment.autoApprovalTime = assignment.getAutoApprovalTime().toString(); amtAssignment.acceptTime = (assignment.getAcceptTime() == null) ? null :  df.format(assignment.getAcceptTime()); amtAssignment.submitTime = (assignment.getSubmitTime() == null) ? null :  df.format(assignment.getSubmitTime()); amtAssignment.answer = assignment.getAnswer(); if (!update) { hit.amtAssignments.add(amtAssignment); } hit.save(); ObjectNode jsonAssignment = Json.newObject(); jsonAssignment.put(""assignmentId"", amtAssignment.assignmentId); jsonAssignment.put(""workerId"", amtAssignment.workerId); jsonAssignment.put(""approvalTime"", (assignment.getApprovalTime() == null) ? null : df.format(assignment.getApprovalTime())); jsonAssignment.put(""rejectionTime"", (assignment.getRejectionTime() == null) ? null : df.format(assignment.getRejectionTime())); jsonAssignment.put(""answer"", amtAssignment.answer); jsonAssignment.put(""assignmentCompleted"", amtAssignment.assignmentCompleted); jsonAssignments.add(jsonAssignment); } String token = assignmentResults.getNextToken(); returnJson.put(""nextToken"", token); return ok(returnJson); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result listBonusPaymentsForHIT(String hitId, Integer maxResults, String nextToken, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); ListBonusPaymentsRequest listBonusPaymentsRequest = new ListBonusPaymentsRequest().withMaxResults(maxResults).withHITId(hitId); if (nextToken != null) listBonusPaymentsRequest.setNextToken(nextToken); ListBonusPaymentsResult bonusPaymentsResults = mTurk.listBonusPayments(listBonusPaymentsRequest); List<BonusPayment> bonusPayments = bonusPaymentsResults.getBonusPayments(); for (BonusPayment bonusPayment : bonusPayments) { AMTAssignment amtAssignment = AMTAssignment.findByAssignmentId(bonusPayment.getAssignmentId()); if (amtAssignment != null) { amtAssignment.bonusGranted = true; amtAssignment.bonusAmount = bonusPayment.getBonusAmount(); amtAssignment.save(); } } String token = bonusPaymentsResults.getNextToken(); ObjectNode returnJson = Json.newObject(); returnJson.put(""bonusPayments"", Json.toJson(bonusPayments)); returnJson.put(""nextToken"", token); return ok(returnJson); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result approveAssignment(String assignmentId, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); ApproveAssignmentRequest approveAssignmentRequest= new ApproveAssignmentRequest().withAssignmentId(assignmentId); mTurk.approveAssignment(approveAssignmentRequest); return ok(); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result rejectAssignment(String assignmentId, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String requesterFeedback = null; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { requesterFeedback = json.findPath(""requesterFeedback"").textValue(); } if (requesterFeedback == null) { return badRequest(""Please provide requester feedback.""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); RejectAssignmentRequest rejectAssignmentRequest= new RejectAssignmentRequest()
          .withAssignmentId(assignmentId)
          .withRequesterFeedback(requesterFeedback); mTurk.rejectAssignment(rejectAssignmentRequest); return ok(); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result sendBonus(String assignmentId, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String bonusAmount = null; String reason = null; String workerId = null; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { bonusAmount = json.findPath(""bonusAmount"").textValue(); reason = json.findPath(""reason"").textValue(); workerId = json.findPath(""workerId"").textValue(); } if (bonusAmount == null || reason == null || workerId == null) { return badRequest(""Please provide workerId, bonusAmount, and reason.""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); SendBonusRequest sendBonusRequest= new SendBonusRequest().withAssignmentId(assignmentId).withBonusAmount(bonusAmount).withReason(reason).withWorkerId(workerId); mTurk.sendBonus(sendBonusRequest); return ok(); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result updateAssignmentCompleted(String assignmentId) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String completedText; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { completedText = json.findPath(""completed"").asText(); } if (completedText == null || (!(completedText.matches(""(?i)0|1|true|false"")))) { return badRequest(""Please provide completed as a boolean value (0, 1, true, false).""); } AMTAssignment amtAssignment = AMTAssignment.findByAssignmentId(assignmentId); if (amtAssignment == null) { return badRequest(""Invalid Assignment ID.""); } Boolean completed = (completedText.matches(""(?i)1|true"")); amtAssignment.assignmentCompleted = completed; amtAssignment.save(); return ok(); } @Security.Authenticated(Secured.class)
  public static Result createHIT(Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String title; String description; String reward; Integer maxAssignments; Long hitLifetime; Long tutorialTime; Long assignmentDuration; String keywords; String disallowPrevious; String experimentId; String experimentInstanceId; BBQualificationRequirement[] qualificationRequirements = null; JsonNode json = request().body().asJson(); if (json == null) { return badRequest(""Expecting Json data""); } else { title = json.findPath(""title"").textValue(); description = json.findPath(""description"").textValue(); reward = json.findPath(""reward"").textValue(); maxAssignments = json.findPath(""maxAssignments"").asInt(-1); hitLifetime = json.findPath(""hitLifetime"").asLong(-1L); tutorialTime = json.findPath(""tutorialTime"").asLong(-1L); assignmentDuration = json.findPath(""assignmentDuration"").asLong(-1L); keywords = json.findPath(""keywords"").textValue(); disallowPrevious = json.findPath(""disallowPrevious"").textValue(); experimentId = json.findPath(""experimentId"").textValue(); experimentInstanceId = json.findPath(""experimentInstanceId"").textValue(); <FILL_ME> try { qualificationRequirements = new ObjectMapper().readValue(json.findPath(""qualificationRequirements"").toString(), BBQualificationRequirement[].class); } catch(IOException ioe) { } } if (title == null || description == null || reward == null || maxAssignments < 0 || hitLifetime < 0 || tutorialTime < 0 || assignmentDuration < 0 || keywords == null || disallowPrevious == null || experimentId == null || experimentInstanceId == null) { return badRequest(""Please provide experiment ID, experiment instance ID, title, description, reward, max assignments, hit lifetime, tutorial time, assignment duration, keywords, and allow repeat play option.""); } String rootURL = play.Play.application().configuration().getString(""breadboard.rootUrl""); String gameURL = String.format(""/game/%1$s/%2$s/amt"", experimentId, experimentInstanceId); String externalURL = rootURL + gameURL; Integer frameHeight = play.Play.application().configuration().getInt(""breadboard.amtFrameHeight""); ""  <ExternalURL>"" + externalURL + ""</ExternalURL>\n"" +
        ""  <FrameHeight>"" + frameHeight + ""</FrameHeight>\n"" +
        ""</ExternalQuestion>""; try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); Experiment experiment = Experiment.findById(Long.parseLong(experimentId)); String experimentName = experiment.name; if (experimentName.length() > 120) experimentName = experimentName.substring(0, 120) + ""...""; String annotation = ""{ \""experimentType\"":\""breadboard\"",\""experimentUid\"":\"""" + experiment.uid + ""\"",\""experimentName\"":\"""" + experimentName + ""\""} ""; CreateHITRequest createHITRequest = new CreateHITRequest()
          .withQuestion(question)
          .withTitle(title)
          .withDescription(description)
          .withMaxAssignments(maxAssignments)
          .withLifetimeInSeconds(hitLifetime)
          .withAssignmentDurationInSeconds(assignmentDuration)
          .withKeywords(keywords)
          .withReward(reward)
          .withRequesterAnnotation(annotation); if (qualificationRequirements != null) { <FILL_ME> } List<QualificationRequirement> qualificationRequirementList = new ArrayList<>(); for (BBQualificationRequirement bbQualificationRequirement : qualificationRequirements) { List<Locale> locales = new ArrayList<>(); for (BBLocale bbLocale : bbQualificationRequirement.locales) { Locale locale = new Locale()
              .withCountry(bbLocale.country.trim()); if (!bbLocale.subdivision.trim().isEmpty()) { locale.setSubdivision(bbLocale.subdivision.trim()); } locales.add(locale); } List<Integer> integerValues = new ArrayList<>(); for (String integerString : bbQualificationRequirement.integerValues.split("","")) { try { Integer integerValue = Integer.parseInt(integerString.trim()); integerValues.add(integerValue); } catch (NumberFormatException nfe) { } } String qualificationTypeId = bbQualificationRequirement.selectedQualificationType.qualificationTypeId; if (qualificationTypeId.equals(""OTHER_EXPERIMENT"")) { String experimentUid = bbQualificationRequirement.otherExperiment; String qualificationName = PARTICIPANT_QUALIFICATION_PREFIX + experimentUid; QualificationType qualificationType = getQualificationTypeByName(qualificationName, sandbox); if (qualificationType != null) { qualificationTypeId = qualificationType.getQualificationTypeId(); } } QualificationRequirement qualificationRequirement = new QualificationRequirement()
            .withActionsGuarded(bbQualificationRequirement.actionsGuarded)
            .withComparator(bbQualificationRequirement.comparator)
            .withQualificationTypeId(qualificationTypeId); if (!locales.isEmpty()) { qualificationRequirement.setLocaleValues(locales); } if (!integerValues.isEmpty()) { qualificationRequirement.setIntegerValues(integerValues); } qualificationRequirementList.add(qualificationRequirement); } if (!qualificationRequirementList.isEmpty()) { createHITRequest.setQualificationRequirements(qualificationRequirementList); } CreateHITResult createHITResult = mTurk.createHIT(createHITRequest); HIT hit = createHITResult.getHIT(); AMTHit amtHit = new AMTHit(); amtHit.hitId = hit.getHITId(); amtHit.description = hit.getDescription(); amtHit.lifetimeInSeconds = hitLifetime.toString(); amtHit.tutorialTime = tutorialTime.toString(); amtHit.maxAssignments = hit.getMaxAssignments().toString(); amtHit.externalURL = externalURL; amtHit.reward = hit.getReward(); amtHit.title = hit.getTitle(); amtHit.disallowPrevious = disallowPrevious; amtHit.sandbox = sandbox; ExperimentInstance experimentInstance = ExperimentInstance.findById(Long.parseLong(experimentInstanceId)); experimentInstance.amtHits.add(amtHit); experimentInstance.save(); return ok(amtHit.toJson()); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } @Security.Authenticated(Secured.class)
  public static Result createDummyHit(Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String workerId = null; String reason = null; String reward = null; String paymentHitHtml = getDummyHitHTML(); if (paymentHitHtml == null) { return badRequest(""Unable to read 'payment-hit.html' or 'default-payment-hit.html' file in conf/defaults directory.""); } JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { workerId = json.findPath(""workerId"").textValue(); reason = json.findPath(""reason"").textValue(); reward = json.findPath(""reward"").textValue(); } if (workerId == null || reason == null || reward == null) { return badRequest(""Please provide workerId, reason, and reward.""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); String qualificationName = new Date().getTime() + ""_"" + workerId; CreateQualificationTypeRequest createQualificationTypeRequest = new CreateQualificationTypeRequest()
          .withName(qualificationName)
          .withDescription(reason)
          .withQualificationTypeStatus(QualificationTypeStatus.Active); CreateQualificationTypeResult createQualificationTypeResult = mTurk.createQualificationType(createQualificationTypeRequest); AssociateQualificationWithWorkerRequest associateQualificationWithWorkerRequest = new AssociateQualificationWithWorkerRequest()
          .withQualificationTypeId(createQualificationTypeResult.getQualificationType().getQualificationTypeId())
          .withIntegerValue(1)
          .withWorkerId(workerId); mTurk.associateQualificationWithWorker(associateQualificationWithWorkerRequest); QualificationRequirement qualificationRequirement = new QualificationRequirement()
          .withQualificationTypeId(createQualificationTypeResult.getQualificationType().getQualificationTypeId())
          .withRequiredToPreview(true)
          .withComparator(""EqualTo"")
          .withIntegerValues(1); CreateHITRequest createHITRequest = new CreateHITRequest()
          .withTitle(""HIT for "" + workerId)
          .withDescription(reason)
          .withMaxAssignments(1)
          .withQuestion(paymentHitHtml)
          .withQualificationRequirements(qualificationRequirement)
          .withLifetimeInSeconds(31536000L)
          .withAssignmentDurationInSeconds(5400L)
          .withKeywords(workerId)
          .withReward(reward); mTurk.createHIT(createHITRequest); return ok(); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } } private static String getDummyHitHTML() { String returnString = null; InputStream paymentHitHtml = Play.application().resourceAsStream(""defaults/payment-hit.html""); if (paymentHitHtml == null) paymentHitHtml = Play.application().resourceAsStream(""defaults/default-payment-hit.html""); if (paymentHitHtml == null) return null; try { ""  <HTMLContent><![CDATA["" +
                     IOUtils.toString(paymentHitHtml) +
                     ""]]>\n"" +
                     ""  </HTMLContent>\n"" +
                     ""  <FrameHeight>600</FrameHeight>\n"" +
                     ""</HTMLQuestion>""; } catch (IOException ioe) { } return returnString; } private static class ExperimentQualificationType { public QualificationType qualificationType; public Experiment experiment; } private static class BBQualificationRequirement { public String actionsGuarded; public String comparator; public String integerValues; public List<BBLocale> locales; public String otherExperiment; public BBQualificationType selectedQualificationType; } private static class BBQualificationType { public String label; public String qualificationTypeId; public String experimentUid; public String experimentName; public String creationTime; public String description; public Boolean isRequestable; public Boolean autoGranted; public String keywords; public String name; public String qualificationTypeStatus; } private static class BBLocale { public String country; public String subdivision; } } ","package controllers; 
import com.amazonaws.AmazonClientException; import com.amazonaws.AmazonServiceException; import com.amazonaws.auth.AWSStaticCredentialsProvider; import com.amazonaws.auth.BasicAWSCredentials; import com.amazonaws.client.builder.AwsClientBuilder; import com.amazonaws.services.mturk.AmazonMTurk; import com.amazonaws.services.mturk.AmazonMTurkClientBuilder; import com.amazonaws.services.mturk.model.*; import com.amazonaws.services.mturk.model.Locale; import com.amazonaws.services.mturk.model.QualificationRequirement; import com.avaje.ebean.*; import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.node.ArrayNode; import com.fasterxml.jackson.databind.node.ObjectNode; import com.google.gson.Gson; import com.google.gson.reflect.TypeToken; import models.*; import org.apache.commons.csv.CSVFormat; import org.apache.commons.csv.CSVRecord; import org.apache.commons.io.IOUtils; import play.Logger; import play.Play; import play.libs.*; import play.mvc.Controller; import play.mvc.Http; import play.mvc.Result; import play.mvc.Security; 
import java.io.*; import java.lang.reflect.Type; import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.*;  public class AMTAdmin extends Controller { private static final String PRODUCTION_ENDPOINT = ""mturk-requester.us-east-1.amazonaws.com""; private static final String SANDBOX_ENDPOINT = ""mturk-requester-sandbox.us-east-1.amazonaws.com""; private static final String SIGNING_REGION = ""us-east-1""; private static final String SECRET_KEY = Play.application().configuration().getString(""amt.secretKey""); private static final String ACCESS_KEY = Play.application().configuration().getString(""amt.accessKey""); private static final String PARTICIPANT_QUALIFICATION_PREFIX = ""breadboard_participant_"";  @Security.Authenticated(Secured.class)
  public static Result getAccountBalance(Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } <FILL_ME> try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); GetAccountBalanceRequest getAccountBalanceRequest= new GetAccountBalanceRequest(); GetAccountBalanceResult getAccountBalanceResult = mTurk.getAccountBalance(getAccountBalanceRequest); String availableBalance = getAccountBalanceResult.getAvailableBalance(); String onHoldBalance = getAccountBalanceResult.getOnHoldBalance(); ObjectNode returnJson = Json.newObject(); returnJson.put(""availableBalance"", availableBalance); returnJson.put(""onHoldBalance"", onHoldBalance); return ok(returnJson); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } }  private static class JsonWorker { public String workerId; public List<ObjectNode> assignments = new ArrayList<>(); public int nCompleted = 0;  JsonWorker(String id) { workerId = id; }  public ObjectNode toJson() { ObjectNode worker = Json.newObject(); worker.put(""id"", workerId); worker.put(""nAssignments"", assignments.size()); worker.put(""assignmentsCompleted"", nCompleted); ArrayNode jsonAssignments = worker.putArray(""assignments""); jsonAssignments.addAll(assignments); return worker; } }  @Security.Authenticated(Secured.class)
  public static Result addQualificationType(String experimentUid, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); }  Experiment experiment = Experiment.findByUid(experimentUid);  if (experiment == null) { return badRequest(""Invalid experiment UID.""); }  try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build();  String qualificationName = PARTICIPANT_QUALIFICATION_PREFIX + experimentUid; String reason = ""You previously participated in this experiment.""; // Create a new qualification type CreateQualificationTypeRequest createQualificationTypeRequest = new CreateQualificationTypeRequest()
          .withName(qualificationName)
          .withDescription(reason)
          .withQualificationTypeStatus(QualificationTypeStatus.Active); CreateQualificationTypeResult createQualificationTypeResult = mTurk.createQualificationType(createQualificationTypeRequest); QualificationType qualificationType = createQualificationTypeResult.getQualificationType();  ObjectNode qualificationTypeJson = Json.newObject();  TimeZone tz = TimeZone.getTimeZone(""UTC""); DateFormat df = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm'Z'""); df.setTimeZone(tz);  qualificationTypeJson.put(""experimentUid"", experimentUid); qualificationTypeJson.put(""experimentName"", experiment.name); qualificationTypeJson.put(""creationTime"", df.format(qualificationType.getCreationTime())); qualificationTypeJson.put(""description"", qualificationType.getDescription()); qualificationTypeJson.put(""isRequestable"", qualificationType.getIsRequestable()); qualificationTypeJson.put(""keywords"", qualificationType.getKeywords()); qualificationTypeJson.put(""name"", qualificationType.getName()); qualificationTypeJson.put(""qualificationTypeId"", qualificationType.getQualificationTypeId()); qualificationTypeJson.put(""qualificationTypeStatus"", qualificationType.getQualificationTypeStatus()); qualificationTypeJson.put(""autoGranted"", qualificationType.getAutoGranted());  return ok(qualificationTypeJson); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } }  public static QualificationType getQualificationTypeByName(String qualificationName, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return null; }  try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build();  ListQualificationTypesRequest listQualificationTypesRequest = new ListQualificationTypesRequest()
          .withMaxResults(1)
          .withMustBeOwnedByCaller(false)
          .withMustBeRequestable(false)
          .withQuery(qualificationName);  ListQualificationTypesResult listQualificationTypesResult = mTurk.listQualificationTypes(listQualificationTypesRequest); List<QualificationType> qualificationTypes = listQualificationTypesResult.getQualificationTypes();  if (qualificationTypes.isEmpty()) { return null; }  return qualificationTypes.get(0); } catch (AmazonServiceException ase) { return null; } catch (AmazonClientException ace) { return null; } }  @Security.Authenticated(Secured.class)
  public static Result listQualificationTypes(Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); }  try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build();  List<ExperimentQualificationType> experimentQualificationTypes = new ArrayList<ExperimentQualificationType>();  for (Experiment experiment: Experiment.findAll()) { ListQualificationTypesRequest listQualificationTypesRequest = new ListQualificationTypesRequest()
            .withMaxResults(1)
            .withMustBeOwnedByCaller(true)
            .withMustBeRequestable(false)
            .withQuery(PARTICIPANT_QUALIFICATION_PREFIX + experiment.uid);  ListQualificationTypesResult listQualificationTypesResult = mTurk.listQualificationTypes(listQualificationTypesRequest); List<QualificationType> qualificationType = listQualificationTypesResult.getQualificationTypes(); ExperimentQualificationType experimentQualificationType = new ExperimentQualificationType();  if (!qualificationType.isEmpty()) { experimentQualificationType.qualificationType = qualificationType.get(0); } experimentQualificationType.experiment = experiment;  experimentQualificationTypes.add(experimentQualificationType); }  ObjectNode returnJson = Json.newObject(); ArrayNode qualificationTypesJson = returnJson.putArray(""qualificationTypes"");  TimeZone tz = TimeZone.getTimeZone(""UTC""); DateFormat df = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm'Z'""); df.setTimeZone(tz);  for (ExperimentQualificationType experimentQualificationType : experimentQualificationTypes) { QualificationType qualificationType = experimentQualificationType.qualificationType; Experiment experiment = experimentQualificationType.experiment;  ObjectNode qualificationTypeJson = Json.newObject();  qualificationTypeJson.put(""label"", experiment.name + "" participant""); qualificationTypeJson.put(""experimentUid"", experiment.uid); qualificationTypeJson.put(""experimentName"", experiment.name); qualificationTypeJson.put(""creationTime"", (qualificationType == null) ? null : df.format(qualificationType.getCreationTime())); qualificationTypeJson.put(""description"", (qualificationType == null) ? null : qualificationType.getDescription()); qualificationTypeJson.put(""isRequestable"", (qualificationType == null) ? null : qualificationType.getIsRequestable()); qualificationTypeJson.put(""keywords"", (qualificationType == null) ? null : qualificationType.getKeywords()); qualificationTypeJson.put(""name"", (qualificationType == null) ? null : qualificationType.getName()); qualificationTypeJson.put(""qualificationTypeId"", (qualificationType == null) ? null : qualificationType.getQualificationTypeId()); qualificationTypeJson.put(""qualificationTypeStatus"", (qualificationType == null) ? null : qualificationType.getQualificationTypeStatus()); qualificationTypeJson.put(""autoGranted"", (qualificationType == null) ? null : qualificationType.getAutoGranted()); qualificationTypesJson.add(qualificationTypeJson); } returnJson.put(""rows"", experimentQualificationTypes.size());  return ok(returnJson); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } }  @Security.Authenticated(Secured.class)
  public static Result getExperimentQualificationTypeId(String experimentUid, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); }  QualificationType qualificationType = getQualificationTypeByName(PARTICIPANT_QUALIFICATION_PREFIX + experimentUid, sandbox); if (qualificationType == null) { try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build();  String qualificationName = PARTICIPANT_QUALIFICATION_PREFIX + experimentUid; String reason = ""You previously participated in this experiment.""; // Create a new qualification type CreateQualificationTypeRequest createQualificationTypeRequest = new CreateQualificationTypeRequest()
            .withName(qualificationName)
            .withDescription(reason)
            .withQualificationTypeStatus(QualificationTypeStatus.Active); CreateQualificationTypeResult createQualificationTypeResult = mTurk.createQualificationType(createQualificationTypeRequest); qualificationType = createQualificationTypeResult.getQualificationType(); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } }  ObjectNode returnJson = Json.newObject(); returnJson.put(""qualificationTypeId"", qualificationType.getQualificationTypeId()); return ok(returnJson); }  @Security.Authenticated(Secured.class)
  public static Result assignParticipantQualification(Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String workerId = null; String qualificationTypeId = null; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { workerId = json.findPath(""workerId"").textValue(); qualificationTypeId = json.findPath(""qualificationTypeId"").textValue(); }  if (workerId == null) { return badRequest(""Please provide an AMT worker ID.""); }  if (qualificationTypeId == null) { return badRequest(""Please provide a qualification type ID.""); }  try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build();  AssociateQualificationWithWorkerRequest associateQualificationWithWorkerRequest = new AssociateQualificationWithWorkerRequest()
          .withQualificationTypeId(qualificationTypeId)
          .withIntegerValue(1)
          .withSendNotification(false)
          .withWorkerId(workerId);  mTurk.associateQualificationWithWorker(associateQualificationWithWorkerRequest); return ok(); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } }  @Security.Authenticated(Secured.class)
  public static Result removeParticipantQualification(Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String workerId = null; String qualificationTypeId = null; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { workerId = json.findPath(""workerId"").textValue(); qualificationTypeId = json.findPath(""qualificationTypeId"").textValue(); }  if (workerId == null) { return badRequest(""Please provide an AMT worker ID.""); }  if (qualificationTypeId == null) { return badRequest(""Please provide a qualification type ID.""); }  try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build();  DisassociateQualificationFromWorkerRequest disassociateQualificationFromWorkerRequest = new DisassociateQualificationFromWorkerRequest()
          .withQualificationTypeId(qualificationTypeId)
          .withWorkerId(workerId);  mTurk.disassociateQualificationFromWorker(disassociateQualificationFromWorkerRequest); return ok(); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } }  @Security.Authenticated(Secured.class)
  public static Result getQualificationScore(Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String workerId = null; String qualificationTypeId = null; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { workerId = json.findPath(""workerId"").textValue(); qualificationTypeId = json.findPath(""qualificationTypeId"").textValue(); }  if (workerId == null) { return badRequest(""Please provide an AMT worker ID.""); }  if (qualificationTypeId == null) { return badRequest(""Please provide a qualification type ID.""); }  try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build();  GetQualificationScoreRequest getQualificationScoreRequest = new GetQualificationScoreRequest()
          .withQualificationTypeId(qualificationTypeId)
          .withWorkerId(workerId);  GetQualificationScoreResult qualificationScoreResult = mTurk.getQualificationScore(getQualificationScoreRequest); Qualification qualification = qualificationScoreResult.getQualification();  TimeZone tz = TimeZone.getTimeZone(""UTC""); DateFormat df = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm'Z'""); df.setTimeZone(tz);  ObjectNode returnJson = Json.newObject();  if (qualification == null) { returnJson.put(""status"", ""None""); } else { returnJson.put(""grantTime"", df.format(qualification.getGrantTime())); returnJson.put(""integerValue"", qualification.getIntegerValue()); if (qualification.getLocaleValue() != null) { returnJson.put(""localeValue"", qualification.getLocaleValue().toString()); } returnJson.put(""qualificationTypeId"", qualification.getQualificationTypeId()); returnJson.put(""status"", qualification.getStatus()); returnJson.put(""workerId"", qualification.getWorkerId()); } return ok(returnJson); } catch (AmazonServiceException ase) { ObjectNode returnJson = Json.newObject(); returnJson.put(""status"", ""None""); return ok(returnJson); //return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } }  @Security.Authenticated(Secured.class)
  public static Result importAMTWorkers(Long experimentId, Boolean sandbox) { Http.MultipartFormData body = request().body().asMultipartFormData(); Long maxUploadSize = play.Play.application().configuration().getLong(""maxUploadSize"", 50L * 1024L * 1024L);  // Validate Content-Length header try { Long fileSize = Long.parseLong(request().getHeader(""Content-Length""), 10); if (fileSize > maxUploadSize) { return badRequest(""Uploaded file is too large""); } } catch(Exception e){ return badRequest(""Upload was malformed""); }  // Validate the size of the file Http.MultipartFormData.FilePart filePart = body.getFile(""file""); File workerCsvFile = filePart.getFile();  Experiment experiment = Experiment.findById(experimentId);  // Validate the other data if(experiment == null){ return badRequest(""Invalid experiment ID""); }  if(workerCsvFile.length() > maxUploadSize){ return badRequest(""Uploaded file is too large""); }  try { Reader in = new FileReader(workerCsvFile); try { Date now = new Date(); String importTitle = ""IMPORTED_"" + experimentId + ""_"" + now.getTime(); // Add a fake Experiment Instance ExperimentInstance instance = new ExperimentInstance(importTitle, experiment); experiment.instances.add(instance); experiment.save();  // Add a fake AMTHit for the import AMTHit amtHit = new AMTHit(); amtHit.creationDate = now; amtHit.requestId = ""IMPORTED""; amtHit.isValid = ""true""; amtHit.hitId = ""IMPORTED_"" + experimentId + ""_"" + now.getTime(); amtHit.title = ""IMPORTED INTO "" + experiment.name + "" AT "" + now.getTime(); amtHit.description = ""This is a fake HIT created by breadboard when importing AMT Worker IDs to prevent repeat play.""; amtHit.lifetimeInSeconds = ""0""; amtHit.tutorialTime = ""0""; amtHit.maxAssignments = ""0""; amtHit.externalURL = ""IMPORTED""; amtHit.reward = ""0""; amtHit.disallowPrevious = ""none""; amtHit.sandbox = sandbox; amtHit.setExtended(false); amtHit.experimentInstance = instance; amtHit.save();  int assignmentIndex = 0; CSVFormat format = CSVFormat.DEFAULT; for (CSVRecord record : format.parse(in)) { String workerId = record.get(0); <FILL_ME> AMTWorker amtWorker = AMTWorker.findByWorkerId(workerId); if (amtWorker == null) { amtWorker = new AMTWorker(); amtWorker.workerId = workerId; amtWorker.score = """"; amtWorker.completion = """"; amtWorker.amtHit = amtHit; amtWorker.save(); }  // Add an assignment for the current experiment and mark it as completed AMTAssignment amtAssignment = new AMTAssignment(); amtAssignment.assignmentId = ""IMPORTED_"" + experimentId + ""_"" + now.getTime() + ""_"" + (++assignmentIndex); amtAssignment.workerId = workerId; amtAssignment.assignmentCompleted = true; amtAssignment.assignmentStatus = ""IMPORTED""; amtAssignment.autoApprovalTime = ""IMPORTED""; amtAssignment.acceptTime = null; amtAssignment.submitTime = null; amtAssignment.answer = """"; amtAssignment.score = """"; amtAssignment.reason = ""IMPORTED""; amtAssignment.completion = """"; amtAssignment.bonusAmount = """"; amtAssignment.bonusGranted = false; amtAssignment.workerBlocked = false; amtAssignment.qualificationAssigned = false; amtAssignment.amtHit = amtHit; amtAssignment.save(); } } finally { in.close(); } } catch (IOException ioe) { return badRequest(""Error reading uploaded file""); }  return ok(); }  @Security.Authenticated(Secured.class)
  public static Result disassociateQualificationFromWorker(String qualificationTypeId, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); }  String workerId; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { workerId = json.findPath(""workerId"").textValue(); }  if (workerId == null) { return badRequest(""Please provide an AMT worker ID.""); }  try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); DisassociateQualificationFromWorkerRequest disassociateQualificationFromWorkerRequest = new DisassociateQualificationFromWorkerRequest()
          .withQualificationTypeId(qualificationTypeId)
          .withWorkerId(workerId)
          .withReason(""Allowing re-participation in this experiment type."");  mTurk.disassociateQualificationFromWorker(disassociateQualificationFromWorkerRequest);  return ok(); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } }  @Security.Authenticated(Secured.class)
  public static Result listWorkersWithQualificationType(String qualificationTypeId, Integer maxResults, String nextToken, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); ListWorkersWithQualificationTypeRequest listWorkersWithQualificationTypeRequest = new ListWorkersWithQualificationTypeRequest()
          .withQualificationTypeId(qualificationTypeId)
          .withMaxResults((maxResults == null) ? 20 : maxResults)
          .withStatus(QualificationStatus.Granted);  if (nextToken != null) listWorkersWithQualificationTypeRequest.setNextToken(nextToken); ListWorkersWithQualificationTypeResult listWorkersWithQualificationTypeResult = mTurk.listWorkersWithQualificationType(listWorkersWithQualificationTypeRequest); List<Qualification> qualifications = listWorkersWithQualificationTypeResult.getQualifications();  ObjectNode returnJson = Json.newObject(); ArrayNode qualificationsJson = returnJson.putArray(""qualifications""); TimeZone tz = TimeZone.getTimeZone(""UTC""); DateFormat df = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm'Z'""); df.setTimeZone(tz);  for (Qualification qualification : qualifications) { ObjectNode qualificationJson = Json.newObject(); qualificationJson.put(""qualificationTypeId"", qualification.getQualificationTypeId()); qualificationJson.put(""grantTime"", df.format(qualification.getGrantTime())); qualificationJson.put(""integerValue"", qualification.getIntegerValue()); qualificationJson.put(""status"", qualification.getStatus()); qualificationJson.put(""workerId"", qualification.getWorkerId()); qualificationsJson.add(qualificationJson); } returnJson.put(""rows"", listWorkersWithQualificationTypeResult.getNumResults()); returnJson.put(""nextToken"", listWorkersWithQualificationTypeResult.getNextToken());  return ok(returnJson); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } }  @Security.Authenticated(Secured.class)
  public static Result getAMTWorkers(Long experimentId, Boolean sandbox, Integer limit, Integer offset, String search) { HashMap<String, JsonWorker> amtWorkerAssignments = new HashMap<>(); ObjectNode returnJson = Json.newObject();  /*
    Experiment experiment = Experiment.findById(experimentId);

    if (experiment == null) {
      return badRequest(""Invalid experiment ID"");
    }
    */ // TODO: There is a bug in the interaction between distinct and limit in H2 1.3.172, // Need to upgrade to latest version of H2 to return exactly limit workers // should be fixed in a commit here: // https://github.com/h2database/h2database/pull/578/files //""(select distinct worker_id from amt_assignments "" +  // Return all workers with their assignments and names and UIDs of experiments  String workerCountSql = ""select count(distinct worker_id) as worker_count from amt_assignments "" +
        "" where worker_id like CONCAT(:search, '%')"" +
        "" and worker_id in "" +
        ""(select worker_id from amt_assignments "" +
        "" where amt_hit_id in "" +
        ""(select id from amt_hits where sandbox = :sandbox)); "";  SqlRow sqlRow = Ebean.createSqlQuery(workerCountSql)
        .setParameter(""search"", search)
        .setParameter(""sandbox"", (sandbox) ? 1 : 0)
        .findUnique(); Long workerCount = sqlRow.getLong(""worker_count"");  String workerIdSql = ""select distinct worker_id from amt_assignments "" +
        "" where worker_id like CONCAT(:search, '%')"" +
        "" and worker_id in "" +
        ""(select worker_id from amt_assignments "" +
        "" where amt_hit_id in "" +
        ""(select id from amt_hits where sandbox = :sandbox))"" +
        "" order by worker_id limit :limit offset :offset"";  //"" where worker_id like ':search%'"" + /*
    String sql = ""select * from amt_assignments "" +
        ""where worker_id in "" +
        ""(select worker_id from amt_assignments "" +
        "" where worker_id like CONCAT(:search, '%')"" +
        "" and amt_hit_id in "" +
        ""(select id from amt_hits where sandbox = :sandbox and experiment_instance_id in "" +
        ""(select id from experiment_instances where experiment_id = :experimentId)) "" +
        ""order by worker_id limit :limit offset :offset) order by worker_id;"";
       */  SqlQuery sqlQuery = Ebean.createSqlQuery(workerIdSql)
        .setParameter(""limit"", limit)
        .setParameter(""offset"", offset)
        .setParameter(""search"", search)
        .setParameter(""sandbox"", (sandbox) ? 1 : 0);  //Logger.debug(sqlQuery.toString());  List<SqlRow> workerIds = sqlQuery.findList();  returnJson.put(""total"", workerCount); returnJson.put(""offset"", offset); returnJson.put(""limit"", limit);  // This is necessary because of the bug regarding distinct + limit int endI = Math.min(limit, workerIds.size()); for (int i = 0; i < endI; i++) { SqlRow row = workerIds.get(i); String workerId = row.getString(""worker_id""); List<AMTAssignment> assignments = AMTAssignment.find
          .where()
          .eq(""worker_id"", workerId)
          .findList();  if (! amtWorkerAssignments.containsKey(workerId)) { amtWorkerAssignments.put(workerId, new JsonWorker(workerId)); }  JsonWorker jsonWorker = amtWorkerAssignments.get(workerId); for (AMTAssignment assignment : assignments) { AMTHit hit = assignment.amtHit; ExperimentInstance instance = hit.experimentInstance; Experiment experiment = (instance == null) ? null : instance.experiment;  String experimentName = (experiment == null) ? """" : experiment.name; Long eId = (experiment == null) ? -1L : experiment.id; String eUid = (experiment == null) ? """" : experiment.uid;  Boolean assignmentCompleted = assignment.assignmentCompleted; ; if (assignmentCompleted != null && assignmentCompleted) jsonWorker.nCompleted++;  ObjectNode amtAssignment = Json.newObject();  amtAssignment.put(""id"", assignment.id); amtAssignment.put(""assignmentId"", assignment.assignmentId); amtAssignment.put(""workerId"", workerId); amtAssignment.put(""assignmentStatus"", assignment.assignmentStatus); amtAssignment.put(""autoApprovalTime"", assignment.autoApprovalTime); amtAssignment.put(""acceptTime"", assignment.acceptTime); amtAssignment.put(""submitTime"", assignment.submitTime); amtAssignment.put(""answer"", assignment.answer); amtAssignment.put(""score"", assignment.score); amtAssignment.put(""reason"", assignment.reason); amtAssignment.put(""completion"", assignment.completion); amtAssignment.put(""assignmentCompleted"", assignmentCompleted); amtAssignment.put(""bonusGranted"", assignment.bonusGranted); amtAssignment.put(""bonusAmount"", assignment.bonusAmount); amtAssignment.put(""workerBlocked"", assignment.workerBlocked); amtAssignment.put(""qualificationAssigned"", assignment.qualificationAssigned); amtAssignment.put(""experimentName"", experimentName); amtAssignment.put(""experimentUid"", eUid); amtAssignment.put(""experimentId"", eId);  jsonWorker.assignments.add(amtAssignment); }  }  ArrayNode amtWorkersJson = returnJson.putArray(""amtWorkers"");  for (JsonWorker jsonWorker : amtWorkerAssignments.values()) { amtWorkersJson.add(jsonWorker.toJson()); } returnJson.put(""rows"", amtWorkerAssignments.size());  /*
    for (Map.Entry<String, List<ObjectNode>> entry : amtWorkerAssignments.entrySet()) {
      ObjectNode worker = Json.newObject();
      int nCompleted = 0;
      worker.put(""id"", entry.getKey());
      worker.put(""nAssignments"", entry.getValue().size());
      ArrayNode workerAssignments = worker.putArray(""assignments"");
      for (AMTAssignment assignment : entry.getValue()) {
        if (assignment != null) {
          if (assignment.assignmentCompleted != null && assignment.assignmentCompleted) nCompleted++;
          workerAssignments.add(assignment.toJson());
        }
      }
      worker.put(""assignmentsCompleted"", nCompleted);
      amtWorkersJson.add(worker);
    }
    */  return ok(returnJson); }  @Security.Authenticated(Secured.class)
  public static Result listHITs(String nextToken, Integer maxResults, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); ListHITsRequest listHITsRequest = new ListHITsRequest().withMaxResults((maxResults == null) ? 20 : maxResults); if (nextToken != null) listHITsRequest.setNextToken(nextToken); ListHITsResult hitResults = mTurk.listHITs(listHITsRequest); List<HIT> hits = hitResults.getHITs();  // Update amt_hits table for (HIT hit : hits) { AMTHit amtHit = AMTHit.findByHitId(hit.getHITId()); if (amtHit == null) { amtHit = new AMTHit(); } amtHit.hitId = hit.getHITId(); amtHit.creationDate = hit.getCreationTime(); amtHit.title = hit.getTitle(); amtHit.description = hit.getDescription(); amtHit.maxAssignments = hit.getMaxAssignments().toString(); amtHit.reward = hit.getReward(); amtHit.sandbox = sandbox; amtHit.save(); }  String next = hitResults.getNextToken(); ObjectNode returnJson = Json.newObject(); returnJson.put(""hits"", Json.toJson(hits)); returnJson.put(""nextToken"", next); return ok(returnJson); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } }  @Security.Authenticated(Secured.class)
  public static Result listAssignmentsForHIT(String hitId, Integer maxResults, String nextToken, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); ListAssignmentsForHITRequest listAssignmentsForHITRequest = new ListAssignmentsForHITRequest().withMaxResults(maxResults).withHITId(hitId); ObjectNode returnJson = Json.newObject(); ArrayNode jsonAssignments = returnJson.putArray(""assignments""); if (nextToken != null) listAssignmentsForHITRequest.setNextToken(nextToken); ListAssignmentsForHITResult assignmentResults = mTurk.listAssignmentsForHIT(listAssignmentsForHITRequest); List<Assignment> assignments = assignmentResults.getAssignments();  TimeZone tz = TimeZone.getTimeZone(""UTC""); DateFormat df = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm'Z'""); df.setTimeZone(tz);  // Update amt_assignments table for (Assignment assignment : assignments) { AMTHit hit = AMTHit.findByHitId(assignment.getHITId()); AMTAssignment amtAssignment = hit.getAMTAssignmentById(assignment.getAssignmentId()); boolean update = true; if (amtAssignment == null) { amtAssignment = new AMTAssignment(); // Default to incomplete, require checking completed box to prevent repeat play amtAssignment.assignmentCompleted = false; update = false; } amtAssignment.amtHit = hit; amtAssignment.assignmentId = assignment.getAssignmentId(); amtAssignment.workerId = assignment.getWorkerId(); amtAssignment.assignmentStatus = assignment.getAssignmentStatus(); amtAssignment.autoApprovalTime = assignment.getAutoApprovalTime().toString(); amtAssignment.acceptTime = (assignment.getAcceptTime() == null) ? null :  df.format(assignment.getAcceptTime()); amtAssignment.submitTime = (assignment.getSubmitTime() == null) ? null :  df.format(assignment.getSubmitTime()); amtAssignment.answer = assignment.getAnswer();  if (!update) { hit.amtAssignments.add(amtAssignment); } hit.save();  ObjectNode jsonAssignment = Json.newObject(); jsonAssignment.put(""assignmentId"", amtAssignment.assignmentId); jsonAssignment.put(""workerId"", amtAssignment.workerId); jsonAssignment.put(""approvalTime"", (assignment.getApprovalTime() == null) ? null : df.format(assignment.getApprovalTime())); jsonAssignment.put(""rejectionTime"", (assignment.getRejectionTime() == null) ? null : df.format(assignment.getRejectionTime())); jsonAssignment.put(""answer"", amtAssignment.answer); jsonAssignment.put(""assignmentCompleted"", amtAssignment.assignmentCompleted);  jsonAssignments.add(jsonAssignment); }  String token = assignmentResults.getNextToken(); returnJson.put(""nextToken"", token); return ok(returnJson); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } }  @Security.Authenticated(Secured.class)
  public static Result listBonusPaymentsForHIT(String hitId, Integer maxResults, String nextToken, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); ListBonusPaymentsRequest listBonusPaymentsRequest = new ListBonusPaymentsRequest().withMaxResults(maxResults).withHITId(hitId); if (nextToken != null) listBonusPaymentsRequest.setNextToken(nextToken); ListBonusPaymentsResult bonusPaymentsResults = mTurk.listBonusPayments(listBonusPaymentsRequest); List<BonusPayment> bonusPayments = bonusPaymentsResults.getBonusPayments(); // Update amt_assignments table for (BonusPayment bonusPayment : bonusPayments) { AMTAssignment amtAssignment = AMTAssignment.findByAssignmentId(bonusPayment.getAssignmentId()); if (amtAssignment != null) { amtAssignment.bonusGranted = true; amtAssignment.bonusAmount = bonusPayment.getBonusAmount(); amtAssignment.save(); } } String token = bonusPaymentsResults.getNextToken(); ObjectNode returnJson = Json.newObject(); returnJson.put(""bonusPayments"", Json.toJson(bonusPayments)); returnJson.put(""nextToken"", token); return ok(returnJson); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } }  @Security.Authenticated(Secured.class)
  public static Result approveAssignment(String assignmentId, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); ApproveAssignmentRequest approveAssignmentRequest= new ApproveAssignmentRequest().withAssignmentId(assignmentId); mTurk.approveAssignment(approveAssignmentRequest); return ok(); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } }  @Security.Authenticated(Secured.class)
  public static Result rejectAssignment(String assignmentId, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String requesterFeedback = null; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { requesterFeedback = json.findPath(""requesterFeedback"").textValue(); }  if (requesterFeedback == null) { return badRequest(""Please provide requester feedback.""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); RejectAssignmentRequest rejectAssignmentRequest= new RejectAssignmentRequest()
          .withAssignmentId(assignmentId)
          .withRequesterFeedback(requesterFeedback); mTurk.rejectAssignment(rejectAssignmentRequest); return ok(); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } }  @Security.Authenticated(Secured.class)
  public static Result sendBonus(String assignmentId, Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String bonusAmount = null; String reason = null; String workerId = null; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { bonusAmount = json.findPath(""bonusAmount"").textValue(); reason = json.findPath(""reason"").textValue(); workerId = json.findPath(""workerId"").textValue(); }  if (bonusAmount == null || reason == null || workerId == null) { return badRequest(""Please provide workerId, bonusAmount, and reason.""); } try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); SendBonusRequest sendBonusRequest= new SendBonusRequest().withAssignmentId(assignmentId).withBonusAmount(bonusAmount).withReason(reason).withWorkerId(workerId); mTurk.sendBonus(sendBonusRequest); return ok(); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } }  @Security.Authenticated(Secured.class)
  public static Result updateAssignmentCompleted(String assignmentId) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String completedText;  JsonNode json = request().body().asJson();  if(json == null) { return badRequest(""Expecting Json data""); } else { completedText = json.findPath(""completed"").asText(); }  if (completedText == null || (!(completedText.matches(""(?i)0|1|true|false"")))) { return badRequest(""Please provide completed as a boolean value (0, 1, true, false).""); }  AMTAssignment amtAssignment = AMTAssignment.findByAssignmentId(assignmentId);  if (amtAssignment == null) { return badRequest(""Invalid Assignment ID.""); }  Boolean completed = (completedText.matches(""(?i)1|true""));  amtAssignment.assignmentCompleted = completed; amtAssignment.save();  return ok(); }  @Security.Authenticated(Secured.class)
  public static Result createHIT(Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String title; String description; String reward; Integer maxAssignments; Long hitLifetime; Long tutorialTime; Long assignmentDuration; String keywords; String disallowPrevious; String experimentId; String experimentInstanceId; BBQualificationRequirement[] qualificationRequirements = null;  JsonNode json = request().body().asJson(); if (json == null) { return badRequest(""Expecting Json data""); } else { title = json.findPath(""title"").textValue(); description = json.findPath(""description"").textValue(); reward = json.findPath(""reward"").textValue(); maxAssignments = json.findPath(""maxAssignments"").asInt(-1); hitLifetime = json.findPath(""hitLifetime"").asLong(-1L); tutorialTime = json.findPath(""tutorialTime"").asLong(-1L); assignmentDuration = json.findPath(""assignmentDuration"").asLong(-1L); keywords = json.findPath(""keywords"").textValue(); disallowPrevious = json.findPath(""disallowPrevious"").textValue(); experimentId = json.findPath(""experimentId"").textValue(); experimentInstanceId = json.findPath(""experimentInstanceId"").textValue(); <FILL_ME> try { qualificationRequirements = new ObjectMapper().readValue(json.findPath(""qualificationRequirements"").toString(), BBQualificationRequirement[].class); } catch(IOException ioe) { } } 
 if (title == null || description == null || reward == null || maxAssignments < 0 || hitLifetime < 0 || tutorialTime < 0 || assignmentDuration < 0 || keywords == null || disallowPrevious == null || experimentId == null || experimentInstanceId == null) { return badRequest(""Please provide experiment ID, experiment instance ID, title, description, reward, max assignments, hit lifetime, tutorial time, assignment duration, keywords, and allow repeat play option.""); }  String rootURL = play.Play.application().configuration().getString(""breadboard.rootUrl""); String gameURL = String.format(""/game/%1$s/%2$s/amt"", experimentId, experimentInstanceId); String externalURL = rootURL + gameURL; Integer frameHeight = play.Play.application().configuration().getInt(""breadboard.amtFrameHeight""); 
 ""  <ExternalURL>"" + externalURL + ""</ExternalURL>\n"" +
        ""  <FrameHeight>"" + frameHeight + ""</FrameHeight>\n"" +
        ""</ExternalQuestion>"";  try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build(); //mechanicalturk.amazonaws.com/AWSMechanicalTurkDataSchemas/2006-07-14/ExternalQuestion.xsd\"">\n"" + Experiment experiment = Experiment.findById(Long.parseLong(experimentId)); String experimentName = experiment.name; if (experimentName.length() > 120) experimentName = experimentName.substring(0, 120) + ""...""; String annotation = ""{ \""experimentType\"":\""breadboard\"",\""experimentUid\"":\"""" + experiment.uid + ""\"",\""experimentName\"":\"""" + experimentName + ""\""} "";   CreateHITRequest createHITRequest = new CreateHITRequest()
          .withQuestion(question)
          .withTitle(title)
          .withDescription(description)
          .withMaxAssignments(maxAssignments)
          .withLifetimeInSeconds(hitLifetime)
          .withAssignmentDurationInSeconds(assignmentDuration)
          .withKeywords(keywords)
          .withReward(reward)
          .withRequesterAnnotation(annotation);  if (qualificationRequirements != null) { <FILL_ME> } // Create HIT List<QualificationRequirement> qualificationRequirementList = new ArrayList<>(); for (BBQualificationRequirement bbQualificationRequirement : qualificationRequirements) { List<Locale> locales = new ArrayList<>(); for (BBLocale bbLocale : bbQualificationRequirement.locales) { Locale locale = new Locale()
              .withCountry(bbLocale.country.trim()); if (!bbLocale.subdivision.trim().isEmpty()) { locale.setSubdivision(bbLocale.subdivision.trim()); } locales.add(locale); } List<Integer> integerValues = new ArrayList<>(); for (String integerString : bbQualificationRequirement.integerValues.split("","")) { try { Integer integerValue = Integer.parseInt(integerString.trim()); integerValues.add(integerValue); } catch (NumberFormatException nfe) { } }  String qualificationTypeId = bbQualificationRequirement.selectedQualificationType.qualificationTypeId;  if (qualificationTypeId.equals(""OTHER_EXPERIMENT"")) { String experimentUid = bbQualificationRequirement.otherExperiment; String qualificationName = PARTICIPANT_QUALIFICATION_PREFIX + experimentUid; QualificationType qualificationType = getQualificationTypeByName(qualificationName, sandbox); if (qualificationType != null) { qualificationTypeId = qualificationType.getQualificationTypeId(); } }  QualificationRequirement qualificationRequirement = new QualificationRequirement()
            .withActionsGuarded(bbQualificationRequirement.actionsGuarded)
            .withComparator(bbQualificationRequirement.comparator)
            .withQualificationTypeId(qualificationTypeId);  if (!locales.isEmpty()) { qualificationRequirement.setLocaleValues(locales); }  if (!integerValues.isEmpty()) { qualificationRequirement.setIntegerValues(integerValues); }  qualificationRequirementList.add(qualificationRequirement); }  if (!qualificationRequirementList.isEmpty()) { createHITRequest.setQualificationRequirements(qualificationRequirementList); }   CreateHITResult createHITResult = mTurk.createHIT(createHITRequest); HIT hit = createHITResult.getHIT(); AMTHit amtHit = new AMTHit(); amtHit.hitId = hit.getHITId(); amtHit.description = hit.getDescription(); amtHit.lifetimeInSeconds = hitLifetime.toString(); amtHit.tutorialTime = tutorialTime.toString(); amtHit.maxAssignments = hit.getMaxAssignments().toString(); amtHit.externalURL = externalURL; amtHit.reward = hit.getReward(); amtHit.title = hit.getTitle(); amtHit.disallowPrevious = disallowPrevious; amtHit.sandbox = sandbox;  ExperimentInstance experimentInstance = ExperimentInstance.findById(Long.parseLong(experimentInstanceId)); experimentInstance.amtHits.add(amtHit); experimentInstance.save();  return ok(amtHit.toJson()); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } }  @Security.Authenticated(Secured.class)
  public static Result createDummyHit(Boolean sandbox) { if (SECRET_KEY == null || ACCESS_KEY == null) { return badRequest(""No AWS keys provided""); } String workerId = null; String reason = null; String reward = null; String paymentHitHtml = getDummyHitHTML(); if (paymentHitHtml == null) { return badRequest(""Unable to read 'payment-hit.html' or 'default-payment-hit.html' file in conf/defaults directory.""); } JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { workerId = json.findPath(""workerId"").textValue(); reason = json.findPath(""reason"").textValue(); reward = json.findPath(""reward"").textValue(); }  if (workerId == null || reason == null || reward == null) { return badRequest(""Please provide workerId, reason, and reward.""); }  try { AWSStaticCredentialsProvider awsCredentials = new AWSStaticCredentialsProvider(new BasicAWSCredentials(ACCESS_KEY, SECRET_KEY)); AmazonMTurkClientBuilder builder = AmazonMTurkClientBuilder.standard().withCredentials(awsCredentials); builder.setEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration((sandbox ? SANDBOX_ENDPOINT : PRODUCTION_ENDPOINT), SIGNING_REGION)); AmazonMTurk mTurk = builder.build();   String qualificationName = new Date().getTime() + ""_"" + workerId; CreateQualificationTypeRequest createQualificationTypeRequest = new CreateQualificationTypeRequest()
          .withName(qualificationName)
          .withDescription(reason)
          .withQualificationTypeStatus(QualificationTypeStatus.Active); CreateQualificationTypeResult createQualificationTypeResult = mTurk.createQualificationType(createQualificationTypeRequest);  AssociateQualificationWithWorkerRequest associateQualificationWithWorkerRequest = new AssociateQualificationWithWorkerRequest()
          .withQualificationTypeId(createQualificationTypeResult.getQualificationType().getQualificationTypeId())
          .withIntegerValue(1)
          .withWorkerId(workerId); // Create a qualification for the worker mTurk.associateQualificationWithWorker(associateQualificationWithWorkerRequest);  QualificationRequirement qualificationRequirement = new QualificationRequirement()
          .withQualificationTypeId(createQualificationTypeResult.getQualificationType().getQualificationTypeId())
          .withRequiredToPreview(true)
          .withComparator(""EqualTo"")
          .withIntegerValues(1);   CreateHITRequest createHITRequest = new CreateHITRequest()
          .withTitle(""HIT for "" + workerId)
          .withDescription(reason)
          .withMaxAssignments(1)
          .withQuestion(paymentHitHtml)
          .withQualificationRequirements(qualificationRequirement)
          .withLifetimeInSeconds(31536000L)
          .withAssignmentDurationInSeconds(5400L)
          .withKeywords(workerId)
          .withReward(reward);  mTurk.createHIT(createHITRequest); // Create Dummy/Payment HIT return ok(); } catch (AmazonServiceException ase) { return badRequest(ase.getMessage()); } catch (AmazonClientException ace) { return internalServerError(ace.getMessage()); } }  private static String getDummyHitHTML() { String returnString = null; InputStream paymentHitHtml = Play.application().resourceAsStream(""defaults/payment-hit.html""); if (paymentHitHtml == null) paymentHitHtml = Play.application().resourceAsStream(""defaults/default-payment-hit.html""); if (paymentHitHtml == null) return null; try {  ""  <HTMLContent><![CDATA["" +
                     IOUtils.toString(paymentHitHtml) +
                     ""]]>\n"" +
                     ""  </HTMLContent>\n"" +
                     ""  <FrameHeight>600</FrameHeight>\n"" +
                     ""</HTMLQuestion>""; } catch (IOException ioe) { } return returnString; }  private static class ExperimentQualificationType { public QualificationType qualificationType; public Experiment experiment; } //mechanicalturk.amazonaws.com/AWSMechanicalTurkDataSchemas/2011-11-11/HTMLQuestion.xsd\"">\n"" + private static class BBQualificationRequirement { public String actionsGuarded; public String comparator; public String integerValues; public List<BBLocale> locales; public String otherExperiment; public BBQualificationType selectedQualificationType; }  private static class BBQualificationType { public String label; public String qualificationTypeId; public String experimentUid; public String experimentName; public String creationTime; public String description; public Boolean isRequestable; public Boolean autoGranted; public String keywords; public String name; public String qualificationTypeStatus; }  private static class BBLocale { public String country; public String subdivision; } }  "
app/controllers/AMTAssignmentController.java,"package controllers;

import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import models.*;
import play.libs.Json;
import play.mvc.Controller;
import play.mvc.Result;
import play.mvc.Security;

public class AMTAssignmentController extends Controller {

  @Security.Authenticated(Secured.class)
  public static Result getAMTAssignments(Long experimentId, Boolean sandbox) {
    Experiment experiment = Experiment.findById(experimentId);

    if (experiment == null) {
      return badRequest(""Experiment not found"");
    }

    ObjectNode returnJson = Json.newObject();

    ArrayNode jsonAssignments = returnJson.putArray(""assignments"");

    for (ExperimentInstance instance : experiment.instances) {
      for (AMTHit hit : instance.amtHits) {
        if (hit.sandbox == sandbox) {
          for (AMTAssignment assignment : hit.amtAssignments) {
            jsonAssignments.add(assignment.toJson());
          }
        }
      }
    }
    return ok(returnJson);
  }
}
","package controllers; public class AMTAssignmentController extends Controller { @Security.Authenticated(Secured.class)
  public static Result getAMTAssignments(Long experimentId, Boolean sandbox) { Experiment experiment = Experiment.findById(experimentId); if (experiment == null) { return badRequest(""Experiment not found""); } ObjectNode returnJson = Json.newObject(); ArrayNode jsonAssignments = returnJson.putArray(""assignments""); for (ExperimentInstance instance : experiment.instances) { for (AMTHit hit : instance.amtHits) { if (hit.sandbox == sandbox) { for (AMTAssignment assignment : hit.amtAssignments) { jsonAssignments.add(assignment.toJson()); } } } } return ok(returnJson); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package controllers; public class AMTAssignmentController extends Controller { @Security.Authenticated(Secured.class)
  public static Result getAMTAssignments(Long experimentId, Boolean sandbox) { Experiment experiment = Experiment.findById(experimentId); if (experiment == null) { return badRequest(""Experiment not found""); } ObjectNode returnJson = Json.newObject(); ArrayNode jsonAssignments = returnJson.putArray(""assignments""); for (ExperimentInstance instance : experiment.instances) { for (AMTHit hit : instance.amtHits) { if (hit.sandbox == sandbox) { for (AMTAssignment assignment : hit.amtAssignments) { jsonAssignments.add(assignment.toJson()); } } } } return ok(returnJson); } } ","package controllers; 
import com.fasterxml.jackson.databind.node.ArrayNode; import com.fasterxml.jackson.databind.node.ObjectNode; import models.*; import play.libs.Json; import play.mvc.Controller; import play.mvc.Result; import play.mvc.Security;  public class AMTAssignmentController extends Controller {  @Security.Authenticated(Secured.class)
  public static Result getAMTAssignments(Long experimentId, Boolean sandbox) { Experiment experiment = Experiment.findById(experimentId);  if (experiment == null) { return badRequest(""Experiment not found""); }  ObjectNode returnJson = Json.newObject();  ArrayNode jsonAssignments = returnJson.putArray(""assignments"");  for (ExperimentInstance instance : experiment.instances) { for (AMTHit hit : instance.amtHits) { if (hit.sandbox == sandbox) { for (AMTAssignment assignment : hit.amtAssignments) { jsonAssignments.add(assignment.toJson()); } } } } return ok(returnJson); } }  "
app/controllers/Application.java,"package controllers;

import models.*;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.mindrot.jbcrypt.BCrypt;
import play.Logger;
import play.data.Form;
import play.libs.Json;
import play.mvc.*;
import views.html.*;
import java.io.*;
import java.text.SimpleDateFormat;
import java.util.*;

public class Application extends Controller {

  public static Result addFirstUser() {

    if (User.findRowCount() > 0) {
      return badRequest(""User table is not empty."");
    }

    String email, password;
    Long defaultLanguageId;
    JsonNode json = request().body().asJson();
    if(json == null) {
      return badRequest(""Expecting Json data"");
    } else {
      email = json.findPath(""email"").textValue();
      password = json.findPath(""password"").textValue();
      defaultLanguageId = json.findPath(""defaultLanguageId"").longValue();
    }

    Language defaultLanguage = Language.findById(defaultLanguageId);

    if (email == null || password == null || defaultLanguage == null) {
      return badRequest(""Please provide email, password, and default language."");
    }

    User user = new User();
    user.email = email;
    user.password = BCrypt.hashpw(password, BCrypt.gensalt());
    user.role = ""admin"";
    user.currentScript = """";
    user.defaultLanguage = defaultLanguage;
    user.experimentInstanceId = -1L;
    user.selectedExperiment = null;
    user.save();

    // TODO: Make method for creating demo experiments and associating with new user
    /*
    Experiment experiment = Experiment.findById(321l);
    if (experiment != null) {
      user.ownedExperiments.add(experiment);
      user.update();
      user.saveManyToManyAssociations(""ownedExperiments"");
    }
    */
    return ok();
  }


  public static Result authenticate() {
    Form<Login> loginForm = Form.form(Login.class).bindFromRequest();
    ObjectNode result = Json.newObject();
    if (loginForm.hasErrors()) {
      result.put(""message"", ""Invalid username or password"");
      result.put(""status"", ""error"");
      return badRequest(result);
    } else {
      String email = loginForm.get().email;

      session(""email"", email);

      String uid = UUID.randomUUID().toString();
      String juid = UUID.randomUUID().toString();
      session(""uid"", uid);
      session(""juid"", uid);

      User user = User.findByEmail(email);

      if (user != null) {
        Logger.debug(""authenticate: uid = "" + uid);
        user.uid = uid;
        user.update();
        result = Json.newObject();
        result.put(""uid"", uid);
        result.put(""email"", email);
        result.put(""juid"", juid);
        return ok(result);
      }

      return badRequest(login.render(loginForm));
    }
  }

  public static Result logout() {
    session().clear();
    return unauthorized();
  }

  public static Result index () {
      // final File file = play.Play.application().getFile(""assets/templates/breadboard.html"");
      String assetsRoot = play.Play.application().configuration().getString(""breadboard.assetsRoot"", ""/assets"");
      return ok(main.render(assetsRoot));
  }

  @Security.Authenticated(Secured.class)
  public static Result getState() {
    ObjectNode result = Json.newObject();
    result.put(""uid"", session(""uid"")); // remove this
    result.put(""juid"", session(""juid""));
    result.put(""email"", session(""email""));
    result.put(""connectSocket"", play.Play.application().configuration().getString(""breadboard.wsUrl""));
    return ok(result);
  }

  @Security.Authenticated(Secured.class)
  public static Result saveUserSettings() {
    Form<UserSettings> userSettingsForm = Form.form(UserSettings.class);
    userSettingsForm = userSettingsForm.bindFromRequest();

    ObjectNode result = Json.newObject();

    result.put(""success"", false);
    if (userSettingsForm.hasErrors()) {
      result.put(""error"", userSettingsForm.globalError().message());
      return ok(result);
    }

    UserSettings userSettings = userSettingsForm.get();

    userSettings.user.password = BCrypt.hashpw(userSettings.newPassword, BCrypt.gensalt());
    userSettings.user.update();
    result.put(""success"", true);

    return ok(result);
  }

  @Security.Authenticated(Secured.class)
  public static Result dataCsv(Long experimentId) {
    //TODO: Escape double quotes in ExperimentInstance parameters
    Experiment experiment = Experiment.findById(experimentId);
    final StringBuilder csv = new StringBuilder();
    Set<String> parameterNames = new TreeSet<>();
    for (ExperimentInstance instance : experiment.instances) {
      for (Data d : instance.data) {
        parameterNames.add(d.name);
      }
    }

    csv.append(""\""id\"",\""instance\"",\""status\"",\""created_at\"","");

    // Add all parameter names
    for (String parameterName : parameterNames) {
      csv.append(""\"""" + parameterName + ""\"","");
    }

    // Delete trailing comma
    csv.deleteCharAt(csv.length() - 1);

    csv.append(""\n"");

    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss:SSS'Z'"");

    List<ExperimentInstance> instances = experiment.instances;
    for (ExperimentInstance instance : instances) {
      csv.append(""\"""").append(instance.id).append(""\"","");
      csv.append(""\"""").append(instance.name).append(""\"","");
      csv.append(""\"""").append(instance.status).append(""\"","");
      csv.append(""\"""").append(simpleDateFormat.format(instance.creationDate)).append(""\"","");

      HashMap<String, String> dataMap = new HashMap<>();
      for (Data d : instance.data) {
        dataMap.put(d.name, d.value);
      }

      for (String parameterName : parameterNames) {
        if (dataMap.containsKey(parameterName)) {
          csv.append(""\"""").append(dataMap.get(parameterName)).append(""\"","");
        } else {
          csv.append("","");
        }
      }

      //Delete trailing comma
      csv.deleteCharAt(csv.length() - 1);
      csv.append(""\n"");
    }

    return ok(csv.toString());
  }

  @Security.Authenticated(Secured.class)
  public static Result eventCsv(Long experimentInstanceId) {
    ExperimentInstance ei = ExperimentInstance.findById(experimentInstanceId);

    final StringBuilder csv = new StringBuilder();
    csv.append(""\""id\"",\""event\"",\""event_date\"",\""data_name\"",\""data_value\""\n"");
    Collections.sort(ei.events, new Comparator<Event>() {
      @Override
      public int compare(Event o1, Event o2) {
        return o1.datetime.compareTo(o2.datetime);
      }
    });
    for (Event event : ei.events) {
      List<EventData> eventDatas = event.eventData;
      for (EventData eventData : eventDatas) {
        csv.append(""\"""").append(event.id).append(""\"",\"""")
            .append(event.name).append(""\"",\"""")
            .append(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss:SSS'Z'"").format(event.datetime))
            .append(""\"",\"""").append(eventData.name).append(""\"","")
            .append(eventData.valueToCSV()).append(""\n"");
      }
    }

    return ok(csv.toString());
  }

  /**
   * Handle the websocket.
   */
  public static WebSocket<JsonNode> connect() {
    WebSocket socket = new WebSocket<JsonNode>(){
      // Called when the Websocket Handshake is done.
      public void onReady(final WebSocket.In<JsonNode> in, final WebSocket.Out<JsonNode> out) {
        try {
          Breadboard.connect(in, out);
        } catch (Exception ex) {
          ex.printStackTrace();
        }
      }
    };
    return socket;
  }

  public static class Login {
    public String email;
    public String password;

    public String validate() {
      Logger.debug(""email: "" + email);
      if (User.authenticate(email, password) == null) {
        return ""Invalid user or password"";
      }
      return null;
    }
  }

}
","package controllers; public class Application extends Controller { public static Result addFirstUser() { if (User.findRowCount() > 0) { return badRequest(""User table is not empty.""); } String email, password; Long defaultLanguageId; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { email = json.findPath(""email"").textValue(); password = json.findPath(""password"").textValue(); defaultLanguageId = json.findPath(""defaultLanguageId"").longValue(); } Language defaultLanguage = Language.findById(defaultLanguageId); if (email == null || password == null || defaultLanguage == null) { return badRequest(""Please provide email, password, and default language.""); } User user = new User(); user.email = email; user.password = BCrypt.hashpw(password, BCrypt.gensalt()); user.role = ""admin""; user.currentScript = """"; user.defaultLanguage = defaultLanguage; user.experimentInstanceId = -1L; user.selectedExperiment = null; user.save(); return ok(); } public static Result authenticate() { Form<Login> loginForm = Form.form(Login.class).bindFromRequest(); ObjectNode result = Json.newObject(); if (loginForm.hasErrors()) { result.put(""message"", ""Invalid username or password""); result.put(""status"", ""error""); return badRequest(result); } else { String email = loginForm.get().email; session(""email"", email); String uid = UUID.randomUUID().toString(); String juid = UUID.randomUUID().toString(); session(""uid"", uid); session(""juid"", uid); User user = User.findByEmail(email); if (user != null) { user.uid = uid; user.update(); result = Json.newObject(); result.put(""uid"", uid); result.put(""email"", email); result.put(""juid"", juid); return ok(result); } return badRequest(login.render(loginForm)); } } public static Result logout() { session().clear(); return unauthorized(); } public static Result index () { String assetsRoot = play.Play.application().configuration().getString(""breadboard.assetsRoot"", ""/assets""); return ok(main.render(assetsRoot)); } @Security.Authenticated(Secured.class)
  public static Result getState() { ObjectNode result = Json.newObject(); result.put(""uid"", session(""uid"")); result.put(""juid"", session(""juid"")); result.put(""email"", session(""email"")); result.put(""connectSocket"", play.Play.application().configuration().getString(""breadboard.wsUrl"")); return ok(result); } @Security.Authenticated(Secured.class)
  public static Result saveUserSettings() { Form<UserSettings> userSettingsForm = Form.form(UserSettings.class); userSettingsForm = userSettingsForm.bindFromRequest(); ObjectNode result = Json.newObject(); result.put(""success"", false); if (userSettingsForm.hasErrors()) { result.put(""error"", userSettingsForm.globalError().message()); return ok(result); } UserSettings userSettings = userSettingsForm.get(); userSettings.user.password = BCrypt.hashpw(userSettings.newPassword, BCrypt.gensalt()); userSettings.user.update(); result.put(""success"", true); return ok(result); } @Security.Authenticated(Secured.class)
  public static Result dataCsv(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); final StringBuilder csv = new StringBuilder(); Set<String> parameterNames = new TreeSet<>(); for (ExperimentInstance instance : experiment.instances) { for (Data d : instance.data) { parameterNames.add(d.name); } } csv.append(""\""id\"",\""instance\"",\""status\"",\""created_at\"",""); for (String parameterName : parameterNames) { csv.append(""\"""" + parameterName + ""\"",""); } csv.deleteCharAt(csv.length() - 1); csv.append(""\n""); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss:SSS'Z'""); List<ExperimentInstance> instances = experiment.instances; for (ExperimentInstance instance : instances) { csv.append(""\"""").append(instance.id).append(""\"",""); csv.append(""\"""").append(instance.name).append(""\"",""); csv.append(""\"""").append(instance.status).append(""\"",""); csv.append(""\"""").append(simpleDateFormat.format(instance.creationDate)).append(""\"",""); HashMap<String, String> dataMap = new HashMap<>(); for (Data d : instance.data) { dataMap.put(d.name, d.value); } for (String parameterName : parameterNames) { if (dataMap.containsKey(parameterName)) { csv.append(""\"""").append(dataMap.get(parameterName)).append(""\"",""); } else { csv.append("",""); } } csv.deleteCharAt(csv.length() - 1); csv.append(""\n""); } return ok(csv.toString()); } @Security.Authenticated(Secured.class)
  public static Result eventCsv(Long experimentInstanceId) { ExperimentInstance ei = ExperimentInstance.findById(experimentInstanceId); final StringBuilder csv = new StringBuilder(); csv.append(""\""id\"",\""event\"",\""event_date\"",\""data_name\"",\""data_value\""\n""); Collections.sort(ei.events, new Comparator<Event>() { @Override
      public int compare(Event o1, Event o2) { return o1.datetime.compareTo(o2.datetime); } } ); for (Event event : ei.events) { List<EventData> eventDatas = event.eventData; for (EventData eventData : eventDatas) { csv.append(""\"""").append(event.id).append(""\"",\"""")
            .append(event.name).append(""\"",\"""")
            .append(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss:SSS'Z'"").format(event.datetime))
            .append(""\"",\"""").append(eventData.name).append(""\"","")
            .append(eventData.valueToCSV()).append(""\n""); } } return ok(csv.toString()); } public static WebSocket<JsonNode> connect() { WebSocket socket = new WebSocket<JsonNode>(){ public void onReady(final WebSocket.In<JsonNode> in, final WebSocket.Out<JsonNode> out) { try { Breadboard.connect(in, out); } catch (Exception ex) { ex.printStackTrace(); } } } ; return socket; } public static class Login { public String email; public String password; public String validate() { if (User.authenticate(email, password) == null) { return ""Invalid user or password""; } return null; } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0,"package controllers; public class Application extends Controller { public static Result addFirstUser() { if (User.findRowCount() > 0) { return badRequest(""User table is not empty.""); } String email, password; Long defaultLanguageId; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { email = json.findPath(""email"").textValue(); password = json.findPath(""password"").textValue(); defaultLanguageId = json.findPath(""defaultLanguageId"").longValue(); } Language defaultLanguage = Language.findById(defaultLanguageId); if (email == null || password == null || defaultLanguage == null) { return badRequest(""Please provide email, password, and default language.""); } User user = new User(); user.email = email; user.password = BCrypt.hashpw(password, BCrypt.gensalt()); user.role = ""admin""; user.currentScript = """"; user.defaultLanguage = defaultLanguage; user.experimentInstanceId = -1L; user.selectedExperiment = null; user.save(); return ok(); } public static Result authenticate() { Form<Login> loginForm = Form.form(Login.class).bindFromRequest(); ObjectNode result = Json.newObject(); if (loginForm.hasErrors()) { result.put(""message"", ""Invalid username or password""); result.put(""status"", ""error""); return badRequest(result); } else { String email = loginForm.get().email; session(""email"", email); String uid = UUID.randomUUID().toString(); String juid = UUID.randomUUID().toString(); session(""uid"", uid); session(""juid"", uid); User user = User.findByEmail(email); if (user != null) { <FILL_ME> user.uid = uid; user.update(); result = Json.newObject(); result.put(""uid"", uid); result.put(""email"", email); result.put(""juid"", juid); return ok(result); } return badRequest(login.render(loginForm)); } } public static Result logout() { session().clear(); return unauthorized(); } public static Result index () { String assetsRoot = play.Play.application().configuration().getString(""breadboard.assetsRoot"", ""/assets""); return ok(main.render(assetsRoot)); } @Security.Authenticated(Secured.class)
  public static Result getState() { ObjectNode result = Json.newObject(); result.put(""uid"", session(""uid"")); result.put(""juid"", session(""juid"")); result.put(""email"", session(""email"")); result.put(""connectSocket"", play.Play.application().configuration().getString(""breadboard.wsUrl"")); return ok(result); } @Security.Authenticated(Secured.class)
  public static Result saveUserSettings() { Form<UserSettings> userSettingsForm = Form.form(UserSettings.class); userSettingsForm = userSettingsForm.bindFromRequest(); ObjectNode result = Json.newObject(); result.put(""success"", false); if (userSettingsForm.hasErrors()) { result.put(""error"", userSettingsForm.globalError().message()); return ok(result); } UserSettings userSettings = userSettingsForm.get(); userSettings.user.password = BCrypt.hashpw(userSettings.newPassword, BCrypt.gensalt()); userSettings.user.update(); result.put(""success"", true); return ok(result); } @Security.Authenticated(Secured.class)
  public static Result dataCsv(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); final StringBuilder csv = new StringBuilder(); Set<String> parameterNames = new TreeSet<>(); for (ExperimentInstance instance : experiment.instances) { for (Data d : instance.data) { parameterNames.add(d.name); } } csv.append(""\""id\"",\""instance\"",\""status\"",\""created_at\"",""); for (String parameterName : parameterNames) { csv.append(""\"""" + parameterName + ""\"",""); } csv.deleteCharAt(csv.length() - 1); csv.append(""\n""); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss:SSS'Z'""); List<ExperimentInstance> instances = experiment.instances; for (ExperimentInstance instance : instances) { csv.append(""\"""").append(instance.id).append(""\"",""); csv.append(""\"""").append(instance.name).append(""\"",""); csv.append(""\"""").append(instance.status).append(""\"",""); csv.append(""\"""").append(simpleDateFormat.format(instance.creationDate)).append(""\"",""); HashMap<String, String> dataMap = new HashMap<>(); for (Data d : instance.data) { dataMap.put(d.name, d.value); } for (String parameterName : parameterNames) { if (dataMap.containsKey(parameterName)) { csv.append(""\"""").append(dataMap.get(parameterName)).append(""\"",""); } else { csv.append("",""); } } csv.deleteCharAt(csv.length() - 1); csv.append(""\n""); } return ok(csv.toString()); } @Security.Authenticated(Secured.class)
  public static Result eventCsv(Long experimentInstanceId) { ExperimentInstance ei = ExperimentInstance.findById(experimentInstanceId); final StringBuilder csv = new StringBuilder(); csv.append(""\""id\"",\""event\"",\""event_date\"",\""data_name\"",\""data_value\""\n""); Collections.sort(ei.events, new Comparator<Event>() { @Override
      public int compare(Event o1, Event o2) { return o1.datetime.compareTo(o2.datetime); } } ); for (Event event : ei.events) { List<EventData> eventDatas = event.eventData; for (EventData eventData : eventDatas) { csv.append(""\"""").append(event.id).append(""\"",\"""")
            .append(event.name).append(""\"",\"""")
            .append(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss:SSS'Z'"").format(event.datetime))
            .append(""\"",\"""").append(eventData.name).append(""\"","")
            .append(eventData.valueToCSV()).append(""\n""); } } return ok(csv.toString()); } public static WebSocket<JsonNode> connect() { WebSocket socket = new WebSocket<JsonNode>(){ public void onReady(final WebSocket.In<JsonNode> in, final WebSocket.Out<JsonNode> out) { try { Breadboard.connect(in, out); } catch (Exception ex) { ex.printStackTrace(); } } } ; return socket; } public static class Login { public String email; public String password; public String validate() { <FILL_ME> if (User.authenticate(email, password) == null) { return ""Invalid user or password""; } return null; } } } ","package controllers; 
import models.*; import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.node.ObjectNode; import org.mindrot.jbcrypt.BCrypt; import play.Logger; import play.data.Form; import play.libs.Json; import play.mvc.*; import views.html.*; import java.io.*; import java.text.SimpleDateFormat; import java.util.*;  public class Application extends Controller {  public static Result addFirstUser() {  if (User.findRowCount() > 0) { return badRequest(""User table is not empty.""); }  String email, password; Long defaultLanguageId; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { email = json.findPath(""email"").textValue(); password = json.findPath(""password"").textValue(); defaultLanguageId = json.findPath(""defaultLanguageId"").longValue(); }  Language defaultLanguage = Language.findById(defaultLanguageId);  if (email == null || password == null || defaultLanguage == null) { return badRequest(""Please provide email, password, and default language.""); }  User user = new User(); user.email = email; user.password = BCrypt.hashpw(password, BCrypt.gensalt()); user.role = ""admin""; user.currentScript = """"; user.defaultLanguage = defaultLanguage; user.experimentInstanceId = -1L; user.selectedExperiment = null; user.save();  // TODO: Make method for creating demo experiments and associating with new user /*
    Experiment experiment = Experiment.findById(321l);
    if (experiment != null) {
      user.ownedExperiments.add(experiment);
      user.update();
      user.saveManyToManyAssociations(""ownedExperiments"");
    }
    */ return ok(); } 
 public static Result authenticate() { Form<Login> loginForm = Form.form(Login.class).bindFromRequest(); ObjectNode result = Json.newObject(); if (loginForm.hasErrors()) { result.put(""message"", ""Invalid username or password""); result.put(""status"", ""error""); return badRequest(result); } else { String email = loginForm.get().email;  session(""email"", email);  String uid = UUID.randomUUID().toString(); String juid = UUID.randomUUID().toString(); session(""uid"", uid); session(""juid"", uid);  User user = User.findByEmail(email);  if (user != null) { <FILL_ME> user.uid = uid; user.update(); result = Json.newObject(); result.put(""uid"", uid); result.put(""email"", email); result.put(""juid"", juid); return ok(result); }  return badRequest(login.render(loginForm)); } }  public static Result logout() { session().clear(); return unauthorized(); }  public static Result index () {  String assetsRoot = play.Play.application().configuration().getString(""breadboard.assetsRoot"", ""/assets""); return ok(main.render(assetsRoot)); } // final File file = play.Play.application().getFile(""assets/templates/breadboard.html""); @Security.Authenticated(Secured.class)
  public static Result getState() { ObjectNode result = Json.newObject(); result.put(""uid"", session(""uid""));  result.put(""juid"", session(""juid"")); result.put(""email"", session(""email"")); result.put(""connectSocket"", play.Play.application().configuration().getString(""breadboard.wsUrl"")); return ok(result); } // remove this @Security.Authenticated(Secured.class)
  public static Result saveUserSettings() { Form<UserSettings> userSettingsForm = Form.form(UserSettings.class); userSettingsForm = userSettingsForm.bindFromRequest();  ObjectNode result = Json.newObject();  result.put(""success"", false); if (userSettingsForm.hasErrors()) { result.put(""error"", userSettingsForm.globalError().message()); return ok(result); }  UserSettings userSettings = userSettingsForm.get();  userSettings.user.password = BCrypt.hashpw(userSettings.newPassword, BCrypt.gensalt()); userSettings.user.update(); result.put(""success"", true);  return ok(result); }  @Security.Authenticated(Secured.class)
  public static Result dataCsv(Long experimentId) {  Experiment experiment = Experiment.findById(experimentId); final StringBuilder csv = new StringBuilder(); Set<String> parameterNames = new TreeSet<>(); for (ExperimentInstance instance : experiment.instances) { for (Data d : instance.data) { parameterNames.add(d.name); } } //TODO: Escape double quotes in ExperimentInstance parameters csv.append(""\""id\"",\""instance\"",\""status\"",\""created_at\"","");   for (String parameterName : parameterNames) { csv.append(""\"""" + parameterName + ""\"",""); } // Add all parameter names  csv.deleteCharAt(csv.length() - 1); // Delete trailing comma csv.append(""\n"");  SimpleDateFormat simpleDateFormat = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss:SSS'Z'"");  List<ExperimentInstance> instances = experiment.instances; for (ExperimentInstance instance : instances) { csv.append(""\"""").append(instance.id).append(""\"",""); csv.append(""\"""").append(instance.name).append(""\"",""); csv.append(""\"""").append(instance.status).append(""\"",""); csv.append(""\"""").append(simpleDateFormat.format(instance.creationDate)).append(""\"","");  HashMap<String, String> dataMap = new HashMap<>(); for (Data d : instance.data) { dataMap.put(d.name, d.value); }  for (String parameterName : parameterNames) { if (dataMap.containsKey(parameterName)) { csv.append(""\"""").append(dataMap.get(parameterName)).append(""\"",""); } else { csv.append("",""); } }   csv.deleteCharAt(csv.length() - 1); csv.append(""\n""); } //Delete trailing comma return ok(csv.toString()); }  @Security.Authenticated(Secured.class)
  public static Result eventCsv(Long experimentInstanceId) { ExperimentInstance ei = ExperimentInstance.findById(experimentInstanceId);  final StringBuilder csv = new StringBuilder(); csv.append(""\""id\"",\""event\"",\""event_date\"",\""data_name\"",\""data_value\""\n""); Collections.sort(ei.events, new Comparator<Event>() { @Override
      public int compare(Event o1, Event o2) { return o1.datetime.compareTo(o2.datetime); } } ); for (Event event : ei.events) { List<EventData> eventDatas = event.eventData; for (EventData eventData : eventDatas) { csv.append(""\"""").append(event.id).append(""\"",\"""")
            .append(event.name).append(""\"",\"""")
            .append(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss:SSS'Z'"").format(event.datetime))
            .append(""\"",\"""").append(eventData.name).append(""\"","")
            .append(eventData.valueToCSV()).append(""\n""); } }  return ok(csv.toString()); }   public static WebSocket<JsonNode> connect() { WebSocket socket = new WebSocket<JsonNode>(){ /**
   * Handle the websocket.
   */ public void onReady(final WebSocket.In<JsonNode> in, final WebSocket.Out<JsonNode> out) { try { Breadboard.connect(in, out); } catch (Exception ex) { ex.printStackTrace(); } } } ; return socket; } // Called when the Websocket Handshake is done. public static class Login { public String email; public String password;  public String validate() { <FILL_ME> if (User.authenticate(email, password) == null) { return ""Invalid user or password""; } return null; } }  }  "
app/controllers/BundlesController.java,"package controllers;

import play.libs.WS;
import play.Logger;
import play.mvc.Result;
import static play.libs.F.*;
import static play.libs.F.Promise;
import static play.mvc.Controller.response;
import static play.mvc.Results.ok;
import static play.mvc.Results.badRequest;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;

public class BundlesController {

  private static Boolean isChildOf(String child, String parent) {
    Path parentPath = Paths.get(parent);
    Path childPath = Paths.get(child);
    return isChildOf(childPath, parentPath);
  }

  private static Boolean isChildOf(Path child, Path parent) {
    while (child != null) {
      if (child.equals(parent)) {
        return true;
      }
      child = child.getParent();
    }
    return false;
  }

  private static Boolean isCacheable (Path filePath) {
    String[] exts = {""js"", ""css"", ""png"", ""jpg"", ""jpeg"", ""woff"", ""webp"", ""woff2"", ""js.map"", ""ico"", ""ttf"", ""otf""};
    for (String ext : exts) {
      if (filePath.endsWith(""."" + ext)) {
        return true;
      }
    }
    return false;
  }

  public static Result asset(String filePath) {

    String dir = play.Play.application().configuration().getString(""application.staticPath"", ""generated"");
    Path dirPath = Paths.get(dir).normalize();
    if (!dirPath.isAbsolute()) {
      dirPath = dirPath.toAbsolutePath();
    }

    Path assetPath = dirPath.resolve(filePath).normalize();
    
    // Prevent path traversal attacks by checking that this file is contained in the configured dir
    if (!isChildOf(assetPath, dirPath)) {
      return badRequest(""Invalid path."");
    }
    
    Logger.trace(""serving "" + filePath + "" from "" + assetPath.toAbsolutePath().toString());
    if (isCacheable(assetPath)) {
      response().setHeader(""Cache-Control"", ""max-age=86400 public"");
    }
    File file = new File(assetPath.toString());
    return ok(file, true);
  }

}
","package controllers; public class BundlesController { private static Boolean isChildOf(String child, String parent) { Path parentPath = Paths.get(parent); Path childPath = Paths.get(child); return isChildOf(childPath, parentPath); } private static Boolean isChildOf(Path child, Path parent) { while (child != null) { if (child.equals(parent)) { return true; } child = child.getParent(); } return false; } private static Boolean isCacheable (Path filePath) { String[] exts = { ""js"", ""css"", ""png"", ""jpg"", ""jpeg"", ""woff"", ""webp"", ""woff2"", ""js.map"", ""ico"", ""ttf"", ""otf""} ; for (String ext : exts) { if (filePath.endsWith(""."" + ext)) { return true; } } return false; } public static Result asset(String filePath) { String dir = play.Play.application().configuration().getString(""application.staticPath"", ""generated""); Path dirPath = Paths.get(dir).normalize(); if (!dirPath.isAbsolute()) { dirPath = dirPath.toAbsolutePath(); } Path assetPath = dirPath.resolve(filePath).normalize(); if (!isChildOf(assetPath, dirPath)) { return badRequest(""Invalid path.""); } if (isCacheable(assetPath)) { response().setHeader(""Cache-Control"", ""max-age=86400 public""); } File file = new File(assetPath.toString()); return ok(file, true); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0,"package controllers; public class BundlesController { private static Boolean isChildOf(String child, String parent) { Path parentPath = Paths.get(parent); Path childPath = Paths.get(child); return isChildOf(childPath, parentPath); } <FILL_ME> private static Boolean isChildOf(Path child, Path parent) { while (child != null) { if (child.equals(parent)) { return true; } child = child.getParent(); } return false; } private static Boolean isCacheable (Path filePath) { String[] exts = { ""js"", ""css"", ""png"", ""jpg"", ""jpeg"", ""woff"", ""webp"", ""woff2"", ""js.map"", ""ico"", ""ttf"", ""otf""} ; for (String ext : exts) { if (filePath.endsWith(""."" + ext)) { return true; } } return false; } public static Result asset(String filePath) { String dir = play.Play.application().configuration().getString(""application.staticPath"", ""generated""); Path dirPath = Paths.get(dir).normalize(); if (!dirPath.isAbsolute()) { dirPath = dirPath.toAbsolutePath(); } Path assetPath = dirPath.resolve(filePath).normalize(); if (!isChildOf(assetPath, dirPath)) { return badRequest(""Invalid path.""); } if (isCacheable(assetPath)) { response().setHeader(""Cache-Control"", ""max-age=86400 public""); } File file = new File(assetPath.toString()); return ok(file, true); } } ","package controllers; 
import play.libs.WS; import play.Logger; import play.mvc.Result; import static play.libs.F.*; import static play.libs.F.Promise; import static play.mvc.Controller.response; import static play.mvc.Results.ok; import static play.mvc.Results.badRequest; 
import java.io.File; import java.io.IOException; import java.nio.file.Path; import java.nio.file.Paths;  public class BundlesController {  private static Boolean isChildOf(String child, String parent) { Path parentPath = Paths.get(parent); Path childPath = Paths.get(child); return isChildOf(childPath, parentPath); } <FILL_ME>  private static Boolean isChildOf(Path child, Path parent) { while (child != null) { if (child.equals(parent)) { return true; } child = child.getParent(); } return false; }  private static Boolean isCacheable (Path filePath) { String[] exts = { ""js"", ""css"", ""png"", ""jpg"", ""jpeg"", ""woff"", ""webp"", ""woff2"", ""js.map"", ""ico"", ""ttf"", ""otf""} ; for (String ext : exts) { if (filePath.endsWith(""."" + ext)) { return true; } } return false; }  public static Result asset(String filePath) {  String dir = play.Play.application().configuration().getString(""application.staticPath"", ""generated""); Path dirPath = Paths.get(dir).normalize(); if (!dirPath.isAbsolute()) { dirPath = dirPath.toAbsolutePath(); }  Path assetPath = dirPath.resolve(filePath).normalize();      // Prevent path traversal attacks by checking that this file is contained in the configured dir if (!isChildOf(assetPath, dirPath)) { return badRequest(""Invalid path.""); }      if (isCacheable(assetPath)) { response().setHeader(""Cache-Control"", ""max-age=86400 public""); } File file = new File(assetPath.toString()); return ok(file, true); }  }  "
app/controllers/ClientController.java,"package controllers;

import com.fasterxml.jackson.databind.node.ObjectNode;
import org.apache.commons.io.FileUtils;
import play.*;
import play.libs.Json;
import play.mvc.*;
import views.html.*;
import com.fasterxml.jackson.databind.*;
import models.*;
import java.io.*;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

// TODO: Why does this always redirect to login?
//@Security.Authenticated(SecuredClient.class)
public class ClientController extends Controller 
{
    public static Result index(String experimentId, String experimentInstanceId, String clientId, String connectionSpeed) 
    {
        ExperimentInstance experimentInstance = null;
        Experiment experiment = null;
        
        try {
          experimentInstance = ExperimentInstance.findById(Long.valueOf(experimentInstanceId));
          experiment = Experiment.findById(Long.valueOf(experimentId));
        } catch (NumberFormatException ignored) {}

        if (experimentInstance == null || experiment == null || experimentInstance.status != ExperimentInstance.Status.RUNNING) {
          return ok( amtError.render() );
        }
        String assetsRoot = play.Play.application().configuration().getString(""breadboard.assetsRoot"", ""/assets"");
        if (assetsRoot != null) {
            return ok(client.render(assetsRoot));
        } else {
            return ok(client.render(""""));
        }
    }

    public static Result getState(String experimentId, String experimentInstanceId, String clientId, String connectionSpeed){
        Map<String, String> vals = new HashMap();
        vals.put(""Referer"", ""referer"");
        vals.put(""Connection"", ""connection"");
        vals.put(""Accept"", ""accept"");
        vals.put(""Cache-Control"", ""cacheControl"");
        vals.put(""Accept-Charset"", ""acceptCharset"");
        vals.put(""Cookie"", ""cookie"");
        vals.put(""Accept-Language"", ""acceptLanguage"");
        vals.put(""Accept-Encoding"", ""acceptEncoding"");
        vals.put(""User-Agent"", ""userAgent"");
        vals.put(""Host"", ""host"");
        ObjectNode result = Json.newObject();
        Iterator it = vals.entrySet().iterator();
        while(it.hasNext()){
            Map.Entry pair = (Map.Entry)it.next();
            String header = request().getHeader(pair.getKey().toString());
            result.put((String) pair.getValue(), header);
            it.remove();
        }
        result.put(""assetsRoot"", play.Play.application().configuration().getString(""breadboard.assetsRoot"", ""/assets""));
        result.put(""ipAddress"", request().remoteAddress());
        result.put(""requestURI"", request().uri());
        result.put(""clientId"", clientId);
        result.put(""experimentId"", experimentId);
        result.put(""experimentInstanceId"", experimentInstanceId);
        result.put(""clientGraph"", getClientGraph(experimentId));
        result.put(""clientHtml"", getClientHtml(experimentId));
        result.put(""connectSocket"", routes.ClientController.connectClient(experimentId, experimentInstanceId, clientId).webSocketURL(request(), play.Play.application().configuration().getString(""breadboard.wsUrl"").contains(""wss://"")));
        return ok(result);
    }

    /**
     * Return the custom experiement graph if it exists
     * @return
     */
    public static String getClientGraph(String experimentId){
        Experiment experiment = null;
        try {
            experiment = Experiment.findById(Long.valueOf(experimentId));
        } catch (NumberFormatException ignored) {}

        if (experiment == null) {
            File file = play.Play.application().getFile(""conf/defaults/client-graph.js"");
            try {
                return FileUtils.readFileToString(file, ""UTF-8"");
            } catch(IOException ignored) {}
        }
        return experiment.getClientGraph();
    }

    /**
     * Return the custom experiment client html if it exists
     */
    public static String getClientHtml(String experimentId){
        Experiment experiment = null;
        try {
            experiment = Experiment.findById(Long.valueOf(experimentId));
        } catch (NumberFormatException ignored) {}

        if (experiment == null) {
            File file = play.Play.application().getFile(""conf/defaults/default-client-html.html"");
            try {
                return FileUtils.readFileToString(file, ""UTF-8"");
            } catch(IOException ignored) {}
        }
        return experiment.getClientHtml();
    }

    /**
    * Handle the client websocket.
    */
    public static WebSocket<JsonNode> connectClient(final String experimentId, final String experimentInstanceId, final String clientId) 
    {
        return new WebSocket<JsonNode>() 
        {
            // Called when the Websocket Handshake is done.
            public void onReady(final WebSocket.In<JsonNode> in, final WebSocket.Out<JsonNode> out)
            {
                Logger.debug(""ClientController.connectClient.onReady"");
                try
                {
                    ScriptBoard.addClient(experimentId, experimentInstanceId, clientId, in, new ThrottledWebSocketOut(out, Breadboard.WEBSOCKET_RATE));
                }
                catch (Exception ex)
                {
                    ex.printStackTrace();
                }
            }
        };
    }
}
","package controllers; public class ClientController extends Controller 
{ public static Result index(String experimentId, String experimentInstanceId, String clientId, String connectionSpeed) 
    { ExperimentInstance experimentInstance = null; Experiment experiment = null; try { experimentInstance = ExperimentInstance.findById(Long.valueOf(experimentInstanceId)); experiment = Experiment.findById(Long.valueOf(experimentId)); } catch (NumberFormatException ignored) { } if (experimentInstance == null || experiment == null || experimentInstance.status != ExperimentInstance.Status.RUNNING) { return ok( amtError.render() ); } String assetsRoot = play.Play.application().configuration().getString(""breadboard.assetsRoot"", ""/assets""); if (assetsRoot != null) { return ok(client.render(assetsRoot)); } else { return ok(client.render("""")); } } public static Result getState(String experimentId, String experimentInstanceId, String clientId, String connectionSpeed){ Map<String, String> vals = new HashMap(); vals.put(""Referer"", ""referer""); vals.put(""Connection"", ""connection""); vals.put(""Accept"", ""accept""); vals.put(""Cache-Control"", ""cacheControl""); vals.put(""Accept-Charset"", ""acceptCharset""); vals.put(""Cookie"", ""cookie""); vals.put(""Accept-Language"", ""acceptLanguage""); vals.put(""Accept-Encoding"", ""acceptEncoding""); vals.put(""User-Agent"", ""userAgent""); vals.put(""Host"", ""host""); ObjectNode result = Json.newObject(); Iterator it = vals.entrySet().iterator(); while(it.hasNext()){ Map.Entry pair = (Map.Entry)it.next(); String header = request().getHeader(pair.getKey().toString()); result.put((String) pair.getValue(), header); it.remove(); } result.put(""assetsRoot"", play.Play.application().configuration().getString(""breadboard.assetsRoot"", ""/assets"")); result.put(""ipAddress"", request().remoteAddress()); result.put(""requestURI"", request().uri()); result.put(""clientId"", clientId); result.put(""experimentId"", experimentId); result.put(""experimentInstanceId"", experimentInstanceId); result.put(""clientGraph"", getClientGraph(experimentId)); result.put(""clientHtml"", getClientHtml(experimentId)); return ok(result); } public static String getClientGraph(String experimentId){ Experiment experiment = null; try { experiment = Experiment.findById(Long.valueOf(experimentId)); } catch (NumberFormatException ignored) { } if (experiment == null) { File file = play.Play.application().getFile(""conf/defaults/client-graph.js""); try { return FileUtils.readFileToString(file, ""UTF-8""); } catch(IOException ignored) { } } return experiment.getClientGraph(); } public static String getClientHtml(String experimentId){ Experiment experiment = null; try { experiment = Experiment.findById(Long.valueOf(experimentId)); } catch (NumberFormatException ignored) { } if (experiment == null) { File file = play.Play.application().getFile(""conf/defaults/default-client-html.html""); try { return FileUtils.readFileToString(file, ""UTF-8""); } catch(IOException ignored) { } } return experiment.getClientHtml(); } public static WebSocket<JsonNode> connectClient(final String experimentId, final String experimentInstanceId, final String clientId) 
    { return new WebSocket<JsonNode>() 
        { public void onReady(final WebSocket.In<JsonNode> in, final WebSocket.Out<JsonNode> out)
            { try
                { ScriptBoard.addClient(experimentId, experimentInstanceId, clientId, in, new ThrottledWebSocketOut(out, Breadboard.WEBSOCKET_RATE)); } catch (Exception ex)
                { ex.printStackTrace(); } } } ; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0,"package controllers; public class ClientController extends Controller 
{ public static Result index(String experimentId, String experimentInstanceId, String clientId, String connectionSpeed) 
    { ExperimentInstance experimentInstance = null; Experiment experiment = null; try { experimentInstance = ExperimentInstance.findById(Long.valueOf(experimentInstanceId)); experiment = Experiment.findById(Long.valueOf(experimentId)); } catch (NumberFormatException ignored) { } if (experimentInstance == null || experiment == null || experimentInstance.status != ExperimentInstance.Status.RUNNING) { return ok( amtError.render() ); } String assetsRoot = play.Play.application().configuration().getString(""breadboard.assetsRoot"", ""/assets""); if (assetsRoot != null) { return ok(client.render(assetsRoot)); } else { return ok(client.render("""")); } } public static Result getState(String experimentId, String experimentInstanceId, String clientId, String connectionSpeed){ Map<String, String> vals = new HashMap(); vals.put(""Referer"", ""referer""); vals.put(""Connection"", ""connection""); vals.put(""Accept"", ""accept""); vals.put(""Cache-Control"", ""cacheControl""); vals.put(""Accept-Charset"", ""acceptCharset""); vals.put(""Cookie"", ""cookie""); vals.put(""Accept-Language"", ""acceptLanguage""); vals.put(""Accept-Encoding"", ""acceptEncoding""); vals.put(""User-Agent"", ""userAgent""); vals.put(""Host"", ""host""); ObjectNode result = Json.newObject(); Iterator it = vals.entrySet().iterator(); while(it.hasNext()){ Map.Entry pair = (Map.Entry)it.next(); String header = request().getHeader(pair.getKey().toString()); result.put((String) pair.getValue(), header); it.remove(); } result.put(""assetsRoot"", play.Play.application().configuration().getString(""breadboard.assetsRoot"", ""/assets"")); result.put(""ipAddress"", request().remoteAddress()); result.put(""requestURI"", request().uri()); result.put(""clientId"", clientId); result.put(""experimentId"", experimentId); result.put(""experimentInstanceId"", experimentInstanceId); result.put(""clientGraph"", getClientGraph(experimentId)); result.put(""clientHtml"", getClientHtml(experimentId)); return ok(result); } public static String getClientGraph(String experimentId){ Experiment experiment = null; try { experiment = Experiment.findById(Long.valueOf(experimentId)); } catch (NumberFormatException ignored) { } if (experiment == null) { File file = play.Play.application().getFile(""conf/defaults/client-graph.js""); try { return FileUtils.readFileToString(file, ""UTF-8""); } catch(IOException ignored) { } } return experiment.getClientGraph(); } public static String getClientHtml(String experimentId){ Experiment experiment = null; try { experiment = Experiment.findById(Long.valueOf(experimentId)); } catch (NumberFormatException ignored) { } if (experiment == null) { File file = play.Play.application().getFile(""conf/defaults/default-client-html.html""); try { return FileUtils.readFileToString(file, ""UTF-8""); } catch(IOException ignored) { } } return experiment.getClientHtml(); } public static WebSocket<JsonNode> connectClient(final String experimentId, final String experimentInstanceId, final String clientId) 
    { return new WebSocket<JsonNode>() 
        { public void onReady(final WebSocket.In<JsonNode> in, final WebSocket.Out<JsonNode> out)
            { <FILL_ME> try
                { ScriptBoard.addClient(experimentId, experimentInstanceId, clientId, in, new ThrottledWebSocketOut(out, Breadboard.WEBSOCKET_RATE)); } catch (Exception ex)
                { ex.printStackTrace(); } } } ; } } ","package controllers; 
import com.fasterxml.jackson.databind.node.ObjectNode; import org.apache.commons.io.FileUtils; import play.*; import play.libs.Json; import play.mvc.*; import views.html.*; import com.fasterxml.jackson.databind.*; import models.*; import java.io.*; import java.util.HashMap; import java.util.Iterator; import java.util.Map;  // TODO: Why does this always redirect to login? //@Security.Authenticated(SecuredClient.class) public class ClientController extends Controller 
{ public static Result index(String experimentId, String experimentInstanceId, String clientId, String connectionSpeed) 
    { ExperimentInstance experimentInstance = null; Experiment experiment = null;          try { experimentInstance = ExperimentInstance.findById(Long.valueOf(experimentInstanceId)); experiment = Experiment.findById(Long.valueOf(experimentId)); } catch (NumberFormatException ignored) { }  if (experimentInstance == null || experiment == null || experimentInstance.status != ExperimentInstance.Status.RUNNING) { return ok( amtError.render() ); } String assetsRoot = play.Play.application().configuration().getString(""breadboard.assetsRoot"", ""/assets""); if (assetsRoot != null) { return ok(client.render(assetsRoot)); } else { return ok(client.render("""")); } }  public static Result getState(String experimentId, String experimentInstanceId, String clientId, String connectionSpeed){ Map<String, String> vals = new HashMap(); vals.put(""Referer"", ""referer""); vals.put(""Connection"", ""connection""); vals.put(""Accept"", ""accept""); vals.put(""Cache-Control"", ""cacheControl""); vals.put(""Accept-Charset"", ""acceptCharset""); vals.put(""Cookie"", ""cookie""); vals.put(""Accept-Language"", ""acceptLanguage""); vals.put(""Accept-Encoding"", ""acceptEncoding""); vals.put(""User-Agent"", ""userAgent""); vals.put(""Host"", ""host""); ObjectNode result = Json.newObject(); Iterator it = vals.entrySet().iterator(); while(it.hasNext()){ Map.Entry pair = (Map.Entry)it.next(); String header = request().getHeader(pair.getKey().toString()); result.put((String) pair.getValue(), header); it.remove(); } result.put(""assetsRoot"", play.Play.application().configuration().getString(""breadboard.assetsRoot"", ""/assets"")); result.put(""ipAddress"", request().remoteAddress()); result.put(""requestURI"", request().uri()); result.put(""clientId"", clientId); result.put(""experimentId"", experimentId); result.put(""experimentInstanceId"", experimentInstanceId); result.put(""clientGraph"", getClientGraph(experimentId)); result.put(""clientHtml"", getClientHtml(experimentId)); //""))); return ok(result); }  /**
     * Return the custom experiement graph if it exists
     * @return
     */ public static String getClientGraph(String experimentId){ Experiment experiment = null; try { experiment = Experiment.findById(Long.valueOf(experimentId)); } catch (NumberFormatException ignored) { }  if (experiment == null) { File file = play.Play.application().getFile(""conf/defaults/client-graph.js""); try { return FileUtils.readFileToString(file, ""UTF-8""); } catch(IOException ignored) { } } return experiment.getClientGraph(); }  /**
     * Return the custom experiment client html if it exists
     */ public static String getClientHtml(String experimentId){ Experiment experiment = null; try { experiment = Experiment.findById(Long.valueOf(experimentId)); } catch (NumberFormatException ignored) { }  if (experiment == null) { File file = play.Play.application().getFile(""conf/defaults/default-client-html.html""); try { return FileUtils.readFileToString(file, ""UTF-8""); } catch(IOException ignored) { } } return experiment.getClientHtml(); }  /**
    * Handle the client websocket.
    */ public static WebSocket<JsonNode> connectClient(final String experimentId, final String experimentInstanceId, final String clientId) 
    { return new WebSocket<JsonNode>() 
        { // Called when the Websocket Handshake is done. public void onReady(final WebSocket.In<JsonNode> in, final WebSocket.Out<JsonNode> out)
            { <FILL_ME> try
                { ScriptBoard.addClient(experimentId, experimentInstanceId, clientId, in, new ThrottledWebSocketOut(out, Breadboard.WEBSOCKET_RATE)); } catch (Exception ex)
                { ex.printStackTrace(); } } } ; } }  "
app/controllers/ClientLogin.java,"package controllers;

import com.avaje.ebean.Ebean;
import com.avaje.ebean.SqlQuery;
import com.avaje.ebean.SqlRow;
import com.fasterxml.jackson.databind.JsonNode;
import models.*;
import play.Logger;
import play.data.Form;
import play.mvc.Controller;
import play.mvc.Result;
import play.mvc.WebSocket;
import views.html.*;
import java.util.List;

public class ClientLogin extends Controller {
  public static class AMTLogin {
    public Long experimentId;
    public Long experimentInstanceId;
    public String hitId;
    public String assignmentId;
    public String workerId;
    public String connectionSpeed;

    public String validate() {
      Logger.debug(""validating experimentId: "" + experimentId);
      Logger.debug(""validating experimentInstanceId: "" + experimentInstanceId);
      Logger.debug(""validating hitId: "" + hitId);
      Logger.debug(""validating assignmentId: "" + assignmentId);
      Logger.debug(""validating workerId: "" + workerId);
      Logger.debug(""validating connectionSpeed: "" + connectionSpeed);
      // TODO: save hitId with ExperimentInstance when creating it, then validate here.
      return null;
    }
  }

  public static class CLogin {
    public String id;
    public String password;
    public String experimentId;
    public String experimentInstanceId;

    public String validate() {
      Logger.info(""Client Login, ID: "" + id);

      // TODO: make password a groovy closure to allow for hash functions or custom passwords
      if (!ScriptBoard.checkPassword(password)) {
        return ""Invalid user or password"";
      }
      return null;
    }
  }

  public static Result login(String experimentId, String experimentInstanceId) {
    return ok(clientLogin.render(experimentId, experimentInstanceId, Form.form(CLogin.class)));
  }

  public static Result amtLogin(Long experimentId, Long experimentInstanceId, String hitId, String assignmentId, String workerId) {
    Experiment experiment = Experiment.findById(experimentId);
    ExperimentInstance experimentInstance = ExperimentInstance.findById(experimentInstanceId);
    AMTHit amtHit = experimentInstance.getHit();

    if (experiment == null || experimentInstance == null || experimentInstance.status != ExperimentInstance.Status.RUNNING) {
      return ok(amtError.render());
    }

    if (Boolean.TRUE.equals(experimentInstance.hasStarted) && (workerId == null || (!amtHit.hasWorker(workerId)))) {
      return ok(amtGameStarted.render());
    }

    if (experimentInstance.getHit() != null) {
      if (amtHit != null) {
        if (amtHit.isExtended()) {
          return ok(amtExtended.render(Experiment.findById(experimentId), ExperimentInstance.findById(experimentInstanceId), hitId, assignmentId, workerId, Form.form(AMTLogin.class)));
        }

        if (""any"".equals(amtHit.disallowPrevious)) {
          int rowCount = AMTAssignment.findRowCountByWorkerId(workerId);
          if (rowCount > 0) {
            return ok(amtPreviousWorker.render());
          }
        } // if (""any"".equals(amtHit.disallowPrevious)) {

        if (""type"".equals(amtHit.disallowPrevious)) {
          String sql
              = "" select a.worker_id ""
              + "" from amt_assignments a ""
              + "" join amt_hits h on a.amt_hit_id = h.id""
              + "" join experiment_instances i on h.experiment_instance_id = i.id""
              + "" join experiments e on i.experiment_id = e.id""
              + "" where e.id = :eid""
              + "" and a.worker_id = :wid""
              + "" and a.assignment_completed = 1"";

          SqlQuery sqlQuery = Ebean.createSqlQuery(sql);
          sqlQuery.setParameter(""eid"", experimentId);
          sqlQuery.setParameter(""wid"", workerId);

          List<SqlRow> list = sqlQuery.findList();

          if (list.size() > 0) {
            return ok(amtPreviousWorker.render());
          }
        } // if (""type"".equals(amtHit.disallowPrevious)) {
      } // if (amtHit != null) {
    } // if (experimentInstance.getHit() != null) {
    return ok(amtClientLogin.render(Experiment.findById(experimentId), ExperimentInstance.findById(experimentInstanceId), hitId, assignmentId, workerId, Form.form(AMTLogin.class)));
  }

  public static Result dummyHit(String assignmentId, String sandboxString) {
    boolean sandbox = false;
    if (sandboxString != null && sandboxString.equals(""true"")) {
      sandbox = true;
    }
    return ok(amtDummy.render(assignmentId, sandbox));
  }

  public static Result amtAuthenticate(Long experimentId, Long experimentInstanceId, String hitId, String assignmentId, String workerId) {
    //Logger.info(""Got to amtAuthenticate."");
    Form<AMTLogin> loginForm = Form.form(AMTLogin.class).bindFromRequest();
    String connectionSpeed = loginForm.get().connectionSpeed;

    ExperimentInstance experimentInstance = ExperimentInstance.findById(experimentInstanceId);
    Experiment experiment = Experiment.findById(experimentId);
    if (experimentInstance == null || experiment == null || experimentInstance.status != ExperimentInstance.Status.RUNNING) {
      return ok(amtError.render());
    }

    AMTHit amtHit = null;
    if (experimentInstance.getHit() != null) {
      amtHit = experimentInstance.getHit();
    }

    if (amtHit == null) {
      return ok(amtError.render());
    }

    if (loginForm.hasErrors()) {
      Logger.debug(""loginForm.hasErrors()"");
      return badRequest(amtClientLogin.render(Experiment.findById(experimentId), experimentInstance, hitId, assignmentId, workerId, Form.form(AMTLogin.class)));
    } else {
      // If the game has already started, they can't join.
      if (Boolean.TRUE.equals(ExperimentInstance.findById(experimentInstanceId).hasStarted) && (workerId == null || (!amtHit.hasWorker(workerId)))) {
        Logger.debug(""Got to amtAuthenticate -> amtGameStarted, workerId = "" + workerId + "", AMTWorker.countByWorkerId(workerId) = "" + AMTWorker.countByWorkerId(workerId));
        return ok(amtGameStarted.render());
      }

      Logger.debug(""! loginForm.hasErrors()"");
      String clientId = assignmentId;
      if (!amtHit.hasWorker(workerId)) {
        AMTWorker amtWorker = new AMTWorker();
        amtWorker.workerId = workerId;
        amtHit.amtWorkers.add(amtWorker);
        amtHit.save();
      }
      return redirect(routes.ClientController.index(experimentId.toString(), experimentInstanceId.toString(), clientId, connectionSpeed));
    }
  }

  public static Result authenticate(String experimentId, String experimentInstanceId) {
    Form<CLogin> loginForm = Form.form(CLogin.class).bindFromRequest();

    if (loginForm.hasErrors()) {
      Logger.debug(""loginForm.hasErrors()"");
      return badRequest(clientLogin.render(experimentId, experimentInstanceId, loginForm));
    } else {
      Logger.debug(""! loginForm.hasErrors()"");
      String clientId = loginForm.get().id;
      return redirect(routes.ClientController.index(experimentId, experimentInstanceId, clientId, null));
    }
  }

  /**
   * Handle the script websocket.
   */
  public static WebSocket<JsonNode> connect() {
    return new WebSocket<JsonNode>() {
      // Called when the Websocket Handshake is done.
      public void onReady(final WebSocket.In<JsonNode> in, final WebSocket.Out<JsonNode> out) {
        try {
          //TODO
          //ScriptBoard.connect(in, out);
        } catch (Exception ex) {
          ex.printStackTrace();
        }
      }
    };
  }

}
","package controllers; public class ClientLogin extends Controller { public static class AMTLogin { public Long experimentId; public Long experimentInstanceId; public String hitId; public String assignmentId; public String workerId; public String connectionSpeed; public String validate() { return null; } } public static class CLogin { public String id; public String password; public String experimentId; public String experimentInstanceId; public String validate() { if (!ScriptBoard.checkPassword(password)) { return ""Invalid user or password""; } return null; } } public static Result login(String experimentId, String experimentInstanceId) { return ok(clientLogin.render(experimentId, experimentInstanceId, Form.form(CLogin.class))); } public static Result amtLogin(Long experimentId, Long experimentInstanceId, String hitId, String assignmentId, String workerId) { Experiment experiment = Experiment.findById(experimentId); ExperimentInstance experimentInstance = ExperimentInstance.findById(experimentInstanceId); AMTHit amtHit = experimentInstance.getHit(); if (experiment == null || experimentInstance == null || experimentInstance.status != ExperimentInstance.Status.RUNNING) { return ok(amtError.render()); } if (Boolean.TRUE.equals(experimentInstance.hasStarted) && (workerId == null || (!amtHit.hasWorker(workerId)))) { return ok(amtGameStarted.render()); } if (experimentInstance.getHit() != null) { if (amtHit != null) { if (amtHit.isExtended()) { return ok(amtExtended.render(Experiment.findById(experimentId), ExperimentInstance.findById(experimentInstanceId), hitId, assignmentId, workerId, Form.form(AMTLogin.class))); } if (""any"".equals(amtHit.disallowPrevious)) { int rowCount = AMTAssignment.findRowCountByWorkerId(workerId); if (rowCount > 0) { return ok(amtPreviousWorker.render()); } } if (""type"".equals(amtHit.disallowPrevious)) { String sql
              = "" select a.worker_id ""
              + "" from amt_assignments a ""
              + "" join amt_hits h on a.amt_hit_id = h.id""
              + "" join experiment_instances i on h.experiment_instance_id = i.id""
              + "" join experiments e on i.experiment_id = e.id""
              + "" where e.id = :eid""
              + "" and a.worker_id = :wid""
              + "" and a.assignment_completed = 1""; SqlQuery sqlQuery = Ebean.createSqlQuery(sql); sqlQuery.setParameter(""eid"", experimentId); sqlQuery.setParameter(""wid"", workerId); List<SqlRow> list = sqlQuery.findList(); if (list.size() > 0) { return ok(amtPreviousWorker.render()); } } } } return ok(amtClientLogin.render(Experiment.findById(experimentId), ExperimentInstance.findById(experimentInstanceId), hitId, assignmentId, workerId, Form.form(AMTLogin.class))); } public static Result dummyHit(String assignmentId, String sandboxString) { boolean sandbox = false; if (sandboxString != null && sandboxString.equals(""true"")) { sandbox = true; } return ok(amtDummy.render(assignmentId, sandbox)); } public static Result amtAuthenticate(Long experimentId, Long experimentInstanceId, String hitId, String assignmentId, String workerId) { Form<AMTLogin> loginForm = Form.form(AMTLogin.class).bindFromRequest(); String connectionSpeed = loginForm.get().connectionSpeed; ExperimentInstance experimentInstance = ExperimentInstance.findById(experimentInstanceId); Experiment experiment = Experiment.findById(experimentId); if (experimentInstance == null || experiment == null || experimentInstance.status != ExperimentInstance.Status.RUNNING) { return ok(amtError.render()); } AMTHit amtHit = null; if (experimentInstance.getHit() != null) { amtHit = experimentInstance.getHit(); } if (amtHit == null) { return ok(amtError.render()); } if (loginForm.hasErrors()) { return badRequest(amtClientLogin.render(Experiment.findById(experimentId), experimentInstance, hitId, assignmentId, workerId, Form.form(AMTLogin.class))); } else { if (Boolean.TRUE.equals(ExperimentInstance.findById(experimentInstanceId).hasStarted) && (workerId == null || (!amtHit.hasWorker(workerId)))) { return ok(amtGameStarted.render()); } String clientId = assignmentId; if (!amtHit.hasWorker(workerId)) { AMTWorker amtWorker = new AMTWorker(); amtWorker.workerId = workerId; amtHit.amtWorkers.add(amtWorker); amtHit.save(); } return redirect(routes.ClientController.index(experimentId.toString(), experimentInstanceId.toString(), clientId, connectionSpeed)); } } public static Result authenticate(String experimentId, String experimentInstanceId) { Form<CLogin> loginForm = Form.form(CLogin.class).bindFromRequest(); if (loginForm.hasErrors()) { return badRequest(clientLogin.render(experimentId, experimentInstanceId, loginForm)); } else { String clientId = loginForm.get().id; return redirect(routes.ClientController.index(experimentId, experimentInstanceId, clientId, null)); } } public static WebSocket<JsonNode> connect() { return new WebSocket<JsonNode>() { public void onReady(final WebSocket.In<JsonNode> in, final WebSocket.Out<JsonNode> out) { try { } catch (Exception ex) { ex.printStackTrace(); } } } ; } }",0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package controllers; public class ClientLogin extends Controller { public static class AMTLogin { public Long experimentId; public Long experimentInstanceId; public String hitId; public String assignmentId; public String workerId; public String connectionSpeed; public String validate() { <FILL_ME> <FILL_ME> return null; } <FILL_ME> } public static class CLogin { public String id; public String password; public String experimentId; public String experimentInstanceId; public String validate() { if (!ScriptBoard.checkPassword(password)) { return ""Invalid user or password""; } return null; } } public static Result login(String experimentId, String experimentInstanceId) { return ok(clientLogin.render(experimentId, experimentInstanceId, Form.form(CLogin.class))); } public static Result amtLogin(Long experimentId, Long experimentInstanceId, String hitId, String assignmentId, String workerId) { Experiment experiment = Experiment.findById(experimentId); ExperimentInstance experimentInstance = ExperimentInstance.findById(experimentInstanceId); AMTHit amtHit = experimentInstance.getHit(); if (experiment == null || experimentInstance == null || experimentInstance.status != ExperimentInstance.Status.RUNNING) { return ok(amtError.render()); } if (Boolean.TRUE.equals(experimentInstance.hasStarted) && (workerId == null || (!amtHit.hasWorker(workerId)))) { return ok(amtGameStarted.render()); } if (experimentInstance.getHit() != null) { if (amtHit != null) { if (amtHit.isExtended()) { return ok(amtExtended.render(Experiment.findById(experimentId), ExperimentInstance.findById(experimentInstanceId), hitId, assignmentId, workerId, Form.form(AMTLogin.class))); } if (""any"".equals(amtHit.disallowPrevious)) { int rowCount = AMTAssignment.findRowCountByWorkerId(workerId); if (rowCount > 0) { return ok(amtPreviousWorker.render()); } } if (""type"".equals(amtHit.disallowPrevious)) { String sql
              = "" select a.worker_id ""
              + "" from amt_assignments a ""
              + "" join amt_hits h on a.amt_hit_id = h.id""
              + "" join experiment_instances i on h.experiment_instance_id = i.id""
              + "" join experiments e on i.experiment_id = e.id""
              + "" where e.id = :eid""
              + "" and a.worker_id = :wid""
              + "" and a.assignment_completed = 1""; SqlQuery sqlQuery = Ebean.createSqlQuery(sql); sqlQuery.setParameter(""eid"", experimentId); sqlQuery.setParameter(""wid"", workerId); List<SqlRow> list = sqlQuery.findList(); if (list.size() > 0) { return ok(amtPreviousWorker.render()); } } } } return ok(amtClientLogin.render(Experiment.findById(experimentId), ExperimentInstance.findById(experimentInstanceId), hitId, assignmentId, workerId, Form.form(AMTLogin.class))); } public static Result dummyHit(String assignmentId, String sandboxString) { boolean sandbox = false; if (sandboxString != null && sandboxString.equals(""true"")) { sandbox = true; } return ok(amtDummy.render(assignmentId, sandbox)); } public static Result amtAuthenticate(Long experimentId, Long experimentInstanceId, String hitId, String assignmentId, String workerId) { Form<AMTLogin> loginForm = Form.form(AMTLogin.class).bindFromRequest(); String connectionSpeed = loginForm.get().connectionSpeed; ExperimentInstance experimentInstance = ExperimentInstance.findById(experimentInstanceId); Experiment experiment = Experiment.findById(experimentId); if (experimentInstance == null || experiment == null || experimentInstance.status != ExperimentInstance.Status.RUNNING) { return ok(amtError.render()); } AMTHit amtHit = null; if (experimentInstance.getHit() != null) { amtHit = experimentInstance.getHit(); } if (amtHit == null) { return ok(amtError.render()); } if (loginForm.hasErrors()) { <FILL_ME> <FILL_ME> return badRequest(amtClientLogin.render(Experiment.findById(experimentId), experimentInstance, hitId, assignmentId, workerId, Form.form(AMTLogin.class))); } else { <FILL_ME> if (Boolean.TRUE.equals(ExperimentInstance.findById(experimentInstanceId).hasStarted) && (workerId == null || (!amtHit.hasWorker(workerId)))) { <FILL_ME> return ok(amtGameStarted.render()); } String clientId = assignmentId; if (!amtHit.hasWorker(workerId)) { AMTWorker amtWorker = new AMTWorker(); amtWorker.workerId = workerId; amtHit.amtWorkers.add(amtWorker); amtHit.save(); } return redirect(routes.ClientController.index(experimentId.toString(), experimentInstanceId.toString(), clientId, connectionSpeed)); } } public static Result authenticate(String experimentId, String experimentInstanceId) { Form<CLogin> loginForm = Form.form(CLogin.class).bindFromRequest(); if (loginForm.hasErrors()) { return badRequest(clientLogin.render(experimentId, experimentInstanceId, loginForm)); } else { String clientId = loginForm.get().id; return redirect(routes.ClientController.index(experimentId, experimentInstanceId, clientId, null)); } } public static WebSocket<JsonNode> connect() { return new WebSocket<JsonNode>() { public void onReady(final WebSocket.In<JsonNode> in, final WebSocket.Out<JsonNode> out) { try { } catch (Exception ex) { ex.printStackTrace(); } } } ; } } ","package controllers; 
import com.avaje.ebean.Ebean; import com.avaje.ebean.SqlQuery; import com.avaje.ebean.SqlRow; import com.fasterxml.jackson.databind.JsonNode; import models.*; import play.Logger; import play.data.Form; import play.mvc.Controller; import play.mvc.Result; import play.mvc.WebSocket; import views.html.*; import java.util.List;  public class ClientLogin extends Controller { public static class AMTLogin { public Long experimentId; public Long experimentInstanceId; public String hitId; public String assignmentId; public String workerId; public String connectionSpeed;  public String validate() { <FILL_ME> <FILL_ME> // TODO: save hitId with ExperimentInstance when creating it, then validate here. return null; } <FILL_ME> }  public static class CLogin { public String id; public String password; public String experimentId; public String experimentInstanceId;  public String validate() {  // TODO: make password a groovy closure to allow for hash functions or custom passwords if (!ScriptBoard.checkPassword(password)) { return ""Invalid user or password""; } return null; } }  public static Result login(String experimentId, String experimentInstanceId) { return ok(clientLogin.render(experimentId, experimentInstanceId, Form.form(CLogin.class))); }  public static Result amtLogin(Long experimentId, Long experimentInstanceId, String hitId, String assignmentId, String workerId) { Experiment experiment = Experiment.findById(experimentId); ExperimentInstance experimentInstance = ExperimentInstance.findById(experimentInstanceId); AMTHit amtHit = experimentInstance.getHit();  if (experiment == null || experimentInstance == null || experimentInstance.status != ExperimentInstance.Status.RUNNING) { return ok(amtError.render()); }  if (Boolean.TRUE.equals(experimentInstance.hasStarted) && (workerId == null || (!amtHit.hasWorker(workerId)))) { return ok(amtGameStarted.render()); }  if (experimentInstance.getHit() != null) { if (amtHit != null) { if (amtHit.isExtended()) { return ok(amtExtended.render(Experiment.findById(experimentId), ExperimentInstance.findById(experimentInstanceId), hitId, assignmentId, workerId, Form.form(AMTLogin.class))); }  if (""any"".equals(amtHit.disallowPrevious)) { int rowCount = AMTAssignment.findRowCountByWorkerId(workerId); if (rowCount > 0) { return ok(amtPreviousWorker.render()); } } // if (""any"".equals(amtHit.disallowPrevious)) {  if (""type"".equals(amtHit.disallowPrevious)) { String sql
              = "" select a.worker_id ""
              + "" from amt_assignments a ""
              + "" join amt_hits h on a.amt_hit_id = h.id""
              + "" join experiment_instances i on h.experiment_instance_id = i.id""
              + "" join experiments e on i.experiment_id = e.id""
              + "" where e.id = :eid""
              + "" and a.worker_id = :wid""
              + "" and a.assignment_completed = 1"";  SqlQuery sqlQuery = Ebean.createSqlQuery(sql); sqlQuery.setParameter(""eid"", experimentId); sqlQuery.setParameter(""wid"", workerId);  List<SqlRow> list = sqlQuery.findList();  if (list.size() > 0) { return ok(amtPreviousWorker.render()); } } // if (""type"".equals(amtHit.disallowPrevious)) { } // if (amtHit != null) { } // if (experimentInstance.getHit() != null) { return ok(amtClientLogin.render(Experiment.findById(experimentId), ExperimentInstance.findById(experimentInstanceId), hitId, assignmentId, workerId, Form.form(AMTLogin.class))); }  public static Result dummyHit(String assignmentId, String sandboxString) { boolean sandbox = false; if (sandboxString != null && sandboxString.equals(""true"")) { sandbox = true; } return ok(amtDummy.render(assignmentId, sandbox)); }  public static Result amtAuthenticate(Long experimentId, Long experimentInstanceId, String hitId, String assignmentId, String workerId) { //Logger.info(""Got to amtAuthenticate.""); Form<AMTLogin> loginForm = Form.form(AMTLogin.class).bindFromRequest(); String connectionSpeed = loginForm.get().connectionSpeed;  ExperimentInstance experimentInstance = ExperimentInstance.findById(experimentInstanceId); Experiment experiment = Experiment.findById(experimentId); if (experimentInstance == null || experiment == null || experimentInstance.status != ExperimentInstance.Status.RUNNING) { return ok(amtError.render()); }  AMTHit amtHit = null; if (experimentInstance.getHit() != null) { amtHit = experimentInstance.getHit(); }  if (amtHit == null) { return ok(amtError.render()); }  if (loginForm.hasErrors()) { <FILL_ME> <FILL_ME> return badRequest(amtClientLogin.render(Experiment.findById(experimentId), experimentInstance, hitId, assignmentId, workerId, Form.form(AMTLogin.class))); } else { <FILL_ME> // If the game has already started, they can't join. if (Boolean.TRUE.equals(ExperimentInstance.findById(experimentInstanceId).hasStarted) && (workerId == null || (!amtHit.hasWorker(workerId)))) { <FILL_ME> return ok(amtGameStarted.render()); }  String clientId = assignmentId; if (!amtHit.hasWorker(workerId)) { AMTWorker amtWorker = new AMTWorker(); amtWorker.workerId = workerId; amtHit.amtWorkers.add(amtWorker); amtHit.save(); } return redirect(routes.ClientController.index(experimentId.toString(), experimentInstanceId.toString(), clientId, connectionSpeed)); } }  public static Result authenticate(String experimentId, String experimentInstanceId) { Form<CLogin> loginForm = Form.form(CLogin.class).bindFromRequest();  if (loginForm.hasErrors()) { return badRequest(clientLogin.render(experimentId, experimentInstanceId, loginForm)); } else { String clientId = loginForm.get().id; return redirect(routes.ClientController.index(experimentId, experimentInstanceId, clientId, null)); } }  /**
   * Handle the script websocket.
   */ public static WebSocket<JsonNode> connect() { return new WebSocket<JsonNode>() { // Called when the Websocket Handshake is done. public void onReady(final WebSocket.In<JsonNode> in, final WebSocket.Out<JsonNode> out) { try { //TODO //ScriptBoard.connect(in, out); } catch (Exception ex) { ex.printStackTrace(); } } } ; }  }  "
app/controllers/ContentController.java,"package controllers;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.google.gson.Gson;
import models.Content;
import models.Experiment;
import models.Translation;
import play.libs.Json;
import play.mvc.Controller;
import play.mvc.Result;
import play.mvc.Security;

import java.util.List;

public class ContentController extends Controller {

  @Security.Authenticated(Secured.class)
  public static Result getContent(Long experimentId) {
    Experiment experiment = Experiment.findById(experimentId);
    if(experiment == null) {
      return badRequest(""Invalid Experiment ID"");
    }

    ObjectNode returnJson = Json.newObject();

    ArrayNode jsonSteps = returnJson.putArray(""content"");
    for (Content c : experiment.getContent()) {
      jsonSteps.add(c.toJson());
    }

    return ok(returnJson);
  }

  @Security.Authenticated(Secured.class)
  public static Result deleteContent(Long contentId) {
    Content content = Content.findById(contentId);
    if (content == null) {
      return badRequest(""Invalid Content ID"");
    }
    content.delete();
    return ok();
  }

  @Security.Authenticated(Secured.class)
  public static Result updateContent(Long contentId) {
    Gson gson = new Gson();
    Content content;
    Experiment experiment;
    String name;
    Long experimentId;
    List<Translation> translations;

    JsonNode json = request().body().asJson();
    if(json == null) {
      return badRequest(""Expecting Json data"");
    } else {
      UpdateContentObject updateContentObject = gson.fromJson(json.toString(), UpdateContentObject.class);
      name = updateContentObject.name;
      experimentId = updateContentObject.experimentId;
      translations = updateContentObject.translations;
    }

    experiment = Experiment.findById(experimentId);

    if (experiment == null) {
      return badRequest(""Invalid experiment ID."");
    }

    if (name == null) {
      return badRequest(""Please provide content name."");
    }

    Boolean isNewContent = (contentId == -1);
    if (isNewContent) {
      content = new Content();
    } else {
      content = experiment.getExperimentContent(contentId);
    }

    if (content == null) {
      return badRequest(""Invalid Content ID"");
    }

    content.name = name;

    if (translations != null) {
      // Create or update translations
      for (Translation t : translations) {
        Translation translation;
        Boolean isNewTranslation = false;
        if (t.id == -1) {
          // New translation
          isNewTranslation = true;
          translation = new Translation();
        } else {
          translation = Translation.findById(t.id);
        }

        if (translation == null) {
          return badRequest(""Invalid translation ID."");
        }

        translation.setLanguage(t.getLanguage());
        translation.setHtml(t.getHtml());

        if (isNewTranslation) {
          content.translations.add(translation);
        } else {
          translation.update();
        }
      }
    }

    if (isNewContent) {
      experiment.content.add(content);
    }
    experiment.save();

    Content returnContent = Content.findById(content.id);
    return ok(returnContent.toJson());
  }

  private class UpdateContentObject {
    public UpdateContentObject() {}
    public Long experimentId;
    public String name;
    public List<Translation> translations;
  }

}
","package controllers; public class ContentController extends Controller { @Security.Authenticated(Secured.class)
  public static Result getContent(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if(experiment == null) { return badRequest(""Invalid Experiment ID""); } ObjectNode returnJson = Json.newObject(); ArrayNode jsonSteps = returnJson.putArray(""content""); for (Content c : experiment.getContent()) { jsonSteps.add(c.toJson()); } return ok(returnJson); } @Security.Authenticated(Secured.class)
  public static Result deleteContent(Long contentId) { Content content = Content.findById(contentId); if (content == null) { return badRequest(""Invalid Content ID""); } content.delete(); return ok(); } @Security.Authenticated(Secured.class)
  public static Result updateContent(Long contentId) { Gson gson = new Gson(); Content content; Experiment experiment; String name; Long experimentId; List<Translation> translations; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { UpdateContentObject updateContentObject = gson.fromJson(json.toString(), UpdateContentObject.class); name = updateContentObject.name; experimentId = updateContentObject.experimentId; translations = updateContentObject.translations; } experiment = Experiment.findById(experimentId); if (experiment == null) { return badRequest(""Invalid experiment ID.""); } if (name == null) { return badRequest(""Please provide content name.""); } Boolean isNewContent = (contentId == -1); if (isNewContent) { content = new Content(); } else { content = experiment.getExperimentContent(contentId); } if (content == null) { return badRequest(""Invalid Content ID""); } content.name = name; if (translations != null) { for (Translation t : translations) { Translation translation; Boolean isNewTranslation = false; if (t.id == -1) { isNewTranslation = true; translation = new Translation(); } else { translation = Translation.findById(t.id); } if (translation == null) { return badRequest(""Invalid translation ID.""); } translation.setLanguage(t.getLanguage()); translation.setHtml(t.getHtml()); if (isNewTranslation) { content.translations.add(translation); } else { translation.update(); } } } if (isNewContent) { experiment.content.add(content); } experiment.save(); Content returnContent = Content.findById(content.id); return ok(returnContent.toJson()); } private class UpdateContentObject { public UpdateContentObject() { } public Long experimentId; public String name; public List<Translation> translations; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package controllers; public class ContentController extends Controller { @Security.Authenticated(Secured.class)
  public static Result getContent(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if(experiment == null) { return badRequest(""Invalid Experiment ID""); } ObjectNode returnJson = Json.newObject(); ArrayNode jsonSteps = returnJson.putArray(""content""); for (Content c : experiment.getContent()) { jsonSteps.add(c.toJson()); } return ok(returnJson); } @Security.Authenticated(Secured.class)
  public static Result deleteContent(Long contentId) { Content content = Content.findById(contentId); if (content == null) { return badRequest(""Invalid Content ID""); } content.delete(); return ok(); } @Security.Authenticated(Secured.class)
  public static Result updateContent(Long contentId) { Gson gson = new Gson(); Content content; Experiment experiment; String name; Long experimentId; List<Translation> translations; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { UpdateContentObject updateContentObject = gson.fromJson(json.toString(), UpdateContentObject.class); name = updateContentObject.name; experimentId = updateContentObject.experimentId; translations = updateContentObject.translations; } experiment = Experiment.findById(experimentId); if (experiment == null) { return badRequest(""Invalid experiment ID.""); } if (name == null) { return badRequest(""Please provide content name.""); } Boolean isNewContent = (contentId == -1); if (isNewContent) { content = new Content(); } else { content = experiment.getExperimentContent(contentId); } if (content == null) { return badRequest(""Invalid Content ID""); } content.name = name; if (translations != null) { for (Translation t : translations) { Translation translation; Boolean isNewTranslation = false; if (t.id == -1) { isNewTranslation = true; translation = new Translation(); } else { translation = Translation.findById(t.id); } if (translation == null) { return badRequest(""Invalid translation ID.""); } translation.setLanguage(t.getLanguage()); translation.setHtml(t.getHtml()); if (isNewTranslation) { content.translations.add(translation); } else { translation.update(); } } } if (isNewContent) { experiment.content.add(content); } experiment.save(); Content returnContent = Content.findById(content.id); return ok(returnContent.toJson()); } private class UpdateContentObject { public UpdateContentObject() { } public Long experimentId; public String name; public List<Translation> translations; } } ","package controllers; 
import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.node.ArrayNode; import com.fasterxml.jackson.databind.node.ObjectNode; import com.google.gson.Gson; import models.Content; import models.Experiment; import models.Translation; import play.libs.Json; import play.mvc.Controller; import play.mvc.Result; import play.mvc.Security; 
import java.util.List;  public class ContentController extends Controller {  @Security.Authenticated(Secured.class)
  public static Result getContent(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if(experiment == null) { return badRequest(""Invalid Experiment ID""); }  ObjectNode returnJson = Json.newObject();  ArrayNode jsonSteps = returnJson.putArray(""content""); for (Content c : experiment.getContent()) { jsonSteps.add(c.toJson()); }  return ok(returnJson); }  @Security.Authenticated(Secured.class)
  public static Result deleteContent(Long contentId) { Content content = Content.findById(contentId); if (content == null) { return badRequest(""Invalid Content ID""); } content.delete(); return ok(); }  @Security.Authenticated(Secured.class)
  public static Result updateContent(Long contentId) { Gson gson = new Gson(); Content content; Experiment experiment; String name; Long experimentId; List<Translation> translations;  JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { UpdateContentObject updateContentObject = gson.fromJson(json.toString(), UpdateContentObject.class); name = updateContentObject.name; experimentId = updateContentObject.experimentId; translations = updateContentObject.translations; }  experiment = Experiment.findById(experimentId);  if (experiment == null) { return badRequest(""Invalid experiment ID.""); }  if (name == null) { return badRequest(""Please provide content name.""); }  Boolean isNewContent = (contentId == -1); if (isNewContent) { content = new Content(); } else { content = experiment.getExperimentContent(contentId); }  if (content == null) { return badRequest(""Invalid Content ID""); }  content.name = name;  if (translations != null) { // Create or update translations for (Translation t : translations) { Translation translation; Boolean isNewTranslation = false; if (t.id == -1) { // New translation isNewTranslation = true; translation = new Translation(); } else { translation = Translation.findById(t.id); }  if (translation == null) { return badRequest(""Invalid translation ID.""); }  translation.setLanguage(t.getLanguage()); translation.setHtml(t.getHtml());  if (isNewTranslation) { content.translations.add(translation); } else { translation.update(); } } }  if (isNewContent) { experiment.content.add(content); } experiment.save();  Content returnContent = Content.findById(content.id); return ok(returnContent.toJson()); }  private class UpdateContentObject { public UpdateContentObject() { } public Long experimentId; public String name; public List<Translation> translations; }  }  "
app/controllers/CustomizeController.java,"package controllers;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import models.Experiment;
import play.libs.Json;
import play.mvc.Controller;
import play.mvc.Result;
import play.mvc.Security;

public class CustomizeController extends Controller {

  @Security.Authenticated(Secured.class)
  public static Result getClientHtml(Long experimentId) {
    Experiment experiment = Experiment.findById(experimentId);
    if(experiment == null) {
      return badRequest(""Invalid Experiment ID"");
    }

    ObjectNode returnJson = Json.newObject();
    returnJson.put(""clientHtml"", experiment.getClientHtml());
    return ok(returnJson);
  }

  @Security.Authenticated(Secured.class)
  public static Result getClientGraph(Long experimentId) {
    Experiment experiment = Experiment.findById(experimentId);
    if(experiment == null) {
      return badRequest(""Invalid Experiment ID"");
    }

    ObjectNode returnJson = Json.newObject();
    returnJson.put(""clientGraph"", experiment.getClientGraph());
    return ok(returnJson);
  }

  @Security.Authenticated(Secured.class)
  public static Result getStyle(Long experimentId) {
    Experiment experiment = Experiment.findById(experimentId);
    if(experiment == null) {
      return badRequest(""Invalid Experiment ID"");
    }

    ObjectNode returnJson = Json.newObject();
    returnJson.put(""style"", experiment.getStyle());
    return ok(returnJson);
  }

  @Security.Authenticated(Secured.class)
  public static Result updateClientHtml(Long experimentId) {
    Experiment experiment = Experiment.findById(experimentId);

    if(experiment == null) {
      return badRequest(""Invalid Experiment ID"");
    }

    String clientHtml;
    JsonNode json = request().body().asJson();
    if(json == null) {
      return badRequest(""Expecting Json data"");
    } else {
      clientHtml = json.findPath(""clientHtml"").textValue();
    }

    if (clientHtml == null) {
      return badRequest(""Please provide client HTML."");
    }

    experiment.setClientHtml(clientHtml);
    experiment.save();

    return ok();
  }

  @Security.Authenticated(Secured.class)
  public static Result updateClientGraph(Long experimentId) {
    Experiment experiment = Experiment.findById(experimentId);
    if(experiment == null) {
      return badRequest(""Invalid Experiment ID"");
    }

    String clientGraph;
    JsonNode json = request().body().asJson();
    if(json == null) {
      return badRequest(""Expecting Json data"");
    } else {
      clientGraph = json.findPath(""clientGraph"").textValue();
    }

    if (clientGraph == null) {
      return badRequest(""Please provide client graph."");
    }

    experiment.setClientGraph(clientGraph);
    experiment.save();

    return ok();
  }

  @Security.Authenticated(Secured.class)
  public static Result updateStyle(Long experimentId) {
    Experiment experiment = Experiment.findById(experimentId);
    if(experiment == null) {
      return badRequest(""Invalid Experiment ID"");
    }

    String style;
    JsonNode json = request().body().asJson();
    if(json == null) {
      return badRequest(""Expecting Json data"");
    } else {
      style = json.findPath(""style"").textValue();
    }

    if (style == null) {
      return badRequest(""Please provide style."");
    }

    experiment.setStyle(style);
    experiment.save();

    return ok();
  }

}
","package controllers; public class CustomizeController extends Controller { @Security.Authenticated(Secured.class)
  public static Result getClientHtml(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if(experiment == null) { return badRequest(""Invalid Experiment ID""); } ObjectNode returnJson = Json.newObject(); returnJson.put(""clientHtml"", experiment.getClientHtml()); return ok(returnJson); } @Security.Authenticated(Secured.class)
  public static Result getClientGraph(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if(experiment == null) { return badRequest(""Invalid Experiment ID""); } ObjectNode returnJson = Json.newObject(); returnJson.put(""clientGraph"", experiment.getClientGraph()); return ok(returnJson); } @Security.Authenticated(Secured.class)
  public static Result getStyle(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if(experiment == null) { return badRequest(""Invalid Experiment ID""); } ObjectNode returnJson = Json.newObject(); returnJson.put(""style"", experiment.getStyle()); return ok(returnJson); } @Security.Authenticated(Secured.class)
  public static Result updateClientHtml(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if(experiment == null) { return badRequest(""Invalid Experiment ID""); } String clientHtml; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { clientHtml = json.findPath(""clientHtml"").textValue(); } if (clientHtml == null) { return badRequest(""Please provide client HTML.""); } experiment.setClientHtml(clientHtml); experiment.save(); return ok(); } @Security.Authenticated(Secured.class)
  public static Result updateClientGraph(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if(experiment == null) { return badRequest(""Invalid Experiment ID""); } String clientGraph; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { clientGraph = json.findPath(""clientGraph"").textValue(); } if (clientGraph == null) { return badRequest(""Please provide client graph.""); } experiment.setClientGraph(clientGraph); experiment.save(); return ok(); } @Security.Authenticated(Secured.class)
  public static Result updateStyle(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if(experiment == null) { return badRequest(""Invalid Experiment ID""); } String style; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { style = json.findPath(""style"").textValue(); } if (style == null) { return badRequest(""Please provide style.""); } experiment.setStyle(style); experiment.save(); return ok(); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package controllers; public class CustomizeController extends Controller { @Security.Authenticated(Secured.class)
  public static Result getClientHtml(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if(experiment == null) { return badRequest(""Invalid Experiment ID""); } ObjectNode returnJson = Json.newObject(); returnJson.put(""clientHtml"", experiment.getClientHtml()); return ok(returnJson); } @Security.Authenticated(Secured.class)
  public static Result getClientGraph(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if(experiment == null) { return badRequest(""Invalid Experiment ID""); } ObjectNode returnJson = Json.newObject(); returnJson.put(""clientGraph"", experiment.getClientGraph()); return ok(returnJson); } @Security.Authenticated(Secured.class)
  public static Result getStyle(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if(experiment == null) { return badRequest(""Invalid Experiment ID""); } ObjectNode returnJson = Json.newObject(); returnJson.put(""style"", experiment.getStyle()); return ok(returnJson); } @Security.Authenticated(Secured.class)
  public static Result updateClientHtml(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if(experiment == null) { return badRequest(""Invalid Experiment ID""); } String clientHtml; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { clientHtml = json.findPath(""clientHtml"").textValue(); } if (clientHtml == null) { return badRequest(""Please provide client HTML.""); } experiment.setClientHtml(clientHtml); experiment.save(); return ok(); } @Security.Authenticated(Secured.class)
  public static Result updateClientGraph(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if(experiment == null) { return badRequest(""Invalid Experiment ID""); } String clientGraph; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { clientGraph = json.findPath(""clientGraph"").textValue(); } if (clientGraph == null) { return badRequest(""Please provide client graph.""); } experiment.setClientGraph(clientGraph); experiment.save(); return ok(); } @Security.Authenticated(Secured.class)
  public static Result updateStyle(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if(experiment == null) { return badRequest(""Invalid Experiment ID""); } String style; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { style = json.findPath(""style"").textValue(); } if (style == null) { return badRequest(""Please provide style.""); } experiment.setStyle(style); experiment.save(); return ok(); } } ","package controllers; 
import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.node.ObjectNode; import models.Experiment; import play.libs.Json; import play.mvc.Controller; import play.mvc.Result; import play.mvc.Security;  public class CustomizeController extends Controller {  @Security.Authenticated(Secured.class)
  public static Result getClientHtml(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if(experiment == null) { return badRequest(""Invalid Experiment ID""); }  ObjectNode returnJson = Json.newObject(); returnJson.put(""clientHtml"", experiment.getClientHtml()); return ok(returnJson); }  @Security.Authenticated(Secured.class)
  public static Result getClientGraph(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if(experiment == null) { return badRequest(""Invalid Experiment ID""); }  ObjectNode returnJson = Json.newObject(); returnJson.put(""clientGraph"", experiment.getClientGraph()); return ok(returnJson); }  @Security.Authenticated(Secured.class)
  public static Result getStyle(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if(experiment == null) { return badRequest(""Invalid Experiment ID""); }  ObjectNode returnJson = Json.newObject(); returnJson.put(""style"", experiment.getStyle()); return ok(returnJson); }  @Security.Authenticated(Secured.class)
  public static Result updateClientHtml(Long experimentId) { Experiment experiment = Experiment.findById(experimentId);  if(experiment == null) { return badRequest(""Invalid Experiment ID""); }  String clientHtml; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { clientHtml = json.findPath(""clientHtml"").textValue(); }  if (clientHtml == null) { return badRequest(""Please provide client HTML.""); }  experiment.setClientHtml(clientHtml); experiment.save();  return ok(); }  @Security.Authenticated(Secured.class)
  public static Result updateClientGraph(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if(experiment == null) { return badRequest(""Invalid Experiment ID""); }  String clientGraph; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { clientGraph = json.findPath(""clientGraph"").textValue(); }  if (clientGraph == null) { return badRequest(""Please provide client graph.""); }  experiment.setClientGraph(clientGraph); experiment.save();  return ok(); }  @Security.Authenticated(Secured.class)
  public static Result updateStyle(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if(experiment == null) { return badRequest(""Invalid Experiment ID""); }  String style; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { style = json.findPath(""style"").textValue(); }  if (style == null) { return badRequest(""Please provide style.""); }  experiment.setStyle(style); experiment.save();  return ok(); }  }  "
app/controllers/D3Utils.java,"package controllers;

import com.fasterxml.jackson.databind.node.ObjectNode;
import com.tinkerpop.blueprints.Direction;
import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Graph;
import com.tinkerpop.blueprints.Vertex;
import play.libs.Json;
import java.util.ArrayList;
import java.util.HashMap;

public class D3Utils {
  public static ObjectNode graphToJsonString(Graph graph) {
    ArrayList<Vertex> vertices = new ArrayList<>();
    ArrayList<Edge> edges = new ArrayList<>();

    for (Vertex v : graph.getVertices())
      vertices.add(v);

    for (Edge e : graph.getEdges())
      edges.add(e);

    return toJsonString(vertices, edges);
  }

  public static ObjectNode toJsonString(ArrayList<Vertex> vertices, ArrayList<Edge> edges) {
    ArrayList<HashMap<String, Object>> nodes = new ArrayList<>();

    for (int i = 0; i < vertices.size(); i++) {
      Vertex v = vertices.get(i);

      HashMap<String, Object> n = new HashMap<>();
      n.put(""id"", v.getId().toString());

      // TODO: Make this thread safe, the Vertex's properties may be modified during the execution of the loop
      // Will copying the property keys to an array solve the Concurrent Modification problem?
      String[] propertyKeyArray = v.getPropertyKeys().toArray(new String[0]);
      ArrayList<String> ignoreKeys = new ArrayList<>();

      for (String key : propertyKeyArray) {
        if (ignoreKeys.indexOf(key) < 0) {
          n.put(key, Json.toJson(v.getProperty(key)));
        }
      }

      nodes.add(n);
    }

    ArrayList<HashMap<String, Object>> links = new ArrayList<>();

    for (Edge e : edges) {
      if (e.getLabel().equals(""connected"")) {
        HashMap<String, Object> l = new HashMap<>();
        l.put(""id"", Integer.parseInt(e.getId().toString()));
        l.put(""name"", e.getLabel());

        l.put(""source"", indexOfNode(e.getVertex(Direction.IN).getId().toString(), nodes));
        l.put(""target"", indexOfNode(e.getVertex(Direction.OUT).getId().toString(), nodes));

        for (String key : e.getPropertyKeys()) {
          l.put(key, e.getProperty(key));
        }

        if (l.get(""source"") == null || l.get(""target"") == null)
          System.out.println(""source or target is null"");
        else
          links.add(l);
      }
    }

    ObjectNode rootNode = Json.newObject();
    rootNode.put(""nodes"", Json.toJson(nodes));
    rootNode.put(""links"", Json.toJson(links));

    return rootNode;
  }

  private static int indexOfNode(String nodeId, ArrayList<HashMap<String, Object>> nodes) {
    for (int i = 0; i < nodes.size(); i++) {
      if (nodes.get(i).get(""id"").equals(nodeId)) {
        return i;
      }
    }
    return -1;
  }
}
","package controllers; public class D3Utils { public static ObjectNode graphToJsonString(Graph graph) { ArrayList<Vertex> vertices = new ArrayList<>(); ArrayList<Edge> edges = new ArrayList<>(); for (Vertex v : graph.getVertices())
      vertices.add(v); for (Edge e : graph.getEdges())
      edges.add(e); return toJsonString(vertices, edges); } public static ObjectNode toJsonString(ArrayList<Vertex> vertices, ArrayList<Edge> edges) { ArrayList<HashMap<String, Object>> nodes = new ArrayList<>(); for (int i = 0; i < vertices.size(); i++) { Vertex v = vertices.get(i); HashMap<String, Object> n = new HashMap<>(); n.put(""id"", v.getId().toString()); String[] propertyKeyArray = v.getPropertyKeys().toArray(new String[0]); ArrayList<String> ignoreKeys = new ArrayList<>(); for (String key : propertyKeyArray) { if (ignoreKeys.indexOf(key) < 0) { n.put(key, Json.toJson(v.getProperty(key))); } } nodes.add(n); } ArrayList<HashMap<String, Object>> links = new ArrayList<>(); for (Edge e : edges) { if (e.getLabel().equals(""connected"")) { HashMap<String, Object> l = new HashMap<>(); l.put(""id"", Integer.parseInt(e.getId().toString())); l.put(""name"", e.getLabel()); l.put(""source"", indexOfNode(e.getVertex(Direction.IN).getId().toString(), nodes)); l.put(""target"", indexOfNode(e.getVertex(Direction.OUT).getId().toString(), nodes)); for (String key : e.getPropertyKeys()) { l.put(key, e.getProperty(key)); } if (l.get(""source"") == null || l.get(""target"") == null)
          System.out.println(""source or target is null""); else
          links.add(l); } } ObjectNode rootNode = Json.newObject(); rootNode.put(""nodes"", Json.toJson(nodes)); rootNode.put(""links"", Json.toJson(links)); return rootNode; } private static int indexOfNode(String nodeId, ArrayList<HashMap<String, Object>> nodes) { for (int i = 0; i < nodes.size(); i++) { if (nodes.get(i).get(""id"").equals(nodeId)) { return i; } } return -1; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package controllers; public class D3Utils { public static ObjectNode graphToJsonString(Graph graph) { ArrayList<Vertex> vertices = new ArrayList<>(); ArrayList<Edge> edges = new ArrayList<>(); for (Vertex v : graph.getVertices())
      vertices.add(v); for (Edge e : graph.getEdges())
      edges.add(e); return toJsonString(vertices, edges); } public static ObjectNode toJsonString(ArrayList<Vertex> vertices, ArrayList<Edge> edges) { ArrayList<HashMap<String, Object>> nodes = new ArrayList<>(); for (int i = 0; i < vertices.size(); i++) { Vertex v = vertices.get(i); HashMap<String, Object> n = new HashMap<>(); n.put(""id"", v.getId().toString()); String[] propertyKeyArray = v.getPropertyKeys().toArray(new String[0]); ArrayList<String> ignoreKeys = new ArrayList<>(); for (String key : propertyKeyArray) { if (ignoreKeys.indexOf(key) < 0) { n.put(key, Json.toJson(v.getProperty(key))); } } nodes.add(n); } ArrayList<HashMap<String, Object>> links = new ArrayList<>(); for (Edge e : edges) { if (e.getLabel().equals(""connected"")) { HashMap<String, Object> l = new HashMap<>(); l.put(""id"", Integer.parseInt(e.getId().toString())); l.put(""name"", e.getLabel()); l.put(""source"", indexOfNode(e.getVertex(Direction.IN).getId().toString(), nodes)); l.put(""target"", indexOfNode(e.getVertex(Direction.OUT).getId().toString(), nodes)); for (String key : e.getPropertyKeys()) { l.put(key, e.getProperty(key)); } if (l.get(""source"") == null || l.get(""target"") == null)
          System.out.println(""source or target is null""); else
          links.add(l); } } ObjectNode rootNode = Json.newObject(); rootNode.put(""nodes"", Json.toJson(nodes)); rootNode.put(""links"", Json.toJson(links)); return rootNode; } private static int indexOfNode(String nodeId, ArrayList<HashMap<String, Object>> nodes) { for (int i = 0; i < nodes.size(); i++) { if (nodes.get(i).get(""id"").equals(nodeId)) { return i; } } return -1; } } ","package controllers; 
import com.fasterxml.jackson.databind.node.ObjectNode; import com.tinkerpop.blueprints.Direction; import com.tinkerpop.blueprints.Edge; import com.tinkerpop.blueprints.Graph; import com.tinkerpop.blueprints.Vertex; import play.libs.Json; import java.util.ArrayList; import java.util.HashMap;  public class D3Utils { public static ObjectNode graphToJsonString(Graph graph) { ArrayList<Vertex> vertices = new ArrayList<>(); ArrayList<Edge> edges = new ArrayList<>();  for (Vertex v : graph.getVertices())
      vertices.add(v);  for (Edge e : graph.getEdges())
      edges.add(e);  return toJsonString(vertices, edges); }  public static ObjectNode toJsonString(ArrayList<Vertex> vertices, ArrayList<Edge> edges) { ArrayList<HashMap<String, Object>> nodes = new ArrayList<>();  for (int i = 0; i < vertices.size(); i++) { Vertex v = vertices.get(i);  HashMap<String, Object> n = new HashMap<>(); n.put(""id"", v.getId().toString());  // TODO: Make this thread safe, the Vertex's properties may be modified during the execution of the loop // Will copying the property keys to an array solve the Concurrent Modification problem? String[] propertyKeyArray = v.getPropertyKeys().toArray(new String[0]); ArrayList<String> ignoreKeys = new ArrayList<>();  for (String key : propertyKeyArray) { if (ignoreKeys.indexOf(key) < 0) { n.put(key, Json.toJson(v.getProperty(key))); } }  nodes.add(n); }  ArrayList<HashMap<String, Object>> links = new ArrayList<>();  for (Edge e : edges) { if (e.getLabel().equals(""connected"")) { HashMap<String, Object> l = new HashMap<>(); l.put(""id"", Integer.parseInt(e.getId().toString())); l.put(""name"", e.getLabel());  l.put(""source"", indexOfNode(e.getVertex(Direction.IN).getId().toString(), nodes)); l.put(""target"", indexOfNode(e.getVertex(Direction.OUT).getId().toString(), nodes));  for (String key : e.getPropertyKeys()) { l.put(key, e.getProperty(key)); }  if (l.get(""source"") == null || l.get(""target"") == null)
          System.out.println(""source or target is null""); else
          links.add(l); } }  ObjectNode rootNode = Json.newObject(); rootNode.put(""nodes"", Json.toJson(nodes)); rootNode.put(""links"", Json.toJson(links));  return rootNode; }  private static int indexOfNode(String nodeId, ArrayList<HashMap<String, Object>> nodes) { for (int i = 0; i < nodes.size(); i++) { if (nodes.get(i).get(""id"").equals(nodeId)) { return i; } } return -1; } }  "
app/controllers/ExperimentController.java,"package controllers;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import models.*;

import net.lingala.zip4j.core.ZipFile;
import net.lingala.zip4j.exception.ZipException;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import play.Logger;
import play.libs.Json;
import play.mvc.Controller;
import play.mvc.Http;
import play.mvc.Result;
import play.mvc.Security;

import java.io.*;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Date;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import static org.apache.commons.io.FileUtils.deleteDirectory;

public class ExperimentController extends Controller {

  @Security.Authenticated(Secured.class)
  public static Result createExperiment() {
    String newExperimentName;
    Long copyExperimentId;
    JsonNode json = request().body().asJson();
    if(json == null) {
      return badRequest(""Expecting Json data"");
    } else {
      newExperimentName = json.findPath(""newExperimentName"").textValue();
      copyExperimentId = json.findPath(""copyExperimentId"").asLong();
    }

    if (newExperimentName == null) {
      return badRequest(""Please provide a name for the new experiment."");
    }

    String uid = session().get(""uid"");
    User user = User.findByUID(uid);

    if (user == null) {
      return badRequest(""Unable to determine the user who made this request."");
    }

    Experiment experiment = null;

    Experiment copyExperiment = Experiment.findById(copyExperimentId);

    if (copyExperiment != null) {
      experiment = new Experiment(copyExperiment);
    }

    if (experiment == null) {
      experiment = newExperiment(user, true);
    }

    experiment.name = newExperimentName;
    if (user.defaultLanguage != null && copyExperiment == null) {
      experiment.languages.add(user.defaultLanguage);
    }
    experiment.fileMode = false;
    experiment.save();

    user.ownedExperiments.add(experiment);
    user.update();
    user.saveManyToManyAssociations(""ownedExperiments"");

    return ok(experiment.toJson());
  }

  @Security.Authenticated(Secured.class)
  public static Result importExperiment(String experimentName) throws IOException{

    Http.MultipartFormData body = request().body().asMultipartFormData();
    Long maxUploadSize = play.Play.application().configuration().getLong(""maxUploadSize"", 50L * 1024L * 1024L);

    // Validate Content-Length header
    try {
      Long fileSize = Long.parseLong(request().getHeader(""Content-Length""), 10);
      if (fileSize > maxUploadSize) {
        return badRequest(""Uploaded file is too large"");
      }
    } catch(Exception e){
      return badRequest(""Upload was malformed"");
    }

    // Validate the size of the file
    Http.MultipartFormData.FilePart filePart = body.getFile(""file"");
    File zippedFile = filePart.getFile();

    // Validate the other data
    if(experimentName == null || zippedFile == null){
      return badRequest(""Must include zipFile and experiment name"");
    }

    if(zippedFile.length() > maxUploadSize){
      return badRequest(""Uploaded file is too large"");
    }

    String uid = session().get(""uid"");
    User user = User.findByUID(uid);
    Experiment experiment = newExperiment(user, false);
    experiment.name = experimentName;
    experiment.save();

    String timeString = new Date().getTime() + """";
    String rootOutputFolder = ""experiments/"" + experiment.name + ""_"" + experiment.id + ""_"" + timeString;
    String outputFolder = rootOutputFolder;

    try {
      ZipFile zipFile = new ZipFile(zippedFile);
      zipFile.extractAll(outputFolder);

      //Delete the __MAC_OSX directory if it exists
      File[] outputFiles = (new File(outputFolder)).listFiles();
      for(File outputFile: outputFiles){
        if(outputFile.getName().equals(""__MACOSX"") || outputFile.getName().equals(""__MAC_OSX"")){
          deleteDirectory(outputFile);
        }
      }

      outputFiles = (new File(outputFolder)).listFiles();
      if(outputFiles.length == 1){
        // Pull out the contents of this sub-directory into the main directory
        File subDirectory = outputFiles[0];
        Logger.debug(""Single subdirectory found: "" + outputFiles);
        File stepsDirectory = new File(subDirectory, ""Steps"");
        File contentDirectory = new File(subDirectory, ""Content"");
        if(stepsDirectory.exists() || contentDirectory.exists()) {
          outputFolder = subDirectory.getAbsolutePath();
          Logger.debug(""Using subdirectory, "" + outputFolder + "" for import instead."");
        } else {
          String msg = ""No Steps or Content directories found. Please upload a valid experiment"";
          Logger.debug(msg);
          deleteDirectory(new File(rootOutputFolder));
          return badRequest(msg);
        }
      } else {
        File stepsDirectory = new File(outputFolder, ""Steps"");
        File contentDirectory = new File(outputFolder, ""Content"");
        if(!stepsDirectory.exists() || !contentDirectory.exists()){
          String msg = ""No Steps or Content directories found. Please upload a valid experiment"";
          Logger.debug(msg);
          deleteDirectory(new File(rootOutputFolder));
          return badRequest(msg);
        }
      }
    } catch (ZipException e){
      e.printStackTrace();
    }

    try{
      String dotBreadboard = readFile(outputFolder + File.separator + "".breadboard"", StandardCharsets.UTF_8);
      ObjectMapper mapper = new ObjectMapper();
      JsonNode dotBreadboardJson = mapper.readTree(dotBreadboard);
      String eVersion = dotBreadboardJson.findPath(""version"").textValue();
      String eUid = dotBreadboardJson.findPath(""experimentUid"").textValue();
      String eName = dotBreadboardJson.findPath(""experimentName"").textValue();
      // TODO: offer the option to import the Experiment UID and/or Name from the .breadboard file

      Logger.debug(""Read .breadboard file: experimentVersion = "" + eVersion + "" experimentUid = "" + eUid + "" experimentName = "" + eName);

      if(eVersion.startsWith(""v2.3"") || eVersion.startsWith(""v2.4"")){
        import23To23(experiment, user, outputFolder);
      } else if (eVersion.startsWith(""v2.2"")) {
        import22To23(experiment, user, outputFolder);
      } else {
        // Default to v2.2 import for now
        import22To23(experiment, user, outputFolder);
      }
    } catch(IOException e){
      Logger.debug(""No .breadboard file present"");
      import22To23(experiment, user, outputFolder);
    } finally{
      deleteDirectory(new File(rootOutputFolder));
    }

    return ok(experiment.toJson());
  }

  @Security.Authenticated(Secured.class)
  public static Result exportExperiment(Long experimentId){

    Experiment experiment = Experiment.findById(experimentId);
    String uid = session().get(""uid"");
    User user = User.findByUID(uid);
    if(experiment == null){
      return badRequest(""No experiment found with that ID"");
    }

    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    try(ZipOutputStream zos = new ZipOutputStream(outputStream)) {
      ZipEntry e;

      ObjectNode dotBreadboard = Json.newObject();
      String version = play.Play.application().configuration().getString(""application.version"");
      dotBreadboard.put(""version"", version);
      dotBreadboard.put(""experimentName"", experiment.name);
      dotBreadboard.put(""experimentUid"", experiment.uid);

      e = new ZipEntry("".breadboard"");
      zos.putNextEntry(e);
      zos.write(dotBreadboard.toString().getBytes());
      zos.closeEntry();

      // Client style/html/graph
      e = new ZipEntry(""style.css"");
      zos.putNextEntry(e);
      zos.write(experiment.getStyle().getBytes());
      zos.closeEntry();

      e = new ZipEntry(""client-html.html"");
      zos.putNextEntry(e);
      zos.write(experiment.getClientHtml().getBytes());
      zos.closeEntry();

      e = new ZipEntry(""client-graph.js"");
      zos.putNextEntry(e);
      zos.write(experiment.getClientGraph().getBytes());
      zos.closeEntry();

      // Steps
      for (Step step : experiment.getSteps()) {
        e = new ZipEntry(""Steps/"" + step.name.concat("".groovy""));
        zos.putNextEntry(e);
        zos.write(step.source.getBytes());
        zos.closeEntry();
      }

      // Content in language subfolders
      for (Content c : experiment.getContent()){
        for(Translation t : c.translations){
          String language = (t.language == null || t.language.getCode() == null) ? user.defaultLanguage.getCode(): t.language.getCode();
          e = new ZipEntry(""Content/"" + language + ""/"" + c.name.concat("".html""));
          zos.putNextEntry(e);
          zos.write(t.html.getBytes());
          zos.closeEntry();
        }
      }

      // Create the parameters.csv file
      e = new ZipEntry(""parameters.csv"");
      zos.putNextEntry(e);
      zos.write(experiment.parametersToCsv().getBytes());
      zos.closeEntry();

      // Write image files to stream
      for (Image image : experiment.getImages()) {
        e = new ZipEntry(""Images/"" + image.fileName);
        zos.putNextEntry(e);
        zos.write(image.file);
        zos.closeEntry();
      }

      // Finish by closing the stream
      zos.close();

    } catch(IOException ioe) {
      ioe.printStackTrace();
    }

    return ok(outputStream.toByteArray());

  }

  /**
   * If experimentId is null or invalid, creates a new experiment and returns the newly created experiment ID.
   * Otherwise, imports the experiment files over the existing experiment and returns the provided experimentID.
   * @param experimentId  The ID of the experiment to import over, if null or invalid create new experiment
   * @param user          The User who is making the import request, newly created experiments will be associated with the user
   * @param directory     The File location of the experiment files to impoart
   * @return              the experimentId of the imported experiment
   * @throws IOException
   */
  public static Long importExperimentFromDirectory(Long experimentId, User user, File directory) throws IOException {
    Experiment experiment;
    Logger.debug(""Importing experiment "" + experimentId + "" from "" + directory);
    if (experimentId == null || ((experiment = Experiment.findById(experimentId)) == null) ) {
      // New experiment
      experiment = new Experiment();
      user.ownedExperiments.add(experiment);
      user.update();
      user.saveManyToManyAssociations(""ownedExperiments"");
    } else {
      // Existing experiment, delete before re-importing
      experiment.removeSteps();
      experiment.removeContent();
      experiment.removeParameters();
      experiment.removeImages();
    }
    experiment.setClientGraph(FileUtils.readFileToString(new File(directory, ""client-graph.js"")));
    experiment.setClientHtml(FileUtils.readFileToString(new File(directory, ""client-html.html"")));
    experiment.setStyle(FileUtils.readFileToString(new File(directory, ""style.css"")));
    importParameters(experiment, new File(directory, ""parameters.csv""));
    importSteps(experiment, new File(directory, ""/Steps""));
    importContent(experiment, new File(directory, ""/Content""));
    importImages(experiment, new File(directory, ""/Images""));
    experiment.save();
    return experiment.id;
  }

  public static void exportExperimentToDirectory(Long experimentId, File directory) throws IOException {
    Experiment experiment = Experiment.findById(experimentId);
    if(experiment == null){
      throw new IOException(""Experiment with the ID "" + experimentId + "" not found."");
    }

    // Clean up existing files
    if (directory.exists() && directory.isDirectory()) {
      FileUtils.deleteDirectory(directory);
    }

    // Create the directory
    FileUtils.forceMkdir(directory);

    String version = play.Play.application().configuration().getString(""application.version"");
    ObjectNode dotBreadboard = Json.newObject();
    dotBreadboard.put(""version"", version);
    dotBreadboard.put(""experimentName"", experiment.name);
    dotBreadboard.put(""experimentUid"", experiment.uid);

    FileUtils.writeStringToFile(new File(directory, "".breadboard""), dotBreadboard.toString());
    FileUtils.writeStringToFile(new File(directory, ""style.css""), experiment.getStyle());
    FileUtils.writeStringToFile(new File(directory, ""client-html.html""), experiment.getClientHtml());
    FileUtils.writeStringToFile(new File(directory, ""client-graph.js""), experiment.getClientGraph());

    File stepsDirectory = new File(directory, ""Steps"");
    if (!stepsDirectory.isDirectory()) {
      stepsDirectory.mkdir();
    }
    for (Step step : experiment.getSteps()) {
      FileUtils.writeStringToFile(new File(stepsDirectory, step.name.concat("".groovy"")), step.source);
    }

    File contentDirectory = new File(directory, ""Content"");
    if (!contentDirectory.isDirectory()) {
      contentDirectory.mkdir();
    }
    for (Content c : experiment.getContent()) {
      for (Translation t : c.translations) {
        String language = (t.language == null || t.language.getCode() == null) ? ""en"" : t.language.getCode();
        File translationDirectory = new File(contentDirectory, language);
        FileUtils.writeStringToFile(new File(translationDirectory, c.name.concat("".html"")), t.html);
      }
    }

    FileUtils.writeStringToFile(new File(directory, ""parameters.csv""), experiment.parametersToCsv());

    File imagesDirectory = new File(directory, ""Images"");
    if (!imagesDirectory.isDirectory()) {
      imagesDirectory.mkdir();
    }
    for (Image image : experiment.getImages()) {
      FileUtils.writeByteArrayToFile(new File(imagesDirectory, image.fileName), image.file);
    }
  }


  private static String readFile(String path, Charset encoding) throws IOException{
    byte[] encoded = Files.readAllBytes(Paths.get(path));
    return new String(encoded, encoding);
  }

  /**
   * Specific import function for import v2.2 exports into v2.3 of breadboard. There are some small differences in the
   * export format that must be dealt with as well as breaking changes to the client-html and client-graph that are
   * avoided by simply not importing those files.
   * @param experiment
   * @param user
   * @param directory
   * @return
   */
  private static Boolean import22To23(Experiment experiment, User user,  String directory) throws IOException{
    try {
      String style = FileUtils.readFileToString(new File(directory, ""style.css""));
      Logger.debug(""style: "" + style);
      experiment.setStyle(style);
    } catch(IOException e){
      Logger.error(""Unable to read style.css"", e);
    }
    Logger.debug(""Skipping client.html. Using default instead. Please merge any customizations by hand"");
    Logger.debug(""Skipping client-graph.js. Using default instead. Please merge any customizations by hand."");

    // Import content
    File contentDir = new File(directory, ""/Content"");
    for (File langFileOrDir : contentDir.listFiles()){
      if(!langFileOrDir.isDirectory()){
        Logger.debug(""Content is in root of Content directory. Attempting to import as default language."");
        try {
          importTranslations(experiment, user.defaultLanguage, contentDir);
        } catch(IOException e){
          Logger.error(""Unable to import content from 'Content' directory"", e);
          return false;
        } finally{
          break;
        }
      } else {
        // Content is broken out by language
        String languageIso3 = langFileOrDir.getName().equals(""null"") ? user.defaultLanguage.getCode() : langFileOrDir.getName();
        Language language = Language.findByIso3(languageIso3);
//        Language language = Language.findByIso3(langFileOrDir.getName());
        try{
          importTranslations(experiment, language, langFileOrDir);
        } catch(IOException e){
          Logger.error(""Unable to import content from "" + langFileOrDir.getName(), e);
        }
      }
    }

    // Import steps
    try {
      File stepsDirectory = new File(directory, ""/Steps"");
      importSteps(experiment, stepsDirectory);
    } catch(IOException e){
      Logger.error(""Unable to import step"", e);
      return false;
    }

    // Import parameters
    try {
      File parametersFile = new File(directory, ""parameters.csv"");
      importParameters(experiment, parametersFile);
    } catch(IOException e){
      Logger.error(""Unable to import parameters.csv"", e);
    }

    // Import images
    try {
      File imagesDirectory = new File(directory, ""/Images"");
      importImages(experiment, imagesDirectory);
    } catch(IOException e){
      Logger.error(""Unable to import images"", e);
      return false;
    }

    // Write changes to DB
    experiment.setFileMode(false);
    experiment.save();

    user.ownedExperiments.add(experiment);
    user.update();
    user.saveManyToManyAssociations(""ownedExperiments"");

    return true;
  }


  private static Boolean import23To23(Experiment experiment, User user, String directory) throws IOException{

    Logger.debug(""importing 23 to 23"");
    String style = FileUtils.readFileToString(new File(directory, ""style.css""));
    experiment.setStyle(style);
    experiment.setClientGraph(FileUtils.readFileToString(new File(directory, ""client-graph.js"")));
    experiment.setClientHtml(FileUtils.readFileToString(new File(directory, ""client-html.html"")));
    experiment.setFileMode(false);

    // Import Steps
    importSteps(experiment, new File(directory, ""/Steps""));
    // Import Content
    importContent(experiment, new File(directory, ""/Content""));
    // Import Parameters
    importParameters(experiment, new File(directory, ""parameters.csv""));
    // Import Images
    importImages(experiment, new File(directory, ""/Images""));
    // Save
    experiment.save();

    user.ownedExperiments.add(experiment);
    user.update();
    user.saveManyToManyAssociations(""ownedExperiments"");

    return true;
  }


  private static void importContent(Experiment experiment, File contentDir) throws IOException {
    ArrayList<Content> content = getContentFromDirectory(contentDir);
    for (Content c : content) {
      for (Translation t : c.translations) {
        boolean hasExperimentLanguage = false;
        for(Language l: experiment.languages){
          if(l.id.equals(t.language.id)){
            hasExperimentLanguage = true;
          }
        }
        if(!hasExperimentLanguage){
          experiment.languages.add(t.language);
        }
      }
      experiment.content.add(c);
    }
  }

  public static ArrayList<Content> getContentFromDirectory(File contentDir) throws IOException {
    ArrayList<Content> returnContent = new ArrayList<>();
    if (!contentDir.isDirectory()) {
      return returnContent;
    }
    // Default to English if the directory isn't specified
    Language defaultLanguage = Language.findByIso3(""eng"");
    if (contentDir == null || !contentDir.exists()) {
      throw new IOException(""Directory not found."");
    }
    for (File langFileOrDir : contentDir.listFiles()){
      if(!langFileOrDir.isDirectory() && FilenameUtils.getExtension(langFileOrDir.getName()).equalsIgnoreCase(""html"")) {
        Logger.debug(""Content is in root of Content directory. Attempting to import as default language."");
        try {
          ArrayList<Content> rootContent = getContentFromSubdirectory(contentDir, defaultLanguage);
          returnContent.addAll(rootContent);
        } catch(IOException e){
          Logger.error(""Unable to import content from 'Content' directory"", e);
        } finally{
          break;
        }
      } else if (langFileOrDir.isDirectory()) {
        // Content is broken out by language
        Language language = Language.findByIso3(langFileOrDir.getName());

        // Sometimes the subdirectory is named null or something else
        if(language == null){
          language = defaultLanguage;
        }
        try{
          ArrayList<Content> languageContent = getContentFromSubdirectory(langFileOrDir, language);
          returnContent.addAll(languageContent);
        } catch(IOException e){
          Logger.error(""Unable to import content from "" + langFileOrDir.getName(), e);
        }
      }
    }
    return returnContent;

  }


  /**
   * Import all html files in the supplied directory as translations of the supplied language and experiment.
   * @param experiment
   * @param language
   * @param directory
   * @throws IOException
   */
  private static void importTranslations(Experiment experiment, Language language, File directory) throws IOException {

    // Check for existing experiment language and add it if it doesn't exist
    boolean hasExperimentLanguage = false;
    for(Language l: experiment.languages){
      if(l.id.equals(language.id)){
        hasExperimentLanguage = true;
      }
    }
    if(!hasExperimentLanguage){
      experiment.languages.add(language);
    }

    ArrayList<Content> importedContent = getContentFromSubdirectory(directory, language);

    for(Content content: importedContent) {
      // Check for existing content and create if it doesn't exist
      boolean contentExists = false;
      for (Content c : experiment.content) {
        if (c.name.equals(content.name)) {
          contentExists = true;
          Logger.debug(""Using existing content: "" + content.name + "" with language "" + language.name);
          break;
        }
      }

      // If content with that name doesn't already exist, import it
      if (!contentExists) {
        experiment.content.add(content);
      }
    }

  }

  private static ArrayList<Content> getContentFromSubdirectory(File directory, Language language) throws IOException {
    ArrayList<Content> returnContent = new ArrayList<>();

    for(File file: directory.listFiles()){
      if(FilenameUtils.getExtension(file.getName()).equals(""html"")){
        Translation translation = new Translation();
        translation.language = language;
        translation.html = FileUtils.readFileToString(file);

        String contentName = FilenameUtils.removeExtension(file.getName());
        Content content = new Content();
        content.name = contentName;
        content.translations.add(translation);

        returnContent.add(content);
      }
    }

    return returnContent;
  }

  /**
   * Import all of the images from the specified directory as members of the specified experiment.
   * @param experiment
   * @param directory
   * @throws IOException
   */
  private static void importImages(Experiment experiment, File directory) throws IOException {
    ArrayList<Image> images = getImagesFromDirectory(directory);
    experiment.images.addAll(images);
    experiment.save();
  }

  public static ArrayList<Image> getImagesFromDirectory(File directory) throws IOException {
    ArrayList<Image> returnImages = new ArrayList<>();
    File[] imageFiles = directory.listFiles();
    if (!directory.isDirectory()) {
      return returnImages;
    }
    if (imageFiles != null) {
      for (File imageFile : imageFiles) {
        String imageName = FilenameUtils.removeExtension(imageFile.getName());
        String ext = FilenameUtils.getExtension(imageFile.getName());
        if(ext.matches(""(jpg|jpeg|png|bmp|gif|svg|webp)"")) {
          byte[] imageBytes = FileUtils.readFileToByteArray(imageFile);
          Image image = new Image();
          image.fileName = imageFile.getName();
          image.file = imageBytes;
          String extension = FilenameUtils.getExtension(imageFile.getName());
          image.contentType = ""image/"" + extension;
          if(extension.equals(""svg"")){
            image.contentType += ""+xml"";
          }
          returnImages.add(image);
          Logger.debug(""Adding image: "" + imageName);
        } else {
          Logger.debug(""Skipping file of unsupported type: "" + imageName);
        }
      }
    }
    return returnImages;
  }

  private static void importParameters(Experiment experiment, File file) throws IOException {
    ArrayList<Parameter> parameters = getParametersFromFile(file);
    experiment.parameters.addAll(parameters);
    experiment.update();
  }

  public static ArrayList<Parameter> getParametersFromFile(File parameterFile) throws IOException {
    ArrayList<Parameter> returnParameters = new ArrayList<>();
    Reader in = new FileReader(parameterFile);
    CSVFormat format = CSVFormat.DEFAULT.withHeader(""Name"", ""Type"", ""Min."", ""Max."", ""Default"", ""Short Description"").withFirstRecordAsHeader();
    for (CSVRecord record : format.parse(in)) {
      Parameter parameter = new Parameter();
      parameter.name = record.get(""Name"");
      parameter.type = record.get(""Type"");
      parameter.minVal = record.get(""Min."");
      parameter.maxVal = record.get(""Max."");
      parameter.defaultVal = record.get(""Default"");
      parameter.description = record.get(""Short Description"");
      returnParameters.add(parameter);
    }
    return returnParameters;
  }

  // Reusable code for importing steps
  private static void importSteps(Experiment experiment, File stepsDirectory) throws IOException{
    ArrayList<Step> steps = getStepsFromDirectory(stepsDirectory);
    for (Step step : steps) {
      experiment.addStep(step);
    }
  }

  public static ArrayList<Step> getStepsFromDirectory(File stepsDirectory) throws IOException {
    ArrayList<Step> returnSteps = new ArrayList<>();
    File[] stepFiles = stepsDirectory.listFiles();
    if (stepFiles != null) {
      for (File stepFile : stepFiles) {
        if(FilenameUtils.getExtension(stepFile.getName()).equals(""groovy"")) {
          Step step = new Step();
          String stepName = FilenameUtils.removeExtension(stepFile.getName());
          String source = FileUtils.readFileToString(stepFile);
          step.name = stepName;
          step.source = source;
          returnSteps.add(step);
          Logger.debug(""Adding step: "" + stepName);
        } else {
          Logger.debug(""Skipping "" + stepFile.getName() + "" with unsupported file extension"");
        }
      }
    }
    return returnSteps;
  }

  private static Experiment newExperiment(User user, Boolean isNewExperiment){
    Experiment experiment = new Experiment();
    if (isNewExperiment) {
      Step onJoin = Experiment.generateOnJoinStep();
      Step onLeave = Experiment.generateOnLeaveStep();
      Step init = Experiment.generateInitStep();
      experiment.addStep(onJoin);
      experiment.addStep(onLeave);
      experiment.addStep(init);
    }
    experiment.setClientHtml(Experiment.defaultClientHTML());
    experiment.setClientGraph(Experiment.defaultClientGraph());
    // Add the user's default language
    experiment.languages.add(user.defaultLanguage);
    return experiment;
  }
}
","package controllers; public class ExperimentController extends Controller { @Security.Authenticated(Secured.class)
  public static Result createExperiment() { String newExperimentName; Long copyExperimentId; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { newExperimentName = json.findPath(""newExperimentName"").textValue(); copyExperimentId = json.findPath(""copyExperimentId"").asLong(); } if (newExperimentName == null) { return badRequest(""Please provide a name for the new experiment.""); } String uid = session().get(""uid""); User user = User.findByUID(uid); if (user == null) { return badRequest(""Unable to determine the user who made this request.""); } Experiment experiment = null; Experiment copyExperiment = Experiment.findById(copyExperimentId); if (copyExperiment != null) { experiment = new Experiment(copyExperiment); } if (experiment == null) { experiment = newExperiment(user, true); } experiment.name = newExperimentName; if (user.defaultLanguage != null && copyExperiment == null) { experiment.languages.add(user.defaultLanguage); } experiment.fileMode = false; experiment.save(); user.ownedExperiments.add(experiment); user.update(); user.saveManyToManyAssociations(""ownedExperiments""); return ok(experiment.toJson()); } @Security.Authenticated(Secured.class)
  public static Result importExperiment(String experimentName) throws IOException{ Http.MultipartFormData body = request().body().asMultipartFormData(); Long maxUploadSize = play.Play.application().configuration().getLong(""maxUploadSize"", 50L * 1024L * 1024L); try { Long fileSize = Long.parseLong(request().getHeader(""Content-Length""), 10); if (fileSize > maxUploadSize) { return badRequest(""Uploaded file is too large""); } } catch(Exception e){ return badRequest(""Upload was malformed""); } Http.MultipartFormData.FilePart filePart = body.getFile(""file""); File zippedFile = filePart.getFile(); if(experimentName == null || zippedFile == null){ return badRequest(""Must include zipFile and experiment name""); } if(zippedFile.length() > maxUploadSize){ return badRequest(""Uploaded file is too large""); } String uid = session().get(""uid""); User user = User.findByUID(uid); Experiment experiment = newExperiment(user, false); experiment.name = experimentName; experiment.save(); String timeString = new Date().getTime() + """"; String rootOutputFolder = ""experiments/"" + experiment.name + ""_"" + experiment.id + ""_"" + timeString; String outputFolder = rootOutputFolder; try { ZipFile zipFile = new ZipFile(zippedFile); zipFile.extractAll(outputFolder); File[] outputFiles = (new File(outputFolder)).listFiles(); for(File outputFile: outputFiles){ if(outputFile.getName().equals(""__MACOSX"") || outputFile.getName().equals(""__MAC_OSX"")){ deleteDirectory(outputFile); } } outputFiles = (new File(outputFolder)).listFiles(); if(outputFiles.length == 1){ File subDirectory = outputFiles[0]; File stepsDirectory = new File(subDirectory, ""Steps""); File contentDirectory = new File(subDirectory, ""Content""); if(stepsDirectory.exists() || contentDirectory.exists()) { outputFolder = subDirectory.getAbsolutePath(); } else { String msg = ""No Steps or Content directories found. Please upload a valid experiment""; deleteDirectory(new File(rootOutputFolder)); return badRequest(msg); } } else { File stepsDirectory = new File(outputFolder, ""Steps""); File contentDirectory = new File(outputFolder, ""Content""); if(!stepsDirectory.exists() || !contentDirectory.exists()){ String msg = ""No Steps or Content directories found. Please upload a valid experiment""; deleteDirectory(new File(rootOutputFolder)); return badRequest(msg); } } } catch (ZipException e){ e.printStackTrace(); } try{ String dotBreadboard = readFile(outputFolder + File.separator + "".breadboard"", StandardCharsets.UTF_8); ObjectMapper mapper = new ObjectMapper(); JsonNode dotBreadboardJson = mapper.readTree(dotBreadboard); String eVersion = dotBreadboardJson.findPath(""version"").textValue(); String eUid = dotBreadboardJson.findPath(""experimentUid"").textValue(); String eName = dotBreadboardJson.findPath(""experimentName"").textValue(); if(eVersion.startsWith(""v2.3"") || eVersion.startsWith(""v2.4"")){ import23To23(experiment, user, outputFolder); } else if (eVersion.startsWith(""v2.2"")) { import22To23(experiment, user, outputFolder); } else { import22To23(experiment, user, outputFolder); } } catch(IOException e){ import22To23(experiment, user, outputFolder); } finally{ deleteDirectory(new File(rootOutputFolder)); } return ok(experiment.toJson()); } @Security.Authenticated(Secured.class)
  public static Result exportExperiment(Long experimentId){ Experiment experiment = Experiment.findById(experimentId); String uid = session().get(""uid""); User user = User.findByUID(uid); if(experiment == null){ return badRequest(""No experiment found with that ID""); } ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); try(ZipOutputStream zos = new ZipOutputStream(outputStream)) { ZipEntry e; ObjectNode dotBreadboard = Json.newObject(); String version = play.Play.application().configuration().getString(""application.version""); dotBreadboard.put(""version"", version); dotBreadboard.put(""experimentName"", experiment.name); dotBreadboard.put(""experimentUid"", experiment.uid); e = new ZipEntry("".breadboard""); zos.putNextEntry(e); zos.write(dotBreadboard.toString().getBytes()); zos.closeEntry(); e = new ZipEntry(""style.css""); zos.putNextEntry(e); zos.write(experiment.getStyle().getBytes()); zos.closeEntry(); e = new ZipEntry(""client-html.html""); zos.putNextEntry(e); zos.write(experiment.getClientHtml().getBytes()); zos.closeEntry(); e = new ZipEntry(""client-graph.js""); zos.putNextEntry(e); zos.write(experiment.getClientGraph().getBytes()); zos.closeEntry(); for (Step step : experiment.getSteps()) { e = new ZipEntry(""Steps/"" + step.name.concat("".groovy"")); zos.putNextEntry(e); zos.write(step.source.getBytes()); zos.closeEntry(); } for (Content c : experiment.getContent()){ for(Translation t : c.translations){ String language = (t.language == null || t.language.getCode() == null) ? user.defaultLanguage.getCode(): t.language.getCode(); e = new ZipEntry(""Content/"" + language + ""/"" + c.name.concat("".html"")); zos.putNextEntry(e); zos.write(t.html.getBytes()); zos.closeEntry(); } } e = new ZipEntry(""parameters.csv""); zos.putNextEntry(e); zos.write(experiment.parametersToCsv().getBytes()); zos.closeEntry(); for (Image image : experiment.getImages()) { e = new ZipEntry(""Images/"" + image.fileName); zos.putNextEntry(e); zos.write(image.file); zos.closeEntry(); } zos.close(); } catch(IOException ioe) { ioe.printStackTrace(); } return ok(outputStream.toByteArray()); } public static Long importExperimentFromDirectory(Long experimentId, User user, File directory) throws IOException { Experiment experiment; if (experimentId == null || ((experiment = Experiment.findById(experimentId)) == null) ) { experiment = new Experiment(); user.ownedExperiments.add(experiment); user.update(); user.saveManyToManyAssociations(""ownedExperiments""); } else { experiment.removeSteps(); experiment.removeContent(); experiment.removeParameters(); experiment.removeImages(); } experiment.setClientGraph(FileUtils.readFileToString(new File(directory, ""client-graph.js""))); experiment.setClientHtml(FileUtils.readFileToString(new File(directory, ""client-html.html""))); experiment.setStyle(FileUtils.readFileToString(new File(directory, ""style.css""))); importParameters(experiment, new File(directory, ""parameters.csv"")); importSteps(experiment, new File(directory, ""/Steps"")); importContent(experiment, new File(directory, ""/Content"")); importImages(experiment, new File(directory, ""/Images"")); experiment.save(); return experiment.id; } public static void exportExperimentToDirectory(Long experimentId, File directory) throws IOException { Experiment experiment = Experiment.findById(experimentId); if(experiment == null){ throw new IOException(""Experiment with the ID "" + experimentId + "" not found.""); } if (directory.exists() && directory.isDirectory()) { FileUtils.deleteDirectory(directory); } FileUtils.forceMkdir(directory); String version = play.Play.application().configuration().getString(""application.version""); ObjectNode dotBreadboard = Json.newObject(); dotBreadboard.put(""version"", version); dotBreadboard.put(""experimentName"", experiment.name); dotBreadboard.put(""experimentUid"", experiment.uid); FileUtils.writeStringToFile(new File(directory, "".breadboard""), dotBreadboard.toString()); FileUtils.writeStringToFile(new File(directory, ""style.css""), experiment.getStyle()); FileUtils.writeStringToFile(new File(directory, ""client-html.html""), experiment.getClientHtml()); FileUtils.writeStringToFile(new File(directory, ""client-graph.js""), experiment.getClientGraph()); File stepsDirectory = new File(directory, ""Steps""); if (!stepsDirectory.isDirectory()) { stepsDirectory.mkdir(); } for (Step step : experiment.getSteps()) { FileUtils.writeStringToFile(new File(stepsDirectory, step.name.concat("".groovy"")), step.source); } File contentDirectory = new File(directory, ""Content""); if (!contentDirectory.isDirectory()) { contentDirectory.mkdir(); } for (Content c : experiment.getContent()) { for (Translation t : c.translations) { String language = (t.language == null || t.language.getCode() == null) ? ""en"" : t.language.getCode(); File translationDirectory = new File(contentDirectory, language); FileUtils.writeStringToFile(new File(translationDirectory, c.name.concat("".html"")), t.html); } } FileUtils.writeStringToFile(new File(directory, ""parameters.csv""), experiment.parametersToCsv()); File imagesDirectory = new File(directory, ""Images""); if (!imagesDirectory.isDirectory()) { imagesDirectory.mkdir(); } for (Image image : experiment.getImages()) { FileUtils.writeByteArrayToFile(new File(imagesDirectory, image.fileName), image.file); } } private static String readFile(String path, Charset encoding) throws IOException{ byte[] encoded = Files.readAllBytes(Paths.get(path)); return new String(encoded, encoding); } private static Boolean import22To23(Experiment experiment, User user,  String directory) throws IOException{ try { String style = FileUtils.readFileToString(new File(directory, ""style.css"")); experiment.setStyle(style); } catch(IOException e){ } File contentDir = new File(directory, ""/Content""); for (File langFileOrDir : contentDir.listFiles()){ if(!langFileOrDir.isDirectory()){ try { importTranslations(experiment, user.defaultLanguage, contentDir); } catch(IOException e){ return false; } finally{ break; } } else { String languageIso3 = langFileOrDir.getName().equals(""null"") ? user.defaultLanguage.getCode() : langFileOrDir.getName(); Language language = Language.findByIso3(languageIso3); try{ importTranslations(experiment, language, langFileOrDir); } catch(IOException e){ } } } try { File stepsDirectory = new File(directory, ""/Steps""); importSteps(experiment, stepsDirectory); } catch(IOException e){ return false; } try { File parametersFile = new File(directory, ""parameters.csv""); importParameters(experiment, parametersFile); } catch(IOException e){ } try { File imagesDirectory = new File(directory, ""/Images""); importImages(experiment, imagesDirectory); } catch(IOException e){ return false; } experiment.setFileMode(false); experiment.save(); user.ownedExperiments.add(experiment); user.update(); user.saveManyToManyAssociations(""ownedExperiments""); return true; } private static Boolean import23To23(Experiment experiment, User user, String directory) throws IOException{ String style = FileUtils.readFileToString(new File(directory, ""style.css"")); experiment.setStyle(style); experiment.setClientGraph(FileUtils.readFileToString(new File(directory, ""client-graph.js""))); experiment.setClientHtml(FileUtils.readFileToString(new File(directory, ""client-html.html""))); experiment.setFileMode(false); importSteps(experiment, new File(directory, ""/Steps"")); importContent(experiment, new File(directory, ""/Content"")); importParameters(experiment, new File(directory, ""parameters.csv"")); importImages(experiment, new File(directory, ""/Images"")); experiment.save(); user.ownedExperiments.add(experiment); user.update(); user.saveManyToManyAssociations(""ownedExperiments""); return true; } private static void importContent(Experiment experiment, File contentDir) throws IOException { ArrayList<Content> content = getContentFromDirectory(contentDir); for (Content c : content) { for (Translation t : c.translations) { boolean hasExperimentLanguage = false; for(Language l: experiment.languages){ if(l.id.equals(t.language.id)){ hasExperimentLanguage = true; } } if(!hasExperimentLanguage){ experiment.languages.add(t.language); } } experiment.content.add(c); } } public static ArrayList<Content> getContentFromDirectory(File contentDir) throws IOException { ArrayList<Content> returnContent = new ArrayList<>(); if (!contentDir.isDirectory()) { return returnContent; } Language defaultLanguage = Language.findByIso3(""eng""); if (contentDir == null || !contentDir.exists()) { throw new IOException(""Directory not found.""); } for (File langFileOrDir : contentDir.listFiles()){ if(!langFileOrDir.isDirectory() && FilenameUtils.getExtension(langFileOrDir.getName()).equalsIgnoreCase(""html"")) { try { ArrayList<Content> rootContent = getContentFromSubdirectory(contentDir, defaultLanguage); returnContent.addAll(rootContent); } catch(IOException e){ } finally{ break; } } else if (langFileOrDir.isDirectory()) { Language language = Language.findByIso3(langFileOrDir.getName()); if(language == null){ language = defaultLanguage; } try{ ArrayList<Content> languageContent = getContentFromSubdirectory(langFileOrDir, language); returnContent.addAll(languageContent); } catch(IOException e){ } } } return returnContent; } private static void importTranslations(Experiment experiment, Language language, File directory) throws IOException { boolean hasExperimentLanguage = false; for(Language l: experiment.languages){ if(l.id.equals(language.id)){ hasExperimentLanguage = true; } } if(!hasExperimentLanguage){ experiment.languages.add(language); } ArrayList<Content> importedContent = getContentFromSubdirectory(directory, language); for(Content content: importedContent) { boolean contentExists = false; for (Content c : experiment.content) { if (c.name.equals(content.name)) { contentExists = true; break; } } if (!contentExists) { experiment.content.add(content); } } } private static ArrayList<Content> getContentFromSubdirectory(File directory, Language language) throws IOException { ArrayList<Content> returnContent = new ArrayList<>(); for(File file: directory.listFiles()){ if(FilenameUtils.getExtension(file.getName()).equals(""html"")){ Translation translation = new Translation(); translation.language = language; translation.html = FileUtils.readFileToString(file); String contentName = FilenameUtils.removeExtension(file.getName()); Content content = new Content(); content.name = contentName; content.translations.add(translation); returnContent.add(content); } } return returnContent; } private static void importImages(Experiment experiment, File directory) throws IOException { ArrayList<Image> images = getImagesFromDirectory(directory); experiment.images.addAll(images); experiment.save(); } public static ArrayList<Image> getImagesFromDirectory(File directory) throws IOException { ArrayList<Image> returnImages = new ArrayList<>(); File[] imageFiles = directory.listFiles(); if (!directory.isDirectory()) { return returnImages; } if (imageFiles != null) { for (File imageFile : imageFiles) { String imageName = FilenameUtils.removeExtension(imageFile.getName()); String ext = FilenameUtils.getExtension(imageFile.getName()); if(ext.matches(""(jpg|jpeg|png|bmp|gif|svg|webp)"")) { byte[] imageBytes = FileUtils.readFileToByteArray(imageFile); Image image = new Image(); image.fileName = imageFile.getName(); image.file = imageBytes; String extension = FilenameUtils.getExtension(imageFile.getName()); image.contentType = ""image/"" + extension; if(extension.equals(""svg"")){ image.contentType += ""+xml""; } returnImages.add(image); } else { } } } return returnImages; } private static void importParameters(Experiment experiment, File file) throws IOException { ArrayList<Parameter> parameters = getParametersFromFile(file); experiment.parameters.addAll(parameters); experiment.update(); } public static ArrayList<Parameter> getParametersFromFile(File parameterFile) throws IOException { ArrayList<Parameter> returnParameters = new ArrayList<>(); Reader in = new FileReader(parameterFile); CSVFormat format = CSVFormat.DEFAULT.withHeader(""Name"", ""Type"", ""Min."", ""Max."", ""Default"", ""Short Description"").withFirstRecordAsHeader(); for (CSVRecord record : format.parse(in)) { Parameter parameter = new Parameter(); parameter.name = record.get(""Name""); parameter.type = record.get(""Type""); parameter.minVal = record.get(""Min.""); parameter.maxVal = record.get(""Max.""); parameter.defaultVal = record.get(""Default""); parameter.description = record.get(""Short Description""); returnParameters.add(parameter); } return returnParameters; } private static void importSteps(Experiment experiment, File stepsDirectory) throws IOException{ ArrayList<Step> steps = getStepsFromDirectory(stepsDirectory); for (Step step : steps) { experiment.addStep(step); } } public static ArrayList<Step> getStepsFromDirectory(File stepsDirectory) throws IOException { ArrayList<Step> returnSteps = new ArrayList<>(); File[] stepFiles = stepsDirectory.listFiles(); if (stepFiles != null) { for (File stepFile : stepFiles) { if(FilenameUtils.getExtension(stepFile.getName()).equals(""groovy"")) { Step step = new Step(); String stepName = FilenameUtils.removeExtension(stepFile.getName()); String source = FileUtils.readFileToString(stepFile); step.name = stepName; step.source = source; returnSteps.add(step); } else { } } } return returnSteps; } private static Experiment newExperiment(User user, Boolean isNewExperiment){ Experiment experiment = new Experiment(); if (isNewExperiment) { Step onJoin = Experiment.generateOnJoinStep(); Step onLeave = Experiment.generateOnLeaveStep(); Step init = Experiment.generateInitStep(); experiment.addStep(onJoin); experiment.addStep(onLeave); experiment.addStep(init); } experiment.setClientHtml(Experiment.defaultClientHTML()); experiment.setClientGraph(Experiment.defaultClientGraph()); experiment.languages.add(user.defaultLanguage); return experiment; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package controllers; public class ExperimentController extends Controller { @Security.Authenticated(Secured.class)
  public static Result createExperiment() { String newExperimentName; Long copyExperimentId; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } <FILL_ME> else { <FILL_ME> <FILL_ME> newExperimentName = json.findPath(""newExperimentName"").textValue(); copyExperimentId = json.findPath(""copyExperimentId"").asLong(); } if (newExperimentName == null) { return badRequest(""Please provide a name for the new experiment.""); } String uid = session().get(""uid""); User user = User.findByUID(uid); if (user == null) { return badRequest(""Unable to determine the user who made this request.""); } Experiment experiment = null; Experiment copyExperiment = Experiment.findById(copyExperimentId); if (copyExperiment != null) { experiment = new Experiment(copyExperiment); } if (experiment == null) { experiment = newExperiment(user, true); } experiment.name = newExperimentName; if (user.defaultLanguage != null && copyExperiment == null) { experiment.languages.add(user.defaultLanguage); } experiment.fileMode = false; experiment.save(); user.ownedExperiments.add(experiment); user.update(); user.saveManyToManyAssociations(""ownedExperiments""); return ok(experiment.toJson()); } @Security.Authenticated(Secured.class)
  public static Result importExperiment(String experimentName) throws IOException{ Http.MultipartFormData body = request().body().asMultipartFormData(); Long maxUploadSize = play.Play.application().configuration().getLong(""maxUploadSize"", 50L * 1024L * 1024L); try { Long fileSize = Long.parseLong(request().getHeader(""Content-Length""), 10); if (fileSize > maxUploadSize) { return badRequest(""Uploaded file is too large""); } } catch(Exception e){ return badRequest(""Upload was malformed""); } Http.MultipartFormData.FilePart filePart = body.getFile(""file""); File zippedFile = filePart.getFile(); if(experimentName == null || zippedFile == null){ return badRequest(""Must include zipFile and experiment name""); } if(zippedFile.length() > maxUploadSize){ return badRequest(""Uploaded file is too large""); } String uid = session().get(""uid""); User user = User.findByUID(uid); Experiment experiment = newExperiment(user, false); experiment.name = experimentName; experiment.save(); String timeString = new Date().getTime() + """"; String rootOutputFolder = ""experiments/"" + experiment.name + ""_"" + experiment.id + ""_"" + timeString; String outputFolder = rootOutputFolder; try { ZipFile zipFile = new ZipFile(zippedFile); zipFile.extractAll(outputFolder); File[] outputFiles = (new File(outputFolder)).listFiles(); for(File outputFile: outputFiles){ if(outputFile.getName().equals(""__MACOSX"") || outputFile.getName().equals(""__MAC_OSX"")){ deleteDirectory(outputFile); } } outputFiles = (new File(outputFolder)).listFiles(); if(outputFiles.length == 1){ File subDirectory = outputFiles[0]; <FILL_ME> File stepsDirectory = new File(subDirectory, ""Steps""); File contentDirectory = new File(subDirectory, ""Content""); if(stepsDirectory.exists() || contentDirectory.exists()) { outputFolder = subDirectory.getAbsolutePath(); <FILL_ME> } else { String msg = ""No Steps or Content directories found. Please upload a valid experiment""; <FILL_ME> <FILL_ME> deleteDirectory(new File(rootOutputFolder)); return badRequest(msg); } } else { File stepsDirectory = new File(outputFolder, ""Steps""); File contentDirectory = new File(outputFolder, ""Content""); if(!stepsDirectory.exists() || !contentDirectory.exists()){ String msg = ""No Steps or Content directories found. Please upload a valid experiment""; deleteDirectory(new File(rootOutputFolder)); return badRequest(msg); } } } catch (ZipException e){ e.printStackTrace(); } try{ String dotBreadboard = readFile(outputFolder + File.separator + "".breadboard"", StandardCharsets.UTF_8); ObjectMapper mapper = new ObjectMapper(); JsonNode dotBreadboardJson = mapper.readTree(dotBreadboard); String eVersion = dotBreadboardJson.findPath(""version"").textValue(); String eUid = dotBreadboardJson.findPath(""experimentUid"").textValue(); String eName = dotBreadboardJson.findPath(""experimentName"").textValue(); <FILL_ME> if(eVersion.startsWith(""v2.3"") || eVersion.startsWith(""v2.4"")){ import23To23(experiment, user, outputFolder); } else if (eVersion.startsWith(""v2.2"")) { import22To23(experiment, user, outputFolder); } else { import22To23(experiment, user, outputFolder); } } catch(IOException e){ <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> import22To23(experiment, user, outputFolder); } finally{ deleteDirectory(new File(rootOutputFolder)); } return ok(experiment.toJson()); } @Security.Authenticated(Secured.class)
  public static Result exportExperiment(Long experimentId){ Experiment experiment = Experiment.findById(experimentId); String uid = session().get(""uid""); User user = User.findByUID(uid); if(experiment == null){ return badRequest(""No experiment found with that ID""); } ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); try(ZipOutputStream zos = new ZipOutputStream(outputStream)) { ZipEntry e; ObjectNode dotBreadboard = Json.newObject(); String version = play.Play.application().configuration().getString(""application.version""); dotBreadboard.put(""version"", version); dotBreadboard.put(""experimentName"", experiment.name); dotBreadboard.put(""experimentUid"", experiment.uid); e = new ZipEntry("".breadboard""); zos.putNextEntry(e); zos.write(dotBreadboard.toString().getBytes()); zos.closeEntry(); e = new ZipEntry(""style.css""); zos.putNextEntry(e); zos.write(experiment.getStyle().getBytes()); zos.closeEntry(); e = new ZipEntry(""client-html.html""); zos.putNextEntry(e); zos.write(experiment.getClientHtml().getBytes()); zos.closeEntry(); e = new ZipEntry(""client-graph.js""); zos.putNextEntry(e); zos.write(experiment.getClientGraph().getBytes()); zos.closeEntry(); for (Step step : experiment.getSteps()) { e = new ZipEntry(""Steps/"" + step.name.concat("".groovy"")); zos.putNextEntry(e); zos.write(step.source.getBytes()); zos.closeEntry(); } for (Content c : experiment.getContent()){ for(Translation t : c.translations){ String language = (t.language == null || t.language.getCode() == null) ? user.defaultLanguage.getCode(): t.language.getCode(); e = new ZipEntry(""Content/"" + language + ""/"" + c.name.concat("".html"")); zos.putNextEntry(e); zos.write(t.html.getBytes()); zos.closeEntry(); } } e = new ZipEntry(""parameters.csv""); zos.putNextEntry(e); zos.write(experiment.parametersToCsv().getBytes()); zos.closeEntry(); for (Image image : experiment.getImages()) { e = new ZipEntry(""Images/"" + image.fileName); zos.putNextEntry(e); zos.write(image.file); zos.closeEntry(); } zos.close(); } catch(IOException ioe) { ioe.printStackTrace(); } return ok(outputStream.toByteArray()); } public static Long importExperimentFromDirectory(Long experimentId, User user, File directory) throws IOException { Experiment experiment; <FILL_ME> if (experimentId == null || ((experiment = Experiment.findById(experimentId)) == null) ) { experiment = new Experiment(); user.ownedExperiments.add(experiment); user.update(); user.saveManyToManyAssociations(""ownedExperiments""); } else { experiment.removeSteps(); experiment.removeContent(); experiment.removeParameters(); experiment.removeImages(); } experiment.setClientGraph(FileUtils.readFileToString(new File(directory, ""client-graph.js""))); experiment.setClientHtml(FileUtils.readFileToString(new File(directory, ""client-html.html""))); experiment.setStyle(FileUtils.readFileToString(new File(directory, ""style.css""))); importParameters(experiment, new File(directory, ""parameters.csv"")); importSteps(experiment, new File(directory, ""/Steps"")); importContent(experiment, new File(directory, ""/Content"")); importImages(experiment, new File(directory, ""/Images"")); experiment.save(); return experiment.id; } public static void exportExperimentToDirectory(Long experimentId, File directory) throws IOException { Experiment experiment = Experiment.findById(experimentId); if(experiment == null){ throw new IOException(""Experiment with the ID "" + experimentId + "" not found.""); } if (directory.exists() && directory.isDirectory()) { FileUtils.deleteDirectory(directory); } FileUtils.forceMkdir(directory); String version = play.Play.application().configuration().getString(""application.version""); ObjectNode dotBreadboard = Json.newObject(); dotBreadboard.put(""version"", version); dotBreadboard.put(""experimentName"", experiment.name); dotBreadboard.put(""experimentUid"", experiment.uid); FileUtils.writeStringToFile(new File(directory, "".breadboard""), dotBreadboard.toString()); FileUtils.writeStringToFile(new File(directory, ""style.css""), experiment.getStyle()); FileUtils.writeStringToFile(new File(directory, ""client-html.html""), experiment.getClientHtml()); FileUtils.writeStringToFile(new File(directory, ""client-graph.js""), experiment.getClientGraph()); File stepsDirectory = new File(directory, ""Steps""); if (!stepsDirectory.isDirectory()) { stepsDirectory.mkdir(); } for (Step step : experiment.getSteps()) { FileUtils.writeStringToFile(new File(stepsDirectory, step.name.concat("".groovy"")), step.source); } File contentDirectory = new File(directory, ""Content""); if (!contentDirectory.isDirectory()) { contentDirectory.mkdir(); } for (Content c : experiment.getContent()) { for (Translation t : c.translations) { String language = (t.language == null || t.language.getCode() == null) ? ""en"" : t.language.getCode(); File translationDirectory = new File(contentDirectory, language); FileUtils.writeStringToFile(new File(translationDirectory, c.name.concat("".html"")), t.html); } } FileUtils.writeStringToFile(new File(directory, ""parameters.csv""), experiment.parametersToCsv()); File imagesDirectory = new File(directory, ""Images""); if (!imagesDirectory.isDirectory()) { imagesDirectory.mkdir(); } for (Image image : experiment.getImages()) { FileUtils.writeByteArrayToFile(new File(imagesDirectory, image.fileName), image.file); } } private static String readFile(String path, Charset encoding) throws IOException{ byte[] encoded = Files.readAllBytes(Paths.get(path)); return new String(encoded, encoding); } private static Boolean import22To23(Experiment experiment, User user,  String directory) throws IOException{ try { String style = FileUtils.readFileToString(new File(directory, ""style.css"")); <FILL_ME> experiment.setStyle(style); } catch(IOException e){ } File contentDir = new File(directory, ""/Content""); for (File langFileOrDir : contentDir.listFiles()){ if(!langFileOrDir.isDirectory()){ <FILL_ME> try { importTranslations(experiment, user.defaultLanguage, contentDir); } catch(IOException e){ return false; } finally{ break; } } else { String languageIso3 = langFileOrDir.getName().equals(""null"") ? user.defaultLanguage.getCode() : langFileOrDir.getName(); Language language = Language.findByIso3(languageIso3); try{ importTranslations(experiment, language, langFileOrDir); } catch(IOException e){ } } } try { File stepsDirectory = new File(directory, ""/Steps""); importSteps(experiment, stepsDirectory); } catch(IOException e){ return false; } try { File parametersFile = new File(directory, ""parameters.csv""); importParameters(experiment, parametersFile); } catch(IOException e){ } try { File imagesDirectory = new File(directory, ""/Images""); importImages(experiment, imagesDirectory); } catch(IOException e){ return false; } experiment.setFileMode(false); experiment.save(); user.ownedExperiments.add(experiment); user.update(); user.saveManyToManyAssociations(""ownedExperiments""); return true; } private static Boolean import23To23(Experiment experiment, User user, String directory) throws IOException{ <FILL_ME> String style = FileUtils.readFileToString(new File(directory, ""style.css"")); experiment.setStyle(style); experiment.setClientGraph(FileUtils.readFileToString(new File(directory, ""client-graph.js""))); experiment.setClientHtml(FileUtils.readFileToString(new File(directory, ""client-html.html""))); experiment.setFileMode(false); importSteps(experiment, new File(directory, ""/Steps"")); importContent(experiment, new File(directory, ""/Content"")); importParameters(experiment, new File(directory, ""parameters.csv"")); importImages(experiment, new File(directory, ""/Images"")); experiment.save(); user.ownedExperiments.add(experiment); user.update(); user.saveManyToManyAssociations(""ownedExperiments""); return true; } private static void importContent(Experiment experiment, File contentDir) throws IOException { ArrayList<Content> content = getContentFromDirectory(contentDir); for (Content c : content) { for (Translation t : c.translations) { boolean hasExperimentLanguage = false; for(Language l: experiment.languages){ if(l.id.equals(t.language.id)){ hasExperimentLanguage = true; } } if(!hasExperimentLanguage){ experiment.languages.add(t.language); } } experiment.content.add(c); } } public static ArrayList<Content> getContentFromDirectory(File contentDir) throws IOException { ArrayList<Content> returnContent = new ArrayList<>(); if (!contentDir.isDirectory()) { return returnContent; } Language defaultLanguage = Language.findByIso3(""eng""); if (contentDir == null || !contentDir.exists()) { throw new IOException(""Directory not found.""); } for (File langFileOrDir : contentDir.listFiles()){ if(!langFileOrDir.isDirectory() && FilenameUtils.getExtension(langFileOrDir.getName()).equalsIgnoreCase(""html"")) { <FILL_ME> try { ArrayList<Content> rootContent = getContentFromSubdirectory(contentDir, defaultLanguage); returnContent.addAll(rootContent); } catch(IOException e){ } finally{ break; } } else if (langFileOrDir.isDirectory()) { Language language = Language.findByIso3(langFileOrDir.getName()); if(language == null){ language = defaultLanguage; } try{ ArrayList<Content> languageContent = getContentFromSubdirectory(langFileOrDir, language); returnContent.addAll(languageContent); } catch(IOException e){ } } } return returnContent; } private static void importTranslations(Experiment experiment, Language language, File directory) throws IOException { boolean hasExperimentLanguage = false; for(Language l: experiment.languages){ if(l.id.equals(language.id)){ hasExperimentLanguage = true; } } if(!hasExperimentLanguage){ experiment.languages.add(language); } ArrayList<Content> importedContent = getContentFromSubdirectory(directory, language); for(Content content: importedContent) { boolean contentExists = false; for (Content c : experiment.content) { if (c.name.equals(content.name)) { contentExists = true; <FILL_ME> break; } } if (!contentExists) { experiment.content.add(content); } } } private static ArrayList<Content> getContentFromSubdirectory(File directory, Language language) throws IOException { ArrayList<Content> returnContent = new ArrayList<>(); for(File file: directory.listFiles()){ if(FilenameUtils.getExtension(file.getName()).equals(""html"")){ Translation translation = new Translation(); translation.language = language; translation.html = FileUtils.readFileToString(file); String contentName = FilenameUtils.removeExtension(file.getName()); Content content = new Content(); content.name = contentName; content.translations.add(translation); returnContent.add(content); } } return returnContent; } private static void importImages(Experiment experiment, File directory) throws IOException { ArrayList<Image> images = getImagesFromDirectory(directory); experiment.images.addAll(images); experiment.save(); } public static ArrayList<Image> getImagesFromDirectory(File directory) throws IOException { ArrayList<Image> returnImages = new ArrayList<>(); File[] imageFiles = directory.listFiles(); if (!directory.isDirectory()) { return returnImages; } if (imageFiles != null) { for (File imageFile : imageFiles) { String imageName = FilenameUtils.removeExtension(imageFile.getName()); String ext = FilenameUtils.getExtension(imageFile.getName()); if(ext.matches(""(jpg|jpeg|png|bmp|gif|svg|webp)"")) { byte[] imageBytes = FileUtils.readFileToByteArray(imageFile); Image image = new Image(); image.fileName = imageFile.getName(); image.file = imageBytes; String extension = FilenameUtils.getExtension(imageFile.getName()); image.contentType = ""image/"" + extension; if(extension.equals(""svg"")){ image.contentType += ""+xml""; } returnImages.add(image); <FILL_ME> } else { } } } return returnImages; } private static void importParameters(Experiment experiment, File file) throws IOException { ArrayList<Parameter> parameters = getParametersFromFile(file); experiment.parameters.addAll(parameters); experiment.update(); } public static ArrayList<Parameter> getParametersFromFile(File parameterFile) throws IOException { ArrayList<Parameter> returnParameters = new ArrayList<>(); Reader in = new FileReader(parameterFile); CSVFormat format = CSVFormat.DEFAULT.withHeader(""Name"", ""Type"", ""Min."", ""Max."", ""Default"", ""Short Description"").withFirstRecordAsHeader(); for (CSVRecord record : format.parse(in)) { Parameter parameter = new Parameter(); parameter.name = record.get(""Name""); parameter.type = record.get(""Type""); parameter.minVal = record.get(""Min.""); parameter.maxVal = record.get(""Max.""); parameter.defaultVal = record.get(""Default""); parameter.description = record.get(""Short Description""); returnParameters.add(parameter); } return returnParameters; } private static void importSteps(Experiment experiment, File stepsDirectory) throws IOException{ ArrayList<Step> steps = getStepsFromDirectory(stepsDirectory); for (Step step : steps) { experiment.addStep(step); } } public static ArrayList<Step> getStepsFromDirectory(File stepsDirectory) throws IOException { ArrayList<Step> returnSteps = new ArrayList<>(); File[] stepFiles = stepsDirectory.listFiles(); if (stepFiles != null) { for (File stepFile : stepFiles) { if(FilenameUtils.getExtension(stepFile.getName()).equals(""groovy"")) { Step step = new Step(); String stepName = FilenameUtils.removeExtension(stepFile.getName()); String source = FileUtils.readFileToString(stepFile); step.name = stepName; step.source = source; returnSteps.add(step); <FILL_ME> } else { } } } return returnSteps; } private static Experiment newExperiment(User user, Boolean isNewExperiment){ Experiment experiment = new Experiment(); if (isNewExperiment) { Step onJoin = Experiment.generateOnJoinStep(); Step onLeave = Experiment.generateOnLeaveStep(); Step init = Experiment.generateInitStep(); experiment.addStep(onJoin); experiment.addStep(onLeave); experiment.addStep(init); } experiment.setClientHtml(Experiment.defaultClientHTML()); experiment.setClientGraph(Experiment.defaultClientGraph()); experiment.languages.add(user.defaultLanguage); return experiment; } } ","package controllers; 
import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.node.ObjectNode; import models.*; 
import net.lingala.zip4j.core.ZipFile; import net.lingala.zip4j.exception.ZipException; import org.apache.commons.csv.CSVFormat; import org.apache.commons.csv.CSVRecord; import org.apache.commons.io.FileUtils; import org.apache.commons.io.FilenameUtils; import play.Logger; import play.libs.Json; import play.mvc.Controller; import play.mvc.Http; import play.mvc.Result; import play.mvc.Security; 
import java.io.*; import java.nio.charset.Charset; import java.nio.charset.StandardCharsets; import java.nio.file.Files; import java.nio.file.Paths; import java.util.ArrayList; import java.util.Date; import java.util.zip.ZipEntry; import java.util.zip.ZipOutputStream; 
import static org.apache.commons.io.FileUtils.deleteDirectory;  public class ExperimentController extends Controller {  @Security.Authenticated(Secured.class)
  public static Result createExperiment() { String newExperimentName; Long copyExperimentId; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } <FILL_ME> else { <FILL_ME> <FILL_ME> newExperimentName = json.findPath(""newExperimentName"").textValue(); copyExperimentId = json.findPath(""copyExperimentId"").asLong(); }  if (newExperimentName == null) { return badRequest(""Please provide a name for the new experiment.""); }  String uid = session().get(""uid""); User user = User.findByUID(uid);  if (user == null) { return badRequest(""Unable to determine the user who made this request.""); }  Experiment experiment = null;  Experiment copyExperiment = Experiment.findById(copyExperimentId);  if (copyExperiment != null) { experiment = new Experiment(copyExperiment); }  if (experiment == null) { experiment = newExperiment(user, true); }  experiment.name = newExperimentName; if (user.defaultLanguage != null && copyExperiment == null) { experiment.languages.add(user.defaultLanguage); } experiment.fileMode = false; experiment.save();  user.ownedExperiments.add(experiment); user.update(); user.saveManyToManyAssociations(""ownedExperiments"");  return ok(experiment.toJson()); }  @Security.Authenticated(Secured.class)
  public static Result importExperiment(String experimentName) throws IOException{  Http.MultipartFormData body = request().body().asMultipartFormData(); Long maxUploadSize = play.Play.application().configuration().getLong(""maxUploadSize"", 50L * 1024L * 1024L);  // Validate Content-Length header try { Long fileSize = Long.parseLong(request().getHeader(""Content-Length""), 10); if (fileSize > maxUploadSize) { return badRequest(""Uploaded file is too large""); } } catch(Exception e){ return badRequest(""Upload was malformed""); }  // Validate the size of the file Http.MultipartFormData.FilePart filePart = body.getFile(""file""); File zippedFile = filePart.getFile();  // Validate the other data if(experimentName == null || zippedFile == null){ return badRequest(""Must include zipFile and experiment name""); }  if(zippedFile.length() > maxUploadSize){ return badRequest(""Uploaded file is too large""); }  String uid = session().get(""uid""); User user = User.findByUID(uid); Experiment experiment = newExperiment(user, false); experiment.name = experimentName; experiment.save();  String timeString = new Date().getTime() + """"; String rootOutputFolder = ""experiments/"" + experiment.name + ""_"" + experiment.id + ""_"" + timeString; String outputFolder = rootOutputFolder;  try { ZipFile zipFile = new ZipFile(zippedFile); zipFile.extractAll(outputFolder);  //Delete the __MAC_OSX directory if it exists File[] outputFiles = (new File(outputFolder)).listFiles(); for(File outputFile: outputFiles){ if(outputFile.getName().equals(""__MACOSX"") || outputFile.getName().equals(""__MAC_OSX"")){ deleteDirectory(outputFile); } }  outputFiles = (new File(outputFolder)).listFiles(); if(outputFiles.length == 1){ // Pull out the contents of this sub-directory into the main directory File subDirectory = outputFiles[0]; <FILL_ME> File stepsDirectory = new File(subDirectory, ""Steps""); File contentDirectory = new File(subDirectory, ""Content""); if(stepsDirectory.exists() || contentDirectory.exists()) { outputFolder = subDirectory.getAbsolutePath(); <FILL_ME> } else { String msg = ""No Steps or Content directories found. Please upload a valid experiment""; <FILL_ME> <FILL_ME> deleteDirectory(new File(rootOutputFolder)); return badRequest(msg); } } else { File stepsDirectory = new File(outputFolder, ""Steps""); File contentDirectory = new File(outputFolder, ""Content""); if(!stepsDirectory.exists() || !contentDirectory.exists()){ String msg = ""No Steps or Content directories found. Please upload a valid experiment""; deleteDirectory(new File(rootOutputFolder)); return badRequest(msg); } } } catch (ZipException e){ e.printStackTrace(); }  try{ String dotBreadboard = readFile(outputFolder + File.separator + "".breadboard"", StandardCharsets.UTF_8); ObjectMapper mapper = new ObjectMapper(); JsonNode dotBreadboardJson = mapper.readTree(dotBreadboard); String eVersion = dotBreadboardJson.findPath(""version"").textValue(); String eUid = dotBreadboardJson.findPath(""experimentUid"").textValue(); String eName = dotBreadboardJson.findPath(""experimentName"").textValue(); <FILL_ME> // TODO: offer the option to import the Experiment UID and/or Name from the .breadboard file   if(eVersion.startsWith(""v2.3"") || eVersion.startsWith(""v2.4"")){ import23To23(experiment, user, outputFolder); } else if (eVersion.startsWith(""v2.2"")) { import22To23(experiment, user, outputFolder); } else { // Default to v2.2 import for now import22To23(experiment, user, outputFolder); } } catch(IOException e){ <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> import22To23(experiment, user, outputFolder); } finally{ deleteDirectory(new File(rootOutputFolder)); }  return ok(experiment.toJson()); }  @Security.Authenticated(Secured.class)
  public static Result exportExperiment(Long experimentId){  Experiment experiment = Experiment.findById(experimentId); String uid = session().get(""uid""); User user = User.findByUID(uid); if(experiment == null){ return badRequest(""No experiment found with that ID""); }  ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); try(ZipOutputStream zos = new ZipOutputStream(outputStream)) { ZipEntry e;  ObjectNode dotBreadboard = Json.newObject(); String version = play.Play.application().configuration().getString(""application.version""); dotBreadboard.put(""version"", version); dotBreadboard.put(""experimentName"", experiment.name); dotBreadboard.put(""experimentUid"", experiment.uid);  e = new ZipEntry("".breadboard""); zos.putNextEntry(e); zos.write(dotBreadboard.toString().getBytes()); zos.closeEntry();  // Client style/html/graph e = new ZipEntry(""style.css""); zos.putNextEntry(e); zos.write(experiment.getStyle().getBytes()); zos.closeEntry();  e = new ZipEntry(""client-html.html""); zos.putNextEntry(e); zos.write(experiment.getClientHtml().getBytes()); zos.closeEntry();  e = new ZipEntry(""client-graph.js""); zos.putNextEntry(e); zos.write(experiment.getClientGraph().getBytes()); zos.closeEntry();  // Steps for (Step step : experiment.getSteps()) { e = new ZipEntry(""Steps/"" + step.name.concat("".groovy"")); zos.putNextEntry(e); zos.write(step.source.getBytes()); zos.closeEntry(); }  // Content in language subfolders for (Content c : experiment.getContent()){ for(Translation t : c.translations){ String language = (t.language == null || t.language.getCode() == null) ? user.defaultLanguage.getCode(): t.language.getCode(); e = new ZipEntry(""Content/"" + language + ""/"" + c.name.concat("".html"")); zos.putNextEntry(e); zos.write(t.html.getBytes()); zos.closeEntry(); } }  // Create the parameters.csv file e = new ZipEntry(""parameters.csv""); zos.putNextEntry(e); zos.write(experiment.parametersToCsv().getBytes()); zos.closeEntry();  // Write image files to stream for (Image image : experiment.getImages()) { e = new ZipEntry(""Images/"" + image.fileName); zos.putNextEntry(e); zos.write(image.file); zos.closeEntry(); }  // Finish by closing the stream zos.close();  } catch(IOException ioe) { ioe.printStackTrace(); }  return ok(outputStream.toByteArray());  }  /**
   * If experimentId is null or invalid, creates a new experiment and returns the newly created experiment ID.
   * Otherwise, imports the experiment files over the existing experiment and returns the provided experimentID.
   * @param experimentId  The ID of the experiment to import over, if null or invalid create new experiment
   * @param user          The User who is making the import request, newly created experiments will be associated with the user
   * @param directory     The File location of the experiment files to impoart
   * @return              the experimentId of the imported experiment
   * @throws IOException
   */ public static Long importExperimentFromDirectory(Long experimentId, User user, File directory) throws IOException { Experiment experiment; <FILL_ME> if (experimentId == null || ((experiment = Experiment.findById(experimentId)) == null) ) { // New experiment experiment = new Experiment(); user.ownedExperiments.add(experiment); user.update(); user.saveManyToManyAssociations(""ownedExperiments""); } else { // Existing experiment, delete before re-importing experiment.removeSteps(); experiment.removeContent(); experiment.removeParameters(); experiment.removeImages(); } experiment.setClientGraph(FileUtils.readFileToString(new File(directory, ""client-graph.js""))); experiment.setClientHtml(FileUtils.readFileToString(new File(directory, ""client-html.html""))); experiment.setStyle(FileUtils.readFileToString(new File(directory, ""style.css""))); importParameters(experiment, new File(directory, ""parameters.csv"")); importSteps(experiment, new File(directory, ""/Steps"")); importContent(experiment, new File(directory, ""/Content"")); importImages(experiment, new File(directory, ""/Images"")); experiment.save(); return experiment.id; }  public static void exportExperimentToDirectory(Long experimentId, File directory) throws IOException { Experiment experiment = Experiment.findById(experimentId); if(experiment == null){ throw new IOException(""Experiment with the ID "" + experimentId + "" not found.""); }  // Clean up existing files if (directory.exists() && directory.isDirectory()) { FileUtils.deleteDirectory(directory); }  // Create the directory FileUtils.forceMkdir(directory);  String version = play.Play.application().configuration().getString(""application.version""); ObjectNode dotBreadboard = Json.newObject(); dotBreadboard.put(""version"", version); dotBreadboard.put(""experimentName"", experiment.name); dotBreadboard.put(""experimentUid"", experiment.uid);  FileUtils.writeStringToFile(new File(directory, "".breadboard""), dotBreadboard.toString()); FileUtils.writeStringToFile(new File(directory, ""style.css""), experiment.getStyle()); FileUtils.writeStringToFile(new File(directory, ""client-html.html""), experiment.getClientHtml()); FileUtils.writeStringToFile(new File(directory, ""client-graph.js""), experiment.getClientGraph());  File stepsDirectory = new File(directory, ""Steps""); if (!stepsDirectory.isDirectory()) { stepsDirectory.mkdir(); } for (Step step : experiment.getSteps()) { FileUtils.writeStringToFile(new File(stepsDirectory, step.name.concat("".groovy"")), step.source); }  File contentDirectory = new File(directory, ""Content""); if (!contentDirectory.isDirectory()) { contentDirectory.mkdir(); } for (Content c : experiment.getContent()) { for (Translation t : c.translations) { String language = (t.language == null || t.language.getCode() == null) ? ""en"" : t.language.getCode(); File translationDirectory = new File(contentDirectory, language); FileUtils.writeStringToFile(new File(translationDirectory, c.name.concat("".html"")), t.html); } }  FileUtils.writeStringToFile(new File(directory, ""parameters.csv""), experiment.parametersToCsv());  File imagesDirectory = new File(directory, ""Images""); if (!imagesDirectory.isDirectory()) { imagesDirectory.mkdir(); } for (Image image : experiment.getImages()) { FileUtils.writeByteArrayToFile(new File(imagesDirectory, image.fileName), image.file); } } 
 private static String readFile(String path, Charset encoding) throws IOException{ byte[] encoded = Files.readAllBytes(Paths.get(path)); return new String(encoded, encoding); }   private static Boolean import22To23(Experiment experiment, User user,  String directory) throws IOException{ try { String style = FileUtils.readFileToString(new File(directory, ""style.css"")); <FILL_ME> experiment.setStyle(style); } catch(IOException e){ } /**
   * Specific import function for import v2.2 exports into v2.3 of breadboard. There are some small differences in the
   * export format that must be dealt with as well as breaking changes to the client-html and client-graph that are
   * avoided by simply not importing those files.
   * @param experiment
   * @param user
   * @param directory
   * @return
   */  File contentDir = new File(directory, ""/Content""); for (File langFileOrDir : contentDir.listFiles()){ if(!langFileOrDir.isDirectory()){ <FILL_ME> try { importTranslations(experiment, user.defaultLanguage, contentDir); } catch(IOException e){ return false; } finally{ break; } } else { // Import content String languageIso3 = langFileOrDir.getName().equals(""null"") ? user.defaultLanguage.getCode() : langFileOrDir.getName(); Language language = Language.findByIso3(languageIso3); // Content is broken out by language try{ importTranslations(experiment, language, langFileOrDir); } catch(IOException e){ } } } //        Language language = Language.findByIso3(langFileOrDir.getName());  try { File stepsDirectory = new File(directory, ""/Steps""); importSteps(experiment, stepsDirectory); } catch(IOException e){ return false; } // Import steps  try { File parametersFile = new File(directory, ""parameters.csv""); importParameters(experiment, parametersFile); } catch(IOException e){ } // Import parameters  try { File imagesDirectory = new File(directory, ""/Images""); importImages(experiment, imagesDirectory); } catch(IOException e){ return false; } // Import images  experiment.setFileMode(false); experiment.save(); // Write changes to DB user.ownedExperiments.add(experiment); user.update(); user.saveManyToManyAssociations(""ownedExperiments"");  return true; }  private static Boolean import23To23(Experiment experiment, User user, String directory) throws IOException{ <FILL_ME> 
 String style = FileUtils.readFileToString(new File(directory, ""style.css"")); experiment.setStyle(style); experiment.setClientGraph(FileUtils.readFileToString(new File(directory, ""client-graph.js""))); experiment.setClientHtml(FileUtils.readFileToString(new File(directory, ""client-html.html""))); experiment.setFileMode(false);   importSteps(experiment, new File(directory, ""/Steps""));  importContent(experiment, new File(directory, ""/Content"")); // Import Steps importParameters(experiment, new File(directory, ""parameters.csv"")); // Import Content importImages(experiment, new File(directory, ""/Images"")); // Import Parameters experiment.save(); // Import Images user.ownedExperiments.add(experiment); user.update(); user.saveManyToManyAssociations(""ownedExperiments""); // Save return true; }  private static void importContent(Experiment experiment, File contentDir) throws IOException { ArrayList<Content> content = getContentFromDirectory(contentDir); for (Content c : content) { for (Translation t : c.translations) { boolean hasExperimentLanguage = false; for(Language l: experiment.languages){ if(l.id.equals(t.language.id)){ hasExperimentLanguage = true; } } if(!hasExperimentLanguage){ experiment.languages.add(t.language); } } experiment.content.add(c); } }  public static ArrayList<Content> getContentFromDirectory(File contentDir) throws IOException { ArrayList<Content> returnContent = new ArrayList<>(); if (!contentDir.isDirectory()) { return returnContent; } 
 Language defaultLanguage = Language.findByIso3(""eng""); if (contentDir == null || !contentDir.exists()) { throw new IOException(""Directory not found.""); } for (File langFileOrDir : contentDir.listFiles()){ if(!langFileOrDir.isDirectory() && FilenameUtils.getExtension(langFileOrDir.getName()).equalsIgnoreCase(""html"")) { <FILL_ME> try { ArrayList<Content> rootContent = getContentFromSubdirectory(contentDir, defaultLanguage); returnContent.addAll(rootContent); } catch(IOException e){ } finally{ break; } } else if (langFileOrDir.isDirectory()) {  Language language = Language.findByIso3(langFileOrDir.getName());  // Default to English if the directory isn't specified if(language == null){ language = defaultLanguage; } try{ ArrayList<Content> languageContent = getContentFromSubdirectory(langFileOrDir, language); returnContent.addAll(languageContent); } catch(IOException e){ } } } return returnContent; // Content is broken out by language }  // Sometimes the subdirectory is named null or something else private static void importTranslations(Experiment experiment, Language language, File directory) throws IOException {  
 boolean hasExperimentLanguage = false; for(Language l: experiment.languages){ if(l.id.equals(language.id)){ hasExperimentLanguage = true; } } if(!hasExperimentLanguage){ experiment.languages.add(language); }  ArrayList<Content> importedContent = getContentFromSubdirectory(directory, language); /**
   * Import all html files in the supplied directory as translations of the supplied language and experiment.
   * @param experiment
   * @param language
   * @param directory
   * @throws IOException
   */ for(Content content: importedContent) {  boolean contentExists = false; for (Content c : experiment.content) { if (c.name.equals(content.name)) { contentExists = true; <FILL_ME> break; } } // Check for existing experiment language and add it if it doesn't exist  if (!contentExists) { experiment.content.add(content); } }  } // Check for existing content and create if it doesn't exist private static ArrayList<Content> getContentFromSubdirectory(File directory, Language language) throws IOException { ArrayList<Content> returnContent = new ArrayList<>();  for(File file: directory.listFiles()){ if(FilenameUtils.getExtension(file.getName()).equals(""html"")){ Translation translation = new Translation(); translation.language = language; translation.html = FileUtils.readFileToString(file); // If content with that name doesn't already exist, import it String contentName = FilenameUtils.removeExtension(file.getName()); Content content = new Content(); content.name = contentName; content.translations.add(translation);  returnContent.add(content); } }  return returnContent; }   private static void importImages(Experiment experiment, File directory) throws IOException { ArrayList<Image> images = getImagesFromDirectory(directory); experiment.images.addAll(images); experiment.save(); }  public static ArrayList<Image> getImagesFromDirectory(File directory) throws IOException { ArrayList<Image> returnImages = new ArrayList<>(); File[] imageFiles = directory.listFiles(); if (!directory.isDirectory()) { return returnImages; } if (imageFiles != null) { for (File imageFile : imageFiles) { String imageName = FilenameUtils.removeExtension(imageFile.getName()); String ext = FilenameUtils.getExtension(imageFile.getName()); if(ext.matches(""(jpg|jpeg|png|bmp|gif|svg|webp)"")) { byte[] imageBytes = FileUtils.readFileToByteArray(imageFile); Image image = new Image(); image.fileName = imageFile.getName(); image.file = imageBytes; String extension = FilenameUtils.getExtension(imageFile.getName()); image.contentType = ""image/"" + extension; if(extension.equals(""svg"")){ image.contentType += ""+xml""; } returnImages.add(image); <FILL_ME> } else { } } } return returnImages; }  private static void importParameters(Experiment experiment, File file) throws IOException { ArrayList<Parameter> parameters = getParametersFromFile(file); experiment.parameters.addAll(parameters); experiment.update(); }  public static ArrayList<Parameter> getParametersFromFile(File parameterFile) throws IOException { ArrayList<Parameter> returnParameters = new ArrayList<>(); Reader in = new FileReader(parameterFile); CSVFormat format = CSVFormat.DEFAULT.withHeader(""Name"", ""Type"", ""Min."", ""Max."", ""Default"", ""Short Description"").withFirstRecordAsHeader(); for (CSVRecord record : format.parse(in)) { Parameter parameter = new Parameter(); parameter.name = record.get(""Name""); parameter.type = record.get(""Type""); parameter.minVal = record.get(""Min.""); parameter.maxVal = record.get(""Max.""); parameter.defaultVal = record.get(""Default""); parameter.description = record.get(""Short Description""); returnParameters.add(parameter); } return returnParameters; } /**
   * Import all of the images from the specified directory as members of the specified experiment.
   * @param experiment
   * @param directory
   * @throws IOException
   */  private static void importSteps(Experiment experiment, File stepsDirectory) throws IOException{ ArrayList<Step> steps = getStepsFromDirectory(stepsDirectory); for (Step step : steps) { experiment.addStep(step); } }  public static ArrayList<Step> getStepsFromDirectory(File stepsDirectory) throws IOException { ArrayList<Step> returnSteps = new ArrayList<>(); File[] stepFiles = stepsDirectory.listFiles(); if (stepFiles != null) { for (File stepFile : stepFiles) { if(FilenameUtils.getExtension(stepFile.getName()).equals(""groovy"")) { Step step = new Step(); String stepName = FilenameUtils.removeExtension(stepFile.getName()); String source = FileUtils.readFileToString(stepFile); step.name = stepName; step.source = source; returnSteps.add(step); <FILL_ME> } else { } } } return returnSteps; }  private static Experiment newExperiment(User user, Boolean isNewExperiment){ Experiment experiment = new Experiment(); if (isNewExperiment) { Step onJoin = Experiment.generateOnJoinStep(); Step onLeave = Experiment.generateOnLeaveStep(); Step init = Experiment.generateInitStep(); experiment.addStep(onJoin); experiment.addStep(onLeave); experiment.addStep(init); } experiment.setClientHtml(Experiment.defaultClientHTML()); experiment.setClientGraph(Experiment.defaultClientGraph());  experiment.languages.add(user.defaultLanguage); return experiment; } } // Reusable code for importing steps "
app/controllers/ImagesController.java,"package controllers;

import models.Experiment;
import models.Image;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import play.Logger;
import play.Play;
import play.mvc.Controller;
import play.mvc.Http;
import play.mvc.Result;
import play.mvc.Security;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.Map;

public class ImagesController extends Controller {

  @Security.Authenticated(Secured.class)
  public static Result uploadImage() {
    Http.MultipartFormData body = request().body().asMultipartFormData();
    Http.MultipartFormData.FilePart picture = body.getFile(""picture[file]"");
    if (picture != null) {
      String fileName = picture.getFilename();
      String contentType = picture.getContentType();
      File file = picture.getFile();

      Map<String, String[]> values = body.asFormUrlEncoded();

      try {
        String experimentId = values.get(""experimentId"")[0];
        Long eid = Long.parseLong(experimentId);
        Experiment experiment = Experiment.findById(eid);
        Image image = new Image();
        String uniqueFileName = fileName;
        // If there is already an Image with the same filename, append a ""-2"" to the filename
        int appendNumber = 2;
        while (Image.find.where().eq(""experiment_id"", experimentId).eq(""file_name"", uniqueFileName).findRowCount() > 0) {
          uniqueFileName = FilenameUtils.removeExtension(fileName) + ""-"" + appendNumber + ""."" + FilenameUtils.getExtension(fileName);
          appendNumber++;
        }
        image.fileName = uniqueFileName;
        image.file = FileUtils.readFileToByteArray(file);
        image.contentType = contentType;
        experiment.images.add(image);
        experiment.save();
        return ok(image.toJson());
      } catch (NullPointerException npe) {
        Logger.error(""NullPointerException in uploadImage(): "" + npe.getMessage());
        return ok(""Error uploading"");
      } catch (NumberFormatException nfe) {
        Logger.error(""NumberFormatException in uploadImage(): "" + nfe.getMessage());
        return ok(""Error uploading"");
      } catch (IOException ioe) {
        Logger.error(""IOException in uploadImage(): "" + ioe.getMessage());
        return ok(""Error uploading"");
      }
    } else {
      return ok(""Error uploading"");
    }
  }

  @Security.Authenticated(Secured.class)
  public static Result removeImage(Long imageId) {
    Image image = Image.find.byId(imageId);
    if (image != null) {
      image.delete();
    } else {
      return badRequest(""Invalid image ID"");
    }
    return ok();
  }

  public static Result getImage(Long imageId) {
    Image image = Image.findById(imageId);

    if (image != null) {
      if (image.contentType != null && image.file != null) {
        response().setContentType(image.contentType);
        return ok(image.file);
      }
    }

    return notFound();
  }

  public static Result getImageByFileName(Long experimentId, String fileName) {
    Experiment experiment = Experiment.findById(experimentId);
    if (experiment == null) {
      return notFound();
    }

    if (experiment.fileMode) {
      File imageDirectory = new File(Play.application().path().toString() + ""/dev/"" + experiment.getDirectoryName() + ""/Images"");
      try {
        File file = FileUtils.getFile(imageDirectory, fileName);
        String contentType = Files.probeContentType(file.toPath());
        byte[] contents = FileUtils.readFileToByteArray(file);
        response().setContentType(contentType);
        return ok(contents);
      } catch (IOException ioe) {
        return notFound();
      }
    }

    Image image = Image.find.where()
        .eq(""experiment_id"", experimentId)
        .eq(""file_name"", fileName)
        .setMaxRows(1)
        .findUnique();

    if (image != null) {
      if (image.contentType != null && image.file != null) {
        response().setContentType(image.contentType);
        return ok(image.file);
      }
    }

    return notFound();
  }

  public static Result getImageThumb(Long imageId) {
    Image image = Image.findById(imageId);

    if (image != null) {
      if (image.contentType != null && image.thumbFile != null && image.thumbFile.length > 0) {
        response().setContentType(image.contentType);
        return ok(image.thumbFile);
      }
    }

    return notFound();
  }
}
","package controllers; public class ImagesController extends Controller { @Security.Authenticated(Secured.class)
  public static Result uploadImage() { Http.MultipartFormData body = request().body().asMultipartFormData(); Http.MultipartFormData.FilePart picture = body.getFile(""picture[file]""); if (picture != null) { String fileName = picture.getFilename(); String contentType = picture.getContentType(); File file = picture.getFile(); Map<String, String[]> values = body.asFormUrlEncoded(); try { String experimentId = values.get(""experimentId"")[0]; Long eid = Long.parseLong(experimentId); Experiment experiment = Experiment.findById(eid); Image image = new Image(); String uniqueFileName = fileName; int appendNumber = 2; while (Image.find.where().eq(""experiment_id"", experimentId).eq(""file_name"", uniqueFileName).findRowCount() > 0) { uniqueFileName = FilenameUtils.removeExtension(fileName) + ""-"" + appendNumber + ""."" + FilenameUtils.getExtension(fileName); appendNumber++; } image.fileName = uniqueFileName; image.file = FileUtils.readFileToByteArray(file); image.contentType = contentType; experiment.images.add(image); experiment.save(); return ok(image.toJson()); } catch (NullPointerException npe) { return ok(""Error uploading""); } catch (NumberFormatException nfe) { return ok(""Error uploading""); } catch (IOException ioe) { return ok(""Error uploading""); } } else { return ok(""Error uploading""); } } @Security.Authenticated(Secured.class)
  public static Result removeImage(Long imageId) { Image image = Image.find.byId(imageId); if (image != null) { image.delete(); } else { return badRequest(""Invalid image ID""); } return ok(); } public static Result getImage(Long imageId) { Image image = Image.findById(imageId); if (image != null) { if (image.contentType != null && image.file != null) { response().setContentType(image.contentType); return ok(image.file); } } return notFound(); } public static Result getImageByFileName(Long experimentId, String fileName) { Experiment experiment = Experiment.findById(experimentId); if (experiment == null) { return notFound(); } if (experiment.fileMode) { File imageDirectory = new File(Play.application().path().toString() + ""/dev/"" + experiment.getDirectoryName() + ""/Images""); try { File file = FileUtils.getFile(imageDirectory, fileName); String contentType = Files.probeContentType(file.toPath()); byte[] contents = FileUtils.readFileToByteArray(file); response().setContentType(contentType); return ok(contents); } catch (IOException ioe) { return notFound(); } } Image image = Image.find.where()
        .eq(""experiment_id"", experimentId)
        .eq(""file_name"", fileName)
        .setMaxRows(1)
        .findUnique(); if (image != null) { if (image.contentType != null && image.file != null) { response().setContentType(image.contentType); return ok(image.file); } } return notFound(); } public static Result getImageThumb(Long imageId) { Image image = Image.findById(imageId); if (image != null) { if (image.contentType != null && image.thumbFile != null && image.thumbFile.length > 0) { response().setContentType(image.contentType); return ok(image.thumbFile); } } return notFound(); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package controllers; public class ImagesController extends Controller { @Security.Authenticated(Secured.class)
  public static Result uploadImage() { Http.MultipartFormData body = request().body().asMultipartFormData(); Http.MultipartFormData.FilePart picture = body.getFile(""picture[file]""); if (picture != null) { String fileName = picture.getFilename(); String contentType = picture.getContentType(); File file = picture.getFile(); Map<String, String[]> values = body.asFormUrlEncoded(); try { String experimentId = values.get(""experimentId"")[0]; Long eid = Long.parseLong(experimentId); Experiment experiment = Experiment.findById(eid); Image image = new Image(); String uniqueFileName = fileName; int appendNumber = 2; while (Image.find.where().eq(""experiment_id"", experimentId).eq(""file_name"", uniqueFileName).findRowCount() > 0) { uniqueFileName = FilenameUtils.removeExtension(fileName) + ""-"" + appendNumber + ""."" + FilenameUtils.getExtension(fileName); appendNumber++; } image.fileName = uniqueFileName; image.file = FileUtils.readFileToByteArray(file); image.contentType = contentType; experiment.images.add(image); experiment.save(); return ok(image.toJson()); } catch (NullPointerException npe) { <FILL_ME> return ok(""Error uploading""); } catch (NumberFormatException nfe) { <FILL_ME> return ok(""Error uploading""); } catch (IOException ioe) { <FILL_ME> return ok(""Error uploading""); } } else { return ok(""Error uploading""); } } @Security.Authenticated(Secured.class)
  public static Result removeImage(Long imageId) { Image image = Image.find.byId(imageId); if (image != null) { image.delete(); } else { return badRequest(""Invalid image ID""); } return ok(); } public static Result getImage(Long imageId) { Image image = Image.findById(imageId); if (image != null) { if (image.contentType != null && image.file != null) { response().setContentType(image.contentType); return ok(image.file); } } return notFound(); } public static Result getImageByFileName(Long experimentId, String fileName) { Experiment experiment = Experiment.findById(experimentId); if (experiment == null) { return notFound(); } if (experiment.fileMode) { File imageDirectory = new File(Play.application().path().toString() + ""/dev/"" + experiment.getDirectoryName() + ""/Images""); try { File file = FileUtils.getFile(imageDirectory, fileName); String contentType = Files.probeContentType(file.toPath()); byte[] contents = FileUtils.readFileToByteArray(file); response().setContentType(contentType); return ok(contents); } catch (IOException ioe) { return notFound(); } } Image image = Image.find.where()
        .eq(""experiment_id"", experimentId)
        .eq(""file_name"", fileName)
        .setMaxRows(1)
        .findUnique(); if (image != null) { if (image.contentType != null && image.file != null) { response().setContentType(image.contentType); return ok(image.file); } } return notFound(); } public static Result getImageThumb(Long imageId) { Image image = Image.findById(imageId); if (image != null) { if (image.contentType != null && image.thumbFile != null && image.thumbFile.length > 0) { response().setContentType(image.contentType); return ok(image.thumbFile); } } return notFound(); } } ","package controllers; 
import models.Experiment; import models.Image; import org.apache.commons.io.FileUtils; import org.apache.commons.io.FilenameUtils; import play.Logger; import play.Play; import play.mvc.Controller; import play.mvc.Http; import play.mvc.Result; import play.mvc.Security; 
import java.io.File; import java.io.IOException; import java.nio.file.Files; import java.util.Map;  public class ImagesController extends Controller {  @Security.Authenticated(Secured.class)
  public static Result uploadImage() { Http.MultipartFormData body = request().body().asMultipartFormData(); Http.MultipartFormData.FilePart picture = body.getFile(""picture[file]""); if (picture != null) { String fileName = picture.getFilename(); String contentType = picture.getContentType(); File file = picture.getFile();  Map<String, String[]> values = body.asFormUrlEncoded();  try { String experimentId = values.get(""experimentId"")[0]; Long eid = Long.parseLong(experimentId); Experiment experiment = Experiment.findById(eid); Image image = new Image(); String uniqueFileName = fileName; // If there is already an Image with the same filename, append a ""-2"" to the filename int appendNumber = 2; while (Image.find.where().eq(""experiment_id"", experimentId).eq(""file_name"", uniqueFileName).findRowCount() > 0) { uniqueFileName = FilenameUtils.removeExtension(fileName) + ""-"" + appendNumber + ""."" + FilenameUtils.getExtension(fileName); appendNumber++; } image.fileName = uniqueFileName; image.file = FileUtils.readFileToByteArray(file); image.contentType = contentType; experiment.images.add(image); experiment.save(); return ok(image.toJson()); } catch (NullPointerException npe) { <FILL_ME> return ok(""Error uploading""); } catch (NumberFormatException nfe) { <FILL_ME> return ok(""Error uploading""); } catch (IOException ioe) { <FILL_ME> return ok(""Error uploading""); } } else { return ok(""Error uploading""); } }  @Security.Authenticated(Secured.class)
  public static Result removeImage(Long imageId) { Image image = Image.find.byId(imageId); if (image != null) { image.delete(); } else { return badRequest(""Invalid image ID""); } return ok(); }  public static Result getImage(Long imageId) { Image image = Image.findById(imageId);  if (image != null) { if (image.contentType != null && image.file != null) { response().setContentType(image.contentType); return ok(image.file); } }  return notFound(); }  public static Result getImageByFileName(Long experimentId, String fileName) { Experiment experiment = Experiment.findById(experimentId); if (experiment == null) { return notFound(); }  if (experiment.fileMode) { File imageDirectory = new File(Play.application().path().toString() + ""/dev/"" + experiment.getDirectoryName() + ""/Images""); try { File file = FileUtils.getFile(imageDirectory, fileName); String contentType = Files.probeContentType(file.toPath()); byte[] contents = FileUtils.readFileToByteArray(file); response().setContentType(contentType); return ok(contents); } catch (IOException ioe) { return notFound(); } }  Image image = Image.find.where()
        .eq(""experiment_id"", experimentId)
        .eq(""file_name"", fileName)
        .setMaxRows(1)
        .findUnique();  if (image != null) { if (image.contentType != null && image.file != null) { response().setContentType(image.contentType); return ok(image.file); } }  return notFound(); }  public static Result getImageThumb(Long imageId) { Image image = Image.findById(imageId);  if (image != null) { if (image.contentType != null && image.thumbFile != null && image.thumbFile.length > 0) { response().setContentType(image.contentType); return ok(image.thumbFile); } }  return notFound(); } }  "
app/controllers/LanguageController.java,"package controllers;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import models.Experiment;
import models.Language;
import play.libs.Json;
import play.mvc.Controller;
import play.mvc.Result;
import play.mvc.Security;

import java.util.*;

public class LanguageController extends Controller {

  public static List<Language> seedLanguages() {
    Locale[] locales = Locale.getAvailableLocales();
    Set<String> addedLanguages = new HashSet<>();
    List<Language> returnLanguages = new ArrayList<>();
    for (Locale locale : locales) {
      if (locale.getISO3Language().length() > 0 &&
          locale.getDisplayLanguage().length() > 0 &&
          (! addedLanguages.contains(locale.getISO3Language() + '-' + locale.getDisplayLanguage()))) {
        addedLanguages.add(locale.getISO3Language() + '-' + locale.getDisplayLanguage());
        Language language = new Language();
        language.setName(locale.getDisplayLanguage());
        language.setCode(locale.getISO3Language());
        language.save();
        returnLanguages.add(language);
      }
    }
    return returnLanguages;
  }

  public static Result getLanguages() {
    ObjectNode returnJson = Json.newObject();
    ArrayNode jsonLanguages = returnJson.putArray(""languages"");
    List<Language> languages = Language.findAll();
    if (languages.isEmpty()) {
      // The database table is empty, add default languages
      languages = seedLanguages();
    }
    for (Language language : languages) {
      jsonLanguages.add(language.toJson());
    }
    return ok(returnJson);
  }

  @Security.Authenticated(Secured.class)
  public static Result addLanguage() {
    Long experimentId;
    Long languageId;
    JsonNode json = request().body().asJson();
    if(json == null) {
      return badRequest(""Expecting Json data"");
    } else {
      experimentId = json.findValue(""experimentId"").asLong();
      languageId = json.findValue(""languageId"").asLong();
    }

    Experiment experiment = Experiment.findById(experimentId);
    Language language = Language.findById(languageId);

    if (experiment == null || language == null) {
      return badRequest(""Invalid experiment or language ID"");
    }

    if (!experiment.languages.contains(language)) {
      experiment.languages.add(language);
      experiment.save();
    }

    return ok(language.toJson());
  }

  @Security.Authenticated(Secured.class)
  public static Result removeLanguage() {
    Long experimentId;
    Long languageId;
    JsonNode json = request().body().asJson();
    if(json == null) {
      return badRequest(""Expecting Json data"");
    } else {
      experimentId = json.findValue(""experimentId"").asLong();
      languageId = json.findValue(""languageId"").asLong();
    }

    Experiment experiment = Experiment.findById(experimentId);
    Language language = Language.findById(languageId);

    if (experiment == null || language == null) {
      return badRequest(""Invalid experiment or language ID"");
    }

    experiment.languages.remove(language);
    experiment.save();
    experiment.saveManyToManyAssociations(""languages"");

    return ok();
  }
}
","package controllers; public class LanguageController extends Controller { public static List<Language> seedLanguages() { Locale[] locales = Locale.getAvailableLocales(); Set<String> addedLanguages = new HashSet<>(); List<Language> returnLanguages = new ArrayList<>(); for (Locale locale : locales) { if (locale.getISO3Language().length() > 0 &&
          locale.getDisplayLanguage().length() > 0 &&
          (! addedLanguages.contains(locale.getISO3Language() + '-' + locale.getDisplayLanguage()))) { addedLanguages.add(locale.getISO3Language() + '-' + locale.getDisplayLanguage()); Language language = new Language(); language.setName(locale.getDisplayLanguage()); language.setCode(locale.getISO3Language()); language.save(); returnLanguages.add(language); } } return returnLanguages; } public static Result getLanguages() { ObjectNode returnJson = Json.newObject(); ArrayNode jsonLanguages = returnJson.putArray(""languages""); List<Language> languages = Language.findAll(); if (languages.isEmpty()) { languages = seedLanguages(); } for (Language language : languages) { jsonLanguages.add(language.toJson()); } return ok(returnJson); } @Security.Authenticated(Secured.class)
  public static Result addLanguage() { Long experimentId; Long languageId; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { experimentId = json.findValue(""experimentId"").asLong(); languageId = json.findValue(""languageId"").asLong(); } Experiment experiment = Experiment.findById(experimentId); Language language = Language.findById(languageId); if (experiment == null || language == null) { return badRequest(""Invalid experiment or language ID""); } if (!experiment.languages.contains(language)) { experiment.languages.add(language); experiment.save(); } return ok(language.toJson()); } @Security.Authenticated(Secured.class)
  public static Result removeLanguage() { Long experimentId; Long languageId; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { experimentId = json.findValue(""experimentId"").asLong(); languageId = json.findValue(""languageId"").asLong(); } Experiment experiment = Experiment.findById(experimentId); Language language = Language.findById(languageId); if (experiment == null || language == null) { return badRequest(""Invalid experiment or language ID""); } experiment.languages.remove(language); experiment.save(); experiment.saveManyToManyAssociations(""languages""); return ok(); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package controllers; public class LanguageController extends Controller { public static List<Language> seedLanguages() { Locale[] locales = Locale.getAvailableLocales(); Set<String> addedLanguages = new HashSet<>(); List<Language> returnLanguages = new ArrayList<>(); for (Locale locale : locales) { if (locale.getISO3Language().length() > 0 &&
          locale.getDisplayLanguage().length() > 0 &&
          (! addedLanguages.contains(locale.getISO3Language() + '-' + locale.getDisplayLanguage()))) { addedLanguages.add(locale.getISO3Language() + '-' + locale.getDisplayLanguage()); Language language = new Language(); language.setName(locale.getDisplayLanguage()); language.setCode(locale.getISO3Language()); language.save(); returnLanguages.add(language); } } return returnLanguages; } public static Result getLanguages() { ObjectNode returnJson = Json.newObject(); ArrayNode jsonLanguages = returnJson.putArray(""languages""); List<Language> languages = Language.findAll(); if (languages.isEmpty()) { languages = seedLanguages(); } for (Language language : languages) { jsonLanguages.add(language.toJson()); } return ok(returnJson); } @Security.Authenticated(Secured.class)
  public static Result addLanguage() { Long experimentId; Long languageId; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { experimentId = json.findValue(""experimentId"").asLong(); languageId = json.findValue(""languageId"").asLong(); } Experiment experiment = Experiment.findById(experimentId); Language language = Language.findById(languageId); if (experiment == null || language == null) { return badRequest(""Invalid experiment or language ID""); } if (!experiment.languages.contains(language)) { experiment.languages.add(language); experiment.save(); } return ok(language.toJson()); } @Security.Authenticated(Secured.class)
  public static Result removeLanguage() { Long experimentId; Long languageId; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { experimentId = json.findValue(""experimentId"").asLong(); languageId = json.findValue(""languageId"").asLong(); } Experiment experiment = Experiment.findById(experimentId); Language language = Language.findById(languageId); if (experiment == null || language == null) { return badRequest(""Invalid experiment or language ID""); } experiment.languages.remove(language); experiment.save(); experiment.saveManyToManyAssociations(""languages""); return ok(); } } ","package controllers; 
import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.node.ArrayNode; import com.fasterxml.jackson.databind.node.ObjectNode; import models.Experiment; import models.Language; import play.libs.Json; import play.mvc.Controller; import play.mvc.Result; import play.mvc.Security; 
import java.util.*;  public class LanguageController extends Controller {  public static List<Language> seedLanguages() { Locale[] locales = Locale.getAvailableLocales(); Set<String> addedLanguages = new HashSet<>(); List<Language> returnLanguages = new ArrayList<>(); for (Locale locale : locales) { if (locale.getISO3Language().length() > 0 &&
          locale.getDisplayLanguage().length() > 0 &&
          (! addedLanguages.contains(locale.getISO3Language() + '-' + locale.getDisplayLanguage()))) { addedLanguages.add(locale.getISO3Language() + '-' + locale.getDisplayLanguage()); Language language = new Language(); language.setName(locale.getDisplayLanguage()); language.setCode(locale.getISO3Language()); language.save(); returnLanguages.add(language); } } return returnLanguages; }  public static Result getLanguages() { ObjectNode returnJson = Json.newObject(); ArrayNode jsonLanguages = returnJson.putArray(""languages""); List<Language> languages = Language.findAll(); if (languages.isEmpty()) { // The database table is empty, add default languages languages = seedLanguages(); } for (Language language : languages) { jsonLanguages.add(language.toJson()); } return ok(returnJson); }  @Security.Authenticated(Secured.class)
  public static Result addLanguage() { Long experimentId; Long languageId; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { experimentId = json.findValue(""experimentId"").asLong(); languageId = json.findValue(""languageId"").asLong(); }  Experiment experiment = Experiment.findById(experimentId); Language language = Language.findById(languageId);  if (experiment == null || language == null) { return badRequest(""Invalid experiment or language ID""); }  if (!experiment.languages.contains(language)) { experiment.languages.add(language); experiment.save(); }  return ok(language.toJson()); }  @Security.Authenticated(Secured.class)
  public static Result removeLanguage() { Long experimentId; Long languageId; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { experimentId = json.findValue(""experimentId"").asLong(); languageId = json.findValue(""languageId"").asLong(); }  Experiment experiment = Experiment.findById(experimentId); Language language = Language.findById(languageId);  if (experiment == null || language == null) { return badRequest(""Invalid experiment or language ID""); }  experiment.languages.remove(language); experiment.save(); experiment.saveManyToManyAssociations(""languages"");  return ok(); } }  "
app/controllers/ParametersController.java,"package controllers;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import models.Parameter;
import models.Experiment;
import play.libs.Json;
import play.mvc.Controller;
import play.mvc.Result;
import play.mvc.Security;

public class ParametersController extends Controller {

  @Security.Authenticated(Secured.class)
  public static Result createParameter(Long experimentId) {

    Experiment experiment = Experiment.findById(experimentId);
    if (experiment == null) {
      return badRequest(""Invalid experiment ID"");
     }
    String name, type, minVal, maxVal, defaultVal, description;
    JsonNode json = request().body().asJson();
    if(json == null) {
      return badRequest(""Expecting Json data"");
    } else {
      name = json.findPath(""name"").textValue();
      type = json.findPath(""type"").textValue();
      minVal = json.findPath(""minVal"").textValue();
      maxVal = json.findPath(""maxVal"").textValue();
      defaultVal = json.findPath(""defaultVal"").textValue();
      description = json.findPath(""description"").textValue();
    }

    Parameter parameter = new Parameter();
    parameter.name = name;
    parameter.type = type;
    parameter.minVal = (type.equals(""Text"") || type.equals(""Boolean"")) ? """" : minVal;
    parameter.maxVal = (type.equals(""Text"") || type.equals(""Boolean"")) ? """" : maxVal;
    parameter.defaultVal = defaultVal;
    parameter.description = description;

    experiment.parameters.add(parameter);
    experiment.save();

    ObjectNode returnJson = Json.newObject();
    returnJson.put(""parameter"", parameter.toJson());
    return ok(returnJson);
  }

  @Security.Authenticated(Secured.class)
  public static Result removeParameter(Long experimentId, Long parameterId) {
    Experiment experiment = Experiment.findById(experimentId);
    Parameter parameter = Parameter.find.byId(parameterId+"""");
    if (parameter != null && experiment != null) {
      experiment.parameters.remove(parameter);
      experiment.update();
      parameter.delete();
    } else {
      return badRequest(""Invalid experiment or parameter ID"");
    }
    return ok();
  }
}
","package controllers; public class ParametersController extends Controller { @Security.Authenticated(Secured.class)
  public static Result createParameter(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if (experiment == null) { return badRequest(""Invalid experiment ID""); } String name, type, minVal, maxVal, defaultVal, description; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { name = json.findPath(""name"").textValue(); type = json.findPath(""type"").textValue(); minVal = json.findPath(""minVal"").textValue(); maxVal = json.findPath(""maxVal"").textValue(); defaultVal = json.findPath(""defaultVal"").textValue(); description = json.findPath(""description"").textValue(); } Parameter parameter = new Parameter(); parameter.name = name; parameter.type = type; parameter.minVal = (type.equals(""Text"") || type.equals(""Boolean"")) ? """" : minVal; parameter.maxVal = (type.equals(""Text"") || type.equals(""Boolean"")) ? """" : maxVal; parameter.defaultVal = defaultVal; parameter.description = description; experiment.parameters.add(parameter); experiment.save(); ObjectNode returnJson = Json.newObject(); returnJson.put(""parameter"", parameter.toJson()); return ok(returnJson); } @Security.Authenticated(Secured.class)
  public static Result removeParameter(Long experimentId, Long parameterId) { Experiment experiment = Experiment.findById(experimentId); Parameter parameter = Parameter.find.byId(parameterId+""""); if (parameter != null && experiment != null) { experiment.parameters.remove(parameter); experiment.update(); parameter.delete(); } else { return badRequest(""Invalid experiment or parameter ID""); } return ok(); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package controllers; public class ParametersController extends Controller { @Security.Authenticated(Secured.class)
  public static Result createParameter(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if (experiment == null) { return badRequest(""Invalid experiment ID""); } String name, type, minVal, maxVal, defaultVal, description; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { name = json.findPath(""name"").textValue(); type = json.findPath(""type"").textValue(); minVal = json.findPath(""minVal"").textValue(); maxVal = json.findPath(""maxVal"").textValue(); defaultVal = json.findPath(""defaultVal"").textValue(); description = json.findPath(""description"").textValue(); } Parameter parameter = new Parameter(); parameter.name = name; parameter.type = type; parameter.minVal = (type.equals(""Text"") || type.equals(""Boolean"")) ? """" : minVal; parameter.maxVal = (type.equals(""Text"") || type.equals(""Boolean"")) ? """" : maxVal; parameter.defaultVal = defaultVal; parameter.description = description; experiment.parameters.add(parameter); experiment.save(); ObjectNode returnJson = Json.newObject(); returnJson.put(""parameter"", parameter.toJson()); return ok(returnJson); } @Security.Authenticated(Secured.class)
  public static Result removeParameter(Long experimentId, Long parameterId) { Experiment experiment = Experiment.findById(experimentId); Parameter parameter = Parameter.find.byId(parameterId+""""); if (parameter != null && experiment != null) { experiment.parameters.remove(parameter); experiment.update(); parameter.delete(); } else { return badRequest(""Invalid experiment or parameter ID""); } return ok(); } } ","package controllers; 
import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.node.ObjectNode; import models.Parameter; import models.Experiment; import play.libs.Json; import play.mvc.Controller; import play.mvc.Result; import play.mvc.Security;  public class ParametersController extends Controller {  @Security.Authenticated(Secured.class)
  public static Result createParameter(Long experimentId) {  Experiment experiment = Experiment.findById(experimentId); if (experiment == null) { return badRequest(""Invalid experiment ID""); } String name, type, minVal, maxVal, defaultVal, description; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { name = json.findPath(""name"").textValue(); type = json.findPath(""type"").textValue(); minVal = json.findPath(""minVal"").textValue(); maxVal = json.findPath(""maxVal"").textValue(); defaultVal = json.findPath(""defaultVal"").textValue(); description = json.findPath(""description"").textValue(); }  Parameter parameter = new Parameter(); parameter.name = name; parameter.type = type; parameter.minVal = (type.equals(""Text"") || type.equals(""Boolean"")) ? """" : minVal; parameter.maxVal = (type.equals(""Text"") || type.equals(""Boolean"")) ? """" : maxVal; parameter.defaultVal = defaultVal; parameter.description = description;  experiment.parameters.add(parameter); experiment.save();  ObjectNode returnJson = Json.newObject(); returnJson.put(""parameter"", parameter.toJson()); return ok(returnJson); }  @Security.Authenticated(Secured.class)
  public static Result removeParameter(Long experimentId, Long parameterId) { Experiment experiment = Experiment.findById(experimentId); Parameter parameter = Parameter.find.byId(parameterId+""""); if (parameter != null && experiment != null) { experiment.parameters.remove(parameter); experiment.update(); parameter.delete(); } else { return badRequest(""Invalid experiment or parameter ID""); } return ok(); } }  "
app/controllers/Secured.java,"package controllers;

import com.fasterxml.jackson.databind.node.ObjectNode;
import models.User;
import play.mvc.Http.Context;
import play.mvc.Result;
import play.mvc.Security;
import play.libs.Json;

public class Secured extends Security.Authenticator {
  @Override
  public String getUsername(Context ctx) {
    String uid = ctx.session().get(""uid"");
    User user = User.findByUID(uid);
    if(user != null) {
      return user.email;
    } else {
      return null;
    }
  }

  @Override
  public Result onUnauthorized(Context ctx) {
    ObjectNode result = Json.newObject();
    if (User.findRowCount() == 0) {
      result.put(""status"", ""create-first-user"");
    } else {
      result.put(""status"", ""unauthorized"");
    }
    result.put(""message"", ""please login"");
    return unauthorized(result);
  }
}
","package controllers; public class Secured extends Security.Authenticator { @Override
  public String getUsername(Context ctx) { String uid = ctx.session().get(""uid""); User user = User.findByUID(uid); if(user != null) { return user.email; } else { return null; } } @Override
  public Result onUnauthorized(Context ctx) { ObjectNode result = Json.newObject(); if (User.findRowCount() == 0) { result.put(""status"", ""create-first-user""); } else { result.put(""status"", ""unauthorized""); } result.put(""message"", ""please login""); return unauthorized(result); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package controllers; public class Secured extends Security.Authenticator { @Override
  public String getUsername(Context ctx) { String uid = ctx.session().get(""uid""); User user = User.findByUID(uid); if(user != null) { return user.email; } else { return null; } } @Override
  public Result onUnauthorized(Context ctx) { ObjectNode result = Json.newObject(); if (User.findRowCount() == 0) { result.put(""status"", ""create-first-user""); } else { result.put(""status"", ""unauthorized""); } result.put(""message"", ""please login""); return unauthorized(result); } } ","package controllers; 
import com.fasterxml.jackson.databind.node.ObjectNode; import models.User; import play.mvc.Http.Context; import play.mvc.Result; import play.mvc.Security; import play.libs.Json;  public class Secured extends Security.Authenticator { @Override
  public String getUsername(Context ctx) { String uid = ctx.session().get(""uid""); User user = User.findByUID(uid); if(user != null) { return user.email; } else { return null; } }  @Override
  public Result onUnauthorized(Context ctx) { ObjectNode result = Json.newObject(); if (User.findRowCount() == 0) { result.put(""status"", ""create-first-user""); } else { result.put(""status"", ""unauthorized""); } result.put(""message"", ""please login""); return unauthorized(result); } }  "
app/controllers/SecuredClient.java,"package controllers;

import org.apache.commons.lang3.ArrayUtils;
import play.mvc.Http.Context;
import play.mvc.Result;
import play.mvc.Security;

public class SecuredClient extends Security.Authenticator {
  @Override
  public String getUsername(Context ctx) {
    return ctx.session().get(""id"");
  }

  @Override
  public Result onUnauthorized(Context ctx) {
    String[] pathComponents = ctx.request().path().split(""/"");
    String experimentId = pathComponents[ArrayUtils.indexOf(pathComponents, ""game"") + 1];
    String experimentInstanceId = pathComponents[ArrayUtils.indexOf(pathComponents, ""game"") + 2];
    return redirect(routes.ClientLogin.login(experimentId, experimentInstanceId));
  }
}
","package controllers; public class SecuredClient extends Security.Authenticator { @Override
  public String getUsername(Context ctx) { return ctx.session().get(""id""); } @Override
  public Result onUnauthorized(Context ctx) { String[] pathComponents = ctx.request().path().split(""/""); String experimentId = pathComponents[ArrayUtils.indexOf(pathComponents, ""game"") + 1]; String experimentInstanceId = pathComponents[ArrayUtils.indexOf(pathComponents, ""game"") + 2]; return redirect(routes.ClientLogin.login(experimentId, experimentInstanceId)); } }",0 0 0 0 0 0 0 0 0 0 0 0 0,"package controllers; public class SecuredClient extends Security.Authenticator { @Override
  public String getUsername(Context ctx) { return ctx.session().get(""id""); } @Override
  public Result onUnauthorized(Context ctx) { String[] pathComponents = ctx.request().path().split(""/""); String experimentId = pathComponents[ArrayUtils.indexOf(pathComponents, ""game"") + 1]; String experimentInstanceId = pathComponents[ArrayUtils.indexOf(pathComponents, ""game"") + 2]; return redirect(routes.ClientLogin.login(experimentId, experimentInstanceId)); } } ","package controllers; 
import org.apache.commons.lang3.ArrayUtils; import play.mvc.Http.Context; import play.mvc.Result; import play.mvc.Security;  public class SecuredClient extends Security.Authenticator { @Override
  public String getUsername(Context ctx) { return ctx.session().get(""id""); }  @Override
  public Result onUnauthorized(Context ctx) { String[] pathComponents = ctx.request().path().split(""/""); String experimentId = pathComponents[ArrayUtils.indexOf(pathComponents, ""game"") + 1]; String experimentInstanceId = pathComponents[ArrayUtils.indexOf(pathComponents, ""game"") + 2]; return redirect(routes.ClientLogin.login(experimentId, experimentInstanceId)); } }  "
app/controllers/StepsController.java,"package controllers;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import models.Experiment;
import models.Step;
import play.libs.Json;
import play.mvc.Controller;
import play.mvc.Result;
import play.mvc.Security;

public class StepsController extends Controller {

  @Security.Authenticated(Secured.class)
  public static Result getSteps(Long experimentId) {
    Experiment experiment = Experiment.findById(experimentId);
    if(experiment == null) {
      return badRequest(""Invalid Experiment ID"");
    }

    ObjectNode returnJson = Json.newObject();

    ArrayNode jsonSteps = returnJson.putArray(""steps"");
    for (Step s : experiment.getSteps()) {
      jsonSteps.add(s.toJson());
    }

    return ok(returnJson);
  }

  @Security.Authenticated(Secured.class)
  public static Result deleteStep(Long stepId) {
    Step step = Step.findById(stepId);
    if (step == null) {
      return badRequest(""Invalid Step ID"");
    }
    step.delete();
    return ok();
  }

  @Security.Authenticated(Secured.class)
  public static Result updateStep(Long stepId) {
    Step step;
    Experiment experiment = null;

    Boolean isNewStep = (stepId == -1);
    if (isNewStep) {
      step = new Step();
    } else {
      step = Step.findById(stepId);
    }

    if (step == null) {
      return badRequest(""Invalid Step ID"");
    }

    String name;
    String source;
    Long experimentId;
    JsonNode json = request().body().asJson();
    if(json == null) {
      return badRequest(""Expecting Json data"");
    } else {
      name = json.findPath(""name"").textValue();
      source = json.findPath(""stepSource"").textValue();
      experimentId = json.findValue(""experimentId"").asLong();
    }

    if (source == null) {
      return badRequest(""Please provide step source."");
    }

    if (isNewStep) {
      experiment = Experiment.findById(experimentId);
    }

    if (isNewStep && experiment == null) {
      return badRequest(""Invalid experiment ID."");
    }

    if (isNewStep && name == null) {
      return badRequest(""Please provide step name."");
    }

    step.setSource(source);
    step.setName(name);
    if (isNewStep) {
      experiment.addStep(step);
      experiment.save();
    } else {
      step.update();
    }

    return ok(step.toJson());
  }
}
","package controllers; public class StepsController extends Controller { @Security.Authenticated(Secured.class)
  public static Result getSteps(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if(experiment == null) { return badRequest(""Invalid Experiment ID""); } ObjectNode returnJson = Json.newObject(); ArrayNode jsonSteps = returnJson.putArray(""steps""); for (Step s : experiment.getSteps()) { jsonSteps.add(s.toJson()); } return ok(returnJson); } @Security.Authenticated(Secured.class)
  public static Result deleteStep(Long stepId) { Step step = Step.findById(stepId); if (step == null) { return badRequest(""Invalid Step ID""); } step.delete(); return ok(); } @Security.Authenticated(Secured.class)
  public static Result updateStep(Long stepId) { Step step; Experiment experiment = null; Boolean isNewStep = (stepId == -1); if (isNewStep) { step = new Step(); } else { step = Step.findById(stepId); } if (step == null) { return badRequest(""Invalid Step ID""); } String name; String source; Long experimentId; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { name = json.findPath(""name"").textValue(); source = json.findPath(""stepSource"").textValue(); experimentId = json.findValue(""experimentId"").asLong(); } if (source == null) { return badRequest(""Please provide step source.""); } if (isNewStep) { experiment = Experiment.findById(experimentId); } if (isNewStep && experiment == null) { return badRequest(""Invalid experiment ID.""); } if (isNewStep && name == null) { return badRequest(""Please provide step name.""); } step.setSource(source); step.setName(name); if (isNewStep) { experiment.addStep(step); experiment.save(); } else { step.update(); } return ok(step.toJson()); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package controllers; public class StepsController extends Controller { @Security.Authenticated(Secured.class)
  public static Result getSteps(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if(experiment == null) { return badRequest(""Invalid Experiment ID""); } ObjectNode returnJson = Json.newObject(); ArrayNode jsonSteps = returnJson.putArray(""steps""); for (Step s : experiment.getSteps()) { jsonSteps.add(s.toJson()); } return ok(returnJson); } @Security.Authenticated(Secured.class)
  public static Result deleteStep(Long stepId) { Step step = Step.findById(stepId); if (step == null) { return badRequest(""Invalid Step ID""); } step.delete(); return ok(); } @Security.Authenticated(Secured.class)
  public static Result updateStep(Long stepId) { Step step; Experiment experiment = null; Boolean isNewStep = (stepId == -1); if (isNewStep) { step = new Step(); } else { step = Step.findById(stepId); } if (step == null) { return badRequest(""Invalid Step ID""); } String name; String source; Long experimentId; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { name = json.findPath(""name"").textValue(); source = json.findPath(""stepSource"").textValue(); experimentId = json.findValue(""experimentId"").asLong(); } if (source == null) { return badRequest(""Please provide step source.""); } if (isNewStep) { experiment = Experiment.findById(experimentId); } if (isNewStep && experiment == null) { return badRequest(""Invalid experiment ID.""); } if (isNewStep && name == null) { return badRequest(""Please provide step name.""); } step.setSource(source); step.setName(name); if (isNewStep) { experiment.addStep(step); experiment.save(); } else { step.update(); } return ok(step.toJson()); } } ","package controllers; 
import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.node.ArrayNode; import com.fasterxml.jackson.databind.node.ObjectNode; import models.Experiment; import models.Step; import play.libs.Json; import play.mvc.Controller; import play.mvc.Result; import play.mvc.Security;  public class StepsController extends Controller {  @Security.Authenticated(Secured.class)
  public static Result getSteps(Long experimentId) { Experiment experiment = Experiment.findById(experimentId); if(experiment == null) { return badRequest(""Invalid Experiment ID""); }  ObjectNode returnJson = Json.newObject();  ArrayNode jsonSteps = returnJson.putArray(""steps""); for (Step s : experiment.getSteps()) { jsonSteps.add(s.toJson()); }  return ok(returnJson); }  @Security.Authenticated(Secured.class)
  public static Result deleteStep(Long stepId) { Step step = Step.findById(stepId); if (step == null) { return badRequest(""Invalid Step ID""); } step.delete(); return ok(); }  @Security.Authenticated(Secured.class)
  public static Result updateStep(Long stepId) { Step step; Experiment experiment = null;  Boolean isNewStep = (stepId == -1); if (isNewStep) { step = new Step(); } else { step = Step.findById(stepId); }  if (step == null) { return badRequest(""Invalid Step ID""); }  String name; String source; Long experimentId; JsonNode json = request().body().asJson(); if(json == null) { return badRequest(""Expecting Json data""); } else { name = json.findPath(""name"").textValue(); source = json.findPath(""stepSource"").textValue(); experimentId = json.findValue(""experimentId"").asLong(); }  if (source == null) { return badRequest(""Please provide step source.""); }  if (isNewStep) { experiment = Experiment.findById(experimentId); }  if (isNewStep && experiment == null) { return badRequest(""Invalid experiment ID.""); }  if (isNewStep && name == null) { return badRequest(""Please provide step name.""); }  step.setSource(source); step.setName(name); if (isNewStep) { experiment.addStep(step); experiment.save(); } else { step.update(); }  return ok(step.toJson()); } }  "
app/exceptions/BreadboardException.java,"package exceptions;

public class BreadboardException extends Exception {
  public BreadboardException(String err) {
    super(err);
  }
}
",package exceptions; public class BreadboardException extends Exception { public BreadboardException(String err) { super(err); } },0 0 0 0 0 0 0,package exceptions; public class BreadboardException extends Exception { public BreadboardException(String err) { super(err); } } ,package exceptions;  public class BreadboardException extends Exception { public BreadboardException(String err) { super(err); } }  
app/models/AMTAssignment.java,"package models;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.databind.node.ObjectNode;
import play.db.ebean.Model;
import play.libs.Json;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import javax.persistence.Table;
import java.util.List;

@Entity
@Table(name = ""amt_assignments"")
public class AMTAssignment extends Model {
  @Id
  public Long id;

  public String assignmentId;
  public String workerId;
  public String assignmentStatus;
  public String autoApprovalTime;
  public String acceptTime;
  public String submitTime;
  public String answer;
  public String score;
  public String reason;
  public String completion;
  public String bonusAmount;

  public Boolean assignmentCompleted;
  public Boolean bonusGranted;
  public Boolean workerBlocked;
  public Boolean qualificationAssigned;

  @JsonIgnore
  @ManyToOne
  public AMTHit amtHit;

  @JsonIgnore
  public static Model.Finder<Long, AMTAssignment> find = new Model.Finder(Long.class, AMTAssignment.class);

  public static List<AMTAssignment> findAll() {
    return find.all();
  }

  public static AMTAssignment findByAssignmentId(String assignmentId) {
    return find.where().eq(""assignmentId"", assignmentId).findUnique();
  }

  public static int findRowCountByWorkerId(String workerId) {
    return find.where().eq(""workerId"", workerId).eq(""assignmentCompleted"", true).findRowCount();
  }

  public AMTAssignment() {
  }

  public ObjectNode toJson() {
    ObjectNode amtAssignment = Json.newObject();

    amtAssignment.put(""id"", id);
    amtAssignment.put(""assignmentId"", assignmentId);
    amtAssignment.put(""workerId"", workerId);
    amtAssignment.put(""assignmentStatus"", assignmentStatus);
    amtAssignment.put(""autoApprovalTime"", autoApprovalTime);
    amtAssignment.put(""acceptTime"", acceptTime);
    amtAssignment.put(""submitTime"", submitTime);
    amtAssignment.put(""answer"", (answer==null) ? """" : answer);
    amtAssignment.put(""score"", score);
    amtAssignment.put(""reason"", reason);
    amtAssignment.put(""completion"", completion);
    amtAssignment.put(""assignmentCompleted"", assignmentCompleted);
    amtAssignment.put(""bonusGranted"", bonusGranted);
    amtAssignment.put(""bonusAmount"", bonusAmount);
    amtAssignment.put(""workerBlocked"", workerBlocked);
    amtAssignment.put(""qualificationAssigned"", qualificationAssigned);

    return amtAssignment;
  }

  public String toString() {
    return ""AMTAssignment("" + id + "")"";
  }
}
","package models; @Entity
@Table(name = ""amt_assignments"")
public class AMTAssignment extends Model { @Id
  public Long id; public String assignmentId; public String workerId; public String assignmentStatus; public String autoApprovalTime; public String acceptTime; public String submitTime; public String answer; public String score; public String reason; public String completion; public String bonusAmount; public Boolean assignmentCompleted; public Boolean bonusGranted; public Boolean workerBlocked; public Boolean qualificationAssigned; @JsonIgnore
  @ManyToOne
  public AMTHit amtHit; @JsonIgnore
  public static Model.Finder<Long, AMTAssignment> find = new Model.Finder(Long.class, AMTAssignment.class); public static List<AMTAssignment> findAll() { return find.all(); } public static AMTAssignment findByAssignmentId(String assignmentId) { return find.where().eq(""assignmentId"", assignmentId).findUnique(); } public static int findRowCountByWorkerId(String workerId) { return find.where().eq(""workerId"", workerId).eq(""assignmentCompleted"", true).findRowCount(); } public AMTAssignment() { } public ObjectNode toJson() { ObjectNode amtAssignment = Json.newObject(); amtAssignment.put(""id"", id); amtAssignment.put(""assignmentId"", assignmentId); amtAssignment.put(""workerId"", workerId); amtAssignment.put(""assignmentStatus"", assignmentStatus); amtAssignment.put(""autoApprovalTime"", autoApprovalTime); amtAssignment.put(""acceptTime"", acceptTime); amtAssignment.put(""submitTime"", submitTime); amtAssignment.put(""answer"", (answer==null) ? """" : answer); amtAssignment.put(""score"", score); amtAssignment.put(""reason"", reason); amtAssignment.put(""completion"", completion); amtAssignment.put(""assignmentCompleted"", assignmentCompleted); amtAssignment.put(""bonusGranted"", bonusGranted); amtAssignment.put(""bonusAmount"", bonusAmount); amtAssignment.put(""workerBlocked"", workerBlocked); amtAssignment.put(""qualificationAssigned"", qualificationAssigned); return amtAssignment; } public String toString() { return ""AMTAssignment("" + id + "")""; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; @Entity
@Table(name = ""amt_assignments"")
public class AMTAssignment extends Model { @Id
  public Long id; public String assignmentId; public String workerId; public String assignmentStatus; public String autoApprovalTime; public String acceptTime; public String submitTime; public String answer; public String score; public String reason; public String completion; public String bonusAmount; public Boolean assignmentCompleted; public Boolean bonusGranted; public Boolean workerBlocked; public Boolean qualificationAssigned; @JsonIgnore
  @ManyToOne
  public AMTHit amtHit; @JsonIgnore
  public static Model.Finder<Long, AMTAssignment> find = new Model.Finder(Long.class, AMTAssignment.class); public static List<AMTAssignment> findAll() { return find.all(); } public static AMTAssignment findByAssignmentId(String assignmentId) { return find.where().eq(""assignmentId"", assignmentId).findUnique(); } public static int findRowCountByWorkerId(String workerId) { return find.where().eq(""workerId"", workerId).eq(""assignmentCompleted"", true).findRowCount(); } public AMTAssignment() { } public ObjectNode toJson() { ObjectNode amtAssignment = Json.newObject(); amtAssignment.put(""id"", id); amtAssignment.put(""assignmentId"", assignmentId); amtAssignment.put(""workerId"", workerId); amtAssignment.put(""assignmentStatus"", assignmentStatus); amtAssignment.put(""autoApprovalTime"", autoApprovalTime); amtAssignment.put(""acceptTime"", acceptTime); amtAssignment.put(""submitTime"", submitTime); amtAssignment.put(""answer"", (answer==null) ? """" : answer); amtAssignment.put(""score"", score); amtAssignment.put(""reason"", reason); amtAssignment.put(""completion"", completion); amtAssignment.put(""assignmentCompleted"", assignmentCompleted); amtAssignment.put(""bonusGranted"", bonusGranted); amtAssignment.put(""bonusAmount"", bonusAmount); amtAssignment.put(""workerBlocked"", workerBlocked); amtAssignment.put(""qualificationAssigned"", qualificationAssigned); return amtAssignment; } public String toString() { return ""AMTAssignment("" + id + "")""; } } ","package models; 
import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.databind.node.ObjectNode; import play.db.ebean.Model; import play.libs.Json; 
import javax.persistence.Entity; import javax.persistence.Id; import javax.persistence.ManyToOne; import javax.persistence.Table; import java.util.List;  @Entity
@Table(name = ""amt_assignments"")
public class AMTAssignment extends Model { @Id
  public Long id;  public String assignmentId; public String workerId; public String assignmentStatus; public String autoApprovalTime; public String acceptTime; public String submitTime; public String answer; public String score; public String reason; public String completion; public String bonusAmount;  public Boolean assignmentCompleted; public Boolean bonusGranted; public Boolean workerBlocked; public Boolean qualificationAssigned;  @JsonIgnore
  @ManyToOne
  public AMTHit amtHit;  @JsonIgnore
  public static Model.Finder<Long, AMTAssignment> find = new Model.Finder(Long.class, AMTAssignment.class);  public static List<AMTAssignment> findAll() { return find.all(); }  public static AMTAssignment findByAssignmentId(String assignmentId) { return find.where().eq(""assignmentId"", assignmentId).findUnique(); }  public static int findRowCountByWorkerId(String workerId) { return find.where().eq(""workerId"", workerId).eq(""assignmentCompleted"", true).findRowCount(); }  public AMTAssignment() { }  public ObjectNode toJson() { ObjectNode amtAssignment = Json.newObject();  amtAssignment.put(""id"", id); amtAssignment.put(""assignmentId"", assignmentId); amtAssignment.put(""workerId"", workerId); amtAssignment.put(""assignmentStatus"", assignmentStatus); amtAssignment.put(""autoApprovalTime"", autoApprovalTime); amtAssignment.put(""acceptTime"", acceptTime); amtAssignment.put(""submitTime"", submitTime); amtAssignment.put(""answer"", (answer==null) ? """" : answer); amtAssignment.put(""score"", score); amtAssignment.put(""reason"", reason); amtAssignment.put(""completion"", completion); amtAssignment.put(""assignmentCompleted"", assignmentCompleted); amtAssignment.put(""bonusGranted"", bonusGranted); amtAssignment.put(""bonusAmount"", bonusAmount); amtAssignment.put(""workerBlocked"", workerBlocked); amtAssignment.put(""qualificationAssigned"", qualificationAssigned);  return amtAssignment; }  public String toString() { return ""AMTAssignment("" + id + "")""; } }  "
app/models/AMTHit.java,"package models;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import play.data.format.Formats;
import play.data.validation.Constraints;
import play.db.ebean.Model;
import play.libs.Json;

import javax.persistence.*;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

@Entity
@Table(name = ""amt_hits"")
public class AMTHit extends Model {
  @Version
  public int version;

  @Id
  public Long id;

  @Constraints.Required
  @Formats.NonEmpty
  public Date creationDate;

  public String requestId;
  public String isValid;
  public String hitId;
  public String title;
  public String description;
  public String lifetimeInSeconds;
  public String tutorialTime;
  public String maxAssignments;
  public String externalURL;
  public String reward;
  public String disallowPrevious;
  public Boolean sandbox;
  // Was this HIT extended in the case where the workers were unable to submit their assignments?
  private Boolean extended;

  @JsonIgnore
  @ManyToOne
  public ExperimentInstance experimentInstance;

  // TODO: Remove amtWorkers
  @OneToMany(cascade = CascadeType.ALL, mappedBy = ""amtHit"")
  public List<AMTWorker> amtWorkers = new ArrayList<>();

  @OneToMany(cascade = CascadeType.ALL, mappedBy = ""amtHit"")
  public List<AMTAssignment> amtAssignments = new ArrayList<>();

  @JsonIgnore
  public static Model.Finder<Long, AMTHit> find = new Model.Finder(Long.class, AMTHit.class);

  public static List<AMTHit> findAll() {
    return find.all();
  }

  public static AMTHit findById(Long id) {
    return find.where().eq(""id"", id).findUnique();
  }

  public static AMTHit findByHitId(String hitId) {
    return find.where().eq(""hit_id"", hitId).findUnique();
  }

  public AMTHit() {
    this.creationDate = new Date();
    this.extended = false;
  }

  public Boolean isExtended() {
    if (extended == null) {
      return false;
    }
    return extended;
  }

  public Boolean hasWorker(String workerId) {
    for (AMTWorker w : amtWorkers) {
      if (w.workerId.equals(workerId)) {
        return true;
      }
    }
    return false;
  }

  public void setExtended(Boolean extended) {
    this.extended = extended;
  }

  public ObjectNode toJson() {
    ObjectNode amtHit = Json.newObject();

    amtHit.put(""id"", id);
    amtHit.put(""creationTime"", new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss,S"").format(creationDate));
    amtHit.put(""requestId"", requestId);
    amtHit.put(""isValid"", isValid);
    amtHit.put(""hitId"", hitId);
    amtHit.put(""title"", title);
    amtHit.put(""description"", description);
    amtHit.put(""lifetimeInSeconds"", lifetimeInSeconds);
    amtHit.put(""tutorialTime"", tutorialTime);
    amtHit.put(""maxAssignments"", maxAssignments);
    amtHit.put(""externalURL"", externalURL);
    amtHit.put(""reward"", reward);
    amtHit.put(""disallowPrevious"", disallowPrevious);
    amtHit.put(""sandbox"", sandbox);
    amtHit.put(""extended"", extended);

    ArrayNode jsonAssignments = amtHit.putArray(""assignments"");
    for (AMTAssignment a : amtAssignments) {
      jsonAssignments.add(a.toJson());
    }

    return amtHit;
  }

  public AMTAssignment getAMTAssignmentById(String assignmentId) {
    for (AMTAssignment a : amtAssignments) {
      if (a.assignmentId.equals(assignmentId)) {
        return a;
      }
    }
    return null;
  }

  public String toString() {
    return ""AMTHit("" + id + "")"";
  }
}
","package models; @Entity
@Table(name = ""amt_hits"")
public class AMTHit extends Model { @Version
  public int version; @Id
  public Long id; @Constraints.Required
  @Formats.NonEmpty
  public Date creationDate; public String requestId; public String isValid; public String hitId; public String title; public String description; public String lifetimeInSeconds; public String tutorialTime; public String maxAssignments; public String externalURL; public String reward; public String disallowPrevious; public Boolean sandbox; private Boolean extended; @JsonIgnore
  @ManyToOne
  public ExperimentInstance experimentInstance; @OneToMany(cascade = CascadeType.ALL, mappedBy = ""amtHit"")
  public List<AMTWorker> amtWorkers = new ArrayList<>(); @OneToMany(cascade = CascadeType.ALL, mappedBy = ""amtHit"")
  public List<AMTAssignment> amtAssignments = new ArrayList<>(); @JsonIgnore
  public static Model.Finder<Long, AMTHit> find = new Model.Finder(Long.class, AMTHit.class); public static List<AMTHit> findAll() { return find.all(); } public static AMTHit findById(Long id) { return find.where().eq(""id"", id).findUnique(); } public static AMTHit findByHitId(String hitId) { return find.where().eq(""hit_id"", hitId).findUnique(); } public AMTHit() { this.creationDate = new Date(); this.extended = false; } public Boolean isExtended() { if (extended == null) { return false; } return extended; } public Boolean hasWorker(String workerId) { for (AMTWorker w : amtWorkers) { if (w.workerId.equals(workerId)) { return true; } } return false; } public void setExtended(Boolean extended) { this.extended = extended; } public ObjectNode toJson() { ObjectNode amtHit = Json.newObject(); amtHit.put(""id"", id); amtHit.put(""creationTime"", new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss,S"").format(creationDate)); amtHit.put(""requestId"", requestId); amtHit.put(""isValid"", isValid); amtHit.put(""hitId"", hitId); amtHit.put(""title"", title); amtHit.put(""description"", description); amtHit.put(""lifetimeInSeconds"", lifetimeInSeconds); amtHit.put(""tutorialTime"", tutorialTime); amtHit.put(""maxAssignments"", maxAssignments); amtHit.put(""externalURL"", externalURL); amtHit.put(""reward"", reward); amtHit.put(""disallowPrevious"", disallowPrevious); amtHit.put(""sandbox"", sandbox); amtHit.put(""extended"", extended); ArrayNode jsonAssignments = amtHit.putArray(""assignments""); for (AMTAssignment a : amtAssignments) { jsonAssignments.add(a.toJson()); } return amtHit; } public AMTAssignment getAMTAssignmentById(String assignmentId) { for (AMTAssignment a : amtAssignments) { if (a.assignmentId.equals(assignmentId)) { return a; } } return null; } public String toString() { return ""AMTHit("" + id + "")""; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; @Entity
@Table(name = ""amt_hits"")
public class AMTHit extends Model { @Version
  public int version; @Id
  public Long id; @Constraints.Required
  @Formats.NonEmpty
  public Date creationDate; public String requestId; public String isValid; public String hitId; public String title; public String description; public String lifetimeInSeconds; public String tutorialTime; public String maxAssignments; public String externalURL; public String reward; public String disallowPrevious; public Boolean sandbox; private Boolean extended; @JsonIgnore
  @ManyToOne
  public ExperimentInstance experimentInstance; @OneToMany(cascade = CascadeType.ALL, mappedBy = ""amtHit"")
  public List<AMTWorker> amtWorkers = new ArrayList<>(); @OneToMany(cascade = CascadeType.ALL, mappedBy = ""amtHit"")
  public List<AMTAssignment> amtAssignments = new ArrayList<>(); @JsonIgnore
  public static Model.Finder<Long, AMTHit> find = new Model.Finder(Long.class, AMTHit.class); public static List<AMTHit> findAll() { return find.all(); } public static AMTHit findById(Long id) { return find.where().eq(""id"", id).findUnique(); } public static AMTHit findByHitId(String hitId) { return find.where().eq(""hit_id"", hitId).findUnique(); } public AMTHit() { this.creationDate = new Date(); this.extended = false; } public Boolean isExtended() { if (extended == null) { return false; } return extended; } public Boolean hasWorker(String workerId) { for (AMTWorker w : amtWorkers) { if (w.workerId.equals(workerId)) { return true; } } return false; } public void setExtended(Boolean extended) { this.extended = extended; } public ObjectNode toJson() { ObjectNode amtHit = Json.newObject(); amtHit.put(""id"", id); amtHit.put(""creationTime"", new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss,S"").format(creationDate)); amtHit.put(""requestId"", requestId); amtHit.put(""isValid"", isValid); amtHit.put(""hitId"", hitId); amtHit.put(""title"", title); amtHit.put(""description"", description); amtHit.put(""lifetimeInSeconds"", lifetimeInSeconds); amtHit.put(""tutorialTime"", tutorialTime); amtHit.put(""maxAssignments"", maxAssignments); amtHit.put(""externalURL"", externalURL); amtHit.put(""reward"", reward); amtHit.put(""disallowPrevious"", disallowPrevious); amtHit.put(""sandbox"", sandbox); amtHit.put(""extended"", extended); ArrayNode jsonAssignments = amtHit.putArray(""assignments""); for (AMTAssignment a : amtAssignments) { jsonAssignments.add(a.toJson()); } return amtHit; } public AMTAssignment getAMTAssignmentById(String assignmentId) { for (AMTAssignment a : amtAssignments) { if (a.assignmentId.equals(assignmentId)) { return a; } } return null; } public String toString() { return ""AMTHit("" + id + "")""; } } ","package models; 
import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.databind.node.ArrayNode; import com.fasterxml.jackson.databind.node.ObjectNode; import play.data.format.Formats; import play.data.validation.Constraints; import play.db.ebean.Model; import play.libs.Json; 
import javax.persistence.*; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Date; import java.util.List;  @Entity
@Table(name = ""amt_hits"")
public class AMTHit extends Model { @Version
  public int version;  @Id
  public Long id;  @Constraints.Required
  @Formats.NonEmpty
  public Date creationDate;  public String requestId; public String isValid; public String hitId; public String title; public String description; public String lifetimeInSeconds; public String tutorialTime; public String maxAssignments; public String externalURL; public String reward; public String disallowPrevious; public Boolean sandbox; // Was this HIT extended in the case where the workers were unable to submit their assignments? private Boolean extended;  @JsonIgnore
  @ManyToOne
  public ExperimentInstance experimentInstance;  // TODO: Remove amtWorkers @OneToMany(cascade = CascadeType.ALL, mappedBy = ""amtHit"")
  public List<AMTWorker> amtWorkers = new ArrayList<>();  @OneToMany(cascade = CascadeType.ALL, mappedBy = ""amtHit"")
  public List<AMTAssignment> amtAssignments = new ArrayList<>();  @JsonIgnore
  public static Model.Finder<Long, AMTHit> find = new Model.Finder(Long.class, AMTHit.class);  public static List<AMTHit> findAll() { return find.all(); }  public static AMTHit findById(Long id) { return find.where().eq(""id"", id).findUnique(); }  public static AMTHit findByHitId(String hitId) { return find.where().eq(""hit_id"", hitId).findUnique(); }  public AMTHit() { this.creationDate = new Date(); this.extended = false; }  public Boolean isExtended() { if (extended == null) { return false; } return extended; }  public Boolean hasWorker(String workerId) { for (AMTWorker w : amtWorkers) { if (w.workerId.equals(workerId)) { return true; } } return false; }  public void setExtended(Boolean extended) { this.extended = extended; }  public ObjectNode toJson() { ObjectNode amtHit = Json.newObject();  amtHit.put(""id"", id); amtHit.put(""creationTime"", new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss,S"").format(creationDate)); amtHit.put(""requestId"", requestId); amtHit.put(""isValid"", isValid); amtHit.put(""hitId"", hitId); amtHit.put(""title"", title); amtHit.put(""description"", description); amtHit.put(""lifetimeInSeconds"", lifetimeInSeconds); amtHit.put(""tutorialTime"", tutorialTime); amtHit.put(""maxAssignments"", maxAssignments); amtHit.put(""externalURL"", externalURL); amtHit.put(""reward"", reward); amtHit.put(""disallowPrevious"", disallowPrevious); amtHit.put(""sandbox"", sandbox); amtHit.put(""extended"", extended);  ArrayNode jsonAssignments = amtHit.putArray(""assignments""); for (AMTAssignment a : amtAssignments) { jsonAssignments.add(a.toJson()); }  return amtHit; }  public AMTAssignment getAMTAssignmentById(String assignmentId) { for (AMTAssignment a : amtAssignments) { if (a.assignmentId.equals(assignmentId)) { return a; } } return null; }  public String toString() { return ""AMTHit("" + id + "")""; } }  "
app/models/AMTWorker.java,"package models;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.databind.node.ObjectNode;
import play.db.ebean.Model;
import play.libs.Json;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import javax.persistence.Table;
import java.util.List;

@Entity
@Table(name = ""amt_workers"")
public class AMTWorker extends Model {
  @Id
  public Long id;

  public String workerId;
  public String score;
  public String completion;

  @JsonIgnore
  @ManyToOne
  public AMTHit amtHit;

  @JsonIgnore
  public static Model.Finder<Long, AMTWorker> find = new Model.Finder(Long.class, AMTWorker.class);

  public static List<AMTWorker> findAll() {
    return find.all();
  }

  public static AMTWorker findByWorkerId(String workerId) {
    return find.where().eq(""workerId"", workerId).setMaxRows(1).findUnique();
  }

  public static int countByWorkerId(String wid) {
    return find.where().eq(""worker_id"", wid).findRowCount();
  }

  public AMTWorker() {
  }

  public ObjectNode toJson() {
    ObjectNode amtWorker = Json.newObject();

    amtWorker.put(""id"", id);
    amtWorker.put(""workerId"", workerId);
    amtWorker.put(""score"", score);
    amtWorker.put(""completion"", completion);

    return amtWorker;
  }

  public String toString() {
    return ""AMTWorker("" + id + "")"";
  }
}
","package models; @Entity
@Table(name = ""amt_workers"")
public class AMTWorker extends Model { @Id
  public Long id; public String workerId; public String score; public String completion; @JsonIgnore
  @ManyToOne
  public AMTHit amtHit; @JsonIgnore
  public static Model.Finder<Long, AMTWorker> find = new Model.Finder(Long.class, AMTWorker.class); public static List<AMTWorker> findAll() { return find.all(); } public static AMTWorker findByWorkerId(String workerId) { return find.where().eq(""workerId"", workerId).setMaxRows(1).findUnique(); } public static int countByWorkerId(String wid) { return find.where().eq(""worker_id"", wid).findRowCount(); } public AMTWorker() { } public ObjectNode toJson() { ObjectNode amtWorker = Json.newObject(); amtWorker.put(""id"", id); amtWorker.put(""workerId"", workerId); amtWorker.put(""score"", score); amtWorker.put(""completion"", completion); return amtWorker; } public String toString() { return ""AMTWorker("" + id + "")""; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; @Entity
@Table(name = ""amt_workers"")
public class AMTWorker extends Model { @Id
  public Long id; public String workerId; public String score; public String completion; @JsonIgnore
  @ManyToOne
  public AMTHit amtHit; @JsonIgnore
  public static Model.Finder<Long, AMTWorker> find = new Model.Finder(Long.class, AMTWorker.class); public static List<AMTWorker> findAll() { return find.all(); } public static AMTWorker findByWorkerId(String workerId) { return find.where().eq(""workerId"", workerId).setMaxRows(1).findUnique(); } public static int countByWorkerId(String wid) { return find.where().eq(""worker_id"", wid).findRowCount(); } public AMTWorker() { } public ObjectNode toJson() { ObjectNode amtWorker = Json.newObject(); amtWorker.put(""id"", id); amtWorker.put(""workerId"", workerId); amtWorker.put(""score"", score); amtWorker.put(""completion"", completion); return amtWorker; } public String toString() { return ""AMTWorker("" + id + "")""; } } ","package models; 
import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.databind.node.ObjectNode; import play.db.ebean.Model; import play.libs.Json; 
import javax.persistence.Entity; import javax.persistence.Id; import javax.persistence.ManyToOne; import javax.persistence.Table; import java.util.List;  @Entity
@Table(name = ""amt_workers"")
public class AMTWorker extends Model { @Id
  public Long id;  public String workerId; public String score; public String completion;  @JsonIgnore
  @ManyToOne
  public AMTHit amtHit;  @JsonIgnore
  public static Model.Finder<Long, AMTWorker> find = new Model.Finder(Long.class, AMTWorker.class);  public static List<AMTWorker> findAll() { return find.all(); }  public static AMTWorker findByWorkerId(String workerId) { return find.where().eq(""workerId"", workerId).setMaxRows(1).findUnique(); }  public static int countByWorkerId(String wid) { return find.where().eq(""worker_id"", wid).findRowCount(); }  public AMTWorker() { }  public ObjectNode toJson() { ObjectNode amtWorker = Json.newObject();  amtWorker.put(""id"", id); amtWorker.put(""workerId"", workerId); amtWorker.put(""score"", score); amtWorker.put(""completion"", completion);  return amtWorker; }  public String toString() { return ""AMTWorker("" + id + "")""; } }  "
app/models/Admin.java,"package models;

import akka.actor.ActorRef;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.google.gson.Gson;
import com.tinkerpop.blueprints.Direction;
import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Graph;
import com.tinkerpop.blueprints.Vertex;
import controllers.D3Utils;
import play.libs.Json;
import play.Logger;

import java.util.Map;
import groovy.util.ObservableMap;

public class Admin implements ClientListener {
  /*
   * This class represents a logged in administrator
   */
  private User user;
  private ActorRef scriptBoardController;
  private ThrottledWebSocketOut out;
  private static final Gson gson = new Gson();

  public Admin(User user, ActorRef scriptBoardController, ThrottledWebSocketOut out) {
    this.user = user;
    this.scriptBoardController = scriptBoardController;
    this.out = out;
  }

  public void update() {
    this.out.write(this.user.toJson());
  }

  public void graphChanged(Graph wholeGraph) {
    ObjectNode jsonOutput = Json.newObject();

    ObjectNode graph = D3Utils.graphToJsonString(wholeGraph);
    jsonOutput.put(""graph"", graph);

    out.write(jsonOutput);
  }

  public void vertexAdded(Vertex vertex) {
    vertexAdded(vertex, true);
  }

  public void vertexAdded(Vertex vertex, Boolean runOnJoin) {
    user.refresh();

    if (runOnJoin) {
      Breadboard.RunOnJoinStep onJoinStep = new Breadboard.RunOnJoinStep(user, vertex, out);
      scriptBoardController.tell(onJoinStep, null);
    }

    ObjectNode jsonOutput = Json.newObject();

    jsonOutput.put(""action"", ""addNode"");
    jsonOutput.put(""id"", vertex.getId().toString());

    out.write(jsonOutput);

    if (!runOnJoin) {
      for (String key : vertex.getPropertyKeys()) {
        vertexPropertyChanged(vertex, key, null, vertex.getProperty(key));
      }
    }
  }

  public void vertexRemoved(Vertex vertex) {
    vertexRemoved(vertex, true);
  }

  public void vertexRemoved(Vertex vertex, Boolean runOnLeave) {
    user.refresh();

    if (runOnLeave) {
      Breadboard.RunOnLeaveStep onLeaveStep = new Breadboard.RunOnLeaveStep(user, vertex, out);
      scriptBoardController.tell(onLeaveStep, null);
    }

    ObjectNode jsonOutput = Json.newObject();

    jsonOutput.put(""action"", ""removeNode"");
    jsonOutput.put(""id"", vertex.getId().toString());

    out.write(jsonOutput);
  }

  public void vertexPropertyChanged(Vertex vertex, String key, Object oldValue, Object setValue) {
    ObjectNode jsonOutput = Json.newObject();

    if (key.equals(""private"")) {
      if (vertex.getProperty(""private"") instanceof Map) {
        Map newMap = (Map) vertex.getProperty(""private"");

				/*
         * TODO: oldValue and setValue don't seem to be Maps, is there any way to only send the changed private variables?
				Map oldMap = new HashMap();
				if (oldValue instanceof Map) {
					oldMap = (Map) oldValue;
				}
				*/

        // Find the changed Property and write it out
        for (Object k : newMap.keySet()) {
          jsonOutput = Json.newObject();
          jsonOutput.put(""action"", ""nodePropertyChanged"");
          jsonOutput.put(""id"", vertex.getId().toString());
          jsonOutput.put(""key"", k.toString());
          // Using gson here leads to a StackOverflowError due to a circular reference
          //jsonOutput.put(""value"", gson.toJson(newMap.get(k)));
          jsonOutput.put(""value"", Json.toJson(newMap.get(k)));
          out.write(jsonOutput);
        }
      }
    } else {
      jsonOutput.put(""action"", ""nodePropertyChanged"");
      jsonOutput.put(""id"", vertex.getId().toString());
      jsonOutput.put(""key"", key);
      //jsonOutput.put(""value"", gson.toJson(setValue));
      jsonOutput.put(""value"", Json.toJson(setValue));
      out.write(jsonOutput);
    }
  }

  public void vertexPropertyRemoved(Vertex vertex, String key) {
    ObjectNode jsonOutput = Json.newObject();

    jsonOutput.put(""action"", ""nodePropertyRemoved"");
    jsonOutput.put(""id"", vertex.getId().toString());
    jsonOutput.put(""key"", key);

    out.write(jsonOutput);
  }

  public void edgeAdded(Edge edge) {
    ObjectNode jsonOutput = Json.newObject();

    jsonOutput.put(""action"", ""addLink"");
    jsonOutput.put(""id"", edge.getId().toString());
    jsonOutput.put(""source"", edge.getVertex(Direction.OUT).getId().toString());
    jsonOutput.put(""target"", edge.getVertex(Direction.IN).getId().toString());
    jsonOutput.put(""value"", edge.getLabel());

    out.write(jsonOutput);

    // If there are properties on the edge, notify the listener
    for (String key : edge.getPropertyKeys()) {
      edgePropertyChanged(edge, key, edge.getProperty(key));
    }
  }

  public void edgeRemoved(Edge edge) {
    ObjectNode jsonOutput = Json.newObject();

    jsonOutput.put(""action"", ""removeLink"");
    jsonOutput.put(""id"", edge.getId().toString());
    jsonOutput.put(""source"", edge.getVertex(Direction.OUT).getId().toString());
    jsonOutput.put(""target"", edge.getVertex(Direction.IN).getId().toString());

    out.write(jsonOutput);
  }

  public void edgePropertyChanged(Edge edge, String key, Object setValue) {
    if ((key == ""inProps"" || key == ""outProps"") && edge.getProperty(key) instanceof Map) {
      Map props = (Map) edge.getProperty(key);
      for (Object propKey : props.keySet()) {
        ObjectNode jsonOutput = Json.newObject();
        jsonOutput.put(""action"", ""linkPropertyChanged"");
        jsonOutput.put(""id"", edge.getId().toString());
        jsonOutput.put(""key"", propKey.toString());
        jsonOutput.put(""value"", props.get(propKey).toString());
        out.write(jsonOutput);
      }
    } else {
      ObjectNode jsonOutput = Json.newObject();
      jsonOutput.put(""action"", ""linkPropertyChanged"");
      jsonOutput.put(""id"", edge.getId().toString());
      jsonOutput.put(""key"", key);
      jsonOutput.put(""value"", setValue.toString());
      out.write(jsonOutput);
    }
    
  }

  public void edgePropertyRemoved(Edge edge, String key) {
    ObjectNode jsonOutput = Json.newObject();

    jsonOutput.put(""action"", ""linkPropertyRemoved"");
    jsonOutput.put(""id"", edge.getId().toString());
    jsonOutput.put(""key"", key);

    out.write(jsonOutput);
  }

  public void setOut(ThrottledWebSocketOut out) {
    this.out = out;
  }

  public ThrottledWebSocketOut getOut() {
    return this.out;
  }

  public User getUser() {
    return this.user;
  }
}
","package models; public class Admin implements ClientListener { private User user; private ActorRef scriptBoardController; private ThrottledWebSocketOut out; private static final Gson gson = new Gson(); public Admin(User user, ActorRef scriptBoardController, ThrottledWebSocketOut out) { this.user = user; this.scriptBoardController = scriptBoardController; this.out = out; } public void update() { this.out.write(this.user.toJson()); } public void graphChanged(Graph wholeGraph) { ObjectNode jsonOutput = Json.newObject(); ObjectNode graph = D3Utils.graphToJsonString(wholeGraph); jsonOutput.put(""graph"", graph); out.write(jsonOutput); } public void vertexAdded(Vertex vertex) { vertexAdded(vertex, true); } public void vertexAdded(Vertex vertex, Boolean runOnJoin) { user.refresh(); if (runOnJoin) { Breadboard.RunOnJoinStep onJoinStep = new Breadboard.RunOnJoinStep(user, vertex, out); scriptBoardController.tell(onJoinStep, null); } ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""addNode""); jsonOutput.put(""id"", vertex.getId().toString()); out.write(jsonOutput); if (!runOnJoin) { for (String key : vertex.getPropertyKeys()) { vertexPropertyChanged(vertex, key, null, vertex.getProperty(key)); } } } public void vertexRemoved(Vertex vertex) { vertexRemoved(vertex, true); } public void vertexRemoved(Vertex vertex, Boolean runOnLeave) { user.refresh(); if (runOnLeave) { Breadboard.RunOnLeaveStep onLeaveStep = new Breadboard.RunOnLeaveStep(user, vertex, out); scriptBoardController.tell(onLeaveStep, null); } ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""removeNode""); jsonOutput.put(""id"", vertex.getId().toString()); out.write(jsonOutput); } public void vertexPropertyChanged(Vertex vertex, String key, Object oldValue, Object setValue) { ObjectNode jsonOutput = Json.newObject(); if (key.equals(""private"")) { if (vertex.getProperty(""private"") instanceof Map) { Map newMap = (Map) vertex.getProperty(""private""); for (Object k : newMap.keySet()) { jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""nodePropertyChanged""); jsonOutput.put(""id"", vertex.getId().toString()); jsonOutput.put(""key"", k.toString()); jsonOutput.put(""value"", Json.toJson(newMap.get(k))); out.write(jsonOutput); } } } else { jsonOutput.put(""action"", ""nodePropertyChanged""); jsonOutput.put(""id"", vertex.getId().toString()); jsonOutput.put(""key"", key); jsonOutput.put(""value"", Json.toJson(setValue)); out.write(jsonOutput); } } public void vertexPropertyRemoved(Vertex vertex, String key) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""nodePropertyRemoved""); jsonOutput.put(""id"", vertex.getId().toString()); jsonOutput.put(""key"", key); out.write(jsonOutput); } public void edgeAdded(Edge edge) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""addLink""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""source"", edge.getVertex(Direction.OUT).getId().toString()); jsonOutput.put(""target"", edge.getVertex(Direction.IN).getId().toString()); jsonOutput.put(""value"", edge.getLabel()); out.write(jsonOutput); for (String key : edge.getPropertyKeys()) { edgePropertyChanged(edge, key, edge.getProperty(key)); } } public void edgeRemoved(Edge edge) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""removeLink""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""source"", edge.getVertex(Direction.OUT).getId().toString()); jsonOutput.put(""target"", edge.getVertex(Direction.IN).getId().toString()); out.write(jsonOutput); } public void edgePropertyChanged(Edge edge, String key, Object setValue) { if ((key == ""inProps"" || key == ""outProps"") && edge.getProperty(key) instanceof Map) { Map props = (Map) edge.getProperty(key); for (Object propKey : props.keySet()) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""linkPropertyChanged""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""key"", propKey.toString()); jsonOutput.put(""value"", props.get(propKey).toString()); out.write(jsonOutput); } } else { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""linkPropertyChanged""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""key"", key); jsonOutput.put(""value"", setValue.toString()); out.write(jsonOutput); } } public void edgePropertyRemoved(Edge edge, String key) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""linkPropertyRemoved""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""key"", key); out.write(jsonOutput); } public void setOut(ThrottledWebSocketOut out) { this.out = out; } public ThrottledWebSocketOut getOut() { return this.out; } public User getUser() { return this.user; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; public class Admin implements ClientListener { private User user; private ActorRef scriptBoardController; private ThrottledWebSocketOut out; private static final Gson gson = new Gson(); public Admin(User user, ActorRef scriptBoardController, ThrottledWebSocketOut out) { this.user = user; this.scriptBoardController = scriptBoardController; this.out = out; } public void update() { this.out.write(this.user.toJson()); } public void graphChanged(Graph wholeGraph) { ObjectNode jsonOutput = Json.newObject(); ObjectNode graph = D3Utils.graphToJsonString(wholeGraph); jsonOutput.put(""graph"", graph); out.write(jsonOutput); } public void vertexAdded(Vertex vertex) { vertexAdded(vertex, true); } public void vertexAdded(Vertex vertex, Boolean runOnJoin) { user.refresh(); if (runOnJoin) { Breadboard.RunOnJoinStep onJoinStep = new Breadboard.RunOnJoinStep(user, vertex, out); scriptBoardController.tell(onJoinStep, null); } ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""addNode""); jsonOutput.put(""id"", vertex.getId().toString()); out.write(jsonOutput); if (!runOnJoin) { for (String key : vertex.getPropertyKeys()) { vertexPropertyChanged(vertex, key, null, vertex.getProperty(key)); } } } public void vertexRemoved(Vertex vertex) { vertexRemoved(vertex, true); } public void vertexRemoved(Vertex vertex, Boolean runOnLeave) { user.refresh(); if (runOnLeave) { Breadboard.RunOnLeaveStep onLeaveStep = new Breadboard.RunOnLeaveStep(user, vertex, out); scriptBoardController.tell(onLeaveStep, null); } ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""removeNode""); jsonOutput.put(""id"", vertex.getId().toString()); out.write(jsonOutput); } public void vertexPropertyChanged(Vertex vertex, String key, Object oldValue, Object setValue) { ObjectNode jsonOutput = Json.newObject(); if (key.equals(""private"")) { if (vertex.getProperty(""private"") instanceof Map) { Map newMap = (Map) vertex.getProperty(""private""); for (Object k : newMap.keySet()) { jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""nodePropertyChanged""); jsonOutput.put(""id"", vertex.getId().toString()); jsonOutput.put(""key"", k.toString()); jsonOutput.put(""value"", Json.toJson(newMap.get(k))); out.write(jsonOutput); } } } else { jsonOutput.put(""action"", ""nodePropertyChanged""); jsonOutput.put(""id"", vertex.getId().toString()); jsonOutput.put(""key"", key); jsonOutput.put(""value"", Json.toJson(setValue)); out.write(jsonOutput); } } public void vertexPropertyRemoved(Vertex vertex, String key) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""nodePropertyRemoved""); jsonOutput.put(""id"", vertex.getId().toString()); jsonOutput.put(""key"", key); out.write(jsonOutput); } public void edgeAdded(Edge edge) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""addLink""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""source"", edge.getVertex(Direction.OUT).getId().toString()); jsonOutput.put(""target"", edge.getVertex(Direction.IN).getId().toString()); jsonOutput.put(""value"", edge.getLabel()); out.write(jsonOutput); for (String key : edge.getPropertyKeys()) { edgePropertyChanged(edge, key, edge.getProperty(key)); } } public void edgeRemoved(Edge edge) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""removeLink""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""source"", edge.getVertex(Direction.OUT).getId().toString()); jsonOutput.put(""target"", edge.getVertex(Direction.IN).getId().toString()); out.write(jsonOutput); } public void edgePropertyChanged(Edge edge, String key, Object setValue) { if ((key == ""inProps"" || key == ""outProps"") && edge.getProperty(key) instanceof Map) { Map props = (Map) edge.getProperty(key); for (Object propKey : props.keySet()) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""linkPropertyChanged""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""key"", propKey.toString()); jsonOutput.put(""value"", props.get(propKey).toString()); out.write(jsonOutput); } } else { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""linkPropertyChanged""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""key"", key); jsonOutput.put(""value"", setValue.toString()); out.write(jsonOutput); } } public void edgePropertyRemoved(Edge edge, String key) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""linkPropertyRemoved""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""key"", key); out.write(jsonOutput); } public void setOut(ThrottledWebSocketOut out) { this.out = out; } public ThrottledWebSocketOut getOut() { return this.out; } public User getUser() { return this.user; } } ","package models; 
import akka.actor.ActorRef; import com.fasterxml.jackson.databind.node.ObjectNode; import com.google.gson.Gson; import com.tinkerpop.blueprints.Direction; import com.tinkerpop.blueprints.Edge; import com.tinkerpop.blueprints.Graph; import com.tinkerpop.blueprints.Vertex; import controllers.D3Utils; import play.libs.Json; import play.Logger; 
import java.util.Map; import groovy.util.ObservableMap;  public class Admin implements ClientListener { /*
   * This class represents a logged in administrator
   */ private User user; private ActorRef scriptBoardController; private ThrottledWebSocketOut out; private static final Gson gson = new Gson();  public Admin(User user, ActorRef scriptBoardController, ThrottledWebSocketOut out) { this.user = user; this.scriptBoardController = scriptBoardController; this.out = out; }  public void update() { this.out.write(this.user.toJson()); }  public void graphChanged(Graph wholeGraph) { ObjectNode jsonOutput = Json.newObject();  ObjectNode graph = D3Utils.graphToJsonString(wholeGraph); jsonOutput.put(""graph"", graph);  out.write(jsonOutput); }  public void vertexAdded(Vertex vertex) { vertexAdded(vertex, true); }  public void vertexAdded(Vertex vertex, Boolean runOnJoin) { user.refresh();  if (runOnJoin) { Breadboard.RunOnJoinStep onJoinStep = new Breadboard.RunOnJoinStep(user, vertex, out); scriptBoardController.tell(onJoinStep, null); }  ObjectNode jsonOutput = Json.newObject();  jsonOutput.put(""action"", ""addNode""); jsonOutput.put(""id"", vertex.getId().toString());  out.write(jsonOutput);  if (!runOnJoin) { for (String key : vertex.getPropertyKeys()) { vertexPropertyChanged(vertex, key, null, vertex.getProperty(key)); } } }  public void vertexRemoved(Vertex vertex) { vertexRemoved(vertex, true); }  public void vertexRemoved(Vertex vertex, Boolean runOnLeave) { user.refresh();  if (runOnLeave) { Breadboard.RunOnLeaveStep onLeaveStep = new Breadboard.RunOnLeaveStep(user, vertex, out); scriptBoardController.tell(onLeaveStep, null); }  ObjectNode jsonOutput = Json.newObject();  jsonOutput.put(""action"", ""removeNode""); jsonOutput.put(""id"", vertex.getId().toString());  out.write(jsonOutput); }  public void vertexPropertyChanged(Vertex vertex, String key, Object oldValue, Object setValue) { ObjectNode jsonOutput = Json.newObject();  if (key.equals(""private"")) { if (vertex.getProperty(""private"") instanceof Map) { Map newMap = (Map) vertex.getProperty(""private"");  /*
         * TODO: oldValue and setValue don't seem to be Maps, is there any way to only send the changed private variables?
				Map oldMap = new HashMap();
				if (oldValue instanceof Map) {
					oldMap = (Map) oldValue;
				}
				*/  // Find the changed Property and write it out for (Object k : newMap.keySet()) { jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""nodePropertyChanged""); jsonOutput.put(""id"", vertex.getId().toString()); jsonOutput.put(""key"", k.toString()); // Using gson here leads to a StackOverflowError due to a circular reference //jsonOutput.put(""value"", gson.toJson(newMap.get(k))); jsonOutput.put(""value"", Json.toJson(newMap.get(k))); out.write(jsonOutput); } } } else { jsonOutput.put(""action"", ""nodePropertyChanged""); jsonOutput.put(""id"", vertex.getId().toString()); jsonOutput.put(""key"", key); //jsonOutput.put(""value"", gson.toJson(setValue)); jsonOutput.put(""value"", Json.toJson(setValue)); out.write(jsonOutput); } }  public void vertexPropertyRemoved(Vertex vertex, String key) { ObjectNode jsonOutput = Json.newObject();  jsonOutput.put(""action"", ""nodePropertyRemoved""); jsonOutput.put(""id"", vertex.getId().toString()); jsonOutput.put(""key"", key);  out.write(jsonOutput); }  public void edgeAdded(Edge edge) { ObjectNode jsonOutput = Json.newObject();  jsonOutput.put(""action"", ""addLink""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""source"", edge.getVertex(Direction.OUT).getId().toString()); jsonOutput.put(""target"", edge.getVertex(Direction.IN).getId().toString()); jsonOutput.put(""value"", edge.getLabel());  out.write(jsonOutput);  // If there are properties on the edge, notify the listener for (String key : edge.getPropertyKeys()) { edgePropertyChanged(edge, key, edge.getProperty(key)); } }  public void edgeRemoved(Edge edge) { ObjectNode jsonOutput = Json.newObject();  jsonOutput.put(""action"", ""removeLink""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""source"", edge.getVertex(Direction.OUT).getId().toString()); jsonOutput.put(""target"", edge.getVertex(Direction.IN).getId().toString());  out.write(jsonOutput); }  public void edgePropertyChanged(Edge edge, String key, Object setValue) { if ((key == ""inProps"" || key == ""outProps"") && edge.getProperty(key) instanceof Map) { Map props = (Map) edge.getProperty(key); for (Object propKey : props.keySet()) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""linkPropertyChanged""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""key"", propKey.toString()); jsonOutput.put(""value"", props.get(propKey).toString()); out.write(jsonOutput); } } else { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""linkPropertyChanged""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""key"", key); jsonOutput.put(""value"", setValue.toString()); out.write(jsonOutput); }      }  public void edgePropertyRemoved(Edge edge, String key) { ObjectNode jsonOutput = Json.newObject();  jsonOutput.put(""action"", ""linkPropertyRemoved""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""key"", key);  out.write(jsonOutput); }  public void setOut(ThrottledWebSocketOut out) { this.out = out; }  public ThrottledWebSocketOut getOut() { return this.out; }  public User getUser() { return this.user; } }  "
app/models/Breadboard.java,"package models;

import akka.actor.ActorRef;
import akka.actor.Props;
import akka.actor.UntypedActor;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.tinkerpop.blueprints.Vertex;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.text.WordUtils;
import org.imgscalr.Scalr;
import play.Logger;
import play.Play;
import play.libs.*;
import play.libs.F.Callback;
import play.mvc.WebSocket;
import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.*;
import java.text.SimpleDateFormat;
import java.util.*;

public class Breadboard extends UntypedActor {
  // How often to send websocket messages in ms
  public static final long WEBSOCKET_RATE = 100L;

  // One script environment instance per user at this time, map the user's email address to the instance
  static Map<String, ActorRef> instances = new HashMap<String, ActorRef>();

  static ActorRef breadboardController = Akka.system().actorOf(new Props(Breadboard.class));

  static ThrottledWebSocketOut out;

  public static void connect(final WebSocket.In<JsonNode> in, final WebSocket.Out<JsonNode> wsout) {
    out = new ThrottledWebSocketOut(wsout, WEBSOCKET_RATE);
    in.onMessage(new Callback<JsonNode>() {
      public void invoke(JsonNode event) {
        try {
          Logger.debug(event.toString());
          ObjectMapper mapper = new ObjectMapper();
          // TODO: check if there is a better way to do this with new version of Jackson
          Map<String, Object> jsonInput = mapper.readValue(event.toString(), Map.class);
          String action = jsonInput.get(""action"").toString();
          String uid = jsonInput.get(""uid"").toString();
          User user = User.findByUID(uid);
          ObjectNode result = Json.newObject();

          if (user != null) {
            if (action.equals(""LogIn"")) {
              breadboardController.tell(new LogIn(user, out), null);
            } else if (action.equals(""SaveUserSettings"")) {
              String currentPassword = jsonInput.get(""currentPassword"").toString().trim();
              String newPassword = jsonInput.get(""newPassword"").toString().trim();
              String confirmPassword = jsonInput.get(""confirmPassword"").toString().trim();

              breadboardController.tell(new SaveUserSettings(user, currentPassword, newPassword, confirmPassword, out), null);

            } else if (action.equals(""SelectExperiment"")) {
              Long experimentId = Long.parseLong(jsonInput.get(""experimentId"").toString());
              Experiment experiment = Experiment.findById(experimentId);

              if (experiment != null)
                breadboardController.tell(new SelectExperiment(user, experiment, out), null);
            } else if (action.equals(""CreateExperiment"")) {
              String name = jsonInput.get(""name"").toString();
              String copyExperimentName = jsonInput.containsKey(""copyExperimentName"") ? jsonInput.get(""copyExperimentName"").toString() : null;
              breadboardController.tell(new CreateExperiment(user, name, copyExperimentName, out), null);
              Logger.debug(""CreateExperiment"");
            } else if (action.equals(""ImportExperiment"")) {
              String importFrom = jsonInput.get(""importFrom"").toString();
              String importTo = jsonInput.get(""importTo"").toString();
              breadboardController.tell(new ImportExperiment(user, importFrom, importTo, out), null);
              Logger.debug(""ImportExperiment"");
            } else if (action.equals(""DeleteExperiment"")) {
              String selectedExperimentName = jsonInput.get(""selectedExperiment"").toString();
              instances.get(user.email).tell(new DeleteExperiment(user, selectedExperimentName, out), null);
            } else if (action.equals(""ExportExperiment"")) {
              String selectedExperimentName = jsonInput.get(""selectedExperiment"").toString();
              Experiment experiment = user.getExperimentByName(selectedExperimentName);
              if (experiment != null) {
                ObjectNode jsonOutput = Json.newObject();
                try {
                  experiment.export();
                  jsonOutput.put(""output"", ""Experiment exported."");
                } catch (IOException ioe) {
                  jsonOutput.put(""output"", ""Export failed."");
                  Logger.error(ioe.getMessage());
                }
                out.write(jsonOutput);
              }
            } else if (action.equals(""SubmitAMTTask"")) {
              Logger.debug(""action.equals(\""SubmitAMTTask\"")"");
              // The submission to AMT is handled by the AMTAdmin createHIT route
              // This action handles setting the startAt global variable
              // and setting the timer to start initStep
              try {
                Integer lifetimeInSeconds = new Integer(jsonInput.get(""lifetimeInSeconds"").toString());
                Integer tutorialTime = new Integer(jsonInput.get(""tutorialTime"").toString());

                breadboardController.tell(new SubmitAMTTask(user, lifetimeInSeconds, tutorialTime,  out), null);
              } catch (NumberFormatException nfe) {
                Logger.error(""Invalid number provided for lifetimeInSeconds, or tutorialTime parameter."");
              } catch (Exception e) {
                Logger.debug(""Some other exception: "" + e.getMessage());
                e.printStackTrace();
              }
            } else if (action.equals(""RunGame"")) {
              if (instances.containsKey(user.email)) {
                instances.get(user.email).tell(new RunGame(user, out), null);
              }
            } else if (action.equals(""SendScript"")) {
              if (instances.containsKey(user.email)) {
                String script = jsonInput.get(""script"").toString();
                instances.get(user.email).tell(new SendScript(user, script, out), null);
              }
            } else if (action.equals(""AddLanguage"")) {
              Long experimentId = Long.parseLong(jsonInput.get(""experimentId"").toString());
              String languageCode = jsonInput.get(""code"").toString();
              breadboardController.tell(new AddLanguage(user, experimentId, languageCode, out), null);
            } else if (action.equals(""MakeChoice"")) {
              // TODO: Player client will not be logged in with email and will
              // need a different way to identify the correct game
              if (instances.containsKey(user.email)) {
                String choiceUID = jsonInput.get(""choiceUID"").toString();
                String params = (jsonInput.containsKey(""params"")) ? jsonInput.get(""params"").toString() : null;
                instances.get(user.email).tell(new MakeChoice(user, choiceUID, params, out), null);
              }
            } else if (action.equals(""SaveStyle"")) {
              String style = jsonInput.get(""style"").toString();
              breadboardController.tell(new SaveStyle(user, style, out), null);
            } else if (action.equals(""SaveClientHtml"")) {
              String clientHtml = jsonInput.get(""clientHtml"").toString();
              breadboardController.tell(new SaveClientHtml(user, clientHtml, out), null);
            } else if (action.equals(""SaveClientGraph"")) {
              String clientGraph = jsonInput.get(""clientGraph"").toString();
              breadboardController.tell(new SaveClientGraph(user, clientGraph, out), null);
            } else if (action.equals(""CreateStep"")) {
              String name = jsonInput.get(""name"").toString();
              breadboardController.tell(new CreateStep(user, name, out), null);
            } else if (action.equals(""DeleteStep"")) {
              Long id = Long.valueOf(jsonInput.get(""id"").toString());
              breadboardController.tell(new DeleteStep(user, id, out), null);
            } else if (action.equals(""SendStep"")) {
              if (instances.containsKey(user.email)) {
                try {
                  Long id = Long.parseLong(jsonInput.get(""id"").toString());
                  String name = jsonInput.get(""name"").toString();
                  String source = jsonInput.get(""source"").toString();
                  // TODO: is providing the name necessary?
                  instances.get(user.email).tell(new SendStep(user, id, name, source, out), null);
                } catch (NumberFormatException nfe) {
                  Logger.debug(""Long.parseLong threw NumberFormatException, input: "" + jsonInput.get(""id"").toString());
                }
              }
            } else if (action.equals(""LaunchGame"")) {
              if (instances.containsKey(user.email)) {
                String name = jsonInput.get(""name"").toString();
                Object parameters = jsonInput.get(""parameters"");
                Logger.debug(""parameters.getClass().toString() = "" + parameters.getClass().toString());
                if (parameters instanceof LinkedHashMap) {
                  LinkedHashMap params = (LinkedHashMap) parameters;
                  instances.get(user.email).tell(new LaunchGame(user, name, params, out), null);
                }
              }
            } else if (action.equals(""StopGame"")) {
              if (instances.containsKey(user.email)) {
                try {
                  Long id = Long.parseLong(jsonInput.get(""id"").toString());
                  instances.get(user.email).tell(new StopGame(user, id, out), null);
                } catch (NumberFormatException nfe) {
                  Logger.debug(""Error parsing Long from String: "" + jsonInput.get(""id"").toString());
                }
              }
            } else if (action.equals(""NewParameter"")) {
              String name = jsonInput.get(""name"").toString();
              String type = jsonInput.get(""type"").toString();
              String minVal = (jsonInput.get(""minVal"") == null) ? """" : jsonInput.get(""minVal"").toString();
              String maxVal = (jsonInput.get(""maxVal"") == null) ? """" : jsonInput.get(""maxVal"").toString();
              String defaultVal = jsonInput.get(""defaultVal"").toString();
              String description = jsonInput.get(""description"").toString();

              breadboardController.tell(new NewParameter(user, name, type, minVal, maxVal, defaultVal, description, out), null);
            } else if (action.equals(""RemoveParameter"")) {
              String id = jsonInput.get(""id"").toString();

              breadboardController.tell(new RemoveParameter(user, id, out), null);
            } else if (action.equals(""SelectInstance"")) {
              Long id = Long.parseLong(jsonInput.get(""id"").toString());

              breadboardController.tell(new SelectInstance(user, id, out), null);
            } else if (action.equals(""Update"")) {
              breadboardController.tell(new Update(user, out), null);
            } else if (action.equals(""ShowEvent"")) {
              Long experimentInstanceId = Long.parseLong(jsonInput.get(""id"").toString());
              breadboardController.tell(new ShowEvent(user, experimentInstanceId, out), null);
            } else if (action.equals(""DeleteInstance"")) {
              Long experimentInstanceId = Long.parseLong(jsonInput.get(""id"").toString());
              breadboardController.tell(new DeleteInstance(user, experimentInstanceId, out), null);
            } else if (action.equals(""ReloadEngine"")) {
              instances.get(user.email).tell(new ReloadEngine(user, out), null);
            } else if (action.equals(""DeleteImage"")) {
              Long imageId = Long.parseLong(jsonInput.get(""imageId"").toString());
              breadboardController.tell(new DeleteImage(user, imageId, out), null);
            } else if (action.equals(""ToggleFileMode"")) {
              breadboardController.tell(new ToggleFileMode(user, out), null);
            }
          } else { // END if (user != null)
            Logger.error(""user not found with UID: "" + user.uid);
          }
        } catch (java.io.IOException ioe) {
          Logger.error(ioe.getMessage());
        }
      }
    });
  }

  public void onReceive(Object message) throws Exception {
    if (message instanceof BreadboardMessage) {
      BreadboardMessage breadboardMessage = (BreadboardMessage) message;
      Logger.debug(""breadboardMessage.getClass().getName() = "" + breadboardMessage.getClass().getName());

      if (message instanceof LogIn) {
        if (!instances.containsKey(breadboardMessage.user.email)) {
          Logger.debug(""! instances.containsKey(breadboardMessage.user.email)"");
          // No running instance, start one
          // TODO: Allow multiple instances per user?
          // TODO: Allow starting and stopping of individual instances
          ActorRef scriptBoardController = Akka.system().actorOf(new Props(ScriptBoard.class));
          Logger.debug(""scriptBoardController = "" + scriptBoardController);
                    /*  Another way to declare the scriptBoardController if we need a non-default constructor
                    ActorRef scriptBoardController = Akka.system().actorOf(new Props(new UntypedActorFactory() {
                        public UntypedActor create() {
                            return new ScriptBoard();
                        }
                    }), ""scriptBoardController"");
                    */
          Logger.debug(""breadboardMessage.user.email PUT: "" + breadboardMessage.user.email);
          instances.put(breadboardMessage.user.email, scriptBoardController);

          // Add an Admin to the scriptBoardController
          scriptBoardController.tell(new AddAdmin(breadboardMessage.user, scriptBoardController, breadboardMessage.out), null);

          // If the User has a selected experiment, select the experiment
          if (breadboardMessage.user.selectedExperiment != null) {
            Logger.debug(""breadboardMessage.user.selectedExperiment = "" + breadboardMessage.user.selectedExperiment);
            breadboardController.tell(new SelectExperiment(breadboardMessage.user, breadboardMessage.user.selectedExperiment, breadboardMessage.out), null);
          }
          if (breadboardMessage.user.experimentInstanceId != -1) {
            breadboardController.tell(new SelectInstance(breadboardMessage.user, breadboardMessage.user.experimentInstanceId, breadboardMessage.out), null);
          }
        } else {
          //this is reconnect/refresh
          Logger.debug(""Reconnecting..."");
          ObjectNode userJson = breadboardMessage.user.toJson();
          //Logger.debug(""breadboardMessage.out.write(breadboardMessage.user.toJson()); "" + userJson);
          breadboardMessage.out.write(userJson);

          Logger.debug(""breadboardMessage.user.email GET: "" + breadboardMessage.user.email);
          instances.get(breadboardMessage.user.email).tell(new Refresh(breadboardMessage.user, breadboardMessage.out), null);
          return;
        }
        Logger.debug(""LogIn: "" + breadboardMessage.user.email);
      } else if (message instanceof SaveUserSettings) {
        SaveUserSettings saveUserSettings = (SaveUserSettings) message;

        //TODO: better validation like regex?
        List<String> errors = new ArrayList<String>();
        if (StringUtils.isEmpty(saveUserSettings.currentPassword)) {
          errors.add(""'Current Password' is required"");
        }
        if (!saveUserSettings.currentPassword.equals(saveUserSettings.user.password)) {
          errors.add(""'Current Password' doesn't match the current password"");
        }
        if (StringUtils.isEmpty(saveUserSettings.newPassword)) {
          errors.add(""'New Password' is required"");
        }
        if (!saveUserSettings.confirmPassword.equals(saveUserSettings.newPassword)) {
          errors.add(""'Confirm Password' doesn't match the new password"");
        }

        saveUserSettings.user.password = saveUserSettings.newPassword;
        saveUserSettings.user.update();

      } else if (message instanceof SelectExperiment) {
        // TODO: Clear the working memory of the ScriptEngine
        SelectExperiment selectExperiment = (SelectExperiment) message;
        Logger.debug(""SelectExperiment: "" + selectExperiment.experiment.toString());

        breadboardMessage.user.setSelectedExperiment(selectExperiment.experiment);
        breadboardMessage.user.update();

        // If there are steps associated with this experiment, load them
        Experiment selectedExperiment = breadboardMessage.user.getExperiment();
        if (selectedExperiment != null) {
          // TODO: Create ""ChangeExperiment"" action and handle it in ScriptBoard
          // Find Content based on currently selected Experiment
          instances.get(breadboardMessage.user.email).tell(new ChangeExperiment(breadboardMessage.user, selectedExperiment, breadboardMessage.out), null);
          //move the load steps into scriptboard
//                    for (Step step : selectedExperiment.steps)
//                        instances.get(breadboardMessage.user.email).tell(new RunStep(breadboardMessage.user, step.source, breadboardMessage.out));
        }
      } else if (message instanceof CreateExperiment) {
        Logger.error(""Create experiment incorrectly sent via socket"");
      } else if (message instanceof ImportExperiment) {
        Logger.error(""Import experiment incorrectly sent via socket"");
      } else if (message instanceof SubmitAMTTask) {
        SubmitAMTTask submitAMTTask = (SubmitAMTTask) message;
        Integer lifetimeInSeconds = submitAMTTask.lifetimeInSeconds;
        Integer tutorialTime = submitAMTTask.tutorialTime;

        instances.get(breadboardMessage.user.email).tell(new HitCreated(breadboardMessage.user, lifetimeInSeconds, tutorialTime, breadboardMessage.out), null);

        // Send 'initStep will automatically start' message to Output
        ObjectNode jsonOutput = Json.newObject();
        Double totalSeconds = (double)(lifetimeInSeconds + tutorialTime);
        Double minutes = Math.floor(totalSeconds / 60);
        Double seconds = totalSeconds - (minutes * 60);
        jsonOutput.put(""output"", ""AMT HIT created, initStep will automatically start in "" + minutes.toString() + "" minutes and "" + seconds.toString() + "" seconds."");
        breadboardMessage.out.write(jsonOutput);

      } else if (message instanceof AddLanguage) {
        AddLanguage addLanguage = (AddLanguage) message;
        Language language = Language.find.where().eq(""code"", addLanguage.languageCode).findUnique();
        if (language == null) {
          // New language, create it
          language = new Language();
          language.code = addLanguage.languageCode;
          language.name = new Locale(addLanguage.languageCode).getDisplayLanguage();
        }
        // Add the language to the currently selected Experiment, if it doesn't already exist
        Experiment selectedExperiment = Experiment.findById(addLanguage.experimentId);
        boolean hasLanguage = false;
        for (Language l : selectedExperiment.languages) {
          if (l.id.equals(language.id)) {
            hasLanguage = true;
          }
        }
        if (!hasLanguage) {
          selectedExperiment.languages.add(language);
          selectedExperiment.save();
        }
        instances.get(breadboardMessage.user.email).tell(message, null);
      } else if (message instanceof CreateStep) {
        CreateStep createStep = (CreateStep) message;
        Logger.debug(""CreateStep: "" + createStep.name);
        Experiment selectedExperiment = breadboardMessage.user.getExperiment();
        if (selectedExperiment != null) {
          Step newStep = new Step();
          newStep.name = createStep.name;
          String nameVariableName = WordUtils.uncapitalize(newStep.name.replaceAll(""[^a-zA-Z0-9\\s]"", """"));
          newStep.source = nameVariableName + "" = stepFactory.createStep()\n\n"" +
              nameVariableName + "".run = {\n"" +
              ""\tprintln \"""" + nameVariableName + "".run\""\n"" +
              ""}\n\n"" +
              nameVariableName + "".done = {\n"" +
              ""\tprintln \"""" + nameVariableName + "".done\""\n"" +
              ""}\n"";

          selectedExperiment.addStep(newStep);
          selectedExperiment.save();
        }
      } else if (message instanceof DeleteStep) {
        DeleteStep deleteStep = (DeleteStep) message;
        Step step = Step.find.byId(deleteStep.id);
        step.delete();
      } else if (message instanceof SaveStyle) {
        SaveStyle saveStyle = (SaveStyle) message;
        Experiment selectedExperiment = breadboardMessage.user.getExperiment();
        if (selectedExperiment != null) {
          Logger.debug(""SaveStyle: "" + saveStyle.style);
          selectedExperiment.setStyle(saveStyle.style);
          selectedExperiment.update();
          // Send ""Style saved"" message to output
          ObjectNode jsonOutput = Json.newObject();
          jsonOutput.put(""output"", ""Style saved."");
          breadboardMessage.out.write(jsonOutput);
        }
      } else if (message instanceof SaveClientHtml) {
        SaveClientHtml saveClientHtml = (SaveClientHtml) message;
        Experiment selectedExperiment = breadboardMessage.user.getExperiment();
        if (selectedExperiment != null) {
          Logger.debug(""SaveClientHtml: "" + saveClientHtml.clientHtml);
          selectedExperiment.setClientHtml(saveClientHtml.clientHtml);
          selectedExperiment.update();
          ObjectNode jsonOutput = Json.newObject();
          jsonOutput.put(""output"", ""Client HTML saved."");
          breadboardMessage.out.write(jsonOutput);
          // TODO: Consider pushing update to all clients here, to prevent need for browser refresh.
        }
      } else if (message instanceof SaveClientGraph) {
        SaveClientGraph saveClientGraph = (SaveClientGraph) message;
        Experiment selectedExperiment = breadboardMessage.user.getExperiment();
        if (selectedExperiment != null) {
          Logger.debug(""SaveClientGraph: "" + saveClientGraph.clientGraph);
          selectedExperiment.setClientGraph(saveClientGraph.clientGraph);
          selectedExperiment.update();
          ObjectNode jsonOutput = Json.newObject();
          jsonOutput.put(""output"", ""Client Graph saved."");
          breadboardMessage.out.write(jsonOutput);
          // TODO: Consider pushing update to all clients here, to prevent need for browser refresh.
        }
      } else if (message instanceof NewParameter) {
        NewParameter newParameter = (NewParameter) message;

        Experiment selectedExperiment = breadboardMessage.user.getExperiment();

        if (selectedExperiment != null) {
          Parameter parameter = new Parameter();
          parameter.name = newParameter.name;
          parameter.type = newParameter.type;
          parameter.minVal = (parameter.type.equals(""Text"") || parameter.type.equals(""Boolean"")) ? """" : newParameter.minVal;
          parameter.maxVal = (parameter.type.equals(""Text"") || parameter.type.equals(""Boolean"")) ? """" : newParameter.maxVal;
          parameter.defaultVal = newParameter.defaultVal;
          parameter.description = newParameter.description;

          selectedExperiment.parameters.add(parameter);
          selectedExperiment.save();
        }
      } else if (message instanceof RemoveParameter) {
        RemoveParameter removeParameter = (RemoveParameter) message;

        Experiment selectedExperiment = breadboardMessage.user.getExperiment();

        if (selectedExperiment != null) {
          Parameter parameter = Parameter.find.byId(removeParameter.id);
          if (parameter != null) {
            selectedExperiment.parameters.remove(parameter);
            selectedExperiment.update();
            parameter.delete();
          }
        }
      } else if (message instanceof SelectInstance) {
        instances.get(breadboardMessage.user.email).tell(message, null);
      } else if (message instanceof Update) {
        //Do nothing, just update the user JSON object
      } else if (message instanceof ShowEvent) {
        ShowEvent showEvent = (ShowEvent) message;
        Long experimentInstanceId = showEvent.experimentInstanceId;
        ExperimentInstance experimentInstance = ExperimentInstance.findById(experimentInstanceId);
        List<Event> events = experimentInstance.events;
        Collections.sort(events, new Comparator<Event>() {
          @Override
          public int compare(Event o1, Event o2) {
            return o1.datetime.compareTo(o2.datetime);
          }
        });

        ObjectNode eventNode = Json.newObject();
        eventNode.put(""eventExperimentInstance"", experimentInstance.name);
        ArrayNode arrayNode = eventNode.putArray(""events"");

        for (Event event : events) {
          List<EventData> eventDatas = event.eventData;
          ObjectNode objectNode = Json.newObject();
          objectNode.put(""id"", event.id);
          objectNode.put(""name"", event.name);
          objectNode.put(""datetime"", new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss,S"").format(event.datetime));
          ArrayNode dataNodes = objectNode.putArray(""data"");
          for (EventData eventData : eventDatas) {
            ObjectNode dataNode = Json.newObject();
            dataNode.put(""id"", eventData.id);
            dataNode.put(""name"", eventData.name);
            dataNode.put(""value"", eventData.value);
            dataNodes.add(dataNode);
          }
          arrayNode.add(objectNode);
        }
        Logger.debug(""breadboardMessage.out.write(eventNode); "" + eventNode);
        breadboardMessage.out.write(eventNode);
        return;
      } else if (message instanceof DeleteInstance) {
        DeleteInstance deleteInstance = (DeleteInstance) message;
        Long experimentInstanceId = deleteInstance.experimentInstanceId;
        ExperimentInstance experimentInstance = ExperimentInstance.findById(experimentInstanceId);
        //only finished and stopped instance can be deleted
        if (experimentInstance.status == ExperimentInstance.Status.FINISHED || experimentInstance.status == ExperimentInstance.Status.STOPPED) {
          experimentInstance.delete();
        }
      } else if (message instanceof DeleteImage) {
        DeleteImage deleteImage = (DeleteImage) message;
        Long imageId = deleteImage.imageId;
        Image.findById(imageId).delete();
      } else if (message instanceof ToggleFileMode) {
        Experiment selectedExperiment = breadboardMessage.user.getExperiment();
        if (selectedExperiment != null) {
          selectedExperiment.toggleFileMode(breadboardMessage.user);
        }
      }

      breadboardMessage.out.write(breadboardMessage.user.toJson());

    } // END if(message instanceof BreadboardMessage)
  }

  public static abstract class BreadboardMessage {
    final User user;
    final ThrottledWebSocketOut out;

    public BreadboardMessage(User user, ThrottledWebSocketOut out) {
      this.user = user;
      this.out = out;
    }
  }

  public static class LogIn extends BreadboardMessage {
    public LogIn(User user, ThrottledWebSocketOut out) {
      super(user, out);
    }
  }

  public static class Refresh extends BreadboardMessage {
    public Refresh(User user, ThrottledWebSocketOut out) {
      super(user, out);
    }
  }

  public static class Update extends BreadboardMessage {
    public Update(User user, ThrottledWebSocketOut out) {
      super(user, out);
    }
  }

  public static class SaveUserSettings extends BreadboardMessage {

    final String currentPassword;
    final String newPassword;
    final String confirmPassword;

    public SaveUserSettings(User user, String currentPassword, String newPassword, String confirmPassword, ThrottledWebSocketOut out) {
      super(user, out);
      this.currentPassword = currentPassword;
      this.newPassword = newPassword;
      this.confirmPassword = confirmPassword;
    }
  }

  public static class SelectExperiment extends BreadboardMessage {
    final Experiment experiment;

    public SelectExperiment(User user, Experiment experiment, ThrottledWebSocketOut out) {
      super(user, out);
      this.experiment = experiment;
    }
  }

  public static class DeleteExperiment extends BreadboardMessage {
    final String experimentName;

    public DeleteExperiment(User user, String experimentName, ThrottledWebSocketOut out) {
      super(user, out);
      this.experimentName = experimentName;
    }
  }

  public static class ExportExperiment extends BreadboardMessage {
    final String experimentName;

    public ExportExperiment(User user, String experimentName, ThrottledWebSocketOut out) {
      super(user, out);
      this.experimentName = experimentName;
    }
  }

  public static class ChangeExperiment extends BreadboardMessage {
    final Experiment experiment;

    public ChangeExperiment(User user, Experiment experiment, ThrottledWebSocketOut out) {
      super(user, out);
      this.experiment = experiment;
    }
  }

  public static class CreateExperiment extends BreadboardMessage {
    final String name;
    final String copyExperimentName;

    public CreateExperiment(User user, String name, String copyExperimentName, ThrottledWebSocketOut out) {
      super(user, out);
      this.name = name;
      this.copyExperimentName = copyExperimentName;
    }
  }

  public static class ImportExperiment extends BreadboardMessage {
    final String importFrom;
    final String importTo;

    public ImportExperiment(User user, String importFrom, String importTo, ThrottledWebSocketOut out) {
      super(user, out);
      this.importFrom = importFrom;
      this.importTo = importTo;
    }
  }

  public static class SubmitAMTTask extends BreadboardMessage {
    final Integer lifetimeInSeconds;
    final Integer tutorialTime;

    public SubmitAMTTask(User user, Integer lifetimeInSeconds, Integer tutorialTime, ThrottledWebSocketOut out) {
      super(user, out);
      this.lifetimeInSeconds = lifetimeInSeconds;
      this.tutorialTime = tutorialTime;
    }
  }

  public static class HitCreated extends BreadboardMessage {
    final Integer lifetimeInSeconds;
    final Integer tutorialTime;

    public HitCreated(User user, Integer lifetimeInSeconds, Integer tutorialTime, ThrottledWebSocketOut out) {
      super(user, out);
      this.lifetimeInSeconds = lifetimeInSeconds;
      this.tutorialTime = tutorialTime;
    }
  }

  public static class AddLanguage extends BreadboardMessage {
    final Long experimentId;
    final String languageCode;

    public AddLanguage(User user, Long experimentId, String languageCode, ThrottledWebSocketOut out) {
      super(user, out);
      this.experimentId = experimentId;
      this.languageCode = languageCode;
    }
  }

  public static class CreateStep extends BreadboardMessage {
    final String name;

    public CreateStep(User user, String name, ThrottledWebSocketOut out) {
      super(user, out);
      this.name = name;
    }
  }

  public static class DeleteStep extends BreadboardMessage {
    final Long id;

    public DeleteStep(User user, Long id, ThrottledWebSocketOut out) {
      super(user, out);
      this.id = id;
    }
  }

  public static class SaveStyle extends BreadboardMessage {
    final String style;

    public SaveStyle(User user, String style, ThrottledWebSocketOut out) {
      super(user, out);
      this.style = style;
    }
  }

  public static class SaveClientHtml extends BreadboardMessage {
    final String clientHtml;

    public SaveClientHtml(User user, String clientHtml, ThrottledWebSocketOut out) {
      super(user, out);
      this.clientHtml = clientHtml;
    }
  }

  public static class SaveClientGraph extends BreadboardMessage {
    final String clientGraph;

    public SaveClientGraph(User user, String clientGraph, ThrottledWebSocketOut out) {
      super(user, out);
      this.clientGraph = clientGraph;
    }
  }

  public static class RunGame extends BreadboardMessage {
    public RunGame(User user, ThrottledWebSocketOut out) {
      super(user, out);
    }
  }

  public static class SendScript extends BreadboardMessage {
    final String script;

    public SendScript(User user, String script, ThrottledWebSocketOut out) {
      super(user, out);
      this.script = script;
    }
  }

  public static class SendStep extends BreadboardMessage {
    final Long id;
    final String name;
    final String source;

    public SendStep(User user, Long id, String name, String source, ThrottledWebSocketOut out) {
      super(user, out);
      this.id = id;
      this.name = name;
      this.source = source;
    }
  }

  public static class RunStep extends BreadboardMessage {
    final String source;

    public RunStep(User user, String source, ThrottledWebSocketOut out) {
      super(user, out);
      this.source = source;
    }
  }

  public static class MakeChoice extends BreadboardMessage {
    final String uid;
    final String params;

    public MakeChoice(User user, String uid, String params, ThrottledWebSocketOut out) {
      super(user, out);
      this.uid = uid;
      this.params = params;
    }
  }

  public static class LaunchGame extends BreadboardMessage {
    final String name;
    final LinkedHashMap parameters;

    public LaunchGame(User user, String name, LinkedHashMap parameters, ThrottledWebSocketOut out) {
      super(user, out);
      this.name = name;
      this.parameters = parameters;
    }
  }

  public static class StopGame extends BreadboardMessage {
    final Long id;

    public StopGame(User user, Long id, ThrottledWebSocketOut out) {
      super(user, out);
      this.id = id;
    }
  }

  public static class NewParameter extends BreadboardMessage {
    final String name;
    final String type;
    final String minVal;
    final String maxVal;
    final String defaultVal;
    final String description;

    public NewParameter(User user, String name, String type, String minVal, String maxVal, String defaultVal, String description, ThrottledWebSocketOut out) {
      super(user, out);
      this.name = name;
      this.type = type;
      this.minVal = minVal;
      this.maxVal = maxVal;
      this.defaultVal = defaultVal;
      this.description = description;
    }
  }

  public static class RemoveParameter extends BreadboardMessage {
    final String id;

    public RemoveParameter(User user, String id, ThrottledWebSocketOut out) {
      super(user, out);
      this.id = id;
    }
  }

  public static class SelectInstance extends BreadboardMessage {
    final Long id;

    public SelectInstance(User user, Long id, ThrottledWebSocketOut out) {
      super(user, out);
      this.id = id;
    }
  }

  public static class AddAdmin extends BreadboardMessage {
    final ActorRef scriptBoardController;

    public AddAdmin(User user, ActorRef scriptBoardController, ThrottledWebSocketOut out) {
      super(user, out);
      this.scriptBoardController = scriptBoardController;
    }
  }

  public static class RunOnJoinStep extends BreadboardMessage {
    final Vertex vertex;

    public RunOnJoinStep(User user, Vertex vertex, ThrottledWebSocketOut out) {
      super(user, out);
      this.vertex = vertex;
    }
  }

  public static class RunOnLeaveStep extends BreadboardMessage {
    final Vertex vertex;

    public RunOnLeaveStep(User user, Vertex vertex, ThrottledWebSocketOut out) {
      super(user, out);
      this.vertex = vertex;
    }
  }

  public static class ShowEvent extends BreadboardMessage {
    final Long experimentInstanceId;

    public ShowEvent(User user, Long experimentInstanceId, ThrottledWebSocketOut out) {
      super(user, out);
      this.experimentInstanceId = experimentInstanceId;
    }
  }

  public static class GameFinish extends BreadboardMessage {
    public GameFinish(User user, ThrottledWebSocketOut out) {
      super(user, out);
    }
  }

  public static class DeleteInstance extends BreadboardMessage {

    final Long experimentInstanceId;

    public DeleteInstance(User user, Long experimentInstanceId, ThrottledWebSocketOut out) {
      super(user, out);
      this.experimentInstanceId = experimentInstanceId;
    }
  }

  public static class ReloadEngine extends BreadboardMessage {
    public ReloadEngine(User user, ThrottledWebSocketOut out) {
      super(user, out);
    }
  }

  public static class ToggleFileMode extends BreadboardMessage {
    public ToggleFileMode(User user, ThrottledWebSocketOut out) {
      super(user, out);
    }
  }

  public static class DeleteImage extends BreadboardMessage {
    final Long imageId;

    public DeleteImage(User user, Long imageId, ThrottledWebSocketOut out) {
      super(user, out);
      this.imageId = imageId;
    }
  }

}
","package models; public class Breadboard extends UntypedActor { public static final long WEBSOCKET_RATE = 100L; static Map<String, ActorRef> instances = new HashMap<String, ActorRef>(); static ActorRef breadboardController = Akka.system().actorOf(new Props(Breadboard.class)); static ThrottledWebSocketOut out; public static void connect(final WebSocket.In<JsonNode> in, final WebSocket.Out<JsonNode> wsout) { out = new ThrottledWebSocketOut(wsout, WEBSOCKET_RATE); in.onMessage(new Callback<JsonNode>() { public void invoke(JsonNode event) { try { ObjectMapper mapper = new ObjectMapper(); Map<String, Object> jsonInput = mapper.readValue(event.toString(), Map.class); String action = jsonInput.get(""action"").toString(); String uid = jsonInput.get(""uid"").toString(); User user = User.findByUID(uid); ObjectNode result = Json.newObject(); if (user != null) { if (action.equals(""LogIn"")) { breadboardController.tell(new LogIn(user, out), null); } else if (action.equals(""SaveUserSettings"")) { String currentPassword = jsonInput.get(""currentPassword"").toString().trim(); String newPassword = jsonInput.get(""newPassword"").toString().trim(); String confirmPassword = jsonInput.get(""confirmPassword"").toString().trim(); breadboardController.tell(new SaveUserSettings(user, currentPassword, newPassword, confirmPassword, out), null); } else if (action.equals(""SelectExperiment"")) { Long experimentId = Long.parseLong(jsonInput.get(""experimentId"").toString()); Experiment experiment = Experiment.findById(experimentId); if (experiment != null)
                breadboardController.tell(new SelectExperiment(user, experiment, out), null); } else if (action.equals(""CreateExperiment"")) { String name = jsonInput.get(""name"").toString(); String copyExperimentName = jsonInput.containsKey(""copyExperimentName"") ? jsonInput.get(""copyExperimentName"").toString() : null; breadboardController.tell(new CreateExperiment(user, name, copyExperimentName, out), null); } else if (action.equals(""ImportExperiment"")) { String importFrom = jsonInput.get(""importFrom"").toString(); String importTo = jsonInput.get(""importTo"").toString(); breadboardController.tell(new ImportExperiment(user, importFrom, importTo, out), null); } else if (action.equals(""DeleteExperiment"")) { String selectedExperimentName = jsonInput.get(""selectedExperiment"").toString(); instances.get(user.email).tell(new DeleteExperiment(user, selectedExperimentName, out), null); } else if (action.equals(""ExportExperiment"")) { String selectedExperimentName = jsonInput.get(""selectedExperiment"").toString(); Experiment experiment = user.getExperimentByName(selectedExperimentName); if (experiment != null) { ObjectNode jsonOutput = Json.newObject(); try { experiment.export(); jsonOutput.put(""output"", ""Experiment exported.""); } catch (IOException ioe) { jsonOutput.put(""output"", ""Export failed.""); } out.write(jsonOutput); } } else if (action.equals(""SubmitAMTTask"")) { try { Integer lifetimeInSeconds = new Integer(jsonInput.get(""lifetimeInSeconds"").toString()); Integer tutorialTime = new Integer(jsonInput.get(""tutorialTime"").toString()); breadboardController.tell(new SubmitAMTTask(user, lifetimeInSeconds, tutorialTime,  out), null); } catch (NumberFormatException nfe) { } catch (Exception e) { e.printStackTrace(); } } else if (action.equals(""RunGame"")) { if (instances.containsKey(user.email)) { instances.get(user.email).tell(new RunGame(user, out), null); } } else if (action.equals(""SendScript"")) { if (instances.containsKey(user.email)) { String script = jsonInput.get(""script"").toString(); instances.get(user.email).tell(new SendScript(user, script, out), null); } } else if (action.equals(""AddLanguage"")) { Long experimentId = Long.parseLong(jsonInput.get(""experimentId"").toString()); String languageCode = jsonInput.get(""code"").toString(); breadboardController.tell(new AddLanguage(user, experimentId, languageCode, out), null); } else if (action.equals(""MakeChoice"")) { if (instances.containsKey(user.email)) { String choiceUID = jsonInput.get(""choiceUID"").toString(); String params = (jsonInput.containsKey(""params"")) ? jsonInput.get(""params"").toString() : null; instances.get(user.email).tell(new MakeChoice(user, choiceUID, params, out), null); } } else if (action.equals(""SaveStyle"")) { String style = jsonInput.get(""style"").toString(); breadboardController.tell(new SaveStyle(user, style, out), null); } else if (action.equals(""SaveClientHtml"")) { String clientHtml = jsonInput.get(""clientHtml"").toString(); breadboardController.tell(new SaveClientHtml(user, clientHtml, out), null); } else if (action.equals(""SaveClientGraph"")) { String clientGraph = jsonInput.get(""clientGraph"").toString(); breadboardController.tell(new SaveClientGraph(user, clientGraph, out), null); } else if (action.equals(""CreateStep"")) { String name = jsonInput.get(""name"").toString(); breadboardController.tell(new CreateStep(user, name, out), null); } else if (action.equals(""DeleteStep"")) { Long id = Long.valueOf(jsonInput.get(""id"").toString()); breadboardController.tell(new DeleteStep(user, id, out), null); } else if (action.equals(""SendStep"")) { if (instances.containsKey(user.email)) { try { Long id = Long.parseLong(jsonInput.get(""id"").toString()); String name = jsonInput.get(""name"").toString(); String source = jsonInput.get(""source"").toString(); instances.get(user.email).tell(new SendStep(user, id, name, source, out), null); } catch (NumberFormatException nfe) { } } } else if (action.equals(""LaunchGame"")) { if (instances.containsKey(user.email)) { String name = jsonInput.get(""name"").toString(); Object parameters = jsonInput.get(""parameters""); if (parameters instanceof LinkedHashMap) { LinkedHashMap params = (LinkedHashMap) parameters; instances.get(user.email).tell(new LaunchGame(user, name, params, out), null); } } } else if (action.equals(""StopGame"")) { if (instances.containsKey(user.email)) { try { Long id = Long.parseLong(jsonInput.get(""id"").toString()); instances.get(user.email).tell(new StopGame(user, id, out), null); } catch (NumberFormatException nfe) { } } } else if (action.equals(""NewParameter"")) { String name = jsonInput.get(""name"").toString(); String type = jsonInput.get(""type"").toString(); String minVal = (jsonInput.get(""minVal"") == null) ? """" : jsonInput.get(""minVal"").toString(); String maxVal = (jsonInput.get(""maxVal"") == null) ? """" : jsonInput.get(""maxVal"").toString(); String defaultVal = jsonInput.get(""defaultVal"").toString(); String description = jsonInput.get(""description"").toString(); breadboardController.tell(new NewParameter(user, name, type, minVal, maxVal, defaultVal, description, out), null); } else if (action.equals(""RemoveParameter"")) { String id = jsonInput.get(""id"").toString(); breadboardController.tell(new RemoveParameter(user, id, out), null); } else if (action.equals(""SelectInstance"")) { Long id = Long.parseLong(jsonInput.get(""id"").toString()); breadboardController.tell(new SelectInstance(user, id, out), null); } else if (action.equals(""Update"")) { breadboardController.tell(new Update(user, out), null); } else if (action.equals(""ShowEvent"")) { Long experimentInstanceId = Long.parseLong(jsonInput.get(""id"").toString()); breadboardController.tell(new ShowEvent(user, experimentInstanceId, out), null); } else if (action.equals(""DeleteInstance"")) { Long experimentInstanceId = Long.parseLong(jsonInput.get(""id"").toString()); breadboardController.tell(new DeleteInstance(user, experimentInstanceId, out), null); } else if (action.equals(""ReloadEngine"")) { instances.get(user.email).tell(new ReloadEngine(user, out), null); } else if (action.equals(""DeleteImage"")) { Long imageId = Long.parseLong(jsonInput.get(""imageId"").toString()); breadboardController.tell(new DeleteImage(user, imageId, out), null); } else if (action.equals(""ToggleFileMode"")) { breadboardController.tell(new ToggleFileMode(user, out), null); } } else { } } catch (java.io.IOException ioe) { } } } ); } public void onReceive(Object message) throws Exception { if (message instanceof BreadboardMessage) { BreadboardMessage breadboardMessage = (BreadboardMessage) message; if (message instanceof LogIn) { if (!instances.containsKey(breadboardMessage.user.email)) { ActorRef scriptBoardController = Akka.system().actorOf(new Props(ScriptBoard.class)); instances.put(breadboardMessage.user.email, scriptBoardController); scriptBoardController.tell(new AddAdmin(breadboardMessage.user, scriptBoardController, breadboardMessage.out), null); if (breadboardMessage.user.selectedExperiment != null) { breadboardController.tell(new SelectExperiment(breadboardMessage.user, breadboardMessage.user.selectedExperiment, breadboardMessage.out), null); } if (breadboardMessage.user.experimentInstanceId != -1) { breadboardController.tell(new SelectInstance(breadboardMessage.user, breadboardMessage.user.experimentInstanceId, breadboardMessage.out), null); } } else { ObjectNode userJson = breadboardMessage.user.toJson(); breadboardMessage.out.write(userJson); instances.get(breadboardMessage.user.email).tell(new Refresh(breadboardMessage.user, breadboardMessage.out), null); return; } } else if (message instanceof SaveUserSettings) { SaveUserSettings saveUserSettings = (SaveUserSettings) message; List<String> errors = new ArrayList<String>(); if (StringUtils.isEmpty(saveUserSettings.currentPassword)) { errors.add(""'Current Password' is required""); } if (!saveUserSettings.currentPassword.equals(saveUserSettings.user.password)) { errors.add(""'Current Password' doesn't match the current password""); } if (StringUtils.isEmpty(saveUserSettings.newPassword)) { errors.add(""'New Password' is required""); } if (!saveUserSettings.confirmPassword.equals(saveUserSettings.newPassword)) { errors.add(""'Confirm Password' doesn't match the new password""); } saveUserSettings.user.password = saveUserSettings.newPassword; saveUserSettings.user.update(); } else if (message instanceof SelectExperiment) { SelectExperiment selectExperiment = (SelectExperiment) message; breadboardMessage.user.setSelectedExperiment(selectExperiment.experiment); breadboardMessage.user.update(); Experiment selectedExperiment = breadboardMessage.user.getExperiment(); if (selectedExperiment != null) { instances.get(breadboardMessage.user.email).tell(new ChangeExperiment(breadboardMessage.user, selectedExperiment, breadboardMessage.out), null); } } else if (message instanceof CreateExperiment) { } else if (message instanceof ImportExperiment) { } else if (message instanceof SubmitAMTTask) { SubmitAMTTask submitAMTTask = (SubmitAMTTask) message; Integer lifetimeInSeconds = submitAMTTask.lifetimeInSeconds; Integer tutorialTime = submitAMTTask.tutorialTime; instances.get(breadboardMessage.user.email).tell(new HitCreated(breadboardMessage.user, lifetimeInSeconds, tutorialTime, breadboardMessage.out), null); ObjectNode jsonOutput = Json.newObject(); Double totalSeconds = (double)(lifetimeInSeconds + tutorialTime); Double minutes = Math.floor(totalSeconds / 60); Double seconds = totalSeconds - (minutes * 60); jsonOutput.put(""output"", ""AMT HIT created, initStep will automatically start in "" + minutes.toString() + "" minutes and "" + seconds.toString() + "" seconds.""); breadboardMessage.out.write(jsonOutput); } else if (message instanceof AddLanguage) { AddLanguage addLanguage = (AddLanguage) message; Language language = Language.find.where().eq(""code"", addLanguage.languageCode).findUnique(); if (language == null) { language = new Language(); language.code = addLanguage.languageCode; language.name = new Locale(addLanguage.languageCode).getDisplayLanguage(); } Experiment selectedExperiment = Experiment.findById(addLanguage.experimentId); boolean hasLanguage = false; for (Language l : selectedExperiment.languages) { if (l.id.equals(language.id)) { hasLanguage = true; } } if (!hasLanguage) { selectedExperiment.languages.add(language); selectedExperiment.save(); } instances.get(breadboardMessage.user.email).tell(message, null); } else if (message instanceof CreateStep) { CreateStep createStep = (CreateStep) message; Experiment selectedExperiment = breadboardMessage.user.getExperiment(); if (selectedExperiment != null) { Step newStep = new Step(); newStep.name = createStep.name; String nameVariableName = WordUtils.uncapitalize(newStep.name.replaceAll(""[^a-zA-Z0-9\\s]"", """")); newStep.source = nameVariableName + "" = stepFactory.createStep()\n\n"" +
              nameVariableName + "".run = { \n"" +
              ""\tprintln \"""" + nameVariableName + "".run\""\n"" +
              ""} \n\n"" +
              nameVariableName + "".done = { \n"" +
              ""\tprintln \"""" + nameVariableName + "".done\""\n"" +
              ""} \n""; selectedExperiment.addStep(newStep); selectedExperiment.save(); } } else if (message instanceof DeleteStep) { DeleteStep deleteStep = (DeleteStep) message; Step step = Step.find.byId(deleteStep.id); step.delete(); } else if (message instanceof SaveStyle) { SaveStyle saveStyle = (SaveStyle) message; Experiment selectedExperiment = breadboardMessage.user.getExperiment(); if (selectedExperiment != null) { selectedExperiment.setStyle(saveStyle.style); selectedExperiment.update(); ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""output"", ""Style saved.""); breadboardMessage.out.write(jsonOutput); } } else if (message instanceof SaveClientHtml) { SaveClientHtml saveClientHtml = (SaveClientHtml) message; Experiment selectedExperiment = breadboardMessage.user.getExperiment(); if (selectedExperiment != null) { selectedExperiment.setClientHtml(saveClientHtml.clientHtml); selectedExperiment.update(); ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""output"", ""Client HTML saved.""); breadboardMessage.out.write(jsonOutput); } } else if (message instanceof SaveClientGraph) { SaveClientGraph saveClientGraph = (SaveClientGraph) message; Experiment selectedExperiment = breadboardMessage.user.getExperiment(); if (selectedExperiment != null) { selectedExperiment.setClientGraph(saveClientGraph.clientGraph); selectedExperiment.update(); ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""output"", ""Client Graph saved.""); breadboardMessage.out.write(jsonOutput); } } else if (message instanceof NewParameter) { NewParameter newParameter = (NewParameter) message; Experiment selectedExperiment = breadboardMessage.user.getExperiment(); if (selectedExperiment != null) { Parameter parameter = new Parameter(); parameter.name = newParameter.name; parameter.type = newParameter.type; parameter.minVal = (parameter.type.equals(""Text"") || parameter.type.equals(""Boolean"")) ? """" : newParameter.minVal; parameter.maxVal = (parameter.type.equals(""Text"") || parameter.type.equals(""Boolean"")) ? """" : newParameter.maxVal; parameter.defaultVal = newParameter.defaultVal; parameter.description = newParameter.description; selectedExperiment.parameters.add(parameter); selectedExperiment.save(); } } else if (message instanceof RemoveParameter) { RemoveParameter removeParameter = (RemoveParameter) message; Experiment selectedExperiment = breadboardMessage.user.getExperiment(); if (selectedExperiment != null) { Parameter parameter = Parameter.find.byId(removeParameter.id); if (parameter != null) { selectedExperiment.parameters.remove(parameter); selectedExperiment.update(); parameter.delete(); } } } else if (message instanceof SelectInstance) { instances.get(breadboardMessage.user.email).tell(message, null); } else if (message instanceof Update) { } else if (message instanceof ShowEvent) { ShowEvent showEvent = (ShowEvent) message; Long experimentInstanceId = showEvent.experimentInstanceId; ExperimentInstance experimentInstance = ExperimentInstance.findById(experimentInstanceId); List<Event> events = experimentInstance.events; Collections.sort(events, new Comparator<Event>() { @Override
          public int compare(Event o1, Event o2) { return o1.datetime.compareTo(o2.datetime); } } ); ObjectNode eventNode = Json.newObject(); eventNode.put(""eventExperimentInstance"", experimentInstance.name); ArrayNode arrayNode = eventNode.putArray(""events""); for (Event event : events) { List<EventData> eventDatas = event.eventData; ObjectNode objectNode = Json.newObject(); objectNode.put(""id"", event.id); objectNode.put(""name"", event.name); objectNode.put(""datetime"", new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss,S"").format(event.datetime)); ArrayNode dataNodes = objectNode.putArray(""data""); for (EventData eventData : eventDatas) { ObjectNode dataNode = Json.newObject(); dataNode.put(""id"", eventData.id); dataNode.put(""name"", eventData.name); dataNode.put(""value"", eventData.value); dataNodes.add(dataNode); } arrayNode.add(objectNode); } "" + eventNode); breadboardMessage.out.write(eventNode); return; } else if (message instanceof DeleteInstance) { DeleteInstance deleteInstance = (DeleteInstance) message; Long experimentInstanceId = deleteInstance.experimentInstanceId; ExperimentInstance experimentInstance = ExperimentInstance.findById(experimentInstanceId); if (experimentInstance.status == ExperimentInstance.Status.FINISHED || experimentInstance.status == ExperimentInstance.Status.STOPPED) { experimentInstance.delete(); } } else if (message instanceof DeleteImage) { DeleteImage deleteImage = (DeleteImage) message; Long imageId = deleteImage.imageId; Image.findById(imageId).delete(); } else if (message instanceof ToggleFileMode) { Experiment selectedExperiment = breadboardMessage.user.getExperiment(); if (selectedExperiment != null) { selectedExperiment.toggleFileMode(breadboardMessage.user); } } breadboardMessage.out.write(breadboardMessage.user.toJson()); } } public static abstract class BreadboardMessage { final User user; final ThrottledWebSocketOut out; public BreadboardMessage(User user, ThrottledWebSocketOut out) { this.user = user; this.out = out; } } public static class LogIn extends BreadboardMessage { public LogIn(User user, ThrottledWebSocketOut out) { super(user, out); } } public static class Refresh extends BreadboardMessage { public Refresh(User user, ThrottledWebSocketOut out) { super(user, out); } } public static class Update extends BreadboardMessage { public Update(User user, ThrottledWebSocketOut out) { super(user, out); } } public static class SaveUserSettings extends BreadboardMessage { final String currentPassword; final String newPassword; final String confirmPassword; public SaveUserSettings(User user, String currentPassword, String newPassword, String confirmPassword, ThrottledWebSocketOut out) { super(user, out); this.currentPassword = currentPassword; this.newPassword = newPassword; this.confirmPassword = confirmPassword; } } public static class SelectExperiment extends BreadboardMessage { final Experiment experiment; public SelectExperiment(User user, Experiment experiment, ThrottledWebSocketOut out) { super(user, out); this.experiment = experiment; } } public static class DeleteExperiment extends BreadboardMessage { final String experimentName; public DeleteExperiment(User user, String experimentName, ThrottledWebSocketOut out) { super(user, out); this.experimentName = experimentName; } } public static class ExportExperiment extends BreadboardMessage { final String experimentName; public ExportExperiment(User user, String experimentName, ThrottledWebSocketOut out) { super(user, out); this.experimentName = experimentName; } } public static class ChangeExperiment extends BreadboardMessage { final Experiment experiment; public ChangeExperiment(User user, Experiment experiment, ThrottledWebSocketOut out) { super(user, out); this.experiment = experiment; } } public static class CreateExperiment extends BreadboardMessage { final String name; final String copyExperimentName; public CreateExperiment(User user, String name, String copyExperimentName, ThrottledWebSocketOut out) { super(user, out); this.name = name; this.copyExperimentName = copyExperimentName; } } public static class ImportExperiment extends BreadboardMessage { final String importFrom; final String importTo; public ImportExperiment(User user, String importFrom, String importTo, ThrottledWebSocketOut out) { super(user, out); this.importFrom = importFrom; this.importTo = importTo; } } public static class SubmitAMTTask extends BreadboardMessage { final Integer lifetimeInSeconds; final Integer tutorialTime; public SubmitAMTTask(User user, Integer lifetimeInSeconds, Integer tutorialTime, ThrottledWebSocketOut out) { super(user, out); this.lifetimeInSeconds = lifetimeInSeconds; this.tutorialTime = tutorialTime; } } public static class HitCreated extends BreadboardMessage { final Integer lifetimeInSeconds; final Integer tutorialTime; public HitCreated(User user, Integer lifetimeInSeconds, Integer tutorialTime, ThrottledWebSocketOut out) { super(user, out); this.lifetimeInSeconds = lifetimeInSeconds; this.tutorialTime = tutorialTime; } } public static class AddLanguage extends BreadboardMessage { final Long experimentId; final String languageCode; public AddLanguage(User user, Long experimentId, String languageCode, ThrottledWebSocketOut out) { super(user, out); this.experimentId = experimentId; this.languageCode = languageCode; } } public static class CreateStep extends BreadboardMessage { final String name; public CreateStep(User user, String name, ThrottledWebSocketOut out) { super(user, out); this.name = name; } } public static class DeleteStep extends BreadboardMessage { final Long id; public DeleteStep(User user, Long id, ThrottledWebSocketOut out) { super(user, out); this.id = id; } } public static class SaveStyle extends BreadboardMessage { final String style; public SaveStyle(User user, String style, ThrottledWebSocketOut out) { super(user, out); this.style = style; } } public static class SaveClientHtml extends BreadboardMessage { final String clientHtml; public SaveClientHtml(User user, String clientHtml, ThrottledWebSocketOut out) { super(user, out); this.clientHtml = clientHtml; } } public static class SaveClientGraph extends BreadboardMessage { final String clientGraph; public SaveClientGraph(User user, String clientGraph, ThrottledWebSocketOut out) { super(user, out); this.clientGraph = clientGraph; } } public static class RunGame extends BreadboardMessage { public RunGame(User user, ThrottledWebSocketOut out) { super(user, out); } } public static class SendScript extends BreadboardMessage { final String script; public SendScript(User user, String script, ThrottledWebSocketOut out) { super(user, out); this.script = script; } } public static class SendStep extends BreadboardMessage { final Long id; final String name; final String source; public SendStep(User user, Long id, String name, String source, ThrottledWebSocketOut out) { super(user, out); this.id = id; this.name = name; this.source = source; } } public static class RunStep extends BreadboardMessage { final String source; public RunStep(User user, String source, ThrottledWebSocketOut out) { super(user, out); this.source = source; } } public static class MakeChoice extends BreadboardMessage { final String uid; final String params; public MakeChoice(User user, String uid, String params, ThrottledWebSocketOut out) { super(user, out); this.uid = uid; this.params = params; } } public static class LaunchGame extends BreadboardMessage { final String name; final LinkedHashMap parameters; public LaunchGame(User user, String name, LinkedHashMap parameters, ThrottledWebSocketOut out) { super(user, out); this.name = name; this.parameters = parameters; } } public static class StopGame extends BreadboardMessage { final Long id; public StopGame(User user, Long id, ThrottledWebSocketOut out) { super(user, out); this.id = id; } } public static class NewParameter extends BreadboardMessage { final String name; final String type; final String minVal; final String maxVal; final String defaultVal; final String description; public NewParameter(User user, String name, String type, String minVal, String maxVal, String defaultVal, String description, ThrottledWebSocketOut out) { super(user, out); this.name = name; this.type = type; this.minVal = minVal; this.maxVal = maxVal; this.defaultVal = defaultVal; this.description = description; } } public static class RemoveParameter extends BreadboardMessage { final String id; public RemoveParameter(User user, String id, ThrottledWebSocketOut out) { super(user, out); this.id = id; } } public static class SelectInstance extends BreadboardMessage { final Long id; public SelectInstance(User user, Long id, ThrottledWebSocketOut out) { super(user, out); this.id = id; } } public static class AddAdmin extends BreadboardMessage { final ActorRef scriptBoardController; public AddAdmin(User user, ActorRef scriptBoardController, ThrottledWebSocketOut out) { super(user, out); this.scriptBoardController = scriptBoardController; } } public static class RunOnJoinStep extends BreadboardMessage { final Vertex vertex; public RunOnJoinStep(User user, Vertex vertex, ThrottledWebSocketOut out) { super(user, out); this.vertex = vertex; } } public static class RunOnLeaveStep extends BreadboardMessage { final Vertex vertex; public RunOnLeaveStep(User user, Vertex vertex, ThrottledWebSocketOut out) { super(user, out); this.vertex = vertex; } } public static class ShowEvent extends BreadboardMessage { final Long experimentInstanceId; public ShowEvent(User user, Long experimentInstanceId, ThrottledWebSocketOut out) { super(user, out); this.experimentInstanceId = experimentInstanceId; } } public static class GameFinish extends BreadboardMessage { public GameFinish(User user, ThrottledWebSocketOut out) { super(user, out); } } public static class DeleteInstance extends BreadboardMessage { final Long experimentInstanceId; public DeleteInstance(User user, Long experimentInstanceId, ThrottledWebSocketOut out) { super(user, out); this.experimentInstanceId = experimentInstanceId; } } public static class ReloadEngine extends BreadboardMessage { public ReloadEngine(User user, ThrottledWebSocketOut out) { super(user, out); } } public static class ToggleFileMode extends BreadboardMessage { public ToggleFileMode(User user, ThrottledWebSocketOut out) { super(user, out); } } public static class DeleteImage extends BreadboardMessage { final Long imageId; public DeleteImage(User user, Long imageId, ThrottledWebSocketOut out) { super(user, out); this.imageId = imageId; } } }",0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 1 0 1 1 0 0 1 0 0 0 0 0 0 1 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; public class Breadboard extends UntypedActor { public static final long WEBSOCKET_RATE = 100L; static Map<String, ActorRef> instances = new HashMap<String, ActorRef>(); static ActorRef breadboardController = Akka.system().actorOf(new Props(Breadboard.class)); static ThrottledWebSocketOut out; public static void connect(final WebSocket.In<JsonNode> in, final WebSocket.Out<JsonNode> wsout) { out = new ThrottledWebSocketOut(wsout, WEBSOCKET_RATE); in.onMessage(new Callback<JsonNode>() { public void invoke(JsonNode event) { try { <FILL_ME> ObjectMapper mapper = new ObjectMapper(); Map<String, Object> jsonInput = mapper.readValue(event.toString(), Map.class); String action = jsonInput.get(""action"").toString(); String uid = jsonInput.get(""uid"").toString(); User user = User.findByUID(uid); ObjectNode result = Json.newObject(); if (user != null) { if (action.equals(""LogIn"")) { breadboardController.tell(new LogIn(user, out), null); } <FILL_ME> <FILL_ME> else if (action.equals(""SaveUserSettings"")) { String currentPassword = jsonInput.get(""currentPassword"").toString().trim(); String newPassword = jsonInput.get(""newPassword"").toString().trim(); String confirmPassword = jsonInput.get(""confirmPassword"").toString().trim(); breadboardController.tell(new SaveUserSettings(user, currentPassword, newPassword, confirmPassword, out), null); } else if (action.equals(""SelectExperiment"")) { Long experimentId = Long.parseLong(jsonInput.get(""experimentId"").toString()); Experiment experiment = Experiment.findById(experimentId); if (experiment != null)
                breadboardController.tell(new SelectExperiment(user, experiment, out), null); } else if (action.equals(""CreateExperiment"")) { String name = jsonInput.get(""name"").toString(); String copyExperimentName = jsonInput.containsKey(""copyExperimentName"") ? jsonInput.get(""copyExperimentName"").toString() : null; breadboardController.tell(new CreateExperiment(user, name, copyExperimentName, out), null); <FILL_ME> } else if (action.equals(""ImportExperiment"")) { String importFrom = jsonInput.get(""importFrom"").toString(); String importTo = jsonInput.get(""importTo"").toString(); breadboardController.tell(new ImportExperiment(user, importFrom, importTo, out), null); <FILL_ME> } else if (action.equals(""DeleteExperiment"")) { String selectedExperimentName = jsonInput.get(""selectedExperiment"").toString(); instances.get(user.email).tell(new DeleteExperiment(user, selectedExperimentName, out), null); } else if (action.equals(""ExportExperiment"")) { String selectedExperimentName = jsonInput.get(""selectedExperiment"").toString(); Experiment experiment = user.getExperimentByName(selectedExperimentName); if (experiment != null) { ObjectNode jsonOutput = Json.newObject(); try { experiment.export(); jsonOutput.put(""output"", ""Experiment exported.""); } catch (IOException ioe) { jsonOutput.put(""output"", ""Export failed.""); <FILL_ME> } out.write(jsonOutput); } } else if (action.equals(""SubmitAMTTask"")) { <FILL_ME> try { Integer lifetimeInSeconds = new Integer(jsonInput.get(""lifetimeInSeconds"").toString()); Integer tutorialTime = new Integer(jsonInput.get(""tutorialTime"").toString()); breadboardController.tell(new SubmitAMTTask(user, lifetimeInSeconds, tutorialTime,  out), null); } catch (NumberFormatException nfe) { <FILL_ME> <FILL_ME> <FILL_ME> } catch (Exception e) { <FILL_ME> e.printStackTrace(); } } else if (action.equals(""RunGame"")) { if (instances.containsKey(user.email)) { instances.get(user.email).tell(new RunGame(user, out), null); } } else if (action.equals(""SendScript"")) { if (instances.containsKey(user.email)) { String script = jsonInput.get(""script"").toString(); instances.get(user.email).tell(new SendScript(user, script, out), null); } } else if (action.equals(""AddLanguage"")) { Long experimentId = Long.parseLong(jsonInput.get(""experimentId"").toString()); String languageCode = jsonInput.get(""code"").toString(); breadboardController.tell(new AddLanguage(user, experimentId, languageCode, out), null); } else if (action.equals(""MakeChoice"")) { if (instances.containsKey(user.email)) { String choiceUID = jsonInput.get(""choiceUID"").toString(); String params = (jsonInput.containsKey(""params"")) ? jsonInput.get(""params"").toString() : null; instances.get(user.email).tell(new MakeChoice(user, choiceUID, params, out), null); } } else if (action.equals(""SaveStyle"")) { String style = jsonInput.get(""style"").toString(); breadboardController.tell(new SaveStyle(user, style, out), null); } else if (action.equals(""SaveClientHtml"")) { String clientHtml = jsonInput.get(""clientHtml"").toString(); breadboardController.tell(new SaveClientHtml(user, clientHtml, out), null); } else if (action.equals(""SaveClientGraph"")) { String clientGraph = jsonInput.get(""clientGraph"").toString(); breadboardController.tell(new SaveClientGraph(user, clientGraph, out), null); } else if (action.equals(""CreateStep"")) { String name = jsonInput.get(""name"").toString(); breadboardController.tell(new CreateStep(user, name, out), null); } else if (action.equals(""DeleteStep"")) { Long id = Long.valueOf(jsonInput.get(""id"").toString()); breadboardController.tell(new DeleteStep(user, id, out), null); } else if (action.equals(""SendStep"")) { if (instances.containsKey(user.email)) { try { Long id = Long.parseLong(jsonInput.get(""id"").toString()); String name = jsonInput.get(""name"").toString(); String source = jsonInput.get(""source"").toString(); instances.get(user.email).tell(new SendStep(user, id, name, source, out), null); } catch (NumberFormatException nfe) { } } } else if (action.equals(""LaunchGame"")) { if (instances.containsKey(user.email)) { String name = jsonInput.get(""name"").toString(); Object parameters = jsonInput.get(""parameters""); <FILL_ME> if (parameters instanceof LinkedHashMap) { LinkedHashMap params = (LinkedHashMap) parameters; instances.get(user.email).tell(new LaunchGame(user, name, params, out), null); } } } else if (action.equals(""StopGame"")) { if (instances.containsKey(user.email)) { try { Long id = Long.parseLong(jsonInput.get(""id"").toString()); instances.get(user.email).tell(new StopGame(user, id, out), null); } catch (NumberFormatException nfe) { } } } else if (action.equals(""NewParameter"")) { String name = jsonInput.get(""name"").toString(); String type = jsonInput.get(""type"").toString(); String minVal = (jsonInput.get(""minVal"") == null) ? """" : jsonInput.get(""minVal"").toString(); String maxVal = (jsonInput.get(""maxVal"") == null) ? """" : jsonInput.get(""maxVal"").toString(); String defaultVal = jsonInput.get(""defaultVal"").toString(); String description = jsonInput.get(""description"").toString(); breadboardController.tell(new NewParameter(user, name, type, minVal, maxVal, defaultVal, description, out), null); } else if (action.equals(""RemoveParameter"")) { String id = jsonInput.get(""id"").toString(); breadboardController.tell(new RemoveParameter(user, id, out), null); } else if (action.equals(""SelectInstance"")) { Long id = Long.parseLong(jsonInput.get(""id"").toString()); breadboardController.tell(new SelectInstance(user, id, out), null); } else if (action.equals(""Update"")) { breadboardController.tell(new Update(user, out), null); } else if (action.equals(""ShowEvent"")) { Long experimentInstanceId = Long.parseLong(jsonInput.get(""id"").toString()); breadboardController.tell(new ShowEvent(user, experimentInstanceId, out), null); } else if (action.equals(""DeleteInstance"")) { Long experimentInstanceId = Long.parseLong(jsonInput.get(""id"").toString()); breadboardController.tell(new DeleteInstance(user, experimentInstanceId, out), null); } else if (action.equals(""ReloadEngine"")) { instances.get(user.email).tell(new ReloadEngine(user, out), null); } else if (action.equals(""DeleteImage"")) { Long imageId = Long.parseLong(jsonInput.get(""imageId"").toString()); breadboardController.tell(new DeleteImage(user, imageId, out), null); } else if (action.equals(""ToggleFileMode"")) { breadboardController.tell(new ToggleFileMode(user, out), null); } } else { <FILL_ME> <FILL_ME> } } catch (java.io.IOException ioe) { <FILL_ME> } } } ); } public void onReceive(Object message) throws Exception { if (message instanceof BreadboardMessage) { BreadboardMessage breadboardMessage = (BreadboardMessage) message; <FILL_ME> if (message instanceof LogIn) { if (!instances.containsKey(breadboardMessage.user.email)) { <FILL_ME> ActorRef scriptBoardController = Akka.system().actorOf(new Props(ScriptBoard.class)); <FILL_ME> instances.put(breadboardMessage.user.email, scriptBoardController); scriptBoardController.tell(new AddAdmin(breadboardMessage.user, scriptBoardController, breadboardMessage.out), null); if (breadboardMessage.user.selectedExperiment != null) { <FILL_ME> breadboardController.tell(new SelectExperiment(breadboardMessage.user, breadboardMessage.user.selectedExperiment, breadboardMessage.out), null); } if (breadboardMessage.user.experimentInstanceId != -1) { breadboardController.tell(new SelectInstance(breadboardMessage.user, breadboardMessage.user.experimentInstanceId, breadboardMessage.out), null); } } else { ObjectNode userJson = breadboardMessage.user.toJson(); breadboardMessage.out.write(userJson); <FILL_ME> instances.get(breadboardMessage.user.email).tell(new Refresh(breadboardMessage.user, breadboardMessage.out), null); return; } } else if (message instanceof SaveUserSettings) { SaveUserSettings saveUserSettings = (SaveUserSettings) message; List<String> errors = new ArrayList<String>(); if (StringUtils.isEmpty(saveUserSettings.currentPassword)) { errors.add(""'Current Password' is required""); } if (!saveUserSettings.currentPassword.equals(saveUserSettings.user.password)) { errors.add(""'Current Password' doesn't match the current password""); } if (StringUtils.isEmpty(saveUserSettings.newPassword)) { errors.add(""'New Password' is required""); } if (!saveUserSettings.confirmPassword.equals(saveUserSettings.newPassword)) { errors.add(""'Confirm Password' doesn't match the new password""); } saveUserSettings.user.password = saveUserSettings.newPassword; saveUserSettings.user.update(); } else if (message instanceof SelectExperiment) { SelectExperiment selectExperiment = (SelectExperiment) message; <FILL_ME> breadboardMessage.user.setSelectedExperiment(selectExperiment.experiment); breadboardMessage.user.update(); Experiment selectedExperiment = breadboardMessage.user.getExperiment(); if (selectedExperiment != null) { <FILL_ME> <FILL_ME> <FILL_ME> instances.get(breadboardMessage.user.email).tell(new ChangeExperiment(breadboardMessage.user, selectedExperiment, breadboardMessage.out), null); } } else if (message instanceof CreateExperiment) { <FILL_ME> } else if (message instanceof ImportExperiment) { <FILL_ME> } else if (message instanceof SubmitAMTTask) { SubmitAMTTask submitAMTTask = (SubmitAMTTask) message; Integer lifetimeInSeconds = submitAMTTask.lifetimeInSeconds; Integer tutorialTime = submitAMTTask.tutorialTime; instances.get(breadboardMessage.user.email).tell(new HitCreated(breadboardMessage.user, lifetimeInSeconds, tutorialTime, breadboardMessage.out), null); ObjectNode jsonOutput = Json.newObject(); Double totalSeconds = (double)(lifetimeInSeconds + tutorialTime); Double minutes = Math.floor(totalSeconds / 60); Double seconds = totalSeconds - (minutes * 60); jsonOutput.put(""output"", ""AMT HIT created, initStep will automatically start in "" + minutes.toString() + "" minutes and "" + seconds.toString() + "" seconds.""); breadboardMessage.out.write(jsonOutput); } else if (message instanceof AddLanguage) { AddLanguage addLanguage = (AddLanguage) message; Language language = Language.find.where().eq(""code"", addLanguage.languageCode).findUnique(); if (language == null) { language = new Language(); language.code = addLanguage.languageCode; language.name = new Locale(addLanguage.languageCode).getDisplayLanguage(); } Experiment selectedExperiment = Experiment.findById(addLanguage.experimentId); boolean hasLanguage = false; for (Language l : selectedExperiment.languages) { if (l.id.equals(language.id)) { hasLanguage = true; } } if (!hasLanguage) { selectedExperiment.languages.add(language); selectedExperiment.save(); } instances.get(breadboardMessage.user.email).tell(message, null); } else if (message instanceof CreateStep) { CreateStep createStep = (CreateStep) message; <FILL_ME> Experiment selectedExperiment = breadboardMessage.user.getExperiment(); if (selectedExperiment != null) { Step newStep = new Step(); newStep.name = createStep.name; String nameVariableName = WordUtils.uncapitalize(newStep.name.replaceAll(""[^a-zA-Z0-9\\s]"", """")); newStep.source = nameVariableName + "" = stepFactory.createStep()\n\n"" +
              nameVariableName + "".run = { \n"" +
              ""\tprintln \"""" + nameVariableName + "".run\""\n"" +
              ""} \n\n"" +
              nameVariableName + "".done = { \n"" +
              ""\tprintln \"""" + nameVariableName + "".done\""\n"" +
              ""} \n""; selectedExperiment.addStep(newStep); selectedExperiment.save(); } } else if (message instanceof DeleteStep) { DeleteStep deleteStep = (DeleteStep) message; Step step = Step.find.byId(deleteStep.id); step.delete(); } else if (message instanceof SaveStyle) { SaveStyle saveStyle = (SaveStyle) message; Experiment selectedExperiment = breadboardMessage.user.getExperiment(); if (selectedExperiment != null) { selectedExperiment.setStyle(saveStyle.style); selectedExperiment.update(); ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""output"", ""Style saved.""); breadboardMessage.out.write(jsonOutput); } } else if (message instanceof SaveClientHtml) { SaveClientHtml saveClientHtml = (SaveClientHtml) message; Experiment selectedExperiment = breadboardMessage.user.getExperiment(); if (selectedExperiment != null) { selectedExperiment.setClientHtml(saveClientHtml.clientHtml); selectedExperiment.update(); ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""output"", ""Client HTML saved.""); breadboardMessage.out.write(jsonOutput); } } else if (message instanceof SaveClientGraph) { SaveClientGraph saveClientGraph = (SaveClientGraph) message; Experiment selectedExperiment = breadboardMessage.user.getExperiment(); if (selectedExperiment != null) { selectedExperiment.setClientGraph(saveClientGraph.clientGraph); selectedExperiment.update(); ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""output"", ""Client Graph saved.""); breadboardMessage.out.write(jsonOutput); } } else if (message instanceof NewParameter) { NewParameter newParameter = (NewParameter) message; Experiment selectedExperiment = breadboardMessage.user.getExperiment(); if (selectedExperiment != null) { Parameter parameter = new Parameter(); parameter.name = newParameter.name; parameter.type = newParameter.type; parameter.minVal = (parameter.type.equals(""Text"") || parameter.type.equals(""Boolean"")) ? """" : newParameter.minVal; parameter.maxVal = (parameter.type.equals(""Text"") || parameter.type.equals(""Boolean"")) ? """" : newParameter.maxVal; parameter.defaultVal = newParameter.defaultVal; parameter.description = newParameter.description; selectedExperiment.parameters.add(parameter); selectedExperiment.save(); } } else if (message instanceof RemoveParameter) { RemoveParameter removeParameter = (RemoveParameter) message; Experiment selectedExperiment = breadboardMessage.user.getExperiment(); if (selectedExperiment != null) { Parameter parameter = Parameter.find.byId(removeParameter.id); if (parameter != null) { selectedExperiment.parameters.remove(parameter); selectedExperiment.update(); parameter.delete(); } } } else if (message instanceof SelectInstance) { instances.get(breadboardMessage.user.email).tell(message, null); } else if (message instanceof Update) { } else if (message instanceof ShowEvent) { ShowEvent showEvent = (ShowEvent) message; Long experimentInstanceId = showEvent.experimentInstanceId; ExperimentInstance experimentInstance = ExperimentInstance.findById(experimentInstanceId); List<Event> events = experimentInstance.events; Collections.sort(events, new Comparator<Event>() { @Override
          public int compare(Event o1, Event o2) { return o1.datetime.compareTo(o2.datetime); } } ); ObjectNode eventNode = Json.newObject(); eventNode.put(""eventExperimentInstance"", experimentInstance.name); ArrayNode arrayNode = eventNode.putArray(""events""); for (Event event : events) { List<EventData> eventDatas = event.eventData; ObjectNode objectNode = Json.newObject(); objectNode.put(""id"", event.id); objectNode.put(""name"", event.name); objectNode.put(""datetime"", new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss,S"").format(event.datetime)); ArrayNode dataNodes = objectNode.putArray(""data""); for (EventData eventData : eventDatas) { ObjectNode dataNode = Json.newObject(); dataNode.put(""id"", eventData.id); dataNode.put(""name"", eventData.name); dataNode.put(""value"", eventData.value); dataNodes.add(dataNode); } arrayNode.add(objectNode); } "" + eventNode); breadboardMessage.out.write(eventNode); return; } else if (message instanceof DeleteInstance) { DeleteInstance deleteInstance = (DeleteInstance) message; Long experimentInstanceId = deleteInstance.experimentInstanceId; ExperimentInstance experimentInstance = ExperimentInstance.findById(experimentInstanceId); if (experimentInstance.status == ExperimentInstance.Status.FINISHED || experimentInstance.status == ExperimentInstance.Status.STOPPED) { experimentInstance.delete(); } } else if (message instanceof DeleteImage) { DeleteImage deleteImage = (DeleteImage) message; Long imageId = deleteImage.imageId; Image.findById(imageId).delete(); } else if (message instanceof ToggleFileMode) { Experiment selectedExperiment = breadboardMessage.user.getExperiment(); if (selectedExperiment != null) { selectedExperiment.toggleFileMode(breadboardMessage.user); } } breadboardMessage.out.write(breadboardMessage.user.toJson()); } } public static abstract class BreadboardMessage { final User user; final ThrottledWebSocketOut out; public BreadboardMessage(User user, ThrottledWebSocketOut out) { this.user = user; this.out = out; } } public static class LogIn extends BreadboardMessage { public LogIn(User user, ThrottledWebSocketOut out) { super(user, out); } } public static class Refresh extends BreadboardMessage { public Refresh(User user, ThrottledWebSocketOut out) { super(user, out); } } public static class Update extends BreadboardMessage { public Update(User user, ThrottledWebSocketOut out) { super(user, out); } } public static class SaveUserSettings extends BreadboardMessage { final String currentPassword; final String newPassword; final String confirmPassword; public SaveUserSettings(User user, String currentPassword, String newPassword, String confirmPassword, ThrottledWebSocketOut out) { super(user, out); this.currentPassword = currentPassword; this.newPassword = newPassword; this.confirmPassword = confirmPassword; } } public static class SelectExperiment extends BreadboardMessage { final Experiment experiment; public SelectExperiment(User user, Experiment experiment, ThrottledWebSocketOut out) { super(user, out); this.experiment = experiment; } } public static class DeleteExperiment extends BreadboardMessage { final String experimentName; public DeleteExperiment(User user, String experimentName, ThrottledWebSocketOut out) { super(user, out); this.experimentName = experimentName; } } public static class ExportExperiment extends BreadboardMessage { final String experimentName; public ExportExperiment(User user, String experimentName, ThrottledWebSocketOut out) { super(user, out); this.experimentName = experimentName; } } public static class ChangeExperiment extends BreadboardMessage { final Experiment experiment; public ChangeExperiment(User user, Experiment experiment, ThrottledWebSocketOut out) { super(user, out); this.experiment = experiment; } } public static class CreateExperiment extends BreadboardMessage { final String name; final String copyExperimentName; public CreateExperiment(User user, String name, String copyExperimentName, ThrottledWebSocketOut out) { super(user, out); this.name = name; this.copyExperimentName = copyExperimentName; } } public static class ImportExperiment extends BreadboardMessage { final String importFrom; final String importTo; public ImportExperiment(User user, String importFrom, String importTo, ThrottledWebSocketOut out) { super(user, out); this.importFrom = importFrom; this.importTo = importTo; } } public static class SubmitAMTTask extends BreadboardMessage { final Integer lifetimeInSeconds; final Integer tutorialTime; public SubmitAMTTask(User user, Integer lifetimeInSeconds, Integer tutorialTime, ThrottledWebSocketOut out) { super(user, out); this.lifetimeInSeconds = lifetimeInSeconds; this.tutorialTime = tutorialTime; } } public static class HitCreated extends BreadboardMessage { final Integer lifetimeInSeconds; final Integer tutorialTime; public HitCreated(User user, Integer lifetimeInSeconds, Integer tutorialTime, ThrottledWebSocketOut out) { super(user, out); this.lifetimeInSeconds = lifetimeInSeconds; this.tutorialTime = tutorialTime; } } public static class AddLanguage extends BreadboardMessage { final Long experimentId; final String languageCode; public AddLanguage(User user, Long experimentId, String languageCode, ThrottledWebSocketOut out) { super(user, out); this.experimentId = experimentId; this.languageCode = languageCode; } } public static class CreateStep extends BreadboardMessage { final String name; public CreateStep(User user, String name, ThrottledWebSocketOut out) { super(user, out); this.name = name; } } public static class DeleteStep extends BreadboardMessage { final Long id; public DeleteStep(User user, Long id, ThrottledWebSocketOut out) { super(user, out); this.id = id; } } public static class SaveStyle extends BreadboardMessage { final String style; public SaveStyle(User user, String style, ThrottledWebSocketOut out) { super(user, out); this.style = style; } } public static class SaveClientHtml extends BreadboardMessage { final String clientHtml; public SaveClientHtml(User user, String clientHtml, ThrottledWebSocketOut out) { super(user, out); this.clientHtml = clientHtml; } } public static class SaveClientGraph extends BreadboardMessage { final String clientGraph; public SaveClientGraph(User user, String clientGraph, ThrottledWebSocketOut out) { super(user, out); this.clientGraph = clientGraph; } } public static class RunGame extends BreadboardMessage { public RunGame(User user, ThrottledWebSocketOut out) { super(user, out); } } public static class SendScript extends BreadboardMessage { final String script; public SendScript(User user, String script, ThrottledWebSocketOut out) { super(user, out); this.script = script; } } public static class SendStep extends BreadboardMessage { final Long id; final String name; final String source; public SendStep(User user, Long id, String name, String source, ThrottledWebSocketOut out) { super(user, out); this.id = id; this.name = name; this.source = source; } } public static class RunStep extends BreadboardMessage { final String source; public RunStep(User user, String source, ThrottledWebSocketOut out) { super(user, out); this.source = source; } } public static class MakeChoice extends BreadboardMessage { final String uid; final String params; public MakeChoice(User user, String uid, String params, ThrottledWebSocketOut out) { super(user, out); this.uid = uid; this.params = params; } } public static class LaunchGame extends BreadboardMessage { final String name; final LinkedHashMap parameters; public LaunchGame(User user, String name, LinkedHashMap parameters, ThrottledWebSocketOut out) { super(user, out); this.name = name; this.parameters = parameters; } } public static class StopGame extends BreadboardMessage { final Long id; public StopGame(User user, Long id, ThrottledWebSocketOut out) { super(user, out); this.id = id; } } public static class NewParameter extends BreadboardMessage { final String name; final String type; final String minVal; final String maxVal; final String defaultVal; final String description; public NewParameter(User user, String name, String type, String minVal, String maxVal, String defaultVal, String description, ThrottledWebSocketOut out) { super(user, out); this.name = name; this.type = type; this.minVal = minVal; this.maxVal = maxVal; this.defaultVal = defaultVal; this.description = description; } } public static class RemoveParameter extends BreadboardMessage { final String id; public RemoveParameter(User user, String id, ThrottledWebSocketOut out) { super(user, out); this.id = id; } } public static class SelectInstance extends BreadboardMessage { final Long id; public SelectInstance(User user, Long id, ThrottledWebSocketOut out) { super(user, out); this.id = id; } } public static class AddAdmin extends BreadboardMessage { final ActorRef scriptBoardController; public AddAdmin(User user, ActorRef scriptBoardController, ThrottledWebSocketOut out) { super(user, out); this.scriptBoardController = scriptBoardController; } } public static class RunOnJoinStep extends BreadboardMessage { final Vertex vertex; public RunOnJoinStep(User user, Vertex vertex, ThrottledWebSocketOut out) { super(user, out); this.vertex = vertex; } } public static class RunOnLeaveStep extends BreadboardMessage { final Vertex vertex; public RunOnLeaveStep(User user, Vertex vertex, ThrottledWebSocketOut out) { super(user, out); this.vertex = vertex; } } public static class ShowEvent extends BreadboardMessage { final Long experimentInstanceId; public ShowEvent(User user, Long experimentInstanceId, ThrottledWebSocketOut out) { super(user, out); this.experimentInstanceId = experimentInstanceId; } } public static class GameFinish extends BreadboardMessage { public GameFinish(User user, ThrottledWebSocketOut out) { super(user, out); } } public static class DeleteInstance extends BreadboardMessage { final Long experimentInstanceId; public DeleteInstance(User user, Long experimentInstanceId, ThrottledWebSocketOut out) { super(user, out); this.experimentInstanceId = experimentInstanceId; } } public static class ReloadEngine extends BreadboardMessage { public ReloadEngine(User user, ThrottledWebSocketOut out) { super(user, out); } } public static class ToggleFileMode extends BreadboardMessage { public ToggleFileMode(User user, ThrottledWebSocketOut out) { super(user, out); } } public static class DeleteImage extends BreadboardMessage { final Long imageId; public DeleteImage(User user, Long imageId, ThrottledWebSocketOut out) { super(user, out); this.imageId = imageId; } } } ","package models; 
import akka.actor.ActorRef; import akka.actor.Props; import akka.actor.UntypedActor; import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.node.ArrayNode; import com.fasterxml.jackson.databind.node.ObjectNode; import com.tinkerpop.blueprints.Vertex; import org.apache.commons.io.FileUtils; import org.apache.commons.io.FilenameUtils; import org.apache.commons.lang3.StringUtils; import org.apache.commons.lang3.text.WordUtils; import org.imgscalr.Scalr; import play.Logger; import play.Play; import play.libs.*; import play.libs.F.Callback; import play.mvc.WebSocket; import javax.imageio.ImageIO; import java.awt.image.BufferedImage; import java.io.*; import java.text.SimpleDateFormat; import java.util.*;  public class Breadboard extends UntypedActor { // How often to send websocket messages in ms public static final long WEBSOCKET_RATE = 100L;  // One script environment instance per user at this time, map the user's email address to the instance static Map<String, ActorRef> instances = new HashMap<String, ActorRef>();  static ActorRef breadboardController = Akka.system().actorOf(new Props(Breadboard.class));  static ThrottledWebSocketOut out;  public static void connect(final WebSocket.In<JsonNode> in, final WebSocket.Out<JsonNode> wsout) { out = new ThrottledWebSocketOut(wsout, WEBSOCKET_RATE); in.onMessage(new Callback<JsonNode>() { public void invoke(JsonNode event) { try { <FILL_ME> ObjectMapper mapper = new ObjectMapper(); // TODO: check if there is a better way to do this with new version of Jackson Map<String, Object> jsonInput = mapper.readValue(event.toString(), Map.class); String action = jsonInput.get(""action"").toString(); String uid = jsonInput.get(""uid"").toString(); User user = User.findByUID(uid); ObjectNode result = Json.newObject();  if (user != null) { if (action.equals(""LogIn"")) { breadboardController.tell(new LogIn(user, out), null); } <FILL_ME> <FILL_ME> else if (action.equals(""SaveUserSettings"")) { String currentPassword = jsonInput.get(""currentPassword"").toString().trim(); String newPassword = jsonInput.get(""newPassword"").toString().trim(); String confirmPassword = jsonInput.get(""confirmPassword"").toString().trim();  breadboardController.tell(new SaveUserSettings(user, currentPassword, newPassword, confirmPassword, out), null);  } else if (action.equals(""SelectExperiment"")) { Long experimentId = Long.parseLong(jsonInput.get(""experimentId"").toString()); Experiment experiment = Experiment.findById(experimentId);  if (experiment != null)
                breadboardController.tell(new SelectExperiment(user, experiment, out), null); } else if (action.equals(""CreateExperiment"")) { String name = jsonInput.get(""name"").toString(); String copyExperimentName = jsonInput.containsKey(""copyExperimentName"") ? jsonInput.get(""copyExperimentName"").toString() : null; breadboardController.tell(new CreateExperiment(user, name, copyExperimentName, out), null); <FILL_ME> } else if (action.equals(""ImportExperiment"")) { String importFrom = jsonInput.get(""importFrom"").toString(); String importTo = jsonInput.get(""importTo"").toString(); breadboardController.tell(new ImportExperiment(user, importFrom, importTo, out), null); <FILL_ME> } else if (action.equals(""DeleteExperiment"")) { String selectedExperimentName = jsonInput.get(""selectedExperiment"").toString(); instances.get(user.email).tell(new DeleteExperiment(user, selectedExperimentName, out), null); } else if (action.equals(""ExportExperiment"")) { String selectedExperimentName = jsonInput.get(""selectedExperiment"").toString(); Experiment experiment = user.getExperimentByName(selectedExperimentName); if (experiment != null) { ObjectNode jsonOutput = Json.newObject(); try { experiment.export(); jsonOutput.put(""output"", ""Experiment exported.""); } catch (IOException ioe) { jsonOutput.put(""output"", ""Export failed.""); <FILL_ME> } out.write(jsonOutput); } } else if (action.equals(""SubmitAMTTask"")) { <FILL_ME> // The submission to AMT is handled by the AMTAdmin createHIT route // This action handles setting the startAt global variable // and setting the timer to start initStep try { Integer lifetimeInSeconds = new Integer(jsonInput.get(""lifetimeInSeconds"").toString()); Integer tutorialTime = new Integer(jsonInput.get(""tutorialTime"").toString());  breadboardController.tell(new SubmitAMTTask(user, lifetimeInSeconds, tutorialTime,  out), null); } catch (NumberFormatException nfe) { <FILL_ME> <FILL_ME> <FILL_ME> } catch (Exception e) { <FILL_ME> e.printStackTrace(); } } else if (action.equals(""RunGame"")) { if (instances.containsKey(user.email)) { instances.get(user.email).tell(new RunGame(user, out), null); } } else if (action.equals(""SendScript"")) { if (instances.containsKey(user.email)) { String script = jsonInput.get(""script"").toString(); instances.get(user.email).tell(new SendScript(user, script, out), null); } } else if (action.equals(""AddLanguage"")) { Long experimentId = Long.parseLong(jsonInput.get(""experimentId"").toString()); String languageCode = jsonInput.get(""code"").toString(); breadboardController.tell(new AddLanguage(user, experimentId, languageCode, out), null); } else if (action.equals(""MakeChoice"")) { // TODO: Player client will not be logged in with email and will // need a different way to identify the correct game if (instances.containsKey(user.email)) { String choiceUID = jsonInput.get(""choiceUID"").toString(); String params = (jsonInput.containsKey(""params"")) ? jsonInput.get(""params"").toString() : null; instances.get(user.email).tell(new MakeChoice(user, choiceUID, params, out), null); } } else if (action.equals(""SaveStyle"")) { String style = jsonInput.get(""style"").toString(); breadboardController.tell(new SaveStyle(user, style, out), null); } else if (action.equals(""SaveClientHtml"")) { String clientHtml = jsonInput.get(""clientHtml"").toString(); breadboardController.tell(new SaveClientHtml(user, clientHtml, out), null); } else if (action.equals(""SaveClientGraph"")) { String clientGraph = jsonInput.get(""clientGraph"").toString(); breadboardController.tell(new SaveClientGraph(user, clientGraph, out), null); } else if (action.equals(""CreateStep"")) { String name = jsonInput.get(""name"").toString(); breadboardController.tell(new CreateStep(user, name, out), null); } else if (action.equals(""DeleteStep"")) { Long id = Long.valueOf(jsonInput.get(""id"").toString()); breadboardController.tell(new DeleteStep(user, id, out), null); } else if (action.equals(""SendStep"")) { if (instances.containsKey(user.email)) { try { Long id = Long.parseLong(jsonInput.get(""id"").toString()); String name = jsonInput.get(""name"").toString(); String source = jsonInput.get(""source"").toString(); // TODO: is providing the name necessary? instances.get(user.email).tell(new SendStep(user, id, name, source, out), null); } catch (NumberFormatException nfe) { } } } else if (action.equals(""LaunchGame"")) { if (instances.containsKey(user.email)) { String name = jsonInput.get(""name"").toString(); Object parameters = jsonInput.get(""parameters""); <FILL_ME> if (parameters instanceof LinkedHashMap) { LinkedHashMap params = (LinkedHashMap) parameters; instances.get(user.email).tell(new LaunchGame(user, name, params, out), null); } } } else if (action.equals(""StopGame"")) { if (instances.containsKey(user.email)) { try { Long id = Long.parseLong(jsonInput.get(""id"").toString()); instances.get(user.email).tell(new StopGame(user, id, out), null); } catch (NumberFormatException nfe) { } } } else if (action.equals(""NewParameter"")) { String name = jsonInput.get(""name"").toString(); String type = jsonInput.get(""type"").toString(); String minVal = (jsonInput.get(""minVal"") == null) ? """" : jsonInput.get(""minVal"").toString(); String maxVal = (jsonInput.get(""maxVal"") == null) ? """" : jsonInput.get(""maxVal"").toString(); String defaultVal = jsonInput.get(""defaultVal"").toString(); String description = jsonInput.get(""description"").toString();  breadboardController.tell(new NewParameter(user, name, type, minVal, maxVal, defaultVal, description, out), null); } else if (action.equals(""RemoveParameter"")) { String id = jsonInput.get(""id"").toString();  breadboardController.tell(new RemoveParameter(user, id, out), null); } else if (action.equals(""SelectInstance"")) { Long id = Long.parseLong(jsonInput.get(""id"").toString());  breadboardController.tell(new SelectInstance(user, id, out), null); } else if (action.equals(""Update"")) { breadboardController.tell(new Update(user, out), null); } else if (action.equals(""ShowEvent"")) { Long experimentInstanceId = Long.parseLong(jsonInput.get(""id"").toString()); breadboardController.tell(new ShowEvent(user, experimentInstanceId, out), null); } else if (action.equals(""DeleteInstance"")) { Long experimentInstanceId = Long.parseLong(jsonInput.get(""id"").toString()); breadboardController.tell(new DeleteInstance(user, experimentInstanceId, out), null); } else if (action.equals(""ReloadEngine"")) { instances.get(user.email).tell(new ReloadEngine(user, out), null); } else if (action.equals(""DeleteImage"")) { Long imageId = Long.parseLong(jsonInput.get(""imageId"").toString()); breadboardController.tell(new DeleteImage(user, imageId, out), null); } else if (action.equals(""ToggleFileMode"")) { breadboardController.tell(new ToggleFileMode(user, out), null); } } else { <FILL_ME> <FILL_ME> // END if (user != null) } } catch (java.io.IOException ioe) { <FILL_ME> } } } ); }  public void onReceive(Object message) throws Exception { if (message instanceof BreadboardMessage) { BreadboardMessage breadboardMessage = (BreadboardMessage) message; <FILL_ME>  if (message instanceof LogIn) { if (!instances.containsKey(breadboardMessage.user.email)) { <FILL_ME> // No running instance, start one // TODO: Allow multiple instances per user? // TODO: Allow starting and stopping of individual instances ActorRef scriptBoardController = Akka.system().actorOf(new Props(ScriptBoard.class)); <FILL_ME> /*  Another way to declare the scriptBoardController if we need a non-default constructor
                    ActorRef scriptBoardController = Akka.system().actorOf(new Props(new UntypedActorFactory() {
                        public UntypedActor create() {
                            return new ScriptBoard();
                        }
                    }), ""scriptBoardController"");
                    */ instances.put(breadboardMessage.user.email, scriptBoardController);  // Add an Admin to the scriptBoardController scriptBoardController.tell(new AddAdmin(breadboardMessage.user, scriptBoardController, breadboardMessage.out), null);  // If the User has a selected experiment, select the experiment if (breadboardMessage.user.selectedExperiment != null) { <FILL_ME> breadboardController.tell(new SelectExperiment(breadboardMessage.user, breadboardMessage.user.selectedExperiment, breadboardMessage.out), null); } if (breadboardMessage.user.experimentInstanceId != -1) { breadboardController.tell(new SelectInstance(breadboardMessage.user, breadboardMessage.user.experimentInstanceId, breadboardMessage.out), null); } } else { //this is reconnect/refresh ObjectNode userJson = breadboardMessage.user.toJson(); //Logger.debug(""breadboardMessage.out.write(breadboardMessage.user.toJson()); "" + userJson); breadboardMessage.out.write(userJson); <FILL_ME>  instances.get(breadboardMessage.user.email).tell(new Refresh(breadboardMessage.user, breadboardMessage.out), null); return; } } else if (message instanceof SaveUserSettings) { SaveUserSettings saveUserSettings = (SaveUserSettings) message;  //TODO: better validation like regex? List<String> errors = new ArrayList<String>(); if (StringUtils.isEmpty(saveUserSettings.currentPassword)) { errors.add(""'Current Password' is required""); } if (!saveUserSettings.currentPassword.equals(saveUserSettings.user.password)) { errors.add(""'Current Password' doesn't match the current password""); } if (StringUtils.isEmpty(saveUserSettings.newPassword)) { errors.add(""'New Password' is required""); } if (!saveUserSettings.confirmPassword.equals(saveUserSettings.newPassword)) { errors.add(""'Confirm Password' doesn't match the new password""); }  saveUserSettings.user.password = saveUserSettings.newPassword; saveUserSettings.user.update();  } else if (message instanceof SelectExperiment) { // TODO: Clear the working memory of the ScriptEngine SelectExperiment selectExperiment = (SelectExperiment) message; <FILL_ME>  breadboardMessage.user.setSelectedExperiment(selectExperiment.experiment); breadboardMessage.user.update();  // If there are steps associated with this experiment, load them Experiment selectedExperiment = breadboardMessage.user.getExperiment(); if (selectedExperiment != null) { <FILL_ME> <FILL_ME> <FILL_ME> // TODO: Create ""ChangeExperiment"" action and handle it in ScriptBoard // Find Content based on currently selected Experiment instances.get(breadboardMessage.user.email).tell(new ChangeExperiment(breadboardMessage.user, selectedExperiment, breadboardMessage.out), null); //move the load steps into scriptboard //                    for (Step step : selectedExperiment.steps) //                        instances.get(breadboardMessage.user.email).tell(new RunStep(breadboardMessage.user, step.source, breadboardMessage.out)); } } else if (message instanceof CreateExperiment) { <FILL_ME> } else if (message instanceof ImportExperiment) { <FILL_ME> } else if (message instanceof SubmitAMTTask) { SubmitAMTTask submitAMTTask = (SubmitAMTTask) message; Integer lifetimeInSeconds = submitAMTTask.lifetimeInSeconds; Integer tutorialTime = submitAMTTask.tutorialTime;  instances.get(breadboardMessage.user.email).tell(new HitCreated(breadboardMessage.user, lifetimeInSeconds, tutorialTime, breadboardMessage.out), null);  // Send 'initStep will automatically start' message to Output ObjectNode jsonOutput = Json.newObject(); Double totalSeconds = (double)(lifetimeInSeconds + tutorialTime); Double minutes = Math.floor(totalSeconds / 60); Double seconds = totalSeconds - (minutes * 60); jsonOutput.put(""output"", ""AMT HIT created, initStep will automatically start in "" + minutes.toString() + "" minutes and "" + seconds.toString() + "" seconds.""); breadboardMessage.out.write(jsonOutput);  } else if (message instanceof AddLanguage) { AddLanguage addLanguage = (AddLanguage) message; Language language = Language.find.where().eq(""code"", addLanguage.languageCode).findUnique(); if (language == null) { // New language, create it language = new Language(); language.code = addLanguage.languageCode; language.name = new Locale(addLanguage.languageCode).getDisplayLanguage(); } // Add the language to the currently selected Experiment, if it doesn't already exist Experiment selectedExperiment = Experiment.findById(addLanguage.experimentId); boolean hasLanguage = false; for (Language l : selectedExperiment.languages) { if (l.id.equals(language.id)) { hasLanguage = true; } } if (!hasLanguage) { selectedExperiment.languages.add(language); selectedExperiment.save(); } instances.get(breadboardMessage.user.email).tell(message, null); } else if (message instanceof CreateStep) { CreateStep createStep = (CreateStep) message; <FILL_ME> Experiment selectedExperiment = breadboardMessage.user.getExperiment(); if (selectedExperiment != null) { Step newStep = new Step(); newStep.name = createStep.name; String nameVariableName = WordUtils.uncapitalize(newStep.name.replaceAll(""[^a-zA-Z0-9\\s]"", """")); newStep.source = nameVariableName + "" = stepFactory.createStep()\n\n"" +
              nameVariableName + "".run = { \n"" +
              ""\tprintln \"""" + nameVariableName + "".run\""\n"" +
              ""} \n\n"" +
              nameVariableName + "".done = { \n"" +
              ""\tprintln \"""" + nameVariableName + "".done\""\n"" +
              ""} \n"";  selectedExperiment.addStep(newStep); selectedExperiment.save(); } } else if (message instanceof DeleteStep) { DeleteStep deleteStep = (DeleteStep) message; Step step = Step.find.byId(deleteStep.id); step.delete(); } else if (message instanceof SaveStyle) { SaveStyle saveStyle = (SaveStyle) message; Experiment selectedExperiment = breadboardMessage.user.getExperiment(); if (selectedExperiment != null) { selectedExperiment.setStyle(saveStyle.style); selectedExperiment.update(); // Send ""Style saved"" message to output ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""output"", ""Style saved.""); breadboardMessage.out.write(jsonOutput); } } else if (message instanceof SaveClientHtml) { SaveClientHtml saveClientHtml = (SaveClientHtml) message; Experiment selectedExperiment = breadboardMessage.user.getExperiment(); if (selectedExperiment != null) { selectedExperiment.setClientHtml(saveClientHtml.clientHtml); selectedExperiment.update(); ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""output"", ""Client HTML saved.""); breadboardMessage.out.write(jsonOutput); // TODO: Consider pushing update to all clients here, to prevent need for browser refresh. } } else if (message instanceof SaveClientGraph) { SaveClientGraph saveClientGraph = (SaveClientGraph) message; Experiment selectedExperiment = breadboardMessage.user.getExperiment(); if (selectedExperiment != null) { selectedExperiment.setClientGraph(saveClientGraph.clientGraph); selectedExperiment.update(); ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""output"", ""Client Graph saved.""); breadboardMessage.out.write(jsonOutput); // TODO: Consider pushing update to all clients here, to prevent need for browser refresh. } } else if (message instanceof NewParameter) { NewParameter newParameter = (NewParameter) message;  Experiment selectedExperiment = breadboardMessage.user.getExperiment();  if (selectedExperiment != null) { Parameter parameter = new Parameter(); parameter.name = newParameter.name; parameter.type = newParameter.type; parameter.minVal = (parameter.type.equals(""Text"") || parameter.type.equals(""Boolean"")) ? """" : newParameter.minVal; parameter.maxVal = (parameter.type.equals(""Text"") || parameter.type.equals(""Boolean"")) ? """" : newParameter.maxVal; parameter.defaultVal = newParameter.defaultVal; parameter.description = newParameter.description;  selectedExperiment.parameters.add(parameter); selectedExperiment.save(); } } else if (message instanceof RemoveParameter) { RemoveParameter removeParameter = (RemoveParameter) message;  Experiment selectedExperiment = breadboardMessage.user.getExperiment();  if (selectedExperiment != null) { Parameter parameter = Parameter.find.byId(removeParameter.id); if (parameter != null) { selectedExperiment.parameters.remove(parameter); selectedExperiment.update(); parameter.delete(); } } } else if (message instanceof SelectInstance) { instances.get(breadboardMessage.user.email).tell(message, null); } else if (message instanceof Update) { //Do nothing, just update the user JSON object } else if (message instanceof ShowEvent) { ShowEvent showEvent = (ShowEvent) message; Long experimentInstanceId = showEvent.experimentInstanceId; ExperimentInstance experimentInstance = ExperimentInstance.findById(experimentInstanceId); List<Event> events = experimentInstance.events; Collections.sort(events, new Comparator<Event>() { @Override
          public int compare(Event o1, Event o2) { return o1.datetime.compareTo(o2.datetime); } } );  ObjectNode eventNode = Json.newObject(); eventNode.put(""eventExperimentInstance"", experimentInstance.name); ArrayNode arrayNode = eventNode.putArray(""events"");  for (Event event : events) { List<EventData> eventDatas = event.eventData; ObjectNode objectNode = Json.newObject(); objectNode.put(""id"", event.id); objectNode.put(""name"", event.name); objectNode.put(""datetime"", new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss,S"").format(event.datetime)); ArrayNode dataNodes = objectNode.putArray(""data""); for (EventData eventData : eventDatas) { ObjectNode dataNode = Json.newObject(); dataNode.put(""id"", eventData.id); dataNode.put(""name"", eventData.name); dataNode.put(""value"", eventData.value); dataNodes.add(dataNode); } arrayNode.add(objectNode); } "" + eventNode); breadboardMessage.out.write(eventNode); return; } else if (message instanceof DeleteInstance) { DeleteInstance deleteInstance = (DeleteInstance) message; Long experimentInstanceId = deleteInstance.experimentInstanceId; ExperimentInstance experimentInstance = ExperimentInstance.findById(experimentInstanceId); //only finished and stopped instance can be deleted if (experimentInstance.status == ExperimentInstance.Status.FINISHED || experimentInstance.status == ExperimentInstance.Status.STOPPED) { experimentInstance.delete(); } } else if (message instanceof DeleteImage) { DeleteImage deleteImage = (DeleteImage) message; Long imageId = deleteImage.imageId; Image.findById(imageId).delete(); } else if (message instanceof ToggleFileMode) { Experiment selectedExperiment = breadboardMessage.user.getExperiment(); if (selectedExperiment != null) { selectedExperiment.toggleFileMode(breadboardMessage.user); } }  breadboardMessage.out.write(breadboardMessage.user.toJson());  } // END if(message instanceof BreadboardMessage) }  public static abstract class BreadboardMessage { final User user; final ThrottledWebSocketOut out;  public BreadboardMessage(User user, ThrottledWebSocketOut out) { this.user = user; this.out = out; } }  public static class LogIn extends BreadboardMessage { public LogIn(User user, ThrottledWebSocketOut out) { super(user, out); } }  public static class Refresh extends BreadboardMessage { public Refresh(User user, ThrottledWebSocketOut out) { super(user, out); } }  public static class Update extends BreadboardMessage { public Update(User user, ThrottledWebSocketOut out) { super(user, out); } }  public static class SaveUserSettings extends BreadboardMessage {  final String currentPassword; final String newPassword; final String confirmPassword;  public SaveUserSettings(User user, String currentPassword, String newPassword, String confirmPassword, ThrottledWebSocketOut out) { super(user, out); this.currentPassword = currentPassword; this.newPassword = newPassword; this.confirmPassword = confirmPassword; } }  public static class SelectExperiment extends BreadboardMessage { final Experiment experiment;  public SelectExperiment(User user, Experiment experiment, ThrottledWebSocketOut out) { super(user, out); this.experiment = experiment; } }  public static class DeleteExperiment extends BreadboardMessage { final String experimentName;  public DeleteExperiment(User user, String experimentName, ThrottledWebSocketOut out) { super(user, out); this.experimentName = experimentName; } }  public static class ExportExperiment extends BreadboardMessage { final String experimentName;  public ExportExperiment(User user, String experimentName, ThrottledWebSocketOut out) { super(user, out); this.experimentName = experimentName; } }  public static class ChangeExperiment extends BreadboardMessage { final Experiment experiment;  public ChangeExperiment(User user, Experiment experiment, ThrottledWebSocketOut out) { super(user, out); this.experiment = experiment; } }  public static class CreateExperiment extends BreadboardMessage { final String name; final String copyExperimentName;  public CreateExperiment(User user, String name, String copyExperimentName, ThrottledWebSocketOut out) { super(user, out); this.name = name; this.copyExperimentName = copyExperimentName; } }  public static class ImportExperiment extends BreadboardMessage { final String importFrom; final String importTo;  public ImportExperiment(User user, String importFrom, String importTo, ThrottledWebSocketOut out) { super(user, out); this.importFrom = importFrom; this.importTo = importTo; } }  public static class SubmitAMTTask extends BreadboardMessage { final Integer lifetimeInSeconds; final Integer tutorialTime;  public SubmitAMTTask(User user, Integer lifetimeInSeconds, Integer tutorialTime, ThrottledWebSocketOut out) { super(user, out); this.lifetimeInSeconds = lifetimeInSeconds; this.tutorialTime = tutorialTime; } }  public static class HitCreated extends BreadboardMessage { final Integer lifetimeInSeconds; final Integer tutorialTime;  public HitCreated(User user, Integer lifetimeInSeconds, Integer tutorialTime, ThrottledWebSocketOut out) { super(user, out); this.lifetimeInSeconds = lifetimeInSeconds; this.tutorialTime = tutorialTime; } }  public static class AddLanguage extends BreadboardMessage { final Long experimentId; final String languageCode;  public AddLanguage(User user, Long experimentId, String languageCode, ThrottledWebSocketOut out) { super(user, out); this.experimentId = experimentId; this.languageCode = languageCode; } }  public static class CreateStep extends BreadboardMessage { final String name;  public CreateStep(User user, String name, ThrottledWebSocketOut out) { super(user, out); this.name = name; } }  public static class DeleteStep extends BreadboardMessage { final Long id;  public DeleteStep(User user, Long id, ThrottledWebSocketOut out) { super(user, out); this.id = id; } }  public static class SaveStyle extends BreadboardMessage { final String style;  public SaveStyle(User user, String style, ThrottledWebSocketOut out) { super(user, out); this.style = style; } }  public static class SaveClientHtml extends BreadboardMessage { final String clientHtml;  public SaveClientHtml(User user, String clientHtml, ThrottledWebSocketOut out) { super(user, out); this.clientHtml = clientHtml; } }  public static class SaveClientGraph extends BreadboardMessage { final String clientGraph;  public SaveClientGraph(User user, String clientGraph, ThrottledWebSocketOut out) { super(user, out); this.clientGraph = clientGraph; } }  public static class RunGame extends BreadboardMessage { public RunGame(User user, ThrottledWebSocketOut out) { super(user, out); } }  public static class SendScript extends BreadboardMessage { final String script;  public SendScript(User user, String script, ThrottledWebSocketOut out) { super(user, out); this.script = script; } }  public static class SendStep extends BreadboardMessage { final Long id; final String name; final String source;  public SendStep(User user, Long id, String name, String source, ThrottledWebSocketOut out) { super(user, out); this.id = id; this.name = name; this.source = source; } }  public static class RunStep extends BreadboardMessage { final String source;  public RunStep(User user, String source, ThrottledWebSocketOut out) { super(user, out); this.source = source; } }  public static class MakeChoice extends BreadboardMessage { final String uid; final String params;  public MakeChoice(User user, String uid, String params, ThrottledWebSocketOut out) { super(user, out); this.uid = uid; this.params = params; } }  public static class LaunchGame extends BreadboardMessage { final String name; final LinkedHashMap parameters;  public LaunchGame(User user, String name, LinkedHashMap parameters, ThrottledWebSocketOut out) { super(user, out); this.name = name; this.parameters = parameters; } }  public static class StopGame extends BreadboardMessage { final Long id;  public StopGame(User user, Long id, ThrottledWebSocketOut out) { super(user, out); this.id = id; } }  public static class NewParameter extends BreadboardMessage { final String name; final String type; final String minVal; final String maxVal; final String defaultVal; final String description;  public NewParameter(User user, String name, String type, String minVal, String maxVal, String defaultVal, String description, ThrottledWebSocketOut out) { super(user, out); this.name = name; this.type = type; this.minVal = minVal; this.maxVal = maxVal; this.defaultVal = defaultVal; this.description = description; } }  public static class RemoveParameter extends BreadboardMessage { final String id;  public RemoveParameter(User user, String id, ThrottledWebSocketOut out) { super(user, out); this.id = id; } }  public static class SelectInstance extends BreadboardMessage { final Long id;  public SelectInstance(User user, Long id, ThrottledWebSocketOut out) { super(user, out); this.id = id; } }  public static class AddAdmin extends BreadboardMessage { final ActorRef scriptBoardController;  public AddAdmin(User user, ActorRef scriptBoardController, ThrottledWebSocketOut out) { super(user, out); this.scriptBoardController = scriptBoardController; } }  public static class RunOnJoinStep extends BreadboardMessage { final Vertex vertex;  public RunOnJoinStep(User user, Vertex vertex, ThrottledWebSocketOut out) { super(user, out); this.vertex = vertex; } }  public static class RunOnLeaveStep extends BreadboardMessage { final Vertex vertex;  public RunOnLeaveStep(User user, Vertex vertex, ThrottledWebSocketOut out) { super(user, out); this.vertex = vertex; } }  public static class ShowEvent extends BreadboardMessage { final Long experimentInstanceId;  public ShowEvent(User user, Long experimentInstanceId, ThrottledWebSocketOut out) { super(user, out); this.experimentInstanceId = experimentInstanceId; } }  public static class GameFinish extends BreadboardMessage { public GameFinish(User user, ThrottledWebSocketOut out) { super(user, out); } }  public static class DeleteInstance extends BreadboardMessage {  final Long experimentInstanceId;  public DeleteInstance(User user, Long experimentInstanceId, ThrottledWebSocketOut out) { super(user, out); this.experimentInstanceId = experimentInstanceId; } }  public static class ReloadEngine extends BreadboardMessage { public ReloadEngine(User user, ThrottledWebSocketOut out) { super(user, out); } }  public static class ToggleFileMode extends BreadboardMessage { public ToggleFileMode(User user, ThrottledWebSocketOut out) { super(user, out); } }  public static class DeleteImage extends BreadboardMessage { final Long imageId;  public DeleteImage(User user, Long imageId, ThrottledWebSocketOut out) { super(user, out); this.imageId = imageId; } }  }  "
app/models/BreadboardGraph.java,"package models;

import com.tinkerpop.blueprints.*;
import com.tinkerpop.blueprints.impls.tg.TinkerGraph;

public class BreadboardGraph implements Graph {
  // The underlying graph structure, may be changed to Neo4J or other later on
  private TinkerGraph graph = new TinkerGraph();

  // Keeps track of the current revision number
  private Long revision = 0L;

  public Edge addEdge(Object id, Vertex outVertex, Vertex inVertex, String label) {
    return graph.addEdge(id, outVertex, inVertex, label);
  }

  public Vertex addVertex(Object id) {
    return graph.addVertex(id);
  }

  public Edge getEdge(Object id) {
    return graph.getEdge(id);
  }

  public Iterable<Edge> getEdges() {
    return graph.getEdges();
  }

  public Iterable<Edge> getEdges(String key, Object value) {
    return graph.getEdges(key, value);
  }

  public Features getFeatures() {
    return graph.getFeatures();
  }

  public Vertex getVertex(Object id) {
    return graph.getVertex(id);
  }

  public Iterable<Vertex> getVertices() {
    return graph.getVertices();
  }

  public Iterable<Vertex> getVertices(String key, Object value) {
    return graph.getVertices(key, value);
  }

  public void removeEdge(Edge edge) {
    graph.removeEdge(edge);
  }

  public void removeVertex(Vertex vertex) {
    graph.removeVertex(vertex);
  }

  public void shutdown() {
    graph.shutdown();
  }

  public GraphQuery query() {
    return graph.query();
  }
}
","package models; public class BreadboardGraph implements Graph { private TinkerGraph graph = new TinkerGraph(); private Long revision = 0L; public Edge addEdge(Object id, Vertex outVertex, Vertex inVertex, String label) { return graph.addEdge(id, outVertex, inVertex, label); } public Vertex addVertex(Object id) { return graph.addVertex(id); } public Edge getEdge(Object id) { return graph.getEdge(id); } public Iterable<Edge> getEdges() { return graph.getEdges(); } public Iterable<Edge> getEdges(String key, Object value) { return graph.getEdges(key, value); } public Features getFeatures() { return graph.getFeatures(); } public Vertex getVertex(Object id) { return graph.getVertex(id); } public Iterable<Vertex> getVertices() { return graph.getVertices(); } public Iterable<Vertex> getVertices(String key, Object value) { return graph.getVertices(key, value); } public void removeEdge(Edge edge) { graph.removeEdge(edge); } public void removeVertex(Vertex vertex) { graph.removeVertex(vertex); } public void shutdown() { graph.shutdown(); } public GraphQuery query() { return graph.query(); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; public class BreadboardGraph implements Graph { private TinkerGraph graph = new TinkerGraph(); private Long revision = 0L; public Edge addEdge(Object id, Vertex outVertex, Vertex inVertex, String label) { return graph.addEdge(id, outVertex, inVertex, label); } public Vertex addVertex(Object id) { return graph.addVertex(id); } public Edge getEdge(Object id) { return graph.getEdge(id); } public Iterable<Edge> getEdges() { return graph.getEdges(); } public Iterable<Edge> getEdges(String key, Object value) { return graph.getEdges(key, value); } public Features getFeatures() { return graph.getFeatures(); } public Vertex getVertex(Object id) { return graph.getVertex(id); } public Iterable<Vertex> getVertices() { return graph.getVertices(); } public Iterable<Vertex> getVertices(String key, Object value) { return graph.getVertices(key, value); } public void removeEdge(Edge edge) { graph.removeEdge(edge); } public void removeVertex(Vertex vertex) { graph.removeVertex(vertex); } public void shutdown() { graph.shutdown(); } public GraphQuery query() { return graph.query(); } } ","package models; 
import com.tinkerpop.blueprints.*; import com.tinkerpop.blueprints.impls.tg.TinkerGraph;  public class BreadboardGraph implements Graph { // The underlying graph structure, may be changed to Neo4J or other later on private TinkerGraph graph = new TinkerGraph();  // Keeps track of the current revision number private Long revision = 0L;  public Edge addEdge(Object id, Vertex outVertex, Vertex inVertex, String label) { return graph.addEdge(id, outVertex, inVertex, label); }  public Vertex addVertex(Object id) { return graph.addVertex(id); }  public Edge getEdge(Object id) { return graph.getEdge(id); }  public Iterable<Edge> getEdges() { return graph.getEdges(); }  public Iterable<Edge> getEdges(String key, Object value) { return graph.getEdges(key, value); }  public Features getFeatures() { return graph.getFeatures(); }  public Vertex getVertex(Object id) { return graph.getVertex(id); }  public Iterable<Vertex> getVertices() { return graph.getVertices(); }  public Iterable<Vertex> getVertices(String key, Object value) { return graph.getVertices(key, value); }  public void removeEdge(Edge edge) { graph.removeEdge(edge); }  public void removeVertex(Vertex vertex) { graph.removeVertex(vertex); }  public void shutdown() { graph.shutdown(); }  public GraphQuery query() { return graph.query(); } }  "
app/models/BreadboardGraphChangedListener.java,"package models;

import com.tinkerpop.blueprints.Graph;
import com.tinkerpop.blueprints.util.wrappers.event.listener.GraphChangedListener;

import java.util.ArrayList;

public interface BreadboardGraphChangedListener extends GraphChangedListener {
  void setGraph(Graph g);
  void addAdminListener(ClientListener a);
  void addClientListener(Client c);
  ArrayList<ClientListener> getAdminListeners();
}
",package models; public interface BreadboardGraphChangedListener extends GraphChangedListener { void setGraph(Graph g); void addAdminListener(ClientListener a); void addClientListener(Client c); ArrayList<ClientListener> getAdminListeners(); },0 0 0 0 0 0 0 0,package models; public interface BreadboardGraphChangedListener extends GraphChangedListener { void setGraph(Graph g); void addAdminListener(ClientListener a); void addClientListener(Client c); ArrayList<ClientListener> getAdminListeners(); } ,"package models; 
import com.tinkerpop.blueprints.Graph; import com.tinkerpop.blueprints.util.wrappers.event.listener.GraphChangedListener; 
import java.util.ArrayList;  public interface BreadboardGraphChangedListener extends GraphChangedListener { void setGraph(Graph g); void addAdminListener(ClientListener a); void addClientListener(Client c); ArrayList<ClientListener> getAdminListeners(); }  "
app/models/BreadboardGraphInterface.java,"package models;

import com.tinkerpop.blueprints.util.wrappers.event.listener.GraphChangedListener;

public interface BreadboardGraphInterface {
  void addListener(GraphChangedListener listener);

  void addPlayer(String id);

  void removePlayer(String id);
}
",package models; public interface BreadboardGraphInterface { void addListener(GraphChangedListener listener); void addPlayer(String id); void removePlayer(String id); },0 0 0 0 0 0 0,package models; public interface BreadboardGraphInterface { void addListener(GraphChangedListener listener); void addPlayer(String id); void removePlayer(String id); } ,"package models; 
import com.tinkerpop.blueprints.util.wrappers.event.listener.GraphChangedListener;  public interface BreadboardGraphInterface { void addListener(GraphChangedListener listener);  void addPlayer(String id);  void removePlayer(String id); }  "
app/models/Client.java,"package models;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.tinkerpop.blueprints.Direction;
import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Graph;
import com.tinkerpop.blueprints.Vertex;
import com.tinkerpop.blueprints.impls.tg.TinkerGraph;
import com.tinkerpop.blueprints.util.wrappers.event.EventGraph;
import controllers.D3Utils;
import play.Logger;
import play.db.ebean.Model;
import play.libs.Json;
import play.mvc.WebSocket;

import java.util.HashSet;
import java.util.Map;

public class Client extends Model {
  public String id;
  public WebSocket.In<JsonNode> in;
  public ThrottledWebSocketOut out;
  public ExperimentInstance experimentInstance;
  private int styleHash;

  public Client(String id, ExperimentInstance experimentInstance, WebSocket.In<JsonNode> in, ThrottledWebSocketOut out) {
    this.id = id;
    this.experimentInstance = experimentInstance;
    this.in = in;
    this.out = out;
  }

  public synchronized void updateGraph(Vertex me) {

    // Create an in-memory graph to store the sub-graph in
    TinkerGraph inMemoryGraph = new TinkerGraph();
    EventGraph subGraph = new EventGraph(inMemoryGraph);
    Vertex m = subGraph.addVertex(me.getId());

    // Private keys overwrite public properties so let's get private keys, if they exist
    HashSet<String> privateKeys = new HashSet<String>();
    if (me.getPropertyKeys().contains(""private"")) {
      if (me.getProperty(""private"") instanceof Map) {
        Map privateMap = (Map) me.getProperty(""private"");
        for (Object key : privateMap.keySet()) {
          privateKeys.add(key.toString());
          m.setProperty(key.toString(), privateMap.get(key));
        }
      }
    }

    // Add client vertex with all private properties
    for (String key : me.getPropertyKeys()) {
      if ((!key.equals(""private"")) && (!privateKeys.contains(key))) {
        if (me.getProperty(key) != null) {
          m.setProperty(key.toString(), me.getProperty(key));
        } else {
          Logger.debug(""me.getProperty(key) == null"");
        }
      }
    }

    // Get all neighbors and add them
    for (Vertex v : me.getVertices(Direction.BOTH)) {
      // If this vertex hasn't already been added
      if (subGraph.getVertex(v.getId()) == null) {
        Vertex neighbor = subGraph.addVertex(v.getId());

        for (String key : v.getPropertyKeys()) {
          // private, text, and choices are always private
          if ((!key.equals(""private"")) && (!key.equals(""text"")) && (!key.equals(""choices""))) {
            neighbor.setProperty(key.toString(), v.getProperty(key));
          }
        }
      }
    }

    // Now edges
    // IN edges, handling inProps
    for (Edge e : me.getEdges(Direction.IN, ""connected"")) {

      Vertex outVertex = subGraph.getVertex(e.getVertex(Direction.OUT).getId());
      Vertex inVertex = subGraph.getVertex(e.getVertex(Direction.IN).getId());


      if (outVertex != null && inVertex != null) {
        Edge inE = subGraph.addEdge(e.getId(), outVertex, inVertex, ""connected"");
        HashSet<String> inPropKeys = new HashSet<String>();
        if (e.getPropertyKeys().contains(""inProps"")) {
          if (e.getProperty(""inProps"") instanceof Map) {
            Map inProps = (Map) e.getProperty(""inProps"");
            for (Object key : inProps.keySet()) {
              inPropKeys.add(key.toString());
              inE.setProperty(key.toString(), inProps.get(key));
            }
          }
        }

        for (String key : e.getPropertyKeys()) {
          if ((!key.equals(""outProps"")) && (!key.equals(""inProps"")) && (!inPropKeys.contains(key))) {
            inE.setProperty(key.toString(), e.getProperty(key));
          }
        }
      }
    }

    // OUT edges, handling outProps
    for (Edge e : me.getEdges(Direction.OUT, ""connected"")) {

      Vertex outVertex = subGraph.getVertex(e.getVertex(Direction.OUT).getId());
      Vertex inVertex = subGraph.getVertex(e.getVertex(Direction.IN).getId());


      if (outVertex != null && inVertex != null) {
        Edge outE = subGraph.addEdge(e.getId(), outVertex, inVertex, ""connected"");
        HashSet<String> outPropKeys = new HashSet<String>();
        if (e.getPropertyKeys().contains(""outProps"")) {
          if (e.getProperty(""outProps"") instanceof Map) {
            Map outProps = (Map) e.getProperty(""outProps"");
            for (Object key : outProps.keySet()) {
              outPropKeys.add(key.toString());
              outE.setProperty(key.toString(), outProps.get(key));
            }
          }
        }

        for (String key : e.getPropertyKeys()) {
          if ((!key.equals(""outProps"")) && (!key.equals(""inProps"")) && (!outPropKeys.contains(key))) {
            outE.setProperty(key.toString(), e.getProperty(key));
          }
        }
      }
    }

    writeGraph(m, subGraph);
  }

  public void writeGraph(Vertex me, Graph graph) {
    ObjectNode jsonOutput = Json.newObject();

    ObjectNode jsonGraph = D3Utils.graphToJsonString(graph);
    jsonOutput.put(""graph"", jsonGraph);

    // Write client vertex properties to ""client"" object
    ObjectNode client = Json.newObject();

    for (String key : me.getPropertyKeys()) {
      client.put(key, Json.toJson(me.getProperty(key)));
    }

    jsonOutput.put(""player"", client);

    int hash = experimentInstance.experiment.getStyle().hashCode();
    if (styleHash != hash) {
      styleHash = hash;
      jsonOutput.put(""style"", experimentInstance.experiment.getStyle());
    }

    out.write(jsonOutput);
  }

  public void graphChanged(Graph wholeGraph) {
    ObjectNode jsonOutput = Json.newObject();

    ObjectNode graph = D3Utils.graphToJsonString(wholeGraph);
    jsonOutput.put(""graph"", graph);

    out.write(jsonOutput);
  }

  public void vertexAdded(Vertex vertex) {
    ObjectNode jsonOutput = Json.newObject();

    jsonOutput.put(""action"", ""addNode"");
    jsonOutput.put(""id"", vertex.getId().toString());
    out.write(jsonOutput);

    for (String key : vertex.getPropertyKeys()) {
      vertexPropertyChanged(vertex, key, vertex.getProperty(key));
    }
  }

  public void vertexRemoved(Vertex vertex) {
    ObjectNode jsonOutput = Json.newObject();

    jsonOutput.put(""action"", ""removeNode"");
    jsonOutput.put(""id"", vertex.getId().toString());

    out.write(jsonOutput);
  }

  public void vertexPropertyChanged(Vertex vertex, String key, Object setValue) {
    ObjectNode jsonOutput = Json.newObject();

    // Only send ""text"" and ""choices"" properties to the player whose text or choices is changing
    if (key.equals(""text"")) {
      if (vertex.getId().toString().equals(id)) {
        jsonOutput.put(""text"", Json.toJson(setValue));
        out.write(jsonOutput);
      }
    } else if (key.equals(""choices"")) {
      if (vertex.getId().toString().equals(id)) {
        jsonOutput.put(""choices"", Json.toJson(setValue));
        out.write(jsonOutput);
      }
    } else if (key.startsWith(""private"")) {
      // private key should be sent, without the containing private key, to vertex player only
      if (vertex.getId().toString().equals(id)) {
        String privateKey = key.substring(7);
        jsonOutput.put(""action"", ""nodePropertyChanged"");
        jsonOutput.put(""id"", vertex.getId().toString());
        jsonOutput.put(""key"", privateKey);
        jsonOutput.put(""value"", Json.toJson(setValue));
        out.write(jsonOutput);
      }
    } else {
      jsonOutput.put(""action"", ""nodePropertyChanged"");
      jsonOutput.put(""id"", vertex.getId().toString());
      jsonOutput.put(""key"", key);
      jsonOutput.put(""value"", Json.toJson(setValue));
      out.write(jsonOutput);
    }
  }

  public void vertexPropertyRemoved(Vertex vertex, String key) {
    ObjectNode jsonOutput = Json.newObject();

    jsonOutput.put(""action"", ""nodePropertyRemoved"");
    jsonOutput.put(""id"", vertex.getId().toString());
    jsonOutput.put(""key"", key);

    out.write(jsonOutput);
  }

  public void edgeAdded(Edge edge) {
    ObjectNode jsonOutput = Json.newObject();

    jsonOutput.put(""action"", ""addLink"");
    jsonOutput.put(""id"", edge.getId().toString());
    jsonOutput.put(""source"", edge.getVertex(Direction.OUT).getId().toString());
    jsonOutput.put(""target"", edge.getVertex(Direction.IN).getId().toString());
    jsonOutput.put(""value"", edge.getLabel());

    out.write(jsonOutput);
  }

  public void edgeRemoved(Edge edge) {
    ObjectNode jsonOutput = Json.newObject();

    jsonOutput.put(""action"", ""removeLink"");
    jsonOutput.put(""id"", edge.getId().toString());
    jsonOutput.put(""source"", edge.getVertex(Direction.OUT).getId().toString());
    jsonOutput.put(""target"", edge.getVertex(Direction.IN).getId().toString());

    out.write(jsonOutput);
  }

  public void edgePropertyChanged(Edge edge, String key, Object setValue) {
    ObjectNode jsonOutput = Json.newObject();

    jsonOutput.put(""action"", ""linkPropertyChanged"");
    jsonOutput.put(""id"", edge.getId().toString());
    jsonOutput.put(""key"", key);
    jsonOutput.put(""value"", setValue.toString());

    out.write(jsonOutput);
  }

  public void edgePropertyRemoved(Edge edge, String key) {
    ObjectNode jsonOutput = Json.newObject();

    jsonOutput.put(""action"", ""linkPropertyRemoved"");
    jsonOutput.put(""id"", edge.getId().toString());
    jsonOutput.put(""key"", key);

    out.write(jsonOutput);
  }

  public void send (String eventName, Object ...data) {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode json = Json.newObject();
    json.put(""eventName"", eventName);
    json.put(""data"", Json.toJson(data));
    // JsonNode json = mapper.convertValue(data, JsonNode.class);
    out.write(json);
  }

  public ObjectNode toJson() {
    ObjectNode client = Json.newObject();
    client.put(""style"", experimentInstance.experiment.getStyle());
    return client;
  }

  public void setIn(WebSocket.In<JsonNode> in) {
    this.in = in;
  }

  public void setOut(ThrottledWebSocketOut out) {
    this.out = out;
  }

  public String toString() {
    return ""Client("" + id + "")"";
  }

  public void disconnect () {
    this.out.close();
  }

}
","package models; public class Client extends Model { public String id; public WebSocket.In<JsonNode> in; public ThrottledWebSocketOut out; public ExperimentInstance experimentInstance; private int styleHash; public Client(String id, ExperimentInstance experimentInstance, WebSocket.In<JsonNode> in, ThrottledWebSocketOut out) { this.id = id; this.experimentInstance = experimentInstance; this.in = in; this.out = out; } public synchronized void updateGraph(Vertex me) { TinkerGraph inMemoryGraph = new TinkerGraph(); EventGraph subGraph = new EventGraph(inMemoryGraph); Vertex m = subGraph.addVertex(me.getId()); HashSet<String> privateKeys = new HashSet<String>(); if (me.getPropertyKeys().contains(""private"")) { if (me.getProperty(""private"") instanceof Map) { Map privateMap = (Map) me.getProperty(""private""); for (Object key : privateMap.keySet()) { privateKeys.add(key.toString()); m.setProperty(key.toString(), privateMap.get(key)); } } } for (String key : me.getPropertyKeys()) { if ((!key.equals(""private"")) && (!privateKeys.contains(key))) { if (me.getProperty(key) != null) { m.setProperty(key.toString(), me.getProperty(key)); } else { } } } for (Vertex v : me.getVertices(Direction.BOTH)) { if (subGraph.getVertex(v.getId()) == null) { Vertex neighbor = subGraph.addVertex(v.getId()); for (String key : v.getPropertyKeys()) { if ((!key.equals(""private"")) && (!key.equals(""text"")) && (!key.equals(""choices""))) { neighbor.setProperty(key.toString(), v.getProperty(key)); } } } } for (Edge e : me.getEdges(Direction.IN, ""connected"")) { Vertex outVertex = subGraph.getVertex(e.getVertex(Direction.OUT).getId()); Vertex inVertex = subGraph.getVertex(e.getVertex(Direction.IN).getId()); if (outVertex != null && inVertex != null) { Edge inE = subGraph.addEdge(e.getId(), outVertex, inVertex, ""connected""); HashSet<String> inPropKeys = new HashSet<String>(); if (e.getPropertyKeys().contains(""inProps"")) { if (e.getProperty(""inProps"") instanceof Map) { Map inProps = (Map) e.getProperty(""inProps""); for (Object key : inProps.keySet()) { inPropKeys.add(key.toString()); inE.setProperty(key.toString(), inProps.get(key)); } } } for (String key : e.getPropertyKeys()) { if ((!key.equals(""outProps"")) && (!key.equals(""inProps"")) && (!inPropKeys.contains(key))) { inE.setProperty(key.toString(), e.getProperty(key)); } } } } for (Edge e : me.getEdges(Direction.OUT, ""connected"")) { Vertex outVertex = subGraph.getVertex(e.getVertex(Direction.OUT).getId()); Vertex inVertex = subGraph.getVertex(e.getVertex(Direction.IN).getId()); if (outVertex != null && inVertex != null) { Edge outE = subGraph.addEdge(e.getId(), outVertex, inVertex, ""connected""); HashSet<String> outPropKeys = new HashSet<String>(); if (e.getPropertyKeys().contains(""outProps"")) { if (e.getProperty(""outProps"") instanceof Map) { Map outProps = (Map) e.getProperty(""outProps""); for (Object key : outProps.keySet()) { outPropKeys.add(key.toString()); outE.setProperty(key.toString(), outProps.get(key)); } } } for (String key : e.getPropertyKeys()) { if ((!key.equals(""outProps"")) && (!key.equals(""inProps"")) && (!outPropKeys.contains(key))) { outE.setProperty(key.toString(), e.getProperty(key)); } } } } writeGraph(m, subGraph); } public void writeGraph(Vertex me, Graph graph) { ObjectNode jsonOutput = Json.newObject(); ObjectNode jsonGraph = D3Utils.graphToJsonString(graph); jsonOutput.put(""graph"", jsonGraph); ObjectNode client = Json.newObject(); for (String key : me.getPropertyKeys()) { client.put(key, Json.toJson(me.getProperty(key))); } jsonOutput.put(""player"", client); int hash = experimentInstance.experiment.getStyle().hashCode(); if (styleHash != hash) { styleHash = hash; jsonOutput.put(""style"", experimentInstance.experiment.getStyle()); } out.write(jsonOutput); } public void graphChanged(Graph wholeGraph) { ObjectNode jsonOutput = Json.newObject(); ObjectNode graph = D3Utils.graphToJsonString(wholeGraph); jsonOutput.put(""graph"", graph); out.write(jsonOutput); } public void vertexAdded(Vertex vertex) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""addNode""); jsonOutput.put(""id"", vertex.getId().toString()); out.write(jsonOutput); for (String key : vertex.getPropertyKeys()) { vertexPropertyChanged(vertex, key, vertex.getProperty(key)); } } public void vertexRemoved(Vertex vertex) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""removeNode""); jsonOutput.put(""id"", vertex.getId().toString()); out.write(jsonOutput); } public void vertexPropertyChanged(Vertex vertex, String key, Object setValue) { ObjectNode jsonOutput = Json.newObject(); if (key.equals(""text"")) { if (vertex.getId().toString().equals(id)) { jsonOutput.put(""text"", Json.toJson(setValue)); out.write(jsonOutput); } } else if (key.equals(""choices"")) { if (vertex.getId().toString().equals(id)) { jsonOutput.put(""choices"", Json.toJson(setValue)); out.write(jsonOutput); } } else if (key.startsWith(""private"")) { if (vertex.getId().toString().equals(id)) { String privateKey = key.substring(7); jsonOutput.put(""action"", ""nodePropertyChanged""); jsonOutput.put(""id"", vertex.getId().toString()); jsonOutput.put(""key"", privateKey); jsonOutput.put(""value"", Json.toJson(setValue)); out.write(jsonOutput); } } else { jsonOutput.put(""action"", ""nodePropertyChanged""); jsonOutput.put(""id"", vertex.getId().toString()); jsonOutput.put(""key"", key); jsonOutput.put(""value"", Json.toJson(setValue)); out.write(jsonOutput); } } public void vertexPropertyRemoved(Vertex vertex, String key) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""nodePropertyRemoved""); jsonOutput.put(""id"", vertex.getId().toString()); jsonOutput.put(""key"", key); out.write(jsonOutput); } public void edgeAdded(Edge edge) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""addLink""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""source"", edge.getVertex(Direction.OUT).getId().toString()); jsonOutput.put(""target"", edge.getVertex(Direction.IN).getId().toString()); jsonOutput.put(""value"", edge.getLabel()); out.write(jsonOutput); } public void edgeRemoved(Edge edge) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""removeLink""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""source"", edge.getVertex(Direction.OUT).getId().toString()); jsonOutput.put(""target"", edge.getVertex(Direction.IN).getId().toString()); out.write(jsonOutput); } public void edgePropertyChanged(Edge edge, String key, Object setValue) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""linkPropertyChanged""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""key"", key); jsonOutput.put(""value"", setValue.toString()); out.write(jsonOutput); } public void edgePropertyRemoved(Edge edge, String key) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""linkPropertyRemoved""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""key"", key); out.write(jsonOutput); } public void send (String eventName, Object ...data) { ObjectMapper mapper = new ObjectMapper(); ObjectNode json = Json.newObject(); json.put(""eventName"", eventName); json.put(""data"", Json.toJson(data)); out.write(json); } public ObjectNode toJson() { ObjectNode client = Json.newObject(); client.put(""style"", experimentInstance.experiment.getStyle()); return client; } public void setIn(WebSocket.In<JsonNode> in) { this.in = in; } public void setOut(ThrottledWebSocketOut out) { this.out = out; } public String toString() { return ""Client("" + id + "")""; } public void disconnect () { this.out.close(); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; public class Client extends Model { public String id; public WebSocket.In<JsonNode> in; public ThrottledWebSocketOut out; public ExperimentInstance experimentInstance; private int styleHash; public Client(String id, ExperimentInstance experimentInstance, WebSocket.In<JsonNode> in, ThrottledWebSocketOut out) { this.id = id; this.experimentInstance = experimentInstance; this.in = in; this.out = out; } public synchronized void updateGraph(Vertex me) { TinkerGraph inMemoryGraph = new TinkerGraph(); EventGraph subGraph = new EventGraph(inMemoryGraph); Vertex m = subGraph.addVertex(me.getId()); HashSet<String> privateKeys = new HashSet<String>(); if (me.getPropertyKeys().contains(""private"")) { if (me.getProperty(""private"") instanceof Map) { Map privateMap = (Map) me.getProperty(""private""); for (Object key : privateMap.keySet()) { privateKeys.add(key.toString()); m.setProperty(key.toString(), privateMap.get(key)); } } } for (String key : me.getPropertyKeys()) { if ((!key.equals(""private"")) && (!privateKeys.contains(key))) { if (me.getProperty(key) != null) { m.setProperty(key.toString(), me.getProperty(key)); } else { <FILL_ME> } } } for (Vertex v : me.getVertices(Direction.BOTH)) { if (subGraph.getVertex(v.getId()) == null) { Vertex neighbor = subGraph.addVertex(v.getId()); for (String key : v.getPropertyKeys()) { if ((!key.equals(""private"")) && (!key.equals(""text"")) && (!key.equals(""choices""))) { neighbor.setProperty(key.toString(), v.getProperty(key)); } } } } for (Edge e : me.getEdges(Direction.IN, ""connected"")) { Vertex outVertex = subGraph.getVertex(e.getVertex(Direction.OUT).getId()); Vertex inVertex = subGraph.getVertex(e.getVertex(Direction.IN).getId()); if (outVertex != null && inVertex != null) { Edge inE = subGraph.addEdge(e.getId(), outVertex, inVertex, ""connected""); HashSet<String> inPropKeys = new HashSet<String>(); if (e.getPropertyKeys().contains(""inProps"")) { if (e.getProperty(""inProps"") instanceof Map) { Map inProps = (Map) e.getProperty(""inProps""); for (Object key : inProps.keySet()) { inPropKeys.add(key.toString()); inE.setProperty(key.toString(), inProps.get(key)); } } } for (String key : e.getPropertyKeys()) { if ((!key.equals(""outProps"")) && (!key.equals(""inProps"")) && (!inPropKeys.contains(key))) { inE.setProperty(key.toString(), e.getProperty(key)); } } } } for (Edge e : me.getEdges(Direction.OUT, ""connected"")) { Vertex outVertex = subGraph.getVertex(e.getVertex(Direction.OUT).getId()); Vertex inVertex = subGraph.getVertex(e.getVertex(Direction.IN).getId()); if (outVertex != null && inVertex != null) { Edge outE = subGraph.addEdge(e.getId(), outVertex, inVertex, ""connected""); HashSet<String> outPropKeys = new HashSet<String>(); if (e.getPropertyKeys().contains(""outProps"")) { if (e.getProperty(""outProps"") instanceof Map) { Map outProps = (Map) e.getProperty(""outProps""); for (Object key : outProps.keySet()) { outPropKeys.add(key.toString()); outE.setProperty(key.toString(), outProps.get(key)); } } } for (String key : e.getPropertyKeys()) { if ((!key.equals(""outProps"")) && (!key.equals(""inProps"")) && (!outPropKeys.contains(key))) { outE.setProperty(key.toString(), e.getProperty(key)); } } } } writeGraph(m, subGraph); } public void writeGraph(Vertex me, Graph graph) { ObjectNode jsonOutput = Json.newObject(); ObjectNode jsonGraph = D3Utils.graphToJsonString(graph); jsonOutput.put(""graph"", jsonGraph); ObjectNode client = Json.newObject(); for (String key : me.getPropertyKeys()) { client.put(key, Json.toJson(me.getProperty(key))); } jsonOutput.put(""player"", client); int hash = experimentInstance.experiment.getStyle().hashCode(); if (styleHash != hash) { styleHash = hash; jsonOutput.put(""style"", experimentInstance.experiment.getStyle()); } out.write(jsonOutput); } public void graphChanged(Graph wholeGraph) { ObjectNode jsonOutput = Json.newObject(); ObjectNode graph = D3Utils.graphToJsonString(wholeGraph); jsonOutput.put(""graph"", graph); out.write(jsonOutput); } public void vertexAdded(Vertex vertex) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""addNode""); jsonOutput.put(""id"", vertex.getId().toString()); out.write(jsonOutput); for (String key : vertex.getPropertyKeys()) { vertexPropertyChanged(vertex, key, vertex.getProperty(key)); } } public void vertexRemoved(Vertex vertex) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""removeNode""); jsonOutput.put(""id"", vertex.getId().toString()); out.write(jsonOutput); } public void vertexPropertyChanged(Vertex vertex, String key, Object setValue) { ObjectNode jsonOutput = Json.newObject(); if (key.equals(""text"")) { if (vertex.getId().toString().equals(id)) { jsonOutput.put(""text"", Json.toJson(setValue)); out.write(jsonOutput); } } else if (key.equals(""choices"")) { if (vertex.getId().toString().equals(id)) { jsonOutput.put(""choices"", Json.toJson(setValue)); out.write(jsonOutput); } } else if (key.startsWith(""private"")) { if (vertex.getId().toString().equals(id)) { String privateKey = key.substring(7); jsonOutput.put(""action"", ""nodePropertyChanged""); jsonOutput.put(""id"", vertex.getId().toString()); jsonOutput.put(""key"", privateKey); jsonOutput.put(""value"", Json.toJson(setValue)); out.write(jsonOutput); } } else { jsonOutput.put(""action"", ""nodePropertyChanged""); jsonOutput.put(""id"", vertex.getId().toString()); jsonOutput.put(""key"", key); jsonOutput.put(""value"", Json.toJson(setValue)); out.write(jsonOutput); } } public void vertexPropertyRemoved(Vertex vertex, String key) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""nodePropertyRemoved""); jsonOutput.put(""id"", vertex.getId().toString()); jsonOutput.put(""key"", key); out.write(jsonOutput); } public void edgeAdded(Edge edge) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""addLink""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""source"", edge.getVertex(Direction.OUT).getId().toString()); jsonOutput.put(""target"", edge.getVertex(Direction.IN).getId().toString()); jsonOutput.put(""value"", edge.getLabel()); out.write(jsonOutput); } public void edgeRemoved(Edge edge) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""removeLink""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""source"", edge.getVertex(Direction.OUT).getId().toString()); jsonOutput.put(""target"", edge.getVertex(Direction.IN).getId().toString()); out.write(jsonOutput); } public void edgePropertyChanged(Edge edge, String key, Object setValue) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""linkPropertyChanged""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""key"", key); jsonOutput.put(""value"", setValue.toString()); out.write(jsonOutput); } public void edgePropertyRemoved(Edge edge, String key) { ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""action"", ""linkPropertyRemoved""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""key"", key); out.write(jsonOutput); } public void send (String eventName, Object ...data) { ObjectMapper mapper = new ObjectMapper(); ObjectNode json = Json.newObject(); json.put(""eventName"", eventName); json.put(""data"", Json.toJson(data)); out.write(json); } public ObjectNode toJson() { ObjectNode client = Json.newObject(); client.put(""style"", experimentInstance.experiment.getStyle()); return client; } public void setIn(WebSocket.In<JsonNode> in) { this.in = in; } public void setOut(ThrottledWebSocketOut out) { this.out = out; } public String toString() { return ""Client("" + id + "")""; } public void disconnect () { this.out.close(); } } ","package models; 
import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.node.ObjectNode; import com.tinkerpop.blueprints.Direction; import com.tinkerpop.blueprints.Edge; import com.tinkerpop.blueprints.Graph; import com.tinkerpop.blueprints.Vertex; import com.tinkerpop.blueprints.impls.tg.TinkerGraph; import com.tinkerpop.blueprints.util.wrappers.event.EventGraph; import controllers.D3Utils; import play.Logger; import play.db.ebean.Model; import play.libs.Json; import play.mvc.WebSocket; 
import java.util.HashSet; import java.util.Map;  public class Client extends Model { public String id; public WebSocket.In<JsonNode> in; public ThrottledWebSocketOut out; public ExperimentInstance experimentInstance; private int styleHash;  public Client(String id, ExperimentInstance experimentInstance, WebSocket.In<JsonNode> in, ThrottledWebSocketOut out) { this.id = id; this.experimentInstance = experimentInstance; this.in = in; this.out = out; }  public synchronized void updateGraph(Vertex me) {  // Create an in-memory graph to store the sub-graph in TinkerGraph inMemoryGraph = new TinkerGraph(); EventGraph subGraph = new EventGraph(inMemoryGraph); Vertex m = subGraph.addVertex(me.getId());  // Private keys overwrite public properties so let's get private keys, if they exist HashSet<String> privateKeys = new HashSet<String>(); if (me.getPropertyKeys().contains(""private"")) { if (me.getProperty(""private"") instanceof Map) { Map privateMap = (Map) me.getProperty(""private""); for (Object key : privateMap.keySet()) { privateKeys.add(key.toString()); m.setProperty(key.toString(), privateMap.get(key)); } } }  // Add client vertex with all private properties for (String key : me.getPropertyKeys()) { if ((!key.equals(""private"")) && (!privateKeys.contains(key))) { if (me.getProperty(key) != null) { m.setProperty(key.toString(), me.getProperty(key)); } else { <FILL_ME> } } }  // Get all neighbors and add them for (Vertex v : me.getVertices(Direction.BOTH)) { // If this vertex hasn't already been added if (subGraph.getVertex(v.getId()) == null) { Vertex neighbor = subGraph.addVertex(v.getId());  for (String key : v.getPropertyKeys()) { // private, text, and choices are always private if ((!key.equals(""private"")) && (!key.equals(""text"")) && (!key.equals(""choices""))) { neighbor.setProperty(key.toString(), v.getProperty(key)); } } } }  // Now edges // IN edges, handling inProps for (Edge e : me.getEdges(Direction.IN, ""connected"")) {  Vertex outVertex = subGraph.getVertex(e.getVertex(Direction.OUT).getId()); Vertex inVertex = subGraph.getVertex(e.getVertex(Direction.IN).getId()); 
 if (outVertex != null && inVertex != null) { Edge inE = subGraph.addEdge(e.getId(), outVertex, inVertex, ""connected""); HashSet<String> inPropKeys = new HashSet<String>(); if (e.getPropertyKeys().contains(""inProps"")) { if (e.getProperty(""inProps"") instanceof Map) { Map inProps = (Map) e.getProperty(""inProps""); for (Object key : inProps.keySet()) { inPropKeys.add(key.toString()); inE.setProperty(key.toString(), inProps.get(key)); } } }  for (String key : e.getPropertyKeys()) { if ((!key.equals(""outProps"")) && (!key.equals(""inProps"")) && (!inPropKeys.contains(key))) { inE.setProperty(key.toString(), e.getProperty(key)); } } } }   for (Edge e : me.getEdges(Direction.OUT, ""connected"")) { // OUT edges, handling outProps Vertex outVertex = subGraph.getVertex(e.getVertex(Direction.OUT).getId()); Vertex inVertex = subGraph.getVertex(e.getVertex(Direction.IN).getId());  if (outVertex != null && inVertex != null) { Edge outE = subGraph.addEdge(e.getId(), outVertex, inVertex, ""connected""); HashSet<String> outPropKeys = new HashSet<String>(); if (e.getPropertyKeys().contains(""outProps"")) { if (e.getProperty(""outProps"") instanceof Map) { Map outProps = (Map) e.getProperty(""outProps""); for (Object key : outProps.keySet()) { outPropKeys.add(key.toString()); outE.setProperty(key.toString(), outProps.get(key)); } } } 
 for (String key : e.getPropertyKeys()) { if ((!key.equals(""outProps"")) && (!key.equals(""inProps"")) && (!outPropKeys.contains(key))) { outE.setProperty(key.toString(), e.getProperty(key)); } } } }  writeGraph(m, subGraph); }  public void writeGraph(Vertex me, Graph graph) { ObjectNode jsonOutput = Json.newObject();  ObjectNode jsonGraph = D3Utils.graphToJsonString(graph); jsonOutput.put(""graph"", jsonGraph);   ObjectNode client = Json.newObject();  for (String key : me.getPropertyKeys()) { client.put(key, Json.toJson(me.getProperty(key))); } // Write client vertex properties to ""client"" object jsonOutput.put(""player"", client);  int hash = experimentInstance.experiment.getStyle().hashCode(); if (styleHash != hash) { styleHash = hash; jsonOutput.put(""style"", experimentInstance.experiment.getStyle()); }  out.write(jsonOutput); }  public void graphChanged(Graph wholeGraph) { ObjectNode jsonOutput = Json.newObject();  ObjectNode graph = D3Utils.graphToJsonString(wholeGraph); jsonOutput.put(""graph"", graph);  out.write(jsonOutput); }  public void vertexAdded(Vertex vertex) { ObjectNode jsonOutput = Json.newObject();  jsonOutput.put(""action"", ""addNode""); jsonOutput.put(""id"", vertex.getId().toString()); out.write(jsonOutput);  for (String key : vertex.getPropertyKeys()) { vertexPropertyChanged(vertex, key, vertex.getProperty(key)); } }  public void vertexRemoved(Vertex vertex) { ObjectNode jsonOutput = Json.newObject();  jsonOutput.put(""action"", ""removeNode""); jsonOutput.put(""id"", vertex.getId().toString());  out.write(jsonOutput); }  public void vertexPropertyChanged(Vertex vertex, String key, Object setValue) { ObjectNode jsonOutput = Json.newObject();   if (key.equals(""text"")) { if (vertex.getId().toString().equals(id)) { jsonOutput.put(""text"", Json.toJson(setValue)); out.write(jsonOutput); } } else if (key.equals(""choices"")) { if (vertex.getId().toString().equals(id)) { jsonOutput.put(""choices"", Json.toJson(setValue)); out.write(jsonOutput); } } else if (key.startsWith(""private"")) {  if (vertex.getId().toString().equals(id)) { String privateKey = key.substring(7); jsonOutput.put(""action"", ""nodePropertyChanged""); jsonOutput.put(""id"", vertex.getId().toString()); jsonOutput.put(""key"", privateKey); jsonOutput.put(""value"", Json.toJson(setValue)); out.write(jsonOutput); } } else { jsonOutput.put(""action"", ""nodePropertyChanged""); jsonOutput.put(""id"", vertex.getId().toString()); jsonOutput.put(""key"", key); jsonOutput.put(""value"", Json.toJson(setValue)); out.write(jsonOutput); } } // Only send ""text"" and ""choices"" properties to the player whose text or choices is changing public void vertexPropertyRemoved(Vertex vertex, String key) { ObjectNode jsonOutput = Json.newObject(); // private key should be sent, without the containing private key, to vertex player only jsonOutput.put(""action"", ""nodePropertyRemoved""); jsonOutput.put(""id"", vertex.getId().toString()); jsonOutput.put(""key"", key);  out.write(jsonOutput); }  public void edgeAdded(Edge edge) { ObjectNode jsonOutput = Json.newObject();  jsonOutput.put(""action"", ""addLink""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""source"", edge.getVertex(Direction.OUT).getId().toString()); jsonOutput.put(""target"", edge.getVertex(Direction.IN).getId().toString()); jsonOutput.put(""value"", edge.getLabel());  out.write(jsonOutput); }  public void edgeRemoved(Edge edge) { ObjectNode jsonOutput = Json.newObject();  jsonOutput.put(""action"", ""removeLink""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""source"", edge.getVertex(Direction.OUT).getId().toString()); jsonOutput.put(""target"", edge.getVertex(Direction.IN).getId().toString());  out.write(jsonOutput); }  public void edgePropertyChanged(Edge edge, String key, Object setValue) { ObjectNode jsonOutput = Json.newObject();  jsonOutput.put(""action"", ""linkPropertyChanged""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""key"", key); jsonOutput.put(""value"", setValue.toString());  out.write(jsonOutput); }  public void edgePropertyRemoved(Edge edge, String key) { ObjectNode jsonOutput = Json.newObject();  jsonOutput.put(""action"", ""linkPropertyRemoved""); jsonOutput.put(""id"", edge.getId().toString()); jsonOutput.put(""key"", key);  out.write(jsonOutput); }  public void send (String eventName, Object ...data) { ObjectMapper mapper = new ObjectMapper(); ObjectNode json = Json.newObject(); json.put(""eventName"", eventName); json.put(""data"", Json.toJson(data));  out.write(json); }  public ObjectNode toJson() { ObjectNode client = Json.newObject(); client.put(""style"", experimentInstance.experiment.getStyle()); return client; } // JsonNode json = mapper.convertValue(data, JsonNode.class); public void setIn(WebSocket.In<JsonNode> in) { this.in = in; }  public void setOut(ThrottledWebSocketOut out) { this.out = out; }  public String toString() { return ""Client("" + id + "")""; }  public void disconnect () { this.out.close(); }  }  "
app/models/ClientListener.java,"package models;

import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Graph;
import com.tinkerpop.blueprints.Vertex;

public interface ClientListener {
  public void graphChanged(Graph wholeGraph);

  public void vertexAdded(Vertex vertex);

  public void vertexRemoved(Vertex vertex);

  public void vertexPropertyChanged(Vertex vertex, String key, Object oldValue, Object setValue);

  public void vertexPropertyRemoved(Vertex vertex, String key);

  public void edgeAdded(Edge edge);

  public void edgeRemoved(Edge edge);

  public void edgePropertyChanged(Edge edge, String key, Object setValue);

  public void edgePropertyRemoved(Edge edge, String key);
}
","package models; public interface ClientListener { public void graphChanged(Graph wholeGraph); public void vertexAdded(Vertex vertex); public void vertexRemoved(Vertex vertex); public void vertexPropertyChanged(Vertex vertex, String key, Object oldValue, Object setValue); public void vertexPropertyRemoved(Vertex vertex, String key); public void edgeAdded(Edge edge); public void edgeRemoved(Edge edge); public void edgePropertyChanged(Edge edge, String key, Object setValue); public void edgePropertyRemoved(Edge edge, String key); }",0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; public interface ClientListener { public void graphChanged(Graph wholeGraph); public void vertexAdded(Vertex vertex); public void vertexRemoved(Vertex vertex); public void vertexPropertyChanged(Vertex vertex, String key, Object oldValue, Object setValue); public void vertexPropertyRemoved(Vertex vertex, String key); public void edgeAdded(Edge edge); public void edgeRemoved(Edge edge); public void edgePropertyChanged(Edge edge, String key, Object setValue); public void edgePropertyRemoved(Edge edge, String key); } ","package models; 
import com.tinkerpop.blueprints.Edge; import com.tinkerpop.blueprints.Graph; import com.tinkerpop.blueprints.Vertex;  public interface ClientListener { public void graphChanged(Graph wholeGraph);  public void vertexAdded(Vertex vertex);  public void vertexRemoved(Vertex vertex);  public void vertexPropertyChanged(Vertex vertex, String key, Object oldValue, Object setValue);  public void vertexPropertyRemoved(Vertex vertex, String key);  public void edgeAdded(Edge edge);  public void edgeRemoved(Edge edge);  public void edgePropertyChanged(Edge edge, String key, Object setValue);  public void edgePropertyRemoved(Edge edge, String key); }  "
app/models/Content.java,"package models;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import play.data.format.Formats;
import play.data.validation.Constraints;
import play.db.ebean.Model;
import play.libs.Json;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = ""content"")
public class Content extends Model {
  @Id
  public Long id;

  @Constraints.Required
  @Formats.NonEmpty
  public String name;

  @OneToMany(mappedBy=""content"", cascade = CascadeType.ALL)
  public List<Translation> translations = new ArrayList<>();

  // Removed in v2.3.0 kept for migration purposes
  public String html;

  @JsonIgnore
  public static Model.Finder<Long, Content> find = new Model.Finder(Long.class, Content.class);

  public static List<Content> findAll() {
    return find.all();
  }

  @JsonIgnore
  public static Content findById(Long id) {
    return find.where().eq(""id"", id).findUnique();
  }

  public static Content findByName(String name) {
    return find.where().eq(""name"", name).findUnique();
  }

  public Content() {
  }

  public Content(Content c) {
    this.name = c.name;
    for (Translation t : c.translations) {
      this.translations.add(new Translation(t));
    }
  }

  public String toString() {
    return ""Content("" + name + "")"";
  }

  public ObjectNode toJson() {
    ObjectNode content = Json.newObject();
    content.put(""id"", id);
    content.put(""name"", name);
    ArrayNode jsonTranslations = content.putArray(""translations"");
    for (Translation t : translations) {
      jsonTranslations.add(t.toJson());
    }
    return content;
  }

}
","package models; @Entity
@Table(name = ""content"")
public class Content extends Model { @Id
  public Long id; @Constraints.Required
  @Formats.NonEmpty
  public String name; @OneToMany(mappedBy=""content"", cascade = CascadeType.ALL)
  public List<Translation> translations = new ArrayList<>(); public String html; @JsonIgnore
  public static Model.Finder<Long, Content> find = new Model.Finder(Long.class, Content.class); public static List<Content> findAll() { return find.all(); } @JsonIgnore
  public static Content findById(Long id) { return find.where().eq(""id"", id).findUnique(); } public static Content findByName(String name) { return find.where().eq(""name"", name).findUnique(); } public Content() { } public Content(Content c) { this.name = c.name; for (Translation t : c.translations) { this.translations.add(new Translation(t)); } } public String toString() { return ""Content("" + name + "")""; } public ObjectNode toJson() { ObjectNode content = Json.newObject(); content.put(""id"", id); content.put(""name"", name); ArrayNode jsonTranslations = content.putArray(""translations""); for (Translation t : translations) { jsonTranslations.add(t.toJson()); } return content; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; @Entity
@Table(name = ""content"")
public class Content extends Model { @Id
  public Long id; @Constraints.Required
  @Formats.NonEmpty
  public String name; @OneToMany(mappedBy=""content"", cascade = CascadeType.ALL)
  public List<Translation> translations = new ArrayList<>(); public String html; @JsonIgnore
  public static Model.Finder<Long, Content> find = new Model.Finder(Long.class, Content.class); public static List<Content> findAll() { return find.all(); } @JsonIgnore
  public static Content findById(Long id) { return find.where().eq(""id"", id).findUnique(); } public static Content findByName(String name) { return find.where().eq(""name"", name).findUnique(); } public Content() { } public Content(Content c) { this.name = c.name; for (Translation t : c.translations) { this.translations.add(new Translation(t)); } } public String toString() { return ""Content("" + name + "")""; } public ObjectNode toJson() { ObjectNode content = Json.newObject(); content.put(""id"", id); content.put(""name"", name); ArrayNode jsonTranslations = content.putArray(""translations""); for (Translation t : translations) { jsonTranslations.add(t.toJson()); } return content; } } ","package models; 
import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.databind.node.ArrayNode; import com.fasterxml.jackson.databind.node.ObjectNode; import play.data.format.Formats; import play.data.validation.Constraints; import play.db.ebean.Model; import play.libs.Json; 
import javax.persistence.*; import java.util.ArrayList; import java.util.List;  @Entity
@Table(name = ""content"")
public class Content extends Model { @Id
  public Long id;  @Constraints.Required
  @Formats.NonEmpty
  public String name;  @OneToMany(mappedBy=""content"", cascade = CascadeType.ALL)
  public List<Translation> translations = new ArrayList<>();  // Removed in v2.3.0 kept for migration purposes public String html;  @JsonIgnore
  public static Model.Finder<Long, Content> find = new Model.Finder(Long.class, Content.class);  public static List<Content> findAll() { return find.all(); }  @JsonIgnore
  public static Content findById(Long id) { return find.where().eq(""id"", id).findUnique(); }  public static Content findByName(String name) { return find.where().eq(""name"", name).findUnique(); }  public Content() { }  public Content(Content c) { this.name = c.name; for (Translation t : c.translations) { this.translations.add(new Translation(t)); } }  public String toString() { return ""Content("" + name + "")""; }  public ObjectNode toJson() { ObjectNode content = Json.newObject(); content.put(""id"", id); content.put(""name"", name); ArrayNode jsonTranslations = content.putArray(""translations""); for (Translation t : translations) { jsonTranslations.add(t.toJson()); } return content; }  }  "
app/models/ContentFetcher.java,"package models;


import java.util.Map;
import com.avaje.ebean.Expr;
import play.Logger;

public class ContentFetcher {
  public Experiment selectedExperiment;
  public Language defaultLanguage;
  public ContentFetcher(Experiment selectedExperiment) {
    this.selectedExperiment = selectedExperiment;
  }

  public void setDefaultLanguage(String languageString) {
    Language language = Language.find.where()
        .or(Expr.eq(""code"", languageString),
            Expr.eq(""name"", languageString))
        .setMaxRows(1)
        .findUnique();

    this.defaultLanguage = language;
  }

  public String get(String name) {
    String languageCode = null;
    if (defaultLanguage != null) {
      languageCode = defaultLanguage.getCode();
    }

    return getContentString(name, languageCode);
  }

  /**
   * Interpolate numbered curly brackets in a string. Ex: (""These are 3 numbers: {0}, {1}, and {2}"", [1, 2, 3]) -> ""This is one: 1, 2, and 3""
   * @param content
   * @param parameters
   * @return
   */
  public String interpolate (String content, Object[] parameters) {
    String returnContent = content;
    for (int i = 0; i < parameters.length; i++) {
      returnContent = returnContent.replace(""{"" + i + ""}"", parameters[i].toString());
    }
    return returnContent;
  }

  public String get(String name, Object... parameters) {
    String content = this.get(name);
    return this.interpolate(content, parameters);
  }

  public String getTranslated(String name, String languageCode, Object... parameters) {
    String returnString = getContentString(name, languageCode);
    for (int i = 0; i < parameters.length; i++) {
      returnString = returnString.replace(""{"" + i + ""}"", parameters[i].toString());
    }
    return returnString;
  }

  private String getContentString(String name, String languageCode) {
    // Accessing selectedExperiment.fileMode directly does not update due to some Ebean caching going on
    Experiment experiment = Experiment.findById(selectedExperiment.id);
    String returnString = """";
    if (experiment.fileMode) {
      for (Content c : experiment.getContent()) {
        if (c.name.equals(name)) {
          for (Translation t : c.translations) {
            if (languageCode == null || t.language.code.equals(languageCode)) {
              returnString = t.getHtml();
              break;
            }
          }
        }
      }
    } else {
      Content c = Content.find.where()
          .eq(""experiment_id"", selectedExperiment.id)
          .eq(""name"", name)
          .setMaxRows(1)
          .findUnique();
      if (c != null) {
        if (languageCode == null) {
          Translation t = Translation.find.where()
              .eq(""content_id"", c.id)
              .setMaxRows(1)
              .findUnique();
          returnString = t.getHtml();
        } else {
          Language l = Language.find.where()
              .eq(""code"", languageCode)
              .setMaxRows(1)
              .findUnique();

          Translation t = Translation.find.where()
              .eq(""content_id"", c.id)
              .eq(""languages_id"", l.id)
              .setMaxRows(1)
              .findUnique();
          returnString = t.getHtml();
        }
      } else {
        Logger.debug(""getTranslated -> c == null"");
      }
    }
    return returnString;
  }
}
","package models; public class ContentFetcher { public Experiment selectedExperiment; public Language defaultLanguage; public ContentFetcher(Experiment selectedExperiment) { this.selectedExperiment = selectedExperiment; } public void setDefaultLanguage(String languageString) { Language language = Language.find.where()
        .or(Expr.eq(""code"", languageString),
            Expr.eq(""name"", languageString))
        .setMaxRows(1)
        .findUnique(); this.defaultLanguage = language; } public String get(String name) { String languageCode = null; if (defaultLanguage != null) { languageCode = defaultLanguage.getCode(); } return getContentString(name, languageCode); } public String interpolate (String content, Object[] parameters) { String returnContent = content; for (int i = 0; i < parameters.length; i++) { returnContent = returnContent.replace(""{ "" + i + ""} "", parameters[i].toString()); } return returnContent; } public String get(String name, Object... parameters) { String content = this.get(name); return this.interpolate(content, parameters); } public String getTranslated(String name, String languageCode, Object... parameters) { String returnString = getContentString(name, languageCode); for (int i = 0; i < parameters.length; i++) { returnString = returnString.replace(""{ "" + i + ""} "", parameters[i].toString()); } return returnString; } private String getContentString(String name, String languageCode) { Experiment experiment = Experiment.findById(selectedExperiment.id); String returnString = """"; if (experiment.fileMode) { for (Content c : experiment.getContent()) { if (c.name.equals(name)) { for (Translation t : c.translations) { if (languageCode == null || t.language.code.equals(languageCode)) { returnString = t.getHtml(); break; } } } } } else { Content c = Content.find.where()
          .eq(""experiment_id"", selectedExperiment.id)
          .eq(""name"", name)
          .setMaxRows(1)
          .findUnique(); if (c != null) { if (languageCode == null) { Translation t = Translation.find.where()
              .eq(""content_id"", c.id)
              .setMaxRows(1)
              .findUnique(); returnString = t.getHtml(); } else { Language l = Language.find.where()
              .eq(""code"", languageCode)
              .setMaxRows(1)
              .findUnique(); Translation t = Translation.find.where()
              .eq(""content_id"", c.id)
              .eq(""languages_id"", l.id)
              .setMaxRows(1)
              .findUnique(); returnString = t.getHtml(); } } else { } } return returnString; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0,"package models; public class ContentFetcher { public Experiment selectedExperiment; public Language defaultLanguage; public ContentFetcher(Experiment selectedExperiment) { this.selectedExperiment = selectedExperiment; } public void setDefaultLanguage(String languageString) { Language language = Language.find.where()
        .or(Expr.eq(""code"", languageString),
            Expr.eq(""name"", languageString))
        .setMaxRows(1)
        .findUnique(); this.defaultLanguage = language; } public String get(String name) { String languageCode = null; if (defaultLanguage != null) { languageCode = defaultLanguage.getCode(); } return getContentString(name, languageCode); } public String interpolate (String content, Object[] parameters) { String returnContent = content; for (int i = 0; i < parameters.length; i++) { returnContent = returnContent.replace(""{ "" + i + ""} "", parameters[i].toString()); } return returnContent; } public String get(String name, Object... parameters) { String content = this.get(name); return this.interpolate(content, parameters); } public String getTranslated(String name, String languageCode, Object... parameters) { String returnString = getContentString(name, languageCode); for (int i = 0; i < parameters.length; i++) { returnString = returnString.replace(""{ "" + i + ""} "", parameters[i].toString()); } return returnString; } private String getContentString(String name, String languageCode) { Experiment experiment = Experiment.findById(selectedExperiment.id); String returnString = """"; if (experiment.fileMode) { for (Content c : experiment.getContent()) { if (c.name.equals(name)) { for (Translation t : c.translations) { if (languageCode == null || t.language.code.equals(languageCode)) { returnString = t.getHtml(); break; } } } } } else { <FILL_ME> Content c = Content.find.where()
          .eq(""experiment_id"", selectedExperiment.id)
          .eq(""name"", name)
          .setMaxRows(1)
          .findUnique(); if (c != null) { if (languageCode == null) { Translation t = Translation.find.where()
              .eq(""content_id"", c.id)
              .setMaxRows(1)
              .findUnique(); returnString = t.getHtml(); } else { Language l = Language.find.where()
              .eq(""code"", languageCode)
              .setMaxRows(1)
              .findUnique(); Translation t = Translation.find.where()
              .eq(""content_id"", c.id)
              .eq(""languages_id"", l.id)
              .setMaxRows(1)
              .findUnique(); returnString = t.getHtml(); } } else { } } return returnString; } } ","package models; 

import java.util.Map; import com.avaje.ebean.Expr; import play.Logger;  public class ContentFetcher { public Experiment selectedExperiment; public Language defaultLanguage; public ContentFetcher(Experiment selectedExperiment) { this.selectedExperiment = selectedExperiment; }  public void setDefaultLanguage(String languageString) { Language language = Language.find.where()
        .or(Expr.eq(""code"", languageString),
            Expr.eq(""name"", languageString))
        .setMaxRows(1)
        .findUnique();  this.defaultLanguage = language; }  public String get(String name) { String languageCode = null; if (defaultLanguage != null) { languageCode = defaultLanguage.getCode(); }  return getContentString(name, languageCode); }  /**
   * Interpolate numbered curly brackets in a string. Ex: (""These are 3 numbers: {0}, {1}, and {2}"", [1, 2, 3]) -> ""This is one: 1, 2, and 3""
   * @param content
   * @param parameters
   * @return
   */ public String interpolate (String content, Object[] parameters) { String returnContent = content; for (int i = 0; i < parameters.length; i++) { returnContent = returnContent.replace(""{ "" + i + ""} "", parameters[i].toString()); } return returnContent; }  public String get(String name, Object... parameters) { String content = this.get(name); return this.interpolate(content, parameters); }  public String getTranslated(String name, String languageCode, Object... parameters) { String returnString = getContentString(name, languageCode); for (int i = 0; i < parameters.length; i++) { returnString = returnString.replace(""{ "" + i + ""} "", parameters[i].toString()); } return returnString; }  private String getContentString(String name, String languageCode) { // Accessing selectedExperiment.fileMode directly does not update due to some Ebean caching going on Experiment experiment = Experiment.findById(selectedExperiment.id); String returnString = """"; if (experiment.fileMode) { for (Content c : experiment.getContent()) { if (c.name.equals(name)) { for (Translation t : c.translations) { if (languageCode == null || t.language.code.equals(languageCode)) { returnString = t.getHtml(); break; } } } } } else { <FILL_ME> Content c = Content.find.where()
          .eq(""experiment_id"", selectedExperiment.id)
          .eq(""name"", name)
          .setMaxRows(1)
          .findUnique(); if (c != null) { if (languageCode == null) { Translation t = Translation.find.where()
              .eq(""content_id"", c.id)
              .setMaxRows(1)
              .findUnique(); returnString = t.getHtml(); } else { Language l = Language.find.where()
              .eq(""code"", languageCode)
              .setMaxRows(1)
              .findUnique();  Translation t = Translation.find.where()
              .eq(""content_id"", c.id)
              .eq(""languages_id"", l.id)
              .setMaxRows(1)
              .findUnique(); returnString = t.getHtml(); } } else { } } return returnString; } }  "
app/models/CreateFirstUser.java,"package models;

import org.apache.commons.lang3.StringUtils;

public class CreateFirstUser {

  public String email;
  public String newPassword;
  public String confirmPassword;

  public String validate() {
    if (StringUtils.isEmpty(email)) {
      return ""Email can't be empty"";
    }

    if (email.equals(""test@test.com"")) {
      return ""Email can't be test@test.com"";
    }

    //TODO: better validation like regex?
    if (StringUtils.isEmpty(newPassword)) {
      return ""New password is missing"";
    }

    if (!newPassword.equals(confirmPassword)) {
      return ""Confirm Password doesn't match the new password"";
    }
    return null;
  }
}
","package models; public class CreateFirstUser { public String email; public String newPassword; public String confirmPassword; public String validate() { if (StringUtils.isEmpty(email)) { return ""Email can't be empty""; } if (email.equals(""test@test.com"")) { return ""Email can't be test@test.com""; } if (StringUtils.isEmpty(newPassword)) { return ""New password is missing""; } if (!newPassword.equals(confirmPassword)) { return ""Confirm Password doesn't match the new password""; } return null; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; public class CreateFirstUser { public String email; public String newPassword; public String confirmPassword; public String validate() { if (StringUtils.isEmpty(email)) { return ""Email can't be empty""; } if (email.equals(""test@test.com"")) { return ""Email can't be test@test.com""; } if (StringUtils.isEmpty(newPassword)) { return ""New password is missing""; } if (!newPassword.equals(confirmPassword)) { return ""Confirm Password doesn't match the new password""; } return null; } } ","package models; 
import org.apache.commons.lang3.StringUtils;  public class CreateFirstUser {  public String email; public String newPassword; public String confirmPassword;  public String validate() { if (StringUtils.isEmpty(email)) { return ""Email can't be empty""; }  if (email.equals(""test@test.com"")) { return ""Email can't be test@test.com""; }  //TODO: better validation like regex? if (StringUtils.isEmpty(newPassword)) { return ""New password is missing""; }  if (!newPassword.equals(confirmPassword)) { return ""Confirm Password doesn't match the new password""; } return null; } }  "
app/models/Data.java,"package models;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.databind.node.ObjectNode;
import play.data.format.Formats;
import play.data.validation.Constraints;
import play.db.ebean.Model;
import play.libs.Json;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import javax.persistence.Table;
import java.util.List;

@Entity
@Table(name = ""data"")
public class Data extends Model {
  @Id
  public Long id;

  @Constraints.Required
  @Formats.NonEmpty
  public String name;

  public String value;

  @ManyToOne
  @JsonIgnore
  public ExperimentInstance experimentInstance;

  @JsonIgnore
  public static Model.Finder<Long, Data> find = new Model.Finder(Long.class, Data.class);

  public static List<Data> findAll() {
    return find.all();
  }

  public ObjectNode toJson() {
    ObjectNode data = Json.newObject();
    data.put(""id"", id);
    data.put(""name"", name);
    data.put(""value"", value);
    return data;
  }

  public String toString() {
    return ""Data("" + id + "")"";
  }
}
","package models; @Entity
@Table(name = ""data"")
public class Data extends Model { @Id
  public Long id; @Constraints.Required
  @Formats.NonEmpty
  public String name; public String value; @ManyToOne
  @JsonIgnore
  public ExperimentInstance experimentInstance; @JsonIgnore
  public static Model.Finder<Long, Data> find = new Model.Finder(Long.class, Data.class); public static List<Data> findAll() { return find.all(); } public ObjectNode toJson() { ObjectNode data = Json.newObject(); data.put(""id"", id); data.put(""name"", name); data.put(""value"", value); return data; } public String toString() { return ""Data("" + id + "")""; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; @Entity
@Table(name = ""data"")
public class Data extends Model { @Id
  public Long id; @Constraints.Required
  @Formats.NonEmpty
  public String name; public String value; @ManyToOne
  @JsonIgnore
  public ExperimentInstance experimentInstance; @JsonIgnore
  public static Model.Finder<Long, Data> find = new Model.Finder(Long.class, Data.class); public static List<Data> findAll() { return find.all(); } public ObjectNode toJson() { ObjectNode data = Json.newObject(); data.put(""id"", id); data.put(""name"", name); data.put(""value"", value); return data; } public String toString() { return ""Data("" + id + "")""; } } ","package models; 
import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.databind.node.ObjectNode; import play.data.format.Formats; import play.data.validation.Constraints; import play.db.ebean.Model; import play.libs.Json; 
import javax.persistence.Entity; import javax.persistence.Id; import javax.persistence.ManyToOne; import javax.persistence.Table; import java.util.List;  @Entity
@Table(name = ""data"")
public class Data extends Model { @Id
  public Long id;  @Constraints.Required
  @Formats.NonEmpty
  public String name;  public String value;  @ManyToOne
  @JsonIgnore
  public ExperimentInstance experimentInstance;  @JsonIgnore
  public static Model.Finder<Long, Data> find = new Model.Finder(Long.class, Data.class);  public static List<Data> findAll() { return find.all(); }  public ObjectNode toJson() { ObjectNode data = Json.newObject(); data.put(""id"", id); data.put(""name"", name); data.put(""value"", value); return data; }  public String toString() { return ""Data("" + id + "")""; } }  "
app/models/Event.java,"package models;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import play.data.format.Formats;
import play.data.validation.Constraints;
import play.db.ebean.Model;
import play.libs.Json;

import javax.persistence.*;
import java.text.SimpleDateFormat;
import java.util.*;

@Entity
@Table(name = ""events"")
public class Event extends Model {
  @Id
  public Long id;

  @Constraints.Required
  @Formats.NonEmpty
  public Date datetime;

  @Constraints.Required
  @Formats.NonEmpty
  public String name;

  @JsonIgnore
  @ManyToOne
  public ExperimentInstance experimentInstance;

  @OneToMany(cascade = CascadeType.ALL, mappedBy = ""event"")
  @OrderBy(""name"")
  public List<EventData> eventData;

  @JsonIgnore
  public static Model.Finder<Long, Event> find = new Model.Finder(Long.class, Event.class);

  public Event() {
    datetime = new Date();
    eventData = new ArrayList<EventData>();
  }

  public static List<Event> findAll() {
    return find.all();
  }

  @Override
  public void delete() {
    for (EventData ed : eventData) {
      ed.delete();
    }
    eventData.clear();
    super.delete();
  }

  public void addEventData(EventData eventData) {
    eventData.event = this;
    this.eventData.add(eventData);
  }

  public ObjectNode toJson() {
    ObjectNode event = Json.newObject();
    event.put(""id"", id);
    event.put(""name"", name);
    event.put(""datetime"", new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss,S"").format(datetime));

    ArrayNode jsonEventData = event.putArray(""eventData"");
    for (EventData ed : eventData) {
      jsonEventData.add(ed.toJson());
    }

    return event;
  }

  public String toString() {
    return ""Event("" + id + "")"";
  }
}
","package models; @Entity
@Table(name = ""events"")
public class Event extends Model { @Id
  public Long id; @Constraints.Required
  @Formats.NonEmpty
  public Date datetime; @Constraints.Required
  @Formats.NonEmpty
  public String name; @JsonIgnore
  @ManyToOne
  public ExperimentInstance experimentInstance; @OneToMany(cascade = CascadeType.ALL, mappedBy = ""event"")
  @OrderBy(""name"")
  public List<EventData> eventData; @JsonIgnore
  public static Model.Finder<Long, Event> find = new Model.Finder(Long.class, Event.class); public Event() { datetime = new Date(); eventData = new ArrayList<EventData>(); } public static List<Event> findAll() { return find.all(); } @Override
  public void delete() { for (EventData ed : eventData) { ed.delete(); } eventData.clear(); super.delete(); } public void addEventData(EventData eventData) { eventData.event = this; this.eventData.add(eventData); } public ObjectNode toJson() { ObjectNode event = Json.newObject(); event.put(""id"", id); event.put(""name"", name); event.put(""datetime"", new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss,S"").format(datetime)); ArrayNode jsonEventData = event.putArray(""eventData""); for (EventData ed : eventData) { jsonEventData.add(ed.toJson()); } return event; } public String toString() { return ""Event("" + id + "")""; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; @Entity
@Table(name = ""events"")
public class Event extends Model { @Id
  public Long id; @Constraints.Required
  @Formats.NonEmpty
  public Date datetime; @Constraints.Required
  @Formats.NonEmpty
  public String name; @JsonIgnore
  @ManyToOne
  public ExperimentInstance experimentInstance; @OneToMany(cascade = CascadeType.ALL, mappedBy = ""event"")
  @OrderBy(""name"")
  public List<EventData> eventData; @JsonIgnore
  public static Model.Finder<Long, Event> find = new Model.Finder(Long.class, Event.class); public Event() { datetime = new Date(); eventData = new ArrayList<EventData>(); } public static List<Event> findAll() { return find.all(); } @Override
  public void delete() { for (EventData ed : eventData) { ed.delete(); } eventData.clear(); super.delete(); } public void addEventData(EventData eventData) { eventData.event = this; this.eventData.add(eventData); } public ObjectNode toJson() { ObjectNode event = Json.newObject(); event.put(""id"", id); event.put(""name"", name); event.put(""datetime"", new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss,S"").format(datetime)); ArrayNode jsonEventData = event.putArray(""eventData""); for (EventData ed : eventData) { jsonEventData.add(ed.toJson()); } return event; } public String toString() { return ""Event("" + id + "")""; } } ","package models; 
import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.databind.node.ArrayNode; import com.fasterxml.jackson.databind.node.ObjectNode; import play.data.format.Formats; import play.data.validation.Constraints; import play.db.ebean.Model; import play.libs.Json; 
import javax.persistence.*; import java.text.SimpleDateFormat; import java.util.*;  @Entity
@Table(name = ""events"")
public class Event extends Model { @Id
  public Long id;  @Constraints.Required
  @Formats.NonEmpty
  public Date datetime;  @Constraints.Required
  @Formats.NonEmpty
  public String name;  @JsonIgnore
  @ManyToOne
  public ExperimentInstance experimentInstance;  @OneToMany(cascade = CascadeType.ALL, mappedBy = ""event"")
  @OrderBy(""name"")
  public List<EventData> eventData;  @JsonIgnore
  public static Model.Finder<Long, Event> find = new Model.Finder(Long.class, Event.class);  public Event() { datetime = new Date(); eventData = new ArrayList<EventData>(); }  public static List<Event> findAll() { return find.all(); }  @Override
  public void delete() { for (EventData ed : eventData) { ed.delete(); } eventData.clear(); super.delete(); }  public void addEventData(EventData eventData) { eventData.event = this; this.eventData.add(eventData); }  public ObjectNode toJson() { ObjectNode event = Json.newObject(); event.put(""id"", id); event.put(""name"", name); event.put(""datetime"", new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss,S"").format(datetime));  ArrayNode jsonEventData = event.putArray(""eventData""); for (EventData ed : eventData) { jsonEventData.add(ed.toJson()); }  return event; }  public String toString() { return ""Event("" + id + "")""; } }  "
app/models/EventBus.java,"package models;

import play.Logger;
import groovy.lang.Closure;
import java.util.Map;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Collections;

class EventHandler<A> {
  public List<Closure<A>> closures = new CopyOnWriteArrayList<>();

  public void addClosure (Closure<A> closure) {
    this.closures.add(closure);
  }

  public boolean removeClosure (Closure<A> closure) {
    return this.closures.remove(closure);
  }

  public void emit (A... data) {
    for (Closure<A> closure : this.closures) {
      closure.call(data);
    }
  }

  public void clear () {
    this.closures.clear();
  }

}

public class EventBus <T> {

  private Map<String, EventHandler<T>> events = new ConcurrentHashMap();

  public EventHandler<T> register (String eventName) {
    EventHandler<T> handler = new EventHandler();
    this.events.put(eventName, handler);
    return handler;
  }

  public void unregister (String eventName) {
    this.events.remove(eventName);
  }

  public void on (String eventName, Closure closure) {
    EventHandler<T> event = this.events.get(eventName);
    // Automatically register the event if it hasn't been registered yet
    if (event == null) {
      event = register(eventName);
    }
    event.addClosure(closure);
    this.logThread(""on"", eventName); 
  }

   public boolean off (String eventName) {
    EventHandler<T> removed = this.events.remove(eventName);
    boolean wasRemoved = removed != null;
    this.logThread(""off 1"", eventName);
    return wasRemoved;
  }
  
  public boolean off (String eventName, Closure closure) {
    EventHandler<T> event = this.events.get(eventName);
    boolean wasRemoved = false;
    if (event != null) {
      wasRemoved = event.removeClosure(closure);
    }
    this.logThread(""off 2"", eventName);
    return wasRemoved;
  }

  public void emit (String eventName, T... payload) {
    EventHandler<T> event = this.events.get(eventName);
    if (event != null) {
      event.emit(payload);
    }
    this.logThread(""emit"", eventName);
  }

  private void logThread (String methodName, String eventName) {
    EventHandler<T> event = this.events.get(eventName);
    String msg = methodName + "" thread "" + Thread.currentThread().getId() + "" size "" + this.events.keySet().size() + "" "" + eventName;
    if (event != null) {
      msg += "" listeners "" + event.closures.size();
    }
    Logger.trace(msg);
  }

  private void logThread (String methodName) {
    Logger.trace(methodName + "" thread "" + Thread.currentThread().getId() + "" size "" + this.events.keySet().size());
  }

  public void clear () {
    this.events.clear();
    this.logThread(""clear"");
  }

}","package models; class EventHandler<A> { public List<Closure<A>> closures = new CopyOnWriteArrayList<>(); public void addClosure (Closure<A> closure) { this.closures.add(closure); } public boolean removeClosure (Closure<A> closure) { return this.closures.remove(closure); } public void emit (A... data) { for (Closure<A> closure : this.closures) { closure.call(data); } } public void clear () { this.closures.clear(); } } public class EventBus <T> { private Map<String, EventHandler<T>> events = new ConcurrentHashMap(); public EventHandler<T> register (String eventName) { EventHandler<T> handler = new EventHandler(); this.events.put(eventName, handler); return handler; } public void unregister (String eventName) { this.events.remove(eventName); } public void on (String eventName, Closure closure) { EventHandler<T> event = this.events.get(eventName); if (event == null) { event = register(eventName); } event.addClosure(closure); this.logThread(""on"", eventName); } public boolean off (String eventName) { EventHandler<T> removed = this.events.remove(eventName); boolean wasRemoved = removed != null; this.logThread(""off 1"", eventName); return wasRemoved; } public boolean off (String eventName, Closure closure) { EventHandler<T> event = this.events.get(eventName); boolean wasRemoved = false; if (event != null) { wasRemoved = event.removeClosure(closure); } this.logThread(""off 2"", eventName); return wasRemoved; } public void emit (String eventName, T... payload) { EventHandler<T> event = this.events.get(eventName); if (event != null) { event.emit(payload); } this.logThread(""emit"", eventName); } private void logThread (String methodName, String eventName) { EventHandler<T> event = this.events.get(eventName); String msg = methodName + "" thread "" + Thread.currentThread().getId() + "" size "" + this.events.keySet().size() + "" "" + eventName; if (event != null) { msg += "" listeners "" + event.closures.size(); } } private void logThread (String methodName) { } public void clear () { this.events.clear(); this.logThread(""clear""); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0,"package models; class EventHandler<A> { public List<Closure<A>> closures = new CopyOnWriteArrayList<>(); public void addClosure (Closure<A> closure) { this.closures.add(closure); } <FILL_ME> public boolean removeClosure (Closure<A> closure) { return this.closures.remove(closure); } public void emit (A... data) { for (Closure<A> closure : this.closures) { closure.call(data); } } public void clear () { this.closures.clear(); } } public class EventBus <T> { private Map<String, EventHandler<T>> events = new ConcurrentHashMap(); public EventHandler<T> register (String eventName) { EventHandler<T> handler = new EventHandler(); this.events.put(eventName, handler); return handler; } public void unregister (String eventName) { this.events.remove(eventName); } public void on (String eventName, Closure closure) { EventHandler<T> event = this.events.get(eventName); if (event == null) { event = register(eventName); } event.addClosure(closure); this.logThread(""on"", eventName); } public boolean off (String eventName) { EventHandler<T> removed = this.events.remove(eventName); boolean wasRemoved = removed != null; this.logThread(""off 1"", eventName); return wasRemoved; } public boolean off (String eventName, Closure closure) { EventHandler<T> event = this.events.get(eventName); boolean wasRemoved = false; if (event != null) { wasRemoved = event.removeClosure(closure); } this.logThread(""off 2"", eventName); return wasRemoved; } public void emit (String eventName, T... payload) { EventHandler<T> event = this.events.get(eventName); if (event != null) { event.emit(payload); } this.logThread(""emit"", eventName); } private void logThread (String methodName, String eventName) { EventHandler<T> event = this.events.get(eventName); String msg = methodName + "" thread "" + Thread.currentThread().getId() + "" size "" + this.events.keySet().size() + "" "" + eventName; if (event != null) { msg += "" listeners "" + event.closures.size(); } } private void logThread (String methodName) { <FILL_ME> } public void clear () { this.events.clear(); this.logThread(""clear""); } }","package models; 
import play.Logger; import groovy.lang.Closure; import java.util.Map; import java.util.List; import java.util.concurrent.CopyOnWriteArrayList; import java.util.concurrent.ConcurrentHashMap; import java.util.Collections;  class EventHandler<A> { public List<Closure<A>> closures = new CopyOnWriteArrayList<>();  public void addClosure (Closure<A> closure) { this.closures.add(closure); } <FILL_ME>  public boolean removeClosure (Closure<A> closure) { return this.closures.remove(closure); }  public void emit (A... data) { for (Closure<A> closure : this.closures) { closure.call(data); } }  public void clear () { this.closures.clear(); }  }  public class EventBus <T> {  private Map<String, EventHandler<T>> events = new ConcurrentHashMap();  public EventHandler<T> register (String eventName) { EventHandler<T> handler = new EventHandler(); this.events.put(eventName, handler); return handler; }  public void unregister (String eventName) { this.events.remove(eventName); }  public void on (String eventName, Closure closure) { EventHandler<T> event = this.events.get(eventName); // Automatically register the event if it hasn't been registered yet if (event == null) { event = register(eventName); } event.addClosure(closure); this.logThread(""on"", eventName); }  public boolean off (String eventName) { EventHandler<T> removed = this.events.remove(eventName); boolean wasRemoved = removed != null; this.logThread(""off 1"", eventName); return wasRemoved; }    public boolean off (String eventName, Closure closure) { EventHandler<T> event = this.events.get(eventName); boolean wasRemoved = false; if (event != null) { wasRemoved = event.removeClosure(closure); } this.logThread(""off 2"", eventName); return wasRemoved; }  public void emit (String eventName, T... payload) { EventHandler<T> event = this.events.get(eventName); if (event != null) { event.emit(payload); } this.logThread(""emit"", eventName); }  private void logThread (String methodName, String eventName) { EventHandler<T> event = this.events.get(eventName); String msg = methodName + "" thread "" + Thread.currentThread().getId() + "" size "" + this.events.keySet().size() + "" "" + eventName; if (event != null) { msg += "" listeners "" + event.closures.size(); } }  private void logThread (String methodName) { <FILL_ME> }  public void clear () { this.events.clear(); this.logThread(""clear""); }  }"
app/models/EventData.java,"package models;

import com.fasterxml.jackson.databind.node.ObjectNode;
import play.data.format.Formats;
import play.data.validation.Constraints;
import play.db.ebean.Model;
import play.libs.Json;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import javax.persistence.Table;
import java.util.List;

@Entity
@Table(name = ""event_data"")
public class EventData extends Model {
  @Id
  public Long id;

  @Constraints.Required
  @Formats.NonEmpty
  public String name;

  public String value;

  @ManyToOne
  public Event event;

  public static Model.Finder<Long, EventData> find = new Model.Finder(Long.class, EventData.class);

  public static List<EventData> findAll() {
    return find.all();
  }

  public String valueToCSV() {
    return ""\"""" + value.replace(""\"""", ""\""\"""") + ""\"""";
  }

  public ObjectNode toJson() {
    ObjectNode eventData = Json.newObject();
    eventData.put(""id"", id);
    eventData.put(""name"", name);
    eventData.put(""value"", value);
    return eventData;
  }

  public String toString() {
    return ""EventData("" + id + "")"";
  }
}
","package models; @Entity
@Table(name = ""event_data"")
public class EventData extends Model { @Id
  public Long id; @Constraints.Required
  @Formats.NonEmpty
  public String name; public String value; @ManyToOne
  public Event event; public static Model.Finder<Long, EventData> find = new Model.Finder(Long.class, EventData.class); public static List<EventData> findAll() { return find.all(); } public String valueToCSV() { return ""\"""" + value.replace(""\"""", ""\""\"""") + ""\""""; } public ObjectNode toJson() { ObjectNode eventData = Json.newObject(); eventData.put(""id"", id); eventData.put(""name"", name); eventData.put(""value"", value); return eventData; } public String toString() { return ""EventData("" + id + "")""; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; @Entity
@Table(name = ""event_data"")
public class EventData extends Model { @Id
  public Long id; @Constraints.Required
  @Formats.NonEmpty
  public String name; public String value; @ManyToOne
  public Event event; public static Model.Finder<Long, EventData> find = new Model.Finder(Long.class, EventData.class); public static List<EventData> findAll() { return find.all(); } public String valueToCSV() { return ""\"""" + value.replace(""\"""", ""\""\"""") + ""\""""; } public ObjectNode toJson() { ObjectNode eventData = Json.newObject(); eventData.put(""id"", id); eventData.put(""name"", name); eventData.put(""value"", value); return eventData; } public String toString() { return ""EventData("" + id + "")""; } } ","package models; 
import com.fasterxml.jackson.databind.node.ObjectNode; import play.data.format.Formats; import play.data.validation.Constraints; import play.db.ebean.Model; import play.libs.Json; 
import javax.persistence.Entity; import javax.persistence.Id; import javax.persistence.ManyToOne; import javax.persistence.Table; import java.util.List;  @Entity
@Table(name = ""event_data"")
public class EventData extends Model { @Id
  public Long id;  @Constraints.Required
  @Formats.NonEmpty
  public String name;  public String value;  @ManyToOne
  public Event event;  public static Model.Finder<Long, EventData> find = new Model.Finder(Long.class, EventData.class);  public static List<EventData> findAll() { return find.all(); }  public String valueToCSV() { return ""\"""" + value.replace(""\"""", ""\""\"""") + ""\""""; }  public ObjectNode toJson() { ObjectNode eventData = Json.newObject(); eventData.put(""id"", id); eventData.put(""name"", name); eventData.put(""value"", value); return eventData; }  public String toString() { return ""EventData("" + id + "")""; } }  "
app/models/EventGraphChangedListener.java,"package models;

import com.tinkerpop.blueprints.Direction;
import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Graph;
import com.tinkerpop.blueprints.Vertex;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

public class EventGraphChangedListener implements BreadboardGraphChangedListener {
  private Graph graph;
  private ArrayList<ClientListener> adminListeners = new ArrayList<>();
  private static HashMap<String, Client> clientListeners = new HashMap<>();

  public EventGraphChangedListener(Graph graph) {
    this.graph = graph;
  }

  public void addAdminListener(ClientListener adminListener) {
    adminListeners.add(adminListener);
  }

  public ArrayList<ClientListener> getAdminListeners() {
    return this.adminListeners;
  }

  @Override
  public void setGraph(Graph g) {
    this.graph = g;
  }

  public void addClientListener(Client clientListener) {
    clientListeners.put(clientListener.id, clientListener);
  }

  @Override
  public void edgeAdded(Edge edge) {
    //Logger.debug(""EventGraphChangedListener edgeAdded"");
    for (ClientListener al : adminListeners)
      al.edgeAdded(edge);

    clientEdgeChanged(edge);
  }

  @Override
  public void edgePropertyChanged(Edge edge, String key, Object oldValue, Object setValue) {
    for (ClientListener al : adminListeners)
      al.edgePropertyChanged(edge, key, setValue);

    clientEdgePropertyChanged(edge, key, setValue);
  }

  @Override
  public void edgePropertyRemoved(Edge edge, String key, Object removedValue) {
    for (ClientListener al : adminListeners)
      al.edgePropertyRemoved(edge, key);

    clientEdgePropertyChanged(edge, key, removedValue);
  }

  @Override
  public void edgeRemoved(Edge edge, Map<String, Object> props) {
    for (ClientListener al : adminListeners)
      al.edgeRemoved(edge);

    clientEdgeChanged(edge);
  }

  @Override
  public void vertexAdded(Vertex vertex) {
    for (ClientListener al : adminListeners)
      al.vertexAdded(vertex);

    clientVertexChanged(vertex, false);
  }

  @Override
  public void vertexPropertyChanged(Vertex vertex, String key, Object oldValue, Object setValue) {
    for (ClientListener al : adminListeners)
      al.vertexPropertyChanged(vertex, key, oldValue, setValue);

    boolean pvt = (key.equals(""private"") || key.equals(""choices"") || key.equals(""text""));
    clientVertexChanged(vertex, pvt);
  }

  @Override
  public void vertexPropertyRemoved(Vertex vertex, String key, Object removedValue) {
    for (ClientListener al : adminListeners)
      al.vertexPropertyRemoved(vertex, key);

    boolean pvt = (key.equals(""private"") || key.equals(""choices"") || key.equals(""text""));
    clientVertexChanged(vertex, pvt);
  }

  @Override
  public void vertexRemoved(Vertex vertex, Map<String, Object> props) {
    for (ClientListener al : adminListeners)
      al.vertexRemoved(vertex);

    clientVertexChanged(vertex, false);
  }

  private void clientEdgePropertyChanged(Edge edge, String key, Object value) {
    // inProps are only visible by the inVertex and outProps are only visible by the outVertex
    if (key.equals(""inProps"")) {
      Vertex inVertex = edge.getVertex(Direction.IN);
      String inId = (String) inVertex.getId();
      if (clientListeners.containsKey(inId)) {
        Client inClient = clientListeners.get(inId);
        inClient.updateGraph(inVertex);
      }
    } else if (key.equals(""outProps"")) {
      Vertex outVertex = edge.getVertex(Direction.OUT);
      String outId = (String) outVertex.getId();
      if (clientListeners.containsKey(outId)) {
        Client outClient = clientListeners.get(outId);
        outClient.updateGraph(outVertex);
      }
    } else {
      clientEdgeChanged(edge);
    }
  }

  private void clientEdgeChanged(Edge edge) {
    Vertex[] vertices = getVerticesByEdge(edge);

    String id1 = (String) vertices[0].getId();
    String id2 = (String) vertices[1].getId();

    if (clientListeners.containsKey(id1)) {
      Client c1 = clientListeners.get(id1);
      c1.updateGraph(vertices[0]);
    }

    if (clientListeners.containsKey(id2)) {
      Client c2 = clientListeners.get(id2);
      c2.updateGraph(vertices[1]);
    }
  }

  private void clientVertexChanged(Vertex vertex, boolean pvt) {
    // The vertex itself
    String id = (String) vertex.getId();
    if (clientListeners.containsKey(id)) {
      clientListeners.get(id).updateGraph(vertex);
    }
    // And all neighbors, if it isn't a private property
    if (!pvt) {
      for (Vertex v : vertex.getVertices(Direction.BOTH)) {
        id = (String) v.getId();
        if (clientListeners.containsKey(id)) {
          clientListeners.get(id).updateGraph(v);
        }
      }
    }
  }

  private Vertex[] getVerticesByEdge(Edge edge) {
    Vertex[] returnArray = new Vertex[2];
    returnArray[0] = edge.getVertex(Direction.IN);
    returnArray[1] = edge.getVertex(Direction.OUT);
    return returnArray;
  }
}
","package models; public class EventGraphChangedListener implements BreadboardGraphChangedListener { private Graph graph; private ArrayList<ClientListener> adminListeners = new ArrayList<>(); private static HashMap<String, Client> clientListeners = new HashMap<>(); public EventGraphChangedListener(Graph graph) { this.graph = graph; } public void addAdminListener(ClientListener adminListener) { adminListeners.add(adminListener); } public ArrayList<ClientListener> getAdminListeners() { return this.adminListeners; } @Override
  public void setGraph(Graph g) { this.graph = g; } public void addClientListener(Client clientListener) { clientListeners.put(clientListener.id, clientListener); } @Override
  public void edgeAdded(Edge edge) { for (ClientListener al : adminListeners)
      al.edgeAdded(edge); clientEdgeChanged(edge); } @Override
  public void edgePropertyChanged(Edge edge, String key, Object oldValue, Object setValue) { for (ClientListener al : adminListeners)
      al.edgePropertyChanged(edge, key, setValue); clientEdgePropertyChanged(edge, key, setValue); } @Override
  public void edgePropertyRemoved(Edge edge, String key, Object removedValue) { for (ClientListener al : adminListeners)
      al.edgePropertyRemoved(edge, key); clientEdgePropertyChanged(edge, key, removedValue); } @Override
  public void edgeRemoved(Edge edge, Map<String, Object> props) { for (ClientListener al : adminListeners)
      al.edgeRemoved(edge); clientEdgeChanged(edge); } @Override
  public void vertexAdded(Vertex vertex) { for (ClientListener al : adminListeners)
      al.vertexAdded(vertex); clientVertexChanged(vertex, false); } @Override
  public void vertexPropertyChanged(Vertex vertex, String key, Object oldValue, Object setValue) { for (ClientListener al : adminListeners)
      al.vertexPropertyChanged(vertex, key, oldValue, setValue); boolean pvt = (key.equals(""private"") || key.equals(""choices"") || key.equals(""text"")); clientVertexChanged(vertex, pvt); } @Override
  public void vertexPropertyRemoved(Vertex vertex, String key, Object removedValue) { for (ClientListener al : adminListeners)
      al.vertexPropertyRemoved(vertex, key); boolean pvt = (key.equals(""private"") || key.equals(""choices"") || key.equals(""text"")); clientVertexChanged(vertex, pvt); } @Override
  public void vertexRemoved(Vertex vertex, Map<String, Object> props) { for (ClientListener al : adminListeners)
      al.vertexRemoved(vertex); clientVertexChanged(vertex, false); } private void clientEdgePropertyChanged(Edge edge, String key, Object value) { if (key.equals(""inProps"")) { Vertex inVertex = edge.getVertex(Direction.IN); String inId = (String) inVertex.getId(); if (clientListeners.containsKey(inId)) { Client inClient = clientListeners.get(inId); inClient.updateGraph(inVertex); } } else if (key.equals(""outProps"")) { Vertex outVertex = edge.getVertex(Direction.OUT); String outId = (String) outVertex.getId(); if (clientListeners.containsKey(outId)) { Client outClient = clientListeners.get(outId); outClient.updateGraph(outVertex); } } else { clientEdgeChanged(edge); } } private void clientEdgeChanged(Edge edge) { Vertex[] vertices = getVerticesByEdge(edge); String id1 = (String) vertices[0].getId(); String id2 = (String) vertices[1].getId(); if (clientListeners.containsKey(id1)) { Client c1 = clientListeners.get(id1); c1.updateGraph(vertices[0]); } if (clientListeners.containsKey(id2)) { Client c2 = clientListeners.get(id2); c2.updateGraph(vertices[1]); } } private void clientVertexChanged(Vertex vertex, boolean pvt) { String id = (String) vertex.getId(); if (clientListeners.containsKey(id)) { clientListeners.get(id).updateGraph(vertex); } if (!pvt) { for (Vertex v : vertex.getVertices(Direction.BOTH)) { id = (String) v.getId(); if (clientListeners.containsKey(id)) { clientListeners.get(id).updateGraph(v); } } } } private Vertex[] getVerticesByEdge(Edge edge) { Vertex[] returnArray = new Vertex[2]; returnArray[0] = edge.getVertex(Direction.IN); returnArray[1] = edge.getVertex(Direction.OUT); return returnArray; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; public class EventGraphChangedListener implements BreadboardGraphChangedListener { private Graph graph; private ArrayList<ClientListener> adminListeners = new ArrayList<>(); private static HashMap<String, Client> clientListeners = new HashMap<>(); public EventGraphChangedListener(Graph graph) { this.graph = graph; } public void addAdminListener(ClientListener adminListener) { adminListeners.add(adminListener); } public ArrayList<ClientListener> getAdminListeners() { return this.adminListeners; } @Override
  public void setGraph(Graph g) { this.graph = g; } public void addClientListener(Client clientListener) { clientListeners.put(clientListener.id, clientListener); } @Override
  public void edgeAdded(Edge edge) { for (ClientListener al : adminListeners)
      al.edgeAdded(edge); clientEdgeChanged(edge); } @Override
  public void edgePropertyChanged(Edge edge, String key, Object oldValue, Object setValue) { for (ClientListener al : adminListeners)
      al.edgePropertyChanged(edge, key, setValue); clientEdgePropertyChanged(edge, key, setValue); } @Override
  public void edgePropertyRemoved(Edge edge, String key, Object removedValue) { for (ClientListener al : adminListeners)
      al.edgePropertyRemoved(edge, key); clientEdgePropertyChanged(edge, key, removedValue); } @Override
  public void edgeRemoved(Edge edge, Map<String, Object> props) { for (ClientListener al : adminListeners)
      al.edgeRemoved(edge); clientEdgeChanged(edge); } @Override
  public void vertexAdded(Vertex vertex) { for (ClientListener al : adminListeners)
      al.vertexAdded(vertex); clientVertexChanged(vertex, false); } @Override
  public void vertexPropertyChanged(Vertex vertex, String key, Object oldValue, Object setValue) { for (ClientListener al : adminListeners)
      al.vertexPropertyChanged(vertex, key, oldValue, setValue); boolean pvt = (key.equals(""private"") || key.equals(""choices"") || key.equals(""text"")); clientVertexChanged(vertex, pvt); } @Override
  public void vertexPropertyRemoved(Vertex vertex, String key, Object removedValue) { for (ClientListener al : adminListeners)
      al.vertexPropertyRemoved(vertex, key); boolean pvt = (key.equals(""private"") || key.equals(""choices"") || key.equals(""text"")); clientVertexChanged(vertex, pvt); } @Override
  public void vertexRemoved(Vertex vertex, Map<String, Object> props) { for (ClientListener al : adminListeners)
      al.vertexRemoved(vertex); clientVertexChanged(vertex, false); } private void clientEdgePropertyChanged(Edge edge, String key, Object value) { if (key.equals(""inProps"")) { Vertex inVertex = edge.getVertex(Direction.IN); String inId = (String) inVertex.getId(); if (clientListeners.containsKey(inId)) { Client inClient = clientListeners.get(inId); inClient.updateGraph(inVertex); } } else if (key.equals(""outProps"")) { Vertex outVertex = edge.getVertex(Direction.OUT); String outId = (String) outVertex.getId(); if (clientListeners.containsKey(outId)) { Client outClient = clientListeners.get(outId); outClient.updateGraph(outVertex); } } else { clientEdgeChanged(edge); } } private void clientEdgeChanged(Edge edge) { Vertex[] vertices = getVerticesByEdge(edge); String id1 = (String) vertices[0].getId(); String id2 = (String) vertices[1].getId(); if (clientListeners.containsKey(id1)) { Client c1 = clientListeners.get(id1); c1.updateGraph(vertices[0]); } if (clientListeners.containsKey(id2)) { Client c2 = clientListeners.get(id2); c2.updateGraph(vertices[1]); } } private void clientVertexChanged(Vertex vertex, boolean pvt) { String id = (String) vertex.getId(); if (clientListeners.containsKey(id)) { clientListeners.get(id).updateGraph(vertex); } if (!pvt) { for (Vertex v : vertex.getVertices(Direction.BOTH)) { id = (String) v.getId(); if (clientListeners.containsKey(id)) { clientListeners.get(id).updateGraph(v); } } } } private Vertex[] getVerticesByEdge(Edge edge) { Vertex[] returnArray = new Vertex[2]; returnArray[0] = edge.getVertex(Direction.IN); returnArray[1] = edge.getVertex(Direction.OUT); return returnArray; } } ","package models; 
import com.tinkerpop.blueprints.Direction; import com.tinkerpop.blueprints.Edge; import com.tinkerpop.blueprints.Graph; import com.tinkerpop.blueprints.Vertex; 
import java.util.ArrayList; import java.util.HashMap; import java.util.Map;  public class EventGraphChangedListener implements BreadboardGraphChangedListener { private Graph graph; private ArrayList<ClientListener> adminListeners = new ArrayList<>(); private static HashMap<String, Client> clientListeners = new HashMap<>();  public EventGraphChangedListener(Graph graph) { this.graph = graph; }  public void addAdminListener(ClientListener adminListener) { adminListeners.add(adminListener); }  public ArrayList<ClientListener> getAdminListeners() { return this.adminListeners; }  @Override
  public void setGraph(Graph g) { this.graph = g; }  public void addClientListener(Client clientListener) { clientListeners.put(clientListener.id, clientListener); }  @Override
  public void edgeAdded(Edge edge) { //Logger.debug(""EventGraphChangedListener edgeAdded""); for (ClientListener al : adminListeners)
      al.edgeAdded(edge);  clientEdgeChanged(edge); }  @Override
  public void edgePropertyChanged(Edge edge, String key, Object oldValue, Object setValue) { for (ClientListener al : adminListeners)
      al.edgePropertyChanged(edge, key, setValue);  clientEdgePropertyChanged(edge, key, setValue); }  @Override
  public void edgePropertyRemoved(Edge edge, String key, Object removedValue) { for (ClientListener al : adminListeners)
      al.edgePropertyRemoved(edge, key);  clientEdgePropertyChanged(edge, key, removedValue); }  @Override
  public void edgeRemoved(Edge edge, Map<String, Object> props) { for (ClientListener al : adminListeners)
      al.edgeRemoved(edge);  clientEdgeChanged(edge); }  @Override
  public void vertexAdded(Vertex vertex) { for (ClientListener al : adminListeners)
      al.vertexAdded(vertex);  clientVertexChanged(vertex, false); }  @Override
  public void vertexPropertyChanged(Vertex vertex, String key, Object oldValue, Object setValue) { for (ClientListener al : adminListeners)
      al.vertexPropertyChanged(vertex, key, oldValue, setValue);  boolean pvt = (key.equals(""private"") || key.equals(""choices"") || key.equals(""text"")); clientVertexChanged(vertex, pvt); }  @Override
  public void vertexPropertyRemoved(Vertex vertex, String key, Object removedValue) { for (ClientListener al : adminListeners)
      al.vertexPropertyRemoved(vertex, key);  boolean pvt = (key.equals(""private"") || key.equals(""choices"") || key.equals(""text"")); clientVertexChanged(vertex, pvt); }  @Override
  public void vertexRemoved(Vertex vertex, Map<String, Object> props) { for (ClientListener al : adminListeners)
      al.vertexRemoved(vertex);  clientVertexChanged(vertex, false); }  private void clientEdgePropertyChanged(Edge edge, String key, Object value) { // inProps are only visible by the inVertex and outProps are only visible by the outVertex if (key.equals(""inProps"")) { Vertex inVertex = edge.getVertex(Direction.IN); String inId = (String) inVertex.getId(); if (clientListeners.containsKey(inId)) { Client inClient = clientListeners.get(inId); inClient.updateGraph(inVertex); } } else if (key.equals(""outProps"")) { Vertex outVertex = edge.getVertex(Direction.OUT); String outId = (String) outVertex.getId(); if (clientListeners.containsKey(outId)) { Client outClient = clientListeners.get(outId); outClient.updateGraph(outVertex); } } else { clientEdgeChanged(edge); } }  private void clientEdgeChanged(Edge edge) { Vertex[] vertices = getVerticesByEdge(edge);  String id1 = (String) vertices[0].getId(); String id2 = (String) vertices[1].getId();  if (clientListeners.containsKey(id1)) { Client c1 = clientListeners.get(id1); c1.updateGraph(vertices[0]); }  if (clientListeners.containsKey(id2)) { Client c2 = clientListeners.get(id2); c2.updateGraph(vertices[1]); } }  private void clientVertexChanged(Vertex vertex, boolean pvt) { // The vertex itself String id = (String) vertex.getId(); if (clientListeners.containsKey(id)) { clientListeners.get(id).updateGraph(vertex); } // And all neighbors, if it isn't a private property if (!pvt) { for (Vertex v : vertex.getVertices(Direction.BOTH)) { id = (String) v.getId(); if (clientListeners.containsKey(id)) { clientListeners.get(id).updateGraph(v); } } } }  private Vertex[] getVerticesByEdge(Edge edge) { Vertex[] returnArray = new Vertex[2]; returnArray[0] = edge.getVertex(Direction.IN); returnArray[1] = edge.getVertex(Direction.OUT); return returnArray; } }  "
app/models/EventTracker.java,"package models;

import com.fasterxml.jackson.annotation.JsonIgnore;
import play.Logger;

import java.util.*;

public class EventTracker {

  @JsonIgnore
  private ExperimentInstance experimentInstance;
  private boolean enabled = true;

  public ExperimentInstance getExperimentInstance() {
    return experimentInstance;
  }

  public void enable() {
    enabled = true;
  }

  public void disable() {
    enabled = false;
  }

  public void setExperimentInstance(ExperimentInstance experimentInstance) {
    this.experimentInstance = experimentInstance;
  }

  public void track(String name, LinkedHashMap<Object, Object> data) {
    List<Map<String, String>> nameValues = new ArrayList<>();

    for (Object key : data.keySet()) {
      Map<String, String> dataMap = new HashMap<>();
      dataMap.put(""name"", key.toString());
      dataMap.put(""value"", (data.get(key) == null) ? ""null"" : data.get(key).toString());
      nameValues.add(dataMap);
    }

    this.track(name, nameValues);
  }

  public void track(String name, List<Map<String, String>> nameValues) {
    if (!enabled) {
      return;
    }
    if (experimentInstance == null) {
      Logger.warn(""No experimentInstance. Skips event tracking."");
      return;
    }
    Event event = new Event();
    event.name = name;
    event.experimentInstance = experimentInstance;
    for (Map<String, String> nameValue : nameValues) {
      EventData eventData = new EventData();
      eventData.name = nameValue.get(""name"");
      eventData.value = nameValue.get(""value"");
      event.addEventData(eventData);
    }
    event.save();
  }
}
","package models; public class EventTracker { @JsonIgnore
  private ExperimentInstance experimentInstance; private boolean enabled = true; public ExperimentInstance getExperimentInstance() { return experimentInstance; } public void enable() { enabled = true; } public void disable() { enabled = false; } public void setExperimentInstance(ExperimentInstance experimentInstance) { this.experimentInstance = experimentInstance; } public void track(String name, LinkedHashMap<Object, Object> data) { List<Map<String, String>> nameValues = new ArrayList<>(); for (Object key : data.keySet()) { Map<String, String> dataMap = new HashMap<>(); dataMap.put(""name"", key.toString()); dataMap.put(""value"", (data.get(key) == null) ? ""null"" : data.get(key).toString()); nameValues.add(dataMap); } this.track(name, nameValues); } public void track(String name, List<Map<String, String>> nameValues) { if (!enabled) { return; } if (experimentInstance == null) { return; } Event event = new Event(); event.name = name; event.experimentInstance = experimentInstance; for (Map<String, String> nameValue : nameValues) { EventData eventData = new EventData(); eventData.name = nameValue.get(""name""); eventData.value = nameValue.get(""value""); event.addEventData(eventData); } event.save(); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; public class EventTracker { @JsonIgnore
  private ExperimentInstance experimentInstance; private boolean enabled = true; public ExperimentInstance getExperimentInstance() { return experimentInstance; } public void enable() { enabled = true; } public void disable() { enabled = false; } public void setExperimentInstance(ExperimentInstance experimentInstance) { this.experimentInstance = experimentInstance; } public void track(String name, LinkedHashMap<Object, Object> data) { List<Map<String, String>> nameValues = new ArrayList<>(); for (Object key : data.keySet()) { Map<String, String> dataMap = new HashMap<>(); dataMap.put(""name"", key.toString()); dataMap.put(""value"", (data.get(key) == null) ? ""null"" : data.get(key).toString()); nameValues.add(dataMap); } this.track(name, nameValues); } public void track(String name, List<Map<String, String>> nameValues) { if (!enabled) { return; } if (experimentInstance == null) { <FILL_ME> return; } Event event = new Event(); event.name = name; event.experimentInstance = experimentInstance; for (Map<String, String> nameValue : nameValues) { EventData eventData = new EventData(); eventData.name = nameValue.get(""name""); eventData.value = nameValue.get(""value""); event.addEventData(eventData); } event.save(); } } ","package models; 
import com.fasterxml.jackson.annotation.JsonIgnore; import play.Logger; 
import java.util.*;  public class EventTracker {  @JsonIgnore
  private ExperimentInstance experimentInstance; private boolean enabled = true;  public ExperimentInstance getExperimentInstance() { return experimentInstance; }  public void enable() { enabled = true; }  public void disable() { enabled = false; }  public void setExperimentInstance(ExperimentInstance experimentInstance) { this.experimentInstance = experimentInstance; }  public void track(String name, LinkedHashMap<Object, Object> data) { List<Map<String, String>> nameValues = new ArrayList<>();  for (Object key : data.keySet()) { Map<String, String> dataMap = new HashMap<>(); dataMap.put(""name"", key.toString()); dataMap.put(""value"", (data.get(key) == null) ? ""null"" : data.get(key).toString()); nameValues.add(dataMap); }  this.track(name, nameValues); }  public void track(String name, List<Map<String, String>> nameValues) { if (!enabled) { return; } if (experimentInstance == null) { <FILL_ME> return; } Event event = new Event(); event.name = name; event.experimentInstance = experimentInstance; for (Map<String, String> nameValue : nameValues) { EventData eventData = new EventData(); eventData.name = nameValue.get(""name""); eventData.value = nameValue.get(""value""); event.addEventData(eventData); } event.save(); } }  "
app/models/Experiment.java,"package models;

import com.avaje.ebean.Ebean;
import com.avaje.ebean.annotation.ConcurrencyMode;
import com.avaje.ebean.annotation.EntityConcurrencyMode;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonValue;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import controllers.ExperimentController;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import play.Logger;
import play.Play;
import play.data.format.Formats;
import play.data.validation.Constraints;
import play.db.ebean.Model;
import play.libs.Json;

import javax.persistence.*;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.UUID;

@Entity
@EntityConcurrencyMode(ConcurrencyMode.NONE)
@Table(name = ""experiments"")
public class Experiment extends Model {
  @Id
  public Long id;

  @Constraints.Required
  @Formats.NonEmpty
  public String name;

  public String uid;

  @OneToMany(cascade = CascadeType.ALL)
  @OrderBy(""name asc"")
  private List<Step> steps = new ArrayList<>();

  @OneToMany(cascade = CascadeType.ALL)
  public List<Content> content = new ArrayList<>();

  @OneToMany(cascade = CascadeType.ALL)
  public List<Parameter> parameters = new ArrayList<>();

  @JsonIgnore
  public ContentFetcher contentFetcher = new ContentFetcher(this);

  @OneToMany(cascade = CascadeType.ALL)
  public List<ExperimentInstance> instances = new ArrayList<>();

  @OneToMany(cascade = CascadeType.ALL)
  public List<Image> images = new ArrayList<>();

  @ManyToMany
  @JoinTable(name = ""experiments_languages"")
  public List<Language> languages = new ArrayList<>();

  public static final Long TEST_INSTANCE_ID = 0L;
  public ExperimentInstance TEST_INSTANCE = null;

  // The AMT QualificationTypeId for the Previous Worker qualification specific to this experiment type.
  public String qualificationTypeId;

  // QualificationTypeId in the AMT Sandbox
  public String qualificationTypeIdSandbox;

  public static final String ON_JOIN_STEP_NAME = ""OnJoinStep"";
  public static final String ON_LEAVE_STEP_NAME = ""OnLeaveStep"";

  public Boolean fileMode;

  /*
   * The CSS Style for the experiment
   */
  @Column(columnDefinition = ""text"")
  public String style = """";

  /*
   * The HTML + JavaScript for the client.
   */
  @Column(columnDefinition = ""text"")
  public String clientHtml = """";

  /*
   * The client-graph.js for the client.
   */
  @Column(columnDefinition = ""text"")
  public String clientGraph = """";

  @JsonIgnore
  public static Model.Finder<Long, Experiment> find = new Model.Finder(Long.class, Experiment.class);

  public static List<Experiment> findAll() {
    return find.all();
  }

  public static Experiment findByName(String name) {
    return find.where().eq(""name"", name).findUnique();
  }

  public static Experiment findByUid(String uid) {
    return find.where().eq(""uid"", uid).findUnique();
  }

  public static Experiment findById(Long id) {
    return find.where().eq(""id"", id).findUnique();
  }

  public ExperimentInstance getTestInstance() {
    if (TEST_INSTANCE == null) {
      TEST_INSTANCE = new ExperimentInstance(""TESTING"", this);
      TEST_INSTANCE.status = ExperimentInstance.Status.TESTING;
      TEST_INSTANCE.id = TEST_INSTANCE_ID;
    }
    return TEST_INSTANCE;
  }

  public Experiment() {
    this.uid = UUID.randomUUID().toString();
  }

  public Experiment(String uid) {
    this.uid = uid;
  }

  /**
   * Copy constructor. Everything is copied except the experimentInstances and name.
   *
   * @param experiment the experiment to be copied from
   */
  public Experiment(Experiment experiment) {
    this.uid = UUID.randomUUID().toString();
    this.style = experiment.getStyle();
    this.clientHtml = experiment.getClientHtml();
    this.clientGraph = experiment.getClientGraph();

    for (Step step : experiment.getSteps()) {
      this.steps.add(new Step(step));
    }
    for (Content c : experiment.getContent()) {
      this.content.add(new Content(c));
    }
    for (Parameter param : experiment.getParameters()) {
      this.parameters.add(new Parameter(param));
    }
    for (Image image : experiment.getImages()) {
      this.images.add(new Image(image));
    }
    for(Language language : experiment.languages) {
      this.languages.add(language);
    }
  }

  public String getDirectoryName() {
    String returnString = StringUtils.replace(this.name, "" "", ""-"").concat(""_"").concat(this.id.toString());
    return returnString;
  }

  public void setFileMode(Boolean fileMode) {
    this.fileMode = fileMode;
  }

  public List<Image> getImages() {
    if (this.fileMode) {
      ArrayList<Image> returnImages = new ArrayList<>();
      File imagesDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName() + ""/Images"");
      if (imagesDirectory.isDirectory()) {
        try {
          returnImages = ExperimentController.getImagesFromDirectory(imagesDirectory);
        } catch (IOException ioe) {
          Logger.error(""Error reading images from "" + imagesDirectory + "", check your permissions."");
          Logger.debug(ioe.getMessage());;
        }
      }
      return returnImages;
    }
    return this.images;
  }

  public List<Content> getContent() {
    if (this.fileMode) {
      ArrayList<Content> returnContent = new ArrayList<>();
      File contentDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName() + ""/Content"");
      if (contentDirectory.isDirectory()) {
        try {
          returnContent = ExperimentController.getContentFromDirectory(contentDirectory);
        } catch (IOException ioe) {
          Logger.error(""Error reading Content from "" + contentDirectory + "", check your permissions."");
          Logger.debug(ioe.getMessage());;
        }
      }
      return returnContent;

    }
    return this.content;
  }

  public void removeContent() {
    Iterator<Content> iter = this.content.iterator();
    while (iter.hasNext()) {
      Content c = iter.next();
      iter.remove();
      c.delete();
    }
    this.update();
  }

  public void removeImages() {
    Iterator<Image> iter = this.images.iterator();
    while (iter.hasNext()) {
      Image i = iter.next();
      iter.remove();
      i.delete();
    }
    this.update();
  }

  public String getStyle() {
    if (this.fileMode) {
      String returnStyle = """";
      try {
        File devDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName());
        returnStyle = FileUtils.readFileToString(new File(devDirectory, ""style.css""));
      } catch (IOException ioe) {
        Logger.error(""Error reading style.css file from the dev directory, check your permissions."");
        Logger.debug(ioe.getMessage());;
      }
      return returnStyle;
    } else {
      return this.style;
    }
  }

  public String getClientHtml() {
    if (this.fileMode) {
      String returnClientHtml = """";
      try {
        File devDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName());
        returnClientHtml = FileUtils.readFileToString(new File(devDirectory, ""client-html.html""));
      } catch (IOException ioe) {
        Logger.error(""Error reading client-html.html file from the dev directory, check your permissions."");
        Logger.debug(ioe.getMessage());;
      }
      return returnClientHtml;
    } else {
      return this.clientHtml;
    }
  }

  public String getClientGraph() {
    if (this.fileMode) {
      String returnClientGraph = """";
      try {
        File devDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName());
        returnClientGraph = FileUtils.readFileToString(new File(devDirectory, ""client-graph.js""));
      } catch (IOException ioe) {
        Logger.error(""Error reading client-graph.js file from the dev directory, check your permissions."");
        Logger.debug(ioe.getMessage());;
      }
      return returnClientGraph;
    } else {
      return this.clientGraph;
    }
  }

  public List<Step> getSteps() {
    if (this.fileMode) {
      ArrayList<Step> returnSteps = new ArrayList<>();
      File stepsDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName() + ""/steps"");
      try {
        returnSteps = ExperimentController.getStepsFromDirectory(stepsDirectory);
      } catch (IOException ioe) {
        Logger.error(""Error reading Steps from "" + stepsDirectory + "", check your permissions."");
        Logger.debug(ioe.getMessage());;
      }
      return returnSteps;
    } else {
      return this.steps;
    }
  }

  public void addStep(Step step) {
    this.steps.add(step);
  }

  public void removeSteps() {
    Iterator<Step> iter = this.steps.iterator();
    while (iter.hasNext()) {
      Step s = iter.next();
      iter.remove();
      s.delete();
    }
    this.update();
  }

  public void toggleFileMode(User user) {
    File experimentDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName());
    try {
      if (this.fileMode) {
        // Turning fileMode off, let's import the files into the current experiment
        ExperimentController.importExperimentFromDirectory(this.id, user, experimentDirectory);
      } else {
        // Turning fileMode on, let's export the experiment into the appropriate directory
        ExperimentController.exportExperimentToDirectory(this.id, experimentDirectory);
      }
      this.setFileMode(!this.fileMode);
      this.save();
    } catch (IOException ioe) {
      Logger.error(""Unable to access "" + experimentDirectory + "", check your file permissions."", ioe);
      // if (Logger.canLog(Logger.DEBUG)) {
      //   ioe.printStackTrace(Logger);
      // }
    }
  }

  public String parametersToCsv() {
    CSVFormat format = CSVFormat.DEFAULT.withHeader(""Name"", ""Type"", ""Min."", ""Max."", ""Default"", ""Short Description"");
    StringBuilder stringBuilder = new StringBuilder();
    try {
      CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, format);
      for (Parameter param : getParameters()) {
        csvPrinter.printRecord(param.name, param.type, param.minVal, param.maxVal, param.defaultVal, param.description);
      }
    } catch (IOException ioe) {}
    return stringBuilder.toString();
  }

  public void export() throws IOException {
    File experimentDirectory = new File(Play.application().path().toString() + ""/experiments/"" + this.name);
    FileUtils.writeStringToFile(new File(experimentDirectory, ""style.css""), this.getStyle());
    FileUtils.writeStringToFile(new File(experimentDirectory, ""client.html""), this.getClientHtml());
    FileUtils.writeStringToFile(new File(experimentDirectory, ""client-graph.js""), this.getClientGraph());

    File stepsDirectory = new File(experimentDirectory, ""/Steps"");
    for (Step step : this.getSteps()) {
      FileUtils.writeStringToFile(new File(stepsDirectory, step.name.concat("".groovy"")), step.source);
    }

    File contentDirectory = new File(experimentDirectory, ""/Content"");
    for (Content c : this.getContent()) {
      // Write to a subdirectory based on the language of the Content or 'en' if language is undefined
      for (Translation t : c.translations) {
        String language = (t.language == null) ? ""en"" : t.language.code;
        File languageDirectory = new File(contentDirectory, ""/"" + language);
        FileUtils.writeStringToFile(new File(languageDirectory, c.name.concat("".html"")), t.html);
      }
    }

    String ls = System.getProperty(""line.separator"");
    File parametersFile = new File(experimentDirectory, ""parameters.csv"");
    FileUtils.writeStringToFile(parametersFile, ""Name,Type,Min.,Max.,Default,Short Description"" + ls);
    for (Parameter param : this.getParameters()) {
      FileUtils.writeStringToFile(parametersFile, param.name + "","" + param.type + "","" + param.minVal + "","" + param.maxVal + "","" + param.defaultVal + "","" + param.description + ls, true);
    }

    File imagesDirectory = new File(experimentDirectory, ""/Images"");
    for (Image image : this.getImages()) {
      FileUtils.writeByteArrayToFile(new File(imagesDirectory, image.fileName), image.file);
    }
  }

  public static String defaultClientHTML() {
    String contents = """";
    try {
      InputStream defaultClientHtml = Play.application().resourceAsStream(""defaults/client-html.html"");
      if (defaultClientHtml == null) defaultClientHtml = Play.application().resourceAsStream(""defaults/default-client-html.html"");

      if (defaultClientHtml == null) {
        Logger.error(""Couldn't find the conf/defaults/default-client-html.html file."");
      } else {
        contents = IOUtils.toString(defaultClientHtml);
      }
    } catch(IOException e){
      Logger.error(""Error reading the conf/defaults/client-html.html file."");
    }
    return contents;
  }

  public static String defaultClientGraph() {
    String contents = """";
    try {
      InputStream defaultClientGraph = Play.application().resourceAsStream(""defaults/client-graph.js"");
      if (defaultClientGraph == null) defaultClientGraph = Play.application().resourceAsStream(""defaults/default-client-graph.js"");

      if (defaultClientGraph == null) {
        Logger.error(""Couldn't find the conf/defaults/default-client-graph.js file."");
      } else {
        contents = IOUtils.toString(defaultClientGraph);
      }
    } catch(IOException e){
      Logger.error(""Error reading the conf/defaults/default-client-graph.js file."");
    }
    return contents;
  }

  public static Step generateOnJoinStep() {
    Step onJoin = new Step();
    onJoin.name = ""OnJoinStep"";
    onJoin.source = ""onJoinStep = stepFactory.createNoUserActionStep()\n"" +
        ""\n"" +
        ""onJoinStep.run = { playerId->\n"" +
        ""  println \""onJoinStep.run\""\n"" +
        ""  def player = g.getVertex(playerId)\n"" +
        ""}"" +
        ""\n"" +
        ""onJoinStep.done = {\n"" +
        ""  println \""onJoinStep.done\""\n"" +
        ""}"";

    return onJoin;
  }

  public static Step generateOnLeaveStep() {
    Step onLeave = new Step();
    onLeave.name = ""OnLeaveStep"";
    onLeave.source = ""onLeaveStep = stepFactory.createNoUserActionStep()\n"" +
        ""\n"" +
        ""onLeaveStep.run = {\n"" +
        ""  println \""onLeaveStep.run\""\n"" +
        ""}"" +
        ""\n"" +
        ""onLeaveStep.done = {\n"" +
        ""  println \""onLeaveStep.done\""\n"" +
        ""}"";
    return onLeave;
  }

  public static Step generateInitStep() {
    Step init = new Step();
    init.name = ""InitStep"";
    init.source = ""initStep = stepFactory.createStep(\""InitStep\"")\n"" +
        ""\n"" +
        ""initStep.run = {\n"" +
        ""  println \""initStep.run\""\n"" +
        ""}"" +
        ""\n"" +
        ""initStep.done = {\n"" +
        ""  println \""initStep.done\""\n"" +
        ""}"";
    return init;
  }

  @Override
  public void delete() {
    Ebean.createSqlUpdate(""delete from experiments_languages where experiments_id = :experimentId"")
        .setParameter(""experimentId"", this.id)
        .execute();

    for (Step s : steps) {
      s.delete();
    }
    for (Content c : content) {
      c.delete();
    }
    for (Parameter p : parameters) {
      p.delete();
    }
    for (ExperimentInstance ei : instances) {
      ei.delete();
    }
    for (Image i : images) {
      i.delete();
    }
    super.delete();
  }

  public void setStyle(String style) {
    this.style = style;
  }

  public void setClientHtml(String clientHtml) {
    this.clientHtml = clientHtml;
  }

  public void setClientGraph(String clientGraph) {
    this.clientGraph = clientGraph;
  }

  public Content getExperimentContent(Long id) {
    for (Content c : content) {
      if (c.id.equals(id))
        return c;
    }
    return null;
  }

  public Content getContentByName(String name) {
    for (Content c : content) {
      if (c.name.equals(name))
        return c;
    }
    return null;
  }

  public Parameter getParameterByName(String name) {
    for (Parameter p : parameters) {
      if (p.name.equals(name))
        return p;
    }
    return null;
  }

  public List<Parameter> getParameters() {
    if (this.fileMode) {
      ArrayList<Parameter> returnParameters = new ArrayList<>();
      File parameterFile = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName() + ""/parameters.csv"");
      try {
        returnParameters = ExperimentController.getParametersFromFile(parameterFile);
      } catch (IOException ioe) {
        Logger.error(""Error reading "" + parameterFile + "" from the dev directory, check your permissions."");
        Logger.debug(ioe.getMessage());;
      }
      return returnParameters;

    }
    return this.parameters;
  }

  public void removeParameters() {
    Iterator<Parameter> iter = this.parameters.iterator();
    while (iter.hasNext()) {
      Parameter p = iter.next();
      iter.remove();
      p.delete();
    }
    this.update();
  }

  public boolean hasOnJoinStep() {
    return getOnJoinStep() != null;
  }

  public boolean hasOnLeaveStep() {
    return getOnLeaveStep() != null;
  }

  public Step getOnJoinStep() {
    for (Step step : this.getSteps()) {
      if (ON_JOIN_STEP_NAME.equalsIgnoreCase(step.name)) {
        return step;
      }
    }
    return null;
  }

  public Step getOnLeaveStep() {
    for (Step step : this.getSteps()) {
      if (ON_LEAVE_STEP_NAME.equalsIgnoreCase(step.name)) {
        return step;
      }
    }
    return null;
  }

  @JsonValue
  public ObjectNode toJson() {
    ObjectNode experiment = Json.newObject();

    experiment.put(""id"", id);
    experiment.put(""name"", name);
    experiment.put(""uid"", uid);
    experiment.put(""fileMode"", fileMode);

    ArrayNode jsonSteps = experiment.putArray(""steps"");
    for (Step s : getSteps()) {
      jsonSteps.add(s.toJson());
    }

    ArrayNode jsonLanguages = experiment.putArray(""languages"");
    for (Language l : languages) {
      jsonLanguages.add(l.toJson());
    }

    ArrayNode jsonContent = experiment.putArray(""content"");
    for (Content c : getContent()) {
      jsonContent.add(c.toJson());
    }

    ArrayNode jsonParameters = experiment.putArray(""parameters"");
    for (Parameter p : getParameters()) {
      jsonParameters.add(p.toJson());
    }

    ArrayNode jsonInstances = experiment.putArray(""instances"");
    for (ExperimentInstance ei : instances) {
      // Only return the name and ID of the instances
      // TODO: Perhaps add the Date/Time of the instance here as well
      jsonInstances.add(ei.toJsonStub());
    }

    ArrayNode jsonImages = experiment.putArray(""images"");
    for (Image i : getImages()) {
      jsonImages.add(i.toJson());
    }

    experiment.put(""style"", getStyle());
    experiment.put(""clientGraphHash"", getClientGraph().hashCode());
    experiment.put(""clientHtmlHash"", getClientHtml().hashCode());

    return experiment;
  }

  public String toString() {
    return ""Experiment("" + id + "")"";
  }
}

","package models; @Entity
@EntityConcurrencyMode(ConcurrencyMode.NONE)
@Table(name = ""experiments"")
public class Experiment extends Model { @Id
  public Long id; @Constraints.Required
  @Formats.NonEmpty
  public String name; public String uid; @OneToMany(cascade = CascadeType.ALL)
  @OrderBy(""name asc"")
  private List<Step> steps = new ArrayList<>(); @OneToMany(cascade = CascadeType.ALL)
  public List<Content> content = new ArrayList<>(); @OneToMany(cascade = CascadeType.ALL)
  public List<Parameter> parameters = new ArrayList<>(); @JsonIgnore
  public ContentFetcher contentFetcher = new ContentFetcher(this); @OneToMany(cascade = CascadeType.ALL)
  public List<ExperimentInstance> instances = new ArrayList<>(); @OneToMany(cascade = CascadeType.ALL)
  public List<Image> images = new ArrayList<>(); @ManyToMany
  @JoinTable(name = ""experiments_languages"")
  public List<Language> languages = new ArrayList<>(); public static final Long TEST_INSTANCE_ID = 0L; public ExperimentInstance TEST_INSTANCE = null; public String qualificationTypeId; public String qualificationTypeIdSandbox; public static final String ON_JOIN_STEP_NAME = ""OnJoinStep""; public static final String ON_LEAVE_STEP_NAME = ""OnLeaveStep""; public Boolean fileMode; @Column(columnDefinition = ""text"")
  public String style = """"; @Column(columnDefinition = ""text"")
  public String clientHtml = """"; @Column(columnDefinition = ""text"")
  public String clientGraph = """"; @JsonIgnore
  public static Model.Finder<Long, Experiment> find = new Model.Finder(Long.class, Experiment.class); public static List<Experiment> findAll() { return find.all(); } public static Experiment findByName(String name) { return find.where().eq(""name"", name).findUnique(); } public static Experiment findByUid(String uid) { return find.where().eq(""uid"", uid).findUnique(); } public static Experiment findById(Long id) { return find.where().eq(""id"", id).findUnique(); } public ExperimentInstance getTestInstance() { if (TEST_INSTANCE == null) { TEST_INSTANCE = new ExperimentInstance(""TESTING"", this); TEST_INSTANCE.status = ExperimentInstance.Status.TESTING; TEST_INSTANCE.id = TEST_INSTANCE_ID; } return TEST_INSTANCE; } public Experiment() { this.uid = UUID.randomUUID().toString(); } public Experiment(String uid) { this.uid = uid; } public Experiment(Experiment experiment) { this.uid = UUID.randomUUID().toString(); this.style = experiment.getStyle(); this.clientHtml = experiment.getClientHtml(); this.clientGraph = experiment.getClientGraph(); for (Step step : experiment.getSteps()) { this.steps.add(new Step(step)); } for (Content c : experiment.getContent()) { this.content.add(new Content(c)); } for (Parameter param : experiment.getParameters()) { this.parameters.add(new Parameter(param)); } for (Image image : experiment.getImages()) { this.images.add(new Image(image)); } for(Language language : experiment.languages) { this.languages.add(language); } } public String getDirectoryName() { String returnString = StringUtils.replace(this.name, "" "", ""-"").concat(""_"").concat(this.id.toString()); return returnString; } public void setFileMode(Boolean fileMode) { this.fileMode = fileMode; } public List<Image> getImages() { if (this.fileMode) { ArrayList<Image> returnImages = new ArrayList<>(); File imagesDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName() + ""/Images""); if (imagesDirectory.isDirectory()) { try { returnImages = ExperimentController.getImagesFromDirectory(imagesDirectory); } catch (IOException ioe) { ; } } return returnImages; } return this.images; } public List<Content> getContent() { if (this.fileMode) { ArrayList<Content> returnContent = new ArrayList<>(); File contentDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName() + ""/Content""); if (contentDirectory.isDirectory()) { try { returnContent = ExperimentController.getContentFromDirectory(contentDirectory); } catch (IOException ioe) { ; } } return returnContent; } return this.content; } public void removeContent() { Iterator<Content> iter = this.content.iterator(); while (iter.hasNext()) { Content c = iter.next(); iter.remove(); c.delete(); } this.update(); } public void removeImages() { Iterator<Image> iter = this.images.iterator(); while (iter.hasNext()) { Image i = iter.next(); iter.remove(); i.delete(); } this.update(); } public String getStyle() { if (this.fileMode) { String returnStyle = """"; try { File devDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName()); returnStyle = FileUtils.readFileToString(new File(devDirectory, ""style.css"")); } catch (IOException ioe) { ; } return returnStyle; } else { return this.style; } } public String getClientHtml() { if (this.fileMode) { String returnClientHtml = """"; try { File devDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName()); returnClientHtml = FileUtils.readFileToString(new File(devDirectory, ""client-html.html"")); } catch (IOException ioe) { ; } return returnClientHtml; } else { return this.clientHtml; } } public String getClientGraph() { if (this.fileMode) { String returnClientGraph = """"; try { File devDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName()); returnClientGraph = FileUtils.readFileToString(new File(devDirectory, ""client-graph.js"")); } catch (IOException ioe) { ; } return returnClientGraph; } else { return this.clientGraph; } } public List<Step> getSteps() { if (this.fileMode) { ArrayList<Step> returnSteps = new ArrayList<>(); File stepsDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName() + ""/steps""); try { returnSteps = ExperimentController.getStepsFromDirectory(stepsDirectory); } catch (IOException ioe) { ; } return returnSteps; } else { return this.steps; } } public void addStep(Step step) { this.steps.add(step); } public void removeSteps() { Iterator<Step> iter = this.steps.iterator(); while (iter.hasNext()) { Step s = iter.next(); iter.remove(); s.delete(); } this.update(); } public void toggleFileMode(User user) { File experimentDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName()); try { if (this.fileMode) { ExperimentController.importExperimentFromDirectory(this.id, user, experimentDirectory); } else { ExperimentController.exportExperimentToDirectory(this.id, experimentDirectory); } this.setFileMode(!this.fileMode); this.save(); } catch (IOException ioe) { } } public String parametersToCsv() { CSVFormat format = CSVFormat.DEFAULT.withHeader(""Name"", ""Type"", ""Min."", ""Max."", ""Default"", ""Short Description""); StringBuilder stringBuilder = new StringBuilder(); try { CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, format); for (Parameter param : getParameters()) { csvPrinter.printRecord(param.name, param.type, param.minVal, param.maxVal, param.defaultVal, param.description); } } catch (IOException ioe) { } return stringBuilder.toString(); } public void export() throws IOException { File experimentDirectory = new File(Play.application().path().toString() + ""/experiments/"" + this.name); FileUtils.writeStringToFile(new File(experimentDirectory, ""style.css""), this.getStyle()); FileUtils.writeStringToFile(new File(experimentDirectory, ""client.html""), this.getClientHtml()); FileUtils.writeStringToFile(new File(experimentDirectory, ""client-graph.js""), this.getClientGraph()); File stepsDirectory = new File(experimentDirectory, ""/Steps""); for (Step step : this.getSteps()) { FileUtils.writeStringToFile(new File(stepsDirectory, step.name.concat("".groovy"")), step.source); } File contentDirectory = new File(experimentDirectory, ""/Content""); for (Content c : this.getContent()) { for (Translation t : c.translations) { String language = (t.language == null) ? ""en"" : t.language.code; File languageDirectory = new File(contentDirectory, ""/"" + language); FileUtils.writeStringToFile(new File(languageDirectory, c.name.concat("".html"")), t.html); } } String ls = System.getProperty(""line.separator""); File parametersFile = new File(experimentDirectory, ""parameters.csv""); FileUtils.writeStringToFile(parametersFile, ""Name,Type,Min.,Max.,Default,Short Description"" + ls); for (Parameter param : this.getParameters()) { FileUtils.writeStringToFile(parametersFile, param.name + "","" + param.type + "","" + param.minVal + "","" + param.maxVal + "","" + param.defaultVal + "","" + param.description + ls, true); } File imagesDirectory = new File(experimentDirectory, ""/Images""); for (Image image : this.getImages()) { FileUtils.writeByteArrayToFile(new File(imagesDirectory, image.fileName), image.file); } } public static String defaultClientHTML() { String contents = """"; try { InputStream defaultClientHtml = Play.application().resourceAsStream(""defaults/client-html.html""); if (defaultClientHtml == null) defaultClientHtml = Play.application().resourceAsStream(""defaults/default-client-html.html""); if (defaultClientHtml == null) { } else { contents = IOUtils.toString(defaultClientHtml); } } catch(IOException e){ } return contents; } public static String defaultClientGraph() { String contents = """"; try { InputStream defaultClientGraph = Play.application().resourceAsStream(""defaults/client-graph.js""); if (defaultClientGraph == null) defaultClientGraph = Play.application().resourceAsStream(""defaults/default-client-graph.js""); if (defaultClientGraph == null) { } else { contents = IOUtils.toString(defaultClientGraph); } } catch(IOException e){ } return contents; } public static Step generateOnJoinStep() { Step onJoin = new Step(); onJoin.name = ""OnJoinStep""; onJoin.source = ""onJoinStep = stepFactory.createNoUserActionStep()\n"" +
        ""\n"" +
        ""onJoinStep.run = { playerId->\n"" +
        ""  println \""onJoinStep.run\""\n"" +
        ""  def player = g.getVertex(playerId)\n"" +
        ""} "" +
        ""\n"" +
        ""onJoinStep.done = { \n"" +
        ""  println \""onJoinStep.done\""\n"" +
        ""} ""; return onJoin; } public static Step generateOnLeaveStep() { Step onLeave = new Step(); onLeave.name = ""OnLeaveStep""; onLeave.source = ""onLeaveStep = stepFactory.createNoUserActionStep()\n"" +
        ""\n"" +
        ""onLeaveStep.run = { \n"" +
        ""  println \""onLeaveStep.run\""\n"" +
        ""} "" +
        ""\n"" +
        ""onLeaveStep.done = { \n"" +
        ""  println \""onLeaveStep.done\""\n"" +
        ""} ""; return onLeave; } public static Step generateInitStep() { Step init = new Step(); init.name = ""InitStep""; init.source = ""initStep = stepFactory.createStep(\""InitStep\"")\n"" +
        ""\n"" +
        ""initStep.run = { \n"" +
        ""  println \""initStep.run\""\n"" +
        ""} "" +
        ""\n"" +
        ""initStep.done = { \n"" +
        ""  println \""initStep.done\""\n"" +
        ""} ""; return init; } @Override
  public void delete() { Ebean.createSqlUpdate(""delete from experiments_languages where experiments_id = :experimentId"")
        .setParameter(""experimentId"", this.id)
        .execute(); for (Step s : steps) { s.delete(); } for (Content c : content) { c.delete(); } for (Parameter p : parameters) { p.delete(); } for (ExperimentInstance ei : instances) { ei.delete(); } for (Image i : images) { i.delete(); } super.delete(); } public void setStyle(String style) { this.style = style; } public void setClientHtml(String clientHtml) { this.clientHtml = clientHtml; } public void setClientGraph(String clientGraph) { this.clientGraph = clientGraph; } public Content getExperimentContent(Long id) { for (Content c : content) { if (c.id.equals(id))
        return c; } return null; } public Content getContentByName(String name) { for (Content c : content) { if (c.name.equals(name))
        return c; } return null; } public Parameter getParameterByName(String name) { for (Parameter p : parameters) { if (p.name.equals(name))
        return p; } return null; } public List<Parameter> getParameters() { if (this.fileMode) { ArrayList<Parameter> returnParameters = new ArrayList<>(); File parameterFile = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName() + ""/parameters.csv""); try { returnParameters = ExperimentController.getParametersFromFile(parameterFile); } catch (IOException ioe) { ; } return returnParameters; } return this.parameters; } public void removeParameters() { Iterator<Parameter> iter = this.parameters.iterator(); while (iter.hasNext()) { Parameter p = iter.next(); iter.remove(); p.delete(); } this.update(); } public boolean hasOnJoinStep() { return getOnJoinStep() != null; } public boolean hasOnLeaveStep() { return getOnLeaveStep() != null; } public Step getOnJoinStep() { for (Step step : this.getSteps()) { if (ON_JOIN_STEP_NAME.equalsIgnoreCase(step.name)) { return step; } } return null; } public Step getOnLeaveStep() { for (Step step : this.getSteps()) { if (ON_LEAVE_STEP_NAME.equalsIgnoreCase(step.name)) { return step; } } return null; } @JsonValue
  public ObjectNode toJson() { ObjectNode experiment = Json.newObject(); experiment.put(""id"", id); experiment.put(""name"", name); experiment.put(""uid"", uid); experiment.put(""fileMode"", fileMode); ArrayNode jsonSteps = experiment.putArray(""steps""); for (Step s : getSteps()) { jsonSteps.add(s.toJson()); } ArrayNode jsonLanguages = experiment.putArray(""languages""); for (Language l : languages) { jsonLanguages.add(l.toJson()); } ArrayNode jsonContent = experiment.putArray(""content""); for (Content c : getContent()) { jsonContent.add(c.toJson()); } ArrayNode jsonParameters = experiment.putArray(""parameters""); for (Parameter p : getParameters()) { jsonParameters.add(p.toJson()); } ArrayNode jsonInstances = experiment.putArray(""instances""); for (ExperimentInstance ei : instances) { jsonInstances.add(ei.toJsonStub()); } ArrayNode jsonImages = experiment.putArray(""images""); for (Image i : getImages()) { jsonImages.add(i.toJson()); } experiment.put(""style"", getStyle()); experiment.put(""clientGraphHash"", getClientGraph().hashCode()); experiment.put(""clientHtmlHash"", getClientHtml().hashCode()); return experiment; } public String toString() { return ""Experiment("" + id + "")""; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; @Entity
@EntityConcurrencyMode(ConcurrencyMode.NONE)
@Table(name = ""experiments"")
public class Experiment extends Model { @Id
  public Long id; @Constraints.Required
  @Formats.NonEmpty
  public String name; public String uid; @OneToMany(cascade = CascadeType.ALL)
  @OrderBy(""name asc"")
  private List<Step> steps = new ArrayList<>(); @OneToMany(cascade = CascadeType.ALL)
  public List<Content> content = new ArrayList<>(); @OneToMany(cascade = CascadeType.ALL)
  public List<Parameter> parameters = new ArrayList<>(); @JsonIgnore
  public ContentFetcher contentFetcher = new ContentFetcher(this); @OneToMany(cascade = CascadeType.ALL)
  public List<ExperimentInstance> instances = new ArrayList<>(); @OneToMany(cascade = CascadeType.ALL)
  public List<Image> images = new ArrayList<>(); @ManyToMany
  @JoinTable(name = ""experiments_languages"")
  public List<Language> languages = new ArrayList<>(); public static final Long TEST_INSTANCE_ID = 0L; public ExperimentInstance TEST_INSTANCE = null; public String qualificationTypeId; public String qualificationTypeIdSandbox; public static final String ON_JOIN_STEP_NAME = ""OnJoinStep""; public static final String ON_LEAVE_STEP_NAME = ""OnLeaveStep""; public Boolean fileMode; @Column(columnDefinition = ""text"")
  public String style = """"; @Column(columnDefinition = ""text"")
  public String clientHtml = """"; @Column(columnDefinition = ""text"")
  public String clientGraph = """"; @JsonIgnore
  public static Model.Finder<Long, Experiment> find = new Model.Finder(Long.class, Experiment.class); public static List<Experiment> findAll() { return find.all(); } public static Experiment findByName(String name) { return find.where().eq(""name"", name).findUnique(); } public static Experiment findByUid(String uid) { return find.where().eq(""uid"", uid).findUnique(); } public static Experiment findById(Long id) { return find.where().eq(""id"", id).findUnique(); } public ExperimentInstance getTestInstance() { if (TEST_INSTANCE == null) { TEST_INSTANCE = new ExperimentInstance(""TESTING"", this); TEST_INSTANCE.status = ExperimentInstance.Status.TESTING; TEST_INSTANCE.id = TEST_INSTANCE_ID; } return TEST_INSTANCE; } public Experiment() { this.uid = UUID.randomUUID().toString(); } public Experiment(String uid) { this.uid = uid; } public Experiment(Experiment experiment) { this.uid = UUID.randomUUID().toString(); this.style = experiment.getStyle(); this.clientHtml = experiment.getClientHtml(); this.clientGraph = experiment.getClientGraph(); for (Step step : experiment.getSteps()) { this.steps.add(new Step(step)); } for (Content c : experiment.getContent()) { this.content.add(new Content(c)); } for (Parameter param : experiment.getParameters()) { this.parameters.add(new Parameter(param)); } for (Image image : experiment.getImages()) { this.images.add(new Image(image)); } for(Language language : experiment.languages) { this.languages.add(language); } } public String getDirectoryName() { String returnString = StringUtils.replace(this.name, "" "", ""-"").concat(""_"").concat(this.id.toString()); return returnString; } public void setFileMode(Boolean fileMode) { this.fileMode = fileMode; } public List<Image> getImages() { if (this.fileMode) { ArrayList<Image> returnImages = new ArrayList<>(); File imagesDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName() + ""/Images""); if (imagesDirectory.isDirectory()) { try { returnImages = ExperimentController.getImagesFromDirectory(imagesDirectory); } catch (IOException ioe) { <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> ; } } return returnImages; } return this.images; } public List<Content> getContent() { if (this.fileMode) { ArrayList<Content> returnContent = new ArrayList<>(); File contentDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName() + ""/Content""); if (contentDirectory.isDirectory()) { try { returnContent = ExperimentController.getContentFromDirectory(contentDirectory); } catch (IOException ioe) { ; } } return returnContent; } return this.content; } public void removeContent() { Iterator<Content> iter = this.content.iterator(); while (iter.hasNext()) { Content c = iter.next(); iter.remove(); c.delete(); } this.update(); } public void removeImages() { Iterator<Image> iter = this.images.iterator(); while (iter.hasNext()) { Image i = iter.next(); iter.remove(); i.delete(); } this.update(); } public String getStyle() { if (this.fileMode) { String returnStyle = """"; try { File devDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName()); returnStyle = FileUtils.readFileToString(new File(devDirectory, ""style.css"")); } catch (IOException ioe) { ; } return returnStyle; } else { return this.style; } } public String getClientHtml() { if (this.fileMode) { String returnClientHtml = """"; try { File devDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName()); returnClientHtml = FileUtils.readFileToString(new File(devDirectory, ""client-html.html"")); } catch (IOException ioe) { ; } return returnClientHtml; } else { return this.clientHtml; } } public String getClientGraph() { if (this.fileMode) { String returnClientGraph = """"; try { File devDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName()); returnClientGraph = FileUtils.readFileToString(new File(devDirectory, ""client-graph.js"")); } catch (IOException ioe) { ; } return returnClientGraph; } else { return this.clientGraph; } } public List<Step> getSteps() { if (this.fileMode) { ArrayList<Step> returnSteps = new ArrayList<>(); File stepsDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName() + ""/steps""); try { returnSteps = ExperimentController.getStepsFromDirectory(stepsDirectory); } catch (IOException ioe) { ; } return returnSteps; } else { return this.steps; } } public void addStep(Step step) { this.steps.add(step); } public void removeSteps() { Iterator<Step> iter = this.steps.iterator(); while (iter.hasNext()) { Step s = iter.next(); iter.remove(); s.delete(); } this.update(); } public void toggleFileMode(User user) { File experimentDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName()); try { if (this.fileMode) { ExperimentController.importExperimentFromDirectory(this.id, user, experimentDirectory); } else { ExperimentController.exportExperimentToDirectory(this.id, experimentDirectory); } this.setFileMode(!this.fileMode); this.save(); } catch (IOException ioe) { } } public String parametersToCsv() { CSVFormat format = CSVFormat.DEFAULT.withHeader(""Name"", ""Type"", ""Min."", ""Max."", ""Default"", ""Short Description""); StringBuilder stringBuilder = new StringBuilder(); try { CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, format); for (Parameter param : getParameters()) { csvPrinter.printRecord(param.name, param.type, param.minVal, param.maxVal, param.defaultVal, param.description); } } catch (IOException ioe) { } return stringBuilder.toString(); } public void export() throws IOException { File experimentDirectory = new File(Play.application().path().toString() + ""/experiments/"" + this.name); FileUtils.writeStringToFile(new File(experimentDirectory, ""style.css""), this.getStyle()); FileUtils.writeStringToFile(new File(experimentDirectory, ""client.html""), this.getClientHtml()); FileUtils.writeStringToFile(new File(experimentDirectory, ""client-graph.js""), this.getClientGraph()); File stepsDirectory = new File(experimentDirectory, ""/Steps""); for (Step step : this.getSteps()) { FileUtils.writeStringToFile(new File(stepsDirectory, step.name.concat("".groovy"")), step.source); } File contentDirectory = new File(experimentDirectory, ""/Content""); for (Content c : this.getContent()) { for (Translation t : c.translations) { String language = (t.language == null) ? ""en"" : t.language.code; File languageDirectory = new File(contentDirectory, ""/"" + language); FileUtils.writeStringToFile(new File(languageDirectory, c.name.concat("".html"")), t.html); } } String ls = System.getProperty(""line.separator""); File parametersFile = new File(experimentDirectory, ""parameters.csv""); FileUtils.writeStringToFile(parametersFile, ""Name,Type,Min.,Max.,Default,Short Description"" + ls); for (Parameter param : this.getParameters()) { FileUtils.writeStringToFile(parametersFile, param.name + "","" + param.type + "","" + param.minVal + "","" + param.maxVal + "","" + param.defaultVal + "","" + param.description + ls, true); } File imagesDirectory = new File(experimentDirectory, ""/Images""); for (Image image : this.getImages()) { FileUtils.writeByteArrayToFile(new File(imagesDirectory, image.fileName), image.file); } } public static String defaultClientHTML() { String contents = """"; try { InputStream defaultClientHtml = Play.application().resourceAsStream(""defaults/client-html.html""); if (defaultClientHtml == null) defaultClientHtml = Play.application().resourceAsStream(""defaults/default-client-html.html""); if (defaultClientHtml == null) { <FILL_ME> } else { contents = IOUtils.toString(defaultClientHtml); } } catch(IOException e){ <FILL_ME> <FILL_ME> } return contents; } public static String defaultClientGraph() { String contents = """"; try { InputStream defaultClientGraph = Play.application().resourceAsStream(""defaults/client-graph.js""); if (defaultClientGraph == null) defaultClientGraph = Play.application().resourceAsStream(""defaults/default-client-graph.js""); if (defaultClientGraph == null) { <FILL_ME> } else { contents = IOUtils.toString(defaultClientGraph); } } catch(IOException e){ } return contents; } public static Step generateOnJoinStep() { Step onJoin = new Step(); onJoin.name = ""OnJoinStep""; onJoin.source = ""onJoinStep = stepFactory.createNoUserActionStep()\n"" +
        ""\n"" +
        ""onJoinStep.run = { playerId->\n"" +
        ""  println \""onJoinStep.run\""\n"" +
        ""  def player = g.getVertex(playerId)\n"" +
        ""} "" +
        ""\n"" +
        ""onJoinStep.done = { \n"" +
        ""  println \""onJoinStep.done\""\n"" +
        ""} ""; return onJoin; } public static Step generateOnLeaveStep() { Step onLeave = new Step(); onLeave.name = ""OnLeaveStep""; onLeave.source = ""onLeaveStep = stepFactory.createNoUserActionStep()\n"" +
        ""\n"" +
        ""onLeaveStep.run = { \n"" +
        ""  println \""onLeaveStep.run\""\n"" +
        ""} "" +
        ""\n"" +
        ""onLeaveStep.done = { \n"" +
        ""  println \""onLeaveStep.done\""\n"" +
        ""} ""; return onLeave; } public static Step generateInitStep() { Step init = new Step(); init.name = ""InitStep""; init.source = ""initStep = stepFactory.createStep(\""InitStep\"")\n"" +
        ""\n"" +
        ""initStep.run = { \n"" +
        ""  println \""initStep.run\""\n"" +
        ""} "" +
        ""\n"" +
        ""initStep.done = { \n"" +
        ""  println \""initStep.done\""\n"" +
        ""} ""; return init; } @Override
  public void delete() { Ebean.createSqlUpdate(""delete from experiments_languages where experiments_id = :experimentId"")
        .setParameter(""experimentId"", this.id)
        .execute(); for (Step s : steps) { s.delete(); } for (Content c : content) { c.delete(); } for (Parameter p : parameters) { p.delete(); } for (ExperimentInstance ei : instances) { ei.delete(); } for (Image i : images) { i.delete(); } super.delete(); } public void setStyle(String style) { this.style = style; } public void setClientHtml(String clientHtml) { this.clientHtml = clientHtml; } public void setClientGraph(String clientGraph) { this.clientGraph = clientGraph; } public Content getExperimentContent(Long id) { for (Content c : content) { if (c.id.equals(id))
        return c; } return null; } public Content getContentByName(String name) { for (Content c : content) { if (c.name.equals(name))
        return c; } return null; } public Parameter getParameterByName(String name) { for (Parameter p : parameters) { if (p.name.equals(name))
        return p; } return null; } public List<Parameter> getParameters() { if (this.fileMode) { ArrayList<Parameter> returnParameters = new ArrayList<>(); File parameterFile = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName() + ""/parameters.csv""); try { returnParameters = ExperimentController.getParametersFromFile(parameterFile); } catch (IOException ioe) { ; } return returnParameters; } return this.parameters; } public void removeParameters() { Iterator<Parameter> iter = this.parameters.iterator(); while (iter.hasNext()) { Parameter p = iter.next(); iter.remove(); p.delete(); } this.update(); } public boolean hasOnJoinStep() { return getOnJoinStep() != null; } public boolean hasOnLeaveStep() { return getOnLeaveStep() != null; } public Step getOnJoinStep() { for (Step step : this.getSteps()) { if (ON_JOIN_STEP_NAME.equalsIgnoreCase(step.name)) { return step; } } return null; } public Step getOnLeaveStep() { for (Step step : this.getSteps()) { if (ON_LEAVE_STEP_NAME.equalsIgnoreCase(step.name)) { return step; } } return null; } @JsonValue
  public ObjectNode toJson() { ObjectNode experiment = Json.newObject(); experiment.put(""id"", id); experiment.put(""name"", name); experiment.put(""uid"", uid); experiment.put(""fileMode"", fileMode); ArrayNode jsonSteps = experiment.putArray(""steps""); for (Step s : getSteps()) { jsonSteps.add(s.toJson()); } ArrayNode jsonLanguages = experiment.putArray(""languages""); for (Language l : languages) { jsonLanguages.add(l.toJson()); } ArrayNode jsonContent = experiment.putArray(""content""); for (Content c : getContent()) { jsonContent.add(c.toJson()); } ArrayNode jsonParameters = experiment.putArray(""parameters""); for (Parameter p : getParameters()) { jsonParameters.add(p.toJson()); } ArrayNode jsonInstances = experiment.putArray(""instances""); for (ExperimentInstance ei : instances) { jsonInstances.add(ei.toJsonStub()); } ArrayNode jsonImages = experiment.putArray(""images""); for (Image i : getImages()) { jsonImages.add(i.toJson()); } experiment.put(""style"", getStyle()); experiment.put(""clientGraphHash"", getClientGraph().hashCode()); experiment.put(""clientHtmlHash"", getClientHtml().hashCode()); return experiment; } public String toString() { return ""Experiment("" + id + "")""; } } ","package models; 
import com.avaje.ebean.Ebean; import com.avaje.ebean.annotation.ConcurrencyMode; import com.avaje.ebean.annotation.EntityConcurrencyMode; import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.annotation.JsonValue; import com.fasterxml.jackson.databind.node.ArrayNode; import com.fasterxml.jackson.databind.node.ObjectNode; import controllers.ExperimentController; import org.apache.commons.csv.CSVFormat; import org.apache.commons.csv.CSVPrinter; import org.apache.commons.io.FileUtils; import org.apache.commons.io.IOUtils; import org.apache.commons.lang3.StringUtils; import play.Logger; import play.Play; import play.data.format.Formats; import play.data.validation.Constraints; import play.db.ebean.Model; import play.libs.Json; 
import javax.persistence.*; import java.io.File; import java.io.IOException; import java.io.InputStream; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.UUID;  @Entity
@EntityConcurrencyMode(ConcurrencyMode.NONE)
@Table(name = ""experiments"")
public class Experiment extends Model { @Id
  public Long id;  @Constraints.Required
  @Formats.NonEmpty
  public String name;  public String uid;  @OneToMany(cascade = CascadeType.ALL)
  @OrderBy(""name asc"")
  private List<Step> steps = new ArrayList<>();  @OneToMany(cascade = CascadeType.ALL)
  public List<Content> content = new ArrayList<>();  @OneToMany(cascade = CascadeType.ALL)
  public List<Parameter> parameters = new ArrayList<>();  @JsonIgnore
  public ContentFetcher contentFetcher = new ContentFetcher(this);  @OneToMany(cascade = CascadeType.ALL)
  public List<ExperimentInstance> instances = new ArrayList<>();  @OneToMany(cascade = CascadeType.ALL)
  public List<Image> images = new ArrayList<>();  @ManyToMany
  @JoinTable(name = ""experiments_languages"")
  public List<Language> languages = new ArrayList<>();  public static final Long TEST_INSTANCE_ID = 0L; public ExperimentInstance TEST_INSTANCE = null;  // The AMT QualificationTypeId for the Previous Worker qualification specific to this experiment type. public String qualificationTypeId;  // QualificationTypeId in the AMT Sandbox public String qualificationTypeIdSandbox;  public static final String ON_JOIN_STEP_NAME = ""OnJoinStep""; public static final String ON_LEAVE_STEP_NAME = ""OnLeaveStep"";  public Boolean fileMode;  /*
   * The CSS Style for the experiment
   */ @Column(columnDefinition = ""text"")
  public String style = """";  /*
   * The HTML + JavaScript for the client.
   */ @Column(columnDefinition = ""text"")
  public String clientHtml = """";  /*
   * The client-graph.js for the client.
   */ @Column(columnDefinition = ""text"")
  public String clientGraph = """";  @JsonIgnore
  public static Model.Finder<Long, Experiment> find = new Model.Finder(Long.class, Experiment.class);  public static List<Experiment> findAll() { return find.all(); }  public static Experiment findByName(String name) { return find.where().eq(""name"", name).findUnique(); }  public static Experiment findByUid(String uid) { return find.where().eq(""uid"", uid).findUnique(); }  public static Experiment findById(Long id) { return find.where().eq(""id"", id).findUnique(); }  public ExperimentInstance getTestInstance() { if (TEST_INSTANCE == null) { TEST_INSTANCE = new ExperimentInstance(""TESTING"", this); TEST_INSTANCE.status = ExperimentInstance.Status.TESTING; TEST_INSTANCE.id = TEST_INSTANCE_ID; } return TEST_INSTANCE; }  public Experiment() { this.uid = UUID.randomUUID().toString(); }  public Experiment(String uid) { this.uid = uid; }  /**
   * Copy constructor. Everything is copied except the experimentInstances and name.
   *
   * @param experiment the experiment to be copied from
   */ public Experiment(Experiment experiment) { this.uid = UUID.randomUUID().toString(); this.style = experiment.getStyle(); this.clientHtml = experiment.getClientHtml(); this.clientGraph = experiment.getClientGraph();  for (Step step : experiment.getSteps()) { this.steps.add(new Step(step)); } for (Content c : experiment.getContent()) { this.content.add(new Content(c)); } for (Parameter param : experiment.getParameters()) { this.parameters.add(new Parameter(param)); } for (Image image : experiment.getImages()) { this.images.add(new Image(image)); } for(Language language : experiment.languages) { this.languages.add(language); } }  public String getDirectoryName() { String returnString = StringUtils.replace(this.name, "" "", ""-"").concat(""_"").concat(this.id.toString()); return returnString; }  public void setFileMode(Boolean fileMode) { this.fileMode = fileMode; }  public List<Image> getImages() { if (this.fileMode) { ArrayList<Image> returnImages = new ArrayList<>(); File imagesDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName() + ""/Images""); if (imagesDirectory.isDirectory()) { try { returnImages = ExperimentController.getImagesFromDirectory(imagesDirectory); } catch (IOException ioe) { <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> <FILL_ME> ; } } return returnImages; } return this.images; }  public List<Content> getContent() { if (this.fileMode) { ArrayList<Content> returnContent = new ArrayList<>(); File contentDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName() + ""/Content""); if (contentDirectory.isDirectory()) { try { returnContent = ExperimentController.getContentFromDirectory(contentDirectory); } catch (IOException ioe) { ; } } return returnContent;  } return this.content; }  public void removeContent() { Iterator<Content> iter = this.content.iterator(); while (iter.hasNext()) { Content c = iter.next(); iter.remove(); c.delete(); } this.update(); }  public void removeImages() { Iterator<Image> iter = this.images.iterator(); while (iter.hasNext()) { Image i = iter.next(); iter.remove(); i.delete(); } this.update(); }  public String getStyle() { if (this.fileMode) { String returnStyle = """"; try { File devDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName()); returnStyle = FileUtils.readFileToString(new File(devDirectory, ""style.css"")); } catch (IOException ioe) { ; } return returnStyle; } else { return this.style; } }  public String getClientHtml() { if (this.fileMode) { String returnClientHtml = """"; try { File devDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName()); returnClientHtml = FileUtils.readFileToString(new File(devDirectory, ""client-html.html"")); } catch (IOException ioe) { ; } return returnClientHtml; } else { return this.clientHtml; } }  public String getClientGraph() { if (this.fileMode) { String returnClientGraph = """"; try { File devDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName()); returnClientGraph = FileUtils.readFileToString(new File(devDirectory, ""client-graph.js"")); } catch (IOException ioe) { ; } return returnClientGraph; } else { return this.clientGraph; } }  public List<Step> getSteps() { if (this.fileMode) { ArrayList<Step> returnSteps = new ArrayList<>(); File stepsDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName() + ""/steps""); try { returnSteps = ExperimentController.getStepsFromDirectory(stepsDirectory); } catch (IOException ioe) { ; } return returnSteps; } else { return this.steps; } }  public void addStep(Step step) { this.steps.add(step); }  public void removeSteps() { Iterator<Step> iter = this.steps.iterator(); while (iter.hasNext()) { Step s = iter.next(); iter.remove(); s.delete(); } this.update(); }  public void toggleFileMode(User user) { File experimentDirectory = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName()); try { if (this.fileMode) { // Turning fileMode off, let's import the files into the current experiment ExperimentController.importExperimentFromDirectory(this.id, user, experimentDirectory); } else { // Turning fileMode on, let's export the experiment into the appropriate directory ExperimentController.exportExperimentToDirectory(this.id, experimentDirectory); } this.setFileMode(!this.fileMode); this.save(); } catch (IOException ioe) { // if (Logger.canLog(Logger.DEBUG)) { //   ioe.printStackTrace(Logger); // } } }  public String parametersToCsv() { CSVFormat format = CSVFormat.DEFAULT.withHeader(""Name"", ""Type"", ""Min."", ""Max."", ""Default"", ""Short Description""); StringBuilder stringBuilder = new StringBuilder(); try { CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, format); for (Parameter param : getParameters()) { csvPrinter.printRecord(param.name, param.type, param.minVal, param.maxVal, param.defaultVal, param.description); } } catch (IOException ioe) { } return stringBuilder.toString(); }  public void export() throws IOException { File experimentDirectory = new File(Play.application().path().toString() + ""/experiments/"" + this.name); FileUtils.writeStringToFile(new File(experimentDirectory, ""style.css""), this.getStyle()); FileUtils.writeStringToFile(new File(experimentDirectory, ""client.html""), this.getClientHtml()); FileUtils.writeStringToFile(new File(experimentDirectory, ""client-graph.js""), this.getClientGraph());  File stepsDirectory = new File(experimentDirectory, ""/Steps""); for (Step step : this.getSteps()) { FileUtils.writeStringToFile(new File(stepsDirectory, step.name.concat("".groovy"")), step.source); }  File contentDirectory = new File(experimentDirectory, ""/Content""); for (Content c : this.getContent()) { // Write to a subdirectory based on the language of the Content or 'en' if language is undefined for (Translation t : c.translations) { String language = (t.language == null) ? ""en"" : t.language.code; File languageDirectory = new File(contentDirectory, ""/"" + language); FileUtils.writeStringToFile(new File(languageDirectory, c.name.concat("".html"")), t.html); } }  String ls = System.getProperty(""line.separator""); File parametersFile = new File(experimentDirectory, ""parameters.csv""); FileUtils.writeStringToFile(parametersFile, ""Name,Type,Min.,Max.,Default,Short Description"" + ls); for (Parameter param : this.getParameters()) { FileUtils.writeStringToFile(parametersFile, param.name + "","" + param.type + "","" + param.minVal + "","" + param.maxVal + "","" + param.defaultVal + "","" + param.description + ls, true); }  File imagesDirectory = new File(experimentDirectory, ""/Images""); for (Image image : this.getImages()) { FileUtils.writeByteArrayToFile(new File(imagesDirectory, image.fileName), image.file); } }  public static String defaultClientHTML() { String contents = """"; try { InputStream defaultClientHtml = Play.application().resourceAsStream(""defaults/client-html.html""); if (defaultClientHtml == null) defaultClientHtml = Play.application().resourceAsStream(""defaults/default-client-html.html"");  if (defaultClientHtml == null) { <FILL_ME> } else { contents = IOUtils.toString(defaultClientHtml); } } catch(IOException e){ <FILL_ME> <FILL_ME> } return contents; }  public static String defaultClientGraph() { String contents = """"; try { InputStream defaultClientGraph = Play.application().resourceAsStream(""defaults/client-graph.js""); if (defaultClientGraph == null) defaultClientGraph = Play.application().resourceAsStream(""defaults/default-client-graph.js"");  if (defaultClientGraph == null) { <FILL_ME> } else { contents = IOUtils.toString(defaultClientGraph); } } catch(IOException e){ } return contents; }  public static Step generateOnJoinStep() { Step onJoin = new Step(); onJoin.name = ""OnJoinStep""; onJoin.source = ""onJoinStep = stepFactory.createNoUserActionStep()\n"" +
        ""\n"" +
        ""onJoinStep.run = { playerId->\n"" +
        ""  println \""onJoinStep.run\""\n"" +
        ""  def player = g.getVertex(playerId)\n"" +
        ""} "" +
        ""\n"" +
        ""onJoinStep.done = { \n"" +
        ""  println \""onJoinStep.done\""\n"" +
        ""} "";  return onJoin; }  public static Step generateOnLeaveStep() { Step onLeave = new Step(); onLeave.name = ""OnLeaveStep""; onLeave.source = ""onLeaveStep = stepFactory.createNoUserActionStep()\n"" +
        ""\n"" +
        ""onLeaveStep.run = { \n"" +
        ""  println \""onLeaveStep.run\""\n"" +
        ""} "" +
        ""\n"" +
        ""onLeaveStep.done = { \n"" +
        ""  println \""onLeaveStep.done\""\n"" +
        ""} ""; return onLeave; }  public static Step generateInitStep() { Step init = new Step(); init.name = ""InitStep""; init.source = ""initStep = stepFactory.createStep(\""InitStep\"")\n"" +
        ""\n"" +
        ""initStep.run = { \n"" +
        ""  println \""initStep.run\""\n"" +
        ""} "" +
        ""\n"" +
        ""initStep.done = { \n"" +
        ""  println \""initStep.done\""\n"" +
        ""} ""; return init; }  @Override
  public void delete() { Ebean.createSqlUpdate(""delete from experiments_languages where experiments_id = :experimentId"")
        .setParameter(""experimentId"", this.id)
        .execute();  for (Step s : steps) { s.delete(); } for (Content c : content) { c.delete(); } for (Parameter p : parameters) { p.delete(); } for (ExperimentInstance ei : instances) { ei.delete(); } for (Image i : images) { i.delete(); } super.delete(); }  public void setStyle(String style) { this.style = style; }  public void setClientHtml(String clientHtml) { this.clientHtml = clientHtml; }  public void setClientGraph(String clientGraph) { this.clientGraph = clientGraph; }  public Content getExperimentContent(Long id) { for (Content c : content) { if (c.id.equals(id))
        return c; } return null; }  public Content getContentByName(String name) { for (Content c : content) { if (c.name.equals(name))
        return c; } return null; }  public Parameter getParameterByName(String name) { for (Parameter p : parameters) { if (p.name.equals(name))
        return p; } return null; }  public List<Parameter> getParameters() { if (this.fileMode) { ArrayList<Parameter> returnParameters = new ArrayList<>(); File parameterFile = new File(Play.application().path().toString() + ""/dev/"" + getDirectoryName() + ""/parameters.csv""); try { returnParameters = ExperimentController.getParametersFromFile(parameterFile); } catch (IOException ioe) { ; } return returnParameters;  } return this.parameters; }  public void removeParameters() { Iterator<Parameter> iter = this.parameters.iterator(); while (iter.hasNext()) { Parameter p = iter.next(); iter.remove(); p.delete(); } this.update(); }  public boolean hasOnJoinStep() { return getOnJoinStep() != null; }  public boolean hasOnLeaveStep() { return getOnLeaveStep() != null; }  public Step getOnJoinStep() { for (Step step : this.getSteps()) { if (ON_JOIN_STEP_NAME.equalsIgnoreCase(step.name)) { return step; } } return null; }  public Step getOnLeaveStep() { for (Step step : this.getSteps()) { if (ON_LEAVE_STEP_NAME.equalsIgnoreCase(step.name)) { return step; } } return null; }  @JsonValue
  public ObjectNode toJson() { ObjectNode experiment = Json.newObject();  experiment.put(""id"", id); experiment.put(""name"", name); experiment.put(""uid"", uid); experiment.put(""fileMode"", fileMode);  ArrayNode jsonSteps = experiment.putArray(""steps""); for (Step s : getSteps()) { jsonSteps.add(s.toJson()); }  ArrayNode jsonLanguages = experiment.putArray(""languages""); for (Language l : languages) { jsonLanguages.add(l.toJson()); }  ArrayNode jsonContent = experiment.putArray(""content""); for (Content c : getContent()) { jsonContent.add(c.toJson()); }  ArrayNode jsonParameters = experiment.putArray(""parameters""); for (Parameter p : getParameters()) { jsonParameters.add(p.toJson()); }  ArrayNode jsonInstances = experiment.putArray(""instances""); for (ExperimentInstance ei : instances) { // Only return the name and ID of the instances // TODO: Perhaps add the Date/Time of the instance here as well jsonInstances.add(ei.toJsonStub()); }  ArrayNode jsonImages = experiment.putArray(""images""); for (Image i : getImages()) { jsonImages.add(i.toJson()); }  experiment.put(""style"", getStyle()); experiment.put(""clientGraphHash"", getClientGraph().hashCode()); experiment.put(""clientHtmlHash"", getClientHtml().hashCode());  return experiment; }  public String toString() { return ""Experiment("" + id + "")""; } } 
 "
app/models/ExperimentInstance.java,"package models;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import play.data.format.Formats;
import play.data.validation.Constraints;
import play.db.ebean.Model;
import play.libs.Json;

import javax.persistence.*;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.EnumSet;
import java.util.List;

@Entity
@Table(name = ""experiment_instances"")
public class ExperimentInstance extends Model {
  @Version
  public int version;

  @Id
  public Long id;

  @Constraints.Required
  @Formats.NonEmpty
  public Date creationDate;

  @Constraints.Required
  @Formats.NonEmpty
  public String name;

  @OneToMany(cascade = CascadeType.ALL, mappedBy = ""experimentInstance"", orphanRemoval = true)
  public List<Data> data = new ArrayList<>();

  @OneToMany(cascade = CascadeType.ALL, mappedBy = ""experimentInstance"")
  public List<Event> events = new ArrayList<>();

  @OneToMany(cascade = CascadeType.ALL, mappedBy = ""experimentInstance"")
  public List<AMTHit> amtHits = new ArrayList<>();

  @JsonIgnore
  @ManyToOne
  public Experiment experiment;

  @Enumerated(EnumType.STRING)
  public Status status;

  public Boolean hasStarted;

  public static enum Status {
    RUNNING, TESTING, STOPPED, FINISHED, ARCHIVED;

    static EnumSet<Status> RUNNABLE = EnumSet.of(RUNNING, TESTING, STOPPED);

    public boolean isRunnable() {
      return RUNNABLE.contains(this);
    }
  }

  @JsonIgnore
  public static Model.Finder<Long, ExperimentInstance> find = new Model.Finder(Long.class, ExperimentInstance.class);

  public static List<ExperimentInstance> findAll() {
    return find.all();
  }

  public AMTHit getHit() {
    if (amtHits.isEmpty()) {
      return null;
    }
    return amtHits.get(0);
  }

  public ExperimentInstance(String name, Experiment experiment) {
    this.name = name;
    this.experiment = experiment;
    this.creationDate = new Date();
    this.status = Status.STOPPED;
    this.hasStarted = Boolean.FALSE;

        /* Set up the test instance
        this.TEST_INSTANCE = new ExperimentInstance(""TESTING"", experiment);
        this.TEST_INSTANCE.status = Status.TESTING;
        this.TEST_INSTANCE.id = TEST_INSTANCE_ID;
        */
  }

  @Override
  public void delete() {
    for (Data d : data) {
      d.delete();
    }
    data.clear();
    for (Event e : events) {
      e.delete();
    }
    events.clear();
    super.delete();
  }

  public void start() {
    if (!status.isRunnable()) {
      throw new IllegalStateException(""The current status is not runnable:"" + status);
    }
    status = Status.RUNNING;
  }

  public void test() {
    if (!status.isRunnable()) {
      throw new IllegalStateException(""The current status is not runnable:"" + status);
    }
    status = Status.TESTING;
  }

  public void finish() {
    status = Status.FINISHED;
  }

  public void stop() {
    if (!status.isRunnable()) {
      throw new IllegalStateException(""The current status is not runnable:"" + status);
    }
    status = Status.STOPPED;
  }

  public void setHasStarted(Boolean hasStarted) {
    this.hasStarted = hasStarted;
    this.update();
  }

  public boolean isTestInstance() {
    return (this.id.equals(Experiment.TEST_INSTANCE_ID));
  }

  public static ExperimentInstance findById(Long id) {
    return find.where().eq(""id"", id).findUnique();
  }

  public static List<ExperimentInstance> findByStatus(Status status) {
    return find.where().eq(""status"", status).findList();
  }

  public ObjectNode toJson() {
    ObjectNode experimentInstance = this.toJsonStub();

    ArrayNode jsonEvents = experimentInstance.putArray(""events"");
    for (Event e : events) {
      jsonEvents.add(e.toJson());
    }

    return experimentInstance;
  }

  public ObjectNode toJsonStub() {
    ObjectNode experimentInstance = Json.newObject();

    experimentInstance.put(""id"", id);
    experimentInstance.put(""creationTime"", new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss,S"").format(creationDate));
    experimentInstance.put(""status"", status.toString());
    experimentInstance.put(""name"", name);
    experimentInstance.put(""hitId"", (amtHits.size() > 0) ? amtHits.get(0).id.toString() : """");

    ArrayNode jsonHits = experimentInstance.putArray(""hits"");
    for (AMTHit h : amtHits) {
      jsonHits.add(h.toJson());
    }

    ArrayNode jsonData = experimentInstance.putArray(""data"");
    for (Data d : data) {
      jsonData.add(d.toJson());
    }

    return experimentInstance;
  }

  public String toString() {
    return ""ExperimentInstance("" + id + "")"";
  }
}
","package models; @Entity
@Table(name = ""experiment_instances"")
public class ExperimentInstance extends Model { @Version
  public int version; @Id
  public Long id; @Constraints.Required
  @Formats.NonEmpty
  public Date creationDate; @Constraints.Required
  @Formats.NonEmpty
  public String name; @OneToMany(cascade = CascadeType.ALL, mappedBy = ""experimentInstance"", orphanRemoval = true)
  public List<Data> data = new ArrayList<>(); @OneToMany(cascade = CascadeType.ALL, mappedBy = ""experimentInstance"")
  public List<Event> events = new ArrayList<>(); @OneToMany(cascade = CascadeType.ALL, mappedBy = ""experimentInstance"")
  public List<AMTHit> amtHits = new ArrayList<>(); @JsonIgnore
  @ManyToOne
  public Experiment experiment; @Enumerated(EnumType.STRING)
  public Status status; public Boolean hasStarted; public static enum Status { RUNNING, TESTING, STOPPED, FINISHED, ARCHIVED; static EnumSet<Status> RUNNABLE = EnumSet.of(RUNNING, TESTING, STOPPED); public boolean isRunnable() { return RUNNABLE.contains(this); } } @JsonIgnore
  public static Model.Finder<Long, ExperimentInstance> find = new Model.Finder(Long.class, ExperimentInstance.class); public static List<ExperimentInstance> findAll() { return find.all(); } public AMTHit getHit() { if (amtHits.isEmpty()) { return null; } return amtHits.get(0); } public ExperimentInstance(String name, Experiment experiment) { this.name = name; this.experiment = experiment; this.creationDate = new Date(); this.status = Status.STOPPED; this.hasStarted = Boolean.FALSE; } @Override
  public void delete() { for (Data d : data) { d.delete(); } data.clear(); for (Event e : events) { e.delete(); } events.clear(); super.delete(); } public void start() { if (!status.isRunnable()) { throw new IllegalStateException(""The current status is not runnable:"" + status); } status = Status.RUNNING; } public void test() { if (!status.isRunnable()) { throw new IllegalStateException(""The current status is not runnable:"" + status); } status = Status.TESTING; } public void finish() { status = Status.FINISHED; } public void stop() { if (!status.isRunnable()) { throw new IllegalStateException(""The current status is not runnable:"" + status); } status = Status.STOPPED; } public void setHasStarted(Boolean hasStarted) { this.hasStarted = hasStarted; this.update(); } public boolean isTestInstance() { return (this.id.equals(Experiment.TEST_INSTANCE_ID)); } public static ExperimentInstance findById(Long id) { return find.where().eq(""id"", id).findUnique(); } public static List<ExperimentInstance> findByStatus(Status status) { return find.where().eq(""status"", status).findList(); } public ObjectNode toJson() { ObjectNode experimentInstance = this.toJsonStub(); ArrayNode jsonEvents = experimentInstance.putArray(""events""); for (Event e : events) { jsonEvents.add(e.toJson()); } return experimentInstance; } public ObjectNode toJsonStub() { ObjectNode experimentInstance = Json.newObject(); experimentInstance.put(""id"", id); experimentInstance.put(""creationTime"", new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss,S"").format(creationDate)); experimentInstance.put(""status"", status.toString()); experimentInstance.put(""name"", name); experimentInstance.put(""hitId"", (amtHits.size() > 0) ? amtHits.get(0).id.toString() : """"); ArrayNode jsonHits = experimentInstance.putArray(""hits""); for (AMTHit h : amtHits) { jsonHits.add(h.toJson()); } ArrayNode jsonData = experimentInstance.putArray(""data""); for (Data d : data) { jsonData.add(d.toJson()); } return experimentInstance; } public String toString() { return ""ExperimentInstance("" + id + "")""; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; @Entity
@Table(name = ""experiment_instances"")
public class ExperimentInstance extends Model { @Version
  public int version; @Id
  public Long id; @Constraints.Required
  @Formats.NonEmpty
  public Date creationDate; @Constraints.Required
  @Formats.NonEmpty
  public String name; @OneToMany(cascade = CascadeType.ALL, mappedBy = ""experimentInstance"", orphanRemoval = true)
  public List<Data> data = new ArrayList<>(); @OneToMany(cascade = CascadeType.ALL, mappedBy = ""experimentInstance"")
  public List<Event> events = new ArrayList<>(); @OneToMany(cascade = CascadeType.ALL, mappedBy = ""experimentInstance"")
  public List<AMTHit> amtHits = new ArrayList<>(); @JsonIgnore
  @ManyToOne
  public Experiment experiment; @Enumerated(EnumType.STRING)
  public Status status; public Boolean hasStarted; public static enum Status { RUNNING, TESTING, STOPPED, FINISHED, ARCHIVED; static EnumSet<Status> RUNNABLE = EnumSet.of(RUNNING, TESTING, STOPPED); public boolean isRunnable() { return RUNNABLE.contains(this); } } @JsonIgnore
  public static Model.Finder<Long, ExperimentInstance> find = new Model.Finder(Long.class, ExperimentInstance.class); public static List<ExperimentInstance> findAll() { return find.all(); } public AMTHit getHit() { if (amtHits.isEmpty()) { return null; } return amtHits.get(0); } public ExperimentInstance(String name, Experiment experiment) { this.name = name; this.experiment = experiment; this.creationDate = new Date(); this.status = Status.STOPPED; this.hasStarted = Boolean.FALSE; } @Override
  public void delete() { for (Data d : data) { d.delete(); } data.clear(); for (Event e : events) { e.delete(); } events.clear(); super.delete(); } public void start() { if (!status.isRunnable()) { throw new IllegalStateException(""The current status is not runnable:"" + status); } status = Status.RUNNING; } public void test() { if (!status.isRunnable()) { throw new IllegalStateException(""The current status is not runnable:"" + status); } status = Status.TESTING; } public void finish() { status = Status.FINISHED; } public void stop() { if (!status.isRunnable()) { throw new IllegalStateException(""The current status is not runnable:"" + status); } status = Status.STOPPED; } public void setHasStarted(Boolean hasStarted) { this.hasStarted = hasStarted; this.update(); } public boolean isTestInstance() { return (this.id.equals(Experiment.TEST_INSTANCE_ID)); } public static ExperimentInstance findById(Long id) { return find.where().eq(""id"", id).findUnique(); } public static List<ExperimentInstance> findByStatus(Status status) { return find.where().eq(""status"", status).findList(); } public ObjectNode toJson() { ObjectNode experimentInstance = this.toJsonStub(); ArrayNode jsonEvents = experimentInstance.putArray(""events""); for (Event e : events) { jsonEvents.add(e.toJson()); } return experimentInstance; } public ObjectNode toJsonStub() { ObjectNode experimentInstance = Json.newObject(); experimentInstance.put(""id"", id); experimentInstance.put(""creationTime"", new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss,S"").format(creationDate)); experimentInstance.put(""status"", status.toString()); experimentInstance.put(""name"", name); experimentInstance.put(""hitId"", (amtHits.size() > 0) ? amtHits.get(0).id.toString() : """"); ArrayNode jsonHits = experimentInstance.putArray(""hits""); for (AMTHit h : amtHits) { jsonHits.add(h.toJson()); } ArrayNode jsonData = experimentInstance.putArray(""data""); for (Data d : data) { jsonData.add(d.toJson()); } return experimentInstance; } public String toString() { return ""ExperimentInstance("" + id + "")""; } } ","package models; 
import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.databind.node.ArrayNode; import com.fasterxml.jackson.databind.node.ObjectNode; import play.data.format.Formats; import play.data.validation.Constraints; import play.db.ebean.Model; import play.libs.Json; 
import javax.persistence.*; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Date; import java.util.EnumSet; import java.util.List;  @Entity
@Table(name = ""experiment_instances"")
public class ExperimentInstance extends Model { @Version
  public int version;  @Id
  public Long id;  @Constraints.Required
  @Formats.NonEmpty
  public Date creationDate;  @Constraints.Required
  @Formats.NonEmpty
  public String name;  @OneToMany(cascade = CascadeType.ALL, mappedBy = ""experimentInstance"", orphanRemoval = true)
  public List<Data> data = new ArrayList<>();  @OneToMany(cascade = CascadeType.ALL, mappedBy = ""experimentInstance"")
  public List<Event> events = new ArrayList<>();  @OneToMany(cascade = CascadeType.ALL, mappedBy = ""experimentInstance"")
  public List<AMTHit> amtHits = new ArrayList<>();  @JsonIgnore
  @ManyToOne
  public Experiment experiment;  @Enumerated(EnumType.STRING)
  public Status status;  public Boolean hasStarted;  public static enum Status { RUNNING, TESTING, STOPPED, FINISHED, ARCHIVED;  static EnumSet<Status> RUNNABLE = EnumSet.of(RUNNING, TESTING, STOPPED);  public boolean isRunnable() { return RUNNABLE.contains(this); } }  @JsonIgnore
  public static Model.Finder<Long, ExperimentInstance> find = new Model.Finder(Long.class, ExperimentInstance.class);  public static List<ExperimentInstance> findAll() { return find.all(); }  public AMTHit getHit() { if (amtHits.isEmpty()) { return null; } return amtHits.get(0); }  public ExperimentInstance(String name, Experiment experiment) { this.name = name; this.experiment = experiment; this.creationDate = new Date(); this.status = Status.STOPPED; this.hasStarted = Boolean.FALSE;  /* Set up the test instance
        this.TEST_INSTANCE = new ExperimentInstance(""TESTING"", experiment);
        this.TEST_INSTANCE.status = Status.TESTING;
        this.TEST_INSTANCE.id = TEST_INSTANCE_ID;
        */ }  @Override
  public void delete() { for (Data d : data) { d.delete(); } data.clear(); for (Event e : events) { e.delete(); } events.clear(); super.delete(); }  public void start() { if (!status.isRunnable()) { throw new IllegalStateException(""The current status is not runnable:"" + status); } status = Status.RUNNING; }  public void test() { if (!status.isRunnable()) { throw new IllegalStateException(""The current status is not runnable:"" + status); } status = Status.TESTING; }  public void finish() { status = Status.FINISHED; }  public void stop() { if (!status.isRunnable()) { throw new IllegalStateException(""The current status is not runnable:"" + status); } status = Status.STOPPED; }  public void setHasStarted(Boolean hasStarted) { this.hasStarted = hasStarted; this.update(); }  public boolean isTestInstance() { return (this.id.equals(Experiment.TEST_INSTANCE_ID)); }  public static ExperimentInstance findById(Long id) { return find.where().eq(""id"", id).findUnique(); }  public static List<ExperimentInstance> findByStatus(Status status) { return find.where().eq(""status"", status).findList(); }  public ObjectNode toJson() { ObjectNode experimentInstance = this.toJsonStub();  ArrayNode jsonEvents = experimentInstance.putArray(""events""); for (Event e : events) { jsonEvents.add(e.toJson()); }  return experimentInstance; }  public ObjectNode toJsonStub() { ObjectNode experimentInstance = Json.newObject();  experimentInstance.put(""id"", id); experimentInstance.put(""creationTime"", new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss,S"").format(creationDate)); experimentInstance.put(""status"", status.toString()); experimentInstance.put(""name"", name); experimentInstance.put(""hitId"", (amtHits.size() > 0) ? amtHits.get(0).id.toString() : """");  ArrayNode jsonHits = experimentInstance.putArray(""hits""); for (AMTHit h : amtHits) { jsonHits.add(h.toJson()); }  ArrayNode jsonData = experimentInstance.putArray(""data""); for (Data d : data) { jsonData.add(d.toJson()); }  return experimentInstance; }  public String toString() { return ""ExperimentInstance("" + id + "")""; } }  "
app/models/FileWatcher.java,"package models;

import actors.FileWatcherActor;
import actors.FileWatcherActorProtocol;
import akka.actor.ActorRef;
import akka.actor.Props;
import com.sun.nio.file.SensitivityWatchEventModifier;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.filefilter.DirectoryFileFilter;
import org.apache.commons.io.filefilter.FalseFileFilter;
import play.Logger;
import play.libs.Akka;
import scala.concurrent.duration.Duration;

import java.io.File;
import java.io.IOException;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;
import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;
import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;

public class FileWatcher {
  private Long updateIteration = 0L;
  private ArrayList<Admin> adminListeners = new ArrayList<>();
  static ActorRef fileWatcherActor;
  private WatchService watcher;
  private Map<WatchKey, Path> watchKeys;

  public FileWatcher(ArrayList<Admin> adminListeners) {
    this.adminListeners = adminListeners;

    Path devPath = FileSystems.getDefault().getPath(""dev"");
    this.watchKeys = new HashMap<>();
    try {
      this.watcher = FileSystems.getDefault().newWatchService();
      // Recursively watch all directories inside of the 'dev' directory
      registerRecursive(devPath);
    } catch (IOException ioe) {
      Logger.error(""Can no longer watch the dev directory, was it deleted?"");
    }

    fileWatcherActor = Akka.system().actorOf(new Props(FileWatcherActor.class));
    Long fileWatchRate = play.Play.application().configuration().getMilliseconds(""breadboard.fileWatchRate"", 100L);
    Akka.system().scheduler().schedule(
        Duration.create(0, TimeUnit.MILLISECONDS),
        Duration.create(fileWatchRate, TimeUnit.MILLISECONDS),
        fileWatcherActor,
        new FileWatcherActorProtocol.FileWatch(this),
        Akka.system().dispatcher(),
        null
    );
  }

  public void registerRecursive(Path parent) throws IOException {
    for (File f : FileUtils.listFilesAndDirs(parent.toFile(), FalseFileFilter.INSTANCE, DirectoryFileFilter.DIRECTORY)) {
      WatchKey watchKey = f.toPath().register(watcher, new WatchEvent.Kind[]{ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY}, SensitivityWatchEventModifier.HIGH);
      watchKeys.put(watchKey, f.toPath());
    }
  }

  public ArrayList<Admin> getAdminListeners() {
    return this.adminListeners;
  }

  public Experiment getExperiment() {
    return this.adminListeners.get(0).getUser().selectedExperiment;
  }

  public void incrementUpdateIteration() {
    this.updateIteration++;
  }

  public Long getUpdateIteration() {
    return this.updateIteration;
  }

  public WatchService getWatcher() {
    return this.watcher;
  }

  public Map<WatchKey, Path> getWatchKeys() {
    return this.watchKeys;
  }

  public void loadStep(String source, ThrottledWebSocketOut out, String name) {
    ScriptBoard.processScript(source, out, name);
  }
}
","package models; public class FileWatcher { private Long updateIteration = 0L; private ArrayList<Admin> adminListeners = new ArrayList<>(); static ActorRef fileWatcherActor; private WatchService watcher; private Map<WatchKey, Path> watchKeys; public FileWatcher(ArrayList<Admin> adminListeners) { this.adminListeners = adminListeners; Path devPath = FileSystems.getDefault().getPath(""dev""); this.watchKeys = new HashMap<>(); try { this.watcher = FileSystems.getDefault().newWatchService(); registerRecursive(devPath); } catch (IOException ioe) { } fileWatcherActor = Akka.system().actorOf(new Props(FileWatcherActor.class)); Long fileWatchRate = play.Play.application().configuration().getMilliseconds(""breadboard.fileWatchRate"", 100L); Akka.system().scheduler().schedule(
        Duration.create(0, TimeUnit.MILLISECONDS),
        Duration.create(fileWatchRate, TimeUnit.MILLISECONDS),
        fileWatcherActor,
        new FileWatcherActorProtocol.FileWatch(this),
        Akka.system().dispatcher(),
        null
    ); } public void registerRecursive(Path parent) throws IOException { for (File f : FileUtils.listFilesAndDirs(parent.toFile(), FalseFileFilter.INSTANCE, DirectoryFileFilter.DIRECTORY)) { WatchKey watchKey = f.toPath().register(watcher, new WatchEvent.Kind[]{ ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY} , SensitivityWatchEventModifier.HIGH); watchKeys.put(watchKey, f.toPath()); } } public ArrayList<Admin> getAdminListeners() { return this.adminListeners; } public Experiment getExperiment() { return this.adminListeners.get(0).getUser().selectedExperiment; } public void incrementUpdateIteration() { this.updateIteration++; } public Long getUpdateIteration() { return this.updateIteration; } public WatchService getWatcher() { return this.watcher; } public Map<WatchKey, Path> getWatchKeys() { return this.watchKeys; } public void loadStep(String source, ThrottledWebSocketOut out, String name) { ScriptBoard.processScript(source, out, name); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; public class FileWatcher { private Long updateIteration = 0L; private ArrayList<Admin> adminListeners = new ArrayList<>(); static ActorRef fileWatcherActor; private WatchService watcher; private Map<WatchKey, Path> watchKeys; public FileWatcher(ArrayList<Admin> adminListeners) { this.adminListeners = adminListeners; Path devPath = FileSystems.getDefault().getPath(""dev""); this.watchKeys = new HashMap<>(); try { this.watcher = FileSystems.getDefault().newWatchService(); registerRecursive(devPath); } catch (IOException ioe) { <FILL_ME> } fileWatcherActor = Akka.system().actorOf(new Props(FileWatcherActor.class)); Long fileWatchRate = play.Play.application().configuration().getMilliseconds(""breadboard.fileWatchRate"", 100L); Akka.system().scheduler().schedule(
        Duration.create(0, TimeUnit.MILLISECONDS),
        Duration.create(fileWatchRate, TimeUnit.MILLISECONDS),
        fileWatcherActor,
        new FileWatcherActorProtocol.FileWatch(this),
        Akka.system().dispatcher(),
        null
    ); } public void registerRecursive(Path parent) throws IOException { for (File f : FileUtils.listFilesAndDirs(parent.toFile(), FalseFileFilter.INSTANCE, DirectoryFileFilter.DIRECTORY)) { WatchKey watchKey = f.toPath().register(watcher, new WatchEvent.Kind[]{ ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY} , SensitivityWatchEventModifier.HIGH); watchKeys.put(watchKey, f.toPath()); } } public ArrayList<Admin> getAdminListeners() { return this.adminListeners; } public Experiment getExperiment() { return this.adminListeners.get(0).getUser().selectedExperiment; } public void incrementUpdateIteration() { this.updateIteration++; } public Long getUpdateIteration() { return this.updateIteration; } public WatchService getWatcher() { return this.watcher; } public Map<WatchKey, Path> getWatchKeys() { return this.watchKeys; } public void loadStep(String source, ThrottledWebSocketOut out, String name) { ScriptBoard.processScript(source, out, name); } } ","package models; 
import actors.FileWatcherActor; import actors.FileWatcherActorProtocol; import akka.actor.ActorRef; import akka.actor.Props; import com.sun.nio.file.SensitivityWatchEventModifier; import org.apache.commons.io.FileUtils; import org.apache.commons.io.filefilter.DirectoryFileFilter; import org.apache.commons.io.filefilter.FalseFileFilter; import play.Logger; import play.libs.Akka; import scala.concurrent.duration.Duration; 
import java.io.File; import java.io.IOException; import java.nio.file.*; import java.util.ArrayList; import java.util.HashMap; import java.util.Map; import java.util.concurrent.TimeUnit; 
import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE; import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE; import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;  public class FileWatcher { private Long updateIteration = 0L; private ArrayList<Admin> adminListeners = new ArrayList<>(); static ActorRef fileWatcherActor; private WatchService watcher; private Map<WatchKey, Path> watchKeys;  public FileWatcher(ArrayList<Admin> adminListeners) { this.adminListeners = adminListeners;  Path devPath = FileSystems.getDefault().getPath(""dev""); this.watchKeys = new HashMap<>(); try { this.watcher = FileSystems.getDefault().newWatchService(); // Recursively watch all directories inside of the 'dev' directory registerRecursive(devPath); } catch (IOException ioe) { <FILL_ME> }  fileWatcherActor = Akka.system().actorOf(new Props(FileWatcherActor.class)); Long fileWatchRate = play.Play.application().configuration().getMilliseconds(""breadboard.fileWatchRate"", 100L); Akka.system().scheduler().schedule(
        Duration.create(0, TimeUnit.MILLISECONDS),
        Duration.create(fileWatchRate, TimeUnit.MILLISECONDS),
        fileWatcherActor,
        new FileWatcherActorProtocol.FileWatch(this),
        Akka.system().dispatcher(),
        null
    ); }  public void registerRecursive(Path parent) throws IOException { for (File f : FileUtils.listFilesAndDirs(parent.toFile(), FalseFileFilter.INSTANCE, DirectoryFileFilter.DIRECTORY)) { WatchKey watchKey = f.toPath().register(watcher, new WatchEvent.Kind[]{ ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY} , SensitivityWatchEventModifier.HIGH); watchKeys.put(watchKey, f.toPath()); } }  public ArrayList<Admin> getAdminListeners() { return this.adminListeners; }  public Experiment getExperiment() { return this.adminListeners.get(0).getUser().selectedExperiment; }  public void incrementUpdateIteration() { this.updateIteration++; }  public Long getUpdateIteration() { return this.updateIteration; }  public WatchService getWatcher() { return this.watcher; }  public Map<WatchKey, Path> getWatchKeys() { return this.watchKeys; }  public void loadStep(String source, ThrottledWebSocketOut out, String name) { ScriptBoard.processScript(source, out, name); } }  "
app/models/GameListener.java,"package models;

import javax.script.ScriptEngine;

public class GameListener {

  public ExperimentInstance experimentInstance;
  public User user;
  public ScriptEngine engine;
  public ThrottledWebSocketOut out;

  public GameListener() {
  }

  public void hasStarted() {
    if (this.experimentInstance != null && (!this.experimentInstance.isTestInstance())) {
      this.experimentInstance.setHasStarted(Boolean.TRUE);
      this.experimentInstance.save();
    }
  }

  public void start() {
    if (this.experimentInstance != null && (!this.experimentInstance.isTestInstance())) {
      this.experimentInstance.start();
      this.experimentInstance.save();
    }
  }

  public void stop() {
    if (this.experimentInstance != null && (!this.experimentInstance.isTestInstance())) {
      this.experimentInstance.stop();
      this.experimentInstance.save();
    }
  }

  public void finish() {
    if (this.experimentInstance != null && (!this.experimentInstance.isTestInstance())) {
      this.experimentInstance.finish();
      this.experimentInstance.save();
    }
    if (user != null && engine != null) {
      this.out.write(user.toJson());
    }
  }

}
",package models; public class GameListener { public ExperimentInstance experimentInstance; public User user; public ScriptEngine engine; public ThrottledWebSocketOut out; public GameListener() { } public void hasStarted() { if (this.experimentInstance != null && (!this.experimentInstance.isTestInstance())) { this.experimentInstance.setHasStarted(Boolean.TRUE); this.experimentInstance.save(); } } public void start() { if (this.experimentInstance != null && (!this.experimentInstance.isTestInstance())) { this.experimentInstance.start(); this.experimentInstance.save(); } } public void stop() { if (this.experimentInstance != null && (!this.experimentInstance.isTestInstance())) { this.experimentInstance.stop(); this.experimentInstance.save(); } } public void finish() { if (this.experimentInstance != null && (!this.experimentInstance.isTestInstance())) { this.experimentInstance.finish(); this.experimentInstance.save(); } if (user != null && engine != null) { this.out.write(user.toJson()); } } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package models; public class GameListener { public ExperimentInstance experimentInstance; public User user; public ScriptEngine engine; public ThrottledWebSocketOut out; public GameListener() { } public void hasStarted() { if (this.experimentInstance != null && (!this.experimentInstance.isTestInstance())) { this.experimentInstance.setHasStarted(Boolean.TRUE); this.experimentInstance.save(); } } public void start() { if (this.experimentInstance != null && (!this.experimentInstance.isTestInstance())) { this.experimentInstance.start(); this.experimentInstance.save(); } } public void stop() { if (this.experimentInstance != null && (!this.experimentInstance.isTestInstance())) { this.experimentInstance.stop(); this.experimentInstance.save(); } } public void finish() { if (this.experimentInstance != null && (!this.experimentInstance.isTestInstance())) { this.experimentInstance.finish(); this.experimentInstance.save(); } if (user != null && engine != null) { this.out.write(user.toJson()); } } } ,"package models; 
import javax.script.ScriptEngine;  public class GameListener {  public ExperimentInstance experimentInstance; public User user; public ScriptEngine engine; public ThrottledWebSocketOut out;  public GameListener() { }  public void hasStarted() { if (this.experimentInstance != null && (!this.experimentInstance.isTestInstance())) { this.experimentInstance.setHasStarted(Boolean.TRUE); this.experimentInstance.save(); } }  public void start() { if (this.experimentInstance != null && (!this.experimentInstance.isTestInstance())) { this.experimentInstance.start(); this.experimentInstance.save(); } }  public void stop() { if (this.experimentInstance != null && (!this.experimentInstance.isTestInstance())) { this.experimentInstance.stop(); this.experimentInstance.save(); } }  public void finish() { if (this.experimentInstance != null && (!this.experimentInstance.isTestInstance())) { this.experimentInstance.finish(); this.experimentInstance.save(); } if (user != null && engine != null) { this.out.write(user.toJson()); } }  }  "
app/models/Image.java,"package models;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.databind.node.ObjectNode;
import play.data.validation.Constraints;
import play.db.ebean.Model;
import play.libs.Json;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Lob;
import javax.persistence.Table;
import java.util.Arrays;

@Entity
@Table(name = ""images"")
public class Image extends Model {
  @Id
  public Long id;

  @Constraints.Required
  @Lob
  public byte[] file;

  @Lob
  public byte[] thumbFile;

  @Constraints.Required
  public String fileName;

  public String thumbFileName;

  @Constraints.Required
  public String contentType;

  @JsonIgnore
  public static Model.Finder<Long, Image> find = new Model.Finder(Long.class, Image.class);

  public static Image findById(Long id) {
    return find.where().eq(""id"", id).findUnique();
  }

  public Image() {
  }

  public Image(Image image) {
    this.file = Arrays.copyOf(image.file, image.file.length);
    if (image.thumbFile != null) {
      this.thumbFile = Arrays.copyOf(image.thumbFile, image.thumbFile.length);
      this.thumbFileName = image.thumbFileName;
    }
    this.fileName = image.fileName;
    this.contentType = image.contentType;
  }

  public String toString() {
    return ""Image("" + id.toString() + "")"";
  }

  public ObjectNode toJson() {
    ObjectNode image = Json.newObject();

    image.put(""id"", id);
    image.put(""fileName"", fileName);

    return image;
  }
}
","package models; @Entity
@Table(name = ""images"")
public class Image extends Model { @Id
  public Long id; @Constraints.Required
  @Lob
  public byte[] file; @Lob
  public byte[] thumbFile; @Constraints.Required
  public String fileName; public String thumbFileName; @Constraints.Required
  public String contentType; @JsonIgnore
  public static Model.Finder<Long, Image> find = new Model.Finder(Long.class, Image.class); public static Image findById(Long id) { return find.where().eq(""id"", id).findUnique(); } public Image() { } public Image(Image image) { this.file = Arrays.copyOf(image.file, image.file.length); if (image.thumbFile != null) { this.thumbFile = Arrays.copyOf(image.thumbFile, image.thumbFile.length); this.thumbFileName = image.thumbFileName; } this.fileName = image.fileName; this.contentType = image.contentType; } public String toString() { return ""Image("" + id.toString() + "")""; } public ObjectNode toJson() { ObjectNode image = Json.newObject(); image.put(""id"", id); image.put(""fileName"", fileName); return image; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; @Entity
@Table(name = ""images"")
public class Image extends Model { @Id
  public Long id; @Constraints.Required
  @Lob
  public byte[] file; @Lob
  public byte[] thumbFile; @Constraints.Required
  public String fileName; public String thumbFileName; @Constraints.Required
  public String contentType; @JsonIgnore
  public static Model.Finder<Long, Image> find = new Model.Finder(Long.class, Image.class); public static Image findById(Long id) { return find.where().eq(""id"", id).findUnique(); } public Image() { } public Image(Image image) { this.file = Arrays.copyOf(image.file, image.file.length); if (image.thumbFile != null) { this.thumbFile = Arrays.copyOf(image.thumbFile, image.thumbFile.length); this.thumbFileName = image.thumbFileName; } this.fileName = image.fileName; this.contentType = image.contentType; } public String toString() { return ""Image("" + id.toString() + "")""; } public ObjectNode toJson() { ObjectNode image = Json.newObject(); image.put(""id"", id); image.put(""fileName"", fileName); return image; } } ","package models; 
import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.databind.node.ObjectNode; import play.data.validation.Constraints; import play.db.ebean.Model; import play.libs.Json; 
import javax.persistence.Entity; import javax.persistence.Id; import javax.persistence.Lob; import javax.persistence.Table; import java.util.Arrays;  @Entity
@Table(name = ""images"")
public class Image extends Model { @Id
  public Long id;  @Constraints.Required
  @Lob
  public byte[] file;  @Lob
  public byte[] thumbFile;  @Constraints.Required
  public String fileName;  public String thumbFileName;  @Constraints.Required
  public String contentType;  @JsonIgnore
  public static Model.Finder<Long, Image> find = new Model.Finder(Long.class, Image.class);  public static Image findById(Long id) { return find.where().eq(""id"", id).findUnique(); }  public Image() { }  public Image(Image image) { this.file = Arrays.copyOf(image.file, image.file.length); if (image.thumbFile != null) { this.thumbFile = Arrays.copyOf(image.thumbFile, image.thumbFile.length); this.thumbFileName = image.thumbFileName; } this.fileName = image.fileName; this.contentType = image.contentType; }  public String toString() { return ""Image("" + id.toString() + "")""; }  public ObjectNode toJson() { ObjectNode image = Json.newObject();  image.put(""id"", id); image.put(""fileName"", fileName);  return image; } }  "
app/models/IteratedBreadboardGraphChangedListener.java,"package models;

import actors.ClientUpdateActor;
import actors.ClientUpdateActorProtocol;
import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Graph;
import com.tinkerpop.blueprints.Vertex;
import play.Logger;
import play.libs.Akka;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import akka.actor.*;
import scala.concurrent.duration.Duration;

public class IteratedBreadboardGraphChangedListener implements BreadboardGraphChangedListener {
  private Graph graph;
  private Long updateIteration = 0L;
  private ArrayList<ClientListener> adminListeners = new ArrayList<>();
  private HashMap<String, Client> clientListeners = new HashMap<>();

  static ActorRef clientUpdateActor;

  public IteratedBreadboardGraphChangedListener(Graph graph) {
    this.graph = graph;
    clientUpdateActor = Akka.system().actorOf(new Props(ClientUpdateActor.class));
    Long clientUpdateRate = play.Play.application().configuration().getMilliseconds(""breadboard.clientUpdateRate"");
    if (clientUpdateRate == null) {
      Logger.debug(""clientUpdateRate = null"");
      clientUpdateRate = 1000L;
    }
    Akka.system().scheduler().schedule(
        Duration.create(0, TimeUnit.MILLISECONDS),
        Duration.create(clientUpdateRate, TimeUnit.MILLISECONDS),
        clientUpdateActor,
        new ClientUpdateActorProtocol.ClientUpdate(this),
        Akka.system().dispatcher(),
        null
    );
  }

  private class ClientUpdateTask implements Runnable {
    @Override
    public void run() {
      updateIteration++;
      if (updateIteration % 10 == 0) {
        Logger.debug(""Client update: "" + updateIteration);
      }

      for(Client c : clientListeners.values()) {
        if (graph.getVertex(c.id) != null) {
          try {
            c.updateGraph(graph.getVertex(c.id));
          } catch (Exception e) {
            Logger.debug(""Caught exception in ClientUpdateTask: "" + e.getLocalizedMessage());
          }
        }
      }
    }
  }

  public HashMap<String, Client> getClientListeners() {
    return this.clientListeners;
  }

  public void incrementUpdateIteration() {
    this.updateIteration++;
  }

  public Long getUpdateIteration() {
    return this.updateIteration;
  }

  public Graph getGraph() {
    return this.graph;
  }

  public void setGraph(Graph g) {
    this.graph = g;
  }

  public void addAdminListener(ClientListener adminListener) {
    adminListeners.add(adminListener);
  }

  public ArrayList<ClientListener> getAdminListeners() {
    return this.adminListeners;
  }

  public void addClientListener(Client clientListener) {
    clientListeners.put(clientListener.id, clientListener);
  }

  @Override
  public void edgeAdded(Edge edge) {
    for (ClientListener al : adminListeners)
      al.edgeAdded(edge);
  }

  @Override
  public void edgePropertyChanged(Edge edge, String key, Object oldValue, Object setValue) {
    for (ClientListener al : adminListeners)
      al.edgePropertyChanged(edge, key, setValue);
  }

  @Override
  public void edgePropertyRemoved(Edge edge, String key, Object removedValue) {
    for (ClientListener al : adminListeners)
      al.edgePropertyRemoved(edge, key);
  }

  @Override
  public void edgeRemoved(Edge edge, Map<String, Object> props) {
    for (ClientListener al : adminListeners)
      al.edgeRemoved(edge);
  }

  @Override
  public void vertexAdded(Vertex vertex) {
    for (ClientListener al : adminListeners)
      al.vertexAdded(vertex);
  }

  @Override
  public void vertexPropertyChanged(Vertex vertex, String key, Object oldValue, Object setValue) {
    for (ClientListener al : adminListeners)
      al.vertexPropertyChanged(vertex, key, oldValue, setValue);
  }

  @Override
  public void vertexPropertyRemoved(Vertex vertex, String key, Object removedValue) {
    for (ClientListener al : adminListeners)
      al.vertexPropertyRemoved(vertex, key);
  }

  @Override
  public void vertexRemoved(Vertex vertex, Map<String, Object> props) {
    for (ClientListener al : adminListeners)
      al.vertexRemoved(vertex);
  }
}
","package models; public class IteratedBreadboardGraphChangedListener implements BreadboardGraphChangedListener { private Graph graph; private Long updateIteration = 0L; private ArrayList<ClientListener> adminListeners = new ArrayList<>(); private HashMap<String, Client> clientListeners = new HashMap<>(); static ActorRef clientUpdateActor; public IteratedBreadboardGraphChangedListener(Graph graph) { this.graph = graph; clientUpdateActor = Akka.system().actorOf(new Props(ClientUpdateActor.class)); Long clientUpdateRate = play.Play.application().configuration().getMilliseconds(""breadboard.clientUpdateRate""); if (clientUpdateRate == null) { clientUpdateRate = 1000L; } Akka.system().scheduler().schedule(
        Duration.create(0, TimeUnit.MILLISECONDS),
        Duration.create(clientUpdateRate, TimeUnit.MILLISECONDS),
        clientUpdateActor,
        new ClientUpdateActorProtocol.ClientUpdate(this),
        Akka.system().dispatcher(),
        null
    ); } private class ClientUpdateTask implements Runnable { @Override
    public void run() { updateIteration++; if (updateIteration % 10 == 0) { } for(Client c : clientListeners.values()) { if (graph.getVertex(c.id) != null) { try { c.updateGraph(graph.getVertex(c.id)); } catch (Exception e) { } } } } } public HashMap<String, Client> getClientListeners() { return this.clientListeners; } public void incrementUpdateIteration() { this.updateIteration++; } public Long getUpdateIteration() { return this.updateIteration; } public Graph getGraph() { return this.graph; } public void setGraph(Graph g) { this.graph = g; } public void addAdminListener(ClientListener adminListener) { adminListeners.add(adminListener); } public ArrayList<ClientListener> getAdminListeners() { return this.adminListeners; } public void addClientListener(Client clientListener) { clientListeners.put(clientListener.id, clientListener); } @Override
  public void edgeAdded(Edge edge) { for (ClientListener al : adminListeners)
      al.edgeAdded(edge); } @Override
  public void edgePropertyChanged(Edge edge, String key, Object oldValue, Object setValue) { for (ClientListener al : adminListeners)
      al.edgePropertyChanged(edge, key, setValue); } @Override
  public void edgePropertyRemoved(Edge edge, String key, Object removedValue) { for (ClientListener al : adminListeners)
      al.edgePropertyRemoved(edge, key); } @Override
  public void edgeRemoved(Edge edge, Map<String, Object> props) { for (ClientListener al : adminListeners)
      al.edgeRemoved(edge); } @Override
  public void vertexAdded(Vertex vertex) { for (ClientListener al : adminListeners)
      al.vertexAdded(vertex); } @Override
  public void vertexPropertyChanged(Vertex vertex, String key, Object oldValue, Object setValue) { for (ClientListener al : adminListeners)
      al.vertexPropertyChanged(vertex, key, oldValue, setValue); } @Override
  public void vertexPropertyRemoved(Vertex vertex, String key, Object removedValue) { for (ClientListener al : adminListeners)
      al.vertexPropertyRemoved(vertex, key); } @Override
  public void vertexRemoved(Vertex vertex, Map<String, Object> props) { for (ClientListener al : adminListeners)
      al.vertexRemoved(vertex); } }",0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; public class IteratedBreadboardGraphChangedListener implements BreadboardGraphChangedListener { private Graph graph; private Long updateIteration = 0L; private ArrayList<ClientListener> adminListeners = new ArrayList<>(); private HashMap<String, Client> clientListeners = new HashMap<>(); static ActorRef clientUpdateActor; public IteratedBreadboardGraphChangedListener(Graph graph) { this.graph = graph; clientUpdateActor = Akka.system().actorOf(new Props(ClientUpdateActor.class)); Long clientUpdateRate = play.Play.application().configuration().getMilliseconds(""breadboard.clientUpdateRate""); if (clientUpdateRate == null) { <FILL_ME> clientUpdateRate = 1000L; } Akka.system().scheduler().schedule(
        Duration.create(0, TimeUnit.MILLISECONDS),
        Duration.create(clientUpdateRate, TimeUnit.MILLISECONDS),
        clientUpdateActor,
        new ClientUpdateActorProtocol.ClientUpdate(this),
        Akka.system().dispatcher(),
        null
    ); } private class ClientUpdateTask implements Runnable { @Override
    public void run() { updateIteration++; if (updateIteration % 10 == 0) { <FILL_ME> } for(Client c : clientListeners.values()) { if (graph.getVertex(c.id) != null) { try { c.updateGraph(graph.getVertex(c.id)); } catch (Exception e) { <FILL_ME> } } } } } public HashMap<String, Client> getClientListeners() { return this.clientListeners; } public void incrementUpdateIteration() { this.updateIteration++; } public Long getUpdateIteration() { return this.updateIteration; } public Graph getGraph() { return this.graph; } public void setGraph(Graph g) { this.graph = g; } public void addAdminListener(ClientListener adminListener) { adminListeners.add(adminListener); } public ArrayList<ClientListener> getAdminListeners() { return this.adminListeners; } public void addClientListener(Client clientListener) { clientListeners.put(clientListener.id, clientListener); } @Override
  public void edgeAdded(Edge edge) { for (ClientListener al : adminListeners)
      al.edgeAdded(edge); } @Override
  public void edgePropertyChanged(Edge edge, String key, Object oldValue, Object setValue) { for (ClientListener al : adminListeners)
      al.edgePropertyChanged(edge, key, setValue); } @Override
  public void edgePropertyRemoved(Edge edge, String key, Object removedValue) { for (ClientListener al : adminListeners)
      al.edgePropertyRemoved(edge, key); } @Override
  public void edgeRemoved(Edge edge, Map<String, Object> props) { for (ClientListener al : adminListeners)
      al.edgeRemoved(edge); } @Override
  public void vertexAdded(Vertex vertex) { for (ClientListener al : adminListeners)
      al.vertexAdded(vertex); } @Override
  public void vertexPropertyChanged(Vertex vertex, String key, Object oldValue, Object setValue) { for (ClientListener al : adminListeners)
      al.vertexPropertyChanged(vertex, key, oldValue, setValue); } @Override
  public void vertexPropertyRemoved(Vertex vertex, String key, Object removedValue) { for (ClientListener al : adminListeners)
      al.vertexPropertyRemoved(vertex, key); } @Override
  public void vertexRemoved(Vertex vertex, Map<String, Object> props) { for (ClientListener al : adminListeners)
      al.vertexRemoved(vertex); } } ","package models; 
import actors.ClientUpdateActor; import actors.ClientUpdateActorProtocol; import com.tinkerpop.blueprints.Edge; import com.tinkerpop.blueprints.Graph; import com.tinkerpop.blueprints.Vertex; import play.Logger; import play.libs.Akka; 
import java.util.ArrayList; import java.util.HashMap; import java.util.Map; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; import akka.actor.*; import scala.concurrent.duration.Duration;  public class IteratedBreadboardGraphChangedListener implements BreadboardGraphChangedListener { private Graph graph; private Long updateIteration = 0L; private ArrayList<ClientListener> adminListeners = new ArrayList<>(); private HashMap<String, Client> clientListeners = new HashMap<>();  static ActorRef clientUpdateActor;  public IteratedBreadboardGraphChangedListener(Graph graph) { this.graph = graph; clientUpdateActor = Akka.system().actorOf(new Props(ClientUpdateActor.class)); Long clientUpdateRate = play.Play.application().configuration().getMilliseconds(""breadboard.clientUpdateRate""); if (clientUpdateRate == null) { <FILL_ME> clientUpdateRate = 1000L; } Akka.system().scheduler().schedule(
        Duration.create(0, TimeUnit.MILLISECONDS),
        Duration.create(clientUpdateRate, TimeUnit.MILLISECONDS),
        clientUpdateActor,
        new ClientUpdateActorProtocol.ClientUpdate(this),
        Akka.system().dispatcher(),
        null
    ); }  private class ClientUpdateTask implements Runnable { @Override
    public void run() { updateIteration++; if (updateIteration % 10 == 0) { <FILL_ME> }  for(Client c : clientListeners.values()) { if (graph.getVertex(c.id) != null) { try { c.updateGraph(graph.getVertex(c.id)); } catch (Exception e) { <FILL_ME> } } } } }  public HashMap<String, Client> getClientListeners() { return this.clientListeners; }  public void incrementUpdateIteration() { this.updateIteration++; }  public Long getUpdateIteration() { return this.updateIteration; }  public Graph getGraph() { return this.graph; }  public void setGraph(Graph g) { this.graph = g; }  public void addAdminListener(ClientListener adminListener) { adminListeners.add(adminListener); }  public ArrayList<ClientListener> getAdminListeners() { return this.adminListeners; }  public void addClientListener(Client clientListener) { clientListeners.put(clientListener.id, clientListener); }  @Override
  public void edgeAdded(Edge edge) { for (ClientListener al : adminListeners)
      al.edgeAdded(edge); }  @Override
  public void edgePropertyChanged(Edge edge, String key, Object oldValue, Object setValue) { for (ClientListener al : adminListeners)
      al.edgePropertyChanged(edge, key, setValue); }  @Override
  public void edgePropertyRemoved(Edge edge, String key, Object removedValue) { for (ClientListener al : adminListeners)
      al.edgePropertyRemoved(edge, key); }  @Override
  public void edgeRemoved(Edge edge, Map<String, Object> props) { for (ClientListener al : adminListeners)
      al.edgeRemoved(edge); }  @Override
  public void vertexAdded(Vertex vertex) { for (ClientListener al : adminListeners)
      al.vertexAdded(vertex); }  @Override
  public void vertexPropertyChanged(Vertex vertex, String key, Object oldValue, Object setValue) { for (ClientListener al : adminListeners)
      al.vertexPropertyChanged(vertex, key, oldValue, setValue); }  @Override
  public void vertexPropertyRemoved(Vertex vertex, String key, Object removedValue) { for (ClientListener al : adminListeners)
      al.vertexPropertyRemoved(vertex, key); }  @Override
  public void vertexRemoved(Vertex vertex, Map<String, Object> props) { for (ClientListener al : adminListeners)
      al.vertexRemoved(vertex); } }  "
app/models/Language.java,"package models;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.databind.node.ObjectNode;
import play.db.ebean.Model;
import play.libs.Json;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

@Entity
@Table(name = ""languages"")
public class Language extends Model {
  @Id
  public Long id;

  public String code;

  public String name;

  @ManyToMany
  @JoinTable(name = ""experiments_languages"")
  public List<Experiment> experiments = new ArrayList<>();

  @JsonIgnore
  public static Finder<Long, Language> find = new Finder(Long.class, Language.class);

  @JsonIgnore
  public static List<Language> findAll() {
    return find.all();
  }

  @JsonIgnore
  public static Language findById(Long id) {
    return find.where().eq(""id"", id).findUnique();
  }

  @JsonIgnore
  public static Language findByIso3(String iso3) { return find.where().eq(""code"", iso3).findUnique(); }

  @JsonIgnore
  public static Language fromIso3(String iso3) {
    Locale locale = new Locale(iso3);
    Language language = new Language();
    language.setCode(iso3);
    language.setName(locale.getDisplayName());
    return language;
  }

  public Language() {}

  public Long getId() {
    return id;
  }

  public void setId(Long id) {
    this.id = id;
  }

  public String getCode() {
    return code;
  }

  public void setCode(String code) {
    this.code = code;
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  @JsonIgnore
  public ObjectNode toJson() {
    ObjectNode language = Json.newObject();
    language.put(""id"", id);
    language.put(""code"", code);
    language.put(""name"", name);
    return language;
  }

  @JsonIgnore
  public String toString() {
    return ""Language("" + id + "")"";
  }
}
","package models; @Entity
@Table(name = ""languages"")
public class Language extends Model { @Id
  public Long id; public String code; public String name; @ManyToMany
  @JoinTable(name = ""experiments_languages"")
  public List<Experiment> experiments = new ArrayList<>(); @JsonIgnore
  public static Finder<Long, Language> find = new Finder(Long.class, Language.class); @JsonIgnore
  public static List<Language> findAll() { return find.all(); } @JsonIgnore
  public static Language findById(Long id) { return find.where().eq(""id"", id).findUnique(); } @JsonIgnore
  public static Language findByIso3(String iso3) { return find.where().eq(""code"", iso3).findUnique(); } @JsonIgnore
  public static Language fromIso3(String iso3) { Locale locale = new Locale(iso3); Language language = new Language(); language.setCode(iso3); language.setName(locale.getDisplayName()); return language; } public Language() { } public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getCode() { return code; } public void setCode(String code) { this.code = code; } public String getName() { return name; } public void setName(String name) { this.name = name; } @JsonIgnore
  public ObjectNode toJson() { ObjectNode language = Json.newObject(); language.put(""id"", id); language.put(""code"", code); language.put(""name"", name); return language; } @JsonIgnore
  public String toString() { return ""Language("" + id + "")""; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; @Entity
@Table(name = ""languages"")
public class Language extends Model { @Id
  public Long id; public String code; public String name; @ManyToMany
  @JoinTable(name = ""experiments_languages"")
  public List<Experiment> experiments = new ArrayList<>(); @JsonIgnore
  public static Finder<Long, Language> find = new Finder(Long.class, Language.class); @JsonIgnore
  public static List<Language> findAll() { return find.all(); } @JsonIgnore
  public static Language findById(Long id) { return find.where().eq(""id"", id).findUnique(); } @JsonIgnore
  public static Language findByIso3(String iso3) { return find.where().eq(""code"", iso3).findUnique(); } @JsonIgnore
  public static Language fromIso3(String iso3) { Locale locale = new Locale(iso3); Language language = new Language(); language.setCode(iso3); language.setName(locale.getDisplayName()); return language; } public Language() { } public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getCode() { return code; } public void setCode(String code) { this.code = code; } public String getName() { return name; } public void setName(String name) { this.name = name; } @JsonIgnore
  public ObjectNode toJson() { ObjectNode language = Json.newObject(); language.put(""id"", id); language.put(""code"", code); language.put(""name"", name); return language; } @JsonIgnore
  public String toString() { return ""Language("" + id + "")""; } } ","package models; 
import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.databind.node.ObjectNode; import play.db.ebean.Model; import play.libs.Json; 
import javax.persistence.*; import java.util.ArrayList; import java.util.List; import java.util.Locale;  @Entity
@Table(name = ""languages"")
public class Language extends Model { @Id
  public Long id;  public String code;  public String name;  @ManyToMany
  @JoinTable(name = ""experiments_languages"")
  public List<Experiment> experiments = new ArrayList<>();  @JsonIgnore
  public static Finder<Long, Language> find = new Finder(Long.class, Language.class);  @JsonIgnore
  public static List<Language> findAll() { return find.all(); }  @JsonIgnore
  public static Language findById(Long id) { return find.where().eq(""id"", id).findUnique(); }  @JsonIgnore
  public static Language findByIso3(String iso3) { return find.where().eq(""code"", iso3).findUnique(); }  @JsonIgnore
  public static Language fromIso3(String iso3) { Locale locale = new Locale(iso3); Language language = new Language(); language.setCode(iso3); language.setName(locale.getDisplayName()); return language; }  public Language() { }  public Long getId() { return id; }  public void setId(Long id) { this.id = id; }  public String getCode() { return code; }  public void setCode(String code) { this.code = code; }  public String getName() { return name; }  public void setName(String name) { this.name = name; }  @JsonIgnore
  public ObjectNode toJson() { ObjectNode language = Json.newObject(); language.put(""id"", id); language.put(""code"", code); language.put(""name"", name); return language; }  @JsonIgnore
  public String toString() { return ""Language("" + id + "")""; } }  "
app/models/Parameter.java,"package models;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.databind.node.ObjectNode;
import play.data.format.Formats;
import play.data.validation.Constraints;
import play.db.ebean.Model;
import play.libs.Json;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;
import java.util.List;

@Entity
@Table(name = ""parameters"")
public class Parameter extends Model {
  @Id
  public Long id;

  @Constraints.Required
  @Formats.NonEmpty
  public String name;

  public String type;

  public String minVal;
  public String maxVal;

  public String defaultVal;

  public String description;

  @JsonIgnore
  public static Model.Finder<String, Parameter> find = new Model.Finder(String.class, Parameter.class);

  public static List<Parameter> findAll() {
    return find.all();
  }

  public Parameter() {
  }

  public Parameter(Parameter parameter) {
    this.name = parameter.name;
    this.type = parameter.type;
    this.minVal = parameter.minVal;
    this.maxVal = parameter.maxVal;
    this.defaultVal = parameter.defaultVal;
    this.description = parameter.description;
  }

  public ObjectNode toJson() {
    ObjectNode parameter = Json.newObject();
    parameter.put(""id"", id);
    parameter.put(""name"", name);
    parameter.put(""type"", type);
    parameter.put(""minVal"", minVal);
    parameter.put(""maxVal"", maxVal);
    parameter.put(""defaultVal"", defaultVal);
    parameter.put(""description"", description);
    return parameter;
  }

  public String toString() {
    return ""Parameter("" + id + "")"";
  }
}
","package models; @Entity
@Table(name = ""parameters"")
public class Parameter extends Model { @Id
  public Long id; @Constraints.Required
  @Formats.NonEmpty
  public String name; public String type; public String minVal; public String maxVal; public String defaultVal; public String description; @JsonIgnore
  public static Model.Finder<String, Parameter> find = new Model.Finder(String.class, Parameter.class); public static List<Parameter> findAll() { return find.all(); } public Parameter() { } public Parameter(Parameter parameter) { this.name = parameter.name; this.type = parameter.type; this.minVal = parameter.minVal; this.maxVal = parameter.maxVal; this.defaultVal = parameter.defaultVal; this.description = parameter.description; } public ObjectNode toJson() { ObjectNode parameter = Json.newObject(); parameter.put(""id"", id); parameter.put(""name"", name); parameter.put(""type"", type); parameter.put(""minVal"", minVal); parameter.put(""maxVal"", maxVal); parameter.put(""defaultVal"", defaultVal); parameter.put(""description"", description); return parameter; } public String toString() { return ""Parameter("" + id + "")""; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; @Entity
@Table(name = ""parameters"")
public class Parameter extends Model { @Id
  public Long id; @Constraints.Required
  @Formats.NonEmpty
  public String name; public String type; public String minVal; public String maxVal; public String defaultVal; public String description; @JsonIgnore
  public static Model.Finder<String, Parameter> find = new Model.Finder(String.class, Parameter.class); public static List<Parameter> findAll() { return find.all(); } public Parameter() { } public Parameter(Parameter parameter) { this.name = parameter.name; this.type = parameter.type; this.minVal = parameter.minVal; this.maxVal = parameter.maxVal; this.defaultVal = parameter.defaultVal; this.description = parameter.description; } public ObjectNode toJson() { ObjectNode parameter = Json.newObject(); parameter.put(""id"", id); parameter.put(""name"", name); parameter.put(""type"", type); parameter.put(""minVal"", minVal); parameter.put(""maxVal"", maxVal); parameter.put(""defaultVal"", defaultVal); parameter.put(""description"", description); return parameter; } public String toString() { return ""Parameter("" + id + "")""; } } ","package models; 
import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.databind.node.ObjectNode; import play.data.format.Formats; import play.data.validation.Constraints; import play.db.ebean.Model; import play.libs.Json; 
import javax.persistence.Entity; import javax.persistence.Id; import javax.persistence.Table; import java.util.List;  @Entity
@Table(name = ""parameters"")
public class Parameter extends Model { @Id
  public Long id;  @Constraints.Required
  @Formats.NonEmpty
  public String name;  public String type;  public String minVal; public String maxVal;  public String defaultVal;  public String description;  @JsonIgnore
  public static Model.Finder<String, Parameter> find = new Model.Finder(String.class, Parameter.class);  public static List<Parameter> findAll() { return find.all(); }  public Parameter() { }  public Parameter(Parameter parameter) { this.name = parameter.name; this.type = parameter.type; this.minVal = parameter.minVal; this.maxVal = parameter.maxVal; this.defaultVal = parameter.defaultVal; this.description = parameter.description; }  public ObjectNode toJson() { ObjectNode parameter = Json.newObject(); parameter.put(""id"", id); parameter.put(""name"", name); parameter.put(""type"", type); parameter.put(""minVal"", minVal); parameter.put(""maxVal"", maxVal); parameter.put(""defaultVal"", defaultVal); parameter.put(""description"", description); return parameter; }  public String toString() { return ""Parameter("" + id + "")""; } }  "
app/models/PlayerActionsInterface.java,"package models;

public interface PlayerActionsInterface {
  void choose(String uid, String params);

  void remove(String pid);

  void turnAIOff();

  void turnAIOn();
}
","package models; public interface PlayerActionsInterface { void choose(String uid, String params); void remove(String pid); void turnAIOff(); void turnAIOn(); }",0 0 0 0 0 0 0 0,"package models; public interface PlayerActionsInterface { void choose(String uid, String params); void remove(String pid); void turnAIOff(); void turnAIOn(); } ","package models;  public interface PlayerActionsInterface { void choose(String uid, String params);  void remove(String pid);  void turnAIOff();  void turnAIOn(); }  "
app/models/QualificationRequirement.java,"package models;

public class QualificationRequirement {
  public String qualificationTypeId;
  public String comparator;
  public String integerValue;
}
",package models; public class QualificationRequirement { public String qualificationTypeId; public String comparator; public String integerValue; },0 0 0 0 0 0 0,package models; public class QualificationRequirement { public String qualificationTypeId; public String comparator; public String integerValue; } ,package models;  public class QualificationRequirement { public String qualificationTypeId; public String comparator; public String integerValue; }  
app/models/ScriptBoard.java,"package models;

import akka.actor.*;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Graph;
import com.tinkerpop.blueprints.Vertex;
import com.tinkerpop.gremlin.groovy.GremlinGroovyPipeline;
import groovy.util.ObservableMap;
import groovy.lang.Closure;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.output.ByteArrayOutputStream;
import org.apache.commons.lang3.StringUtils;
import org.codehaus.groovy.control.CompilationFailedException;
import play.Logger;
import play.Play;
import play.libs.F.Callback;
import play.libs.Json;
import play.mvc.WebSocket;

import javax.script.*;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.IOException;
import java.util.*;

public class ScriptBoard extends UntypedActor {
  private static ObjectMapper mapper = new ObjectMapper();

  private static ScriptEngineManager manager = new ScriptEngineManager();
  private static ScriptEngine engine;

  private static Map results = new HashMap();
  private static PlayerActionsInterface playerActions;
  private static BreadboardGraphInterface graphInterface;
  private static BreadboardGraphChangedListener graphChangedListener;
  private static FileWatcher fileWatcher;
  private static EventTracker eventTracker = new EventTracker();
  private static EventBus<Map> eventBus = new EventBus();

  private static Random rand = new Random();
  private static HashMap<String, Client> clients = new HashMap<>();

  // A list of admins currently watching the game.
  private static ArrayList<Admin> admins = new ArrayList<>();
  private static UserDataInterface instanceData;
  private GameListener gameListener = new GameListener();

  private Long experimentId;
  private Long instanceId;

  public static boolean checkPassword(String _password) {
    // If no password is set, always return true
    if (engine == null || engine.get(""password"") == null)
      return true;
    Object password = engine.get(""password"");
    return _password.equals(password.toString());
  }

  public ScriptBoard() throws IOException, ScriptException {
    rebuildScriptBoard(null);
  }

  private void init() {
    results = new HashMap();
    mapper = new ObjectMapper();
    admins = new ArrayList<>();
    clients = new HashMap<>();
    eventTracker = new EventTracker();
    manager = new ScriptEngineManager();
    eventBus.clear();
  }

  private void disconnectClients () {
    // Disconnect all connected clients
    for (Client client : clients.values()) {
      client.disconnect();
    }
    clients.clear();
  }

  private void resetEngine(Experiment experiment) throws IOException, ScriptException {
    // When started, send a message to each Admin
    for (Admin admin : admins) {
      ObjectNode jsonOutput = Json.newObject();
      ObjectNode notify = Json.newObject();
      notify.put(""ScriptEngineReloading"", new Date().getTime());
      jsonOutput.put(""notify"", notify);
      admin.getOut().write(jsonOutput);
    }
    Logger.debug(""ScriptEngine reload start"");
    if (engine != null) {
      // just in case
      playerActions.turnAIOff();
      // clean up the graph
      processScript(""g.empty()"", null, null);
      // Reset the timers
      processScript(""timers.cancel()"", null, null);
    }

    // Global events used to communicate via the groovy scripting
    eventBus.clear();
    eventBus.on(""__send-event"", new Closure(null) {
      public void doCall (String clientId, String eventName, Object ...data) {
        Logger.debug(""client send "" + clientId);
        Client client = clients.get(clientId);
        if (client == null) {
          Logger.error(""Client with id, "" + clientId + "" has not connected yet"");
          return;
        }
        client.send(eventName, data);
      }
    });
    eventBus.on(""__broadcast-event"", new Closure(null) {
      public void doCall (String clientId, String eventName, Object ...data) {
        Logger.debug(""client broadcast "" + clientId);
        for (Client client : clients.values()) {
          client.send(eventName, data);
        }
      }
    });

    engine = manager.getEngineByName(""gremlin-groovy"");
    engine.getBindings(ScriptContext.ENGINE_SCOPE).put(""r"", rand);
    engine.getBindings(ScriptContext.ENGINE_SCOPE).put(""results"", results);

    engine.getBindings(ScriptContext.ENGINE_SCOPE).put(""eventTracker"", eventTracker);
    engine.getBindings(ScriptContext.ENGINE_SCOPE).put(""gameListener"", gameListener);
    engine.getBindings(ScriptContext.ENGINE_SCOPE).put(""events"", eventBus);

    if (experiment != null) {
      engine.getBindings(ScriptContext.ENGINE_SCOPE).put(""c"", experiment.contentFetcher);
    }

    String[] scriptFiles = {
      ""/util.groovy"", 
      ""/timer.groovy"",
      ""/graph.groovy"", 
      ""/actions.groovy"", 
      ""/step.groovy"", 
      ""/test.groovy"",
      ""/events.groovy"",
      ""/chat.groovy"",
      ""/form.groovy"",
      ""/ready.groovy""
    };

    // Load Groovy scripts
    for (String file : scriptFiles) {
      File utilFile = new File(Play.application().path().toString() + ""/groovy"" + file);
      // Add a null terminator for each file so the script engine can always reload even after errors
      String utilString = FileUtils.readFileToString(utilFile, ""UTF-8"") + "";null;"";
      Logger.debug(""loading "" + file);
      engine.eval(utilString);
      Logger.debug(file + "" load done"");
    }

    // get script object on which we want to implement the interface with
    Object a = engine.get(""a"");
    Invocable inv = (Invocable) engine;
    playerActions = inv.getInterface(a, PlayerActionsInterface.class);

    Object d = engine.get(""d"");
    instanceData = inv.getInterface(d, UserDataInterface.class);

    Object g = engine.get(""g"");
    graphInterface = inv.getInterface(g, BreadboardGraphInterface.class);

    if (graphChangedListener == null) {
      Logger.debug(""graphChangedListener == null"");
      Long clientUpdateRate = play.Play.application().configuration().getMilliseconds(""breadboard.clientUpdateRate"");
      if (clientUpdateRate == null || clientUpdateRate == 0) {
        Logger.debug(""clientUpdateRate not found or 0, using event based updating"");
        graphChangedListener = new EventGraphChangedListener((Graph) g);

      } else {
        Logger.debug(""clientUpdateRate found, using polling"");
        graphChangedListener = new IteratedBreadboardGraphChangedListener((Graph) g);
      }
    } else {
      Logger.debug(""graphChangedListener != null"");
      graphChangedListener.setGraph((Graph) g);
    }

    graphInterface.addListener(graphChangedListener);

    if (fileWatcher == null) {
      fileWatcher = new FileWatcher(admins);
    }

    gameListener.engine = engine;

    // When done, send a message to each Admin
    for (Admin admin : admins) {
      ObjectNode jsonOutput = Json.newObject();
      ObjectNode notify = Json.newObject();
      notify.put(""ScriptEngineReloaded"", new Date().getTime());
      jsonOutput.put(""notify"", notify);
      admin.getOut().write(jsonOutput);
    }
    this.disconnectClients();
    Logger.debug(""ScriptEngine reload complete"");
  }

  private void loadSteps(Experiment experiment, ThrottledWebSocketOut out) {
    for (Step step : experiment.getSteps()) {
      //should call RunStep?
      processScript(step.source + "";null;"", out, step.name);
    }
  }

  private String makeUniqueClientId (String clientId) {
    return this.experimentId + ""-"" + this.instanceId + ""-"" + clientId;
  }

  private void rebuildScriptBoard(Experiment experiment) throws IOException, ScriptException {
    //init();
    resetEngine(experiment);
  }

  public static void addAdmin(Admin admin) {
    admins.add(admin);
    graphChangedListener.addAdminListener(admin);
  }

  public static void addClient(String experimentIdString, String experimentInstanceIdString, String clientId, final WebSocket.In<JsonNode> in, final ThrottledWebSocketOut out) throws Exception {
    try {
      Long experimentId = Long.parseLong(experimentIdString);
      Long experimentInstanceId = Long.parseLong(experimentInstanceIdString);

      Experiment experiment = Experiment.findById(experimentId);
      if (experiment == null) {
        Logger.debug(""addClient: experiment == null"");
        return;
      }

      ExperimentInstance experimentInstance = null;
      if (experimentInstanceId.equals(Experiment.TEST_INSTANCE_ID)) {
        experimentInstance = experiment.getTestInstance();
      } else {
        experimentInstance = ExperimentInstance.findById(experimentInstanceId);
      }
      if (experimentInstance == null) {
        Logger.debug(""addClient: experimentInstance == null"");
        return;
      }

      Client client = clients.get(clientId);

      if (client == null && experimentInstance.hasStarted) {
        Logger.debug(""New client trying to join after game has already started."");
        return;
      }

      if (client == null) {
        // New client, let's create a new Client object
        client = new Client(clientId, experimentInstance, in, out);
        clients.put(clientId, client);
      } else {
        // Reconnecting: let's change the in / out so they continue to receive messages
        client.setIn(in);
        client.setOut(out);
      }

      in.onMessage(new Callback<JsonNode>() {
        public void invoke(JsonNode event) {
          try {
            ObjectMapper mapper = new ObjectMapper();
            // TODO: is event.toString() the correct method here?
            Map<String, Object> jsonInput = mapper.readValue(event.toString(), Map.class);
            String action = jsonInput.get(""action"").toString();
            if (action.equals(""LogIn"")) {
              String clientId = jsonInput.get(""clientId"").toString();
              String referer = jsonInput.get(""referer"").toString();
              String connection = jsonInput.get(""connection"").toString();
              String accept = jsonInput.get(""accept"").toString();
              String acceptLanguage = jsonInput.get(""acceptLanguage"").toString();
              String acceptEncoding = jsonInput.get(""acceptEncoding"").toString();
              String userAgent = jsonInput.get(""userAgent"").toString();
              String host = jsonInput.get(""host"").toString();
              String ipAddress = jsonInput.get(""ipAddress"").toString();
              String requestURI = jsonInput.get(""requestURI"").toString();

              if (eventTracker != null) {
                LinkedHashMap<Object, Object> data = new LinkedHashMap<Object, Object>();
                data.put(""clientId"", clientId);
                data.put(""referer"", referer);
                data.put(""connection"", connection);
                data.put(""acceptLanguage"", acceptLanguage);
                data.put(""acceptEncoding"", acceptEncoding);
                data.put(""userAgent"", userAgent);
                data.put(""host"", host);
                data.put(""ipAddress"", ipAddress);
                data.put(""requestURI"", requestURI);
                eventTracker.track(""clientLogIn"", data);
              }
            } else if (action.equals(""MakeChoice"")) {
              String choiceUID = jsonInput.get(""choiceUID"").toString();
              String params = (jsonInput.containsKey(""params"")) ? jsonInput.get(""params"").toString() : null;
              makeChoice(choiceUID, params, out);
            } else if (action.equals(""CustomEvent"")) {
              // TODO: Is is possible for this to be emitted before the event has been registered? 
              //       I think it is and I think it will cause exceptions to be thrown...
              eventBus.emit(""CustomEvent"", jsonInput, new HashMap<String, String>() {{
                put(""clientId"", clientId);
            }});
            }
          } catch (java.io.IOException ignored) {
            Logger.debug(""java.io.IOException"");
          } catch (Exception e) {
            Logger.error(e.getMessage());
          }
        }
      });

      if (graphChangedListener != null) {
        graphChangedListener.addClientListener(client);
      }

      if (graphInterface != null) {
        if (!experimentInstance.hasStarted) {
          graphInterface.addPlayer(clientId);
        }
        Graph wholeGraph = (Graph) engine.get(""g"");
        Vertex clientVertex = wholeGraph.getVertex(clientId);
        if (clientVertex != null) {
          if (graphChangedListener instanceof EventGraphChangedListener) {
            client.updateGraph(clientVertex);
          }
        }
      }

      // Update the client's state
      ObjectNode jsonOutput = Json.newObject();
      jsonOutput.put(""style"", experimentInstance.experiment.getStyle());
      Logger.debug(""addClient, "" + clientId);
      out.write(jsonOutput);
    } catch (NumberFormatException nfe) {
      Logger.debug(""addClient: NumberFormatException"");
    }
  }

  public void onReceive(Object message) throws Exception {
    try {
      if (message instanceof Breadboard.BreadboardMessage) {
        Breadboard.BreadboardMessage breadboardMessage = (Breadboard.BreadboardMessage) message;
        if (breadboardMessage.user != null) {
          gameListener.user = breadboardMessage.user;
          gameListener.out = breadboardMessage.out;
        }
        if (message instanceof Breadboard.AddAdmin) {
          Breadboard.AddAdmin addAdmin = (Breadboard.AddAdmin) message;

          addAdmin(new Admin(addAdmin.user, addAdmin.scriptBoardController, addAdmin.out));
        } else if (message instanceof Breadboard.RunGame) {
          if (breadboardMessage.user != null) {
            // Run Game
            processScript(""initStep.start()"", breadboardMessage.out, null);
          }

        } else if (message instanceof Breadboard.HitCreated) {
          Breadboard.HitCreated hitCreated = (Breadboard.HitCreated) message;
          if (breadboardMessage.user != null) {
            Integer lifetimeInMs = hitCreated.lifetimeInSeconds * 1000;
            Integer tutorialTimeInMs = hitCreated.tutorialTime * 1000;
            Long timerTime = System.currentTimeMillis() + (lifetimeInMs + tutorialTimeInMs);
            // startAt will be used to add timer to clients for start of game
            processScript(""startAt = "" + timerTime, breadboardMessage.out, null);

            final ThrottledWebSocketOut breadboardOut = breadboardMessage.out;
            // Set timer for lifetimeInSeconds time after which no longer allow new client connections
            new Timer().schedule(new TimerTask() {
              @Override
              public void run() {
                gameListener.hasStarted();
              }
            }, lifetimeInMs);

            // Set timer for lifetimeInMs + tutorialTimeInMs time after which send an initStep.start() message
            new Timer().schedule(new TimerTask() {
              @Override
              public void run() {
                processScript(""initStep.start()"", breadboardOut, null);
                Logger.debug(""initStep.start()"");
              }
            }, (lifetimeInMs + tutorialTimeInMs));
          }
        } else if (message instanceof Breadboard.SendScript) {
          Breadboard.SendScript sendScript = (Breadboard.SendScript) message;

          if (breadboardMessage.user != null) {
            // Save script in database
            breadboardMessage.user.currentScript = sendScript.script;
            breadboardMessage.user.update();

            // Process script
            processScript(sendScript.script, breadboardMessage.out, null);
          }

        } else if (message instanceof Breadboard.MakeChoice) {
          Breadboard.MakeChoice makeChoice = (Breadboard.MakeChoice) message;
          makeChoice(makeChoice.uid, makeChoice.params, breadboardMessage.out);
        } else if (message instanceof Breadboard.SendStep) {
          Breadboard.SendStep sendStep = (Breadboard.SendStep) message;

          if (breadboardMessage.user != null && breadboardMessage.user.selectedExperiment != null) {
            Logger.debug(""SendStep: "" + sendStep.id + "", "" + sendStep.name + "", "" + sendStep.source);
            // Now we only run the step
            Breadboard.instances.get(breadboardMessage.user.email).tell(new Breadboard.RunStep(breadboardMessage.user, sendStep.source, breadboardMessage.out), null);
          }
        } else if (message instanceof Breadboard.RunStep) {
          // TODO: Compile step here and make available to scripting engine
          Breadboard.RunStep runStep = (Breadboard.RunStep) message;
          processScript(runStep.source, breadboardMessage.out, null);
        } else if (message instanceof Breadboard.ChangeExperiment) {
          if (breadboardMessage.user != null) {
            rebuildScriptBoard(breadboardMessage.user.selectedExperiment);
            loadSteps(breadboardMessage.user.selectedExperiment, breadboardMessage.out);
            Breadboard.ChangeExperiment changeExperiment = (Breadboard.ChangeExperiment) message;

            //reset the instance
            if (breadboardMessage.user.experimentInstanceId != -1) {
              ExperimentInstance runningInstance = ExperimentInstance.findById(breadboardMessage.user.experimentInstanceId);
              if (runningInstance != null) {
                if (runningInstance.status == ExperimentInstance.Status.RUNNING && runningInstance.experiment.id.equals(changeExperiment.experiment.id)) {
                  eventTracker.setExperimentInstance(runningInstance);
                  gameListener.experimentInstance = runningInstance;
                  for (Data param : runningInstance.data) {
                    initParam(param, changeExperiment.experiment);
                  }
                }
              } else {
                Logger.error(""runningInstance == null"");
              }
            }
          }
        } else if (message instanceof Breadboard.DeleteExperiment) {
          Breadboard.DeleteExperiment deleteExperiment = (Breadboard.DeleteExperiment) message;

          Experiment toBeDeleteExperiment = deleteExperiment.user.getExperimentByName(deleteExperiment.experimentName);
          Logger.debug(""DeleteExperiment: "" + toBeDeleteExperiment.name);

          //also stops the game
          for (Parameter p : breadboardMessage.user.getExperiment().getParameters()) {
            Logger.debug(""Key: "" + p.name);
            if (engine.getBindings(ScriptContext.ENGINE_SCOPE).containsKey(p.name))
              engine.getBindings(ScriptContext.ENGINE_SCOPE).remove(p.name);
          }

          breadboardMessage.user.currentScript = """";
          processScript(""g.empty()"", breadboardMessage.out, null);

          if (toBeDeleteExperiment != null) {
            //needs to remove all the selectedExperiment and ownedExperiments which is this toBeDeleteExperiment
            List<User> users = User.find.all();

            boolean update;
            boolean updateManyToMany;
            for (User user : users) {
              if (user.email.equalsIgnoreCase(breadboardMessage.user.email)) {
                user = breadboardMessage.user;
                user.setExperimentInstanceId(-1L);
              }
              update = false;
              updateManyToMany = false;
              if (user.selectedExperiment != null && user.selectedExperiment.id == toBeDeleteExperiment.id) {
                update = true;
                user.setSelectedExperiment(null);
              }
              if (user.ownedExperiments.contains(toBeDeleteExperiment)) {
                updateManyToMany = true;
                user.ownedExperiments.remove(toBeDeleteExperiment);
              }
              if (update) {
                user.update();
              }
              if (updateManyToMany) {
                user.saveManyToManyAssociations(""ownedExperiments"");
              }
            }

            toBeDeleteExperiment.delete();
          }

          Breadboard.breadboardController.tell(new Breadboard.Update(breadboardMessage.user, breadboardMessage.out), null);
        } else if (message instanceof Breadboard.LaunchGame) {
          Breadboard.LaunchGame launchGame = (Breadboard.LaunchGame) message;

          if (breadboardMessage.user.selectedExperiment != null) {
            rebuildScriptBoard(breadboardMessage.user.selectedExperiment);
            ExperimentInstance instance = startGame(launchGame.name, breadboardMessage.user.experimentInstanceId, launchGame.parameters,
                breadboardMessage.user.selectedExperiment, breadboardMessage.user);

            instanceData.addPropertyChangeListener(new UserDataChangeListener(instance));

            eventTracker.enable();
            eventTracker.setExperimentInstance(instance);
            gameListener.experimentInstance = instance;
            gameListener.start();

            // Re-run the Steps
            for (Step step : instance.experiment.getSteps())
              Breadboard.instances.get(breadboardMessage.user.email).tell(new Breadboard.RunStep(breadboardMessage.user, step.source, breadboardMessage.out), null);

          } // END if (breadboardMessage.user.selectedExperiment != null)
          // Update User JSON
          Breadboard.breadboardController.tell(new Breadboard.Update(breadboardMessage.user, breadboardMessage.out), null);

        } // END else if(message instanceof Breadboard.LaunchGame)
        else if (message instanceof Breadboard.SelectInstance) {
          Breadboard.SelectInstance selectInstance = (Breadboard.SelectInstance) message;
          rebuildScriptBoard(breadboardMessage.user.selectedExperiment);
          loadSteps(breadboardMessage.user.selectedExperiment, selectInstance.out);
          breadboardMessage.user.setExperimentInstanceId(selectInstance.id);
          breadboardMessage.user.update();

          gameListener.stop();
          ExperimentInstance instance = ExperimentInstance.findById(selectInstance.id);
          if (instance.status.isRunnable()) {
            List<Data> parameters = instance.data;
            for (Data param : parameters) {
              initParam(param, breadboardMessage.user.selectedExperiment);
            } // END for (Data param : parameters)

            eventTracker.enable();
            eventTracker.setExperimentInstance(instance);
            gameListener.experimentInstance = instance;
            gameListener.start();

            instanceData.addPropertyChangeListener(new UserDataChangeListener(instance));

            //don't know why... ebean bug? if don't do this, the instances in the selectedExperiment doesn't get updated
            //which is causing the launch button still shows up (because the status isn't updated) instead of the stop button for the instance
            breadboardMessage.user.selectedExperiment = Experiment.findById(breadboardMessage.user.selectedExperiment.id);
          }
          Breadboard.breadboardController.tell(new Breadboard.Update(breadboardMessage.user, breadboardMessage.out), null);
        } // END else if(message instanceof Breadboard.SelectInstance)
        else if (message instanceof Breadboard.StopGame) {
          Breadboard.StopGame stopGame = (Breadboard.StopGame) message;

          ExperimentInstance instance = ExperimentInstance.findById(stopGame.id);
          if (gameListener.experimentInstance != null && gameListener.experimentInstance.equals(instance)) {
            for (Parameter p : breadboardMessage.user.getExperiment().getParameters()) {
              //Logger.debug(""Key: "" + p.name);
              if (engine.getBindings(ScriptContext.ENGINE_SCOPE).containsKey(p.name))
                engine.getBindings(ScriptContext.ENGINE_SCOPE).remove(p.name);
            }

            if (gameListener.experimentInstance == null) {
              Logger.debug(""gameListener.experimentInstance == null"");
              gameListener.experimentInstance = ExperimentInstance.findById(breadboardMessage.user.experimentInstanceId);
            }

            if (gameListener.experimentInstance.status.isRunnable()) {
              Logger.debug(""gameListener.experimentInstance.status.isRunnable()"");
              gameListener.stop();
            }

          } else {
            if (instance.status.isRunnable()) {
              instance.stop();
            }
          }
          breadboardMessage.user.setExperimentInstanceId(-1L);
          breadboardMessage.user.update();
          // Update User JSON
          Breadboard.breadboardController.tell(new Breadboard.Update(breadboardMessage.user, breadboardMessage.out), null);
        } // END else if(message instanceof Breadboard.StopGame)
        else if (message instanceof Breadboard.RunOnJoinStep) {
          Breadboard.RunOnJoinStep runOnJoinStep = (Breadboard.RunOnJoinStep) message;
          runOnJoinStep.user.refresh();
          //the script engine was throwing exception for ArbesmanRand because of missing onJoinStep
          if (runOnJoinStep.user.selectedExperiment != null && runOnJoinStep.user.selectedExperiment.hasOnJoinStep()) {
            Vertex player = runOnJoinStep.vertex;
            String script = ""onJoinStep.start(\"""" + player.getId().toString() + ""\"")"";
            processScript(script, runOnJoinStep.out, null);
          }

        } // END else if(message instanceof Breadboard.RunOnJoinStep)
        else if (message instanceof Breadboard.RunOnLeaveStep) {
          Breadboard.RunOnLeaveStep runOnLeaveStep = (Breadboard.RunOnLeaveStep) message;
          runOnLeaveStep.user.refresh();
          //the script engine was throwing exception for ArbesmanRand because of missing runOnLeaveStep
          if (runOnLeaveStep.user.selectedExperiment != null && runOnLeaveStep.user.selectedExperiment.hasOnLeaveStep()) {
            Vertex player = runOnLeaveStep.vertex;
            if (engine.get(""onLeaveStep.start()"") != null) {
              processScript(""onLeaveStep.start(\"""" + player.getId().toString() + ""\"")"", runOnLeaveStep.out, null);
            }
          }

        } // END else if(message instanceof Breadboard.RunOnLeaveStep)
        else if (message instanceof Breadboard.Refresh) {
          Logger.debug(""Breadboard.Refresh"");

          //need to refresh the listeners
          for (Admin admin : admins) {
            admin.setOut(breadboardMessage.out);
          }

          //ObjectNode jsonOutput = Json.newObject();
          Graph wholeGraph = (Graph) engine.get(""g"");

          for (Admin admin : admins) {
            for (Vertex v : wholeGraph.getVertices()) {
              admin.vertexAdded(v, false);
            }
            for (Edge e : wholeGraph.getEdges()) {
              admin.edgeAdded(e);
            }
          }
          //breadboardMessage.out.write(jsonOutput);
        } else if (message instanceof Breadboard.GameFinish) {
          Breadboard.instances.get(breadboardMessage.user.email).tell(new Breadboard.ReloadEngine(breadboardMessage.user, breadboardMessage.out), null);
          Breadboard.breadboardController.tell(new Breadboard.Update(breadboardMessage.user, breadboardMessage.out), null);
        } else if (message instanceof Breadboard.ReloadEngine) {
          Experiment selectedExperiment = breadboardMessage.user.getExperiment();
          rebuildScriptBoard(selectedExperiment);
          loadSteps(selectedExperiment, breadboardMessage.out);
          Breadboard.ReloadEngine reloadEngine = (Breadboard.ReloadEngine) message;
          if (reloadEngine.user.experimentInstanceId != -1) {
            ExperimentInstance ei = ExperimentInstance.findById(reloadEngine.user.experimentInstanceId);
            if (ei != null) {
              eventTracker.enable();
              eventTracker.setExperimentInstance(ei);
              for (Data d : ei.data) {
                initParam(d, selectedExperiment);
              }
            }
          }
        }
      }
    } catch (Exception e) {
      e.printStackTrace();
    }
  }

  private ExperimentInstance startGame(String gameName, long currentExperimentInstanceId, LinkedHashMap parameters, Experiment selectedExperiment, User user) {
    ExperimentInstance instance = new ExperimentInstance(gameName, selectedExperiment);
    instance.hasStarted = false;
    instance.status = ExperimentInstance.Status.STOPPED;

    if (currentExperimentInstanceId != -1) {
      ExperimentInstance runningInstance = ExperimentInstance.findById(currentExperimentInstanceId);
      if (runningInstance != null && runningInstance.status.isRunnable()) {
        runningInstance.status = ExperimentInstance.Status.STOPPED;
        runningInstance.update();
      }
    }

    initAllParam(parameters, selectedExperiment, instance);

    selectedExperiment.instances.add(instance);
    selectedExperiment.save();

    user.setExperimentInstanceId(instance.id);
    user.update();

    return instance;
  }

  private void initAllParam(Map params, Experiment experiment, ExperimentInstance instance) {

    Iterator it = params.keySet().iterator();
    while (it.hasNext()) {
      Object key = it.next();
      // Add the initial parameters to the data of the ExperimentInstance
      Data data = new Data();
      data.name = key.toString();
      data.value = params.get(key).toString();
      if (instance != null) {
        instance.data.add(data);
      }

      initParam(data, experiment);
    } // END while(it.hasNext())
  }

  private void initParam(Data param, Experiment experiment) {
    String key = param.name;
    Logger.debug(""initParam: "" + key);
    Parameter parameter = experiment == null ? null : experiment.getParameterByName(key);
    if (parameter == null) {
      //default string value
      engine.getBindings(ScriptContext.ENGINE_SCOPE).put(key, param.value);
      return;
    }
    // TODO: Perhaps put this code elsewhere?
    // Bind the initial variables to the script engine
    if (parameter != null) {
      if (parameter.type.equals(""Integer"")) {
        try {
          Integer intParameter = Integer.parseInt(param.value);
          engine.getBindings(ScriptContext.ENGINE_SCOPE).put(key, intParameter);
        } catch (NumberFormatException npe) {
          Logger.error(""Breadboard.LaunchGame: Caught NumberFormatException parsing string as Integer: "" + param.value);
        }
      } else if (parameter.type.equals(""Decimal"")) {
        try {
          Double doubleParameter = Double.parseDouble(param.value);
          engine.getBindings(ScriptContext.ENGINE_SCOPE).put(key, doubleParameter);
        } catch (NumberFormatException npe) {
          Logger.error(""Breadboard.LaunchGame: Caught NumberFormatException parsing string as Double: "" + param.value);
        }

      } else if (parameter.type.equals(""Text"")) {
        engine.getBindings(ScriptContext.ENGINE_SCOPE).put(key, param.value);
      } else if (parameter.type.equals(""Boolean"")) {
        Boolean booleanParameter = Boolean.parseBoolean(param.value);
        engine.getBindings(ScriptContext.ENGINE_SCOPE).put(key, booleanParameter);
      }
    } //END if (parameter != null)
  }

  private static void makeChoice(String uid, String params, ThrottledWebSocketOut out) {
    ObjectNode jsonOutput = Json.newObject();
    playerActions.choose(uid, params);
    out.write(jsonOutput);
  }

  public static void processScript(String script, ThrottledWebSocketOut out, String scriptName) {
    if (scriptName == null) scriptName = ""Unnamed Script"";

    ObjectNode jsonOutput = Json.newObject();
    //TODO: better way to handle this?
    boolean initStep = false;
    synchronized (ScriptBoard.class) {
      if (script.contains(""initStep.start()"")) {
        if (engine.get(""initStep.start()"") != null) {
          Logger.debug(""engine.get(\""initStep.start()\"") = "" + engine.get(""initStep.start()"").toString());
          Logger.warn(""The initStep has started already."");
          jsonOutput.put(""error"", ""Caught error: "".concat(""initStep started already"").concat(""\n""));
          if (out != null) {
            out.write(jsonOutput);
          }
          return;
        }
        engine.put(""initStep.start()"", true);
        initStep = true;
      }
    }
    try {
      Object outputObject = engine.eval(script);
      // Clear out error
      jsonOutput.put(""error"", """");

      // Write out the results Map as JSON
      ByteArrayOutputStream outputStream = new ByteArrayOutputStream();

      mapper.writeValue(outputStream, engine.getBindings(ScriptContext.ENGINE_SCOPE).get(""results""));
      String outputString = script.trim().concat(""\n\n==>"");

      if (outputObject != null) {
        if (outputObject instanceof GremlinGroovyPipeline) {
          outputString += StringUtils.join(((GremlinGroovyPipeline) outputObject).toList(), ""\n==>"");
        } else {
          outputString += outputObject.toString();
        }
      }

      jsonOutput.put(""output"", outputString.trim());
    } catch (CompilationFailedException cfe) {
      Logger.error(""Unable to compile the script. "" + scriptName, cfe);
      jsonOutput.put(""error"", ""Caught error: "".concat(cfe.getMessage()).concat(""\n""));
      if (initStep) {
        engine.put(""initStep.start()"", null);
      }
    } catch (ScriptException se) {
      Logger.error(""Script Error. "" + scriptName, se);
      jsonOutput.put(""error"", ""Caught error: "".concat(se.getMessage()).concat(""\n""));
      if (initStep) {
        engine.put(""initStep.start()"", null);
      }
    } catch (Exception e) {
      Logger.error(""Failed to process the script. "" + scriptName, e);
      jsonOutput.put(""error"", ""Caught error: "".concat(e.getMessage()).concat(""\n""));
      if (initStep) {
        engine.put(""initStep.start()"", null);
      }
    } finally {
      if (out != null) {
        out.write(jsonOutput);
      }
    }
  }

  private class UserDataChangeListener implements PropertyChangeListener {

    private ExperimentInstance experimentInstance;

    private UserDataChangeListener(ExperimentInstance experimentInstance) {
      this.experimentInstance = experimentInstance;
    }

    @Override
    public void propertyChange(PropertyChangeEvent evt) {
      List<Data> dataList = experimentInstance.data;
      Data foundData = null;
      if (evt.getPropertyName() != null) {
        foundData = findDataByName(evt.getPropertyName());
      }
      if (evt instanceof ObservableMap.PropertyAddedEvent) {
        Data newData = foundData == null ? new Data() : foundData;
        newData.name = evt.getPropertyName();
        newData.value = evt.getNewValue().toString();
        newData.experimentInstance = experimentInstance;
        if (foundData == null) {
          dataList.add(newData);
          experimentInstance.save();
        } else {
          newData.save();
        }
        initParam(newData, null);

      } else if (evt instanceof ObservableMap.PropertyClearedEvent) {
        List<Parameter> parameters = experimentInstance.experiment.getParameters();
        List<String> parameterNames = new ArrayList<String>();
        for (Parameter parameter : parameters) {
          parameterNames.add(parameter.name);
        }
        Iterator<Data> dataIterator = dataList.iterator();
        while (dataIterator.hasNext()) {
          Data d = dataIterator.next();
          //make sure not removing the parameters
          if (!parameterNames.contains(d.name)) {
            dataIterator.remove();
            engine.getBindings(ScriptContext.ENGINE_SCOPE).remove(d.name);
          }
        }
        experimentInstance.save();

      } else if (evt instanceof ObservableMap.PropertyRemovedEvent) {
        if (foundData != null) {
          dataList.remove(foundData);
          engine.getBindings(ScriptContext.ENGINE_SCOPE).remove(foundData.name);
        }
        experimentInstance.save();
      } else if (evt instanceof ObservableMap.PropertyUpdatedEvent) {
        if (foundData != null) {
          foundData.value = evt.getNewValue().toString();
        }
        foundData.save();
        initParam(foundData, null);
      }
    }

    private Data findDataByName(String name) {
      List<Data> dataList = experimentInstance.data;
      for (Data d : dataList) {
        //this should be case-sensitive
        if (d.name.equals(name)) {
          return d;
        }
      }
      return null;
    }
  }
}
","package models; public class ScriptBoard extends UntypedActor { private static ObjectMapper mapper = new ObjectMapper(); private static ScriptEngineManager manager = new ScriptEngineManager(); private static ScriptEngine engine; private static Map results = new HashMap(); private static PlayerActionsInterface playerActions; private static BreadboardGraphInterface graphInterface; private static BreadboardGraphChangedListener graphChangedListener; private static FileWatcher fileWatcher; private static EventTracker eventTracker = new EventTracker(); private static EventBus<Map> eventBus = new EventBus(); private static Random rand = new Random(); private static HashMap<String, Client> clients = new HashMap<>(); private static ArrayList<Admin> admins = new ArrayList<>(); private static UserDataInterface instanceData; private GameListener gameListener = new GameListener(); private Long experimentId; private Long instanceId; public static boolean checkPassword(String _password) { if (engine == null || engine.get(""password"") == null)
      return true; Object password = engine.get(""password""); return _password.equals(password.toString()); } public ScriptBoard() throws IOException, ScriptException { rebuildScriptBoard(null); } private void init() { results = new HashMap(); mapper = new ObjectMapper(); admins = new ArrayList<>(); clients = new HashMap<>(); eventTracker = new EventTracker(); manager = new ScriptEngineManager(); eventBus.clear(); } private void disconnectClients () { for (Client client : clients.values()) { client.disconnect(); } clients.clear(); } private void resetEngine(Experiment experiment) throws IOException, ScriptException { for (Admin admin : admins) { ObjectNode jsonOutput = Json.newObject(); ObjectNode notify = Json.newObject(); notify.put(""ScriptEngineReloading"", new Date().getTime()); jsonOutput.put(""notify"", notify); admin.getOut().write(jsonOutput); } if (engine != null) { playerActions.turnAIOff(); processScript(""g.empty()"", null, null); processScript(""timers.cancel()"", null, null); } eventBus.clear(); eventBus.on(""__send-event"", new Closure(null) { public void doCall (String clientId, String eventName, Object ...data) { Client client = clients.get(clientId); if (client == null) { return; } client.send(eventName, data); } } ); eventBus.on(""__broadcast-event"", new Closure(null) { public void doCall (String clientId, String eventName, Object ...data) { for (Client client : clients.values()) { client.send(eventName, data); } } } ); engine = manager.getEngineByName(""gremlin-groovy""); engine.getBindings(ScriptContext.ENGINE_SCOPE).put(""r"", rand); engine.getBindings(ScriptContext.ENGINE_SCOPE).put(""results"", results); engine.getBindings(ScriptContext.ENGINE_SCOPE).put(""eventTracker"", eventTracker); engine.getBindings(ScriptContext.ENGINE_SCOPE).put(""gameListener"", gameListener); engine.getBindings(ScriptContext.ENGINE_SCOPE).put(""events"", eventBus); if (experiment != null) { engine.getBindings(ScriptContext.ENGINE_SCOPE).put(""c"", experiment.contentFetcher); } String[] scriptFiles = { ""/util.groovy"", 
      ""/timer.groovy"",
      ""/graph.groovy"", 
      ""/actions.groovy"", 
      ""/step.groovy"", 
      ""/test.groovy"",
      ""/events.groovy"",
      ""/chat.groovy"",
      ""/form.groovy"",
      ""/ready.groovy""
    } ; for (String file : scriptFiles) { File utilFile = new File(Play.application().path().toString() + ""/groovy"" + file); String utilString = FileUtils.readFileToString(utilFile, ""UTF-8"") + ""; null; ""; engine.eval(utilString); } Object a = engine.get(""a""); Invocable inv = (Invocable) engine; playerActions = inv.getInterface(a, PlayerActionsInterface.class); Object d = engine.get(""d""); instanceData = inv.getInterface(d, UserDataInterface.class); Object g = engine.get(""g""); graphInterface = inv.getInterface(g, BreadboardGraphInterface.class); if (graphChangedListener == null) { Long clientUpdateRate = play.Play.application().configuration().getMilliseconds(""breadboard.clientUpdateRate""); if (clientUpdateRate == null || clientUpdateRate == 0) { graphChangedListener = new EventGraphChangedListener((Graph) g); } else { graphChangedListener = new IteratedBreadboardGraphChangedListener((Graph) g); } } else { graphChangedListener.setGraph((Graph) g); } graphInterface.addListener(graphChangedListener); if (fileWatcher == null) { fileWatcher = new FileWatcher(admins); } gameListener.engine = engine; for (Admin admin : admins) { ObjectNode jsonOutput = Json.newObject(); ObjectNode notify = Json.newObject(); notify.put(""ScriptEngineReloaded"", new Date().getTime()); jsonOutput.put(""notify"", notify); admin.getOut().write(jsonOutput); } this.disconnectClients(); } private void loadSteps(Experiment experiment, ThrottledWebSocketOut out) { for (Step step : experiment.getSteps()) { processScript(step.source + ""; null; "", out, step.name); } } private String makeUniqueClientId (String clientId) { return this.experimentId + ""-"" + this.instanceId + ""-"" + clientId; } private void rebuildScriptBoard(Experiment experiment) throws IOException, ScriptException { resetEngine(experiment); } public static void addAdmin(Admin admin) { admins.add(admin); graphChangedListener.addAdminListener(admin); } public static void addClient(String experimentIdString, String experimentInstanceIdString, String clientId, final WebSocket.In<JsonNode> in, final ThrottledWebSocketOut out) throws Exception { try { Long experimentId = Long.parseLong(experimentIdString); Long experimentInstanceId = Long.parseLong(experimentInstanceIdString); Experiment experiment = Experiment.findById(experimentId); if (experiment == null) { return; } ExperimentInstance experimentInstance = null; if (experimentInstanceId.equals(Experiment.TEST_INSTANCE_ID)) { experimentInstance = experiment.getTestInstance(); } else { experimentInstance = ExperimentInstance.findById(experimentInstanceId); } if (experimentInstance == null) { return; } Client client = clients.get(clientId); if (client == null && experimentInstance.hasStarted) { return; } if (client == null) { client = new Client(clientId, experimentInstance, in, out); clients.put(clientId, client); } else { client.setIn(in); client.setOut(out); } in.onMessage(new Callback<JsonNode>() { public void invoke(JsonNode event) { try { ObjectMapper mapper = new ObjectMapper(); Map<String, Object> jsonInput = mapper.readValue(event.toString(), Map.class); String action = jsonInput.get(""action"").toString(); if (action.equals(""LogIn"")) { String clientId = jsonInput.get(""clientId"").toString(); String referer = jsonInput.get(""referer"").toString(); String connection = jsonInput.get(""connection"").toString(); String accept = jsonInput.get(""accept"").toString(); String acceptLanguage = jsonInput.get(""acceptLanguage"").toString(); String acceptEncoding = jsonInput.get(""acceptEncoding"").toString(); String userAgent = jsonInput.get(""userAgent"").toString(); String host = jsonInput.get(""host"").toString(); String ipAddress = jsonInput.get(""ipAddress"").toString(); String requestURI = jsonInput.get(""requestURI"").toString(); if (eventTracker != null) { LinkedHashMap<Object, Object> data = new LinkedHashMap<Object, Object>(); data.put(""clientId"", clientId); data.put(""referer"", referer); data.put(""connection"", connection); data.put(""acceptLanguage"", acceptLanguage); data.put(""acceptEncoding"", acceptEncoding); data.put(""userAgent"", userAgent); data.put(""host"", host); data.put(""ipAddress"", ipAddress); data.put(""requestURI"", requestURI); eventTracker.track(""clientLogIn"", data); } } else if (action.equals(""MakeChoice"")) { String choiceUID = jsonInput.get(""choiceUID"").toString(); String params = (jsonInput.containsKey(""params"")) ? jsonInput.get(""params"").toString() : null; makeChoice(choiceUID, params, out); } else if (action.equals(""CustomEvent"")) { eventBus.emit(""CustomEvent"", jsonInput, new HashMap<String, String>() { { put(""clientId"", clientId); } } ); } } catch (java.io.IOException ignored) { } catch (Exception e) { } } } ); if (graphChangedListener != null) { graphChangedListener.addClientListener(client); } if (graphInterface != null) { if (!experimentInstance.hasStarted) { graphInterface.addPlayer(clientId); } Graph wholeGraph = (Graph) engine.get(""g""); Vertex clientVertex = wholeGraph.getVertex(clientId); if (clientVertex != null) { if (graphChangedListener instanceof EventGraphChangedListener) { client.updateGraph(clientVertex); } } } ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""style"", experimentInstance.experiment.getStyle()); out.write(jsonOutput); } catch (NumberFormatException nfe) { } } public void onReceive(Object message) throws Exception { try { if (message instanceof Breadboard.BreadboardMessage) { Breadboard.BreadboardMessage breadboardMessage = (Breadboard.BreadboardMessage) message; if (breadboardMessage.user != null) { gameListener.user = breadboardMessage.user; gameListener.out = breadboardMessage.out; } if (message instanceof Breadboard.AddAdmin) { Breadboard.AddAdmin addAdmin = (Breadboard.AddAdmin) message; addAdmin(new Admin(addAdmin.user, addAdmin.scriptBoardController, addAdmin.out)); } else if (message instanceof Breadboard.RunGame) { if (breadboardMessage.user != null) { processScript(""initStep.start()"", breadboardMessage.out, null); } } else if (message instanceof Breadboard.HitCreated) { Breadboard.HitCreated hitCreated = (Breadboard.HitCreated) message; if (breadboardMessage.user != null) { Integer lifetimeInMs = hitCreated.lifetimeInSeconds * 1000; Integer tutorialTimeInMs = hitCreated.tutorialTime * 1000; Long timerTime = System.currentTimeMillis() + (lifetimeInMs + tutorialTimeInMs); processScript(""startAt = "" + timerTime, breadboardMessage.out, null); final ThrottledWebSocketOut breadboardOut = breadboardMessage.out; new Timer().schedule(new TimerTask() { @Override
              public void run() { gameListener.hasStarted(); } } , lifetimeInMs); new Timer().schedule(new TimerTask() { @Override
              public void run() { processScript(""initStep.start()"", breadboardOut, null); } } , (lifetimeInMs + tutorialTimeInMs)); } } else if (message instanceof Breadboard.SendScript) { Breadboard.SendScript sendScript = (Breadboard.SendScript) message; if (breadboardMessage.user != null) { breadboardMessage.user.currentScript = sendScript.script; breadboardMessage.user.update(); processScript(sendScript.script, breadboardMessage.out, null); } } else if (message instanceof Breadboard.MakeChoice) { Breadboard.MakeChoice makeChoice = (Breadboard.MakeChoice) message; makeChoice(makeChoice.uid, makeChoice.params, breadboardMessage.out); } else if (message instanceof Breadboard.SendStep) { Breadboard.SendStep sendStep = (Breadboard.SendStep) message; if (breadboardMessage.user != null && breadboardMessage.user.selectedExperiment != null) { Breadboard.instances.get(breadboardMessage.user.email).tell(new Breadboard.RunStep(breadboardMessage.user, sendStep.source, breadboardMessage.out), null); } } else if (message instanceof Breadboard.RunStep) { Breadboard.RunStep runStep = (Breadboard.RunStep) message; processScript(runStep.source, breadboardMessage.out, null); } else if (message instanceof Breadboard.ChangeExperiment) { if (breadboardMessage.user != null) { rebuildScriptBoard(breadboardMessage.user.selectedExperiment); loadSteps(breadboardMessage.user.selectedExperiment, breadboardMessage.out); Breadboard.ChangeExperiment changeExperiment = (Breadboard.ChangeExperiment) message; if (breadboardMessage.user.experimentInstanceId != -1) { ExperimentInstance runningInstance = ExperimentInstance.findById(breadboardMessage.user.experimentInstanceId); if (runningInstance != null) { if (runningInstance.status == ExperimentInstance.Status.RUNNING && runningInstance.experiment.id.equals(changeExperiment.experiment.id)) { eventTracker.setExperimentInstance(runningInstance); gameListener.experimentInstance = runningInstance; for (Data param : runningInstance.data) { initParam(param, changeExperiment.experiment); } } } else { } } } } else if (message instanceof Breadboard.DeleteExperiment) { Breadboard.DeleteExperiment deleteExperiment = (Breadboard.DeleteExperiment) message; Experiment toBeDeleteExperiment = deleteExperiment.user.getExperimentByName(deleteExperiment.experimentName); for (Parameter p : breadboardMessage.user.getExperiment().getParameters()) { if (engine.getBindings(ScriptContext.ENGINE_SCOPE).containsKey(p.name))
              engine.getBindings(ScriptContext.ENGINE_SCOPE).remove(p.name); } breadboardMessage.user.currentScript = """"; processScript(""g.empty()"", breadboardMessage.out, null); if (toBeDeleteExperiment != null) { List<User> users = User.find.all(); boolean update; boolean updateManyToMany; for (User user : users) { if (user.email.equalsIgnoreCase(breadboardMessage.user.email)) { user = breadboardMessage.user; user.setExperimentInstanceId(-1L); } update = false; updateManyToMany = false; if (user.selectedExperiment != null && user.selectedExperiment.id == toBeDeleteExperiment.id) { update = true; user.setSelectedExperiment(null); } if (user.ownedExperiments.contains(toBeDeleteExperiment)) { updateManyToMany = true; user.ownedExperiments.remove(toBeDeleteExperiment); } if (update) { user.update(); } if (updateManyToMany) { user.saveManyToManyAssociations(""ownedExperiments""); } } toBeDeleteExperiment.delete(); } Breadboard.breadboardController.tell(new Breadboard.Update(breadboardMessage.user, breadboardMessage.out), null); } else if (message instanceof Breadboard.LaunchGame) { Breadboard.LaunchGame launchGame = (Breadboard.LaunchGame) message; if (breadboardMessage.user.selectedExperiment != null) { rebuildScriptBoard(breadboardMessage.user.selectedExperiment); ExperimentInstance instance = startGame(launchGame.name, breadboardMessage.user.experimentInstanceId, launchGame.parameters,
                breadboardMessage.user.selectedExperiment, breadboardMessage.user); instanceData.addPropertyChangeListener(new UserDataChangeListener(instance)); eventTracker.enable(); eventTracker.setExperimentInstance(instance); gameListener.experimentInstance = instance; gameListener.start(); for (Step step : instance.experiment.getSteps())
              Breadboard.instances.get(breadboardMessage.user.email).tell(new Breadboard.RunStep(breadboardMessage.user, step.source, breadboardMessage.out), null); } Breadboard.breadboardController.tell(new Breadboard.Update(breadboardMessage.user, breadboardMessage.out), null); } else if (message instanceof Breadboard.SelectInstance) { Breadboard.SelectInstance selectInstance = (Breadboard.SelectInstance) message; rebuildScriptBoard(breadboardMessage.user.selectedExperiment); loadSteps(breadboardMessage.user.selectedExperiment, selectInstance.out); breadboardMessage.user.setExperimentInstanceId(selectInstance.id); breadboardMessage.user.update(); gameListener.stop(); ExperimentInstance instance = ExperimentInstance.findById(selectInstance.id); if (instance.status.isRunnable()) { List<Data> parameters = instance.data; for (Data param : parameters) { initParam(param, breadboardMessage.user.selectedExperiment); } eventTracker.enable(); eventTracker.setExperimentInstance(instance); gameListener.experimentInstance = instance; gameListener.start(); instanceData.addPropertyChangeListener(new UserDataChangeListener(instance)); breadboardMessage.user.selectedExperiment = Experiment.findById(breadboardMessage.user.selectedExperiment.id); } Breadboard.breadboardController.tell(new Breadboard.Update(breadboardMessage.user, breadboardMessage.out), null); } else if (message instanceof Breadboard.StopGame) { Breadboard.StopGame stopGame = (Breadboard.StopGame) message; ExperimentInstance instance = ExperimentInstance.findById(stopGame.id); if (gameListener.experimentInstance != null && gameListener.experimentInstance.equals(instance)) { for (Parameter p : breadboardMessage.user.getExperiment().getParameters()) { if (engine.getBindings(ScriptContext.ENGINE_SCOPE).containsKey(p.name))
                engine.getBindings(ScriptContext.ENGINE_SCOPE).remove(p.name); } if (gameListener.experimentInstance == null) { gameListener.experimentInstance = ExperimentInstance.findById(breadboardMessage.user.experimentInstanceId); } if (gameListener.experimentInstance.status.isRunnable()) { gameListener.stop(); } } else { if (instance.status.isRunnable()) { instance.stop(); } } breadboardMessage.user.setExperimentInstanceId(-1L); breadboardMessage.user.update(); Breadboard.breadboardController.tell(new Breadboard.Update(breadboardMessage.user, breadboardMessage.out), null); } else if (message instanceof Breadboard.RunOnJoinStep) { Breadboard.RunOnJoinStep runOnJoinStep = (Breadboard.RunOnJoinStep) message; runOnJoinStep.user.refresh(); if (runOnJoinStep.user.selectedExperiment != null && runOnJoinStep.user.selectedExperiment.hasOnJoinStep()) { Vertex player = runOnJoinStep.vertex; String script = ""onJoinStep.start(\"""" + player.getId().toString() + ""\"")""; processScript(script, runOnJoinStep.out, null); } } else if (message instanceof Breadboard.RunOnLeaveStep) { Breadboard.RunOnLeaveStep runOnLeaveStep = (Breadboard.RunOnLeaveStep) message; runOnLeaveStep.user.refresh(); if (runOnLeaveStep.user.selectedExperiment != null && runOnLeaveStep.user.selectedExperiment.hasOnLeaveStep()) { Vertex player = runOnLeaveStep.vertex; if (engine.get(""onLeaveStep.start()"") != null) { processScript(""onLeaveStep.start(\"""" + player.getId().toString() + ""\"")"", runOnLeaveStep.out, null); } } } else if (message instanceof Breadboard.Refresh) { for (Admin admin : admins) { admin.setOut(breadboardMessage.out); } Graph wholeGraph = (Graph) engine.get(""g""); for (Admin admin : admins) { for (Vertex v : wholeGraph.getVertices()) { admin.vertexAdded(v, false); } for (Edge e : wholeGraph.getEdges()) { admin.edgeAdded(e); } } } else if (message instanceof Breadboard.GameFinish) { Breadboard.instances.get(breadboardMessage.user.email).tell(new Breadboard.ReloadEngine(breadboardMessage.user, breadboardMessage.out), null); Breadboard.breadboardController.tell(new Breadboard.Update(breadboardMessage.user, breadboardMessage.out), null); } else if (message instanceof Breadboard.ReloadEngine) { Experiment selectedExperiment = breadboardMessage.user.getExperiment(); rebuildScriptBoard(selectedExperiment); loadSteps(selectedExperiment, breadboardMessage.out); Breadboard.ReloadEngine reloadEngine = (Breadboard.ReloadEngine) message; if (reloadEngine.user.experimentInstanceId != -1) { ExperimentInstance ei = ExperimentInstance.findById(reloadEngine.user.experimentInstanceId); if (ei != null) { eventTracker.enable(); eventTracker.setExperimentInstance(ei); for (Data d : ei.data) { initParam(d, selectedExperiment); } } } } } } catch (Exception e) { e.printStackTrace(); } } private ExperimentInstance startGame(String gameName, long currentExperimentInstanceId, LinkedHashMap parameters, Experiment selectedExperiment, User user) { ExperimentInstance instance = new ExperimentInstance(gameName, selectedExperiment); instance.hasStarted = false; instance.status = ExperimentInstance.Status.STOPPED; if (currentExperimentInstanceId != -1) { ExperimentInstance runningInstance = ExperimentInstance.findById(currentExperimentInstanceId); if (runningInstance != null && runningInstance.status.isRunnable()) { runningInstance.status = ExperimentInstance.Status.STOPPED; runningInstance.update(); } } initAllParam(parameters, selectedExperiment, instance); selectedExperiment.instances.add(instance); selectedExperiment.save(); user.setExperimentInstanceId(instance.id); user.update(); return instance; } private void initAllParam(Map params, Experiment experiment, ExperimentInstance instance) { Iterator it = params.keySet().iterator(); while (it.hasNext()) { Object key = it.next(); Data data = new Data(); data.name = key.toString(); data.value = params.get(key).toString(); if (instance != null) { instance.data.add(data); } initParam(data, experiment); } } private void initParam(Data param, Experiment experiment) { String key = param.name; Parameter parameter = experiment == null ? null : experiment.getParameterByName(key); if (parameter == null) { engine.getBindings(ScriptContext.ENGINE_SCOPE).put(key, param.value); return; } if (parameter != null) { if (parameter.type.equals(""Integer"")) { try { Integer intParameter = Integer.parseInt(param.value); engine.getBindings(ScriptContext.ENGINE_SCOPE).put(key, intParameter); } catch (NumberFormatException npe) { } } else if (parameter.type.equals(""Decimal"")) { try { Double doubleParameter = Double.parseDouble(param.value); engine.getBindings(ScriptContext.ENGINE_SCOPE).put(key, doubleParameter); } catch (NumberFormatException npe) { } } else if (parameter.type.equals(""Text"")) { engine.getBindings(ScriptContext.ENGINE_SCOPE).put(key, param.value); } else if (parameter.type.equals(""Boolean"")) { Boolean booleanParameter = Boolean.parseBoolean(param.value); engine.getBindings(ScriptContext.ENGINE_SCOPE).put(key, booleanParameter); } } } private static void makeChoice(String uid, String params, ThrottledWebSocketOut out) { ObjectNode jsonOutput = Json.newObject(); playerActions.choose(uid, params); out.write(jsonOutput); } public static void processScript(String script, ThrottledWebSocketOut out, String scriptName) { if (scriptName == null) scriptName = ""Unnamed Script""; ObjectNode jsonOutput = Json.newObject(); boolean initStep = false; synchronized (ScriptBoard.class) { if (script.contains(""initStep.start()"")) { if (engine.get(""initStep.start()"") != null) { jsonOutput.put(""error"", ""Caught error: "".concat(""initStep started already"").concat(""\n"")); if (out != null) { out.write(jsonOutput); } return; } engine.put(""initStep.start()"", true); initStep = true; } } try { Object outputObject = engine.eval(script); jsonOutput.put(""error"", """"); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); mapper.writeValue(outputStream, engine.getBindings(ScriptContext.ENGINE_SCOPE).get(""results"")); String outputString = script.trim().concat(""\n\n==>""); if (outputObject != null) { if (outputObject instanceof GremlinGroovyPipeline) { outputString += StringUtils.join(((GremlinGroovyPipeline) outputObject).toList(), ""\n==>""); } else { outputString += outputObject.toString(); } } jsonOutput.put(""output"", outputString.trim()); } catch (CompilationFailedException cfe) { jsonOutput.put(""error"", ""Caught error: "".concat(cfe.getMessage()).concat(""\n"")); if (initStep) { engine.put(""initStep.start()"", null); } } catch (ScriptException se) { jsonOutput.put(""error"", ""Caught error: "".concat(se.getMessage()).concat(""\n"")); if (initStep) { engine.put(""initStep.start()"", null); } } catch (Exception e) { jsonOutput.put(""error"", ""Caught error: "".concat(e.getMessage()).concat(""\n"")); if (initStep) { engine.put(""initStep.start()"", null); } } finally { if (out != null) { out.write(jsonOutput); } } } private class UserDataChangeListener implements PropertyChangeListener { private ExperimentInstance experimentInstance; private UserDataChangeListener(ExperimentInstance experimentInstance) { this.experimentInstance = experimentInstance; } @Override
    public void propertyChange(PropertyChangeEvent evt) { List<Data> dataList = experimentInstance.data; Data foundData = null; if (evt.getPropertyName() != null) { foundData = findDataByName(evt.getPropertyName()); } if (evt instanceof ObservableMap.PropertyAddedEvent) { Data newData = foundData == null ? new Data() : foundData; newData.name = evt.getPropertyName(); newData.value = evt.getNewValue().toString(); newData.experimentInstance = experimentInstance; if (foundData == null) { dataList.add(newData); experimentInstance.save(); } else { newData.save(); } initParam(newData, null); } else if (evt instanceof ObservableMap.PropertyClearedEvent) { List<Parameter> parameters = experimentInstance.experiment.getParameters(); List<String> parameterNames = new ArrayList<String>(); for (Parameter parameter : parameters) { parameterNames.add(parameter.name); } Iterator<Data> dataIterator = dataList.iterator(); while (dataIterator.hasNext()) { Data d = dataIterator.next(); if (!parameterNames.contains(d.name)) { dataIterator.remove(); engine.getBindings(ScriptContext.ENGINE_SCOPE).remove(d.name); } } experimentInstance.save(); } else if (evt instanceof ObservableMap.PropertyRemovedEvent) { if (foundData != null) { dataList.remove(foundData); engine.getBindings(ScriptContext.ENGINE_SCOPE).remove(foundData.name); } experimentInstance.save(); } else if (evt instanceof ObservableMap.PropertyUpdatedEvent) { if (foundData != null) { foundData.value = evt.getNewValue().toString(); } foundData.save(); initParam(foundData, null); } } private Data findDataByName(String name) { List<Data> dataList = experimentInstance.data; for (Data d : dataList) { if (d.name.equals(name)) { return d; } } return null; } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 0 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; public class ScriptBoard extends UntypedActor { private static ObjectMapper mapper = new ObjectMapper(); private static ScriptEngineManager manager = new ScriptEngineManager(); private static ScriptEngine engine; private static Map results = new HashMap(); private static PlayerActionsInterface playerActions; private static BreadboardGraphInterface graphInterface; private static BreadboardGraphChangedListener graphChangedListener; private static FileWatcher fileWatcher; private static EventTracker eventTracker = new EventTracker(); private static EventBus<Map> eventBus = new EventBus(); private static Random rand = new Random(); private static HashMap<String, Client> clients = new HashMap<>(); private static ArrayList<Admin> admins = new ArrayList<>(); private static UserDataInterface instanceData; private GameListener gameListener = new GameListener(); private Long experimentId; private Long instanceId; public static boolean checkPassword(String _password) { if (engine == null || engine.get(""password"") == null)
      return true; Object password = engine.get(""password""); return _password.equals(password.toString()); } <FILL_ME> public ScriptBoard() throws IOException, ScriptException { rebuildScriptBoard(null); } private void init() { results = new HashMap(); mapper = new ObjectMapper(); admins = new ArrayList<>(); clients = new HashMap<>(); eventTracker = new EventTracker(); manager = new ScriptEngineManager(); eventBus.clear(); } private void disconnectClients () { for (Client client : clients.values()) { client.disconnect(); } clients.clear(); } private void resetEngine(Experiment experiment) throws IOException, ScriptException { for (Admin admin : admins) { ObjectNode jsonOutput = Json.newObject(); ObjectNode notify = Json.newObject(); notify.put(""ScriptEngineReloading"", new Date().getTime()); jsonOutput.put(""notify"", notify); admin.getOut().write(jsonOutput); } if (engine != null) { playerActions.turnAIOff(); processScript(""g.empty()"", null, null); processScript(""timers.cancel()"", null, null); } eventBus.clear(); eventBus.on(""__send-event"", new Closure(null) { public void doCall (String clientId, String eventName, Object ...data) { <FILL_ME> <FILL_ME> Client client = clients.get(clientId); if (client == null) { <FILL_ME> return; } client.send(eventName, data); } } ); eventBus.on(""__broadcast-event"", new Closure(null) { public void doCall (String clientId, String eventName, Object ...data) { for (Client client : clients.values()) { client.send(eventName, data); } } } ); engine = manager.getEngineByName(""gremlin-groovy""); engine.getBindings(ScriptContext.ENGINE_SCOPE).put(""r"", rand); engine.getBindings(ScriptContext.ENGINE_SCOPE).put(""results"", results); engine.getBindings(ScriptContext.ENGINE_SCOPE).put(""eventTracker"", eventTracker); engine.getBindings(ScriptContext.ENGINE_SCOPE).put(""gameListener"", gameListener); engine.getBindings(ScriptContext.ENGINE_SCOPE).put(""events"", eventBus); if (experiment != null) { engine.getBindings(ScriptContext.ENGINE_SCOPE).put(""c"", experiment.contentFetcher); } String[] scriptFiles = { ""/util.groovy"", 
      ""/timer.groovy"",
      ""/graph.groovy"", 
      ""/actions.groovy"", 
      ""/step.groovy"", 
      ""/test.groovy"",
      ""/events.groovy"",
      ""/chat.groovy"",
      ""/form.groovy"",
      ""/ready.groovy""
    } ; for (String file : scriptFiles) { File utilFile = new File(Play.application().path().toString() + ""/groovy"" + file); String utilString = FileUtils.readFileToString(utilFile, ""UTF-8"") + ""; null; ""; <FILL_ME> engine.eval(utilString); <FILL_ME> } Object a = engine.get(""a""); Invocable inv = (Invocable) engine; playerActions = inv.getInterface(a, PlayerActionsInterface.class); Object d = engine.get(""d""); instanceData = inv.getInterface(d, UserDataInterface.class); Object g = engine.get(""g""); graphInterface = inv.getInterface(g, BreadboardGraphInterface.class); if (graphChangedListener == null) { <FILL_ME> Long clientUpdateRate = play.Play.application().configuration().getMilliseconds(""breadboard.clientUpdateRate""); if (clientUpdateRate == null || clientUpdateRate == 0) { <FILL_ME> graphChangedListener = new EventGraphChangedListener((Graph) g); } else { <FILL_ME> <FILL_ME> <FILL_ME> graphChangedListener = new IteratedBreadboardGraphChangedListener((Graph) g); } } else { graphChangedListener.setGraph((Graph) g); } graphInterface.addListener(graphChangedListener); if (fileWatcher == null) { fileWatcher = new FileWatcher(admins); } gameListener.engine = engine; for (Admin admin : admins) { ObjectNode jsonOutput = Json.newObject(); ObjectNode notify = Json.newObject(); notify.put(""ScriptEngineReloaded"", new Date().getTime()); jsonOutput.put(""notify"", notify); admin.getOut().write(jsonOutput); } this.disconnectClients(); <FILL_ME> } private void loadSteps(Experiment experiment, ThrottledWebSocketOut out) { for (Step step : experiment.getSteps()) { processScript(step.source + ""; null; "", out, step.name); } } private String makeUniqueClientId (String clientId) { return this.experimentId + ""-"" + this.instanceId + ""-"" + clientId; } private void rebuildScriptBoard(Experiment experiment) throws IOException, ScriptException { resetEngine(experiment); } public static void addAdmin(Admin admin) { admins.add(admin); graphChangedListener.addAdminListener(admin); } public static void addClient(String experimentIdString, String experimentInstanceIdString, String clientId, final WebSocket.In<JsonNode> in, final ThrottledWebSocketOut out) throws Exception { try { Long experimentId = Long.parseLong(experimentIdString); Long experimentInstanceId = Long.parseLong(experimentInstanceIdString); Experiment experiment = Experiment.findById(experimentId); if (experiment == null) { <FILL_ME> return; } ExperimentInstance experimentInstance = null; if (experimentInstanceId.equals(Experiment.TEST_INSTANCE_ID)) { experimentInstance = experiment.getTestInstance(); } else { experimentInstance = ExperimentInstance.findById(experimentInstanceId); } if (experimentInstance == null) { <FILL_ME> return; } Client client = clients.get(clientId); if (client == null && experimentInstance.hasStarted) { <FILL_ME> return; } if (client == null) { client = new Client(clientId, experimentInstance, in, out); clients.put(clientId, client); } else { client.setIn(in); client.setOut(out); } in.onMessage(new Callback<JsonNode>() { public void invoke(JsonNode event) { try { ObjectMapper mapper = new ObjectMapper(); Map<String, Object> jsonInput = mapper.readValue(event.toString(), Map.class); String action = jsonInput.get(""action"").toString(); if (action.equals(""LogIn"")) { String clientId = jsonInput.get(""clientId"").toString(); String referer = jsonInput.get(""referer"").toString(); String connection = jsonInput.get(""connection"").toString(); String accept = jsonInput.get(""accept"").toString(); String acceptLanguage = jsonInput.get(""acceptLanguage"").toString(); String acceptEncoding = jsonInput.get(""acceptEncoding"").toString(); String userAgent = jsonInput.get(""userAgent"").toString(); String host = jsonInput.get(""host"").toString(); String ipAddress = jsonInput.get(""ipAddress"").toString(); String requestURI = jsonInput.get(""requestURI"").toString(); if (eventTracker != null) { LinkedHashMap<Object, Object> data = new LinkedHashMap<Object, Object>(); data.put(""clientId"", clientId); data.put(""referer"", referer); data.put(""connection"", connection); data.put(""acceptLanguage"", acceptLanguage); data.put(""acceptEncoding"", acceptEncoding); data.put(""userAgent"", userAgent); data.put(""host"", host); data.put(""ipAddress"", ipAddress); data.put(""requestURI"", requestURI); eventTracker.track(""clientLogIn"", data); } } else if (action.equals(""MakeChoice"")) { String choiceUID = jsonInput.get(""choiceUID"").toString(); String params = (jsonInput.containsKey(""params"")) ? jsonInput.get(""params"").toString() : null; makeChoice(choiceUID, params, out); } else if (action.equals(""CustomEvent"")) { eventBus.emit(""CustomEvent"", jsonInput, new HashMap<String, String>() { { put(""clientId"", clientId); } } ); } } catch (java.io.IOException ignored) { <FILL_ME> } catch (Exception e) { <FILL_ME> <FILL_ME> } } } ); if (graphChangedListener != null) { graphChangedListener.addClientListener(client); } if (graphInterface != null) { if (!experimentInstance.hasStarted) { graphInterface.addPlayer(clientId); } Graph wholeGraph = (Graph) engine.get(""g""); Vertex clientVertex = wholeGraph.getVertex(clientId); if (clientVertex != null) { if (graphChangedListener instanceof EventGraphChangedListener) { client.updateGraph(clientVertex); } } } ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""style"", experimentInstance.experiment.getStyle()); <FILL_ME> out.write(jsonOutput); } catch (NumberFormatException nfe) { <FILL_ME> } } public void onReceive(Object message) throws Exception { try { if (message instanceof Breadboard.BreadboardMessage) { Breadboard.BreadboardMessage breadboardMessage = (Breadboard.BreadboardMessage) message; if (breadboardMessage.user != null) { gameListener.user = breadboardMessage.user; gameListener.out = breadboardMessage.out; } if (message instanceof Breadboard.AddAdmin) { Breadboard.AddAdmin addAdmin = (Breadboard.AddAdmin) message; addAdmin(new Admin(addAdmin.user, addAdmin.scriptBoardController, addAdmin.out)); } else if (message instanceof Breadboard.RunGame) { if (breadboardMessage.user != null) { processScript(""initStep.start()"", breadboardMessage.out, null); } } else if (message instanceof Breadboard.HitCreated) { Breadboard.HitCreated hitCreated = (Breadboard.HitCreated) message; if (breadboardMessage.user != null) { Integer lifetimeInMs = hitCreated.lifetimeInSeconds * 1000; Integer tutorialTimeInMs = hitCreated.tutorialTime * 1000; Long timerTime = System.currentTimeMillis() + (lifetimeInMs + tutorialTimeInMs); processScript(""startAt = "" + timerTime, breadboardMessage.out, null); final ThrottledWebSocketOut breadboardOut = breadboardMessage.out; new Timer().schedule(new TimerTask() { @Override
              public void run() { gameListener.hasStarted(); } } , lifetimeInMs); new Timer().schedule(new TimerTask() { @Override
              public void run() { processScript(""initStep.start()"", breadboardOut, null); <FILL_ME> } } , (lifetimeInMs + tutorialTimeInMs)); } } else if (message instanceof Breadboard.SendScript) { Breadboard.SendScript sendScript = (Breadboard.SendScript) message; if (breadboardMessage.user != null) { breadboardMessage.user.currentScript = sendScript.script; breadboardMessage.user.update(); processScript(sendScript.script, breadboardMessage.out, null); } } else if (message instanceof Breadboard.MakeChoice) { Breadboard.MakeChoice makeChoice = (Breadboard.MakeChoice) message; makeChoice(makeChoice.uid, makeChoice.params, breadboardMessage.out); } else if (message instanceof Breadboard.SendStep) { Breadboard.SendStep sendStep = (Breadboard.SendStep) message; if (breadboardMessage.user != null && breadboardMessage.user.selectedExperiment != null) { <FILL_ME> Breadboard.instances.get(breadboardMessage.user.email).tell(new Breadboard.RunStep(breadboardMessage.user, sendStep.source, breadboardMessage.out), null); } } else if (message instanceof Breadboard.RunStep) { Breadboard.RunStep runStep = (Breadboard.RunStep) message; processScript(runStep.source, breadboardMessage.out, null); } else if (message instanceof Breadboard.ChangeExperiment) { if (breadboardMessage.user != null) { rebuildScriptBoard(breadboardMessage.user.selectedExperiment); loadSteps(breadboardMessage.user.selectedExperiment, breadboardMessage.out); Breadboard.ChangeExperiment changeExperiment = (Breadboard.ChangeExperiment) message; if (breadboardMessage.user.experimentInstanceId != -1) { ExperimentInstance runningInstance = ExperimentInstance.findById(breadboardMessage.user.experimentInstanceId); if (runningInstance != null) { if (runningInstance.status == ExperimentInstance.Status.RUNNING && runningInstance.experiment.id.equals(changeExperiment.experiment.id)) { eventTracker.setExperimentInstance(runningInstance); gameListener.experimentInstance = runningInstance; for (Data param : runningInstance.data) { initParam(param, changeExperiment.experiment); } } } else { } } } } else if (message instanceof Breadboard.DeleteExperiment) { Breadboard.DeleteExperiment deleteExperiment = (Breadboard.DeleteExperiment) message; Experiment toBeDeleteExperiment = deleteExperiment.user.getExperimentByName(deleteExperiment.experimentName); <FILL_ME> for (Parameter p : breadboardMessage.user.getExperiment().getParameters()) { <FILL_ME> if (engine.getBindings(ScriptContext.ENGINE_SCOPE).containsKey(p.name))
              engine.getBindings(ScriptContext.ENGINE_SCOPE).remove(p.name); } breadboardMessage.user.currentScript = """"; processScript(""g.empty()"", breadboardMessage.out, null); if (toBeDeleteExperiment != null) { List<User> users = User.find.all(); boolean update; boolean updateManyToMany; for (User user : users) { if (user.email.equalsIgnoreCase(breadboardMessage.user.email)) { user = breadboardMessage.user; user.setExperimentInstanceId(-1L); } update = false; updateManyToMany = false; if (user.selectedExperiment != null && user.selectedExperiment.id == toBeDeleteExperiment.id) { update = true; user.setSelectedExperiment(null); } if (user.ownedExperiments.contains(toBeDeleteExperiment)) { updateManyToMany = true; user.ownedExperiments.remove(toBeDeleteExperiment); } if (update) { user.update(); } if (updateManyToMany) { user.saveManyToManyAssociations(""ownedExperiments""); } } toBeDeleteExperiment.delete(); } Breadboard.breadboardController.tell(new Breadboard.Update(breadboardMessage.user, breadboardMessage.out), null); } else if (message instanceof Breadboard.LaunchGame) { Breadboard.LaunchGame launchGame = (Breadboard.LaunchGame) message; if (breadboardMessage.user.selectedExperiment != null) { rebuildScriptBoard(breadboardMessage.user.selectedExperiment); ExperimentInstance instance = startGame(launchGame.name, breadboardMessage.user.experimentInstanceId, launchGame.parameters,
                breadboardMessage.user.selectedExperiment, breadboardMessage.user); instanceData.addPropertyChangeListener(new UserDataChangeListener(instance)); eventTracker.enable(); eventTracker.setExperimentInstance(instance); gameListener.experimentInstance = instance; gameListener.start(); for (Step step : instance.experiment.getSteps())
              Breadboard.instances.get(breadboardMessage.user.email).tell(new Breadboard.RunStep(breadboardMessage.user, step.source, breadboardMessage.out), null); } Breadboard.breadboardController.tell(new Breadboard.Update(breadboardMessage.user, breadboardMessage.out), null); } else if (message instanceof Breadboard.SelectInstance) { Breadboard.SelectInstance selectInstance = (Breadboard.SelectInstance) message; rebuildScriptBoard(breadboardMessage.user.selectedExperiment); loadSteps(breadboardMessage.user.selectedExperiment, selectInstance.out); breadboardMessage.user.setExperimentInstanceId(selectInstance.id); breadboardMessage.user.update(); gameListener.stop(); ExperimentInstance instance = ExperimentInstance.findById(selectInstance.id); if (instance.status.isRunnable()) { List<Data> parameters = instance.data; for (Data param : parameters) { initParam(param, breadboardMessage.user.selectedExperiment); } eventTracker.enable(); eventTracker.setExperimentInstance(instance); gameListener.experimentInstance = instance; gameListener.start(); instanceData.addPropertyChangeListener(new UserDataChangeListener(instance)); breadboardMessage.user.selectedExperiment = Experiment.findById(breadboardMessage.user.selectedExperiment.id); } Breadboard.breadboardController.tell(new Breadboard.Update(breadboardMessage.user, breadboardMessage.out), null); } else if (message instanceof Breadboard.StopGame) { Breadboard.StopGame stopGame = (Breadboard.StopGame) message; ExperimentInstance instance = ExperimentInstance.findById(stopGame.id); if (gameListener.experimentInstance != null && gameListener.experimentInstance.equals(instance)) { for (Parameter p : breadboardMessage.user.getExperiment().getParameters()) { if (engine.getBindings(ScriptContext.ENGINE_SCOPE).containsKey(p.name))
                engine.getBindings(ScriptContext.ENGINE_SCOPE).remove(p.name); } if (gameListener.experimentInstance == null) { <FILL_ME> gameListener.experimentInstance = ExperimentInstance.findById(breadboardMessage.user.experimentInstanceId); } if (gameListener.experimentInstance.status.isRunnable()) { <FILL_ME> gameListener.stop(); } } else { if (instance.status.isRunnable()) { instance.stop(); } } breadboardMessage.user.setExperimentInstanceId(-1L); breadboardMessage.user.update(); Breadboard.breadboardController.tell(new Breadboard.Update(breadboardMessage.user, breadboardMessage.out), null); } else if (message instanceof Breadboard.RunOnJoinStep) { Breadboard.RunOnJoinStep runOnJoinStep = (Breadboard.RunOnJoinStep) message; runOnJoinStep.user.refresh(); if (runOnJoinStep.user.selectedExperiment != null && runOnJoinStep.user.selectedExperiment.hasOnJoinStep()) { Vertex player = runOnJoinStep.vertex; String script = ""onJoinStep.start(\"""" + player.getId().toString() + ""\"")""; processScript(script, runOnJoinStep.out, null); } } else if (message instanceof Breadboard.RunOnLeaveStep) { Breadboard.RunOnLeaveStep runOnLeaveStep = (Breadboard.RunOnLeaveStep) message; runOnLeaveStep.user.refresh(); if (runOnLeaveStep.user.selectedExperiment != null && runOnLeaveStep.user.selectedExperiment.hasOnLeaveStep()) { Vertex player = runOnLeaveStep.vertex; if (engine.get(""onLeaveStep.start()"") != null) { processScript(""onLeaveStep.start(\"""" + player.getId().toString() + ""\"")"", runOnLeaveStep.out, null); } } } else if (message instanceof Breadboard.Refresh) { <FILL_ME> for (Admin admin : admins) { admin.setOut(breadboardMessage.out); } Graph wholeGraph = (Graph) engine.get(""g""); for (Admin admin : admins) { for (Vertex v : wholeGraph.getVertices()) { admin.vertexAdded(v, false); } for (Edge e : wholeGraph.getEdges()) { admin.edgeAdded(e); } } } else if (message instanceof Breadboard.GameFinish) { Breadboard.instances.get(breadboardMessage.user.email).tell(new Breadboard.ReloadEngine(breadboardMessage.user, breadboardMessage.out), null); Breadboard.breadboardController.tell(new Breadboard.Update(breadboardMessage.user, breadboardMessage.out), null); } else if (message instanceof Breadboard.ReloadEngine) { Experiment selectedExperiment = breadboardMessage.user.getExperiment(); rebuildScriptBoard(selectedExperiment); loadSteps(selectedExperiment, breadboardMessage.out); Breadboard.ReloadEngine reloadEngine = (Breadboard.ReloadEngine) message; if (reloadEngine.user.experimentInstanceId != -1) { ExperimentInstance ei = ExperimentInstance.findById(reloadEngine.user.experimentInstanceId); if (ei != null) { eventTracker.enable(); eventTracker.setExperimentInstance(ei); for (Data d : ei.data) { initParam(d, selectedExperiment); } } } } } } catch (Exception e) { e.printStackTrace(); } } private ExperimentInstance startGame(String gameName, long currentExperimentInstanceId, LinkedHashMap parameters, Experiment selectedExperiment, User user) { ExperimentInstance instance = new ExperimentInstance(gameName, selectedExperiment); instance.hasStarted = false; instance.status = ExperimentInstance.Status.STOPPED; if (currentExperimentInstanceId != -1) { ExperimentInstance runningInstance = ExperimentInstance.findById(currentExperimentInstanceId); if (runningInstance != null && runningInstance.status.isRunnable()) { runningInstance.status = ExperimentInstance.Status.STOPPED; runningInstance.update(); } } initAllParam(parameters, selectedExperiment, instance); selectedExperiment.instances.add(instance); selectedExperiment.save(); user.setExperimentInstanceId(instance.id); user.update(); return instance; } private void initAllParam(Map params, Experiment experiment, ExperimentInstance instance) { Iterator it = params.keySet().iterator(); while (it.hasNext()) { Object key = it.next(); Data data = new Data(); data.name = key.toString(); data.value = params.get(key).toString(); if (instance != null) { instance.data.add(data); } initParam(data, experiment); } } private void initParam(Data param, Experiment experiment) { String key = param.name; <FILL_ME> Parameter parameter = experiment == null ? null : experiment.getParameterByName(key); if (parameter == null) { engine.getBindings(ScriptContext.ENGINE_SCOPE).put(key, param.value); return; } if (parameter != null) { if (parameter.type.equals(""Integer"")) { try { Integer intParameter = Integer.parseInt(param.value); engine.getBindings(ScriptContext.ENGINE_SCOPE).put(key, intParameter); } catch (NumberFormatException npe) { <FILL_ME> <FILL_ME> } } else if (parameter.type.equals(""Decimal"")) { try { Double doubleParameter = Double.parseDouble(param.value); engine.getBindings(ScriptContext.ENGINE_SCOPE).put(key, doubleParameter); } catch (NumberFormatException npe) { } } else if (parameter.type.equals(""Text"")) { engine.getBindings(ScriptContext.ENGINE_SCOPE).put(key, param.value); } else if (parameter.type.equals(""Boolean"")) { Boolean booleanParameter = Boolean.parseBoolean(param.value); engine.getBindings(ScriptContext.ENGINE_SCOPE).put(key, booleanParameter); } } } private static void makeChoice(String uid, String params, ThrottledWebSocketOut out) { ObjectNode jsonOutput = Json.newObject(); playerActions.choose(uid, params); out.write(jsonOutput); } public static void processScript(String script, ThrottledWebSocketOut out, String scriptName) { if (scriptName == null) scriptName = ""Unnamed Script""; ObjectNode jsonOutput = Json.newObject(); boolean initStep = false; synchronized (ScriptBoard.class) { if (script.contains(""initStep.start()"")) { if (engine.get(""initStep.start()"") != null) { <FILL_ME> jsonOutput.put(""error"", ""Caught error: "".concat(""initStep started already"").concat(""\n"")); if (out != null) { out.write(jsonOutput); } return; } engine.put(""initStep.start()"", true); initStep = true; } } try { Object outputObject = engine.eval(script); jsonOutput.put(""error"", """"); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); mapper.writeValue(outputStream, engine.getBindings(ScriptContext.ENGINE_SCOPE).get(""results"")); String outputString = script.trim().concat(""\n\n==>""); if (outputObject != null) { if (outputObject instanceof GremlinGroovyPipeline) { outputString += StringUtils.join(((GremlinGroovyPipeline) outputObject).toList(), ""\n==>""); } else { outputString += outputObject.toString(); } } jsonOutput.put(""output"", outputString.trim()); } catch (CompilationFailedException cfe) { <FILL_ME> jsonOutput.put(""error"", ""Caught error: "".concat(cfe.getMessage()).concat(""\n"")); if (initStep) { engine.put(""initStep.start()"", null); } } catch (ScriptException se) { <FILL_ME> jsonOutput.put(""error"", ""Caught error: "".concat(se.getMessage()).concat(""\n"")); if (initStep) { engine.put(""initStep.start()"", null); } } catch (Exception e) { jsonOutput.put(""error"", ""Caught error: "".concat(e.getMessage()).concat(""\n"")); if (initStep) { engine.put(""initStep.start()"", null); } } finally { if (out != null) { out.write(jsonOutput); } } } private class UserDataChangeListener implements PropertyChangeListener { private ExperimentInstance experimentInstance; private UserDataChangeListener(ExperimentInstance experimentInstance) { this.experimentInstance = experimentInstance; } @Override
    public void propertyChange(PropertyChangeEvent evt) { List<Data> dataList = experimentInstance.data; Data foundData = null; if (evt.getPropertyName() != null) { foundData = findDataByName(evt.getPropertyName()); } if (evt instanceof ObservableMap.PropertyAddedEvent) { Data newData = foundData == null ? new Data() : foundData; newData.name = evt.getPropertyName(); newData.value = evt.getNewValue().toString(); newData.experimentInstance = experimentInstance; if (foundData == null) { dataList.add(newData); experimentInstance.save(); } else { newData.save(); } initParam(newData, null); } else if (evt instanceof ObservableMap.PropertyClearedEvent) { List<Parameter> parameters = experimentInstance.experiment.getParameters(); List<String> parameterNames = new ArrayList<String>(); for (Parameter parameter : parameters) { parameterNames.add(parameter.name); } Iterator<Data> dataIterator = dataList.iterator(); while (dataIterator.hasNext()) { Data d = dataIterator.next(); if (!parameterNames.contains(d.name)) { dataIterator.remove(); engine.getBindings(ScriptContext.ENGINE_SCOPE).remove(d.name); } } experimentInstance.save(); } else if (evt instanceof ObservableMap.PropertyRemovedEvent) { if (foundData != null) { dataList.remove(foundData); engine.getBindings(ScriptContext.ENGINE_SCOPE).remove(foundData.name); } experimentInstance.save(); } else if (evt instanceof ObservableMap.PropertyUpdatedEvent) { if (foundData != null) { foundData.value = evt.getNewValue().toString(); } foundData.save(); initParam(foundData, null); } } private Data findDataByName(String name) { List<Data> dataList = experimentInstance.data; for (Data d : dataList) { if (d.name.equals(name)) { return d; } } return null; } } } ","package models; 
import akka.actor.*; import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.node.ObjectNode; import com.tinkerpop.blueprints.Edge; import com.tinkerpop.blueprints.Graph; import com.tinkerpop.blueprints.Vertex; import com.tinkerpop.gremlin.groovy.GremlinGroovyPipeline; import groovy.util.ObservableMap; import groovy.lang.Closure; import org.apache.commons.io.FileUtils; import org.apache.commons.io.output.ByteArrayOutputStream; import org.apache.commons.lang3.StringUtils; import org.codehaus.groovy.control.CompilationFailedException; import play.Logger; import play.Play; import play.libs.F.Callback; import play.libs.Json; import play.mvc.WebSocket; 
import javax.script.*; import java.beans.PropertyChangeEvent; import java.beans.PropertyChangeListener; import java.io.File; import java.io.IOException; import java.util.*;  public class ScriptBoard extends UntypedActor { private static ObjectMapper mapper = new ObjectMapper();  private static ScriptEngineManager manager = new ScriptEngineManager(); private static ScriptEngine engine;  private static Map results = new HashMap(); private static PlayerActionsInterface playerActions; private static BreadboardGraphInterface graphInterface; private static BreadboardGraphChangedListener graphChangedListener; private static FileWatcher fileWatcher; private static EventTracker eventTracker = new EventTracker(); private static EventBus<Map> eventBus = new EventBus();  private static Random rand = new Random(); private static HashMap<String, Client> clients = new HashMap<>();  // A list of admins currently watching the game. private static ArrayList<Admin> admins = new ArrayList<>(); private static UserDataInterface instanceData; private GameListener gameListener = new GameListener();  private Long experimentId; private Long instanceId;  public static boolean checkPassword(String _password) { // If no password is set, always return true if (engine == null || engine.get(""password"") == null)
      return true; Object password = engine.get(""password""); return _password.equals(password.toString()); } <FILL_ME>  public ScriptBoard() throws IOException, ScriptException { rebuildScriptBoard(null); }  private void init() { results = new HashMap(); mapper = new ObjectMapper(); admins = new ArrayList<>(); clients = new HashMap<>(); eventTracker = new EventTracker(); manager = new ScriptEngineManager(); eventBus.clear(); }  private void disconnectClients () { // Disconnect all connected clients for (Client client : clients.values()) { client.disconnect(); } clients.clear(); }  private void resetEngine(Experiment experiment) throws IOException, ScriptException { // When started, send a message to each Admin for (Admin admin : admins) { ObjectNode jsonOutput = Json.newObject(); ObjectNode notify = Json.newObject(); notify.put(""ScriptEngineReloading"", new Date().getTime()); jsonOutput.put(""notify"", notify); admin.getOut().write(jsonOutput); } if (engine != null) { // just in case playerActions.turnAIOff(); // clean up the graph processScript(""g.empty()"", null, null); // Reset the timers processScript(""timers.cancel()"", null, null); }  // Global events used to communicate via the groovy scripting eventBus.clear(); eventBus.on(""__send-event"", new Closure(null) { public void doCall (String clientId, String eventName, Object ...data) { <FILL_ME> <FILL_ME> Client client = clients.get(clientId); if (client == null) { <FILL_ME> return; } client.send(eventName, data); } } ); eventBus.on(""__broadcast-event"", new Closure(null) { public void doCall (String clientId, String eventName, Object ...data) { for (Client client : clients.values()) { client.send(eventName, data); } } } );  engine = manager.getEngineByName(""gremlin-groovy""); engine.getBindings(ScriptContext.ENGINE_SCOPE).put(""r"", rand); engine.getBindings(ScriptContext.ENGINE_SCOPE).put(""results"", results);  engine.getBindings(ScriptContext.ENGINE_SCOPE).put(""eventTracker"", eventTracker); engine.getBindings(ScriptContext.ENGINE_SCOPE).put(""gameListener"", gameListener); engine.getBindings(ScriptContext.ENGINE_SCOPE).put(""events"", eventBus);  if (experiment != null) { engine.getBindings(ScriptContext.ENGINE_SCOPE).put(""c"", experiment.contentFetcher); }  String[] scriptFiles = { ""/util.groovy"", 
      ""/timer.groovy"",
      ""/graph.groovy"", 
      ""/actions.groovy"", 
      ""/step.groovy"", 
      ""/test.groovy"",
      ""/events.groovy"",
      ""/chat.groovy"",
      ""/form.groovy"",
      ""/ready.groovy""
    } ;  // Load Groovy scripts for (String file : scriptFiles) { File utilFile = new File(Play.application().path().toString() + ""/groovy"" + file); // Add a null terminator for each file so the script engine can always reload even after errors String utilString = FileUtils.readFileToString(utilFile, ""UTF-8"") + ""; null; ""; <FILL_ME> engine.eval(utilString); <FILL_ME> }  // get script object on which we want to implement the interface with Object a = engine.get(""a""); Invocable inv = (Invocable) engine; playerActions = inv.getInterface(a, PlayerActionsInterface.class);  Object d = engine.get(""d""); instanceData = inv.getInterface(d, UserDataInterface.class);  Object g = engine.get(""g""); graphInterface = inv.getInterface(g, BreadboardGraphInterface.class);  if (graphChangedListener == null) { <FILL_ME> Long clientUpdateRate = play.Play.application().configuration().getMilliseconds(""breadboard.clientUpdateRate""); if (clientUpdateRate == null || clientUpdateRate == 0) { <FILL_ME> graphChangedListener = new EventGraphChangedListener((Graph) g);  } else { <FILL_ME> <FILL_ME> <FILL_ME> graphChangedListener = new IteratedBreadboardGraphChangedListener((Graph) g); } } else { graphChangedListener.setGraph((Graph) g); }  graphInterface.addListener(graphChangedListener);  if (fileWatcher == null) { fileWatcher = new FileWatcher(admins); }  gameListener.engine = engine;  // When done, send a message to each Admin for (Admin admin : admins) { ObjectNode jsonOutput = Json.newObject(); ObjectNode notify = Json.newObject(); notify.put(""ScriptEngineReloaded"", new Date().getTime()); jsonOutput.put(""notify"", notify); admin.getOut().write(jsonOutput); } this.disconnectClients(); <FILL_ME> }  private void loadSteps(Experiment experiment, ThrottledWebSocketOut out) { for (Step step : experiment.getSteps()) { //should call RunStep? processScript(step.source + ""; null; "", out, step.name); } }  private String makeUniqueClientId (String clientId) { return this.experimentId + ""-"" + this.instanceId + ""-"" + clientId; }  private void rebuildScriptBoard(Experiment experiment) throws IOException, ScriptException { //init(); resetEngine(experiment); }  public static void addAdmin(Admin admin) { admins.add(admin); graphChangedListener.addAdminListener(admin); }  public static void addClient(String experimentIdString, String experimentInstanceIdString, String clientId, final WebSocket.In<JsonNode> in, final ThrottledWebSocketOut out) throws Exception { try { Long experimentId = Long.parseLong(experimentIdString); Long experimentInstanceId = Long.parseLong(experimentInstanceIdString);  Experiment experiment = Experiment.findById(experimentId); if (experiment == null) { <FILL_ME> return; }  ExperimentInstance experimentInstance = null; if (experimentInstanceId.equals(Experiment.TEST_INSTANCE_ID)) { experimentInstance = experiment.getTestInstance(); } else { experimentInstance = ExperimentInstance.findById(experimentInstanceId); } if (experimentInstance == null) { <FILL_ME> return; }  Client client = clients.get(clientId);  if (client == null && experimentInstance.hasStarted) { <FILL_ME> return; }  if (client == null) { // New client, let's create a new Client object client = new Client(clientId, experimentInstance, in, out); clients.put(clientId, client); } else { // Reconnecting: let's change the in / out so they continue to receive messages client.setIn(in); client.setOut(out); }  in.onMessage(new Callback<JsonNode>() { public void invoke(JsonNode event) { try { ObjectMapper mapper = new ObjectMapper(); // TODO: is event.toString() the correct method here? Map<String, Object> jsonInput = mapper.readValue(event.toString(), Map.class); String action = jsonInput.get(""action"").toString(); if (action.equals(""LogIn"")) { String clientId = jsonInput.get(""clientId"").toString(); String referer = jsonInput.get(""referer"").toString(); String connection = jsonInput.get(""connection"").toString(); String accept = jsonInput.get(""accept"").toString(); String acceptLanguage = jsonInput.get(""acceptLanguage"").toString(); String acceptEncoding = jsonInput.get(""acceptEncoding"").toString(); String userAgent = jsonInput.get(""userAgent"").toString(); String host = jsonInput.get(""host"").toString(); String ipAddress = jsonInput.get(""ipAddress"").toString(); String requestURI = jsonInput.get(""requestURI"").toString();  if (eventTracker != null) { LinkedHashMap<Object, Object> data = new LinkedHashMap<Object, Object>(); data.put(""clientId"", clientId); data.put(""referer"", referer); data.put(""connection"", connection); data.put(""acceptLanguage"", acceptLanguage); data.put(""acceptEncoding"", acceptEncoding); data.put(""userAgent"", userAgent); data.put(""host"", host); data.put(""ipAddress"", ipAddress); data.put(""requestURI"", requestURI); eventTracker.track(""clientLogIn"", data); } } else if (action.equals(""MakeChoice"")) { String choiceUID = jsonInput.get(""choiceUID"").toString(); String params = (jsonInput.containsKey(""params"")) ? jsonInput.get(""params"").toString() : null; makeChoice(choiceUID, params, out); } else if (action.equals(""CustomEvent"")) { // TODO: Is is possible for this to be emitted before the event has been registered?  //       I think it is and I think it will cause exceptions to be thrown... eventBus.emit(""CustomEvent"", jsonInput, new HashMap<String, String>() { { put(""clientId"", clientId); } } ); } } catch (java.io.IOException ignored) { <FILL_ME> } catch (Exception e) { <FILL_ME> <FILL_ME> } } } );  if (graphChangedListener != null) { graphChangedListener.addClientListener(client); }  if (graphInterface != null) { if (!experimentInstance.hasStarted) { graphInterface.addPlayer(clientId); } Graph wholeGraph = (Graph) engine.get(""g""); Vertex clientVertex = wholeGraph.getVertex(clientId); if (clientVertex != null) { if (graphChangedListener instanceof EventGraphChangedListener) { client.updateGraph(clientVertex); } } }  // Update the client's state ObjectNode jsonOutput = Json.newObject(); jsonOutput.put(""style"", experimentInstance.experiment.getStyle()); <FILL_ME> out.write(jsonOutput); } catch (NumberFormatException nfe) { <FILL_ME> } }  public void onReceive(Object message) throws Exception { try { if (message instanceof Breadboard.BreadboardMessage) { Breadboard.BreadboardMessage breadboardMessage = (Breadboard.BreadboardMessage) message; if (breadboardMessage.user != null) { gameListener.user = breadboardMessage.user; gameListener.out = breadboardMessage.out; } if (message instanceof Breadboard.AddAdmin) { Breadboard.AddAdmin addAdmin = (Breadboard.AddAdmin) message;  addAdmin(new Admin(addAdmin.user, addAdmin.scriptBoardController, addAdmin.out)); } else if (message instanceof Breadboard.RunGame) { if (breadboardMessage.user != null) { // Run Game processScript(""initStep.start()"", breadboardMessage.out, null); }  } else if (message instanceof Breadboard.HitCreated) { Breadboard.HitCreated hitCreated = (Breadboard.HitCreated) message; if (breadboardMessage.user != null) { Integer lifetimeInMs = hitCreated.lifetimeInSeconds * 1000; Integer tutorialTimeInMs = hitCreated.tutorialTime * 1000; Long timerTime = System.currentTimeMillis() + (lifetimeInMs + tutorialTimeInMs); // startAt will be used to add timer to clients for start of game processScript(""startAt = "" + timerTime, breadboardMessage.out, null);  final ThrottledWebSocketOut breadboardOut = breadboardMessage.out; // Set timer for lifetimeInSeconds time after which no longer allow new client connections new Timer().schedule(new TimerTask() { @Override
              public void run() { gameListener.hasStarted(); } } , lifetimeInMs);  // Set timer for lifetimeInMs + tutorialTimeInMs time after which send an initStep.start() message new Timer().schedule(new TimerTask() { @Override
              public void run() { processScript(""initStep.start()"", breadboardOut, null); <FILL_ME> } } , (lifetimeInMs + tutorialTimeInMs)); } } else if (message instanceof Breadboard.SendScript) { Breadboard.SendScript sendScript = (Breadboard.SendScript) message;  if (breadboardMessage.user != null) { // Save script in database breadboardMessage.user.currentScript = sendScript.script; breadboardMessage.user.update();  // Process script processScript(sendScript.script, breadboardMessage.out, null); }  } else if (message instanceof Breadboard.MakeChoice) { Breadboard.MakeChoice makeChoice = (Breadboard.MakeChoice) message; makeChoice(makeChoice.uid, makeChoice.params, breadboardMessage.out); } else if (message instanceof Breadboard.SendStep) { Breadboard.SendStep sendStep = (Breadboard.SendStep) message;  if (breadboardMessage.user != null && breadboardMessage.user.selectedExperiment != null) { <FILL_ME> // Now we only run the step Breadboard.instances.get(breadboardMessage.user.email).tell(new Breadboard.RunStep(breadboardMessage.user, sendStep.source, breadboardMessage.out), null); } } else if (message instanceof Breadboard.RunStep) { // TODO: Compile step here and make available to scripting engine Breadboard.RunStep runStep = (Breadboard.RunStep) message; processScript(runStep.source, breadboardMessage.out, null); } else if (message instanceof Breadboard.ChangeExperiment) { if (breadboardMessage.user != null) { rebuildScriptBoard(breadboardMessage.user.selectedExperiment); loadSteps(breadboardMessage.user.selectedExperiment, breadboardMessage.out); Breadboard.ChangeExperiment changeExperiment = (Breadboard.ChangeExperiment) message;  //reset the instance if (breadboardMessage.user.experimentInstanceId != -1) { ExperimentInstance runningInstance = ExperimentInstance.findById(breadboardMessage.user.experimentInstanceId); if (runningInstance != null) { if (runningInstance.status == ExperimentInstance.Status.RUNNING && runningInstance.experiment.id.equals(changeExperiment.experiment.id)) { eventTracker.setExperimentInstance(runningInstance); gameListener.experimentInstance = runningInstance; for (Data param : runningInstance.data) { initParam(param, changeExperiment.experiment); } } } else { } } } } else if (message instanceof Breadboard.DeleteExperiment) { Breadboard.DeleteExperiment deleteExperiment = (Breadboard.DeleteExperiment) message;  Experiment toBeDeleteExperiment = deleteExperiment.user.getExperimentByName(deleteExperiment.experimentName); <FILL_ME>  //also stops the game for (Parameter p : breadboardMessage.user.getExperiment().getParameters()) { <FILL_ME> if (engine.getBindings(ScriptContext.ENGINE_SCOPE).containsKey(p.name))
              engine.getBindings(ScriptContext.ENGINE_SCOPE).remove(p.name); }  breadboardMessage.user.currentScript = """"; processScript(""g.empty()"", breadboardMessage.out, null);  if (toBeDeleteExperiment != null) { //needs to remove all the selectedExperiment and ownedExperiments which is this toBeDeleteExperiment List<User> users = User.find.all();  boolean update; boolean updateManyToMany; for (User user : users) { if (user.email.equalsIgnoreCase(breadboardMessage.user.email)) { user = breadboardMessage.user; user.setExperimentInstanceId(-1L); } update = false; updateManyToMany = false; if (user.selectedExperiment != null && user.selectedExperiment.id == toBeDeleteExperiment.id) { update = true; user.setSelectedExperiment(null); } if (user.ownedExperiments.contains(toBeDeleteExperiment)) { updateManyToMany = true; user.ownedExperiments.remove(toBeDeleteExperiment); } if (update) { user.update(); } if (updateManyToMany) { user.saveManyToManyAssociations(""ownedExperiments""); } }  toBeDeleteExperiment.delete(); }  Breadboard.breadboardController.tell(new Breadboard.Update(breadboardMessage.user, breadboardMessage.out), null); } else if (message instanceof Breadboard.LaunchGame) { Breadboard.LaunchGame launchGame = (Breadboard.LaunchGame) message;  if (breadboardMessage.user.selectedExperiment != null) { rebuildScriptBoard(breadboardMessage.user.selectedExperiment); ExperimentInstance instance = startGame(launchGame.name, breadboardMessage.user.experimentInstanceId, launchGame.parameters,
                breadboardMessage.user.selectedExperiment, breadboardMessage.user);  instanceData.addPropertyChangeListener(new UserDataChangeListener(instance));  eventTracker.enable(); eventTracker.setExperimentInstance(instance); gameListener.experimentInstance = instance; gameListener.start();  // Re-run the Steps for (Step step : instance.experiment.getSteps())
              Breadboard.instances.get(breadboardMessage.user.email).tell(new Breadboard.RunStep(breadboardMessage.user, step.source, breadboardMessage.out), null);  } // END if (breadboardMessage.user.selectedExperiment != null) // Update User JSON Breadboard.breadboardController.tell(new Breadboard.Update(breadboardMessage.user, breadboardMessage.out), null);  } // END else if(message instanceof Breadboard.LaunchGame) else if (message instanceof Breadboard.SelectInstance) { Breadboard.SelectInstance selectInstance = (Breadboard.SelectInstance) message; rebuildScriptBoard(breadboardMessage.user.selectedExperiment); loadSteps(breadboardMessage.user.selectedExperiment, selectInstance.out); breadboardMessage.user.setExperimentInstanceId(selectInstance.id); breadboardMessage.user.update();  gameListener.stop(); ExperimentInstance instance = ExperimentInstance.findById(selectInstance.id); if (instance.status.isRunnable()) { List<Data> parameters = instance.data; for (Data param : parameters) { initParam(param, breadboardMessage.user.selectedExperiment); } // END for (Data param : parameters)  eventTracker.enable(); eventTracker.setExperimentInstance(instance); gameListener.experimentInstance = instance; gameListener.start();  instanceData.addPropertyChangeListener(new UserDataChangeListener(instance));  //don't know why... ebean bug? if don't do this, the instances in the selectedExperiment doesn't get updated //which is causing the launch button still shows up (because the status isn't updated) instead of the stop button for the instance breadboardMessage.user.selectedExperiment = Experiment.findById(breadboardMessage.user.selectedExperiment.id); } Breadboard.breadboardController.tell(new Breadboard.Update(breadboardMessage.user, breadboardMessage.out), null); } // END else if(message instanceof Breadboard.SelectInstance) else if (message instanceof Breadboard.StopGame) { Breadboard.StopGame stopGame = (Breadboard.StopGame) message;  ExperimentInstance instance = ExperimentInstance.findById(stopGame.id); if (gameListener.experimentInstance != null && gameListener.experimentInstance.equals(instance)) { for (Parameter p : breadboardMessage.user.getExperiment().getParameters()) { //Logger.debug(""Key: "" + p.name); if (engine.getBindings(ScriptContext.ENGINE_SCOPE).containsKey(p.name))
                engine.getBindings(ScriptContext.ENGINE_SCOPE).remove(p.name); }  if (gameListener.experimentInstance == null) { <FILL_ME> gameListener.experimentInstance = ExperimentInstance.findById(breadboardMessage.user.experimentInstanceId); }  if (gameListener.experimentInstance.status.isRunnable()) { <FILL_ME> gameListener.stop(); }  } else { if (instance.status.isRunnable()) { instance.stop(); } } breadboardMessage.user.setExperimentInstanceId(-1L); breadboardMessage.user.update(); // Update User JSON Breadboard.breadboardController.tell(new Breadboard.Update(breadboardMessage.user, breadboardMessage.out), null); } // END else if(message instanceof Breadboard.StopGame) else if (message instanceof Breadboard.RunOnJoinStep) { Breadboard.RunOnJoinStep runOnJoinStep = (Breadboard.RunOnJoinStep) message; runOnJoinStep.user.refresh(); //the script engine was throwing exception for ArbesmanRand because of missing onJoinStep if (runOnJoinStep.user.selectedExperiment != null && runOnJoinStep.user.selectedExperiment.hasOnJoinStep()) { Vertex player = runOnJoinStep.vertex; String script = ""onJoinStep.start(\"""" + player.getId().toString() + ""\"")""; processScript(script, runOnJoinStep.out, null); }  } // END else if(message instanceof Breadboard.RunOnJoinStep) else if (message instanceof Breadboard.RunOnLeaveStep) { Breadboard.RunOnLeaveStep runOnLeaveStep = (Breadboard.RunOnLeaveStep) message; runOnLeaveStep.user.refresh(); //the script engine was throwing exception for ArbesmanRand because of missing runOnLeaveStep if (runOnLeaveStep.user.selectedExperiment != null && runOnLeaveStep.user.selectedExperiment.hasOnLeaveStep()) { Vertex player = runOnLeaveStep.vertex; if (engine.get(""onLeaveStep.start()"") != null) { processScript(""onLeaveStep.start(\"""" + player.getId().toString() + ""\"")"", runOnLeaveStep.out, null); } }  } // END else if(message instanceof Breadboard.RunOnLeaveStep) else if (message instanceof Breadboard.Refresh) { <FILL_ME>  //need to refresh the listeners for (Admin admin : admins) { admin.setOut(breadboardMessage.out); }  //ObjectNode jsonOutput = Json.newObject(); Graph wholeGraph = (Graph) engine.get(""g"");  for (Admin admin : admins) { for (Vertex v : wholeGraph.getVertices()) { admin.vertexAdded(v, false); } for (Edge e : wholeGraph.getEdges()) { admin.edgeAdded(e); } } //breadboardMessage.out.write(jsonOutput); } else if (message instanceof Breadboard.GameFinish) { Breadboard.instances.get(breadboardMessage.user.email).tell(new Breadboard.ReloadEngine(breadboardMessage.user, breadboardMessage.out), null); Breadboard.breadboardController.tell(new Breadboard.Update(breadboardMessage.user, breadboardMessage.out), null); } else if (message instanceof Breadboard.ReloadEngine) { Experiment selectedExperiment = breadboardMessage.user.getExperiment(); rebuildScriptBoard(selectedExperiment); loadSteps(selectedExperiment, breadboardMessage.out); Breadboard.ReloadEngine reloadEngine = (Breadboard.ReloadEngine) message; if (reloadEngine.user.experimentInstanceId != -1) { ExperimentInstance ei = ExperimentInstance.findById(reloadEngine.user.experimentInstanceId); if (ei != null) { eventTracker.enable(); eventTracker.setExperimentInstance(ei); for (Data d : ei.data) { initParam(d, selectedExperiment); } } } } } } catch (Exception e) { e.printStackTrace(); } }  private ExperimentInstance startGame(String gameName, long currentExperimentInstanceId, LinkedHashMap parameters, Experiment selectedExperiment, User user) { ExperimentInstance instance = new ExperimentInstance(gameName, selectedExperiment); instance.hasStarted = false; instance.status = ExperimentInstance.Status.STOPPED;  if (currentExperimentInstanceId != -1) { ExperimentInstance runningInstance = ExperimentInstance.findById(currentExperimentInstanceId); if (runningInstance != null && runningInstance.status.isRunnable()) { runningInstance.status = ExperimentInstance.Status.STOPPED; runningInstance.update(); } }  initAllParam(parameters, selectedExperiment, instance);  selectedExperiment.instances.add(instance); selectedExperiment.save();  user.setExperimentInstanceId(instance.id); user.update();  return instance; }  private void initAllParam(Map params, Experiment experiment, ExperimentInstance instance) {  Iterator it = params.keySet().iterator(); while (it.hasNext()) { Object key = it.next(); // Add the initial parameters to the data of the ExperimentInstance Data data = new Data(); data.name = key.toString(); data.value = params.get(key).toString(); if (instance != null) { instance.data.add(data); }  initParam(data, experiment); } // END while(it.hasNext()) }  private void initParam(Data param, Experiment experiment) { String key = param.name; <FILL_ME> Parameter parameter = experiment == null ? null : experiment.getParameterByName(key); if (parameter == null) { //default string value engine.getBindings(ScriptContext.ENGINE_SCOPE).put(key, param.value); return; } // TODO: Perhaps put this code elsewhere? // Bind the initial variables to the script engine if (parameter != null) { if (parameter.type.equals(""Integer"")) { try { Integer intParameter = Integer.parseInt(param.value); engine.getBindings(ScriptContext.ENGINE_SCOPE).put(key, intParameter); } catch (NumberFormatException npe) { <FILL_ME> <FILL_ME> } } else if (parameter.type.equals(""Decimal"")) { try { Double doubleParameter = Double.parseDouble(param.value); engine.getBindings(ScriptContext.ENGINE_SCOPE).put(key, doubleParameter); } catch (NumberFormatException npe) { }  } else if (parameter.type.equals(""Text"")) { engine.getBindings(ScriptContext.ENGINE_SCOPE).put(key, param.value); } else if (parameter.type.equals(""Boolean"")) { Boolean booleanParameter = Boolean.parseBoolean(param.value); engine.getBindings(ScriptContext.ENGINE_SCOPE).put(key, booleanParameter); } } //END if (parameter != null) }  private static void makeChoice(String uid, String params, ThrottledWebSocketOut out) { ObjectNode jsonOutput = Json.newObject(); playerActions.choose(uid, params); out.write(jsonOutput); }  public static void processScript(String script, ThrottledWebSocketOut out, String scriptName) { if (scriptName == null) scriptName = ""Unnamed Script"";  ObjectNode jsonOutput = Json.newObject(); //TODO: better way to handle this? boolean initStep = false; synchronized (ScriptBoard.class) { if (script.contains(""initStep.start()"")) { if (engine.get(""initStep.start()"") != null) { <FILL_ME> jsonOutput.put(""error"", ""Caught error: "".concat(""initStep started already"").concat(""\n"")); if (out != null) { out.write(jsonOutput); } return; } engine.put(""initStep.start()"", true); initStep = true; } } try { Object outputObject = engine.eval(script); // Clear out error jsonOutput.put(""error"", """");  // Write out the results Map as JSON ByteArrayOutputStream outputStream = new ByteArrayOutputStream();  mapper.writeValue(outputStream, engine.getBindings(ScriptContext.ENGINE_SCOPE).get(""results"")); String outputString = script.trim().concat(""\n\n==>"");  if (outputObject != null) { if (outputObject instanceof GremlinGroovyPipeline) { outputString += StringUtils.join(((GremlinGroovyPipeline) outputObject).toList(), ""\n==>""); } else { outputString += outputObject.toString(); } }  jsonOutput.put(""output"", outputString.trim()); } catch (CompilationFailedException cfe) { <FILL_ME> jsonOutput.put(""error"", ""Caught error: "".concat(cfe.getMessage()).concat(""\n"")); if (initStep) { engine.put(""initStep.start()"", null); } } catch (ScriptException se) { <FILL_ME> jsonOutput.put(""error"", ""Caught error: "".concat(se.getMessage()).concat(""\n"")); if (initStep) { engine.put(""initStep.start()"", null); } } catch (Exception e) { jsonOutput.put(""error"", ""Caught error: "".concat(e.getMessage()).concat(""\n"")); if (initStep) { engine.put(""initStep.start()"", null); } } finally { if (out != null) { out.write(jsonOutput); } } }  private class UserDataChangeListener implements PropertyChangeListener {  private ExperimentInstance experimentInstance;  private UserDataChangeListener(ExperimentInstance experimentInstance) { this.experimentInstance = experimentInstance; }  @Override
    public void propertyChange(PropertyChangeEvent evt) { List<Data> dataList = experimentInstance.data; Data foundData = null; if (evt.getPropertyName() != null) { foundData = findDataByName(evt.getPropertyName()); } if (evt instanceof ObservableMap.PropertyAddedEvent) { Data newData = foundData == null ? new Data() : foundData; newData.name = evt.getPropertyName(); newData.value = evt.getNewValue().toString(); newData.experimentInstance = experimentInstance; if (foundData == null) { dataList.add(newData); experimentInstance.save(); } else { newData.save(); } initParam(newData, null);  } else if (evt instanceof ObservableMap.PropertyClearedEvent) { List<Parameter> parameters = experimentInstance.experiment.getParameters(); List<String> parameterNames = new ArrayList<String>(); for (Parameter parameter : parameters) { parameterNames.add(parameter.name); } Iterator<Data> dataIterator = dataList.iterator(); while (dataIterator.hasNext()) { Data d = dataIterator.next(); //make sure not removing the parameters if (!parameterNames.contains(d.name)) { dataIterator.remove(); engine.getBindings(ScriptContext.ENGINE_SCOPE).remove(d.name); } } experimentInstance.save();  } else if (evt instanceof ObservableMap.PropertyRemovedEvent) { if (foundData != null) { dataList.remove(foundData); engine.getBindings(ScriptContext.ENGINE_SCOPE).remove(foundData.name); } experimentInstance.save(); } else if (evt instanceof ObservableMap.PropertyUpdatedEvent) { if (foundData != null) { foundData.value = evt.getNewValue().toString(); } foundData.save(); initParam(foundData, null); } }  private Data findDataByName(String name) { List<Data> dataList = experimentInstance.data; for (Data d : dataList) { //this should be case-sensitive if (d.name.equals(name)) { return d; } } return null; } } }  "
app/models/Step.java,"package models;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonValue;
import com.fasterxml.jackson.databind.node.ObjectNode;
import play.data.format.Formats;
import play.data.validation.Constraints;
import play.db.ebean.Model;
import play.libs.Json;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;
import java.util.List;

@Entity
@Table(name = ""steps"")
public class Step extends Model {
  @Id
  public Long id;

  @Constraints.Required
  @Formats.NonEmpty
  public String name;

  @Column(columnDefinition = ""text"")
  public String source;

  @JsonIgnore
  public static Model.Finder<Long, Step> find = new Model.Finder(Long.class, Step.class);

  @JsonIgnore
  public static List<Step> findAll() {
    return find.all();
  }

  @JsonIgnore
  public static Step findById(Long id) {
    return find.where().eq(""id"", id).findUnique();
  }

  public Step() {
  }

  public Step(Step step) {
    this.name = step.name;
    this.source = step.source;
  }

  public void setSource(String source) {
    this.source = source;
  }

  public void setName(String name) {
    this.name = name;
  }

  public static Step findByName(String name) {
    return find.where().eq(""name"", name).findUnique();
  }

  @JsonValue
  public ObjectNode toJson() {
    ObjectNode step = Json.newObject();
    step.put(""id"", id);
    step.put(""name"", name);
    step.put(""source"", source);
    return step;
  }

  public String toString() {
    return ""Step("" + id + "")"";
  }
}
","package models; @Entity
@Table(name = ""steps"")
public class Step extends Model { @Id
  public Long id; @Constraints.Required
  @Formats.NonEmpty
  public String name; @Column(columnDefinition = ""text"")
  public String source; @JsonIgnore
  public static Model.Finder<Long, Step> find = new Model.Finder(Long.class, Step.class); @JsonIgnore
  public static List<Step> findAll() { return find.all(); } @JsonIgnore
  public static Step findById(Long id) { return find.where().eq(""id"", id).findUnique(); } public Step() { } public Step(Step step) { this.name = step.name; this.source = step.source; } public void setSource(String source) { this.source = source; } public void setName(String name) { this.name = name; } public static Step findByName(String name) { return find.where().eq(""name"", name).findUnique(); } @JsonValue
  public ObjectNode toJson() { ObjectNode step = Json.newObject(); step.put(""id"", id); step.put(""name"", name); step.put(""source"", source); return step; } public String toString() { return ""Step("" + id + "")""; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; @Entity
@Table(name = ""steps"")
public class Step extends Model { @Id
  public Long id; @Constraints.Required
  @Formats.NonEmpty
  public String name; @Column(columnDefinition = ""text"")
  public String source; @JsonIgnore
  public static Model.Finder<Long, Step> find = new Model.Finder(Long.class, Step.class); @JsonIgnore
  public static List<Step> findAll() { return find.all(); } @JsonIgnore
  public static Step findById(Long id) { return find.where().eq(""id"", id).findUnique(); } public Step() { } public Step(Step step) { this.name = step.name; this.source = step.source; } public void setSource(String source) { this.source = source; } public void setName(String name) { this.name = name; } public static Step findByName(String name) { return find.where().eq(""name"", name).findUnique(); } @JsonValue
  public ObjectNode toJson() { ObjectNode step = Json.newObject(); step.put(""id"", id); step.put(""name"", name); step.put(""source"", source); return step; } public String toString() { return ""Step("" + id + "")""; } } ","package models; 
import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.annotation.JsonValue; import com.fasterxml.jackson.databind.node.ObjectNode; import play.data.format.Formats; import play.data.validation.Constraints; import play.db.ebean.Model; import play.libs.Json; 
import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.Id; import javax.persistence.Table; import java.util.List;  @Entity
@Table(name = ""steps"")
public class Step extends Model { @Id
  public Long id;  @Constraints.Required
  @Formats.NonEmpty
  public String name;  @Column(columnDefinition = ""text"")
  public String source;  @JsonIgnore
  public static Model.Finder<Long, Step> find = new Model.Finder(Long.class, Step.class);  @JsonIgnore
  public static List<Step> findAll() { return find.all(); }  @JsonIgnore
  public static Step findById(Long id) { return find.where().eq(""id"", id).findUnique(); }  public Step() { }  public Step(Step step) { this.name = step.name; this.source = step.source; }  public void setSource(String source) { this.source = source; }  public void setName(String name) { this.name = name; }  public static Step findByName(String name) { return find.where().eq(""name"", name).findUnique(); }  @JsonValue
  public ObjectNode toJson() { ObjectNode step = Json.newObject(); step.put(""id"", id); step.put(""name"", name); step.put(""source"", source); return step; }  public String toString() { return ""Step("" + id + "")""; } }  "
app/models/ThrottledWebSocketOut.java,"package models;

import com.fasterxml.jackson.databind.JsonNode;
import play.mvc.WebSocket;

import java.util.Timer;
import java.util.concurrent.LinkedBlockingQueue;

public class ThrottledWebSocketOut {
  private WebSocket.Out<JsonNode> out;
  private LinkedBlockingQueue<JsonNode> queue = new LinkedBlockingQueue<JsonNode>();
  private long lastSent = Long.MAX_VALUE;
  private long wait;
  private Timer timer = new Timer();
  private boolean scheduled = false;

  public ThrottledWebSocketOut(WebSocket.Out<JsonNode> out, long wait) {
    this.out = out;
    this.wait = wait;
  }

  public synchronized void write(JsonNode message) {
    /*
    if(System.currentTimeMillis() - lastSent < wait || scheduled) {
      queue.offer(message);
      if (! scheduled) {
        timer.schedule(new TimerTask() {
          @Override
          public void run() {
            //System.out.println(""TimerTask.run()"");
            ObjectNode outNode = Json.newObject();

            ArrayList<JsonNode> jsonNodes = new ArrayList<JsonNode>();
            while (! queue.isEmpty()) {
              jsonNodes.add(queue.poll());
            }
            outNode.put(""queuedMessages"", Json.toJson(jsonNodes));

            out.write(outNode);

            lastSent = System.currentTimeMillis();
            scheduled = false;
          }
        }, wait);
        scheduled = true;
      }
    } else {
      out.write(message);
      //System.out.println(""queue.size() = "" + queue.size());

      lastSent = System.currentTimeMillis();
    }
    */
    out.write(message);
  }

  public void close () {
    this.out.close();
  }
}
","package models; public class ThrottledWebSocketOut { private WebSocket.Out<JsonNode> out; private LinkedBlockingQueue<JsonNode> queue = new LinkedBlockingQueue<JsonNode>(); private long lastSent = Long.MAX_VALUE; private long wait; private Timer timer = new Timer(); private boolean scheduled = false; public ThrottledWebSocketOut(WebSocket.Out<JsonNode> out, long wait) { this.out = out; this.wait = wait; } public synchronized void write(JsonNode message) { out.write(message); } public void close () { this.out.close(); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; public class ThrottledWebSocketOut { private WebSocket.Out<JsonNode> out; private LinkedBlockingQueue<JsonNode> queue = new LinkedBlockingQueue<JsonNode>(); private long lastSent = Long.MAX_VALUE; private long wait; private Timer timer = new Timer(); private boolean scheduled = false; public ThrottledWebSocketOut(WebSocket.Out<JsonNode> out, long wait) { this.out = out; this.wait = wait; } public synchronized void write(JsonNode message) { out.write(message); } public void close () { this.out.close(); } } ","package models; 
import com.fasterxml.jackson.databind.JsonNode; import play.mvc.WebSocket; 
import java.util.Timer; import java.util.concurrent.LinkedBlockingQueue;  public class ThrottledWebSocketOut { private WebSocket.Out<JsonNode> out; private LinkedBlockingQueue<JsonNode> queue = new LinkedBlockingQueue<JsonNode>(); private long lastSent = Long.MAX_VALUE; private long wait; private Timer timer = new Timer(); private boolean scheduled = false;  public ThrottledWebSocketOut(WebSocket.Out<JsonNode> out, long wait) { this.out = out; this.wait = wait; }  public synchronized void write(JsonNode message) { /*
    if(System.currentTimeMillis() - lastSent < wait || scheduled) {
      queue.offer(message);
      if (! scheduled) {
        timer.schedule(new TimerTask() {
          @Override
          public void run() {
            //System.out.println(""TimerTask.run()"");
            ObjectNode outNode = Json.newObject();

            ArrayList<JsonNode> jsonNodes = new ArrayList<JsonNode>();
            while (! queue.isEmpty()) {
              jsonNodes.add(queue.poll());
            }
            outNode.put(""queuedMessages"", Json.toJson(jsonNodes));

            out.write(outNode);

            lastSent = System.currentTimeMillis();
            scheduled = false;
          }
        }, wait);
        scheduled = true;
      }
    } else {
      out.write(message);
      //System.out.println(""queue.size() = "" + queue.size());

      lastSent = System.currentTimeMillis();
    }
    */ out.write(message); }  public void close () { this.out.close(); } }  "
app/models/Translation.java,"package models;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.node.ObjectNode;
import play.db.ebean.Model;
import play.libs.Json;

import javax.persistence.*;
import java.io.Serializable;
import java.util.List;

@Entity
@Table(name = ""translations"")
public class Translation extends Model implements Serializable {
  @Id
  public Long id;

  public String html;

  @ManyToOne
  @JsonIgnore
  public Content content;

  @ManyToOne
  @JoinColumn(name = ""languages_id"")
  @JsonProperty(""language"")
  public Language language;

  @JsonIgnore
  public static Finder<Long, Translation> find = new Finder(Long.class, Translation.class);

  @JsonIgnore
  public static List<Translation> findAll() {
    return find.all();
  }

  @JsonIgnore
  public static Translation findById(Long id) {
    return find.where().eq(""id"", id).findUnique();
  }

  public Translation() {}

  public Translation(Translation t) {
    this.html = t.html;
    this.language = t.language;
  }

  public Long getId() {
    return id;
  }

  public void setId(Long id) {
    this.id = id;
  }

  public String getHtml() {
    return html;
  }

  public void setHtml(String html) {
    this.html = html;
  }

  public Content getContent() {
    return content;
  }

  public void setContent(Content content) {
    this.content = content;
  }

  public Language getLanguage() {
    return language;
  }

  public void setLanguage(Language language) {
    this.language = language;
  }

  @JsonIgnore
  public ObjectNode toJson() {
    ObjectNode translation = Json.newObject();
    translation.put(""id"", id);
    translation.put(""html"", html);
    translation.put(""language"", language.toJson());
    return translation;
  }

  @JsonIgnore
  public String toString() {
    return ""Translation("" + id + "")"";
  }
}
","package models; @Entity
@Table(name = ""translations"")
public class Translation extends Model implements Serializable { @Id
  public Long id; public String html; @ManyToOne
  @JsonIgnore
  public Content content; @ManyToOne
  @JoinColumn(name = ""languages_id"")
  @JsonProperty(""language"")
  public Language language; @JsonIgnore
  public static Finder<Long, Translation> find = new Finder(Long.class, Translation.class); @JsonIgnore
  public static List<Translation> findAll() { return find.all(); } @JsonIgnore
  public static Translation findById(Long id) { return find.where().eq(""id"", id).findUnique(); } public Translation() { } public Translation(Translation t) { this.html = t.html; this.language = t.language; } public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getHtml() { return html; } public void setHtml(String html) { this.html = html; } public Content getContent() { return content; } public void setContent(Content content) { this.content = content; } public Language getLanguage() { return language; } public void setLanguage(Language language) { this.language = language; } @JsonIgnore
  public ObjectNode toJson() { ObjectNode translation = Json.newObject(); translation.put(""id"", id); translation.put(""html"", html); translation.put(""language"", language.toJson()); return translation; } @JsonIgnore
  public String toString() { return ""Translation("" + id + "")""; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; @Entity
@Table(name = ""translations"")
public class Translation extends Model implements Serializable { @Id
  public Long id; public String html; @ManyToOne
  @JsonIgnore
  public Content content; @ManyToOne
  @JoinColumn(name = ""languages_id"")
  @JsonProperty(""language"")
  public Language language; @JsonIgnore
  public static Finder<Long, Translation> find = new Finder(Long.class, Translation.class); @JsonIgnore
  public static List<Translation> findAll() { return find.all(); } @JsonIgnore
  public static Translation findById(Long id) { return find.where().eq(""id"", id).findUnique(); } public Translation() { } public Translation(Translation t) { this.html = t.html; this.language = t.language; } public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getHtml() { return html; } public void setHtml(String html) { this.html = html; } public Content getContent() { return content; } public void setContent(Content content) { this.content = content; } public Language getLanguage() { return language; } public void setLanguage(Language language) { this.language = language; } @JsonIgnore
  public ObjectNode toJson() { ObjectNode translation = Json.newObject(); translation.put(""id"", id); translation.put(""html"", html); translation.put(""language"", language.toJson()); return translation; } @JsonIgnore
  public String toString() { return ""Translation("" + id + "")""; } } ","package models; 
import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.annotation.JsonProperty; import com.fasterxml.jackson.databind.node.ObjectNode; import play.db.ebean.Model; import play.libs.Json; 
import javax.persistence.*; import java.io.Serializable; import java.util.List;  @Entity
@Table(name = ""translations"")
public class Translation extends Model implements Serializable { @Id
  public Long id;  public String html;  @ManyToOne
  @JsonIgnore
  public Content content;  @ManyToOne
  @JoinColumn(name = ""languages_id"")
  @JsonProperty(""language"")
  public Language language;  @JsonIgnore
  public static Finder<Long, Translation> find = new Finder(Long.class, Translation.class);  @JsonIgnore
  public static List<Translation> findAll() { return find.all(); }  @JsonIgnore
  public static Translation findById(Long id) { return find.where().eq(""id"", id).findUnique(); }  public Translation() { }  public Translation(Translation t) { this.html = t.html; this.language = t.language; }  public Long getId() { return id; }  public void setId(Long id) { this.id = id; }  public String getHtml() { return html; }  public void setHtml(String html) { this.html = html; }  public Content getContent() { return content; }  public void setContent(Content content) { this.content = content; }  public Language getLanguage() { return language; }  public void setLanguage(Language language) { this.language = language; }  @JsonIgnore
  public ObjectNode toJson() { ObjectNode translation = Json.newObject(); translation.put(""id"", id); translation.put(""html"", html); translation.put(""language"", language.toJson()); return translation; }  @JsonIgnore
  public String toString() { return ""Translation("" + id + "")""; } }  "
app/models/User.java,"package models;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonValue;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.mindrot.jbcrypt.BCrypt;
import play.Logger;
import play.data.format.Formats;
import play.data.validation.Constraints;
import play.db.ebean.Model;
import play.libs.Json;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = ""users"")
public class User extends Model {

  @Id
  @Constraints.Required
  @Formats.NonEmpty
  public String email;

  @Constraints.Required
  public String name;

  @Constraints.Required
  public String password;

  public String uid;

  @OneToOne
  public Language defaultLanguage;

  /*
   * Currently role can be admin or amt_admin, should expand this to include experiment runners vs.
   * experiment designers.
   */
  public String role;

  @ManyToMany
  public List<Experiment> ownedExperiments = new ArrayList<Experiment>();

  @OneToOne
  public Experiment selectedExperiment;

  @Column(columnDefinition = ""text"")
  public String currentScript;

  public Long experimentInstanceId = -1L;

  @JsonIgnore
  public static Model.Finder<String, User> find = new Model.Finder(String.class, User.class);

  public static int findRowCount() {
    return find.findRowCount();
  }

  public static List<User> findAll() {
    return find.all();
  }

  public static User findByEmail(String email) {
    return find.where().eq(""email"", email).findUnique();
  }

  public static User findByUID(String uid) {
    return find.where().eq(""uid"", uid).findUnique();
  }

  public static User authenticate(String email, String password) {
    Logger.debug(""authenticate("" + email + "")"");
    User user = find.where()
        .eq(""email"", email)
        .findUnique();
    Logger.debug(""user: "" + user);
    if (user == null) {
      return null;
    }
    if (BCrypt.checkpw(password, user.password)) {
      return user;
    } else {
      return null;
    }
  }

  public void setExperimentInstanceId(Long experimentInstanceId) {
    this.experimentInstanceId = experimentInstanceId;
  }

  public void setSelectedExperiment(Experiment selectedExperiment) {
    this.selectedExperiment = selectedExperiment;
  }

  public Experiment getExperiment() {
    return selectedExperiment;
  }

  public Experiment getExperimentByName(String name) {
    for (Experiment e : ownedExperiments) {
      if (e.name.equals(name))
        return e;
    }
    return null;
  }

  @JsonValue
  public ObjectNode toJson() {
    ObjectNode breadboard = Json.newObject();
    ObjectNode user = Json.newObject();

    ArrayList<String> experimentNames = new ArrayList<String>();

    user.put(""email"", this.email);

    user.put(""defaultLanguage"", (this.defaultLanguage == null) ? null : this.defaultLanguage.toJson());

    //user.put(""experiments"", Json.toJson(experimentNames));
    ArrayNode experiments = user.putArray(""experiments"");
    for (Experiment experiment: ownedExperiments) {
      experiments.add(experiment.toJson());
    }

    if (selectedExperiment != null) {
      user.put(""selectedExperiment"", selectedExperiment.name);
    } else {
      Logger.debug(""selectedExperiment == null?"");
    }

    user.put(""currentScript"", currentScript);

    breadboard.put(""user"", user);

    if (selectedExperiment != null) {
      breadboard.put(""experiment"", selectedExperiment.toJson());
    }

    if (experimentInstanceId.equals(Experiment.TEST_INSTANCE_ID)) {
      breadboard.put(""experimentInstance"", selectedExperiment.getTestInstance().toJson());
    } else if (experimentInstanceId != null && experimentInstanceId != -1L) {
      ExperimentInstance ei = ExperimentInstance.findById(experimentInstanceId);
      Logger.debug(""experimentInstanceId = "" + experimentInstanceId.toString() + (ei == null ? "" is null"" : """"));
      if (ei != null) {
        breadboard.put(""experimentInstance"", ei.toJson());
      } else {
        experimentInstanceId = -1L;
        breadboard.put(""experimentInstance"", """");
      }
    } else {
      breadboard.put(""experimentInstance"", """");
    }

    return breadboard;
  }

  public String toString() {
    return ""User("" + email + "")"";
  }
}
","package models; @Entity
@Table(name = ""users"")
public class User extends Model { @Id
  @Constraints.Required
  @Formats.NonEmpty
  public String email; @Constraints.Required
  public String name; @Constraints.Required
  public String password; public String uid; @OneToOne
  public Language defaultLanguage; public String role; @ManyToMany
  public List<Experiment> ownedExperiments = new ArrayList<Experiment>(); @OneToOne
  public Experiment selectedExperiment; @Column(columnDefinition = ""text"")
  public String currentScript; public Long experimentInstanceId = -1L; @JsonIgnore
  public static Model.Finder<String, User> find = new Model.Finder(String.class, User.class); public static int findRowCount() { return find.findRowCount(); } public static List<User> findAll() { return find.all(); } public static User findByEmail(String email) { return find.where().eq(""email"", email).findUnique(); } public static User findByUID(String uid) { return find.where().eq(""uid"", uid).findUnique(); } public static User authenticate(String email, String password) { User user = find.where()
        .eq(""email"", email)
        .findUnique(); if (user == null) { return null; } if (BCrypt.checkpw(password, user.password)) { return user; } else { return null; } } public void setExperimentInstanceId(Long experimentInstanceId) { this.experimentInstanceId = experimentInstanceId; } public void setSelectedExperiment(Experiment selectedExperiment) { this.selectedExperiment = selectedExperiment; } public Experiment getExperiment() { return selectedExperiment; } public Experiment getExperimentByName(String name) { for (Experiment e : ownedExperiments) { if (e.name.equals(name))
        return e; } return null; } @JsonValue
  public ObjectNode toJson() { ObjectNode breadboard = Json.newObject(); ObjectNode user = Json.newObject(); ArrayList<String> experimentNames = new ArrayList<String>(); user.put(""email"", this.email); user.put(""defaultLanguage"", (this.defaultLanguage == null) ? null : this.defaultLanguage.toJson()); ArrayNode experiments = user.putArray(""experiments""); for (Experiment experiment: ownedExperiments) { experiments.add(experiment.toJson()); } if (selectedExperiment != null) { user.put(""selectedExperiment"", selectedExperiment.name); } else { } user.put(""currentScript"", currentScript); breadboard.put(""user"", user); if (selectedExperiment != null) { breadboard.put(""experiment"", selectedExperiment.toJson()); } if (experimentInstanceId.equals(Experiment.TEST_INSTANCE_ID)) { breadboard.put(""experimentInstance"", selectedExperiment.getTestInstance().toJson()); } else if (experimentInstanceId != null && experimentInstanceId != -1L) { ExperimentInstance ei = ExperimentInstance.findById(experimentInstanceId); if (ei != null) { breadboard.put(""experimentInstance"", ei.toJson()); } else { experimentInstanceId = -1L; breadboard.put(""experimentInstance"", """"); } } else { breadboard.put(""experimentInstance"", """"); } return breadboard; } public String toString() { return ""User("" + email + "")""; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; @Entity
@Table(name = ""users"")
public class User extends Model { @Id
  @Constraints.Required
  @Formats.NonEmpty
  public String email; @Constraints.Required
  public String name; @Constraints.Required
  public String password; public String uid; @OneToOne
  public Language defaultLanguage; public String role; @ManyToMany
  public List<Experiment> ownedExperiments = new ArrayList<Experiment>(); @OneToOne
  public Experiment selectedExperiment; @Column(columnDefinition = ""text"")
  public String currentScript; public Long experimentInstanceId = -1L; @JsonIgnore
  public static Model.Finder<String, User> find = new Model.Finder(String.class, User.class); public static int findRowCount() { return find.findRowCount(); } public static List<User> findAll() { return find.all(); } public static User findByEmail(String email) { return find.where().eq(""email"", email).findUnique(); } public static User findByUID(String uid) { return find.where().eq(""uid"", uid).findUnique(); } public static User authenticate(String email, String password) { <FILL_ME> User user = find.where()
        .eq(""email"", email)
        .findUnique(); <FILL_ME> if (user == null) { return null; } if (BCrypt.checkpw(password, user.password)) { return user; } else { <FILL_ME> return null; } } public void setExperimentInstanceId(Long experimentInstanceId) { this.experimentInstanceId = experimentInstanceId; } public void setSelectedExperiment(Experiment selectedExperiment) { this.selectedExperiment = selectedExperiment; } public Experiment getExperiment() { return selectedExperiment; } public Experiment getExperimentByName(String name) { for (Experiment e : ownedExperiments) { if (e.name.equals(name))
        return e; } return null; } @JsonValue
  public ObjectNode toJson() { ObjectNode breadboard = Json.newObject(); ObjectNode user = Json.newObject(); ArrayList<String> experimentNames = new ArrayList<String>(); user.put(""email"", this.email); user.put(""defaultLanguage"", (this.defaultLanguage == null) ? null : this.defaultLanguage.toJson()); ArrayNode experiments = user.putArray(""experiments""); for (Experiment experiment: ownedExperiments) { experiments.add(experiment.toJson()); } if (selectedExperiment != null) { user.put(""selectedExperiment"", selectedExperiment.name); } else { } user.put(""currentScript"", currentScript); breadboard.put(""user"", user); if (selectedExperiment != null) { breadboard.put(""experiment"", selectedExperiment.toJson()); } if (experimentInstanceId.equals(Experiment.TEST_INSTANCE_ID)) { breadboard.put(""experimentInstance"", selectedExperiment.getTestInstance().toJson()); } else if (experimentInstanceId != null && experimentInstanceId != -1L) { ExperimentInstance ei = ExperimentInstance.findById(experimentInstanceId); <FILL_ME> if (ei != null) { breadboard.put(""experimentInstance"", ei.toJson()); } else { experimentInstanceId = -1L; breadboard.put(""experimentInstance"", """"); } } else { breadboard.put(""experimentInstance"", """"); } return breadboard; } public String toString() { return ""User("" + email + "")""; } } ","package models; 
import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.annotation.JsonValue; import com.fasterxml.jackson.databind.node.ArrayNode; import com.fasterxml.jackson.databind.node.ObjectNode; import org.mindrot.jbcrypt.BCrypt; import play.Logger; import play.data.format.Formats; import play.data.validation.Constraints; import play.db.ebean.Model; import play.libs.Json; 
import javax.persistence.*; import java.util.ArrayList; import java.util.List;  @Entity
@Table(name = ""users"")
public class User extends Model {  @Id
  @Constraints.Required
  @Formats.NonEmpty
  public String email;  @Constraints.Required
  public String name;  @Constraints.Required
  public String password;  public String uid;  @OneToOne
  public Language defaultLanguage;  /*
   * Currently role can be admin or amt_admin, should expand this to include experiment runners vs.
   * experiment designers.
   */ public String role;  @ManyToMany
  public List<Experiment> ownedExperiments = new ArrayList<Experiment>();  @OneToOne
  public Experiment selectedExperiment;  @Column(columnDefinition = ""text"")
  public String currentScript;  public Long experimentInstanceId = -1L;  @JsonIgnore
  public static Model.Finder<String, User> find = new Model.Finder(String.class, User.class);  public static int findRowCount() { return find.findRowCount(); }  public static List<User> findAll() { return find.all(); }  public static User findByEmail(String email) { return find.where().eq(""email"", email).findUnique(); }  public static User findByUID(String uid) { return find.where().eq(""uid"", uid).findUnique(); }  public static User authenticate(String email, String password) { <FILL_ME> User user = find.where()
        .eq(""email"", email)
        .findUnique(); <FILL_ME> if (user == null) { return null; } if (BCrypt.checkpw(password, user.password)) { return user; } else { <FILL_ME> return null; } }  public void setExperimentInstanceId(Long experimentInstanceId) { this.experimentInstanceId = experimentInstanceId; }  public void setSelectedExperiment(Experiment selectedExperiment) { this.selectedExperiment = selectedExperiment; }  public Experiment getExperiment() { return selectedExperiment; }  public Experiment getExperimentByName(String name) { for (Experiment e : ownedExperiments) { if (e.name.equals(name))
        return e; } return null; }  @JsonValue
  public ObjectNode toJson() { ObjectNode breadboard = Json.newObject(); ObjectNode user = Json.newObject();  ArrayList<String> experimentNames = new ArrayList<String>();  user.put(""email"", this.email);  user.put(""defaultLanguage"", (this.defaultLanguage == null) ? null : this.defaultLanguage.toJson());  //user.put(""experiments"", Json.toJson(experimentNames)); ArrayNode experiments = user.putArray(""experiments""); for (Experiment experiment: ownedExperiments) { experiments.add(experiment.toJson()); }  if (selectedExperiment != null) { user.put(""selectedExperiment"", selectedExperiment.name); } else { }  user.put(""currentScript"", currentScript);  breadboard.put(""user"", user);  if (selectedExperiment != null) { breadboard.put(""experiment"", selectedExperiment.toJson()); }  if (experimentInstanceId.equals(Experiment.TEST_INSTANCE_ID)) { breadboard.put(""experimentInstance"", selectedExperiment.getTestInstance().toJson()); } else if (experimentInstanceId != null && experimentInstanceId != -1L) { ExperimentInstance ei = ExperimentInstance.findById(experimentInstanceId); <FILL_ME> if (ei != null) { breadboard.put(""experimentInstance"", ei.toJson()); } else { experimentInstanceId = -1L; breadboard.put(""experimentInstance"", """"); } } else { breadboard.put(""experimentInstance"", """"); }  return breadboard; }  public String toString() { return ""User("" + email + "")""; } }  "
app/models/UserDataInterface.java,"package models;

//basically just copy from groovy.util.ObserableMap and make it as interface
interface UserDataInterface {

  java.util.Map getContent();

  void clear();

  boolean containsKey(java.lang.Object key);

  boolean containsValue(java.lang.Object value);

  java.util.Set entrySet();

  boolean equals(java.lang.Object o);

  java.lang.Object get(java.lang.Object key);

  int hashCode();

  boolean isEmpty();

  java.util.Set keySet();

  java.lang.Object put(java.lang.Object key, java.lang.Object value);

  void putAll(java.util.Map map);

  java.lang.Object remove(java.lang.Object key);

  int size();

  int getSize();

  java.util.Collection values();

  void addPropertyChangeListener(java.beans.PropertyChangeListener listener);

  void addPropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener);

  java.beans.PropertyChangeListener[] getPropertyChangeListeners();

  java.beans.PropertyChangeListener[] getPropertyChangeListeners(java.lang.String propertyName);

  void removePropertyChangeListener(java.beans.PropertyChangeListener listener);

  void removePropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener);

  boolean hasListeners(java.lang.String propertyName);

}

","package models; interface UserDataInterface { java.util.Map getContent(); void clear(); boolean containsKey(java.lang.Object key); boolean containsValue(java.lang.Object value); java.util.Set entrySet(); boolean equals(java.lang.Object o); java.lang.Object get(java.lang.Object key); int hashCode(); boolean isEmpty(); java.util.Set keySet(); java.lang.Object put(java.lang.Object key, java.lang.Object value); void putAll(java.util.Map map); java.lang.Object remove(java.lang.Object key); int size(); int getSize(); java.util.Collection values(); void addPropertyChangeListener(java.beans.PropertyChangeListener listener); void addPropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener); java.beans.PropertyChangeListener[] getPropertyChangeListeners(); java.beans.PropertyChangeListener[] getPropertyChangeListeners(java.lang.String propertyName); void removePropertyChangeListener(java.beans.PropertyChangeListener listener); void removePropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener); boolean hasListeners(java.lang.String propertyName); }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; interface UserDataInterface { java.util.Map getContent(); void clear(); boolean containsKey(java.lang.Object key); boolean containsValue(java.lang.Object value); java.util.Set entrySet(); boolean equals(java.lang.Object o); java.lang.Object get(java.lang.Object key); int hashCode(); boolean isEmpty(); java.util.Set keySet(); java.lang.Object put(java.lang.Object key, java.lang.Object value); void putAll(java.util.Map map); java.lang.Object remove(java.lang.Object key); int size(); int getSize(); java.util.Collection values(); void addPropertyChangeListener(java.beans.PropertyChangeListener listener); void addPropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener); java.beans.PropertyChangeListener[] getPropertyChangeListeners(); java.beans.PropertyChangeListener[] getPropertyChangeListeners(java.lang.String propertyName); void removePropertyChangeListener(java.beans.PropertyChangeListener listener); void removePropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener); boolean hasListeners(java.lang.String propertyName); } ","package models;  //basically just copy from groovy.util.ObserableMap and make it as interface interface UserDataInterface {  java.util.Map getContent();  void clear();  boolean containsKey(java.lang.Object key);  boolean containsValue(java.lang.Object value);  java.util.Set entrySet();  boolean equals(java.lang.Object o);  java.lang.Object get(java.lang.Object key);  int hashCode();  boolean isEmpty();  java.util.Set keySet();  java.lang.Object put(java.lang.Object key, java.lang.Object value);  void putAll(java.util.Map map);  java.lang.Object remove(java.lang.Object key);  int size();  int getSize();  java.util.Collection values();  void addPropertyChangeListener(java.beans.PropertyChangeListener listener);  void addPropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener);  java.beans.PropertyChangeListener[] getPropertyChangeListeners();  java.beans.PropertyChangeListener[] getPropertyChangeListeners(java.lang.String propertyName);  void removePropertyChangeListener(java.beans.PropertyChangeListener listener);  void removePropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener);  boolean hasListeners(java.lang.String propertyName);  } 
 "
app/models/UserSettings.java,"package models;


import org.apache.commons.lang3.StringUtils;
import org.mindrot.jbcrypt.BCrypt;

public class UserSettings {

  public User user;
  public String email;
  public String currentPassword;
  public String newPassword;
  public String confirmPassword;

  public String validate() {
    if (StringUtils.isEmpty(email)) {
      return ""Email can't be empty"";
    }

    user = User.findByEmail(email);
    if (user == null) {
      return ""User is not found for the email:"" + email;
    }

    //TODO: better validation like regex?
    if (StringUtils.isEmpty(currentPassword)) {
      return ""Current password is missing"";
    }
    if (!BCrypt.checkpw(currentPassword, user.password)) {
      return ""Current password doesn't match user's password"";
    }
    if (StringUtils.isEmpty(newPassword)) {
      return ""New password is missing"";
    }
    if (!newPassword.equals(confirmPassword)) {
      return ""Confirm Password doesn't match the new password"";
    }
    return null;
  }


}
","package models; public class UserSettings { public User user; public String email; public String currentPassword; public String newPassword; public String confirmPassword; public String validate() { if (StringUtils.isEmpty(email)) { return ""Email can't be empty""; } user = User.findByEmail(email); if (user == null) { return ""User is not found for the email:"" + email; } if (StringUtils.isEmpty(currentPassword)) { return ""Current password is missing""; } if (!BCrypt.checkpw(currentPassword, user.password)) { return ""Current password doesn't match user's password""; } if (StringUtils.isEmpty(newPassword)) { return ""New password is missing""; } if (!newPassword.equals(confirmPassword)) { return ""Confirm Password doesn't match the new password""; } return null; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package models; public class UserSettings { public User user; public String email; public String currentPassword; public String newPassword; public String confirmPassword; public String validate() { if (StringUtils.isEmpty(email)) { return ""Email can't be empty""; } user = User.findByEmail(email); if (user == null) { return ""User is not found for the email:"" + email; } if (StringUtils.isEmpty(currentPassword)) { return ""Current password is missing""; } if (!BCrypt.checkpw(currentPassword, user.password)) { return ""Current password doesn't match user's password""; } if (StringUtils.isEmpty(newPassword)) { return ""New password is missing""; } if (!newPassword.equals(confirmPassword)) { return ""Confirm Password doesn't match the new password""; } return null; } } ","package models; 

import org.apache.commons.lang3.StringUtils; import org.mindrot.jbcrypt.BCrypt;  public class UserSettings {  public User user; public String email; public String currentPassword; public String newPassword; public String confirmPassword;  public String validate() { if (StringUtils.isEmpty(email)) { return ""Email can't be empty""; }  user = User.findByEmail(email); if (user == null) { return ""User is not found for the email:"" + email; }  //TODO: better validation like regex? if (StringUtils.isEmpty(currentPassword)) { return ""Current password is missing""; } if (!BCrypt.checkpw(currentPassword, user.password)) { return ""Current password doesn't match user's password""; } if (StringUtils.isEmpty(newPassword)) { return ""New password is missing""; } if (!newPassword.equals(confirmPassword)) { return ""Confirm Password doesn't match the new password""; } return null; } 
 }  "
app/security/Signature.java,"package security;

import org.apache.commons.codec.binary.Base64;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.security.SignatureException;

/**
 * This class defines common routines for generating
 * authentication signatures for AWS Platform requests.
 */

public class Signature {
  private static final String HMAC_SHA1_ALGORITHM = ""HmacSHA1"";

  /**
   * Computes RFC 2104-compliant HMAC signature.
   *
   * @param data The data to be signed.
   * @param key  The signing key.
   * @return The Base64-encoded RFC 2104-compliant HMAC signature.
   * @throws java.security.SignatureException when signature generation fails
   */
  public static String calculateRFC2104HMAC(String data, String key) throws java.security.SignatureException {
    String result;
    try {
      // get an hmac_sha1 key from the raw key bytes
      SecretKeySpec signingKey = new SecretKeySpec(key.getBytes(), HMAC_SHA1_ALGORITHM);

      // get an hmac_sha1 Mac instance and initialize with the signing key
      Mac mac = Mac.getInstance(HMAC_SHA1_ALGORITHM);
      mac.init(signingKey);

      // compute the hmac on input data bytes
      byte[] rawHmac = mac.doFinal(data.getBytes());

      // base64-encode the hmac
      result = Base64.encodeBase64String(rawHmac);
    } catch (Exception e) {
      throw new SignatureException(""Failed to generate HMAC : "" + e.getMessage());
    }
    return result;
  }

  public static String getSignature(String service, String operation, String timestamp, String secretKey) throws java.security.SignatureException {
    String data = new StringBuilder(service).append(operation).append(timestamp).toString();

    return calculateRFC2104HMAC(data, secretKey);
  }
}
","package security; public class Signature { private static final String HMAC_SHA1_ALGORITHM = ""HmacSHA1""; public static String calculateRFC2104HMAC(String data, String key) throws java.security.SignatureException { String result; try { SecretKeySpec signingKey = new SecretKeySpec(key.getBytes(), HMAC_SHA1_ALGORITHM); Mac mac = Mac.getInstance(HMAC_SHA1_ALGORITHM); mac.init(signingKey); byte[] rawHmac = mac.doFinal(data.getBytes()); result = Base64.encodeBase64String(rawHmac); } catch (Exception e) { throw new SignatureException(""Failed to generate HMAC : "" + e.getMessage()); } return result; } public static String getSignature(String service, String operation, String timestamp, String secretKey) throws java.security.SignatureException { String data = new StringBuilder(service).append(operation).append(timestamp).toString(); return calculateRFC2104HMAC(data, secretKey); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package security; public class Signature { private static final String HMAC_SHA1_ALGORITHM = ""HmacSHA1""; public static String calculateRFC2104HMAC(String data, String key) throws java.security.SignatureException { String result; try { SecretKeySpec signingKey = new SecretKeySpec(key.getBytes(), HMAC_SHA1_ALGORITHM); Mac mac = Mac.getInstance(HMAC_SHA1_ALGORITHM); mac.init(signingKey); byte[] rawHmac = mac.doFinal(data.getBytes()); result = Base64.encodeBase64String(rawHmac); } catch (Exception e) { throw new SignatureException(""Failed to generate HMAC : "" + e.getMessage()); } return result; } public static String getSignature(String service, String operation, String timestamp, String secretKey) throws java.security.SignatureException { String data = new StringBuilder(service).append(operation).append(timestamp).toString(); return calculateRFC2104HMAC(data, secretKey); } } ","package security; 
import org.apache.commons.codec.binary.Base64; 
import javax.crypto.Mac; import javax.crypto.spec.SecretKeySpec; import java.security.SignatureException;  /**
 * This class defines common routines for generating
 * authentication signatures for AWS Platform requests.
 */  public class Signature { private static final String HMAC_SHA1_ALGORITHM = ""HmacSHA1"";  /**
   * Computes RFC 2104-compliant HMAC signature.
   *
   * @param data The data to be signed.
   * @param key  The signing key.
   * @return The Base64-encoded RFC 2104-compliant HMAC signature.
   * @throws java.security.SignatureException when signature generation fails
   */ public static String calculateRFC2104HMAC(String data, String key) throws java.security.SignatureException { String result; try { // get an hmac_sha1 key from the raw key bytes SecretKeySpec signingKey = new SecretKeySpec(key.getBytes(), HMAC_SHA1_ALGORITHM);  // get an hmac_sha1 Mac instance and initialize with the signing key Mac mac = Mac.getInstance(HMAC_SHA1_ALGORITHM); mac.init(signingKey);  // compute the hmac on input data bytes byte[] rawHmac = mac.doFinal(data.getBytes());  // base64-encode the hmac result = Base64.encodeBase64String(rawHmac); } catch (Exception e) { throw new SignatureException(""Failed to generate HMAC : "" + e.getMessage()); } return result; }  public static String getSignature(String service, String operation, String timestamp, String secretKey) throws java.security.SignatureException { String data = new StringBuilder(service).append(operation).append(timestamp).toString();  return calculateRFC2104HMAC(data, secretKey); } }  "
