file_name,original_file_content,Input,Label,Output,OriginalWithPlaceholder
src/burp/BurpExtender.java,"package burp;

import burp.persistence.Persistor;

public class BurpExtender implements IBurpExtender {

    @Override
    public void registerExtenderCallbacks(IBurpExtenderCallbacks callbacks) {
        callbacks.setExtensionName(""Extractor"");

        // Create main extractor tab and an extractor, which actually does the work
        ExtractorMainTab extractorMainTab = new ExtractorMainTab(callbacks);
        Extractor extractor = new Extractor(extractorMainTab, callbacks);

        // Initialize the Persistor
        Persistor.init(extractorMainTab, callbacks);

        // Attempt to load a saved state
		Persistor.restoreExtractor();

        // Register Extractor as an HTTP listener
        callbacks.registerHttpListener(extractor);

        // Create menu item
        callbacks.registerContextMenuFactory(new ExtractorMenu(extractorMainTab));
    }
}","package burp; public class BurpExtender implements IBurpExtender { @Override
    public void registerExtenderCallbacks(IBurpExtenderCallbacks callbacks) { callbacks.setExtensionName(""Extractor""); ExtractorMainTab extractorMainTab = new ExtractorMainTab(callbacks); Extractor extractor = new Extractor(extractorMainTab, callbacks); Persistor.init(extractorMainTab, callbacks); Persistor.restoreExtractor(); callbacks.registerHttpListener(extractor); callbacks.registerContextMenuFactory(new ExtractorMenu(extractorMainTab)); } }",0 0 0 0 0 0 0 0 0 0 0 0,"package burp; public class BurpExtender implements IBurpExtender { @Override
    public void registerExtenderCallbacks(IBurpExtenderCallbacks callbacks) { callbacks.setExtensionName(""Extractor""); ExtractorMainTab extractorMainTab = new ExtractorMainTab(callbacks); Extractor extractor = new Extractor(extractorMainTab, callbacks); Persistor.init(extractorMainTab, callbacks); Persistor.restoreExtractor(); callbacks.registerHttpListener(extractor); callbacks.registerContextMenuFactory(new ExtractorMenu(extractorMainTab)); } }","package burp; 
import burp.persistence.Persistor;  public class BurpExtender implements IBurpExtender {  @Override
    public void registerExtenderCallbacks(IBurpExtenderCallbacks callbacks) { callbacks.setExtensionName(""Extractor"");  // Create main extractor tab and an extractor, which actually does the work ExtractorMainTab extractorMainTab = new ExtractorMainTab(callbacks); Extractor extractor = new Extractor(extractorMainTab, callbacks);  // Initialize the Persistor Persistor.init(extractorMainTab, callbacks);  // Attempt to load a saved state Persistor.restoreExtractor();  // Register Extractor as an HTTP listener callbacks.registerHttpListener(extractor);  // Create menu item callbacks.registerContextMenuFactory(new ExtractorMenu(extractorMainTab)); } }"
src/burp/ButtonTabComponent.java,"package burp;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class ButtonTabComponent extends JPanel {

    private ExtractorMainTab extractorMainTab;
    private int tabNum;
    public ButtonTabComponent(ExtractorMainTab extractorMainTab, int tabNum) {
        super(new FlowLayout(FlowLayout.LEFT, 0, 0));
        this.extractorMainTab = extractorMainTab;
        this.tabNum = tabNum;

        setOpaque(false);
        //make JLabel read titles from JTabbedPane
        JLabel label = new JLabel(Integer.toString(tabNum));
        add(label);
        //add more space between the label and the button
        label.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 5));
        //tab button
        JButton button = new TabButton();
        add(button);
}

    private class TabButton extends JButton implements ActionListener {

        public TabButton() {
            int size = 15;
            setPreferredSize(new Dimension(size, size));
            setToolTipText(""close this tab"");
            setText(""x"");
            //Make it transparent
            setContentAreaFilled(false);
            //No need to be focusable
            setFocusable(false);
            setBorder(BorderFactory.createEtchedBorder());
            setBorderPainted(false);
            //Making nice rollover effect
            //we use the same listener for all buttons
            addMouseListener(buttonMouseListener);
            setRolloverEnabled(true);
            //Close the proper tab by clicking the button
            addActionListener(this);
        }

        @Override
        public void actionPerformed(ActionEvent e) {
            int index = extractorMainTab.getIndexOfTabComponent(ButtonTabComponent.this);
            if (index != -1) {
                extractorMainTab.removeTab(index);
                extractorMainTab.removeExtractor(tabNum);
                ExtractorMainTab.tabsRemoved++;
            }
        }
    }

    private final static MouseListener buttonMouseListener = new MouseAdapter() {
        public void mouseEntered(MouseEvent e) {
            Component component = e.getComponent();
            if (component instanceof AbstractButton) {
                AbstractButton button = (AbstractButton) component;
                button.setBorderPainted(true);
            }
        }

        public void mouseExited(MouseEvent e) {
            Component component = e.getComponent();
            if (component instanceof AbstractButton) {
                AbstractButton button = (AbstractButton) component;
                button.setBorderPainted(false);
            }
        }
    };
}
","package burp; public class ButtonTabComponent extends JPanel { private ExtractorMainTab extractorMainTab; private int tabNum; public ButtonTabComponent(ExtractorMainTab extractorMainTab, int tabNum) { super(new FlowLayout(FlowLayout.LEFT, 0, 0)); this.extractorMainTab = extractorMainTab; this.tabNum = tabNum; setOpaque(false); JLabel label = new JLabel(Integer.toString(tabNum)); add(label); label.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 5)); JButton button = new TabButton(); add(button); } private class TabButton extends JButton implements ActionListener { public TabButton() { int size = 15; setPreferredSize(new Dimension(size, size)); setToolTipText(""close this tab""); setText(""x""); setContentAreaFilled(false); setFocusable(false); setBorder(BorderFactory.createEtchedBorder()); setBorderPainted(false); addMouseListener(buttonMouseListener); setRolloverEnabled(true); addActionListener(this); } @Override
        public void actionPerformed(ActionEvent e) { int index = extractorMainTab.getIndexOfTabComponent(ButtonTabComponent.this); if (index != -1) { extractorMainTab.removeTab(index); extractorMainTab.removeExtractor(tabNum); ExtractorMainTab.tabsRemoved++; } } } private final static MouseListener buttonMouseListener = new MouseAdapter() { public void mouseEntered(MouseEvent e) { Component component = e.getComponent(); if (component instanceof AbstractButton) { AbstractButton button = (AbstractButton) component; button.setBorderPainted(true); } } public void mouseExited(MouseEvent e) { Component component = e.getComponent(); if (component instanceof AbstractButton) { AbstractButton button = (AbstractButton) component; button.setBorderPainted(false); } } } ; }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package burp; public class ButtonTabComponent extends JPanel { private ExtractorMainTab extractorMainTab; private int tabNum; public ButtonTabComponent(ExtractorMainTab extractorMainTab, int tabNum) { super(new FlowLayout(FlowLayout.LEFT, 0, 0)); this.extractorMainTab = extractorMainTab; this.tabNum = tabNum; setOpaque(false); JLabel label = new JLabel(Integer.toString(tabNum)); add(label); label.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 5)); JButton button = new TabButton(); add(button); } private class TabButton extends JButton implements ActionListener { public TabButton() { int size = 15; setPreferredSize(new Dimension(size, size)); setToolTipText(""close this tab""); setText(""x""); setContentAreaFilled(false); setFocusable(false); setBorder(BorderFactory.createEtchedBorder()); setBorderPainted(false); addMouseListener(buttonMouseListener); setRolloverEnabled(true); addActionListener(this); } @Override
        public void actionPerformed(ActionEvent e) { int index = extractorMainTab.getIndexOfTabComponent(ButtonTabComponent.this); if (index != -1) { extractorMainTab.removeTab(index); extractorMainTab.removeExtractor(tabNum); ExtractorMainTab.tabsRemoved++; } } } private final static MouseListener buttonMouseListener = new MouseAdapter() { public void mouseEntered(MouseEvent e) { Component component = e.getComponent(); if (component instanceof AbstractButton) { AbstractButton button = (AbstractButton) component; button.setBorderPainted(true); } } public void mouseExited(MouseEvent e) { Component component = e.getComponent(); if (component instanceof AbstractButton) { AbstractButton button = (AbstractButton) component; button.setBorderPainted(false); } } } ; } ","package burp; 
import javax.swing.*; import java.awt.*; import java.awt.event.*;  public class ButtonTabComponent extends JPanel {  private ExtractorMainTab extractorMainTab; private int tabNum; public ButtonTabComponent(ExtractorMainTab extractorMainTab, int tabNum) { super(new FlowLayout(FlowLayout.LEFT, 0, 0)); this.extractorMainTab = extractorMainTab; this.tabNum = tabNum;  setOpaque(false); //make JLabel read titles from JTabbedPane JLabel label = new JLabel(Integer.toString(tabNum)); add(label); //add more space between the label and the button label.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 5)); //tab button JButton button = new TabButton(); add(button); }  private class TabButton extends JButton implements ActionListener {  public TabButton() { int size = 15; setPreferredSize(new Dimension(size, size)); setToolTipText(""close this tab""); setText(""x""); //Make it transparent setContentAreaFilled(false); //No need to be focusable setFocusable(false); setBorder(BorderFactory.createEtchedBorder()); setBorderPainted(false); //Making nice rollover effect //we use the same listener for all buttons addMouseListener(buttonMouseListener); setRolloverEnabled(true); //Close the proper tab by clicking the button addActionListener(this); }  @Override
        public void actionPerformed(ActionEvent e) { int index = extractorMainTab.getIndexOfTabComponent(ButtonTabComponent.this); if (index != -1) { extractorMainTab.removeTab(index); extractorMainTab.removeExtractor(tabNum); ExtractorMainTab.tabsRemoved++; } } }  private final static MouseListener buttonMouseListener = new MouseAdapter() { public void mouseEntered(MouseEvent e) { Component component = e.getComponent(); if (component instanceof AbstractButton) { AbstractButton button = (AbstractButton) component; button.setBorderPainted(true); } }  public void mouseExited(MouseEvent e) { Component component = e.getComponent(); if (component instanceof AbstractButton) { AbstractButton button = (AbstractButton) component; button.setBorderPainted(false); } } } ; }  "
src/burp/Extractor.java,"package burp;

import java.io.PrintWriter;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

public class Extractor implements IHttpListener {
	private ExtractorMainTab extractorMainTab;
	private IExtensionHelpers helpers;
	private Logger logger;

	public Extractor(ExtractorMainTab extractorMainTab, IBurpExtenderCallbacks callbacks) {
		this.extractorMainTab = extractorMainTab;
		this.helpers = callbacks.getHelpers();

		this.logger = new Logger(new PrintWriter(callbacks.getStdout(), true));
		Logger.setLogLevel(Logger.INFO);
	}

	@Override
	public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo) {
		if (messageIsRequest) {
			logger.debug(""Processing request..."");
			byte[] requestBytes = messageInfo.getRequest();
			String request = this.helpers.bytesToString(requestBytes);

			// Loop over each tab to perform whatever replacement is necessary
			String extractedData;
			boolean edited = false;
			for (ExtractorTab extractorTab : this.extractorMainTab.getExtractorTabs()) {

				// Determine if this message is in scope, and the user wants requests edited at this time
				URL url = this.helpers.analyzeRequest(messageInfo.getHttpService(), requestBytes).getUrl();
				if (extractorTab.requestIsInScope(url,
						messageInfo.getHttpService().getHost(),
						toolFlag) &&
						extractorTab.shouldModifyRequests()) {
					logger.debug(""Request is in scope and Extractor tab is active."");

					// Check if we have the necessary components to do replacement
					String[] requestSelectionRegex = extractorTab.getRequestSelectionRegex();
					extractedData = extractorTab.getDataToInsert();
					if (!extractedData.equals("""")
							&& !requestSelectionRegex[0].equals("""")
							&& !requestSelectionRegex[1].equals("""")) {
						logger.debug(""Attempting replacement..."");
						int[] selectionBounds = Utils.getSelectionBounds(request, requestSelectionRegex[0], requestSelectionRegex[1]);
						if (selectionBounds != null) {
							logger.debug(""Found a match"");
							request = request.substring(0, selectionBounds[0])
									+ extractedData
									+ request.substring(selectionBounds[1], request.length());
							edited = true;
							logger.debug(""Finished replacement"");
						}
					}
				}
			}
			if (edited) {
				messageInfo.setRequest(request.getBytes());
				IRequestInfo reqInfo = this.helpers.analyzeRequest(request.getBytes());
				List<String> newHeaders = new ArrayList<String>();
				for (String header : reqInfo.getHeaders()) {
					if (!header.toLowerCase().startsWith(""content-length"")) {
						newHeaders.add(header);
					}
				}
				int contentLength = request.getBytes().length - reqInfo.getBodyOffset();
				newHeaders.add(""Content-Length: "" + Integer.toString(contentLength));
				byte[] newRequest = this.helpers.buildHttpMessage(newHeaders, Arrays.copyOfRange(request.getBytes(), reqInfo.getBodyOffset(), request.getBytes().length));
				messageInfo.setRequest(newRequest);
			}
		} else if (!messageIsRequest) {

			logger.debug(""Processing response..."");
			byte[] responseBytes = messageInfo.getResponse();
			String response = this.helpers.bytesToString(responseBytes);

			// Loop over each tab, and grab whatever data item is necessary
			for (ExtractorTab extractorTab : this.extractorMainTab.getExtractorTabs()) {

				// Check if message is in scope
				URL url = this.helpers.analyzeRequest(messageInfo.getHttpService(), messageInfo.getRequest()).getUrl();
				if (extractorTab.responseIsInScope(url,
						messageInfo.getHttpService().getHost(),
						toolFlag)) {
					logger.debug(""Response is in scope."");

					String[] responseSelectionRegex = extractorTab.getResponseSelectionRegex();

					// Grab text from response
					if (responseSelectionRegex[0] != """" && responseSelectionRegex[1] != """") {
						int[] selectionBounds = Utils.getSelectionBounds(response, responseSelectionRegex[0], responseSelectionRegex[1]);
						if (selectionBounds != null) {
							logger.debug(""Found a match"");
							extractorTab.setDataToInsert(response.substring(selectionBounds[0], selectionBounds[1]));
						}
					} else {
						logger.debug(""Before and after regex not defined"");
					}
				}
			}
		}
	}
}
","package burp; public class Extractor implements IHttpListener { private ExtractorMainTab extractorMainTab; private IExtensionHelpers helpers; private Logger logger; public Extractor(ExtractorMainTab extractorMainTab, IBurpExtenderCallbacks callbacks) { this.extractorMainTab = extractorMainTab; this.helpers = callbacks.getHelpers(); this.logger = new Logger(new PrintWriter(callbacks.getStdout(), true)); Logger.setLogLevel(Logger.INFO); } @Override
	public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo) { if (messageIsRequest) { byte[] requestBytes = messageInfo.getRequest(); String request = this.helpers.bytesToString(requestBytes); String extractedData; boolean edited = false; for (ExtractorTab extractorTab : this.extractorMainTab.getExtractorTabs()) { URL url = this.helpers.analyzeRequest(messageInfo.getHttpService(), requestBytes).getUrl(); if (extractorTab.requestIsInScope(url,
						messageInfo.getHttpService().getHost(),
						toolFlag) &&
						extractorTab.shouldModifyRequests()) { String[] requestSelectionRegex = extractorTab.getRequestSelectionRegex(); extractedData = extractorTab.getDataToInsert(); if (!extractedData.equals("""")
							&& !requestSelectionRegex[0].equals("""")
							&& !requestSelectionRegex[1].equals("""")) { int[] selectionBounds = Utils.getSelectionBounds(request, requestSelectionRegex[0], requestSelectionRegex[1]); if (selectionBounds != null) { request = request.substring(0, selectionBounds[0])
									+ extractedData
									+ request.substring(selectionBounds[1], request.length()); edited = true; } } } } if (edited) { messageInfo.setRequest(request.getBytes()); IRequestInfo reqInfo = this.helpers.analyzeRequest(request.getBytes()); List<String> newHeaders = new ArrayList<String>(); for (String header : reqInfo.getHeaders()) { if (!header.toLowerCase().startsWith(""content-length"")) { newHeaders.add(header); } } int contentLength = request.getBytes().length - reqInfo.getBodyOffset(); newHeaders.add(""Content-Length: "" + Integer.toString(contentLength)); byte[] newRequest = this.helpers.buildHttpMessage(newHeaders, Arrays.copyOfRange(request.getBytes(), reqInfo.getBodyOffset(), request.getBytes().length)); messageInfo.setRequest(newRequest); } } else if (!messageIsRequest) { byte[] responseBytes = messageInfo.getResponse(); String response = this.helpers.bytesToString(responseBytes); for (ExtractorTab extractorTab : this.extractorMainTab.getExtractorTabs()) { URL url = this.helpers.analyzeRequest(messageInfo.getHttpService(), messageInfo.getRequest()).getUrl(); if (extractorTab.responseIsInScope(url,
						messageInfo.getHttpService().getHost(),
						toolFlag)) { String[] responseSelectionRegex = extractorTab.getResponseSelectionRegex(); if (responseSelectionRegex[0] != """" && responseSelectionRegex[1] != """") { int[] selectionBounds = Utils.getSelectionBounds(response, responseSelectionRegex[0], responseSelectionRegex[1]); if (selectionBounds != null) { extractorTab.setDataToInsert(response.substring(selectionBounds[0], selectionBounds[1])); } } else { } } } } } }",0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0,"package burp; public class Extractor implements IHttpListener { private ExtractorMainTab extractorMainTab; private IExtensionHelpers helpers; private Logger logger; public Extractor(ExtractorMainTab extractorMainTab, IBurpExtenderCallbacks callbacks) { this.extractorMainTab = extractorMainTab; this.helpers = callbacks.getHelpers(); this.logger = new Logger(new PrintWriter(callbacks.getStdout(), true)); Logger.setLogLevel(Logger.INFO); } @Override
	public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo) { if (messageIsRequest) { <FILL_ME> byte[] requestBytes = messageInfo.getRequest(); String request = this.helpers.bytesToString(requestBytes); String extractedData; boolean edited = false; for (ExtractorTab extractorTab : this.extractorMainTab.getExtractorTabs()) { URL url = this.helpers.analyzeRequest(messageInfo.getHttpService(), requestBytes).getUrl(); if (extractorTab.requestIsInScope(url,
						messageInfo.getHttpService().getHost(),
						toolFlag) &&
						extractorTab.shouldModifyRequests()) { <FILL_ME> String[] requestSelectionRegex = extractorTab.getRequestSelectionRegex(); extractedData = extractorTab.getDataToInsert(); if (!extractedData.equals("""")
							&& !requestSelectionRegex[0].equals("""")
							&& !requestSelectionRegex[1].equals("""")) { <FILL_ME> int[] selectionBounds = Utils.getSelectionBounds(request, requestSelectionRegex[0], requestSelectionRegex[1]); if (selectionBounds != null) { <FILL_ME> <FILL_ME> request = request.substring(0, selectionBounds[0])
									+ extractedData
									+ request.substring(selectionBounds[1], request.length()); edited = true; <FILL_ME> } } } } if (edited) { messageInfo.setRequest(request.getBytes()); IRequestInfo reqInfo = this.helpers.analyzeRequest(request.getBytes()); List<String> newHeaders = new ArrayList<String>(); for (String header : reqInfo.getHeaders()) { if (!header.toLowerCase().startsWith(""content-length"")) { newHeaders.add(header); } } int contentLength = request.getBytes().length - reqInfo.getBodyOffset(); newHeaders.add(""Content-Length: "" + Integer.toString(contentLength)); byte[] newRequest = this.helpers.buildHttpMessage(newHeaders, Arrays.copyOfRange(request.getBytes(), reqInfo.getBodyOffset(), request.getBytes().length)); messageInfo.setRequest(newRequest); } } else if (!messageIsRequest) { <FILL_ME> byte[] responseBytes = messageInfo.getResponse(); String response = this.helpers.bytesToString(responseBytes); for (ExtractorTab extractorTab : this.extractorMainTab.getExtractorTabs()) { URL url = this.helpers.analyzeRequest(messageInfo.getHttpService(), messageInfo.getRequest()).getUrl(); if (extractorTab.responseIsInScope(url,
						messageInfo.getHttpService().getHost(),
						toolFlag)) { <FILL_ME> String[] responseSelectionRegex = extractorTab.getResponseSelectionRegex(); if (responseSelectionRegex[0] != """" && responseSelectionRegex[1] != """") { int[] selectionBounds = Utils.getSelectionBounds(response, responseSelectionRegex[0], responseSelectionRegex[1]); if (selectionBounds != null) { extractorTab.setDataToInsert(response.substring(selectionBounds[0], selectionBounds[1])); } } else { <FILL_ME> } } } } } } ","package burp; 
import java.io.PrintWriter; import java.net.URL; import java.nio.charset.StandardCharsets; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Locale;  public class Extractor implements IHttpListener { private ExtractorMainTab extractorMainTab; private IExtensionHelpers helpers; private Logger logger;  public Extractor(ExtractorMainTab extractorMainTab, IBurpExtenderCallbacks callbacks) { this.extractorMainTab = extractorMainTab; this.helpers = callbacks.getHelpers();  this.logger = new Logger(new PrintWriter(callbacks.getStdout(), true)); Logger.setLogLevel(Logger.INFO); }  @Override
	public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo) { if (messageIsRequest) { <FILL_ME> byte[] requestBytes = messageInfo.getRequest(); String request = this.helpers.bytesToString(requestBytes);  // Loop over each tab to perform whatever replacement is necessary String extractedData; boolean edited = false; for (ExtractorTab extractorTab : this.extractorMainTab.getExtractorTabs()) {  // Determine if this message is in scope, and the user wants requests edited at this time URL url = this.helpers.analyzeRequest(messageInfo.getHttpService(), requestBytes).getUrl(); if (extractorTab.requestIsInScope(url,
						messageInfo.getHttpService().getHost(),
						toolFlag) &&
						extractorTab.shouldModifyRequests()) { <FILL_ME>  // Check if we have the necessary components to do replacement String[] requestSelectionRegex = extractorTab.getRequestSelectionRegex(); extractedData = extractorTab.getDataToInsert(); if (!extractedData.equals("""")
							&& !requestSelectionRegex[0].equals("""")
							&& !requestSelectionRegex[1].equals("""")) { <FILL_ME> int[] selectionBounds = Utils.getSelectionBounds(request, requestSelectionRegex[0], requestSelectionRegex[1]); if (selectionBounds != null) { <FILL_ME> <FILL_ME> request = request.substring(0, selectionBounds[0])
									+ extractedData
									+ request.substring(selectionBounds[1], request.length()); edited = true; <FILL_ME> } } } } if (edited) { messageInfo.setRequest(request.getBytes()); IRequestInfo reqInfo = this.helpers.analyzeRequest(request.getBytes()); List<String> newHeaders = new ArrayList<String>(); for (String header : reqInfo.getHeaders()) { if (!header.toLowerCase().startsWith(""content-length"")) { newHeaders.add(header); } } int contentLength = request.getBytes().length - reqInfo.getBodyOffset(); newHeaders.add(""Content-Length: "" + Integer.toString(contentLength)); byte[] newRequest = this.helpers.buildHttpMessage(newHeaders, Arrays.copyOfRange(request.getBytes(), reqInfo.getBodyOffset(), request.getBytes().length)); messageInfo.setRequest(newRequest); } } else if (!messageIsRequest) { <FILL_ME>  byte[] responseBytes = messageInfo.getResponse(); String response = this.helpers.bytesToString(responseBytes);  // Loop over each tab, and grab whatever data item is necessary for (ExtractorTab extractorTab : this.extractorMainTab.getExtractorTabs()) {  // Check if message is in scope URL url = this.helpers.analyzeRequest(messageInfo.getHttpService(), messageInfo.getRequest()).getUrl(); if (extractorTab.responseIsInScope(url,
						messageInfo.getHttpService().getHost(),
						toolFlag)) { <FILL_ME>  String[] responseSelectionRegex = extractorTab.getResponseSelectionRegex();  // Grab text from response if (responseSelectionRegex[0] != """" && responseSelectionRegex[1] != """") { int[] selectionBounds = Utils.getSelectionBounds(response, responseSelectionRegex[0], responseSelectionRegex[1]); if (selectionBounds != null) { extractorTab.setDataToInsert(response.substring(selectionBounds[0], selectionBounds[1])); } } else { <FILL_ME> } } } } } }  "
src/burp/ExtractorEditor.java,"package burp;

import burp.persistence.InScopeTools;
import burp.persistence.Persistor;
import burp.persistence.RequestResponseState;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.*;
import java.awt.event.*;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.HashMap;

public class ExtractorEditor {
	private IExtensionHelpers helpers;
	private JPanel pane;
	private ITextEditor textSelector;
	private HashMap<Integer, ToolMenuItem> toolSelectors;
	private ToolMenuItem allTools;
	private JRadioButton useScope;
	private JRadioButton useCustomHost;
	private JTextField targetHost;
	private JCheckBox regexCheckBox;
	private JTextField beforeRegex;
	private JTextField afterRegex;
	private boolean keyListenerSet;
	private final int SELECTION_BUFFER = 15;
	private Logger logger;

	public ExtractorEditor(final IBurpExtenderCallbacks callbacks) {
		this.pane = new JPanel();
		this.helpers = callbacks.getHelpers();
		this.logger = new Logger(new PrintWriter(callbacks.getStdout(), true));
		this.pane.setLayout(new GridBagLayout());

		// Add buttons to panel
		addButtons(this.pane);

		// Add text fields and labels to panel
		addTextFields(this.pane);

		// Add Burp response editor to panel
		addTextEditor(this.pane, callbacks);
	}

	// Add all buttons to editor
	private void addButtons(JPanel pane) {
		JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));

		// Create tool selection
		toolSelectors = new HashMap<Integer, ToolMenuItem>();
		JButton toolSelectionBar = new JButton(""Select in-scope tools"");
		JPopupMenu toolSelection = new JPopupMenu();
		this.allTools = new ToolMenuItem(""All"", true);
		toolSelection.add(this.allTools);
		ToolMenuItem proxyTool = new ToolMenuItem(""Proxy"", true);
		toolSelectors.put(IBurpExtenderCallbacks.TOOL_PROXY, proxyTool);
		toolSelection.add(proxyTool);
		ToolMenuItem scannerTool = new ToolMenuItem(""Scanner"", true);
		toolSelectors.put(IBurpExtenderCallbacks.TOOL_SCANNER, scannerTool);
		toolSelection.add(scannerTool);
		ToolMenuItem intruderTool = new ToolMenuItem(""Intruder"", true);
		toolSelectors.put(IBurpExtenderCallbacks.TOOL_INTRUDER, intruderTool);
		toolSelection.add(intruderTool);
		ToolMenuItem repeater = new ToolMenuItem(""Repeater"", true);
		toolSelectors.put(IBurpExtenderCallbacks.TOOL_REPEATER, repeater);
		toolSelection.add(repeater);
		ToolMenuItem extender = new ToolMenuItem(""Extender"", true);
		toolSelectors.put(IBurpExtenderCallbacks.TOOL_EXTENDER, extender);
		toolSelection.add(extender);
		toolSelectionBar.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				toolSelection.show(toolSelectionBar, 0, toolSelectionBar.getHeight());
			}
		});
		buttonPanel.add(toolSelectionBar);

		// Create button for testing regex
		JButton testRegexButton = new JButton(""Test defined selection"");
		testRegexButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				String matchResult = getTestRegexMatch();
				JPopupMenu popup = new JPopupMenu();
				JPanel menuPanel = new JPanel();
				JLabel contents = new JLabel();
				if (matchResult == null) {
					contents.setText(""Did not find a match for the defined start and end regex!"");
				} else {
					contents.setText(""Found match: "" + matchResult);
				}
				contents.setBorder(BorderFactory.createEmptyBorder(0,4,0,4));
				menuPanel.setOpaque(false);
				menuPanel.add(contents);
				popup.add(menuPanel);
				popup.show(testRegexButton, 0, testRegexButton.getHeight());
			}
		});
		buttonPanel.add(testRegexButton);

		GridBagConstraints constraints = new GridBagConstraints();
		constraints.gridx = 0;
		constraints.gridy = 0;
		constraints.gridwidth = 4;
		constraints.fill = GridBagConstraints.HORIZONTAL;
		pane.add(buttonPanel, constraints);
	}

	// Add our custom text editor
	private void addTextEditor(JPanel pane, IBurpExtenderCallbacks callbacks) {
		GridBagConstraints constraints = new GridBagConstraints();

		this.textSelector = callbacks.createTextEditor();
		this.textSelector.setEditable(true);
		JPanel panel = new JPanel(new GridBagLayout());
		constraints.gridx = 0;
		constraints.gridy = 0;
		constraints.weightx = 1;
		constraints.weighty = 1;
		constraints.fill = GridBagConstraints.BOTH;
		panel.add(this.textSelector.getComponent(), constraints);

		Border header = BorderFactory.createMatteBorder(4,0,0,0, Color.LIGHT_GRAY);
		panel.setBorder(header);

		constraints.gridx = 0;
		constraints.gridy = 4;
		constraints.gridwidth = 4;
		constraints.fill = GridBagConstraints.BOTH;
		constraints.weighty = 1;
		pane.add(panel, constraints);

		// This is used to select the focused component for an extractor editor.
		KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager();

		// Create mouse listeners for message editor
		this.textSelector.getComponent().addMouseListener(new MouseAdapter() {
			@Override
			public void mouseReleased(MouseEvent e) {
				// I never figured out how to get focus on the textEditor component to set keyListeners,
				// so just find out what is in focus when we click inside the editor and set a key listener on that.
				if (!keyListenerSet) {
					keyListenerSet = true;
					manager.getFocusOwner().addKeyListener(new KeyListener() {
						@Override
						public void keyTyped(KeyEvent e) {
						}

						@Override
						public void keyPressed(KeyEvent e) {
						}

						@Override
						public void keyReleased(KeyEvent e) {
							String [] selectionRegex = buildSelectionRegex();
							if (selectionRegex != null) {
								beforeRegex.setText(selectionRegex[0]);
								afterRegex.setText(selectionRegex[1]);
							}
						}
					});
				}
				String [] selectionRegex = buildSelectionRegex();
				if (selectionRegex != null) {
					beforeRegex.setText(selectionRegex[0]);
					afterRegex.setText(selectionRegex[1]);
				}
			}
		});
	}

	// Add text fields and related labels
	private void addTextFields(JPanel pane) {
		GridBagConstraints constraints = new GridBagConstraints();

		// Add label for target host
		JPanel targetPanel = new JPanel(new GridBagLayout());
		GridBagConstraints targetConstraints = new GridBagConstraints();

		// Add radio button for scope
		this.useScope = new JRadioButton(""Use suite scope  "");
		this.useScope.addItemListener(new ItemListener() {
			@Override
			public void itemStateChanged(ItemEvent e) {
				Persistor.persistExtractor();
			}
		});
		targetConstraints.gridx = 0;
		targetPanel.add(this.useScope, targetConstraints);

		// Add radio button for target host
		this.useCustomHost = new JRadioButton(""Use specified target host: "");
		targetConstraints.gridx += 1;
		targetPanel.add(this.useCustomHost, targetConstraints);

		// Create button group and select suite scope by default
		ButtonGroup scopeSelection = new ButtonGroup();
		scopeSelection.add(this.useScope);
		scopeSelection.add(this.useCustomHost);
		this.useScope.setSelected(true);

		// Add text field for target host
		this.targetHost = new JTextField();
		this.targetHost.getDocument().addDocumentListener(new DocumentListener() {
			@Override
			public void insertUpdate(DocumentEvent e) {
				Persistor.persistExtractor();

			}

			@Override
			public void removeUpdate(DocumentEvent e) {
				Persistor.persistExtractor();
			}

			@Override
			public void changedUpdate(DocumentEvent e) {
				Persistor.persistExtractor();
			}
		});
		targetConstraints.gridx += 1;
		targetConstraints.weightx = 1;
		targetConstraints.fill = GridBagConstraints.HORIZONTAL;
		targetPanel.add(this.targetHost, targetConstraints);

		// Add regex checkBox
		this.regexCheckBox = new JCheckBox(""Regex"");
		this.regexCheckBox.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				Persistor.persistExtractor();
			}
		});
		targetConstraints.gridx += 1;
		targetConstraints.weightx = 0;
		targetConstraints.fill = GridBagConstraints.NONE;
		targetPanel.add(this.regexCheckBox, targetConstraints);

		constraints.gridx = 0;
		constraints.gridwidth = 4;
		constraints.gridy = 1;
		constraints.fill = GridBagConstraints.HORIZONTAL;
		this.pane.add(targetPanel, constraints);

		// Add label for beforeRegex
		JLabel regexLabel = new JLabel(""Before Regex: "");
		constraints.gridx = 0;
		constraints.gridwidth = 1;
		constraints.gridy = 2;
		constraints.fill = GridBagConstraints.NONE;
		constraints.weightx = 0;
		this.pane.add(regexLabel, constraints);

		// Add text field for beforeRegex
		this.beforeRegex = new JTextField();
		this.beforeRegex.getDocument().addDocumentListener(new DocumentListener() {
			@Override
			public void insertUpdate(DocumentEvent e) {
				Persistor.persistExtractor();
			}

			@Override
			public void removeUpdate(DocumentEvent e) {
				Persistor.persistExtractor();
			}

			@Override
			public void changedUpdate(DocumentEvent e) {
				Persistor.persistExtractor();
			}
		});
		constraints.gridx = 1;
		constraints.gridy = 2;
		constraints.fill = GridBagConstraints.HORIZONTAL;
		constraints.weightx = 1;
		this.pane.add(this.beforeRegex, constraints);

		// Add label for afterRegex
		JLabel endRegexLabel = new JLabel(""After Regex: "");
		constraints.gridx = 2;
		constraints.gridwidth = 1;
		constraints.gridy = 2;
		constraints.fill = GridBagConstraints.NONE;
		constraints.weightx = 0;
		this.pane.add(endRegexLabel, constraints);

		// Add text field for afterRegex
		this.afterRegex = new JTextField();
		this.afterRegex.getDocument().addDocumentListener(new DocumentListener() {
			@Override
			public void insertUpdate(DocumentEvent e) {
				Persistor.persistExtractor();
			}

			@Override
			public void removeUpdate(DocumentEvent e) {
				Persistor.persistExtractor();
			}

			@Override
			public void changedUpdate(DocumentEvent e) {
				Persistor.persistExtractor();
			}
		});

		constraints.gridx = 3;
		constraints.gridy = 2;
		constraints.fill = GridBagConstraints.HORIZONTAL;
		constraints.weightx = 1;
		this.pane.add(this.afterRegex, constraints);
	}

	// Build regex to represent the selected text in its appropriate context
	private String[] buildSelectionRegex() {

		// Only perform action if user has selected something
		byte[] selected = textSelector.getSelectedText();
		if (textSelector.getSelectedText() != null) {
			int[] bounds = textSelector.getSelectionBounds();
			byte[] message = textSelector.getText();

			// Get start expression (SELECTION_BUFFER characters or fewer if necessary)
			int[] startExpressionBounds = new int[2];
			if (bounds[0] < SELECTION_BUFFER) {
				startExpressionBounds[0] = 0;
			} else {
				startExpressionBounds[0] = bounds[0] - SELECTION_BUFFER;
			}
			startExpressionBounds[1] = bounds[0];
			byte[] startExpression = Arrays.copyOfRange(message, startExpressionBounds[0], startExpressionBounds[1]);

			// Get end delimeter (SELECTION_BUFFER characters or fewer if necessary)
			int[] endDelimeterBounds = new int[2];
			int messageLength = message.length;
			endDelimeterBounds[0] = bounds[1];
			if (bounds[1] > messageLength - SELECTION_BUFFER) {
				endDelimeterBounds[1] = messageLength;
			} else {
				endDelimeterBounds[1] = bounds[1] + SELECTION_BUFFER;
			}
			byte[] endDelimeter = Arrays.copyOfRange(message, endDelimeterBounds[0], endDelimeterBounds[1]);

			// Build full regex
			String[] regex = new String[2];
			String startText = this.helpers.bytesToString(startExpression);
			String endText = this.helpers.bytesToString(endDelimeter);

			// Build beforeRegex before string we want to select
			if (startText == """" && endText == """") {
				return null;
			}

			if (startText.length() < SELECTION_BUFFER) {
				regex[0] = ""^"" + this.escapeRegex(startText);
			} else {
				regex[0] = this.escapeRegex(startText);
			}

			if (endText.length() < SELECTION_BUFFER) {
				regex[1] = this.escapeRegex(endText) + ""$"";
			} else {
				regex[1] = this.escapeRegex(endText);
			}
			return regex;
		} else {
			return null;
		}
	}

	private String getTestRegexMatch() {
		String toMatch = helpers.bytesToString(textSelector.getText());
		int[] selectionBounds = Utils.getSelectionBounds(toMatch,
				beforeRegex.getText(),
				afterRegex.getText());
		logger.debug(""Testing regex..."");
		logger.debug(""String to match: "" + toMatch);
		logger.debug(""Start regex: "" + beforeRegex.getText());
		logger.debug(""End regex: "" + afterRegex.getText());
		if (selectionBounds == null) {
			return null;
		}
		return toMatch.substring(selectionBounds[0], selectionBounds[1]);
	}

	// I hope that all necessary characters are escaped here, but I'm no regex pro so this could be faulty
	private String escapeRegex(String regex) {

		// Escape all regex chars
		regex = regex.replaceAll(""([!$^&*()-+{\\[}\\]|\\\\:,.?])"", ""\\\\$1"")
				.replace(""\n"", ""\\n"")
				.replace(""\r"", ""\\r"");
		return regex;
	}

	public boolean isToolSelected(int toolFlag) {
		if (this.allTools.isSelected()) {
			return true;
		}
		return toolSelectors.containsKey(toolFlag) && toolSelectors.get(toolFlag).isSelected();
	}

	public void fillTextArea(byte[] text) {
		this.textSelector.setText(text);
	}

	// Get regex string which represents the context of the selected text
	public String[] getSelectionRegex() {
		return new String[] {this.beforeRegex.getText(), this.afterRegex.getText()};
	}

	public String getTargetHost() {
		return this.targetHost.getText();
	}

	public void setTargetHost(String host) {
		this.targetHost.setText(host);
	}

	public boolean useRegexForTarget() {
		return this.regexCheckBox.isSelected();
	}

	public JPanel getUIComponent() {
		return this.pane;
	}

	// Returns true if suite scope should be used to determine if a message is in scope
	public boolean useSuiteScope() {
		return this.useScope.isSelected();
	}

	public String getEditorContent() {
		return this.helpers.bytesToString(this.textSelector.getText());
	}

	public RequestResponseState getEditorState() {
		InScopeTools tools = new InScopeTools(this.allTools.isSelected(),
				this.isToolSelected(IBurpExtenderCallbacks.TOOL_PROXY),
				this.isToolSelected(IBurpExtenderCallbacks.TOOL_SCANNER),
				this.isToolSelected(IBurpExtenderCallbacks.TOOL_INTRUDER),
				this.isToolSelected(IBurpExtenderCallbacks.TOOL_REPEATER),
				this.isToolSelected(IBurpExtenderCallbacks.TOOL_EXTENDER));
		String[] requestSelectionRegex = this.getSelectionRegex();
		RequestResponseState state = new RequestResponseState(tools,
				this.useSuiteScope(),
				this.getTargetHost(),
				this.useRegexForTarget(),
				requestSelectionRegex[0],
				requestSelectionRegex[1],
				this.getEditorContent());
		return state;
	}

	public void setEditorState(RequestResponseState state) {
		this.allTools.setSelected(state.inScopeTools.allTools);
		this.toolSelectors.get(IBurpExtenderCallbacks.TOOL_PROXY).setSelected(state.inScopeTools.proxy);
		this.toolSelectors.get(IBurpExtenderCallbacks.TOOL_SCANNER).setSelected(state.inScopeTools.scanner);
		this.toolSelectors.get(IBurpExtenderCallbacks.TOOL_INTRUDER).setSelected(state.inScopeTools.intruder);
		this.toolSelectors.get(IBurpExtenderCallbacks.TOOL_REPEATER).setSelected(state.inScopeTools.repeater);
		this.toolSelectors.get(IBurpExtenderCallbacks.TOOL_EXTENDER).setSelected(state.inScopeTools.extender);
		this.useScope.setSelected(state.useSuiteScope);
		this.useCustomHost.setSelected(!state.useSuiteScope);
		this.targetHost.setText(state.targetHost);
		this.regexCheckBox.setSelected(state.useRegex);
		this.beforeRegex.setText(state.beforeRegex);
		this.afterRegex.setText(state.afterRegex);
		this.textSelector.setText(state.content.getBytes());
	}


	// Create our own MenuItem so that we can prevent closing on every click
	public class ToolMenuItem extends JCheckBoxMenuItem {

		public ToolMenuItem(String text, boolean selected) {
			super(text, selected);
		}

		@Override
		public void doClick() {
			super.doClick();
			if (this == allTools) {
				// Change all other menu items to match this status
				boolean selected = this.isSelected();
				for (ToolMenuItem menuItem : toolSelectors.values()) {
					menuItem.setSelected(selected);
				}
			} else {
				if (allTools.isSelected()) {
					// If allTools is selected, then everything else should be selected. Deselect allTools
					allTools.setSelected(false);
				}
			}
			logger.info(""Saving in-scope...."");
			Persistor.persistExtractor();
		}

		@Override
		protected void processMouseEvent(MouseEvent event) {
			if (event.getID() == MouseEvent.MOUSE_RELEASED && contains(event.getPoint())) {
				doClick();
				setArmed(true);
			} else {
				super.processMouseEvent(event);
			}
		}
	}
}
","package burp; public class ExtractorEditor { private IExtensionHelpers helpers; private JPanel pane; private ITextEditor textSelector; private HashMap<Integer, ToolMenuItem> toolSelectors; private ToolMenuItem allTools; private JRadioButton useScope; private JRadioButton useCustomHost; private JTextField targetHost; private JCheckBox regexCheckBox; private JTextField beforeRegex; private JTextField afterRegex; private boolean keyListenerSet; private final int SELECTION_BUFFER = 15; private Logger logger; public ExtractorEditor(final IBurpExtenderCallbacks callbacks) { this.pane = new JPanel(); this.helpers = callbacks.getHelpers(); this.logger = new Logger(new PrintWriter(callbacks.getStdout(), true)); this.pane.setLayout(new GridBagLayout()); addButtons(this.pane); addTextFields(this.pane); addTextEditor(this.pane, callbacks); } private void addButtons(JPanel pane) { JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEFT)); toolSelectors = new HashMap<Integer, ToolMenuItem>(); JButton toolSelectionBar = new JButton(""Select in-scope tools""); JPopupMenu toolSelection = new JPopupMenu(); this.allTools = new ToolMenuItem(""All"", true); toolSelection.add(this.allTools); ToolMenuItem proxyTool = new ToolMenuItem(""Proxy"", true); toolSelectors.put(IBurpExtenderCallbacks.TOOL_PROXY, proxyTool); toolSelection.add(proxyTool); ToolMenuItem scannerTool = new ToolMenuItem(""Scanner"", true); toolSelectors.put(IBurpExtenderCallbacks.TOOL_SCANNER, scannerTool); toolSelection.add(scannerTool); ToolMenuItem intruderTool = new ToolMenuItem(""Intruder"", true); toolSelectors.put(IBurpExtenderCallbacks.TOOL_INTRUDER, intruderTool); toolSelection.add(intruderTool); ToolMenuItem repeater = new ToolMenuItem(""Repeater"", true); toolSelectors.put(IBurpExtenderCallbacks.TOOL_REPEATER, repeater); toolSelection.add(repeater); ToolMenuItem extender = new ToolMenuItem(""Extender"", true); toolSelectors.put(IBurpExtenderCallbacks.TOOL_EXTENDER, extender); toolSelection.add(extender); toolSelectionBar.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { toolSelection.show(toolSelectionBar, 0, toolSelectionBar.getHeight()); } } ); buttonPanel.add(toolSelectionBar); JButton testRegexButton = new JButton(""Test defined selection""); testRegexButton.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { String matchResult = getTestRegexMatch(); JPopupMenu popup = new JPopupMenu(); JPanel menuPanel = new JPanel(); JLabel contents = new JLabel(); if (matchResult == null) { contents.setText(""Did not find a match for the defined start and end regex!""); } else { contents.setText(""Found match: "" + matchResult); } contents.setBorder(BorderFactory.createEmptyBorder(0,4,0,4)); menuPanel.setOpaque(false); menuPanel.add(contents); popup.add(menuPanel); popup.show(testRegexButton, 0, testRegexButton.getHeight()); } } ); buttonPanel.add(testRegexButton); GridBagConstraints constraints = new GridBagConstraints(); constraints.gridx = 0; constraints.gridy = 0; constraints.gridwidth = 4; constraints.fill = GridBagConstraints.HORIZONTAL; pane.add(buttonPanel, constraints); } private void addTextEditor(JPanel pane, IBurpExtenderCallbacks callbacks) { GridBagConstraints constraints = new GridBagConstraints(); this.textSelector = callbacks.createTextEditor(); this.textSelector.setEditable(true); JPanel panel = new JPanel(new GridBagLayout()); constraints.gridx = 0; constraints.gridy = 0; constraints.weightx = 1; constraints.weighty = 1; constraints.fill = GridBagConstraints.BOTH; panel.add(this.textSelector.getComponent(), constraints); Border header = BorderFactory.createMatteBorder(4,0,0,0, Color.LIGHT_GRAY); panel.setBorder(header); constraints.gridx = 0; constraints.gridy = 4; constraints.gridwidth = 4; constraints.fill = GridBagConstraints.BOTH; constraints.weighty = 1; pane.add(panel, constraints); KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager(); this.textSelector.getComponent().addMouseListener(new MouseAdapter() { @Override
			public void mouseReleased(MouseEvent e) { if (!keyListenerSet) { keyListenerSet = true; manager.getFocusOwner().addKeyListener(new KeyListener() { @Override
						public void keyTyped(KeyEvent e) { } @Override
						public void keyPressed(KeyEvent e) { } @Override
						public void keyReleased(KeyEvent e) { String [] selectionRegex = buildSelectionRegex(); if (selectionRegex != null) { beforeRegex.setText(selectionRegex[0]); afterRegex.setText(selectionRegex[1]); } } } ); } String [] selectionRegex = buildSelectionRegex(); if (selectionRegex != null) { beforeRegex.setText(selectionRegex[0]); afterRegex.setText(selectionRegex[1]); } } } ); } private void addTextFields(JPanel pane) { GridBagConstraints constraints = new GridBagConstraints(); JPanel targetPanel = new JPanel(new GridBagLayout()); GridBagConstraints targetConstraints = new GridBagConstraints(); this.useScope = new JRadioButton(""Use suite scope  ""); this.useScope.addItemListener(new ItemListener() { @Override
			public void itemStateChanged(ItemEvent e) { Persistor.persistExtractor(); } } ); targetConstraints.gridx = 0; targetPanel.add(this.useScope, targetConstraints); this.useCustomHost = new JRadioButton(""Use specified target host: ""); targetConstraints.gridx += 1; targetPanel.add(this.useCustomHost, targetConstraints); ButtonGroup scopeSelection = new ButtonGroup(); scopeSelection.add(this.useScope); scopeSelection.add(this.useCustomHost); this.useScope.setSelected(true); this.targetHost = new JTextField(); this.targetHost.getDocument().addDocumentListener(new DocumentListener() { @Override
			public void insertUpdate(DocumentEvent e) { Persistor.persistExtractor(); } @Override
			public void removeUpdate(DocumentEvent e) { Persistor.persistExtractor(); } @Override
			public void changedUpdate(DocumentEvent e) { Persistor.persistExtractor(); } } ); targetConstraints.gridx += 1; targetConstraints.weightx = 1; targetConstraints.fill = GridBagConstraints.HORIZONTAL; targetPanel.add(this.targetHost, targetConstraints); this.regexCheckBox = new JCheckBox(""Regex""); this.regexCheckBox.addActionListener(new ActionListener() { @Override
			public void actionPerformed(ActionEvent e) { Persistor.persistExtractor(); } } ); targetConstraints.gridx += 1; targetConstraints.weightx = 0; targetConstraints.fill = GridBagConstraints.NONE; targetPanel.add(this.regexCheckBox, targetConstraints); constraints.gridx = 0; constraints.gridwidth = 4; constraints.gridy = 1; constraints.fill = GridBagConstraints.HORIZONTAL; this.pane.add(targetPanel, constraints); JLabel regexLabel = new JLabel(""Before Regex: ""); constraints.gridx = 0; constraints.gridwidth = 1; constraints.gridy = 2; constraints.fill = GridBagConstraints.NONE; constraints.weightx = 0; this.pane.add(regexLabel, constraints); this.beforeRegex = new JTextField(); this.beforeRegex.getDocument().addDocumentListener(new DocumentListener() { @Override
			public void insertUpdate(DocumentEvent e) { Persistor.persistExtractor(); } @Override
			public void removeUpdate(DocumentEvent e) { Persistor.persistExtractor(); } @Override
			public void changedUpdate(DocumentEvent e) { Persistor.persistExtractor(); } } ); constraints.gridx = 1; constraints.gridy = 2; constraints.fill = GridBagConstraints.HORIZONTAL; constraints.weightx = 1; this.pane.add(this.beforeRegex, constraints); JLabel endRegexLabel = new JLabel(""After Regex: ""); constraints.gridx = 2; constraints.gridwidth = 1; constraints.gridy = 2; constraints.fill = GridBagConstraints.NONE; constraints.weightx = 0; this.pane.add(endRegexLabel, constraints); this.afterRegex = new JTextField(); this.afterRegex.getDocument().addDocumentListener(new DocumentListener() { @Override
			public void insertUpdate(DocumentEvent e) { Persistor.persistExtractor(); } @Override
			public void removeUpdate(DocumentEvent e) { Persistor.persistExtractor(); } @Override
			public void changedUpdate(DocumentEvent e) { Persistor.persistExtractor(); } } ); constraints.gridx = 3; constraints.gridy = 2; constraints.fill = GridBagConstraints.HORIZONTAL; constraints.weightx = 1; this.pane.add(this.afterRegex, constraints); } private String[] buildSelectionRegex() { byte[] selected = textSelector.getSelectedText(); if (textSelector.getSelectedText() != null) { int[] bounds = textSelector.getSelectionBounds(); byte[] message = textSelector.getText(); int[] startExpressionBounds = new int[2]; if (bounds[0] < SELECTION_BUFFER) { startExpressionBounds[0] = 0; } else { startExpressionBounds[0] = bounds[0] - SELECTION_BUFFER; } startExpressionBounds[1] = bounds[0]; byte[] startExpression = Arrays.copyOfRange(message, startExpressionBounds[0], startExpressionBounds[1]); int[] endDelimeterBounds = new int[2]; int messageLength = message.length; endDelimeterBounds[0] = bounds[1]; if (bounds[1] > messageLength - SELECTION_BUFFER) { endDelimeterBounds[1] = messageLength; } else { endDelimeterBounds[1] = bounds[1] + SELECTION_BUFFER; } byte[] endDelimeter = Arrays.copyOfRange(message, endDelimeterBounds[0], endDelimeterBounds[1]); String[] regex = new String[2]; String startText = this.helpers.bytesToString(startExpression); String endText = this.helpers.bytesToString(endDelimeter); if (startText == """" && endText == """") { return null; } if (startText.length() < SELECTION_BUFFER) { regex[0] = ""^"" + this.escapeRegex(startText); } else { regex[0] = this.escapeRegex(startText); } if (endText.length() < SELECTION_BUFFER) { regex[1] = this.escapeRegex(endText) + ""$""; } else { regex[1] = this.escapeRegex(endText); } return regex; } else { return null; } } private String getTestRegexMatch() { String toMatch = helpers.bytesToString(textSelector.getText()); int[] selectionBounds = Utils.getSelectionBounds(toMatch,
				beforeRegex.getText(),
				afterRegex.getText()); if (selectionBounds == null) { return null; } return toMatch.substring(selectionBounds[0], selectionBounds[1]); } private String escapeRegex(String regex) { regex = regex.replaceAll(""([!$^&*()-+{ \\[} \\]|\\\\:,.?])"", ""\\\\$1"")
				.replace(""\n"", ""\\n"")
				.replace(""\r"", ""\\r""); return regex; } public boolean isToolSelected(int toolFlag) { if (this.allTools.isSelected()) { return true; } return toolSelectors.containsKey(toolFlag) && toolSelectors.get(toolFlag).isSelected(); } public void fillTextArea(byte[] text) { this.textSelector.setText(text); } public String[] getSelectionRegex() { return new String[] { this.beforeRegex.getText(), this.afterRegex.getText()} ; } public String getTargetHost() { return this.targetHost.getText(); } public void setTargetHost(String host) { this.targetHost.setText(host); } public boolean useRegexForTarget() { return this.regexCheckBox.isSelected(); } public JPanel getUIComponent() { return this.pane; } public boolean useSuiteScope() { return this.useScope.isSelected(); } public String getEditorContent() { return this.helpers.bytesToString(this.textSelector.getText()); } public RequestResponseState getEditorState() { InScopeTools tools = new InScopeTools(this.allTools.isSelected(),
				this.isToolSelected(IBurpExtenderCallbacks.TOOL_PROXY),
				this.isToolSelected(IBurpExtenderCallbacks.TOOL_SCANNER),
				this.isToolSelected(IBurpExtenderCallbacks.TOOL_INTRUDER),
				this.isToolSelected(IBurpExtenderCallbacks.TOOL_REPEATER),
				this.isToolSelected(IBurpExtenderCallbacks.TOOL_EXTENDER)); String[] requestSelectionRegex = this.getSelectionRegex(); RequestResponseState state = new RequestResponseState(tools,
				this.useSuiteScope(),
				this.getTargetHost(),
				this.useRegexForTarget(),
				requestSelectionRegex[0],
				requestSelectionRegex[1],
				this.getEditorContent()); return state; } public void setEditorState(RequestResponseState state) { this.allTools.setSelected(state.inScopeTools.allTools); this.toolSelectors.get(IBurpExtenderCallbacks.TOOL_PROXY).setSelected(state.inScopeTools.proxy); this.toolSelectors.get(IBurpExtenderCallbacks.TOOL_SCANNER).setSelected(state.inScopeTools.scanner); this.toolSelectors.get(IBurpExtenderCallbacks.TOOL_INTRUDER).setSelected(state.inScopeTools.intruder); this.toolSelectors.get(IBurpExtenderCallbacks.TOOL_REPEATER).setSelected(state.inScopeTools.repeater); this.toolSelectors.get(IBurpExtenderCallbacks.TOOL_EXTENDER).setSelected(state.inScopeTools.extender); this.useScope.setSelected(state.useSuiteScope); this.useCustomHost.setSelected(!state.useSuiteScope); this.targetHost.setText(state.targetHost); this.regexCheckBox.setSelected(state.useRegex); this.beforeRegex.setText(state.beforeRegex); this.afterRegex.setText(state.afterRegex); this.textSelector.setText(state.content.getBytes()); } public class ToolMenuItem extends JCheckBoxMenuItem { public ToolMenuItem(String text, boolean selected) { super(text, selected); } @Override
		public void doClick() { super.doClick(); if (this == allTools) { boolean selected = this.isSelected(); for (ToolMenuItem menuItem : toolSelectors.values()) { menuItem.setSelected(selected); } } else { if (allTools.isSelected()) { allTools.setSelected(false); } } Persistor.persistExtractor(); } @Override
		protected void processMouseEvent(MouseEvent event) { if (event.getID() == MouseEvent.MOUSE_RELEASED && contains(event.getPoint())) { doClick(); setArmed(true); } else { super.processMouseEvent(event); } } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package burp; public class ExtractorEditor { private IExtensionHelpers helpers; private JPanel pane; private ITextEditor textSelector; private HashMap<Integer, ToolMenuItem> toolSelectors; private ToolMenuItem allTools; private JRadioButton useScope; private JRadioButton useCustomHost; private JTextField targetHost; private JCheckBox regexCheckBox; private JTextField beforeRegex; private JTextField afterRegex; private boolean keyListenerSet; private final int SELECTION_BUFFER = 15; private Logger logger; public ExtractorEditor(final IBurpExtenderCallbacks callbacks) { this.pane = new JPanel(); this.helpers = callbacks.getHelpers(); this.logger = new Logger(new PrintWriter(callbacks.getStdout(), true)); this.pane.setLayout(new GridBagLayout()); addButtons(this.pane); addTextFields(this.pane); addTextEditor(this.pane, callbacks); } <FILL_ME> private void addButtons(JPanel pane) { JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEFT)); toolSelectors = new HashMap<Integer, ToolMenuItem>(); JButton toolSelectionBar = new JButton(""Select in-scope tools""); JPopupMenu toolSelection = new JPopupMenu(); this.allTools = new ToolMenuItem(""All"", true); toolSelection.add(this.allTools); ToolMenuItem proxyTool = new ToolMenuItem(""Proxy"", true); toolSelectors.put(IBurpExtenderCallbacks.TOOL_PROXY, proxyTool); toolSelection.add(proxyTool); ToolMenuItem scannerTool = new ToolMenuItem(""Scanner"", true); toolSelectors.put(IBurpExtenderCallbacks.TOOL_SCANNER, scannerTool); toolSelection.add(scannerTool); ToolMenuItem intruderTool = new ToolMenuItem(""Intruder"", true); toolSelectors.put(IBurpExtenderCallbacks.TOOL_INTRUDER, intruderTool); toolSelection.add(intruderTool); ToolMenuItem repeater = new ToolMenuItem(""Repeater"", true); toolSelectors.put(IBurpExtenderCallbacks.TOOL_REPEATER, repeater); toolSelection.add(repeater); ToolMenuItem extender = new ToolMenuItem(""Extender"", true); toolSelectors.put(IBurpExtenderCallbacks.TOOL_EXTENDER, extender); toolSelection.add(extender); toolSelectionBar.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { toolSelection.show(toolSelectionBar, 0, toolSelectionBar.getHeight()); } } ); buttonPanel.add(toolSelectionBar); JButton testRegexButton = new JButton(""Test defined selection""); testRegexButton.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { String matchResult = getTestRegexMatch(); JPopupMenu popup = new JPopupMenu(); JPanel menuPanel = new JPanel(); JLabel contents = new JLabel(); if (matchResult == null) { contents.setText(""Did not find a match for the defined start and end regex!""); } else { contents.setText(""Found match: "" + matchResult); } contents.setBorder(BorderFactory.createEmptyBorder(0,4,0,4)); menuPanel.setOpaque(false); menuPanel.add(contents); popup.add(menuPanel); popup.show(testRegexButton, 0, testRegexButton.getHeight()); } } ); buttonPanel.add(testRegexButton); GridBagConstraints constraints = new GridBagConstraints(); constraints.gridx = 0; constraints.gridy = 0; constraints.gridwidth = 4; constraints.fill = GridBagConstraints.HORIZONTAL; pane.add(buttonPanel, constraints); } private void addTextEditor(JPanel pane, IBurpExtenderCallbacks callbacks) { GridBagConstraints constraints = new GridBagConstraints(); this.textSelector = callbacks.createTextEditor(); this.textSelector.setEditable(true); JPanel panel = new JPanel(new GridBagLayout()); constraints.gridx = 0; constraints.gridy = 0; constraints.weightx = 1; constraints.weighty = 1; constraints.fill = GridBagConstraints.BOTH; panel.add(this.textSelector.getComponent(), constraints); Border header = BorderFactory.createMatteBorder(4,0,0,0, Color.LIGHT_GRAY); panel.setBorder(header); constraints.gridx = 0; constraints.gridy = 4; constraints.gridwidth = 4; constraints.fill = GridBagConstraints.BOTH; constraints.weighty = 1; pane.add(panel, constraints); KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager(); this.textSelector.getComponent().addMouseListener(new MouseAdapter() { @Override
			public void mouseReleased(MouseEvent e) { if (!keyListenerSet) { keyListenerSet = true; manager.getFocusOwner().addKeyListener(new KeyListener() { @Override
						public void keyTyped(KeyEvent e) { } @Override
						public void keyPressed(KeyEvent e) { } @Override
						public void keyReleased(KeyEvent e) { String [] selectionRegex = buildSelectionRegex(); if (selectionRegex != null) { beforeRegex.setText(selectionRegex[0]); afterRegex.setText(selectionRegex[1]); } } } ); } String [] selectionRegex = buildSelectionRegex(); if (selectionRegex != null) { beforeRegex.setText(selectionRegex[0]); afterRegex.setText(selectionRegex[1]); } } } ); } private void addTextFields(JPanel pane) { GridBagConstraints constraints = new GridBagConstraints(); JPanel targetPanel = new JPanel(new GridBagLayout()); GridBagConstraints targetConstraints = new GridBagConstraints(); this.useScope = new JRadioButton(""Use suite scope  ""); this.useScope.addItemListener(new ItemListener() { @Override
			public void itemStateChanged(ItemEvent e) { Persistor.persistExtractor(); } } ); targetConstraints.gridx = 0; targetPanel.add(this.useScope, targetConstraints); this.useCustomHost = new JRadioButton(""Use specified target host: ""); targetConstraints.gridx += 1; targetPanel.add(this.useCustomHost, targetConstraints); ButtonGroup scopeSelection = new ButtonGroup(); scopeSelection.add(this.useScope); scopeSelection.add(this.useCustomHost); this.useScope.setSelected(true); this.targetHost = new JTextField(); this.targetHost.getDocument().addDocumentListener(new DocumentListener() { @Override
			public void insertUpdate(DocumentEvent e) { Persistor.persistExtractor(); } @Override
			public void removeUpdate(DocumentEvent e) { Persistor.persistExtractor(); } @Override
			public void changedUpdate(DocumentEvent e) { Persistor.persistExtractor(); } } ); targetConstraints.gridx += 1; targetConstraints.weightx = 1; targetConstraints.fill = GridBagConstraints.HORIZONTAL; targetPanel.add(this.targetHost, targetConstraints); this.regexCheckBox = new JCheckBox(""Regex""); this.regexCheckBox.addActionListener(new ActionListener() { @Override
			public void actionPerformed(ActionEvent e) { Persistor.persistExtractor(); } } ); targetConstraints.gridx += 1; targetConstraints.weightx = 0; targetConstraints.fill = GridBagConstraints.NONE; targetPanel.add(this.regexCheckBox, targetConstraints); constraints.gridx = 0; constraints.gridwidth = 4; constraints.gridy = 1; constraints.fill = GridBagConstraints.HORIZONTAL; this.pane.add(targetPanel, constraints); JLabel regexLabel = new JLabel(""Before Regex: ""); constraints.gridx = 0; constraints.gridwidth = 1; constraints.gridy = 2; constraints.fill = GridBagConstraints.NONE; constraints.weightx = 0; this.pane.add(regexLabel, constraints); this.beforeRegex = new JTextField(); this.beforeRegex.getDocument().addDocumentListener(new DocumentListener() { @Override
			public void insertUpdate(DocumentEvent e) { Persistor.persistExtractor(); } @Override
			public void removeUpdate(DocumentEvent e) { Persistor.persistExtractor(); } @Override
			public void changedUpdate(DocumentEvent e) { Persistor.persistExtractor(); } } ); constraints.gridx = 1; constraints.gridy = 2; constraints.fill = GridBagConstraints.HORIZONTAL; constraints.weightx = 1; this.pane.add(this.beforeRegex, constraints); JLabel endRegexLabel = new JLabel(""After Regex: ""); constraints.gridx = 2; constraints.gridwidth = 1; constraints.gridy = 2; constraints.fill = GridBagConstraints.NONE; constraints.weightx = 0; this.pane.add(endRegexLabel, constraints); this.afterRegex = new JTextField(); this.afterRegex.getDocument().addDocumentListener(new DocumentListener() { @Override
			public void insertUpdate(DocumentEvent e) { Persistor.persistExtractor(); } @Override
			public void removeUpdate(DocumentEvent e) { Persistor.persistExtractor(); } @Override
			public void changedUpdate(DocumentEvent e) { Persistor.persistExtractor(); } } ); constraints.gridx = 3; constraints.gridy = 2; constraints.fill = GridBagConstraints.HORIZONTAL; constraints.weightx = 1; this.pane.add(this.afterRegex, constraints); } private String[] buildSelectionRegex() { byte[] selected = textSelector.getSelectedText(); if (textSelector.getSelectedText() != null) { int[] bounds = textSelector.getSelectionBounds(); byte[] message = textSelector.getText(); int[] startExpressionBounds = new int[2]; if (bounds[0] < SELECTION_BUFFER) { startExpressionBounds[0] = 0; } else { startExpressionBounds[0] = bounds[0] - SELECTION_BUFFER; } startExpressionBounds[1] = bounds[0]; byte[] startExpression = Arrays.copyOfRange(message, startExpressionBounds[0], startExpressionBounds[1]); int[] endDelimeterBounds = new int[2]; int messageLength = message.length; endDelimeterBounds[0] = bounds[1]; if (bounds[1] > messageLength - SELECTION_BUFFER) { endDelimeterBounds[1] = messageLength; } else { endDelimeterBounds[1] = bounds[1] + SELECTION_BUFFER; } byte[] endDelimeter = Arrays.copyOfRange(message, endDelimeterBounds[0], endDelimeterBounds[1]); String[] regex = new String[2]; String startText = this.helpers.bytesToString(startExpression); String endText = this.helpers.bytesToString(endDelimeter); if (startText == """" && endText == """") { return null; } if (startText.length() < SELECTION_BUFFER) { regex[0] = ""^"" + this.escapeRegex(startText); } else { regex[0] = this.escapeRegex(startText); } if (endText.length() < SELECTION_BUFFER) { regex[1] = this.escapeRegex(endText) + ""$""; } else { regex[1] = this.escapeRegex(endText); } return regex; } else { return null; } } private String getTestRegexMatch() { String toMatch = helpers.bytesToString(textSelector.getText()); int[] selectionBounds = Utils.getSelectionBounds(toMatch,
				beforeRegex.getText(),
				afterRegex.getText()); <FILL_ME> if (selectionBounds == null) { return null; } return toMatch.substring(selectionBounds[0], selectionBounds[1]); } private String escapeRegex(String regex) { regex = regex.replaceAll(""([!$^&*()-+{ \\[} \\]|\\\\:,.?])"", ""\\\\$1"")
				.replace(""\n"", ""\\n"")
				.replace(""\r"", ""\\r""); return regex; } public boolean isToolSelected(int toolFlag) { if (this.allTools.isSelected()) { return true; } return toolSelectors.containsKey(toolFlag) && toolSelectors.get(toolFlag).isSelected(); } public void fillTextArea(byte[] text) { this.textSelector.setText(text); } public String[] getSelectionRegex() { return new String[] { this.beforeRegex.getText(), this.afterRegex.getText()} ; } public String getTargetHost() { return this.targetHost.getText(); } public void setTargetHost(String host) { this.targetHost.setText(host); } public boolean useRegexForTarget() { return this.regexCheckBox.isSelected(); } public JPanel getUIComponent() { return this.pane; } public boolean useSuiteScope() { return this.useScope.isSelected(); } public String getEditorContent() { return this.helpers.bytesToString(this.textSelector.getText()); } public RequestResponseState getEditorState() { InScopeTools tools = new InScopeTools(this.allTools.isSelected(),
				this.isToolSelected(IBurpExtenderCallbacks.TOOL_PROXY),
				this.isToolSelected(IBurpExtenderCallbacks.TOOL_SCANNER),
				this.isToolSelected(IBurpExtenderCallbacks.TOOL_INTRUDER),
				this.isToolSelected(IBurpExtenderCallbacks.TOOL_REPEATER),
				this.isToolSelected(IBurpExtenderCallbacks.TOOL_EXTENDER)); String[] requestSelectionRegex = this.getSelectionRegex(); RequestResponseState state = new RequestResponseState(tools,
				this.useSuiteScope(),
				this.getTargetHost(),
				this.useRegexForTarget(),
				requestSelectionRegex[0],
				requestSelectionRegex[1],
				this.getEditorContent()); return state; } public void setEditorState(RequestResponseState state) { this.allTools.setSelected(state.inScopeTools.allTools); this.toolSelectors.get(IBurpExtenderCallbacks.TOOL_PROXY).setSelected(state.inScopeTools.proxy); this.toolSelectors.get(IBurpExtenderCallbacks.TOOL_SCANNER).setSelected(state.inScopeTools.scanner); this.toolSelectors.get(IBurpExtenderCallbacks.TOOL_INTRUDER).setSelected(state.inScopeTools.intruder); this.toolSelectors.get(IBurpExtenderCallbacks.TOOL_REPEATER).setSelected(state.inScopeTools.repeater); this.toolSelectors.get(IBurpExtenderCallbacks.TOOL_EXTENDER).setSelected(state.inScopeTools.extender); this.useScope.setSelected(state.useSuiteScope); this.useCustomHost.setSelected(!state.useSuiteScope); this.targetHost.setText(state.targetHost); this.regexCheckBox.setSelected(state.useRegex); this.beforeRegex.setText(state.beforeRegex); this.afterRegex.setText(state.afterRegex); this.textSelector.setText(state.content.getBytes()); } public class ToolMenuItem extends JCheckBoxMenuItem { public ToolMenuItem(String text, boolean selected) { super(text, selected); } @Override
		public void doClick() { super.doClick(); if (this == allTools) { boolean selected = this.isSelected(); for (ToolMenuItem menuItem : toolSelectors.values()) { menuItem.setSelected(selected); } } else { if (allTools.isSelected()) { allTools.setSelected(false); } } Persistor.persistExtractor(); } @Override
		protected void processMouseEvent(MouseEvent event) { if (event.getID() == MouseEvent.MOUSE_RELEASED && contains(event.getPoint())) { doClick(); setArmed(true); } else { super.processMouseEvent(event); } } } } ","package burp; 
import burp.persistence.InScopeTools; import burp.persistence.Persistor; import burp.persistence.RequestResponseState; 
import javax.swing.*; import javax.swing.border.Border; import javax.swing.event.DocumentEvent; import javax.swing.event.DocumentListener; import java.awt.*; import java.awt.event.*; import java.io.PrintWriter; import java.util.Arrays; import java.util.HashMap;  public class ExtractorEditor { private IExtensionHelpers helpers; private JPanel pane; private ITextEditor textSelector; private HashMap<Integer, ToolMenuItem> toolSelectors; private ToolMenuItem allTools; private JRadioButton useScope; private JRadioButton useCustomHost; private JTextField targetHost; private JCheckBox regexCheckBox; private JTextField beforeRegex; private JTextField afterRegex; private boolean keyListenerSet; private final int SELECTION_BUFFER = 15; private Logger logger;  public ExtractorEditor(final IBurpExtenderCallbacks callbacks) { this.pane = new JPanel(); this.helpers = callbacks.getHelpers(); this.logger = new Logger(new PrintWriter(callbacks.getStdout(), true)); this.pane.setLayout(new GridBagLayout());  // Add buttons to panel addButtons(this.pane);  // Add text fields and labels to panel addTextFields(this.pane);  // Add Burp response editor to panel addTextEditor(this.pane, callbacks); } <FILL_ME>  // Add all buttons to editor private void addButtons(JPanel pane) { JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));  // Create tool selection toolSelectors = new HashMap<Integer, ToolMenuItem>(); JButton toolSelectionBar = new JButton(""Select in-scope tools""); JPopupMenu toolSelection = new JPopupMenu(); this.allTools = new ToolMenuItem(""All"", true); toolSelection.add(this.allTools); ToolMenuItem proxyTool = new ToolMenuItem(""Proxy"", true); toolSelectors.put(IBurpExtenderCallbacks.TOOL_PROXY, proxyTool); toolSelection.add(proxyTool); ToolMenuItem scannerTool = new ToolMenuItem(""Scanner"", true); toolSelectors.put(IBurpExtenderCallbacks.TOOL_SCANNER, scannerTool); toolSelection.add(scannerTool); ToolMenuItem intruderTool = new ToolMenuItem(""Intruder"", true); toolSelectors.put(IBurpExtenderCallbacks.TOOL_INTRUDER, intruderTool); toolSelection.add(intruderTool); ToolMenuItem repeater = new ToolMenuItem(""Repeater"", true); toolSelectors.put(IBurpExtenderCallbacks.TOOL_REPEATER, repeater); toolSelection.add(repeater); ToolMenuItem extender = new ToolMenuItem(""Extender"", true); toolSelectors.put(IBurpExtenderCallbacks.TOOL_EXTENDER, extender); toolSelection.add(extender); toolSelectionBar.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { toolSelection.show(toolSelectionBar, 0, toolSelectionBar.getHeight()); } } ); buttonPanel.add(toolSelectionBar);  // Create button for testing regex JButton testRegexButton = new JButton(""Test defined selection""); testRegexButton.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { String matchResult = getTestRegexMatch(); JPopupMenu popup = new JPopupMenu(); JPanel menuPanel = new JPanel(); JLabel contents = new JLabel(); if (matchResult == null) { contents.setText(""Did not find a match for the defined start and end regex!""); } else { contents.setText(""Found match: "" + matchResult); } contents.setBorder(BorderFactory.createEmptyBorder(0,4,0,4)); menuPanel.setOpaque(false); menuPanel.add(contents); popup.add(menuPanel); popup.show(testRegexButton, 0, testRegexButton.getHeight()); } } ); buttonPanel.add(testRegexButton);  GridBagConstraints constraints = new GridBagConstraints(); constraints.gridx = 0; constraints.gridy = 0; constraints.gridwidth = 4; constraints.fill = GridBagConstraints.HORIZONTAL; pane.add(buttonPanel, constraints); }  // Add our custom text editor private void addTextEditor(JPanel pane, IBurpExtenderCallbacks callbacks) { GridBagConstraints constraints = new GridBagConstraints();  this.textSelector = callbacks.createTextEditor(); this.textSelector.setEditable(true); JPanel panel = new JPanel(new GridBagLayout()); constraints.gridx = 0; constraints.gridy = 0; constraints.weightx = 1; constraints.weighty = 1; constraints.fill = GridBagConstraints.BOTH; panel.add(this.textSelector.getComponent(), constraints);  Border header = BorderFactory.createMatteBorder(4,0,0,0, Color.LIGHT_GRAY); panel.setBorder(header);  constraints.gridx = 0; constraints.gridy = 4; constraints.gridwidth = 4; constraints.fill = GridBagConstraints.BOTH; constraints.weighty = 1; pane.add(panel, constraints);  // This is used to select the focused component for an extractor editor. KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager();  // Create mouse listeners for message editor this.textSelector.getComponent().addMouseListener(new MouseAdapter() { @Override
			public void mouseReleased(MouseEvent e) { // I never figured out how to get focus on the textEditor component to set keyListeners, // so just find out what is in focus when we click inside the editor and set a key listener on that. if (!keyListenerSet) { keyListenerSet = true; manager.getFocusOwner().addKeyListener(new KeyListener() { @Override
						public void keyTyped(KeyEvent e) { }  @Override
						public void keyPressed(KeyEvent e) { }  @Override
						public void keyReleased(KeyEvent e) { String [] selectionRegex = buildSelectionRegex(); if (selectionRegex != null) { beforeRegex.setText(selectionRegex[0]); afterRegex.setText(selectionRegex[1]); } } } ); } String [] selectionRegex = buildSelectionRegex(); if (selectionRegex != null) { beforeRegex.setText(selectionRegex[0]); afterRegex.setText(selectionRegex[1]); } } } ); }  // Add text fields and related labels private void addTextFields(JPanel pane) { GridBagConstraints constraints = new GridBagConstraints();  // Add label for target host JPanel targetPanel = new JPanel(new GridBagLayout()); GridBagConstraints targetConstraints = new GridBagConstraints();  // Add radio button for scope this.useScope = new JRadioButton(""Use suite scope  ""); this.useScope.addItemListener(new ItemListener() { @Override
			public void itemStateChanged(ItemEvent e) { Persistor.persistExtractor(); } } ); targetConstraints.gridx = 0; targetPanel.add(this.useScope, targetConstraints);  // Add radio button for target host this.useCustomHost = new JRadioButton(""Use specified target host: ""); targetConstraints.gridx += 1; targetPanel.add(this.useCustomHost, targetConstraints);  // Create button group and select suite scope by default ButtonGroup scopeSelection = new ButtonGroup(); scopeSelection.add(this.useScope); scopeSelection.add(this.useCustomHost); this.useScope.setSelected(true);  // Add text field for target host this.targetHost = new JTextField(); this.targetHost.getDocument().addDocumentListener(new DocumentListener() { @Override
			public void insertUpdate(DocumentEvent e) { Persistor.persistExtractor();  }  @Override
			public void removeUpdate(DocumentEvent e) { Persistor.persistExtractor(); }  @Override
			public void changedUpdate(DocumentEvent e) { Persistor.persistExtractor(); } } ); targetConstraints.gridx += 1; targetConstraints.weightx = 1; targetConstraints.fill = GridBagConstraints.HORIZONTAL; targetPanel.add(this.targetHost, targetConstraints);  // Add regex checkBox this.regexCheckBox = new JCheckBox(""Regex""); this.regexCheckBox.addActionListener(new ActionListener() { @Override
			public void actionPerformed(ActionEvent e) { Persistor.persistExtractor(); } } ); targetConstraints.gridx += 1; targetConstraints.weightx = 0; targetConstraints.fill = GridBagConstraints.NONE; targetPanel.add(this.regexCheckBox, targetConstraints);  constraints.gridx = 0; constraints.gridwidth = 4; constraints.gridy = 1; constraints.fill = GridBagConstraints.HORIZONTAL; this.pane.add(targetPanel, constraints);  // Add label for beforeRegex JLabel regexLabel = new JLabel(""Before Regex: ""); constraints.gridx = 0; constraints.gridwidth = 1; constraints.gridy = 2; constraints.fill = GridBagConstraints.NONE; constraints.weightx = 0; this.pane.add(regexLabel, constraints);  // Add text field for beforeRegex this.beforeRegex = new JTextField(); this.beforeRegex.getDocument().addDocumentListener(new DocumentListener() { @Override
			public void insertUpdate(DocumentEvent e) { Persistor.persistExtractor(); }  @Override
			public void removeUpdate(DocumentEvent e) { Persistor.persistExtractor(); }  @Override
			public void changedUpdate(DocumentEvent e) { Persistor.persistExtractor(); } } ); constraints.gridx = 1; constraints.gridy = 2; constraints.fill = GridBagConstraints.HORIZONTAL; constraints.weightx = 1; this.pane.add(this.beforeRegex, constraints);  // Add label for afterRegex JLabel endRegexLabel = new JLabel(""After Regex: ""); constraints.gridx = 2; constraints.gridwidth = 1; constraints.gridy = 2; constraints.fill = GridBagConstraints.NONE; constraints.weightx = 0; this.pane.add(endRegexLabel, constraints);  // Add text field for afterRegex this.afterRegex = new JTextField(); this.afterRegex.getDocument().addDocumentListener(new DocumentListener() { @Override
			public void insertUpdate(DocumentEvent e) { Persistor.persistExtractor(); }  @Override
			public void removeUpdate(DocumentEvent e) { Persistor.persistExtractor(); }  @Override
			public void changedUpdate(DocumentEvent e) { Persistor.persistExtractor(); } } );  constraints.gridx = 3; constraints.gridy = 2; constraints.fill = GridBagConstraints.HORIZONTAL; constraints.weightx = 1; this.pane.add(this.afterRegex, constraints); }  // Build regex to represent the selected text in its appropriate context private String[] buildSelectionRegex() {  // Only perform action if user has selected something byte[] selected = textSelector.getSelectedText(); if (textSelector.getSelectedText() != null) { int[] bounds = textSelector.getSelectionBounds(); byte[] message = textSelector.getText();  // Get start expression (SELECTION_BUFFER characters or fewer if necessary) int[] startExpressionBounds = new int[2]; if (bounds[0] < SELECTION_BUFFER) { startExpressionBounds[0] = 0; } else { startExpressionBounds[0] = bounds[0] - SELECTION_BUFFER; } startExpressionBounds[1] = bounds[0]; byte[] startExpression = Arrays.copyOfRange(message, startExpressionBounds[0], startExpressionBounds[1]);  // Get end delimeter (SELECTION_BUFFER characters or fewer if necessary) int[] endDelimeterBounds = new int[2]; int messageLength = message.length; endDelimeterBounds[0] = bounds[1]; if (bounds[1] > messageLength - SELECTION_BUFFER) { endDelimeterBounds[1] = messageLength; } else { endDelimeterBounds[1] = bounds[1] + SELECTION_BUFFER; } byte[] endDelimeter = Arrays.copyOfRange(message, endDelimeterBounds[0], endDelimeterBounds[1]);  // Build full regex String[] regex = new String[2]; String startText = this.helpers.bytesToString(startExpression); String endText = this.helpers.bytesToString(endDelimeter);  // Build beforeRegex before string we want to select if (startText == """" && endText == """") { return null; }  if (startText.length() < SELECTION_BUFFER) { regex[0] = ""^"" + this.escapeRegex(startText); } else { regex[0] = this.escapeRegex(startText); }  if (endText.length() < SELECTION_BUFFER) { regex[1] = this.escapeRegex(endText) + ""$""; } else { regex[1] = this.escapeRegex(endText); } return regex; } else { return null; } }  private String getTestRegexMatch() { String toMatch = helpers.bytesToString(textSelector.getText()); int[] selectionBounds = Utils.getSelectionBounds(toMatch,
				beforeRegex.getText(),
				afterRegex.getText()); <FILL_ME> if (selectionBounds == null) { return null; } return toMatch.substring(selectionBounds[0], selectionBounds[1]); }  // I hope that all necessary characters are escaped here, but I'm no regex pro so this could be faulty private String escapeRegex(String regex) {  // Escape all regex chars regex = regex.replaceAll(""([!$^&*()-+{ \\[} \\]|\\\\:,.?])"", ""\\\\$1"")
				.replace(""\n"", ""\\n"")
				.replace(""\r"", ""\\r""); return regex; }  public boolean isToolSelected(int toolFlag) { if (this.allTools.isSelected()) { return true; } return toolSelectors.containsKey(toolFlag) && toolSelectors.get(toolFlag).isSelected(); }  public void fillTextArea(byte[] text) { this.textSelector.setText(text); }  // Get regex string which represents the context of the selected text public String[] getSelectionRegex() { return new String[] { this.beforeRegex.getText(), this.afterRegex.getText()} ; }  public String getTargetHost() { return this.targetHost.getText(); }  public void setTargetHost(String host) { this.targetHost.setText(host); }  public boolean useRegexForTarget() { return this.regexCheckBox.isSelected(); }  public JPanel getUIComponent() { return this.pane; }  // Returns true if suite scope should be used to determine if a message is in scope public boolean useSuiteScope() { return this.useScope.isSelected(); }  public String getEditorContent() { return this.helpers.bytesToString(this.textSelector.getText()); }  public RequestResponseState getEditorState() { InScopeTools tools = new InScopeTools(this.allTools.isSelected(),
				this.isToolSelected(IBurpExtenderCallbacks.TOOL_PROXY),
				this.isToolSelected(IBurpExtenderCallbacks.TOOL_SCANNER),
				this.isToolSelected(IBurpExtenderCallbacks.TOOL_INTRUDER),
				this.isToolSelected(IBurpExtenderCallbacks.TOOL_REPEATER),
				this.isToolSelected(IBurpExtenderCallbacks.TOOL_EXTENDER)); String[] requestSelectionRegex = this.getSelectionRegex(); RequestResponseState state = new RequestResponseState(tools,
				this.useSuiteScope(),
				this.getTargetHost(),
				this.useRegexForTarget(),
				requestSelectionRegex[0],
				requestSelectionRegex[1],
				this.getEditorContent()); return state; }  public void setEditorState(RequestResponseState state) { this.allTools.setSelected(state.inScopeTools.allTools); this.toolSelectors.get(IBurpExtenderCallbacks.TOOL_PROXY).setSelected(state.inScopeTools.proxy); this.toolSelectors.get(IBurpExtenderCallbacks.TOOL_SCANNER).setSelected(state.inScopeTools.scanner); this.toolSelectors.get(IBurpExtenderCallbacks.TOOL_INTRUDER).setSelected(state.inScopeTools.intruder); this.toolSelectors.get(IBurpExtenderCallbacks.TOOL_REPEATER).setSelected(state.inScopeTools.repeater); this.toolSelectors.get(IBurpExtenderCallbacks.TOOL_EXTENDER).setSelected(state.inScopeTools.extender); this.useScope.setSelected(state.useSuiteScope); this.useCustomHost.setSelected(!state.useSuiteScope); this.targetHost.setText(state.targetHost); this.regexCheckBox.setSelected(state.useRegex); this.beforeRegex.setText(state.beforeRegex); this.afterRegex.setText(state.afterRegex); this.textSelector.setText(state.content.getBytes()); } 
  public class ToolMenuItem extends JCheckBoxMenuItem { // Create our own MenuItem so that we can prevent closing on every click public ToolMenuItem(String text, boolean selected) { super(text, selected); }  @Override
		public void doClick() { super.doClick(); if (this == allTools) {  boolean selected = this.isSelected(); for (ToolMenuItem menuItem : toolSelectors.values()) { menuItem.setSelected(selected); } } else { if (allTools.isSelected()) { // Change all other menu items to match this status allTools.setSelected(false); } } Persistor.persistExtractor(); } // If allTools is selected, then everything else should be selected. Deselect allTools @Override
		protected void processMouseEvent(MouseEvent event) { if (event.getID() == MouseEvent.MOUSE_RELEASED && contains(event.getPoint())) { doClick(); setArmed(true); } else { super.processMouseEvent(event); } } } }  "
src/burp/ExtractorMainTab.java,"package burp;

import burp.persistence.ExtractorTabState;
import burp.persistence.Persistor;

import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.HashMap;

public class ExtractorMainTab implements ITab {
	private HashMap extractorTabMap;
	private ExtractorSelectorTab selectorTab;
	private int tabNum = 0;
	static int tabsRemoved = 0;

	private JTabbedPane tabbedPane;

	public ExtractorMainTab(IBurpExtenderCallbacks callbacks) {
		this.extractorTabMap = new HashMap<Integer, ExtractorTab>();
		this.tabbedPane = new JTabbedPane();
		callbacks.customizeUiComponent(this.tabbedPane);
		callbacks.addSuiteTab(ExtractorMainTab.this);

		// Create selection tab
		this.selectorTab = new ExtractorSelectorTab(this, callbacks);
		this.tabbedPane.add(selectorTab.getUiComponent());
		this.tabbedPane.setTabComponentAt(0, new JLabel(""Selection""));
	}

	public void addMessageFromMenu(IHttpRequestResponse message) {
		this.selectorTab.addMessageFromMenu(message);
		this.tabbedPane.setSelectedIndex(0);
	}

	public ExtractorTab createExtractorTab(byte[] response, byte[] request, String responseHost, String requestHost, IBurpExtenderCallbacks callbacks) {
		this.tabNum++;
		int index = (this.tabNum) - this.tabsRemoved;

		// Pause Persistor so that we don't write values before the tab loads
		Persistor.pause();
		ExtractorTab extractorTab = new ExtractorTab(response, request, responseHost, requestHost, callbacks);
		this.tabbedPane.add(extractorTab.getUiComponent());
		this.tabbedPane.setTabComponentAt(index, new ButtonTabComponent(this, this.tabNum));
		this.tabbedPane.setSelectedIndex(index);
		this.extractorTabMap.put(this.tabNum, extractorTab);

		// Now unpause, and write the addition
		Persistor.unpause();
		Persistor.persistExtractor();
		return extractorTab;
	}

	public ExtractorTab createExtractorTab(ExtractorTabState tabState, IBurpExtenderCallbacks callbacks) {
		ExtractorTab extractorTab = this.createExtractorTab(tabState.responseState.content.getBytes(),
				tabState.requestState.content.getBytes(),
				tabState.requestState.targetHost,
				tabState.responseState.targetHost,
				callbacks);
		// Pause Persistor so that we don't have unnecessary writes for each change we make
		Persistor.pause();
		extractorTab.setState(tabState);
		Persistor.unpause();
		Persistor.persistExtractor();
		return extractorTab;
	}

	public ArrayList<ExtractorTab> getExtractorTabs() {
		return new ArrayList<ExtractorTab>(this.extractorTabMap.values());
	}

	public int getIndexOfTabComponent(ButtonTabComponent button) {
		return this.tabbedPane.indexOfTabComponent(button);
	}

	public void removeTab(int index) {
		this.tabbedPane.remove(index);
	}

	public void removeExtractor(int tabNum) {
		this.extractorTabMap.remove(tabNum);
		Persistor.persistExtractor();
	}

	@Override
	public String getTabCaption() {
		return ""Extractor"";
	}

	@Override
	public Component getUiComponent() {
		return this.tabbedPane;
	}
}
","package burp; public class ExtractorMainTab implements ITab { private HashMap extractorTabMap; private ExtractorSelectorTab selectorTab; private int tabNum = 0; static int tabsRemoved = 0; private JTabbedPane tabbedPane; public ExtractorMainTab(IBurpExtenderCallbacks callbacks) { this.extractorTabMap = new HashMap<Integer, ExtractorTab>(); this.tabbedPane = new JTabbedPane(); callbacks.customizeUiComponent(this.tabbedPane); callbacks.addSuiteTab(ExtractorMainTab.this); this.selectorTab = new ExtractorSelectorTab(this, callbacks); this.tabbedPane.add(selectorTab.getUiComponent()); this.tabbedPane.setTabComponentAt(0, new JLabel(""Selection"")); } public void addMessageFromMenu(IHttpRequestResponse message) { this.selectorTab.addMessageFromMenu(message); this.tabbedPane.setSelectedIndex(0); } public ExtractorTab createExtractorTab(byte[] response, byte[] request, String responseHost, String requestHost, IBurpExtenderCallbacks callbacks) { this.tabNum++; int index = (this.tabNum) - this.tabsRemoved; Persistor.pause(); ExtractorTab extractorTab = new ExtractorTab(response, request, responseHost, requestHost, callbacks); this.tabbedPane.add(extractorTab.getUiComponent()); this.tabbedPane.setTabComponentAt(index, new ButtonTabComponent(this, this.tabNum)); this.tabbedPane.setSelectedIndex(index); this.extractorTabMap.put(this.tabNum, extractorTab); Persistor.unpause(); Persistor.persistExtractor(); return extractorTab; } public ExtractorTab createExtractorTab(ExtractorTabState tabState, IBurpExtenderCallbacks callbacks) { ExtractorTab extractorTab = this.createExtractorTab(tabState.responseState.content.getBytes(),
				tabState.requestState.content.getBytes(),
				tabState.requestState.targetHost,
				tabState.responseState.targetHost,
				callbacks); Persistor.pause(); extractorTab.setState(tabState); Persistor.unpause(); Persistor.persistExtractor(); return extractorTab; } public ArrayList<ExtractorTab> getExtractorTabs() { return new ArrayList<ExtractorTab>(this.extractorTabMap.values()); } public int getIndexOfTabComponent(ButtonTabComponent button) { return this.tabbedPane.indexOfTabComponent(button); } public void removeTab(int index) { this.tabbedPane.remove(index); } public void removeExtractor(int tabNum) { this.extractorTabMap.remove(tabNum); Persistor.persistExtractor(); } @Override
	public String getTabCaption() { return ""Extractor""; } @Override
	public Component getUiComponent() { return this.tabbedPane; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package burp; public class ExtractorMainTab implements ITab { private HashMap extractorTabMap; private ExtractorSelectorTab selectorTab; private int tabNum = 0; static int tabsRemoved = 0; private JTabbedPane tabbedPane; public ExtractorMainTab(IBurpExtenderCallbacks callbacks) { this.extractorTabMap = new HashMap<Integer, ExtractorTab>(); this.tabbedPane = new JTabbedPane(); callbacks.customizeUiComponent(this.tabbedPane); callbacks.addSuiteTab(ExtractorMainTab.this); this.selectorTab = new ExtractorSelectorTab(this, callbacks); this.tabbedPane.add(selectorTab.getUiComponent()); this.tabbedPane.setTabComponentAt(0, new JLabel(""Selection"")); } public void addMessageFromMenu(IHttpRequestResponse message) { this.selectorTab.addMessageFromMenu(message); this.tabbedPane.setSelectedIndex(0); } public ExtractorTab createExtractorTab(byte[] response, byte[] request, String responseHost, String requestHost, IBurpExtenderCallbacks callbacks) { this.tabNum++; int index = (this.tabNum) - this.tabsRemoved; Persistor.pause(); ExtractorTab extractorTab = new ExtractorTab(response, request, responseHost, requestHost, callbacks); this.tabbedPane.add(extractorTab.getUiComponent()); this.tabbedPane.setTabComponentAt(index, new ButtonTabComponent(this, this.tabNum)); this.tabbedPane.setSelectedIndex(index); this.extractorTabMap.put(this.tabNum, extractorTab); Persistor.unpause(); Persistor.persistExtractor(); return extractorTab; } public ExtractorTab createExtractorTab(ExtractorTabState tabState, IBurpExtenderCallbacks callbacks) { ExtractorTab extractorTab = this.createExtractorTab(tabState.responseState.content.getBytes(),
				tabState.requestState.content.getBytes(),
				tabState.requestState.targetHost,
				tabState.responseState.targetHost,
				callbacks); Persistor.pause(); extractorTab.setState(tabState); Persistor.unpause(); Persistor.persistExtractor(); return extractorTab; } public ArrayList<ExtractorTab> getExtractorTabs() { return new ArrayList<ExtractorTab>(this.extractorTabMap.values()); } public int getIndexOfTabComponent(ButtonTabComponent button) { return this.tabbedPane.indexOfTabComponent(button); } public void removeTab(int index) { this.tabbedPane.remove(index); } public void removeExtractor(int tabNum) { this.extractorTabMap.remove(tabNum); Persistor.persistExtractor(); } @Override
	public String getTabCaption() { return ""Extractor""; } @Override
	public Component getUiComponent() { return this.tabbedPane; } } ","package burp; 
import burp.persistence.ExtractorTabState; import burp.persistence.Persistor; 
import javax.swing.*; import java.awt.*; import java.util.ArrayList; import java.util.HashMap;  public class ExtractorMainTab implements ITab { private HashMap extractorTabMap; private ExtractorSelectorTab selectorTab; private int tabNum = 0; static int tabsRemoved = 0;  private JTabbedPane tabbedPane;  public ExtractorMainTab(IBurpExtenderCallbacks callbacks) { this.extractorTabMap = new HashMap<Integer, ExtractorTab>(); this.tabbedPane = new JTabbedPane(); callbacks.customizeUiComponent(this.tabbedPane); callbacks.addSuiteTab(ExtractorMainTab.this);  // Create selection tab this.selectorTab = new ExtractorSelectorTab(this, callbacks); this.tabbedPane.add(selectorTab.getUiComponent()); this.tabbedPane.setTabComponentAt(0, new JLabel(""Selection"")); }  public void addMessageFromMenu(IHttpRequestResponse message) { this.selectorTab.addMessageFromMenu(message); this.tabbedPane.setSelectedIndex(0); }  public ExtractorTab createExtractorTab(byte[] response, byte[] request, String responseHost, String requestHost, IBurpExtenderCallbacks callbacks) { this.tabNum++; int index = (this.tabNum) - this.tabsRemoved;  // Pause Persistor so that we don't write values before the tab loads Persistor.pause(); ExtractorTab extractorTab = new ExtractorTab(response, request, responseHost, requestHost, callbacks); this.tabbedPane.add(extractorTab.getUiComponent()); this.tabbedPane.setTabComponentAt(index, new ButtonTabComponent(this, this.tabNum)); this.tabbedPane.setSelectedIndex(index); this.extractorTabMap.put(this.tabNum, extractorTab);  // Now unpause, and write the addition Persistor.unpause(); Persistor.persistExtractor(); return extractorTab; }  public ExtractorTab createExtractorTab(ExtractorTabState tabState, IBurpExtenderCallbacks callbacks) { ExtractorTab extractorTab = this.createExtractorTab(tabState.responseState.content.getBytes(),
				tabState.requestState.content.getBytes(),
				tabState.requestState.targetHost,
				tabState.responseState.targetHost,
				callbacks); // Pause Persistor so that we don't have unnecessary writes for each change we make Persistor.pause(); extractorTab.setState(tabState); Persistor.unpause(); Persistor.persistExtractor(); return extractorTab; }  public ArrayList<ExtractorTab> getExtractorTabs() { return new ArrayList<ExtractorTab>(this.extractorTabMap.values()); }  public int getIndexOfTabComponent(ButtonTabComponent button) { return this.tabbedPane.indexOfTabComponent(button); }  public void removeTab(int index) { this.tabbedPane.remove(index); }  public void removeExtractor(int tabNum) { this.extractorTabMap.remove(tabNum); Persistor.persistExtractor(); }  @Override
	public String getTabCaption() { return ""Extractor""; }  @Override
	public Component getUiComponent() { return this.tabbedPane; } }  "
src/burp/ExtractorMenu.java,"package burp;

import javax.swing.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;

public class ExtractorMenu implements IContextMenuFactory {
	private ExtractorMainTab extractorMainTab;

	public ExtractorMenu(ExtractorMainTab extractorMainTab) {
		this.extractorMainTab = extractorMainTab;
	}

	@Override
	public List<JMenuItem> createMenuItems(IContextMenuInvocation invocation) {
		List<JMenuItem> menuItems = new ArrayList<JMenuItem>();
		JMenuItem menuItem = new JMenuItem(""Send to Extractor"");


		menuItem.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseReleased(MouseEvent e) {
				IHttpRequestResponse[] messages = invocation.getSelectedMessages();

				// grab message if one is selected
				if (messages != null) {
					extractorMainTab.addMessageFromMenu(messages[0]);
				}
			}
		});

		menuItems.add(menuItem);
		return menuItems;
	}
}
","package burp; public class ExtractorMenu implements IContextMenuFactory { private ExtractorMainTab extractorMainTab; public ExtractorMenu(ExtractorMainTab extractorMainTab) { this.extractorMainTab = extractorMainTab; } @Override
	public List<JMenuItem> createMenuItems(IContextMenuInvocation invocation) { List<JMenuItem> menuItems = new ArrayList<JMenuItem>(); JMenuItem menuItem = new JMenuItem(""Send to Extractor""); menuItem.addMouseListener(new MouseAdapter() { @Override
			public void mouseReleased(MouseEvent e) { IHttpRequestResponse[] messages = invocation.getSelectedMessages(); if (messages != null) { extractorMainTab.addMessageFromMenu(messages[0]); } } } ); menuItems.add(menuItem); return menuItems; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package burp; public class ExtractorMenu implements IContextMenuFactory { private ExtractorMainTab extractorMainTab; public ExtractorMenu(ExtractorMainTab extractorMainTab) { this.extractorMainTab = extractorMainTab; } @Override
	public List<JMenuItem> createMenuItems(IContextMenuInvocation invocation) { List<JMenuItem> menuItems = new ArrayList<JMenuItem>(); JMenuItem menuItem = new JMenuItem(""Send to Extractor""); menuItem.addMouseListener(new MouseAdapter() { @Override
			public void mouseReleased(MouseEvent e) { IHttpRequestResponse[] messages = invocation.getSelectedMessages(); if (messages != null) { extractorMainTab.addMessageFromMenu(messages[0]); } } } ); menuItems.add(menuItem); return menuItems; } } ","package burp; 
import javax.swing.*; import java.awt.event.MouseAdapter; import java.awt.event.MouseEvent; import java.util.ArrayList; import java.util.List;  public class ExtractorMenu implements IContextMenuFactory { private ExtractorMainTab extractorMainTab;  public ExtractorMenu(ExtractorMainTab extractorMainTab) { this.extractorMainTab = extractorMainTab; }  @Override
	public List<JMenuItem> createMenuItems(IContextMenuInvocation invocation) { List<JMenuItem> menuItems = new ArrayList<JMenuItem>(); JMenuItem menuItem = new JMenuItem(""Send to Extractor""); 
 menuItem.addMouseListener(new MouseAdapter() { @Override
			public void mouseReleased(MouseEvent e) { IHttpRequestResponse[] messages = invocation.getSelectedMessages();   if (messages != null) { extractorMainTab.addMessageFromMenu(messages[0]); } } } ); // grab message if one is selected menuItems.add(menuItem); return menuItems; } }  "
src/burp/ExtractorSelectorTab.java,"package burp;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableModel;
import java.awt.*;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.event.*;
import java.io.PrintWriter;
import java.io.IOException;

public class ExtractorSelectorTab implements ITab {

	private JTable requestTable;
	private JTable responseTable;
	private ExtractorMainTab mainTab;
	private IBurpExtenderCallbacks callbacks;
	private int messageCount = 0;
	private boolean debugOn;
	private Logger logger;

	public ExtractorSelectorTab(ExtractorMainTab mainTab, IBurpExtenderCallbacks callbacks) {
		this.mainTab = mainTab;
		this.callbacks = callbacks;
		logger = new Logger(new PrintWriter(callbacks.getStdout(), true));
	}

	@Override
	public String getTabCaption() {
		return ""Start"";
	}

	private void addButtonPanel(JPanel pane) {
		GridBagConstraints constraints = new GridBagConstraints();
		constraints.fill = GridBagConstraints.HORIZONTAL;

		// Add set of buttons at top of response table
		JPanel upperButtonPanel = new JPanel();
		upperButtonPanel.setLayout(new GridBagLayout());

		// Add debug button
		JButton debugButton = new JButton(""Debug"");
		debugButton.setBackground(Color.LIGHT_GRAY);
		this.debugOn = false;
		constraints.gridy = 0;
		upperButtonPanel.add(debugButton, constraints);
		debugButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				// Change button state
				debugOn = !debugOn;

				// Change button appearance
				if (debugOn) {
					debugButton.setBackground(Color.GRAY);
					Logger.setLogLevel(Logger.DEBUG);


				} else {
					debugButton.setBackground(Color.LIGHT_GRAY);
					Logger.setLogLevel(Logger.INFO);
				}
			}
		});

		// Add paste button
		JButton pasteButton = new JButton(""Paste"");
		constraints.gridy = 1;
		upperButtonPanel.add(pasteButton, constraints);
		pasteButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				addMessageFromClipboard();
			}
		});

		// Add remove button
		JButton removeButton = new JButton(""Remove"");
		constraints.gridy = 2;
		upperButtonPanel.add(removeButton, constraints);
		removeButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				int[] selectedRequests = requestTable.getSelectedRows();
				DefaultTableModel requestTableModel = (DefaultTableModel) requestTable.getModel();
				int rowsRemoved = 0;
				for (int row : selectedRequests) {
					requestTableModel.removeRow(row - rowsRemoved++);
				}

				int[] selectedResponses = responseTable.getSelectedRows();
				DefaultTableModel responseTableModel = (DefaultTableModel) responseTable.getModel();
				rowsRemoved = 0;
				for (int row : selectedResponses) {
					responseTableModel.removeRow(row - rowsRemoved++);
				}
			}
		});

		// Add clear button
		JButton clearButton = new JButton(""Clear"");
		constraints.gridy = 3;
		upperButtonPanel.add(clearButton, constraints);
		clearButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				// Reset response table
				responseTable.setModel(getTableModel());
				responseTable.removeColumn(responseTable.getColumn(""ByteData""));
				responseTable.removeColumn(responseTable.getColumn(""Host""));

				// Reset request table
				requestTable.setModel(getTableModel());
				requestTable.removeColumn(requestTable.getColumn(""ByteData""));
				requestTable.removeColumn(requestTable.getColumn(""Host""));
			}
		});

		constraints.gridx = 1;
		constraints.gridy = 1;
		constraints.weightx = 0;
		constraints.fill = GridBagConstraints.HORIZONTAL;
		constraints.anchor = GridBagConstraints.NORTH;
		pane.add(upperButtonPanel, constraints);
	}

	private void addGoButton(JPanel pane) {
		GridBagConstraints constraints = new GridBagConstraints();

		JButton goButton = new JButton(""Go"");
		constraints.gridx = 1;
		constraints.gridy = 3;
		constraints.anchor = GridBagConstraints.SOUTH;
		JPanel goPanel = new JPanel();
		goPanel.add(goButton);
		pane.add(goPanel, constraints);
		goButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				int selectedResponse = responseTable.getSelectedRow();
				byte[] response = (byte[]) responseTable.getModel().getValueAt(selectedResponse, 3);
				String responseHost = (String) responseTable.getModel().getValueAt(selectedResponse, 4);

				int selectedRequest = requestTable.getSelectedRow();
				byte[] request = (byte[]) requestTable.getModel().getValueAt(selectedRequest, 3);
				String requestHost = (String) requestTable.getModel().getValueAt(selectedRequest, 4);

				mainTab.createExtractorTab(response, request, responseHost, requestHost, callbacks);
			}
		});
	}

	private void addLabels(JPanel pane) {
		GridBagConstraints constraints = new GridBagConstraints();

		// Create request table label
		JLabel requestLabel = new JLabel(""Select request to insert data into:"");
		requestLabel.setBorder(BorderFactory.createEmptyBorder(4,0,4,0));
		constraints.gridx = 0;
		constraints.gridy = 0;
		constraints.weighty = 0;
		constraints.fill = GridBagConstraints.HORIZONTAL;
		pane.add(requestLabel, constraints);

		// Create response table label
		JLabel responseLabel = new JLabel(""Select response to extract data from:"");
		responseLabel.setBorder(BorderFactory.createEmptyBorder(4,0,4,0));
		constraints.gridx = 0;
		constraints.gridy = 2;
		constraints.weighty = 0;
		constraints.fill = GridBagConstraints.HORIZONTAL;
		pane.add(responseLabel, constraints);
	}

	private void createTables(JPanel pane) {
		GridBagConstraints constraints = new GridBagConstraints();

		// Create request table
		DefaultTableModel requestModel = (DefaultTableModel) getTableModel();
		this.requestTable = new JTable(requestModel) {
			public Component prepareRenderer(TableCellRenderer renderer, int row, int column) {
				Component c = super.prepareRenderer(renderer, row, column);
				c.setForeground(Color.black);
				return c;
			}
		};
		this.requestTable.setAutoCreateRowSorter(true);
		this.requestTable.removeColumn(this.requestTable.getColumn(""ByteData""));
		this.requestTable.removeColumn(this.requestTable.getColumn(""Host""));
		JScrollPane requestScrollPane = new JScrollPane(this.requestTable);
		constraints.gridx = 0;
		constraints.gridy = 1;
		constraints.weighty = 0.5;
		constraints.weightx= 1;
		constraints.fill = GridBagConstraints.BOTH;
		constraints.anchor = GridBagConstraints.CENTER;
		pane.add(requestScrollPane, constraints);

		// Create response table
		DefaultTableModel responseModel = (DefaultTableModel) getTableModel();
		this.responseTable = new JTable(responseModel) {
			public Component prepareRenderer(TableCellRenderer renderer, int row, int column) {
				Component c = super.prepareRenderer(renderer, row, column);
				c.setForeground(Color.black);
				return c;
			}
		};
		this.responseTable.setAutoCreateRowSorter(true);
		this.responseTable.removeColumn(this.responseTable.getColumn(""ByteData""));
		this.responseTable.removeColumn(this.responseTable.getColumn(""Host""));
		JScrollPane responseScrollPane = new JScrollPane(this.responseTable);
		constraints.gridx = 0;
		constraints.gridy = 3;
		constraints.weighty = 0.5;
		constraints.weightx= 1;
		constraints.fill = GridBagConstraints.BOTH;
		pane.add(responseScrollPane, constraints);
	}

	public TableModel getTableModel() {
		return new DefaultTableModel(new Object[] {""#"", ""Length"", ""Data"", ""ByteData"", ""Host""}, 0) {
			public boolean isCellEditable(int row, int column) {
				return false;
			}
		};
	}

	@Override
	public Component getUiComponent() {

		JPanel pane = new JPanel();
		pane.setBorder(BorderFactory.createMatteBorder(5,5,5, 5, new Color(255,255,255)));
		pane.setLayout(new GridBagLayout());
		addLabels(pane);
		addButtonPanel(pane);
		addGoButton(pane);
		createTables(pane);

		return pane;
	}

	public void addMessageFromClipboard() {
		String clipboardData;
		try {
			clipboardData = (String) Toolkit.getDefaultToolkit().getSystemClipboard().getData(DataFlavor.stringFlavor);
		} catch (IOException | UnsupportedFlavorException error) {
			PrintWriter errorWriter = new PrintWriter(callbacks.getStderr());
			errorWriter.println(error.getMessage());
			return;
		}

		DefaultTableModel model = (DefaultTableModel) this.requestTable.getModel();
		model.addRow(new Object[] {this.messageCount, clipboardData.length(), clipboardData, clipboardData.getBytes(), """"});

		model = (DefaultTableModel) this.responseTable.getModel();
		model.addRow(new Object[] {this.messageCount, clipboardData.length(), clipboardData, clipboardData.getBytes(), """"});

		this.messageCount++;
	}

	public void addMessageFromMenu(IHttpRequestResponse message) {
		DefaultTableModel model = (DefaultTableModel) this.requestTable.getModel();
		byte[] request = message.getRequest();
		if (request != null) {
			String requestStr = new String(request);
			model.addRow(new Object[] {this.messageCount, requestStr.length(), requestStr, request, message.getHttpService().getHost()});
		}

		model = (DefaultTableModel) this.responseTable.getModel();
		byte[] response = message.getResponse();
		if (response != null) {
			String responseStr = new String(response);
			model.addRow(new Object[] {this.messageCount, responseStr.length(), responseStr, response, message.getHttpService().getHost()});
		}
		this.messageCount++;
	}
}
","package burp; public class ExtractorSelectorTab implements ITab { private JTable requestTable; private JTable responseTable; private ExtractorMainTab mainTab; private IBurpExtenderCallbacks callbacks; private int messageCount = 0; private boolean debugOn; private Logger logger; public ExtractorSelectorTab(ExtractorMainTab mainTab, IBurpExtenderCallbacks callbacks) { this.mainTab = mainTab; this.callbacks = callbacks; logger = new Logger(new PrintWriter(callbacks.getStdout(), true)); } @Override
	public String getTabCaption() { return ""Start""; } private void addButtonPanel(JPanel pane) { GridBagConstraints constraints = new GridBagConstraints(); constraints.fill = GridBagConstraints.HORIZONTAL; JPanel upperButtonPanel = new JPanel(); upperButtonPanel.setLayout(new GridBagLayout()); JButton debugButton = new JButton(""Debug""); debugButton.setBackground(Color.LIGHT_GRAY); this.debugOn = false; constraints.gridy = 0; upperButtonPanel.add(debugButton, constraints); debugButton.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { debugOn = !debugOn; if (debugOn) { debugButton.setBackground(Color.GRAY); Logger.setLogLevel(Logger.DEBUG); } else { debugButton.setBackground(Color.LIGHT_GRAY); Logger.setLogLevel(Logger.INFO); } } } ); JButton pasteButton = new JButton(""Paste""); constraints.gridy = 1; upperButtonPanel.add(pasteButton, constraints); pasteButton.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { addMessageFromClipboard(); } } ); JButton removeButton = new JButton(""Remove""); constraints.gridy = 2; upperButtonPanel.add(removeButton, constraints); removeButton.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { int[] selectedRequests = requestTable.getSelectedRows(); DefaultTableModel requestTableModel = (DefaultTableModel) requestTable.getModel(); int rowsRemoved = 0; for (int row : selectedRequests) { requestTableModel.removeRow(row - rowsRemoved++); } int[] selectedResponses = responseTable.getSelectedRows(); DefaultTableModel responseTableModel = (DefaultTableModel) responseTable.getModel(); rowsRemoved = 0; for (int row : selectedResponses) { responseTableModel.removeRow(row - rowsRemoved++); } } } ); JButton clearButton = new JButton(""Clear""); constraints.gridy = 3; upperButtonPanel.add(clearButton, constraints); clearButton.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { responseTable.setModel(getTableModel()); responseTable.removeColumn(responseTable.getColumn(""ByteData"")); responseTable.removeColumn(responseTable.getColumn(""Host"")); requestTable.setModel(getTableModel()); requestTable.removeColumn(requestTable.getColumn(""ByteData"")); requestTable.removeColumn(requestTable.getColumn(""Host"")); } } ); constraints.gridx = 1; constraints.gridy = 1; constraints.weightx = 0; constraints.fill = GridBagConstraints.HORIZONTAL; constraints.anchor = GridBagConstraints.NORTH; pane.add(upperButtonPanel, constraints); } private void addGoButton(JPanel pane) { GridBagConstraints constraints = new GridBagConstraints(); JButton goButton = new JButton(""Go""); constraints.gridx = 1; constraints.gridy = 3; constraints.anchor = GridBagConstraints.SOUTH; JPanel goPanel = new JPanel(); goPanel.add(goButton); pane.add(goPanel, constraints); goButton.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { int selectedResponse = responseTable.getSelectedRow(); byte[] response = (byte[]) responseTable.getModel().getValueAt(selectedResponse, 3); String responseHost = (String) responseTable.getModel().getValueAt(selectedResponse, 4); int selectedRequest = requestTable.getSelectedRow(); byte[] request = (byte[]) requestTable.getModel().getValueAt(selectedRequest, 3); String requestHost = (String) requestTable.getModel().getValueAt(selectedRequest, 4); mainTab.createExtractorTab(response, request, responseHost, requestHost, callbacks); } } ); } private void addLabels(JPanel pane) { GridBagConstraints constraints = new GridBagConstraints(); JLabel requestLabel = new JLabel(""Select request to insert data into:""); requestLabel.setBorder(BorderFactory.createEmptyBorder(4,0,4,0)); constraints.gridx = 0; constraints.gridy = 0; constraints.weighty = 0; constraints.fill = GridBagConstraints.HORIZONTAL; pane.add(requestLabel, constraints); JLabel responseLabel = new JLabel(""Select response to extract data from:""); responseLabel.setBorder(BorderFactory.createEmptyBorder(4,0,4,0)); constraints.gridx = 0; constraints.gridy = 2; constraints.weighty = 0; constraints.fill = GridBagConstraints.HORIZONTAL; pane.add(responseLabel, constraints); } private void createTables(JPanel pane) { GridBagConstraints constraints = new GridBagConstraints(); DefaultTableModel requestModel = (DefaultTableModel) getTableModel(); this.requestTable = new JTable(requestModel) { public Component prepareRenderer(TableCellRenderer renderer, int row, int column) { Component c = super.prepareRenderer(renderer, row, column); c.setForeground(Color.black); return c; } } ; this.requestTable.setAutoCreateRowSorter(true); this.requestTable.removeColumn(this.requestTable.getColumn(""ByteData"")); this.requestTable.removeColumn(this.requestTable.getColumn(""Host"")); JScrollPane requestScrollPane = new JScrollPane(this.requestTable); constraints.gridx = 0; constraints.gridy = 1; constraints.weighty = 0.5; constraints.weightx= 1; constraints.fill = GridBagConstraints.BOTH; constraints.anchor = GridBagConstraints.CENTER; pane.add(requestScrollPane, constraints); DefaultTableModel responseModel = (DefaultTableModel) getTableModel(); this.responseTable = new JTable(responseModel) { public Component prepareRenderer(TableCellRenderer renderer, int row, int column) { Component c = super.prepareRenderer(renderer, row, column); c.setForeground(Color.black); return c; } } ; this.responseTable.setAutoCreateRowSorter(true); this.responseTable.removeColumn(this.responseTable.getColumn(""ByteData"")); this.responseTable.removeColumn(this.responseTable.getColumn(""Host"")); JScrollPane responseScrollPane = new JScrollPane(this.responseTable); constraints.gridx = 0; constraints.gridy = 3; constraints.weighty = 0.5; constraints.weightx= 1; constraints.fill = GridBagConstraints.BOTH; pane.add(responseScrollPane, constraints); } public TableModel getTableModel() { return new DefaultTableModel(new Object[] { ""#"", ""Length"", ""Data"", ""ByteData"", ""Host""} , 0) { public boolean isCellEditable(int row, int column) { return false; } } ; } @Override
	public Component getUiComponent() { JPanel pane = new JPanel(); pane.setBorder(BorderFactory.createMatteBorder(5,5,5, 5, new Color(255,255,255))); pane.setLayout(new GridBagLayout()); addLabels(pane); addButtonPanel(pane); addGoButton(pane); createTables(pane); return pane; } public void addMessageFromClipboard() { String clipboardData; try { clipboardData = (String) Toolkit.getDefaultToolkit().getSystemClipboard().getData(DataFlavor.stringFlavor); } catch (IOException | UnsupportedFlavorException error) { PrintWriter errorWriter = new PrintWriter(callbacks.getStderr()); errorWriter.println(error.getMessage()); return; } DefaultTableModel model = (DefaultTableModel) this.requestTable.getModel(); model.addRow(new Object[] { this.messageCount, clipboardData.length(), clipboardData, clipboardData.getBytes(), """"} ); model = (DefaultTableModel) this.responseTable.getModel(); model.addRow(new Object[] { this.messageCount, clipboardData.length(), clipboardData, clipboardData.getBytes(), """"} ); this.messageCount++; } public void addMessageFromMenu(IHttpRequestResponse message) { DefaultTableModel model = (DefaultTableModel) this.requestTable.getModel(); byte[] request = message.getRequest(); if (request != null) { String requestStr = new String(request); model.addRow(new Object[] { this.messageCount, requestStr.length(), requestStr, request, message.getHttpService().getHost()} ); } model = (DefaultTableModel) this.responseTable.getModel(); byte[] response = message.getResponse(); if (response != null) { String responseStr = new String(response); model.addRow(new Object[] { this.messageCount, responseStr.length(), responseStr, response, message.getHttpService().getHost()} ); } this.messageCount++; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package burp; public class ExtractorSelectorTab implements ITab { private JTable requestTable; private JTable responseTable; private ExtractorMainTab mainTab; private IBurpExtenderCallbacks callbacks; private int messageCount = 0; private boolean debugOn; private Logger logger; public ExtractorSelectorTab(ExtractorMainTab mainTab, IBurpExtenderCallbacks callbacks) { this.mainTab = mainTab; this.callbacks = callbacks; logger = new Logger(new PrintWriter(callbacks.getStdout(), true)); } @Override
	public String getTabCaption() { return ""Start""; } private void addButtonPanel(JPanel pane) { GridBagConstraints constraints = new GridBagConstraints(); constraints.fill = GridBagConstraints.HORIZONTAL; JPanel upperButtonPanel = new JPanel(); upperButtonPanel.setLayout(new GridBagLayout()); JButton debugButton = new JButton(""Debug""); debugButton.setBackground(Color.LIGHT_GRAY); this.debugOn = false; constraints.gridy = 0; upperButtonPanel.add(debugButton, constraints); debugButton.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { debugOn = !debugOn; if (debugOn) { debugButton.setBackground(Color.GRAY); Logger.setLogLevel(Logger.DEBUG); } else { debugButton.setBackground(Color.LIGHT_GRAY); Logger.setLogLevel(Logger.INFO); } } } ); JButton pasteButton = new JButton(""Paste""); constraints.gridy = 1; upperButtonPanel.add(pasteButton, constraints); pasteButton.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { addMessageFromClipboard(); } } ); JButton removeButton = new JButton(""Remove""); constraints.gridy = 2; upperButtonPanel.add(removeButton, constraints); removeButton.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { int[] selectedRequests = requestTable.getSelectedRows(); DefaultTableModel requestTableModel = (DefaultTableModel) requestTable.getModel(); int rowsRemoved = 0; for (int row : selectedRequests) { requestTableModel.removeRow(row - rowsRemoved++); } int[] selectedResponses = responseTable.getSelectedRows(); DefaultTableModel responseTableModel = (DefaultTableModel) responseTable.getModel(); rowsRemoved = 0; for (int row : selectedResponses) { responseTableModel.removeRow(row - rowsRemoved++); } } } ); JButton clearButton = new JButton(""Clear""); constraints.gridy = 3; upperButtonPanel.add(clearButton, constraints); clearButton.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { responseTable.setModel(getTableModel()); responseTable.removeColumn(responseTable.getColumn(""ByteData"")); responseTable.removeColumn(responseTable.getColumn(""Host"")); requestTable.setModel(getTableModel()); requestTable.removeColumn(requestTable.getColumn(""ByteData"")); requestTable.removeColumn(requestTable.getColumn(""Host"")); } } ); constraints.gridx = 1; constraints.gridy = 1; constraints.weightx = 0; constraints.fill = GridBagConstraints.HORIZONTAL; constraints.anchor = GridBagConstraints.NORTH; pane.add(upperButtonPanel, constraints); } private void addGoButton(JPanel pane) { GridBagConstraints constraints = new GridBagConstraints(); JButton goButton = new JButton(""Go""); constraints.gridx = 1; constraints.gridy = 3; constraints.anchor = GridBagConstraints.SOUTH; JPanel goPanel = new JPanel(); goPanel.add(goButton); pane.add(goPanel, constraints); goButton.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { int selectedResponse = responseTable.getSelectedRow(); byte[] response = (byte[]) responseTable.getModel().getValueAt(selectedResponse, 3); String responseHost = (String) responseTable.getModel().getValueAt(selectedResponse, 4); int selectedRequest = requestTable.getSelectedRow(); byte[] request = (byte[]) requestTable.getModel().getValueAt(selectedRequest, 3); String requestHost = (String) requestTable.getModel().getValueAt(selectedRequest, 4); mainTab.createExtractorTab(response, request, responseHost, requestHost, callbacks); } } ); } private void addLabels(JPanel pane) { GridBagConstraints constraints = new GridBagConstraints(); JLabel requestLabel = new JLabel(""Select request to insert data into:""); requestLabel.setBorder(BorderFactory.createEmptyBorder(4,0,4,0)); constraints.gridx = 0; constraints.gridy = 0; constraints.weighty = 0; constraints.fill = GridBagConstraints.HORIZONTAL; pane.add(requestLabel, constraints); JLabel responseLabel = new JLabel(""Select response to extract data from:""); responseLabel.setBorder(BorderFactory.createEmptyBorder(4,0,4,0)); constraints.gridx = 0; constraints.gridy = 2; constraints.weighty = 0; constraints.fill = GridBagConstraints.HORIZONTAL; pane.add(responseLabel, constraints); } private void createTables(JPanel pane) { GridBagConstraints constraints = new GridBagConstraints(); DefaultTableModel requestModel = (DefaultTableModel) getTableModel(); this.requestTable = new JTable(requestModel) { public Component prepareRenderer(TableCellRenderer renderer, int row, int column) { Component c = super.prepareRenderer(renderer, row, column); c.setForeground(Color.black); return c; } } ; this.requestTable.setAutoCreateRowSorter(true); this.requestTable.removeColumn(this.requestTable.getColumn(""ByteData"")); this.requestTable.removeColumn(this.requestTable.getColumn(""Host"")); JScrollPane requestScrollPane = new JScrollPane(this.requestTable); constraints.gridx = 0; constraints.gridy = 1; constraints.weighty = 0.5; constraints.weightx= 1; constraints.fill = GridBagConstraints.BOTH; constraints.anchor = GridBagConstraints.CENTER; pane.add(requestScrollPane, constraints); DefaultTableModel responseModel = (DefaultTableModel) getTableModel(); this.responseTable = new JTable(responseModel) { public Component prepareRenderer(TableCellRenderer renderer, int row, int column) { Component c = super.prepareRenderer(renderer, row, column); c.setForeground(Color.black); return c; } } ; this.responseTable.setAutoCreateRowSorter(true); this.responseTable.removeColumn(this.responseTable.getColumn(""ByteData"")); this.responseTable.removeColumn(this.responseTable.getColumn(""Host"")); JScrollPane responseScrollPane = new JScrollPane(this.responseTable); constraints.gridx = 0; constraints.gridy = 3; constraints.weighty = 0.5; constraints.weightx= 1; constraints.fill = GridBagConstraints.BOTH; pane.add(responseScrollPane, constraints); } public TableModel getTableModel() { return new DefaultTableModel(new Object[] { ""#"", ""Length"", ""Data"", ""ByteData"", ""Host""} , 0) { public boolean isCellEditable(int row, int column) { return false; } } ; } @Override
	public Component getUiComponent() { JPanel pane = new JPanel(); pane.setBorder(BorderFactory.createMatteBorder(5,5,5, 5, new Color(255,255,255))); pane.setLayout(new GridBagLayout()); addLabels(pane); addButtonPanel(pane); addGoButton(pane); createTables(pane); return pane; } public void addMessageFromClipboard() { String clipboardData; try { clipboardData = (String) Toolkit.getDefaultToolkit().getSystemClipboard().getData(DataFlavor.stringFlavor); } catch (IOException | UnsupportedFlavorException error) { PrintWriter errorWriter = new PrintWriter(callbacks.getStderr()); errorWriter.println(error.getMessage()); return; } DefaultTableModel model = (DefaultTableModel) this.requestTable.getModel(); model.addRow(new Object[] { this.messageCount, clipboardData.length(), clipboardData, clipboardData.getBytes(), """"} ); model = (DefaultTableModel) this.responseTable.getModel(); model.addRow(new Object[] { this.messageCount, clipboardData.length(), clipboardData, clipboardData.getBytes(), """"} ); this.messageCount++; } public void addMessageFromMenu(IHttpRequestResponse message) { DefaultTableModel model = (DefaultTableModel) this.requestTable.getModel(); byte[] request = message.getRequest(); if (request != null) { String requestStr = new String(request); model.addRow(new Object[] { this.messageCount, requestStr.length(), requestStr, request, message.getHttpService().getHost()} ); } model = (DefaultTableModel) this.responseTable.getModel(); byte[] response = message.getResponse(); if (response != null) { String responseStr = new String(response); model.addRow(new Object[] { this.messageCount, responseStr.length(), responseStr, response, message.getHttpService().getHost()} ); } this.messageCount++; } } ","package burp; 
import javax.swing.*; import javax.swing.table.DefaultTableModel; import javax.swing.table.TableCellRenderer; import javax.swing.table.TableModel; import java.awt.*; import java.awt.datatransfer.DataFlavor; import java.awt.datatransfer.UnsupportedFlavorException; import java.awt.event.*; import java.io.PrintWriter; import java.io.IOException;  public class ExtractorSelectorTab implements ITab {  private JTable requestTable; private JTable responseTable; private ExtractorMainTab mainTab; private IBurpExtenderCallbacks callbacks; private int messageCount = 0; private boolean debugOn; private Logger logger;  public ExtractorSelectorTab(ExtractorMainTab mainTab, IBurpExtenderCallbacks callbacks) { this.mainTab = mainTab; this.callbacks = callbacks; logger = new Logger(new PrintWriter(callbacks.getStdout(), true)); }  @Override
	public String getTabCaption() { return ""Start""; }  private void addButtonPanel(JPanel pane) { GridBagConstraints constraints = new GridBagConstraints(); constraints.fill = GridBagConstraints.HORIZONTAL;  // Add set of buttons at top of response table JPanel upperButtonPanel = new JPanel(); upperButtonPanel.setLayout(new GridBagLayout());  // Add debug button JButton debugButton = new JButton(""Debug""); debugButton.setBackground(Color.LIGHT_GRAY); this.debugOn = false; constraints.gridy = 0; upperButtonPanel.add(debugButton, constraints); debugButton.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { // Change button state debugOn = !debugOn;  // Change button appearance if (debugOn) { debugButton.setBackground(Color.GRAY); Logger.setLogLevel(Logger.DEBUG); 
 } else { debugButton.setBackground(Color.LIGHT_GRAY); Logger.setLogLevel(Logger.INFO); } } } );   JButton pasteButton = new JButton(""Paste""); constraints.gridy = 1; upperButtonPanel.add(pasteButton, constraints); pasteButton.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { addMessageFromClipboard(); } } ); // Add paste button  JButton removeButton = new JButton(""Remove""); constraints.gridy = 2; upperButtonPanel.add(removeButton, constraints); removeButton.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { int[] selectedRequests = requestTable.getSelectedRows(); DefaultTableModel requestTableModel = (DefaultTableModel) requestTable.getModel(); int rowsRemoved = 0; for (int row : selectedRequests) { requestTableModel.removeRow(row - rowsRemoved++); } // Add remove button int[] selectedResponses = responseTable.getSelectedRows(); DefaultTableModel responseTableModel = (DefaultTableModel) responseTable.getModel(); rowsRemoved = 0; for (int row : selectedResponses) { responseTableModel.removeRow(row - rowsRemoved++); } } } );   JButton clearButton = new JButton(""Clear""); constraints.gridy = 3; upperButtonPanel.add(clearButton, constraints); clearButton.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { // Add clear button responseTable.setModel(getTableModel()); responseTable.removeColumn(responseTable.getColumn(""ByteData"")); responseTable.removeColumn(responseTable.getColumn(""Host"")); // Reset response table  requestTable.setModel(getTableModel()); requestTable.removeColumn(requestTable.getColumn(""ByteData"")); requestTable.removeColumn(requestTable.getColumn(""Host"")); } } ); // Reset request table constraints.gridx = 1; constraints.gridy = 1; constraints.weightx = 0; constraints.fill = GridBagConstraints.HORIZONTAL; constraints.anchor = GridBagConstraints.NORTH; pane.add(upperButtonPanel, constraints); }  private void addGoButton(JPanel pane) { GridBagConstraints constraints = new GridBagConstraints();  JButton goButton = new JButton(""Go""); constraints.gridx = 1; constraints.gridy = 3; constraints.anchor = GridBagConstraints.SOUTH; JPanel goPanel = new JPanel(); goPanel.add(goButton); pane.add(goPanel, constraints); goButton.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { int selectedResponse = responseTable.getSelectedRow(); byte[] response = (byte[]) responseTable.getModel().getValueAt(selectedResponse, 3); String responseHost = (String) responseTable.getModel().getValueAt(selectedResponse, 4);  int selectedRequest = requestTable.getSelectedRow(); byte[] request = (byte[]) requestTable.getModel().getValueAt(selectedRequest, 3); String requestHost = (String) requestTable.getModel().getValueAt(selectedRequest, 4);  mainTab.createExtractorTab(response, request, responseHost, requestHost, callbacks); } } ); }  private void addLabels(JPanel pane) { GridBagConstraints constraints = new GridBagConstraints();   JLabel requestLabel = new JLabel(""Select request to insert data into:""); requestLabel.setBorder(BorderFactory.createEmptyBorder(4,0,4,0)); constraints.gridx = 0; constraints.gridy = 0; constraints.weighty = 0; constraints.fill = GridBagConstraints.HORIZONTAL; pane.add(requestLabel, constraints); // Create request table label  JLabel responseLabel = new JLabel(""Select response to extract data from:""); responseLabel.setBorder(BorderFactory.createEmptyBorder(4,0,4,0)); constraints.gridx = 0; constraints.gridy = 2; constraints.weighty = 0; constraints.fill = GridBagConstraints.HORIZONTAL; pane.add(responseLabel, constraints); } // Create response table label private void createTables(JPanel pane) { GridBagConstraints constraints = new GridBagConstraints();   DefaultTableModel requestModel = (DefaultTableModel) getTableModel(); this.requestTable = new JTable(requestModel) { public Component prepareRenderer(TableCellRenderer renderer, int row, int column) { Component c = super.prepareRenderer(renderer, row, column); c.setForeground(Color.black); return c; } } ; this.requestTable.setAutoCreateRowSorter(true); this.requestTable.removeColumn(this.requestTable.getColumn(""ByteData"")); this.requestTable.removeColumn(this.requestTable.getColumn(""Host"")); JScrollPane requestScrollPane = new JScrollPane(this.requestTable); constraints.gridx = 0; constraints.gridy = 1; constraints.weighty = 0.5; constraints.weightx= 1; constraints.fill = GridBagConstraints.BOTH; constraints.anchor = GridBagConstraints.CENTER; pane.add(requestScrollPane, constraints); // Create request table  DefaultTableModel responseModel = (DefaultTableModel) getTableModel(); this.responseTable = new JTable(responseModel) { public Component prepareRenderer(TableCellRenderer renderer, int row, int column) { Component c = super.prepareRenderer(renderer, row, column); c.setForeground(Color.black); return c; } } ; this.responseTable.setAutoCreateRowSorter(true); this.responseTable.removeColumn(this.responseTable.getColumn(""ByteData"")); this.responseTable.removeColumn(this.responseTable.getColumn(""Host"")); JScrollPane responseScrollPane = new JScrollPane(this.responseTable); constraints.gridx = 0; constraints.gridy = 3; constraints.weighty = 0.5; constraints.weightx= 1; constraints.fill = GridBagConstraints.BOTH; pane.add(responseScrollPane, constraints); } // Create response table public TableModel getTableModel() { return new DefaultTableModel(new Object[] { ""#"", ""Length"", ""Data"", ""ByteData"", ""Host""} , 0) { public boolean isCellEditable(int row, int column) { return false; } } ; }  @Override
	public Component getUiComponent() {  JPanel pane = new JPanel(); pane.setBorder(BorderFactory.createMatteBorder(5,5,5, 5, new Color(255,255,255))); pane.setLayout(new GridBagLayout()); addLabels(pane); addButtonPanel(pane); addGoButton(pane); createTables(pane);  return pane; }  public void addMessageFromClipboard() { String clipboardData; try { clipboardData = (String) Toolkit.getDefaultToolkit().getSystemClipboard().getData(DataFlavor.stringFlavor); } catch (IOException | UnsupportedFlavorException error) { PrintWriter errorWriter = new PrintWriter(callbacks.getStderr()); errorWriter.println(error.getMessage()); return; }  DefaultTableModel model = (DefaultTableModel) this.requestTable.getModel(); model.addRow(new Object[] { this.messageCount, clipboardData.length(), clipboardData, clipboardData.getBytes(), """"} );  model = (DefaultTableModel) this.responseTable.getModel(); model.addRow(new Object[] { this.messageCount, clipboardData.length(), clipboardData, clipboardData.getBytes(), """"} );  this.messageCount++; }  public void addMessageFromMenu(IHttpRequestResponse message) { DefaultTableModel model = (DefaultTableModel) this.requestTable.getModel(); byte[] request = message.getRequest(); if (request != null) { String requestStr = new String(request); model.addRow(new Object[] { this.messageCount, requestStr.length(), requestStr, request, message.getHttpService().getHost()} ); }  model = (DefaultTableModel) this.responseTable.getModel(); byte[] response = message.getResponse(); if (response != null) { String responseStr = new String(response); model.addRow(new Object[] { this.messageCount, responseStr.length(), responseStr, response, message.getHttpService().getHost()} ); } this.messageCount++; } }  "
src/burp/ExtractorTab.java,"package burp;

import burp.persistence.RequestResponseState;
import burp.persistence.ExtractorTabState;

import java.awt.*;
import java.awt.event.*;
import java.net.URL;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.*;
import javax.swing.border.EmptyBorder;

public class ExtractorTab implements ITab {

	private IBurpExtenderCallbacks callbacks;
	private JSplitPane splitPane;
	private JPanel topPane;
	private JButton modifyRequests;
	private boolean extractorOn;
	private ExtractorEditor requestEditor;
	private ExtractorEditor responseEditor;
	private JTextArea dataToInsert;
	private Font normalFont;
	private Font boldFont;


	public ExtractorTab(byte[] response, byte[] request, String responseHost, String requestHost, final IBurpExtenderCallbacks callbacks) {
		this.callbacks = callbacks;

		this.topPane = new JPanel();
		topPane.setLayout(new BoxLayout(topPane, BoxLayout.Y_AXIS));

		// Build split pane
		this.splitPane = new JSplitPane();
		this.splitPane.setResizeWeight(0.5);
		JPanel leftPane = new JPanel();
		leftPane.setLayout(new GridBagLayout());
		leftPane.setBorder(BorderFactory.createEmptyBorder(0,0,0,4));
		this.splitPane.setLeftComponent(leftPane);
		JPanel rightPane = new JPanel();
		rightPane.setLayout(new GridBagLayout());
		rightPane.setBorder(BorderFactory.createEmptyBorder(0,4,0,0));
		this.splitPane.setRightComponent(rightPane);
		GridBagConstraints constraints = new GridBagConstraints();
		constraints.insets = new Insets(2,2,2,2);


		// Make our headers
		JLabel requestHeader = new JLabel(""Request"");
		constraints.gridx = 0;
		constraints.gridy = 0;
		constraints.gridwidth = 2;
		constraints.fill = GridBagConstraints.NONE;
		this.normalFont = requestHeader.getFont();
		this.boldFont = new Font(this.normalFont.getFontName(), Font.BOLD, this.normalFont.getSize());
		requestHeader.setFont(this.boldFont);
		leftPane.add(requestHeader, constraints);

		JLabel responseHeader = new JLabel(""Response"");
		constraints.gridx = 0;
		constraints.gridy = 0;
		constraints.gridwidth = 1;
		responseHeader.setFont(this.boldFont);
		rightPane.add(responseHeader, constraints);

		// Add field to show the value which will be injected into requests
		JLabel insertIntoRequestLabel = new JLabel(""Value to insert:"");
		constraints.gridx = 0;
		constraints.gridy = 1;
		constraints.anchor = GridBagConstraints.WEST;
		constraints.fill = GridBagConstraints.NONE;
		leftPane.add(insertIntoRequestLabel, constraints);

		this.dataToInsert = new JTextArea();
		constraints.gridx = 1;
		constraints.gridy = 1;
		constraints.fill = GridBagConstraints.HORIZONTAL;
		leftPane.add(dataToInsert, constraints);

		// Made button to dictate whether or not the extension is active
		JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEADING));
		buttonPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
		this.modifyRequests = new JButton(""Turn Extractor on"");
		this.modifyRequests.setFont(this.boldFont);
		this.modifyRequests.setBackground(Color.LIGHT_GRAY);
		this.extractorOn = false;
		buttonPanel.add(this.modifyRequests);
		this.modifyRequests.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				// Change button state
				extractorOn = !extractorOn;

				// Change button appearance
				if (extractorOn) {
					modifyRequests.setBackground(Color.GRAY);
					modifyRequests.setText(""Turn Extractor off"");
				} else {
					modifyRequests.setBackground(Color.LIGHT_GRAY);
					modifyRequests.setText(""Turn Extractor on"");
				}
			}
		});

		// Create help button
		JButton helpButton = new JButton(""?"");
		buttonPanel.add(helpButton);
		JPopupMenu menu = new JPopupMenu();
		menu.add(getHelpContents());
		helpButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				menu.show(helpButton, e.getX(), e.getY());
			}
		});

		topPane.add(buttonPanel);
		topPane.add(splitPane);

		// Create two editor panels. One for requests and one for responses
		this.requestEditor = new ExtractorEditor(callbacks);
		constraints.gridx = 0;
		constraints.gridy = 2;
		constraints.gridwidth = 2;
		constraints.fill = GridBagConstraints.BOTH;
		constraints.weightx = 0.5;
		constraints.weighty = 1;
		leftPane.add(requestEditor.getUIComponent(), constraints);

		this.responseEditor = new ExtractorEditor(callbacks);
		this.responseEditor.getUIComponent().setBorder(new EmptyBorder(32, 0, 0, 0));
		constraints.gridx = 0;
		constraints.gridy = 1;
		constraints.fill = GridBagConstraints.BOTH;
		constraints.weightx = 0.5;
		constraints.weighty = 1;
		constraints.gridwidth = 1;
		rightPane.add(responseEditor.getUIComponent(), constraints);

		// If this tab was created from the menu, we should be able to populate the request and response
		if (response != null && request != null) {
			this.setRequestMessage(request, requestHost);
			this.setResponseMessage(response, responseHost);
		}

		callbacks.customizeUiComponent(this.topPane);
	}

	public void setRequestMessage(byte[] message, String host) {
		this.requestEditor.setTargetHost(host);
		this.requestEditor.fillTextArea(message);
	}

	public void setResponseMessage(byte[] message, String host) {
		this.responseEditor.setTargetHost(host);
		this.responseEditor.fillTextArea(message);
	}

	// Get the regex string to select the intended text for replacement in the request
	public String[] getRequestSelectionRegex() {
		return this.requestEditor.getSelectionRegex();
	}

	// Get the regex string to select the text we want to replay somewhere in our requests
	public String[] getResponseSelectionRegex() {
		return this.responseEditor.getSelectionRegex();
	}

	// Returns true if the user has made the extension currently active, and the tool is selected
	public boolean shouldModifyRequests() {
		return this.extractorOn;
	}

	// Generalize checking scope
	private boolean messageIsInScope(ExtractorEditor editor, URL url, String host, int toolFlag) {
		if (!editor.isToolSelected(toolFlag)) {
			return false;
		}
		if (editor.useSuiteScope()) {
			return this.callbacks.isInScope(url);
		} else {
			if (editor.useRegexForTarget()) {
				Pattern targetPattern = Pattern.compile(editor.getTargetHost());
				Matcher targetMatcher = targetPattern.matcher(host);

				return targetMatcher.find();
			} else {
				return host.equals(editor.getTargetHost());
			}
		}
	}

	// Determine if the given URL and tool is in scope as defined by suite scope or a custom host
	public boolean requestIsInScope(URL url, String host, int toolFlag) {
		return messageIsInScope(this.requestEditor, url, host, toolFlag);
	}

	// Determine if the given URL and tool is in scope as defined by suite scope or a custom host
	public boolean responseIsInScope(URL url, String host, int toolFlag) {
		return messageIsInScope(this.responseEditor, url, host, toolFlag);
	}

	public String getDataToInsert() {
		return this.dataToInsert.getText();
	}

	public void setDataToInsert(String data) {
		this.dataToInsert.setText(data);
	}

	private JPanel getHelpContents() {
		JPanel helpPanel = new JPanel();
		helpPanel.setLayout(new BoxLayout(helpPanel, BoxLayout.Y_AXIS));

		// Add large title
		JPanel titlePanel = new JPanel(new FlowLayout(FlowLayout.LEADING));
		titlePanel.add(Box.createHorizontalGlue());
		JLabel titleLabel = new JLabel(""Burp Extractor"");
		titleLabel.setBorder(new EmptyBorder(0,0,0,0));
		titleLabel.setFont(new Font(this.normalFont.getName(), Font.BOLD, this.normalFont.getSize() + 2));
		titlePanel.add(titleLabel, Component.LEFT_ALIGNMENT);
		helpPanel.add(titlePanel);

		// Add main scroll pane
		JPanel helpScrollPanel = new JPanel();
		helpScrollPanel.setLayout(new BoxLayout(helpScrollPanel, BoxLayout.Y_AXIS));
		JScrollPane scrollPane = new JScrollPane(helpScrollPanel);
		scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
		scrollPane.setViewportView(helpScrollPanel);
//		scrollPane.setPreferredSize(new Dimension(500,300));
		helpPanel.add(scrollPane);

		// Add text selection instructions
		JLabel highlightTitle = new JLabel(""Text Selection"");
		highlightTitle.setBorder(new EmptyBorder(5,5,5,5));
		highlightTitle.setFont(this.boldFont);
		helpScrollPanel.add(highlightTitle);
		JLabel highlightInstructions = new JLabel(""<html><body style='width: 475px'><p>Highlight the text in the "" +
				""request you would like to replace with data from the response. In the response, highlight the text "" +
				""you would like to extract and have inserted into the request. Extractor will "" +
				""define regex for you when you select text in the request and response editors.</p><p>If you want to "" +
				""make customizations to those regex strings, you can! Just make sure that you escape characters that "" +
				""are have special regex meaning. That seems to be anything in this list, though there may be "" +
				""something missing: !$^&*()-+{[}]|\\:,.?</p></body></html>"");
		helpScrollPanel.add(highlightInstructions);

		// Add scope instructions
		JLabel scopeTitle = new JLabel(""Defining scope"");
		scopeTitle.setBorder(new EmptyBorder(5,5,5,5));
		scopeTitle.setFont(this.boldFont);
		helpScrollPanel.add(scopeTitle);
		helpScrollPanel.add(new JLabel(""<html><body style='width: 475px'><p>Users can define scope using both "" +
				""the host and the tools to target. Either a user can select \""Use suite scope\"" which will cause Extractor to "" +
				""examine a request if it is in Burp Suite's scope. Otherwise, the \""Target host\"" field will be "" +
				""examined, and a message from a matching host will cause Extractor to examine it."" +
				""</p><p>Use the \""Select in-scope tools\"" button to select the tools that Extractor will "" +
				""examine for matching tokens.</p></body></html>""));

		// Running Extractor
		JLabel runningTitle = new JLabel(""Running Extractor"");
		runningTitle.setBorder(new EmptyBorder(5,5,5,5));
		runningTitle.setFont(this.boldFont);
		helpScrollPanel.add(runningTitle);
		helpScrollPanel.add(new JLabel(""<html><body style='width:475px'><p>To start altering requests with "" +
				""Extractor, just click \""Turn Extractor on\"". Extractor will begin examining in-scope requests and "" +
				""responses for text which matches the before and after regex fields. Once Extractor "" +
				""has found a match in a response, it will save the text, and write it to the selected location in the "" +
				""request. Multiple Extractor tabs can be used at once, and will execute in the order they were created."" +
				""</p></body></html>""));

		return helpPanel;
	}

	public ExtractorTabState getTabState() {
		// Build request state
		RequestResponseState requestState = this.requestEditor.getEditorState();

		// Build response state
		RequestResponseState responseState = this.responseEditor.getEditorState();

		return new ExtractorTabState(requestState, responseState);
	}

	public void setState(ExtractorTabState state) {
		this.requestEditor.setEditorState(state.requestState);
		this.responseEditor.setEditorState(state.responseState);
	}

	@Override
	public String getTabCaption() {
		return ""Extractor"";
	}

	@Override
	public Component getUiComponent() {
		return this.topPane;
	}
}
","package burp; public class ExtractorTab implements ITab { private IBurpExtenderCallbacks callbacks; private JSplitPane splitPane; private JPanel topPane; private JButton modifyRequests; private boolean extractorOn; private ExtractorEditor requestEditor; private ExtractorEditor responseEditor; private JTextArea dataToInsert; private Font normalFont; private Font boldFont; public ExtractorTab(byte[] response, byte[] request, String responseHost, String requestHost, final IBurpExtenderCallbacks callbacks) { this.callbacks = callbacks; this.topPane = new JPanel(); topPane.setLayout(new BoxLayout(topPane, BoxLayout.Y_AXIS)); this.splitPane = new JSplitPane(); this.splitPane.setResizeWeight(0.5); JPanel leftPane = new JPanel(); leftPane.setLayout(new GridBagLayout()); leftPane.setBorder(BorderFactory.createEmptyBorder(0,0,0,4)); this.splitPane.setLeftComponent(leftPane); JPanel rightPane = new JPanel(); rightPane.setLayout(new GridBagLayout()); rightPane.setBorder(BorderFactory.createEmptyBorder(0,4,0,0)); this.splitPane.setRightComponent(rightPane); GridBagConstraints constraints = new GridBagConstraints(); constraints.insets = new Insets(2,2,2,2); JLabel requestHeader = new JLabel(""Request""); constraints.gridx = 0; constraints.gridy = 0; constraints.gridwidth = 2; constraints.fill = GridBagConstraints.NONE; this.normalFont = requestHeader.getFont(); this.boldFont = new Font(this.normalFont.getFontName(), Font.BOLD, this.normalFont.getSize()); requestHeader.setFont(this.boldFont); leftPane.add(requestHeader, constraints); JLabel responseHeader = new JLabel(""Response""); constraints.gridx = 0; constraints.gridy = 0; constraints.gridwidth = 1; responseHeader.setFont(this.boldFont); rightPane.add(responseHeader, constraints); JLabel insertIntoRequestLabel = new JLabel(""Value to insert:""); constraints.gridx = 0; constraints.gridy = 1; constraints.anchor = GridBagConstraints.WEST; constraints.fill = GridBagConstraints.NONE; leftPane.add(insertIntoRequestLabel, constraints); this.dataToInsert = new JTextArea(); constraints.gridx = 1; constraints.gridy = 1; constraints.fill = GridBagConstraints.HORIZONTAL; leftPane.add(dataToInsert, constraints); JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEADING)); buttonPanel.setAlignmentX(Component.LEFT_ALIGNMENT); this.modifyRequests = new JButton(""Turn Extractor on""); this.modifyRequests.setFont(this.boldFont); this.modifyRequests.setBackground(Color.LIGHT_GRAY); this.extractorOn = false; buttonPanel.add(this.modifyRequests); this.modifyRequests.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { extractorOn = !extractorOn; if (extractorOn) { modifyRequests.setBackground(Color.GRAY); modifyRequests.setText(""Turn Extractor off""); } else { modifyRequests.setBackground(Color.LIGHT_GRAY); modifyRequests.setText(""Turn Extractor on""); } } } ); JButton helpButton = new JButton(""?""); buttonPanel.add(helpButton); JPopupMenu menu = new JPopupMenu(); menu.add(getHelpContents()); helpButton.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { menu.show(helpButton, e.getX(), e.getY()); } } ); topPane.add(buttonPanel); topPane.add(splitPane); this.requestEditor = new ExtractorEditor(callbacks); constraints.gridx = 0; constraints.gridy = 2; constraints.gridwidth = 2; constraints.fill = GridBagConstraints.BOTH; constraints.weightx = 0.5; constraints.weighty = 1; leftPane.add(requestEditor.getUIComponent(), constraints); this.responseEditor = new ExtractorEditor(callbacks); this.responseEditor.getUIComponent().setBorder(new EmptyBorder(32, 0, 0, 0)); constraints.gridx = 0; constraints.gridy = 1; constraints.fill = GridBagConstraints.BOTH; constraints.weightx = 0.5; constraints.weighty = 1; constraints.gridwidth = 1; rightPane.add(responseEditor.getUIComponent(), constraints); if (response != null && request != null) { this.setRequestMessage(request, requestHost); this.setResponseMessage(response, responseHost); } callbacks.customizeUiComponent(this.topPane); } public void setRequestMessage(byte[] message, String host) { this.requestEditor.setTargetHost(host); this.requestEditor.fillTextArea(message); } public void setResponseMessage(byte[] message, String host) { this.responseEditor.setTargetHost(host); this.responseEditor.fillTextArea(message); } public String[] getRequestSelectionRegex() { return this.requestEditor.getSelectionRegex(); } public String[] getResponseSelectionRegex() { return this.responseEditor.getSelectionRegex(); } public boolean shouldModifyRequests() { return this.extractorOn; } private boolean messageIsInScope(ExtractorEditor editor, URL url, String host, int toolFlag) { if (!editor.isToolSelected(toolFlag)) { return false; } if (editor.useSuiteScope()) { return this.callbacks.isInScope(url); } else { if (editor.useRegexForTarget()) { Pattern targetPattern = Pattern.compile(editor.getTargetHost()); Matcher targetMatcher = targetPattern.matcher(host); return targetMatcher.find(); } else { return host.equals(editor.getTargetHost()); } } } public boolean requestIsInScope(URL url, String host, int toolFlag) { return messageIsInScope(this.requestEditor, url, host, toolFlag); } public boolean responseIsInScope(URL url, String host, int toolFlag) { return messageIsInScope(this.responseEditor, url, host, toolFlag); } public String getDataToInsert() { return this.dataToInsert.getText(); } public void setDataToInsert(String data) { this.dataToInsert.setText(data); } private JPanel getHelpContents() { JPanel helpPanel = new JPanel(); helpPanel.setLayout(new BoxLayout(helpPanel, BoxLayout.Y_AXIS)); JPanel titlePanel = new JPanel(new FlowLayout(FlowLayout.LEADING)); titlePanel.add(Box.createHorizontalGlue()); JLabel titleLabel = new JLabel(""Burp Extractor""); titleLabel.setBorder(new EmptyBorder(0,0,0,0)); titleLabel.setFont(new Font(this.normalFont.getName(), Font.BOLD, this.normalFont.getSize() + 2)); titlePanel.add(titleLabel, Component.LEFT_ALIGNMENT); helpPanel.add(titlePanel); JPanel helpScrollPanel = new JPanel(); helpScrollPanel.setLayout(new BoxLayout(helpScrollPanel, BoxLayout.Y_AXIS)); JScrollPane scrollPane = new JScrollPane(helpScrollPanel); scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER); scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS); scrollPane.setViewportView(helpScrollPanel); helpPanel.add(scrollPane); JLabel highlightTitle = new JLabel(""Text Selection""); highlightTitle.setBorder(new EmptyBorder(5,5,5,5)); highlightTitle.setFont(this.boldFont); helpScrollPanel.add(highlightTitle); JLabel highlightInstructions = new JLabel(""<html><body style='width: 475px'><p>Highlight the text in the "" +
				""request you would like to replace with data from the response. In the response, highlight the text "" +
				""you would like to extract and have inserted into the request. Extractor will "" +
				""define regex for you when you select text in the request and response editors.</p><p>If you want to "" +
				""make customizations to those regex strings, you can! Just make sure that you escape characters that "" +
				""are have special regex meaning. That seems to be anything in this list, though there may be "" +
				""something missing: !$^&*()-+{ [} ]|\\:,.?</p></body></html>""); helpScrollPanel.add(highlightInstructions); JLabel scopeTitle = new JLabel(""Defining scope""); scopeTitle.setBorder(new EmptyBorder(5,5,5,5)); scopeTitle.setFont(this.boldFont); helpScrollPanel.add(scopeTitle); helpScrollPanel.add(new JLabel(""<html><body style='width: 475px'><p>Users can define scope using both "" +
				""the host and the tools to target. Either a user can select \""Use suite scope\"" which will cause Extractor to "" +
				""examine a request if it is in Burp Suite's scope. Otherwise, the \""Target host\"" field will be "" +
				""examined, and a message from a matching host will cause Extractor to examine it."" +
				""</p><p>Use the \""Select in-scope tools\"" button to select the tools that Extractor will "" +
				""examine for matching tokens.</p></body></html>"")); JLabel runningTitle = new JLabel(""Running Extractor""); runningTitle.setBorder(new EmptyBorder(5,5,5,5)); runningTitle.setFont(this.boldFont); helpScrollPanel.add(runningTitle); helpScrollPanel.add(new JLabel(""<html><body style='width:475px'><p>To start altering requests with "" +
				""Extractor, just click \""Turn Extractor on\"". Extractor will begin examining in-scope requests and "" +
				""responses for text which matches the before and after regex fields. Once Extractor "" +
				""has found a match in a response, it will save the text, and write it to the selected location in the "" +
				""request. Multiple Extractor tabs can be used at once, and will execute in the order they were created."" +
				""</p></body></html>"")); return helpPanel; } public ExtractorTabState getTabState() { RequestResponseState requestState = this.requestEditor.getEditorState(); RequestResponseState responseState = this.responseEditor.getEditorState(); return new ExtractorTabState(requestState, responseState); } public void setState(ExtractorTabState state) { this.requestEditor.setEditorState(state.requestState); this.responseEditor.setEditorState(state.responseState); } @Override
	public String getTabCaption() { return ""Extractor""; } @Override
	public Component getUiComponent() { return this.topPane; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package burp; public class ExtractorTab implements ITab { private IBurpExtenderCallbacks callbacks; private JSplitPane splitPane; private JPanel topPane; private JButton modifyRequests; private boolean extractorOn; private ExtractorEditor requestEditor; private ExtractorEditor responseEditor; private JTextArea dataToInsert; private Font normalFont; private Font boldFont; public ExtractorTab(byte[] response, byte[] request, String responseHost, String requestHost, final IBurpExtenderCallbacks callbacks) { this.callbacks = callbacks; this.topPane = new JPanel(); topPane.setLayout(new BoxLayout(topPane, BoxLayout.Y_AXIS)); this.splitPane = new JSplitPane(); this.splitPane.setResizeWeight(0.5); JPanel leftPane = new JPanel(); leftPane.setLayout(new GridBagLayout()); leftPane.setBorder(BorderFactory.createEmptyBorder(0,0,0,4)); this.splitPane.setLeftComponent(leftPane); JPanel rightPane = new JPanel(); rightPane.setLayout(new GridBagLayout()); rightPane.setBorder(BorderFactory.createEmptyBorder(0,4,0,0)); this.splitPane.setRightComponent(rightPane); GridBagConstraints constraints = new GridBagConstraints(); constraints.insets = new Insets(2,2,2,2); JLabel requestHeader = new JLabel(""Request""); constraints.gridx = 0; constraints.gridy = 0; constraints.gridwidth = 2; constraints.fill = GridBagConstraints.NONE; this.normalFont = requestHeader.getFont(); this.boldFont = new Font(this.normalFont.getFontName(), Font.BOLD, this.normalFont.getSize()); requestHeader.setFont(this.boldFont); leftPane.add(requestHeader, constraints); JLabel responseHeader = new JLabel(""Response""); constraints.gridx = 0; constraints.gridy = 0; constraints.gridwidth = 1; responseHeader.setFont(this.boldFont); rightPane.add(responseHeader, constraints); JLabel insertIntoRequestLabel = new JLabel(""Value to insert:""); constraints.gridx = 0; constraints.gridy = 1; constraints.anchor = GridBagConstraints.WEST; constraints.fill = GridBagConstraints.NONE; leftPane.add(insertIntoRequestLabel, constraints); this.dataToInsert = new JTextArea(); constraints.gridx = 1; constraints.gridy = 1; constraints.fill = GridBagConstraints.HORIZONTAL; leftPane.add(dataToInsert, constraints); JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEADING)); buttonPanel.setAlignmentX(Component.LEFT_ALIGNMENT); this.modifyRequests = new JButton(""Turn Extractor on""); this.modifyRequests.setFont(this.boldFont); this.modifyRequests.setBackground(Color.LIGHT_GRAY); this.extractorOn = false; buttonPanel.add(this.modifyRequests); this.modifyRequests.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { extractorOn = !extractorOn; if (extractorOn) { modifyRequests.setBackground(Color.GRAY); modifyRequests.setText(""Turn Extractor off""); } else { modifyRequests.setBackground(Color.LIGHT_GRAY); modifyRequests.setText(""Turn Extractor on""); } } } ); JButton helpButton = new JButton(""?""); buttonPanel.add(helpButton); JPopupMenu menu = new JPopupMenu(); menu.add(getHelpContents()); helpButton.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { menu.show(helpButton, e.getX(), e.getY()); } } ); topPane.add(buttonPanel); topPane.add(splitPane); this.requestEditor = new ExtractorEditor(callbacks); constraints.gridx = 0; constraints.gridy = 2; constraints.gridwidth = 2; constraints.fill = GridBagConstraints.BOTH; constraints.weightx = 0.5; constraints.weighty = 1; leftPane.add(requestEditor.getUIComponent(), constraints); this.responseEditor = new ExtractorEditor(callbacks); this.responseEditor.getUIComponent().setBorder(new EmptyBorder(32, 0, 0, 0)); constraints.gridx = 0; constraints.gridy = 1; constraints.fill = GridBagConstraints.BOTH; constraints.weightx = 0.5; constraints.weighty = 1; constraints.gridwidth = 1; rightPane.add(responseEditor.getUIComponent(), constraints); if (response != null && request != null) { this.setRequestMessage(request, requestHost); this.setResponseMessage(response, responseHost); } callbacks.customizeUiComponent(this.topPane); } public void setRequestMessage(byte[] message, String host) { this.requestEditor.setTargetHost(host); this.requestEditor.fillTextArea(message); } public void setResponseMessage(byte[] message, String host) { this.responseEditor.setTargetHost(host); this.responseEditor.fillTextArea(message); } public String[] getRequestSelectionRegex() { return this.requestEditor.getSelectionRegex(); } public String[] getResponseSelectionRegex() { return this.responseEditor.getSelectionRegex(); } public boolean shouldModifyRequests() { return this.extractorOn; } private boolean messageIsInScope(ExtractorEditor editor, URL url, String host, int toolFlag) { if (!editor.isToolSelected(toolFlag)) { return false; } if (editor.useSuiteScope()) { return this.callbacks.isInScope(url); } else { if (editor.useRegexForTarget()) { Pattern targetPattern = Pattern.compile(editor.getTargetHost()); Matcher targetMatcher = targetPattern.matcher(host); return targetMatcher.find(); } else { return host.equals(editor.getTargetHost()); } } } public boolean requestIsInScope(URL url, String host, int toolFlag) { return messageIsInScope(this.requestEditor, url, host, toolFlag); } public boolean responseIsInScope(URL url, String host, int toolFlag) { return messageIsInScope(this.responseEditor, url, host, toolFlag); } public String getDataToInsert() { return this.dataToInsert.getText(); } public void setDataToInsert(String data) { this.dataToInsert.setText(data); } private JPanel getHelpContents() { JPanel helpPanel = new JPanel(); helpPanel.setLayout(new BoxLayout(helpPanel, BoxLayout.Y_AXIS)); JPanel titlePanel = new JPanel(new FlowLayout(FlowLayout.LEADING)); titlePanel.add(Box.createHorizontalGlue()); JLabel titleLabel = new JLabel(""Burp Extractor""); titleLabel.setBorder(new EmptyBorder(0,0,0,0)); titleLabel.setFont(new Font(this.normalFont.getName(), Font.BOLD, this.normalFont.getSize() + 2)); titlePanel.add(titleLabel, Component.LEFT_ALIGNMENT); helpPanel.add(titlePanel); JPanel helpScrollPanel = new JPanel(); helpScrollPanel.setLayout(new BoxLayout(helpScrollPanel, BoxLayout.Y_AXIS)); JScrollPane scrollPane = new JScrollPane(helpScrollPanel); scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER); scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS); scrollPane.setViewportView(helpScrollPanel); helpPanel.add(scrollPane); JLabel highlightTitle = new JLabel(""Text Selection""); highlightTitle.setBorder(new EmptyBorder(5,5,5,5)); highlightTitle.setFont(this.boldFont); helpScrollPanel.add(highlightTitle); JLabel highlightInstructions = new JLabel(""<html><body style='width: 475px'><p>Highlight the text in the "" +
				""request you would like to replace with data from the response. In the response, highlight the text "" +
				""you would like to extract and have inserted into the request. Extractor will "" +
				""define regex for you when you select text in the request and response editors.</p><p>If you want to "" +
				""make customizations to those regex strings, you can! Just make sure that you escape characters that "" +
				""are have special regex meaning. That seems to be anything in this list, though there may be "" +
				""something missing: !$^&*()-+{ [} ]|\\:,.?</p></body></html>""); helpScrollPanel.add(highlightInstructions); JLabel scopeTitle = new JLabel(""Defining scope""); scopeTitle.setBorder(new EmptyBorder(5,5,5,5)); scopeTitle.setFont(this.boldFont); helpScrollPanel.add(scopeTitle); helpScrollPanel.add(new JLabel(""<html><body style='width: 475px'><p>Users can define scope using both "" +
				""the host and the tools to target. Either a user can select \""Use suite scope\"" which will cause Extractor to "" +
				""examine a request if it is in Burp Suite's scope. Otherwise, the \""Target host\"" field will be "" +
				""examined, and a message from a matching host will cause Extractor to examine it."" +
				""</p><p>Use the \""Select in-scope tools\"" button to select the tools that Extractor will "" +
				""examine for matching tokens.</p></body></html>"")); JLabel runningTitle = new JLabel(""Running Extractor""); runningTitle.setBorder(new EmptyBorder(5,5,5,5)); runningTitle.setFont(this.boldFont); helpScrollPanel.add(runningTitle); helpScrollPanel.add(new JLabel(""<html><body style='width:475px'><p>To start altering requests with "" +
				""Extractor, just click \""Turn Extractor on\"". Extractor will begin examining in-scope requests and "" +
				""responses for text which matches the before and after regex fields. Once Extractor "" +
				""has found a match in a response, it will save the text, and write it to the selected location in the "" +
				""request. Multiple Extractor tabs can be used at once, and will execute in the order they were created."" +
				""</p></body></html>"")); return helpPanel; } public ExtractorTabState getTabState() { RequestResponseState requestState = this.requestEditor.getEditorState(); RequestResponseState responseState = this.responseEditor.getEditorState(); return new ExtractorTabState(requestState, responseState); } public void setState(ExtractorTabState state) { this.requestEditor.setEditorState(state.requestState); this.responseEditor.setEditorState(state.responseState); } @Override
	public String getTabCaption() { return ""Extractor""; } @Override
	public Component getUiComponent() { return this.topPane; } } ","package burp; 
import burp.persistence.RequestResponseState; import burp.persistence.ExtractorTabState; 
import java.awt.*; import java.awt.event.*; import java.net.URL; import java.util.regex.Matcher; import java.util.regex.Pattern; import javax.swing.*; import javax.swing.border.EmptyBorder;  public class ExtractorTab implements ITab {  private IBurpExtenderCallbacks callbacks; private JSplitPane splitPane; private JPanel topPane; private JButton modifyRequests; private boolean extractorOn; private ExtractorEditor requestEditor; private ExtractorEditor responseEditor; private JTextArea dataToInsert; private Font normalFont; private Font boldFont; 
 public ExtractorTab(byte[] response, byte[] request, String responseHost, String requestHost, final IBurpExtenderCallbacks callbacks) { this.callbacks = callbacks;  this.topPane = new JPanel(); topPane.setLayout(new BoxLayout(topPane, BoxLayout.Y_AXIS));   this.splitPane = new JSplitPane(); this.splitPane.setResizeWeight(0.5); JPanel leftPane = new JPanel(); leftPane.setLayout(new GridBagLayout()); leftPane.setBorder(BorderFactory.createEmptyBorder(0,0,0,4)); this.splitPane.setLeftComponent(leftPane); JPanel rightPane = new JPanel(); rightPane.setLayout(new GridBagLayout()); rightPane.setBorder(BorderFactory.createEmptyBorder(0,4,0,0)); this.splitPane.setRightComponent(rightPane); GridBagConstraints constraints = new GridBagConstraints(); constraints.insets = new Insets(2,2,2,2); // Build split pane 
 JLabel requestHeader = new JLabel(""Request""); constraints.gridx = 0; constraints.gridy = 0; constraints.gridwidth = 2; constraints.fill = GridBagConstraints.NONE; this.normalFont = requestHeader.getFont(); this.boldFont = new Font(this.normalFont.getFontName(), Font.BOLD, this.normalFont.getSize()); requestHeader.setFont(this.boldFont); leftPane.add(requestHeader, constraints);  JLabel responseHeader = new JLabel(""Response""); constraints.gridx = 0; constraints.gridy = 0; constraints.gridwidth = 1; responseHeader.setFont(this.boldFont); rightPane.add(responseHeader, constraints); // Make our headers  JLabel insertIntoRequestLabel = new JLabel(""Value to insert:""); constraints.gridx = 0; constraints.gridy = 1; constraints.anchor = GridBagConstraints.WEST; constraints.fill = GridBagConstraints.NONE; leftPane.add(insertIntoRequestLabel, constraints);  this.dataToInsert = new JTextArea(); constraints.gridx = 1; constraints.gridy = 1; constraints.fill = GridBagConstraints.HORIZONTAL; leftPane.add(dataToInsert, constraints); // Add field to show the value which will be injected into requests  JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEADING)); buttonPanel.setAlignmentX(Component.LEFT_ALIGNMENT); this.modifyRequests = new JButton(""Turn Extractor on""); this.modifyRequests.setFont(this.boldFont); this.modifyRequests.setBackground(Color.LIGHT_GRAY); this.extractorOn = false; buttonPanel.add(this.modifyRequests); this.modifyRequests.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) {  extractorOn = !extractorOn; // Made button to dictate whether or not the extension is active // Change button state if (extractorOn) { modifyRequests.setBackground(Color.GRAY); modifyRequests.setText(""Turn Extractor off""); } else { modifyRequests.setBackground(Color.LIGHT_GRAY); modifyRequests.setText(""Turn Extractor on""); } } } );  // Change button appearance JButton helpButton = new JButton(""?""); buttonPanel.add(helpButton); JPopupMenu menu = new JPopupMenu(); menu.add(getHelpContents()); helpButton.addMouseListener(new MouseAdapter() { @Override
			public void mouseClicked(MouseEvent e) { menu.show(helpButton, e.getX(), e.getY()); } } );  topPane.add(buttonPanel); topPane.add(splitPane); // Create help button  this.requestEditor = new ExtractorEditor(callbacks); constraints.gridx = 0; constraints.gridy = 2; constraints.gridwidth = 2; constraints.fill = GridBagConstraints.BOTH; constraints.weightx = 0.5; constraints.weighty = 1; leftPane.add(requestEditor.getUIComponent(), constraints);  this.responseEditor = new ExtractorEditor(callbacks); this.responseEditor.getUIComponent().setBorder(new EmptyBorder(32, 0, 0, 0)); constraints.gridx = 0; constraints.gridy = 1; constraints.fill = GridBagConstraints.BOTH; constraints.weightx = 0.5; constraints.weighty = 1; constraints.gridwidth = 1; rightPane.add(responseEditor.getUIComponent(), constraints); // Create two editor panels. One for requests and one for responses  if (response != null && request != null) { this.setRequestMessage(request, requestHost); this.setResponseMessage(response, responseHost); }  callbacks.customizeUiComponent(this.topPane); } // If this tab was created from the menu, we should be able to populate the request and response public void setRequestMessage(byte[] message, String host) { this.requestEditor.setTargetHost(host); this.requestEditor.fillTextArea(message); }  public void setResponseMessage(byte[] message, String host) { this.responseEditor.setTargetHost(host); this.responseEditor.fillTextArea(message); }   public String[] getRequestSelectionRegex() { return this.requestEditor.getSelectionRegex(); }  // Get the regex string to select the intended text for replacement in the request public String[] getResponseSelectionRegex() { return this.responseEditor.getSelectionRegex(); }  // Get the regex string to select the text we want to replay somewhere in our requests public boolean shouldModifyRequests() { return this.extractorOn; }  // Returns true if the user has made the extension currently active, and the tool is selected private boolean messageIsInScope(ExtractorEditor editor, URL url, String host, int toolFlag) { if (!editor.isToolSelected(toolFlag)) { return false; } if (editor.useSuiteScope()) { return this.callbacks.isInScope(url); } else { if (editor.useRegexForTarget()) { Pattern targetPattern = Pattern.compile(editor.getTargetHost()); Matcher targetMatcher = targetPattern.matcher(host);  return targetMatcher.find(); } else { return host.equals(editor.getTargetHost()); } } } // Generalize checking scope  public boolean requestIsInScope(URL url, String host, int toolFlag) { return messageIsInScope(this.requestEditor, url, host, toolFlag); }  // Determine if the given URL and tool is in scope as defined by suite scope or a custom host public boolean responseIsInScope(URL url, String host, int toolFlag) { return messageIsInScope(this.responseEditor, url, host, toolFlag); }  public String getDataToInsert() { return this.dataToInsert.getText(); } // Determine if the given URL and tool is in scope as defined by suite scope or a custom host public void setDataToInsert(String data) { this.dataToInsert.setText(data); }  private JPanel getHelpContents() { JPanel helpPanel = new JPanel(); helpPanel.setLayout(new BoxLayout(helpPanel, BoxLayout.Y_AXIS));   JPanel titlePanel = new JPanel(new FlowLayout(FlowLayout.LEADING)); titlePanel.add(Box.createHorizontalGlue()); JLabel titleLabel = new JLabel(""Burp Extractor""); titleLabel.setBorder(new EmptyBorder(0,0,0,0)); titleLabel.setFont(new Font(this.normalFont.getName(), Font.BOLD, this.normalFont.getSize() + 2)); titlePanel.add(titleLabel, Component.LEFT_ALIGNMENT); helpPanel.add(titlePanel);  // Add large title JPanel helpScrollPanel = new JPanel(); helpScrollPanel.setLayout(new BoxLayout(helpScrollPanel, BoxLayout.Y_AXIS)); JScrollPane scrollPane = new JScrollPane(helpScrollPanel); scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER); scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS); scrollPane.setViewportView(helpScrollPanel);  helpPanel.add(scrollPane); // Add main scroll pane //		scrollPane.setPreferredSize(new Dimension(500,300)); JLabel highlightTitle = new JLabel(""Text Selection""); highlightTitle.setBorder(new EmptyBorder(5,5,5,5)); highlightTitle.setFont(this.boldFont); helpScrollPanel.add(highlightTitle); JLabel highlightInstructions = new JLabel(""<html><body style='width: 475px'><p>Highlight the text in the "" +
				""request you would like to replace with data from the response. In the response, highlight the text "" +
				""you would like to extract and have inserted into the request. Extractor will "" +
				""define regex for you when you select text in the request and response editors.</p><p>If you want to "" +
				""make customizations to those regex strings, you can! Just make sure that you escape characters that "" +
				""are have special regex meaning. That seems to be anything in this list, though there may be "" +
				""something missing: !$^&*()-+{ [} ]|\\:,.?</p></body></html>""); helpScrollPanel.add(highlightInstructions);  // Add text selection instructions JLabel scopeTitle = new JLabel(""Defining scope""); scopeTitle.setBorder(new EmptyBorder(5,5,5,5)); scopeTitle.setFont(this.boldFont); helpScrollPanel.add(scopeTitle); helpScrollPanel.add(new JLabel(""<html><body style='width: 475px'><p>Users can define scope using both "" +
				""the host and the tools to target. Either a user can select \""Use suite scope\"" which will cause Extractor to "" +
				""examine a request if it is in Burp Suite's scope. Otherwise, the \""Target host\"" field will be "" +
				""examined, and a message from a matching host will cause Extractor to examine it."" +
				""</p><p>Use the \""Select in-scope tools\"" button to select the tools that Extractor will "" +
				""examine for matching tokens.</p></body></html>""));  // Add scope instructions JLabel runningTitle = new JLabel(""Running Extractor""); runningTitle.setBorder(new EmptyBorder(5,5,5,5)); runningTitle.setFont(this.boldFont); helpScrollPanel.add(runningTitle); helpScrollPanel.add(new JLabel(""<html><body style='width:475px'><p>To start altering requests with "" +
				""Extractor, just click \""Turn Extractor on\"". Extractor will begin examining in-scope requests and "" +
				""responses for text which matches the before and after regex fields. Once Extractor "" +
				""has found a match in a response, it will save the text, and write it to the selected location in the "" +
				""request. Multiple Extractor tabs can be used at once, and will execute in the order they were created."" +
				""</p></body></html>""));  return helpPanel; } // Running Extractor public ExtractorTabState getTabState() {  RequestResponseState requestState = this.requestEditor.getEditorState();  // Build request state RequestResponseState responseState = this.responseEditor.getEditorState();  return new ExtractorTabState(requestState, responseState); } // Build response state public void setState(ExtractorTabState state) { this.requestEditor.setEditorState(state.requestState); this.responseEditor.setEditorState(state.responseState); }  @Override
	public String getTabCaption() { return ""Extractor""; }  @Override
	public Component getUiComponent() { return this.topPane; } }  "
src/burp/Logger.java,"package burp;

import java.io.PrintWriter;

public class Logger {
    private static int logLevel = 2;
    public static final int SEVERE = 0;
    public static final int WARN = 1;
    public static final int INFO = 2;
    public static final int DEBUG = 3;

    private PrintWriter pw;

    public Logger(PrintWriter pw) {
        this.pw = pw;
    }

    public void debug(String msg) {
        if (logLevel >= Logger.DEBUG) {
            pw.println(msg);
        }
    }

    public void info(String msg) {
        if (logLevel >= Logger.INFO) {
            pw.println(msg);
        }
    }

    public void warn(String msg) {
        if (logLevel >= Logger.WARN) {
            pw.println(msg);
        }
    }

    public void severe(String msg) {
        if (logLevel >= Logger.SEVERE) {
            pw.println(msg);
        }
    }

    public static int getLogLevel() {
        return logLevel;
    }

    public static void setLogLevel(int level) {
        logLevel = level;
    }

}
",package burp; public class Logger { private static int logLevel = 2; public static final int SEVERE = 0; public static final int WARN = 1; public static final int INFO = 2; public static final int DEBUG = 3; private PrintWriter pw; public Logger(PrintWriter pw) { this.pw = pw; } public void debug(String msg) { if (logLevel >= Logger.DEBUG) { pw.println(msg); } } public void info(String msg) { if (logLevel >= Logger.INFO) { pw.println(msg); } } public void warn(String msg) { if (logLevel >= Logger.WARN) { pw.println(msg); } } public void severe(String msg) { if (logLevel >= Logger.SEVERE) { pw.println(msg); } } public static int getLogLevel() { return logLevel; } public static void setLogLevel(int level) { logLevel = level; } },0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,package burp; public class Logger { private static int logLevel = 2; public static final int SEVERE = 0; public static final int WARN = 1; public static final int INFO = 2; public static final int DEBUG = 3; private PrintWriter pw; public Logger(PrintWriter pw) { this.pw = pw; } public void debug(String msg) { if (logLevel >= Logger.DEBUG) { pw.println(msg); } } public void info(String msg) { if (logLevel >= Logger.INFO) { pw.println(msg); } } public void warn(String msg) { if (logLevel >= Logger.WARN) { pw.println(msg); } } public void severe(String msg) { if (logLevel >= Logger.SEVERE) { pw.println(msg); } } public static int getLogLevel() { return logLevel; } public static void setLogLevel(int level) { logLevel = level; } } ,"package burp; 
import java.io.PrintWriter;  public class Logger { private static int logLevel = 2; public static final int SEVERE = 0; public static final int WARN = 1; public static final int INFO = 2; public static final int DEBUG = 3;  private PrintWriter pw;  public Logger(PrintWriter pw) { this.pw = pw; }  public void debug(String msg) { if (logLevel >= Logger.DEBUG) { pw.println(msg); } }  public void info(String msg) { if (logLevel >= Logger.INFO) { pw.println(msg); } }  public void warn(String msg) { if (logLevel >= Logger.WARN) { pw.println(msg); } }  public void severe(String msg) { if (logLevel >= Logger.SEVERE) { pw.println(msg); } }  public static int getLogLevel() { return logLevel; }  public static void setLogLevel(int level) { logLevel = level; }  }  "
src/burp/Utils.java,"package burp;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Utils {
	public static int[] getSelectionBounds(String request, String beforeRegex, String afterRegex) {
		// Don't match anything if we don't have a regex defined
		if (beforeRegex == """" && afterRegex == """") {
			return null;
		}
		int[] selectionBounds = new int[2];
		Matcher beforeMatcher = Pattern.compile(beforeRegex).matcher(request);
		if (beforeMatcher.find()) {
			selectionBounds[0] = beforeMatcher.end();
			Matcher afterMatcher = Pattern.compile(afterRegex).matcher(request);
			if (afterMatcher.find(selectionBounds[0])) {
				selectionBounds[1] = afterMatcher.start();
				return selectionBounds;
			}
		}
		return null;
	}
}
","package burp; public class Utils { public static int[] getSelectionBounds(String request, String beforeRegex, String afterRegex) { if (beforeRegex == """" && afterRegex == """") { return null; } int[] selectionBounds = new int[2]; Matcher beforeMatcher = Pattern.compile(beforeRegex).matcher(request); if (beforeMatcher.find()) { selectionBounds[0] = beforeMatcher.end(); Matcher afterMatcher = Pattern.compile(afterRegex).matcher(request); if (afterMatcher.find(selectionBounds[0])) { selectionBounds[1] = afterMatcher.start(); return selectionBounds; } } return null; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package burp; public class Utils { public static int[] getSelectionBounds(String request, String beforeRegex, String afterRegex) { if (beforeRegex == """" && afterRegex == """") { return null; } int[] selectionBounds = new int[2]; Matcher beforeMatcher = Pattern.compile(beforeRegex).matcher(request); if (beforeMatcher.find()) { selectionBounds[0] = beforeMatcher.end(); Matcher afterMatcher = Pattern.compile(afterRegex).matcher(request); if (afterMatcher.find(selectionBounds[0])) { selectionBounds[1] = afterMatcher.start(); return selectionBounds; } } return null; } } ","package burp; 
import java.util.regex.Matcher; import java.util.regex.Pattern;  public class Utils { public static int[] getSelectionBounds(String request, String beforeRegex, String afterRegex) { // Don't match anything if we don't have a regex defined if (beforeRegex == """" && afterRegex == """") { return null; } int[] selectionBounds = new int[2]; Matcher beforeMatcher = Pattern.compile(beforeRegex).matcher(request); if (beforeMatcher.find()) { selectionBounds[0] = beforeMatcher.end(); Matcher afterMatcher = Pattern.compile(afterRegex).matcher(request); if (afterMatcher.find(selectionBounds[0])) { selectionBounds[1] = afterMatcher.start(); return selectionBounds; } } return null; } }  "
src/burp/persistence/ExtractorSetting.java,"package burp.persistence;

import burp.IBurpExtenderCallbacks;
import burp.IHttpRequestResponse;
import burp.IHttpService;

import java.net.MalformedURLException;
import java.net.URL;

public class ExtractorSetting implements IHttpRequestResponse {

	private IHttpService service;
	private byte[] request;
	private byte[] response;
	public static final String settingFile = ""/setting"";

	public ExtractorSetting(IHttpService service, byte[] setting, IBurpExtenderCallbacks callbacks) throws MalformedURLException {
		this.request = callbacks.getHelpers().buildHttpRequest(new URL(service.getProtocol(), service.getHost(), settingFile));
		this.service = service;
		this.response = setting;
	}

	@Override
	public byte[] getRequest() {
		return this.request;
	}

	@Override
	public void setRequest(byte[] message) {
		this.request = message;
	}

	@Override
	public byte[] getResponse() {
		return this.response;
	}

	@Override
	public void setResponse(byte[] message) {
		this.response = message;
	}

	@Override
	public String getComment() {
		return null;
	}

	@Override
	public void setComment(String comment) {

	}

	@Override
	public String getHighlight() {
		return null;
	}

	@Override
	public void setHighlight(String color) {

	}

	@Override
	public IHttpService getHttpService() {
		return this.service;
	}

	@Override
	public void setHttpService(IHttpService httpService) {
		this.service = httpService;
	}
}","package burp.persistence; public class ExtractorSetting implements IHttpRequestResponse { private IHttpService service; private byte[] request; private byte[] response; public static final String settingFile = ""/setting""; public ExtractorSetting(IHttpService service, byte[] setting, IBurpExtenderCallbacks callbacks) throws MalformedURLException { this.request = callbacks.getHelpers().buildHttpRequest(new URL(service.getProtocol(), service.getHost(), settingFile)); this.service = service; this.response = setting; } @Override
	public byte[] getRequest() { return this.request; } @Override
	public void setRequest(byte[] message) { this.request = message; } @Override
	public byte[] getResponse() { return this.response; } @Override
	public void setResponse(byte[] message) { this.response = message; } @Override
	public String getComment() { return null; } @Override
	public void setComment(String comment) { } @Override
	public String getHighlight() { return null; } @Override
	public void setHighlight(String color) { } @Override
	public IHttpService getHttpService() { return this.service; } @Override
	public void setHttpService(IHttpService httpService) { this.service = httpService; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package burp.persistence; public class ExtractorSetting implements IHttpRequestResponse { private IHttpService service; private byte[] request; private byte[] response; public static final String settingFile = ""/setting""; public ExtractorSetting(IHttpService service, byte[] setting, IBurpExtenderCallbacks callbacks) throws MalformedURLException { this.request = callbacks.getHelpers().buildHttpRequest(new URL(service.getProtocol(), service.getHost(), settingFile)); this.service = service; this.response = setting; } @Override
	public byte[] getRequest() { return this.request; } @Override
	public void setRequest(byte[] message) { this.request = message; } @Override
	public byte[] getResponse() { return this.response; } @Override
	public void setResponse(byte[] message) { this.response = message; } @Override
	public String getComment() { return null; } @Override
	public void setComment(String comment) { } @Override
	public String getHighlight() { return null; } @Override
	public void setHighlight(String color) { } @Override
	public IHttpService getHttpService() { return this.service; } @Override
	public void setHttpService(IHttpService httpService) { this.service = httpService; } }","package burp.persistence; 
import burp.IBurpExtenderCallbacks; import burp.IHttpRequestResponse; import burp.IHttpService; 
import java.net.MalformedURLException; import java.net.URL;  public class ExtractorSetting implements IHttpRequestResponse {  private IHttpService service; private byte[] request; private byte[] response; public static final String settingFile = ""/setting"";  public ExtractorSetting(IHttpService service, byte[] setting, IBurpExtenderCallbacks callbacks) throws MalformedURLException { this.request = callbacks.getHelpers().buildHttpRequest(new URL(service.getProtocol(), service.getHost(), settingFile)); this.service = service; this.response = setting; }  @Override
	public byte[] getRequest() { return this.request; }  @Override
	public void setRequest(byte[] message) { this.request = message; }  @Override
	public byte[] getResponse() { return this.response; }  @Override
	public void setResponse(byte[] message) { this.response = message; }  @Override
	public String getComment() { return null; }  @Override
	public void setComment(String comment) {  }  @Override
	public String getHighlight() { return null; }  @Override
	public void setHighlight(String color) {  }  @Override
	public IHttpService getHttpService() { return this.service; }  @Override
	public void setHttpService(IHttpService httpService) { this.service = httpService; } }"
src/burp/persistence/ExtractorTabState.java,"package burp.persistence;

public class ExtractorTabState {
	public RequestResponseState requestState;
	public RequestResponseState responseState;

	public ExtractorTabState(RequestResponseState requestState,
							 RequestResponseState responseState) {
		this.requestState = requestState;
		this.responseState = responseState;
	}
}
","package burp.persistence; public class ExtractorTabState { public RequestResponseState requestState; public RequestResponseState responseState; public ExtractorTabState(RequestResponseState requestState,
							 RequestResponseState responseState) { this.requestState = requestState; this.responseState = responseState; } }",0 0 0 0 0 0 0 0 0 0,"package burp.persistence; public class ExtractorTabState { public RequestResponseState requestState; public RequestResponseState responseState; public ExtractorTabState(RequestResponseState requestState,
							 RequestResponseState responseState) { this.requestState = requestState; this.responseState = responseState; } } ","package burp.persistence;  public class ExtractorTabState { public RequestResponseState requestState; public RequestResponseState responseState;  public ExtractorTabState(RequestResponseState requestState,
							 RequestResponseState responseState) { this.requestState = requestState; this.responseState = responseState; } }  "
src/burp/persistence/InScopeTools.java,"package burp.persistence;

public class InScopeTools {
	public boolean allTools;
	public boolean proxy;
	public boolean scanner;
	public boolean intruder;
	public boolean repeater;
	public boolean extender;

	public InScopeTools(boolean allTools,
						boolean proxy,
						boolean scanner,
						boolean intruder,
						boolean repeater,
						boolean extender) {
		this.allTools = allTools;
		this.proxy = proxy;
		this.scanner = scanner;
		this.intruder = intruder;
		this.repeater = repeater;
		this.extender = extender;
	}
}
","package burp.persistence; public class InScopeTools { public boolean allTools; public boolean proxy; public boolean scanner; public boolean intruder; public boolean repeater; public boolean extender; public InScopeTools(boolean allTools,
						boolean proxy,
						boolean scanner,
						boolean intruder,
						boolean repeater,
						boolean extender) { this.allTools = allTools; this.proxy = proxy; this.scanner = scanner; this.intruder = intruder; this.repeater = repeater; this.extender = extender; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package burp.persistence; public class InScopeTools { public boolean allTools; public boolean proxy; public boolean scanner; public boolean intruder; public boolean repeater; public boolean extender; public InScopeTools(boolean allTools,
						boolean proxy,
						boolean scanner,
						boolean intruder,
						boolean repeater,
						boolean extender) { this.allTools = allTools; this.proxy = proxy; this.scanner = scanner; this.intruder = intruder; this.repeater = repeater; this.extender = extender; } } ","package burp.persistence;  public class InScopeTools { public boolean allTools; public boolean proxy; public boolean scanner; public boolean intruder; public boolean repeater; public boolean extender;  public InScopeTools(boolean allTools,
						boolean proxy,
						boolean scanner,
						boolean intruder,
						boolean repeater,
						boolean extender) { this.allTools = allTools; this.proxy = proxy; this.scanner = scanner; this.intruder = intruder; this.repeater = repeater; this.extender = extender; } }  "
src/burp/persistence/Persistor.java,"package burp.persistence;

import burp.*;
import com.google.gson.Gson;

import java.io.PrintWriter;
import java.net.MalformedURLException;
import java.util.ArrayList;

public class Persistor {
	private static ExtractorMainTab mainTab;
	private static IBurpExtenderCallbacks callbacks;
	private static burp.Logger logger;
	private static IHttpService service;
	private static boolean paused = false;

	public static void init(ExtractorMainTab mainTab, IBurpExtenderCallbacks callbacks) {
		Persistor.mainTab = mainTab;
		Persistor.callbacks = callbacks;
		Persistor.service = callbacks.getHelpers().buildHttpService(""com.netspi.burpExtractor"", 65535, true);
		logger = new Logger(new PrintWriter(callbacks.getStdout(), true));
	}

	public static void persistExtractor() {
		if (!paused) {
			ArrayList<ExtractorTabState> extractorState = new ArrayList<>();
			for (ExtractorTab tab : mainTab.getExtractorTabs()) {
				extractorState.add(tab.getTabState());
			}
			Gson gson = new Gson();
			String json = gson.toJson(extractorState.toArray());
			ExtractorSetting setting = null;
			try {
				setting = new ExtractorSetting(Persistor.service, json.getBytes(), callbacks);
			} catch (MalformedURLException exception) {
				logger.warn(""Failed to save settings..."");
				return;
			}
			callbacks.addToSiteMap(setting);
		}
	}

	private static IHttpRequestResponse getExistingSetting() {
		IHttpRequestResponse[] settings = callbacks.getSiteMap(Persistor.service.toString() + ExtractorSetting.settingFile);
		if (settings.length > 0) {
			return settings[0];
		} else {
			return null;
		}
	}

	public static void restoreExtractor() {
		Gson gson = new Gson();
		IHttpRequestResponse currentSetting = getExistingSetting();
		if (currentSetting != null) {
			ExtractorTabState[] tabs = gson.fromJson(callbacks.getHelpers().bytesToString(currentSetting.getResponse()),
					ExtractorTabState[].class);
			for (ExtractorTabState state : tabs) {
				logger.info(""Loading tab..."");
				mainTab.createExtractorTab(state, callbacks);
			}
		}
	}

	public static void pause() {
		paused = true;
	}

	public static void unpause() {
		paused = false;
	}
}
","package burp.persistence; public class Persistor { private static ExtractorMainTab mainTab; private static IBurpExtenderCallbacks callbacks; private static burp.Logger logger; private static IHttpService service; private static boolean paused = false; public static void init(ExtractorMainTab mainTab, IBurpExtenderCallbacks callbacks) { Persistor.mainTab = mainTab; Persistor.callbacks = callbacks; Persistor.service = callbacks.getHelpers().buildHttpService(""com.netspi.burpExtractor"", 65535, true); logger = new Logger(new PrintWriter(callbacks.getStdout(), true)); } public static void persistExtractor() { if (!paused) { ArrayList<ExtractorTabState> extractorState = new ArrayList<>(); for (ExtractorTab tab : mainTab.getExtractorTabs()) { extractorState.add(tab.getTabState()); } Gson gson = new Gson(); String json = gson.toJson(extractorState.toArray()); ExtractorSetting setting = null; try { setting = new ExtractorSetting(Persistor.service, json.getBytes(), callbacks); } catch (MalformedURLException exception) { return; } callbacks.addToSiteMap(setting); } } private static IHttpRequestResponse getExistingSetting() { IHttpRequestResponse[] settings = callbacks.getSiteMap(Persistor.service.toString() + ExtractorSetting.settingFile); if (settings.length > 0) { return settings[0]; } else { return null; } } public static void restoreExtractor() { Gson gson = new Gson(); IHttpRequestResponse currentSetting = getExistingSetting(); if (currentSetting != null) { ExtractorTabState[] tabs = gson.fromJson(callbacks.getHelpers().bytesToString(currentSetting.getResponse()),
					ExtractorTabState[].class); for (ExtractorTabState state : tabs) { mainTab.createExtractorTab(state, callbacks); } } } public static void pause() { paused = true; } public static void unpause() { paused = false; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0,"package burp.persistence; public class Persistor { private static ExtractorMainTab mainTab; private static IBurpExtenderCallbacks callbacks; private static burp.Logger logger; private static IHttpService service; private static boolean paused = false; public static void init(ExtractorMainTab mainTab, IBurpExtenderCallbacks callbacks) { Persistor.mainTab = mainTab; Persistor.callbacks = callbacks; Persistor.service = callbacks.getHelpers().buildHttpService(""com.netspi.burpExtractor"", 65535, true); logger = new Logger(new PrintWriter(callbacks.getStdout(), true)); } public static void persistExtractor() { if (!paused) { ArrayList<ExtractorTabState> extractorState = new ArrayList<>(); for (ExtractorTab tab : mainTab.getExtractorTabs()) { extractorState.add(tab.getTabState()); } Gson gson = new Gson(); String json = gson.toJson(extractorState.toArray()); ExtractorSetting setting = null; try { setting = new ExtractorSetting(Persistor.service, json.getBytes(), callbacks); } catch (MalformedURLException exception) { <FILL_ME> return; } callbacks.addToSiteMap(setting); } } private static IHttpRequestResponse getExistingSetting() { IHttpRequestResponse[] settings = callbacks.getSiteMap(Persistor.service.toString() + ExtractorSetting.settingFile); if (settings.length > 0) { return settings[0]; } else { return null; } } public static void restoreExtractor() { Gson gson = new Gson(); IHttpRequestResponse currentSetting = getExistingSetting(); if (currentSetting != null) { ExtractorTabState[] tabs = gson.fromJson(callbacks.getHelpers().bytesToString(currentSetting.getResponse()),
					ExtractorTabState[].class); for (ExtractorTabState state : tabs) { <FILL_ME> mainTab.createExtractorTab(state, callbacks); } } } public static void pause() { paused = true; } public static void unpause() { paused = false; } } ","package burp.persistence; 
import burp.*; import com.google.gson.Gson; 
import java.io.PrintWriter; import java.net.MalformedURLException; import java.util.ArrayList;  public class Persistor { private static ExtractorMainTab mainTab; private static IBurpExtenderCallbacks callbacks; private static burp.Logger logger; private static IHttpService service; private static boolean paused = false;  public static void init(ExtractorMainTab mainTab, IBurpExtenderCallbacks callbacks) { Persistor.mainTab = mainTab; Persistor.callbacks = callbacks; Persistor.service = callbacks.getHelpers().buildHttpService(""com.netspi.burpExtractor"", 65535, true); logger = new Logger(new PrintWriter(callbacks.getStdout(), true)); }  public static void persistExtractor() { if (!paused) { ArrayList<ExtractorTabState> extractorState = new ArrayList<>(); for (ExtractorTab tab : mainTab.getExtractorTabs()) { extractorState.add(tab.getTabState()); } Gson gson = new Gson(); String json = gson.toJson(extractorState.toArray()); ExtractorSetting setting = null; try { setting = new ExtractorSetting(Persistor.service, json.getBytes(), callbacks); } catch (MalformedURLException exception) { <FILL_ME> return; } callbacks.addToSiteMap(setting); } }  private static IHttpRequestResponse getExistingSetting() { IHttpRequestResponse[] settings = callbacks.getSiteMap(Persistor.service.toString() + ExtractorSetting.settingFile); if (settings.length > 0) { return settings[0]; } else { return null; } }  public static void restoreExtractor() { Gson gson = new Gson(); IHttpRequestResponse currentSetting = getExistingSetting(); if (currentSetting != null) { ExtractorTabState[] tabs = gson.fromJson(callbacks.getHelpers().bytesToString(currentSetting.getResponse()),
					ExtractorTabState[].class); for (ExtractorTabState state : tabs) { <FILL_ME> mainTab.createExtractorTab(state, callbacks); } } }  public static void pause() { paused = true; }  public static void unpause() { paused = false; } }  "
src/burp/persistence/RequestResponseState.java,"package burp.persistence;

public class RequestResponseState {
	public InScopeTools inScopeTools;
	public boolean useSuiteScope;
	public String targetHost;
	public boolean useRegex;
	public String beforeRegex;
	public String afterRegex;
	public String content;

	public RequestResponseState(InScopeTools inScopeTools,
								boolean useSuiteScope,
								String targetHost,
								boolean useRegex,
								String beforeRegex,
								String afterRegex,
								String content) {
		this.inScopeTools = inScopeTools;
		this.useSuiteScope = useSuiteScope;
		this.targetHost = targetHost;
		this.useRegex = useRegex;
		this.beforeRegex = beforeRegex;
		this.afterRegex = afterRegex;
		this.content = content;
	}
}
","package burp.persistence; public class RequestResponseState { public InScopeTools inScopeTools; public boolean useSuiteScope; public String targetHost; public boolean useRegex; public String beforeRegex; public String afterRegex; public String content; public RequestResponseState(InScopeTools inScopeTools,
								boolean useSuiteScope,
								String targetHost,
								boolean useRegex,
								String beforeRegex,
								String afterRegex,
								String content) { this.inScopeTools = inScopeTools; this.useSuiteScope = useSuiteScope; this.targetHost = targetHost; this.useRegex = useRegex; this.beforeRegex = beforeRegex; this.afterRegex = afterRegex; this.content = content; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package burp.persistence; public class RequestResponseState { public InScopeTools inScopeTools; public boolean useSuiteScope; public String targetHost; public boolean useRegex; public String beforeRegex; public String afterRegex; public String content; public RequestResponseState(InScopeTools inScopeTools,
								boolean useSuiteScope,
								String targetHost,
								boolean useRegex,
								String beforeRegex,
								String afterRegex,
								String content) { this.inScopeTools = inScopeTools; this.useSuiteScope = useSuiteScope; this.targetHost = targetHost; this.useRegex = useRegex; this.beforeRegex = beforeRegex; this.afterRegex = afterRegex; this.content = content; } } ","package burp.persistence;  public class RequestResponseState { public InScopeTools inScopeTools; public boolean useSuiteScope; public String targetHost; public boolean useRegex; public String beforeRegex; public String afterRegex; public String content;  public RequestResponseState(InScopeTools inScopeTools,
								boolean useSuiteScope,
								String targetHost,
								boolean useRegex,
								String beforeRegex,
								String afterRegex,
								String content) { this.inScopeTools = inScopeTools; this.useSuiteScope = useSuiteScope; this.targetHost = targetHost; this.useRegex = useRegex; this.beforeRegex = beforeRegex; this.afterRegex = afterRegex; this.content = content; } }  "
