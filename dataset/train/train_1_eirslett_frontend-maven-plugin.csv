file_name,original_file_content,Input,Label,Output,OriginalWithPlaceholder
frontend-maven-plugin/src/main/java/com/github/eirslett/maven/plugins/frontend/mojo/AbstractFrontendMojo.java,"package com.github.eirslett.maven.plugins.frontend.mojo;

import java.io.File;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecution;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.MavenProject;
import org.apache.maven.settings.Server;
import org.codehaus.plexus.util.xml.Xpp3Dom;
import org.eclipse.aether.RepositorySystemSession;

import com.github.eirslett.maven.plugins.frontend.lib.FrontendException;
import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory;
import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException;

public abstract class AbstractFrontendMojo extends AbstractMojo {

    @Component
    protected MojoExecution execution;

    /**
     * Whether you should skip while running in the test phase (default is false)
     */
    @Parameter(property = ""skipTests"", required = false, defaultValue = ""false"")
    protected Boolean skipTests;

    /**
     * Set this to true to ignore a failure during testing. Its use is NOT RECOMMENDED, but quite convenient on
     * occasion.
     *
     * @since 1.4
     */
    @Parameter(property = ""maven.test.failure.ignore"", defaultValue = ""false"")
    protected boolean testFailureIgnore;

    /**
     * The base directory for running all Node commands. (Usually the directory that contains package.json)
     */
    @Parameter(defaultValue = ""${basedir}"", property = ""workingDirectory"", required = false)
    protected File workingDirectory;

    /**
     * The base directory for installing node and npm.
     */
    @Parameter(property = ""installDirectory"", required = false)
    protected File installDirectory;

    /**
     * Additional environment variables to pass to the build.
     */
    @Parameter
    protected Map<String, String> environmentVariables;

    @Parameter(defaultValue = ""${project}"", readonly = true)
    private MavenProject project;

    @Parameter(defaultValue = ""${repositorySystemSession}"", readonly = true)
    private RepositorySystemSession repositorySystemSession;

    /**
     * Determines if this execution should be skipped.
     */
    private boolean skipTestPhase() {
        return skipTests && isTestingPhase();
    }

    /**
     * Determines if the current execution is during a testing phase (e.g., ""test"" or ""integration-test"").
     */
    private boolean isTestingPhase() {
        String phase = execution.getLifecyclePhase();
        return ""test"".equals(phase) || ""integration-test"".equals(phase);
    }

    protected abstract void execute(FrontendPluginFactory factory) throws FrontendException;

    /**
     * Implemented by children to determine if this execution should be skipped.
     */
    protected abstract boolean skipExecution();

    @Override
    public void execute() throws MojoFailureException {
        if (testFailureIgnore && !isTestingPhase()) {
            getLog().info(""testFailureIgnore property is ignored in non test phases"");
        }
        if (!(skipTestPhase() || skipExecution())) {
            if (installDirectory == null) {
                installDirectory = workingDirectory;
            }
            try {
                execute(new FrontendPluginFactory(workingDirectory, installDirectory,
                        new RepositoryCacheResolver(repositorySystemSession)));
            } catch (TaskRunnerException e) {
                if (testFailureIgnore && isTestingPhase()) {
                    getLog().error(""There are test failures.\nFailed to run task: "" + e.getMessage(), e);
                } else {
                    throw new MojoFailureException(""Failed to run task"", e);
                }
            } catch (FrontendException e) {
                throw MojoUtils.toMojoFailureException(e);
            }
        } else {
            getLog().info(""Skipping execution."");
        }
    }
    
    /** 
     * Provides the HTTP-Headers from the server section of settings.xml.
     * 
     * @param server 
     *           the &lt;server&gt; entry from the settings.xml
     *           
     * @return the mapping from the name of each configured HTTP header to its value,
     *         an empty map if there is no such configuration
     */
    protected Map<String, String> getHttpHeaders(Server server) {
        if (server == null || !(server.getConfiguration() instanceof Xpp3Dom)) {
            return Collections.emptyMap();
        }
        
        Xpp3Dom configuration = (Xpp3Dom) server.getConfiguration();
        
        Map<String, String> result = new HashMap<>();

        Xpp3Dom httpHeaders = configuration.getChild(""httpHeaders"");
        if (httpHeaders != null) {
            for (Xpp3Dom property : httpHeaders.getChildren(""property"")) {
                Xpp3Dom name = property.getChild(""name"");
                Xpp3Dom value = property.getChild(""value"");
                if (name != null && value != null) {
                    result.put(name.getValue(), value.getValue());
                }
            }
        }
        return result;
    }

}
","package com.github.eirslett.maven.plugins.frontend.mojo; public abstract class AbstractFrontendMojo extends AbstractMojo { @Component
    protected MojoExecution execution; @Parameter(property = ""skipTests"", required = false, defaultValue = ""false"")
    protected Boolean skipTests; @Parameter(property = ""maven.test.failure.ignore"", defaultValue = ""false"")
    protected boolean testFailureIgnore; @Parameter(defaultValue = ""${ basedir} "", property = ""workingDirectory"", required = false)
    protected File workingDirectory; @Parameter(property = ""installDirectory"", required = false)
    protected File installDirectory; @Parameter
    protected Map<String, String> environmentVariables; @Parameter(defaultValue = ""${ project} "", readonly = true)
    private MavenProject project; @Parameter(defaultValue = ""${ repositorySystemSession} "", readonly = true)
    private RepositorySystemSession repositorySystemSession; private boolean skipTestPhase() { return skipTests && isTestingPhase(); } private boolean isTestingPhase() { String phase = execution.getLifecyclePhase(); return ""test"".equals(phase) || ""integration-test"".equals(phase); } protected abstract void execute(FrontendPluginFactory factory) throws FrontendException; protected abstract boolean skipExecution(); @Override
    public void execute() throws MojoFailureException { if (testFailureIgnore && !isTestingPhase()) { getLog().info(""testFailureIgnore property is ignored in non test phases""); } if (!(skipTestPhase() || skipExecution())) { if (installDirectory == null) { installDirectory = workingDirectory; } try { execute(new FrontendPluginFactory(workingDirectory, installDirectory,
                        new RepositoryCacheResolver(repositorySystemSession))); } catch (TaskRunnerException e) { if (testFailureIgnore && isTestingPhase()) { getLog().error(""There are test failures.\nFailed to run task: "" + e.getMessage(), e); } else { throw new MojoFailureException(""Failed to run task"", e); } } catch (FrontendException e) { throw MojoUtils.toMojoFailureException(e); } } else { getLog().info(""Skipping execution.""); } } protected Map<String, String> getHttpHeaders(Server server) { if (server == null || !(server.getConfiguration() instanceof Xpp3Dom)) { return Collections.emptyMap(); } Xpp3Dom configuration = (Xpp3Dom) server.getConfiguration(); Map<String, String> result = new HashMap<>(); Xpp3Dom httpHeaders = configuration.getChild(""httpHeaders""); if (httpHeaders != null) { for (Xpp3Dom property : httpHeaders.getChildren(""property"")) { Xpp3Dom name = property.getChild(""name""); Xpp3Dom value = property.getChild(""value""); if (name != null && value != null) { result.put(name.getValue(), value.getValue()); } } } return result; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.mojo; public abstract class AbstractFrontendMojo extends AbstractMojo { @Component
    protected MojoExecution execution; @Parameter(property = ""skipTests"", required = false, defaultValue = ""false"")
    protected Boolean skipTests; @Parameter(property = ""maven.test.failure.ignore"", defaultValue = ""false"")
    protected boolean testFailureIgnore; @Parameter(defaultValue = ""${ basedir} "", property = ""workingDirectory"", required = false)
    protected File workingDirectory; @Parameter(property = ""installDirectory"", required = false)
    protected File installDirectory; @Parameter
    protected Map<String, String> environmentVariables; @Parameter(defaultValue = ""${ project} "", readonly = true)
    private MavenProject project; @Parameter(defaultValue = ""${ repositorySystemSession} "", readonly = true)
    private RepositorySystemSession repositorySystemSession; private boolean skipTestPhase() { return skipTests && isTestingPhase(); } private boolean isTestingPhase() { String phase = execution.getLifecyclePhase(); return ""test"".equals(phase) || ""integration-test"".equals(phase); } protected abstract void execute(FrontendPluginFactory factory) throws FrontendException; protected abstract boolean skipExecution(); @Override
    public void execute() throws MojoFailureException { if (testFailureIgnore && !isTestingPhase()) { getLog().info(""testFailureIgnore property is ignored in non test phases""); } if (!(skipTestPhase() || skipExecution())) { if (installDirectory == null) { installDirectory = workingDirectory; } try { execute(new FrontendPluginFactory(workingDirectory, installDirectory,
                        new RepositoryCacheResolver(repositorySystemSession))); } catch (TaskRunnerException e) { if (testFailureIgnore && isTestingPhase()) { getLog().error(""There are test failures.\nFailed to run task: "" + e.getMessage(), e); } else { throw new MojoFailureException(""Failed to run task"", e); } } catch (FrontendException e) { throw MojoUtils.toMojoFailureException(e); } } else { getLog().info(""Skipping execution.""); } } protected Map<String, String> getHttpHeaders(Server server) { if (server == null || !(server.getConfiguration() instanceof Xpp3Dom)) { return Collections.emptyMap(); } Xpp3Dom configuration = (Xpp3Dom) server.getConfiguration(); Map<String, String> result = new HashMap<>(); Xpp3Dom httpHeaders = configuration.getChild(""httpHeaders""); if (httpHeaders != null) { for (Xpp3Dom property : httpHeaders.getChildren(""property"")) { Xpp3Dom name = property.getChild(""name""); Xpp3Dom value = property.getChild(""value""); if (name != null && value != null) { result.put(name.getValue(), value.getValue()); } } } return result; } } ","package com.github.eirslett.maven.plugins.frontend.mojo; 
import java.io.File; import java.util.Collections; import java.util.HashMap; import java.util.Map; 
import org.apache.maven.plugin.AbstractMojo; import org.apache.maven.plugin.MojoExecution; import org.apache.maven.plugin.MojoFailureException; import org.apache.maven.plugins.annotations.Component; import org.apache.maven.plugins.annotations.Parameter; import org.apache.maven.project.MavenProject; import org.apache.maven.settings.Server; import org.codehaus.plexus.util.xml.Xpp3Dom; import org.eclipse.aether.RepositorySystemSession; 
import com.github.eirslett.maven.plugins.frontend.lib.FrontendException; import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory; import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException;  public abstract class AbstractFrontendMojo extends AbstractMojo {  @Component
    protected MojoExecution execution;  /**
     * Whether you should skip while running in the test phase (default is false)
     */ @Parameter(property = ""skipTests"", required = false, defaultValue = ""false"")
    protected Boolean skipTests;  /**
     * Set this to true to ignore a failure during testing. Its use is NOT RECOMMENDED, but quite convenient on
     * occasion.
     *
     * @since 1.4
     */ @Parameter(property = ""maven.test.failure.ignore"", defaultValue = ""false"")
    protected boolean testFailureIgnore;  /**
     * The base directory for running all Node commands. (Usually the directory that contains package.json)
     */ @Parameter(defaultValue = ""${ basedir} "", property = ""workingDirectory"", required = false)
    protected File workingDirectory;  /**
     * The base directory for installing node and npm.
     */ @Parameter(property = ""installDirectory"", required = false)
    protected File installDirectory;  /**
     * Additional environment variables to pass to the build.
     */ @Parameter
    protected Map<String, String> environmentVariables;  @Parameter(defaultValue = ""${ project} "", readonly = true)
    private MavenProject project;  @Parameter(defaultValue = ""${ repositorySystemSession} "", readonly = true)
    private RepositorySystemSession repositorySystemSession;  /**
     * Determines if this execution should be skipped.
     */ private boolean skipTestPhase() { return skipTests && isTestingPhase(); }  /**
     * Determines if the current execution is during a testing phase (e.g., ""test"" or ""integration-test"").
     */ private boolean isTestingPhase() { String phase = execution.getLifecyclePhase(); return ""test"".equals(phase) || ""integration-test"".equals(phase); }  protected abstract void execute(FrontendPluginFactory factory) throws FrontendException;  /**
     * Implemented by children to determine if this execution should be skipped.
     */ protected abstract boolean skipExecution();  @Override
    public void execute() throws MojoFailureException { if (testFailureIgnore && !isTestingPhase()) { getLog().info(""testFailureIgnore property is ignored in non test phases""); } if (!(skipTestPhase() || skipExecution())) { if (installDirectory == null) { installDirectory = workingDirectory; } try { execute(new FrontendPluginFactory(workingDirectory, installDirectory,
                        new RepositoryCacheResolver(repositorySystemSession))); } catch (TaskRunnerException e) { if (testFailureIgnore && isTestingPhase()) { getLog().error(""There are test failures.\nFailed to run task: "" + e.getMessage(), e); } else { throw new MojoFailureException(""Failed to run task"", e); } } catch (FrontendException e) { throw MojoUtils.toMojoFailureException(e); } } else { getLog().info(""Skipping execution.""); } }      /** 
     * Provides the HTTP-Headers from the server section of settings.xml.
     * 
     * @param server 
     *           the &lt;server&gt; entry from the settings.xml
     *           
     * @return the mapping from the name of each configured HTTP header to its value,
     *         an empty map if there is no such configuration
     */ protected Map<String, String> getHttpHeaders(Server server) { if (server == null || !(server.getConfiguration() instanceof Xpp3Dom)) { return Collections.emptyMap(); }          Xpp3Dom configuration = (Xpp3Dom) server.getConfiguration();          Map<String, String> result = new HashMap<>();  Xpp3Dom httpHeaders = configuration.getChild(""httpHeaders""); if (httpHeaders != null) { for (Xpp3Dom property : httpHeaders.getChildren(""property"")) { Xpp3Dom name = property.getChild(""name""); Xpp3Dom value = property.getChild(""value""); if (name != null && value != null) { result.put(name.getValue(), value.getValue()); } } } return result; }  }  "
frontend-maven-plugin/src/main/java/com/github/eirslett/maven/plugins/frontend/mojo/BowerMojo.java,"package com.github.eirslett.maven.plugins.frontend.mojo;

import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory;
import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig;
import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.settings.crypto.SettingsDecrypter;

import java.util.Collections;

@Mojo(name = ""bower"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class BowerMojo extends AbstractFrontendMojo {

    /**
     * Bower arguments. Default is ""install"".
     */
    @Parameter(defaultValue = ""install"", property = ""frontend.bower.arguments"", required = false)
    private String arguments;

    /**
     * Skips execution of this mojo.
     */
    @Parameter(property = ""skip.bower"", defaultValue = ""${skip.bower}"")
    private boolean skip;

    @Parameter(property = ""session"", defaultValue = ""${session}"", readonly = true)
    private MavenSession session;

    @Parameter(property = ""frontend.bower.bowerInheritsProxyConfigFromMaven"", required = false, defaultValue = ""true"")
    private boolean bowerInheritsProxyConfigFromMaven;

    @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter;

    @Override
    protected boolean skipExecution() {
        return this.skip;
    }

    @Override
    protected synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException {
        ProxyConfig proxyConfig = getProxyConfig();
        factory.getBowerRunner(proxyConfig).execute(arguments, environmentVariables);
    }

    private ProxyConfig getProxyConfig() {
        if (bowerInheritsProxyConfigFromMaven) {
            return MojoUtils.getProxyConfig(session, decrypter);
        } else {
            getLog().info(""bower not inheriting proxy config from Maven"");
            return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList());
        }
    }

}
","package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name = ""bower"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class BowerMojo extends AbstractFrontendMojo { @Parameter(defaultValue = ""install"", property = ""frontend.bower.arguments"", required = false)
    private String arguments; @Parameter(property = ""skip.bower"", defaultValue = ""${ skip.bower} "")
    private boolean skip; @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session; @Parameter(property = ""frontend.bower.bowerInheritsProxyConfigFromMaven"", required = false, defaultValue = ""true"")
    private boolean bowerInheritsProxyConfigFromMaven; @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    protected synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { ProxyConfig proxyConfig = getProxyConfig(); factory.getBowerRunner(proxyConfig).execute(arguments, environmentVariables); } private ProxyConfig getProxyConfig() { if (bowerInheritsProxyConfigFromMaven) { return MojoUtils.getProxyConfig(session, decrypter); } else { getLog().info(""bower not inheriting proxy config from Maven""); return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList()); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name = ""bower"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class BowerMojo extends AbstractFrontendMojo { @Parameter(defaultValue = ""install"", property = ""frontend.bower.arguments"", required = false)
    private String arguments; @Parameter(property = ""skip.bower"", defaultValue = ""${ skip.bower} "")
    private boolean skip; @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session; @Parameter(property = ""frontend.bower.bowerInheritsProxyConfigFromMaven"", required = false, defaultValue = ""true"")
    private boolean bowerInheritsProxyConfigFromMaven; @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    protected synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { ProxyConfig proxyConfig = getProxyConfig(); factory.getBowerRunner(proxyConfig).execute(arguments, environmentVariables); } private ProxyConfig getProxyConfig() { if (bowerInheritsProxyConfigFromMaven) { return MojoUtils.getProxyConfig(session, decrypter); } else { getLog().info(""bower not inheriting proxy config from Maven""); return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList()); } } } ","package com.github.eirslett.maven.plugins.frontend.mojo; 
import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory; import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig; import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException; import org.apache.maven.execution.MavenSession; import org.apache.maven.plugins.annotations.Component; import org.apache.maven.plugins.annotations.LifecyclePhase; import org.apache.maven.plugins.annotations.Mojo; import org.apache.maven.plugins.annotations.Parameter; import org.apache.maven.settings.crypto.SettingsDecrypter; 
import java.util.Collections;  @Mojo(name = ""bower"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class BowerMojo extends AbstractFrontendMojo {  /**
     * Bower arguments. Default is ""install"".
     */ @Parameter(defaultValue = ""install"", property = ""frontend.bower.arguments"", required = false)
    private String arguments;  /**
     * Skips execution of this mojo.
     */ @Parameter(property = ""skip.bower"", defaultValue = ""${ skip.bower} "")
    private boolean skip;  @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session;  @Parameter(property = ""frontend.bower.bowerInheritsProxyConfigFromMaven"", required = false, defaultValue = ""true"")
    private boolean bowerInheritsProxyConfigFromMaven;  @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter;  @Override
    protected boolean skipExecution() { return this.skip; }  @Override
    protected synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { ProxyConfig proxyConfig = getProxyConfig(); factory.getBowerRunner(proxyConfig).execute(arguments, environmentVariables); }  private ProxyConfig getProxyConfig() { if (bowerInheritsProxyConfigFromMaven) { return MojoUtils.getProxyConfig(session, decrypter); } else { getLog().info(""bower not inheriting proxy config from Maven""); return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList()); } }  }  "
frontend-maven-plugin/src/main/java/com/github/eirslett/maven/plugins/frontend/mojo/BunMojo.java,"package com.github.eirslett.maven.plugins.frontend.mojo;

import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory;
import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig;
import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.settings.crypto.SettingsDecrypter;
import org.sonatype.plexus.build.incremental.BuildContext;

import java.io.File;
import java.util.Collections;

@Mojo(name = ""bun"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class BunMojo extends AbstractFrontendMojo {

    private static final String NPM_REGISTRY_URL = ""npmRegistryURL"";

    /**
     * bun arguments. Default is ""install"".
     */
    @Parameter(defaultValue = """", property = ""frontend.bun.arguments"", required = false)
    private String arguments;

    @Parameter(property = ""frontend.bun.bunInheritsProxyConfigFromMaven"", required = false,
            defaultValue = ""true"")
    private boolean bunInheritsProxyConfigFromMaven;

    /**
     * Registry override, passed as the registry option during npm install if set.
     */
    @Parameter(property = NPM_REGISTRY_URL, required = false, defaultValue = """")
    private String npmRegistryURL;

    @Parameter(property = ""session"", defaultValue = ""${session}"", readonly = true)
    private MavenSession session;

    @Component
    private BuildContext buildContext;

    @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter;

    /**
     * Skips execution of this mojo.
     */
    @Parameter(property = ""skip.bun"", defaultValue = ""${skip.bun}"")
    private boolean skip;

    @Override
    protected boolean skipExecution() {
        return this.skip;
    }

    @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException {
        File packageJson = new File(this.workingDirectory, ""package.json"");
        if (this.buildContext == null || this.buildContext.hasDelta(packageJson)
                || !this.buildContext.isIncremental()) {
            ProxyConfig proxyConfig = getProxyConfig();
            factory.getBunRunner(proxyConfig, getRegistryUrl()).execute(this.arguments,
                    this.environmentVariables);
        } else {
            getLog().info(""Skipping bun install as package.json unchanged"");
        }
    }

    private ProxyConfig getProxyConfig() {
        if (this.bunInheritsProxyConfigFromMaven) {
            return MojoUtils.getProxyConfig(this.session, this.decrypter);
        } else {
            getLog().info(""bun not inheriting proxy config from Maven"");
            return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList());
        }
    }

    private String getRegistryUrl() {
        // check to see if overridden via `-D`, otherwise fallback to pom value
        return System.getProperty(NPM_REGISTRY_URL, this.npmRegistryURL);
    }
}
","package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name = ""bun"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class BunMojo extends AbstractFrontendMojo { private static final String NPM_REGISTRY_URL = ""npmRegistryURL""; @Parameter(defaultValue = """", property = ""frontend.bun.arguments"", required = false)
    private String arguments; @Parameter(property = ""frontend.bun.bunInheritsProxyConfigFromMaven"", required = false,
            defaultValue = ""true"")
    private boolean bunInheritsProxyConfigFromMaven; @Parameter(property = NPM_REGISTRY_URL, required = false, defaultValue = """")
    private String npmRegistryURL; @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session; @Component
    private BuildContext buildContext; @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter; @Parameter(property = ""skip.bun"", defaultValue = ""${ skip.bun} "")
    private boolean skip; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { File packageJson = new File(this.workingDirectory, ""package.json""); if (this.buildContext == null || this.buildContext.hasDelta(packageJson)
                || !this.buildContext.isIncremental()) { ProxyConfig proxyConfig = getProxyConfig(); factory.getBunRunner(proxyConfig, getRegistryUrl()).execute(this.arguments,
                    this.environmentVariables); } else { getLog().info(""Skipping bun install as package.json unchanged""); } } private ProxyConfig getProxyConfig() { if (this.bunInheritsProxyConfigFromMaven) { return MojoUtils.getProxyConfig(this.session, this.decrypter); } else { getLog().info(""bun not inheriting proxy config from Maven""); return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList()); } } private String getRegistryUrl() { return System.getProperty(NPM_REGISTRY_URL, this.npmRegistryURL); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name = ""bun"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class BunMojo extends AbstractFrontendMojo { private static final String NPM_REGISTRY_URL = ""npmRegistryURL""; @Parameter(defaultValue = """", property = ""frontend.bun.arguments"", required = false)
    private String arguments; @Parameter(property = ""frontend.bun.bunInheritsProxyConfigFromMaven"", required = false,
            defaultValue = ""true"")
    private boolean bunInheritsProxyConfigFromMaven; @Parameter(property = NPM_REGISTRY_URL, required = false, defaultValue = """")
    private String npmRegistryURL; @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session; @Component
    private BuildContext buildContext; @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter; @Parameter(property = ""skip.bun"", defaultValue = ""${ skip.bun} "")
    private boolean skip; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { File packageJson = new File(this.workingDirectory, ""package.json""); if (this.buildContext == null || this.buildContext.hasDelta(packageJson)
                || !this.buildContext.isIncremental()) { ProxyConfig proxyConfig = getProxyConfig(); factory.getBunRunner(proxyConfig, getRegistryUrl()).execute(this.arguments,
                    this.environmentVariables); } else { getLog().info(""Skipping bun install as package.json unchanged""); } } private ProxyConfig getProxyConfig() { if (this.bunInheritsProxyConfigFromMaven) { return MojoUtils.getProxyConfig(this.session, this.decrypter); } else { getLog().info(""bun not inheriting proxy config from Maven""); return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList()); } } private String getRegistryUrl() { return System.getProperty(NPM_REGISTRY_URL, this.npmRegistryURL); } } ","package com.github.eirslett.maven.plugins.frontend.mojo; 
import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory; import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig; import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException; import org.apache.maven.execution.MavenSession; import org.apache.maven.plugins.annotations.Component; import org.apache.maven.plugins.annotations.LifecyclePhase; import org.apache.maven.plugins.annotations.Mojo; import org.apache.maven.plugins.annotations.Parameter; import org.apache.maven.settings.crypto.SettingsDecrypter; import org.sonatype.plexus.build.incremental.BuildContext; 
import java.io.File; import java.util.Collections;  @Mojo(name = ""bun"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class BunMojo extends AbstractFrontendMojo {  private static final String NPM_REGISTRY_URL = ""npmRegistryURL"";  /**
     * bun arguments. Default is ""install"".
     */ @Parameter(defaultValue = """", property = ""frontend.bun.arguments"", required = false)
    private String arguments;  @Parameter(property = ""frontend.bun.bunInheritsProxyConfigFromMaven"", required = false,
            defaultValue = ""true"")
    private boolean bunInheritsProxyConfigFromMaven;  /**
     * Registry override, passed as the registry option during npm install if set.
     */ @Parameter(property = NPM_REGISTRY_URL, required = false, defaultValue = """")
    private String npmRegistryURL;  @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session;  @Component
    private BuildContext buildContext;  @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter;  /**
     * Skips execution of this mojo.
     */ @Parameter(property = ""skip.bun"", defaultValue = ""${ skip.bun} "")
    private boolean skip;  @Override
    protected boolean skipExecution() { return this.skip; }  @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { File packageJson = new File(this.workingDirectory, ""package.json""); if (this.buildContext == null || this.buildContext.hasDelta(packageJson)
                || !this.buildContext.isIncremental()) { ProxyConfig proxyConfig = getProxyConfig(); factory.getBunRunner(proxyConfig, getRegistryUrl()).execute(this.arguments,
                    this.environmentVariables); } else { getLog().info(""Skipping bun install as package.json unchanged""); } }  private ProxyConfig getProxyConfig() { if (this.bunInheritsProxyConfigFromMaven) { return MojoUtils.getProxyConfig(this.session, this.decrypter); } else { getLog().info(""bun not inheriting proxy config from Maven""); return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList()); } }  private String getRegistryUrl() { // check to see if overridden via `-D`, otherwise fallback to pom value return System.getProperty(NPM_REGISTRY_URL, this.npmRegistryURL); } }  "
frontend-maven-plugin/src/main/java/com/github/eirslett/maven/plugins/frontend/mojo/CorepackMojo.java,"package com.github.eirslett.maven.plugins.frontend.mojo;

import java.io.File;

import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.settings.crypto.SettingsDecrypter;
import org.sonatype.plexus.build.incremental.BuildContext;

import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory;
import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException;

@Mojo(name=""corepack"",  defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class CorepackMojo extends AbstractFrontendMojo {

    /**
     * corepack arguments. Default is ""enable"".
     */
    @Parameter(defaultValue = ""enable"", property = ""frontend.corepack.arguments"", required = false)
    private String arguments;

    @Parameter(property = ""session"", defaultValue = ""${session}"", readonly = true)
    private MavenSession session;

    @Component
    private BuildContext buildContext;

    @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter;

    /**
     * Skips execution of this mojo.
     */
    @Parameter(property = ""skip.corepack"", defaultValue = ""${skip.corepack}"")
    private boolean skip;

    @Override
    protected boolean skipExecution() {
        return this.skip;
    }

    @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException {
        File packageJson = new File(workingDirectory, ""package.json"");
        if (buildContext == null || buildContext.hasDelta(packageJson) || !buildContext.isIncremental()) {
            factory.getCorepackRunner().execute(arguments, environmentVariables);
        } else {
            getLog().info(""Skipping corepack install as package.json unchanged"");
        }
    }
}
","package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""corepack"",  defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class CorepackMojo extends AbstractFrontendMojo { @Parameter(defaultValue = ""enable"", property = ""frontend.corepack.arguments"", required = false)
    private String arguments; @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session; @Component
    private BuildContext buildContext; @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter; @Parameter(property = ""skip.corepack"", defaultValue = ""${ skip.corepack} "")
    private boolean skip; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { File packageJson = new File(workingDirectory, ""package.json""); if (buildContext == null || buildContext.hasDelta(packageJson) || !buildContext.isIncremental()) { factory.getCorepackRunner().execute(arguments, environmentVariables); } else { getLog().info(""Skipping corepack install as package.json unchanged""); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""corepack"",  defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class CorepackMojo extends AbstractFrontendMojo { @Parameter(defaultValue = ""enable"", property = ""frontend.corepack.arguments"", required = false)
    private String arguments; @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session; @Component
    private BuildContext buildContext; @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter; @Parameter(property = ""skip.corepack"", defaultValue = ""${ skip.corepack} "")
    private boolean skip; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { File packageJson = new File(workingDirectory, ""package.json""); if (buildContext == null || buildContext.hasDelta(packageJson) || !buildContext.isIncremental()) { factory.getCorepackRunner().execute(arguments, environmentVariables); } else { getLog().info(""Skipping corepack install as package.json unchanged""); } } } ","package com.github.eirslett.maven.plugins.frontend.mojo; 
import java.io.File; 
import org.apache.maven.execution.MavenSession; import org.apache.maven.plugins.annotations.Component; import org.apache.maven.plugins.annotations.LifecyclePhase; import org.apache.maven.plugins.annotations.Mojo; import org.apache.maven.plugins.annotations.Parameter; import org.apache.maven.settings.crypto.SettingsDecrypter; import org.sonatype.plexus.build.incremental.BuildContext; 
import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory; import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException;  @Mojo(name=""corepack"",  defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class CorepackMojo extends AbstractFrontendMojo {  /**
     * corepack arguments. Default is ""enable"".
     */ @Parameter(defaultValue = ""enable"", property = ""frontend.corepack.arguments"", required = false)
    private String arguments;  @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session;  @Component
    private BuildContext buildContext;  @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter;  /**
     * Skips execution of this mojo.
     */ @Parameter(property = ""skip.corepack"", defaultValue = ""${ skip.corepack} "")
    private boolean skip;  @Override
    protected boolean skipExecution() { return this.skip; }  @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { File packageJson = new File(workingDirectory, ""package.json""); if (buildContext == null || buildContext.hasDelta(packageJson) || !buildContext.isIncremental()) { factory.getCorepackRunner().execute(arguments, environmentVariables); } else { getLog().info(""Skipping corepack install as package.json unchanged""); } } }  "
frontend-maven-plugin/src/main/java/com/github/eirslett/maven/plugins/frontend/mojo/EmberMojo.java,"package com.github.eirslett.maven.plugins.frontend.mojo;

import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory;
import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.sonatype.plexus.build.incremental.BuildContext;

import java.io.File;
import java.util.Arrays;
import java.util.List;

@Mojo(name=""ember"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class EmberMojo extends AbstractFrontendMojo {

    /**
     * Grunt arguments. Default is empty (runs just the ""grunt"" command).
     */
    @Parameter(property = ""frontend.ember.arguments"")
    private String arguments;

    /**
     * Files that should be checked for changes, in addition to the srcdir files.
     * {@link #workingDirectory}.
     */
    @Parameter(property = ""triggerfiles"")
    private List<File> triggerfiles;

    /**
     * The directory containing front end files that will be processed by grunt.
     * If this is set then files in the directory will be checked for
     * modifications before running grunt.
     */
    @Parameter(property = ""srcdir"")
    private File srcdir;

    /**
     * The directory where front end files will be output by grunt. If this is
     * set then they will be refreshed so they correctly show as modified in
     * Eclipse.
     */
    @Parameter(property = ""outputdir"")
    private File outputdir;

    /**
     * Skips execution of this mojo.
     */
    @Parameter(property = ""skip.ember"", defaultValue = ""${skip.ember}"")
    private boolean skip;

    @Component
    private BuildContext buildContext;

    @Override
    protected boolean skipExecution() {
        return this.skip;
    }

    @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException {
        if (shouldExecute()) {
            factory.getEmberRunner().execute(arguments, environmentVariables);

            if (outputdir != null) {
                getLog().info(""Refreshing files after ember: "" + outputdir);
                buildContext.refresh(outputdir);
            }
        } else {
            getLog().info(""Skipping ember as no modified files in "" + srcdir);
        }
    }

    private boolean shouldExecute() {

        if (triggerfiles == null || triggerfiles.isEmpty()) {
            triggerfiles = Arrays.asList(new File(workingDirectory, ""Gruntfile.js""));
        }

        return MojoUtils.shouldExecute(buildContext, triggerfiles, srcdir);
    }

}","package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""ember"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class EmberMojo extends AbstractFrontendMojo { @Parameter(property = ""frontend.ember.arguments"")
    private String arguments; @Parameter(property = ""triggerfiles"")
    private List<File> triggerfiles; @Parameter(property = ""srcdir"")
    private File srcdir; @Parameter(property = ""outputdir"")
    private File outputdir; @Parameter(property = ""skip.ember"", defaultValue = ""${ skip.ember} "")
    private boolean skip; @Component
    private BuildContext buildContext; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { if (shouldExecute()) { factory.getEmberRunner().execute(arguments, environmentVariables); if (outputdir != null) { getLog().info(""Refreshing files after ember: "" + outputdir); buildContext.refresh(outputdir); } } else { getLog().info(""Skipping ember as no modified files in "" + srcdir); } } private boolean shouldExecute() { if (triggerfiles == null || triggerfiles.isEmpty()) { triggerfiles = Arrays.asList(new File(workingDirectory, ""Gruntfile.js"")); } return MojoUtils.shouldExecute(buildContext, triggerfiles, srcdir); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""ember"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class EmberMojo extends AbstractFrontendMojo { @Parameter(property = ""frontend.ember.arguments"")
    private String arguments; @Parameter(property = ""triggerfiles"")
    private List<File> triggerfiles; @Parameter(property = ""srcdir"")
    private File srcdir; @Parameter(property = ""outputdir"")
    private File outputdir; @Parameter(property = ""skip.ember"", defaultValue = ""${ skip.ember} "")
    private boolean skip; @Component
    private BuildContext buildContext; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { if (shouldExecute()) { factory.getEmberRunner().execute(arguments, environmentVariables); if (outputdir != null) { getLog().info(""Refreshing files after ember: "" + outputdir); buildContext.refresh(outputdir); } } else { getLog().info(""Skipping ember as no modified files in "" + srcdir); } } private boolean shouldExecute() { if (triggerfiles == null || triggerfiles.isEmpty()) { triggerfiles = Arrays.asList(new File(workingDirectory, ""Gruntfile.js"")); } return MojoUtils.shouldExecute(buildContext, triggerfiles, srcdir); } }","package com.github.eirslett.maven.plugins.frontend.mojo; 
import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory; import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException; import org.apache.maven.plugins.annotations.Component; import org.apache.maven.plugins.annotations.LifecyclePhase; import org.apache.maven.plugins.annotations.Mojo; import org.apache.maven.plugins.annotations.Parameter; import org.sonatype.plexus.build.incremental.BuildContext; 
import java.io.File; import java.util.Arrays; import java.util.List;  @Mojo(name=""ember"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class EmberMojo extends AbstractFrontendMojo {  /**
     * Grunt arguments. Default is empty (runs just the ""grunt"" command).
     */ @Parameter(property = ""frontend.ember.arguments"")
    private String arguments;  /**
     * Files that should be checked for changes, in addition to the srcdir files.
     * {@link #workingDirectory}.
     */ @Parameter(property = ""triggerfiles"")
    private List<File> triggerfiles;  /**
     * The directory containing front end files that will be processed by grunt.
     * If this is set then files in the directory will be checked for
     * modifications before running grunt.
     */ @Parameter(property = ""srcdir"")
    private File srcdir;  /**
     * The directory where front end files will be output by grunt. If this is
     * set then they will be refreshed so they correctly show as modified in
     * Eclipse.
     */ @Parameter(property = ""outputdir"")
    private File outputdir;  /**
     * Skips execution of this mojo.
     */ @Parameter(property = ""skip.ember"", defaultValue = ""${ skip.ember} "")
    private boolean skip;  @Component
    private BuildContext buildContext;  @Override
    protected boolean skipExecution() { return this.skip; }  @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { if (shouldExecute()) { factory.getEmberRunner().execute(arguments, environmentVariables);  if (outputdir != null) { getLog().info(""Refreshing files after ember: "" + outputdir); buildContext.refresh(outputdir); } } else { getLog().info(""Skipping ember as no modified files in "" + srcdir); } }  private boolean shouldExecute() {  if (triggerfiles == null || triggerfiles.isEmpty()) { triggerfiles = Arrays.asList(new File(workingDirectory, ""Gruntfile.js"")); }  return MojoUtils.shouldExecute(buildContext, triggerfiles, srcdir); }  }"
frontend-maven-plugin/src/main/java/com/github/eirslett/maven/plugins/frontend/mojo/GruntMojo.java,"package com.github.eirslett.maven.plugins.frontend.mojo;

import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory;
import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.sonatype.plexus.build.incremental.BuildContext;

import java.io.File;
import java.util.Arrays;
import java.util.List;

@Mojo(name=""grunt"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class GruntMojo extends AbstractFrontendMojo {

    /**
     * Grunt arguments. Default is empty (runs just the ""grunt"" command).
     */
    @Parameter(property = ""frontend.grunt.arguments"")
    private String arguments;

    /**
     * Files that should be checked for changes, in addition to the srcdir files.
     * Defaults to Gruntfile.js in the {@link #workingDirectory}.
     */
    @Parameter(property = ""triggerfiles"")
    private List<File> triggerfiles;

    /**
     * The directory containing front end files that will be processed by grunt.
     * If this is set then files in the directory will be checked for
     * modifications before running grunt.
     */
    @Parameter(property = ""srcdir"")
    private File srcdir;

    /**
     * The directory where front end files will be output by grunt. If this is
     * set then they will be refreshed so they correctly show as modified in
     * Eclipse.
     */
    @Parameter(property = ""outputdir"")
    private File outputdir;

    /**
     * Skips execution of this mojo.
     */
    @Parameter(property = ""skip.grunt"", defaultValue = ""${skip.grunt}"")
    private boolean skip;

    @Component
    private BuildContext buildContext;

    @Override
    protected boolean skipExecution() {
        return this.skip;
    }

    @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException {
        if (shouldExecute()) {
            factory.getGruntRunner().execute(arguments, environmentVariables);

            if (outputdir != null) {
                getLog().info(""Refreshing files after grunt: "" + outputdir);
                buildContext.refresh(outputdir);
            }
        } else {
            getLog().info(""Skipping grunt as no modified files in "" + srcdir);
        }
    }

    private boolean shouldExecute() {
        if (triggerfiles == null || triggerfiles.isEmpty()) {
            triggerfiles = Arrays.asList(new File(workingDirectory, ""Gruntfile.js""));
        }

        return MojoUtils.shouldExecute(buildContext, triggerfiles, srcdir);
    }

}","package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""grunt"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class GruntMojo extends AbstractFrontendMojo { @Parameter(property = ""frontend.grunt.arguments"")
    private String arguments; @Parameter(property = ""triggerfiles"")
    private List<File> triggerfiles; @Parameter(property = ""srcdir"")
    private File srcdir; @Parameter(property = ""outputdir"")
    private File outputdir; @Parameter(property = ""skip.grunt"", defaultValue = ""${ skip.grunt} "")
    private boolean skip; @Component
    private BuildContext buildContext; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { if (shouldExecute()) { factory.getGruntRunner().execute(arguments, environmentVariables); if (outputdir != null) { getLog().info(""Refreshing files after grunt: "" + outputdir); buildContext.refresh(outputdir); } } else { getLog().info(""Skipping grunt as no modified files in "" + srcdir); } } private boolean shouldExecute() { if (triggerfiles == null || triggerfiles.isEmpty()) { triggerfiles = Arrays.asList(new File(workingDirectory, ""Gruntfile.js"")); } return MojoUtils.shouldExecute(buildContext, triggerfiles, srcdir); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""grunt"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class GruntMojo extends AbstractFrontendMojo { @Parameter(property = ""frontend.grunt.arguments"")
    private String arguments; @Parameter(property = ""triggerfiles"")
    private List<File> triggerfiles; @Parameter(property = ""srcdir"")
    private File srcdir; @Parameter(property = ""outputdir"")
    private File outputdir; @Parameter(property = ""skip.grunt"", defaultValue = ""${ skip.grunt} "")
    private boolean skip; @Component
    private BuildContext buildContext; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { if (shouldExecute()) { factory.getGruntRunner().execute(arguments, environmentVariables); if (outputdir != null) { getLog().info(""Refreshing files after grunt: "" + outputdir); buildContext.refresh(outputdir); } } else { getLog().info(""Skipping grunt as no modified files in "" + srcdir); } } private boolean shouldExecute() { if (triggerfiles == null || triggerfiles.isEmpty()) { triggerfiles = Arrays.asList(new File(workingDirectory, ""Gruntfile.js"")); } return MojoUtils.shouldExecute(buildContext, triggerfiles, srcdir); } }","package com.github.eirslett.maven.plugins.frontend.mojo; 
import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory; import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException; import org.apache.maven.plugins.annotations.Component; import org.apache.maven.plugins.annotations.LifecyclePhase; import org.apache.maven.plugins.annotations.Mojo; import org.apache.maven.plugins.annotations.Parameter; import org.sonatype.plexus.build.incremental.BuildContext; 
import java.io.File; import java.util.Arrays; import java.util.List;  @Mojo(name=""grunt"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class GruntMojo extends AbstractFrontendMojo {  /**
     * Grunt arguments. Default is empty (runs just the ""grunt"" command).
     */ @Parameter(property = ""frontend.grunt.arguments"")
    private String arguments;  /**
     * Files that should be checked for changes, in addition to the srcdir files.
     * Defaults to Gruntfile.js in the {@link #workingDirectory}.
     */ @Parameter(property = ""triggerfiles"")
    private List<File> triggerfiles;  /**
     * The directory containing front end files that will be processed by grunt.
     * If this is set then files in the directory will be checked for
     * modifications before running grunt.
     */ @Parameter(property = ""srcdir"")
    private File srcdir;  /**
     * The directory where front end files will be output by grunt. If this is
     * set then they will be refreshed so they correctly show as modified in
     * Eclipse.
     */ @Parameter(property = ""outputdir"")
    private File outputdir;  /**
     * Skips execution of this mojo.
     */ @Parameter(property = ""skip.grunt"", defaultValue = ""${ skip.grunt} "")
    private boolean skip;  @Component
    private BuildContext buildContext;  @Override
    protected boolean skipExecution() { return this.skip; }  @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { if (shouldExecute()) { factory.getGruntRunner().execute(arguments, environmentVariables);  if (outputdir != null) { getLog().info(""Refreshing files after grunt: "" + outputdir); buildContext.refresh(outputdir); } } else { getLog().info(""Skipping grunt as no modified files in "" + srcdir); } }  private boolean shouldExecute() { if (triggerfiles == null || triggerfiles.isEmpty()) { triggerfiles = Arrays.asList(new File(workingDirectory, ""Gruntfile.js"")); }  return MojoUtils.shouldExecute(buildContext, triggerfiles, srcdir); }  }"
frontend-maven-plugin/src/main/java/com/github/eirslett/maven/plugins/frontend/mojo/GulpMojo.java,"package com.github.eirslett.maven.plugins.frontend.mojo;

import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory;
import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.sonatype.plexus.build.incremental.BuildContext;

import java.io.File;
import java.util.Arrays;
import java.util.List;

@Mojo(name=""gulp"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class GulpMojo extends AbstractFrontendMojo {

    /**
     * Gulp arguments. Default is empty (runs just the ""gulp"" command).
     */
    @Parameter(property = ""frontend.gulp.arguments"")
    private String arguments;

    /**
     * Files that should be checked for changes, in addition to the srcdir files.
     * Defaults to gulpfile.js in the {@link #workingDirectory}.
     */
    @Parameter(property = ""triggerfiles"")
    private List<File> triggerfiles;

    /**
     * The directory containing front end files that will be processed by gulp.
     * If this is set then files in the directory will be checked for
     * modifications before running gulp.
     */
    @Parameter(property = ""srcdir"")
    private File srcdir;

    /**
     * The directory where front end files will be output by gulp. If this is
     * set then they will be refreshed so they correctly show as modified in
     * Eclipse.
     */
    @Parameter(property = ""outputdir"")
    private File outputdir;

    /**
     * Skips execution of this mojo.
     */
    @Parameter(property = ""skip.gulp"", defaultValue = ""${skip.gulp}"")
    private boolean skip;

    @Component
    private BuildContext buildContext;

    @Override
    protected boolean skipExecution() {
        return this.skip;
    }

    @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException {
        if (shouldExecute()) {
            factory.getGulpRunner().execute(arguments, environmentVariables);

            if (outputdir != null) {
                getLog().info(""Refreshing files after gulp: "" + outputdir);
                buildContext.refresh(outputdir);
            }
        } else {
            getLog().info(""Skipping gulp as no modified files in "" + srcdir);
        }
    }

    private boolean shouldExecute() {
        if (triggerfiles == null || triggerfiles.isEmpty()) {
            triggerfiles = Arrays.asList(new File(workingDirectory, ""gulpfile.js""));
        }

        return MojoUtils.shouldExecute(buildContext, triggerfiles, srcdir);
    }

}
","package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""gulp"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class GulpMojo extends AbstractFrontendMojo { @Parameter(property = ""frontend.gulp.arguments"")
    private String arguments; @Parameter(property = ""triggerfiles"")
    private List<File> triggerfiles; @Parameter(property = ""srcdir"")
    private File srcdir; @Parameter(property = ""outputdir"")
    private File outputdir; @Parameter(property = ""skip.gulp"", defaultValue = ""${ skip.gulp} "")
    private boolean skip; @Component
    private BuildContext buildContext; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { if (shouldExecute()) { factory.getGulpRunner().execute(arguments, environmentVariables); if (outputdir != null) { getLog().info(""Refreshing files after gulp: "" + outputdir); buildContext.refresh(outputdir); } } else { getLog().info(""Skipping gulp as no modified files in "" + srcdir); } } private boolean shouldExecute() { if (triggerfiles == null || triggerfiles.isEmpty()) { triggerfiles = Arrays.asList(new File(workingDirectory, ""gulpfile.js"")); } return MojoUtils.shouldExecute(buildContext, triggerfiles, srcdir); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""gulp"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class GulpMojo extends AbstractFrontendMojo { @Parameter(property = ""frontend.gulp.arguments"")
    private String arguments; @Parameter(property = ""triggerfiles"")
    private List<File> triggerfiles; @Parameter(property = ""srcdir"")
    private File srcdir; @Parameter(property = ""outputdir"")
    private File outputdir; @Parameter(property = ""skip.gulp"", defaultValue = ""${ skip.gulp} "")
    private boolean skip; @Component
    private BuildContext buildContext; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { if (shouldExecute()) { factory.getGulpRunner().execute(arguments, environmentVariables); if (outputdir != null) { getLog().info(""Refreshing files after gulp: "" + outputdir); buildContext.refresh(outputdir); } } else { getLog().info(""Skipping gulp as no modified files in "" + srcdir); } } private boolean shouldExecute() { if (triggerfiles == null || triggerfiles.isEmpty()) { triggerfiles = Arrays.asList(new File(workingDirectory, ""gulpfile.js"")); } return MojoUtils.shouldExecute(buildContext, triggerfiles, srcdir); } } ","package com.github.eirslett.maven.plugins.frontend.mojo; 
import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory; import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException; import org.apache.maven.plugins.annotations.Component; import org.apache.maven.plugins.annotations.LifecyclePhase; import org.apache.maven.plugins.annotations.Mojo; import org.apache.maven.plugins.annotations.Parameter; import org.sonatype.plexus.build.incremental.BuildContext; 
import java.io.File; import java.util.Arrays; import java.util.List;  @Mojo(name=""gulp"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class GulpMojo extends AbstractFrontendMojo {  /**
     * Gulp arguments. Default is empty (runs just the ""gulp"" command).
     */ @Parameter(property = ""frontend.gulp.arguments"")
    private String arguments;  /**
     * Files that should be checked for changes, in addition to the srcdir files.
     * Defaults to gulpfile.js in the {@link #workingDirectory}.
     */ @Parameter(property = ""triggerfiles"")
    private List<File> triggerfiles;  /**
     * The directory containing front end files that will be processed by gulp.
     * If this is set then files in the directory will be checked for
     * modifications before running gulp.
     */ @Parameter(property = ""srcdir"")
    private File srcdir;  /**
     * The directory where front end files will be output by gulp. If this is
     * set then they will be refreshed so they correctly show as modified in
     * Eclipse.
     */ @Parameter(property = ""outputdir"")
    private File outputdir;  /**
     * Skips execution of this mojo.
     */ @Parameter(property = ""skip.gulp"", defaultValue = ""${ skip.gulp} "")
    private boolean skip;  @Component
    private BuildContext buildContext;  @Override
    protected boolean skipExecution() { return this.skip; }  @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { if (shouldExecute()) { factory.getGulpRunner().execute(arguments, environmentVariables);  if (outputdir != null) { getLog().info(""Refreshing files after gulp: "" + outputdir); buildContext.refresh(outputdir); } } else { getLog().info(""Skipping gulp as no modified files in "" + srcdir); } }  private boolean shouldExecute() { if (triggerfiles == null || triggerfiles.isEmpty()) { triggerfiles = Arrays.asList(new File(workingDirectory, ""gulpfile.js"")); }  return MojoUtils.shouldExecute(buildContext, triggerfiles, srcdir); }  }  "
frontend-maven-plugin/src/main/java/com/github/eirslett/maven/plugins/frontend/mojo/InstallBunMojo.java,"package com.github.eirslett.maven.plugins.frontend.mojo;

import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory;
import com.github.eirslett.maven.plugins.frontend.lib.InstallationException;
import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.settings.Server;
import org.apache.maven.settings.crypto.SettingsDecrypter;

@Mojo(name = ""install-bun"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class InstallBunMojo extends AbstractFrontendMojo {

    /**
     * The version of Bun to install. IMPORTANT! Most Bun version names start with 'v', for example
     * 'v1.0.0'
     */
    @Parameter(property = ""bunVersion"", required = true)
    private String bunVersion;

    /**
     * Server Id for download username and password
     */
    @Parameter(property = ""serverId"", defaultValue = """")
    private String serverId;

    @Parameter(property = ""session"", defaultValue = ""${session}"", readonly = true)
    private MavenSession session;

    /**
     * Skips execution of this mojo.
     */
    @Parameter(property = ""skip.installbun"", alias = ""skip.installbun"", defaultValue = ""${skip.installbun}"")
    private boolean skip;

    @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter;

    @Override
    protected boolean skipExecution() {
        return this.skip;
    }

    @Override
    public void execute(FrontendPluginFactory factory) throws InstallationException {
        ProxyConfig proxyConfig = MojoUtils.getProxyConfig(this.session, this.decrypter);
        Server server = MojoUtils.decryptServer(this.serverId, this.session, this.decrypter);
        if (null != server) {
            factory.getBunInstaller(proxyConfig).setBunVersion(this.bunVersion).setUserName(server.getUsername())
                    .setPassword(server.getPassword()).setHttpHeaders(getHttpHeaders(server)).install();
        } else {
            factory.getBunInstaller(proxyConfig).setBunVersion(this.bunVersion).install();
        }
    }

}
","package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name = ""install-bun"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class InstallBunMojo extends AbstractFrontendMojo { @Parameter(property = ""bunVersion"", required = true)
    private String bunVersion; @Parameter(property = ""serverId"", defaultValue = """")
    private String serverId; @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session; @Parameter(property = ""skip.installbun"", alias = ""skip.installbun"", defaultValue = ""${ skip.installbun} "")
    private boolean skip; @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public void execute(FrontendPluginFactory factory) throws InstallationException { ProxyConfig proxyConfig = MojoUtils.getProxyConfig(this.session, this.decrypter); Server server = MojoUtils.decryptServer(this.serverId, this.session, this.decrypter); if (null != server) { factory.getBunInstaller(proxyConfig).setBunVersion(this.bunVersion).setUserName(server.getUsername())
                    .setPassword(server.getPassword()).setHttpHeaders(getHttpHeaders(server)).install(); } else { factory.getBunInstaller(proxyConfig).setBunVersion(this.bunVersion).install(); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name = ""install-bun"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class InstallBunMojo extends AbstractFrontendMojo { @Parameter(property = ""bunVersion"", required = true)
    private String bunVersion; @Parameter(property = ""serverId"", defaultValue = """")
    private String serverId; @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session; @Parameter(property = ""skip.installbun"", alias = ""skip.installbun"", defaultValue = ""${ skip.installbun} "")
    private boolean skip; @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public void execute(FrontendPluginFactory factory) throws InstallationException { ProxyConfig proxyConfig = MojoUtils.getProxyConfig(this.session, this.decrypter); Server server = MojoUtils.decryptServer(this.serverId, this.session, this.decrypter); if (null != server) { factory.getBunInstaller(proxyConfig).setBunVersion(this.bunVersion).setUserName(server.getUsername())
                    .setPassword(server.getPassword()).setHttpHeaders(getHttpHeaders(server)).install(); } else { factory.getBunInstaller(proxyConfig).setBunVersion(this.bunVersion).install(); } } } ","package com.github.eirslett.maven.plugins.frontend.mojo; 
import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory; import com.github.eirslett.maven.plugins.frontend.lib.InstallationException; import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig; import org.apache.maven.execution.MavenSession; import org.apache.maven.plugins.annotations.Component; import org.apache.maven.plugins.annotations.LifecyclePhase; import org.apache.maven.plugins.annotations.Mojo; import org.apache.maven.plugins.annotations.Parameter; import org.apache.maven.settings.Server; import org.apache.maven.settings.crypto.SettingsDecrypter;  @Mojo(name = ""install-bun"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class InstallBunMojo extends AbstractFrontendMojo {  /**
     * The version of Bun to install. IMPORTANT! Most Bun version names start with 'v', for example
     * 'v1.0.0'
     */ @Parameter(property = ""bunVersion"", required = true)
    private String bunVersion;  /**
     * Server Id for download username and password
     */ @Parameter(property = ""serverId"", defaultValue = """")
    private String serverId;  @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session;  /**
     * Skips execution of this mojo.
     */ @Parameter(property = ""skip.installbun"", alias = ""skip.installbun"", defaultValue = ""${ skip.installbun} "")
    private boolean skip;  @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter;  @Override
    protected boolean skipExecution() { return this.skip; }  @Override
    public void execute(FrontendPluginFactory factory) throws InstallationException { ProxyConfig proxyConfig = MojoUtils.getProxyConfig(this.session, this.decrypter); Server server = MojoUtils.decryptServer(this.serverId, this.session, this.decrypter); if (null != server) { factory.getBunInstaller(proxyConfig).setBunVersion(this.bunVersion).setUserName(server.getUsername())
                    .setPassword(server.getPassword()).setHttpHeaders(getHttpHeaders(server)).install(); } else { factory.getBunInstaller(proxyConfig).setBunVersion(this.bunVersion).install(); } }  }  "
frontend-maven-plugin/src/main/java/com/github/eirslett/maven/plugins/frontend/mojo/InstallNodeAndCorepackMojo.java,"package com.github.eirslett.maven.plugins.frontend.mojo;

import com.github.eirslett.maven.plugins.frontend.lib.CorepackInstaller;
import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory;
import com.github.eirslett.maven.plugins.frontend.lib.InstallationException;
import com.github.eirslett.maven.plugins.frontend.lib.NodeInstaller;
import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig;

import java.util.Map;

import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.settings.crypto.SettingsDecrypter;
import org.apache.maven.settings.Server;

@Mojo(name=""install-node-and-corepack"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class InstallNodeAndCorepackMojo extends AbstractFrontendMojo {

    /**
     * Where to download Node.js binary from. Defaults to https://nodejs.org/dist/
     */
    @Parameter(property = ""nodeDownloadRoot"", required = false)
    private String nodeDownloadRoot;

    /**
     * Where to download corepack binary from. Defaults to https://registry.npmjs.org/corepack/-/
     */
    @Parameter(property = ""corepackDownloadRoot"", required = false, defaultValue = CorepackInstaller.DEFAULT_COREPACK_DOWNLOAD_ROOT)
    private String corepackDownloadRoot;

    /**
     * The version of Node.js to install. IMPORTANT! Most Node.js version names start with 'v', for example 'v0.10.18'
     */
    @Parameter(property=""nodeVersion"", required = true)
    private String nodeVersion;

    /**
     * The version of corepack to install. Note that the version string can optionally be prefixed with
     * 'v' (i.e., both 'v1.2.3' and '1.2.3' are valid).
     *
     * If not provided, then the corepack version bundled with Node will be used.
     */
    @Parameter(property = ""corepackVersion"", required = false, defaultValue = ""provided"")
    private String corepackVersion;

    /**
     * Server Id for download username and password
     */
    @Parameter(property = ""serverId"", defaultValue = """")
    private String serverId;

    @Parameter(property = ""session"", defaultValue = ""${session}"", readonly = true)
    private MavenSession session;

    /**
     * Skips execution of this mojo.
     */
    @Parameter(property = ""skip.installnodecorepack"", defaultValue = ""${skip.installnodecorepack}"")
    private boolean skip;

    @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter;

    @Override
    protected boolean skipExecution() {
        return this.skip;
    }

    @Override
    public void execute(FrontendPluginFactory factory) throws InstallationException {
        ProxyConfig proxyConfig = MojoUtils.getProxyConfig(session, decrypter);
        String resolvedNodeDownloadRoot = getNodeDownloadRoot();
        String resolvedCorepackDownloadRoot = getCorepackDownloadRoot();

        // Setup the installers
        NodeInstaller nodeInstaller = factory.getNodeInstaller(proxyConfig);
        nodeInstaller.setNodeVersion(nodeVersion)
                .setNodeDownloadRoot(resolvedNodeDownloadRoot);
        if (""provided"".equals(corepackVersion)) {
            // This causes the node installer to copy over the whole
            // node_modules directory including the corepack module
            nodeInstaller.setNpmVersion(""provided"");
        }
        CorepackInstaller corepackInstaller = factory.getCorepackInstaller(proxyConfig);
        corepackInstaller.setCorepackVersion(corepackVersion)
                .setCorepackDownloadRoot(resolvedCorepackDownloadRoot);

        // If pplicable, configure authentication details
        Server server = MojoUtils.decryptServer(serverId, session, decrypter);
        if (null != server) {
            Map<String, String> httpHeaders = getHttpHeaders(server);
            nodeInstaller
                .setUserName(server.getUsername())
                .setPassword(server.getPassword())
                .setHttpHeaders(httpHeaders);
            corepackInstaller
                .setUserName(server.getUsername())
                .setPassword(server.getPassword())
                .setHttpHeaders(httpHeaders);
        }

        // Perform the installation
        nodeInstaller.install();
        corepackInstaller.install();
    }

    private String getNodeDownloadRoot() {
        return nodeDownloadRoot;
    }

    private String getCorepackDownloadRoot() {
        return corepackDownloadRoot;
    }
}
","package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""install-node-and-corepack"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class InstallNodeAndCorepackMojo extends AbstractFrontendMojo { @Parameter(property = ""nodeDownloadRoot"", required = false)
    private String nodeDownloadRoot; @Parameter(property = ""corepackDownloadRoot"", required = false, defaultValue = CorepackInstaller.DEFAULT_COREPACK_DOWNLOAD_ROOT)
    private String corepackDownloadRoot; @Parameter(property=""nodeVersion"", required = true)
    private String nodeVersion; @Parameter(property = ""corepackVersion"", required = false, defaultValue = ""provided"")
    private String corepackVersion; @Parameter(property = ""serverId"", defaultValue = """")
    private String serverId; @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session; @Parameter(property = ""skip.installnodecorepack"", defaultValue = ""${ skip.installnodecorepack} "")
    private boolean skip; @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public void execute(FrontendPluginFactory factory) throws InstallationException { ProxyConfig proxyConfig = MojoUtils.getProxyConfig(session, decrypter); String resolvedNodeDownloadRoot = getNodeDownloadRoot(); String resolvedCorepackDownloadRoot = getCorepackDownloadRoot(); NodeInstaller nodeInstaller = factory.getNodeInstaller(proxyConfig); nodeInstaller.setNodeVersion(nodeVersion)
                .setNodeDownloadRoot(resolvedNodeDownloadRoot); if (""provided"".equals(corepackVersion)) { nodeInstaller.setNpmVersion(""provided""); } CorepackInstaller corepackInstaller = factory.getCorepackInstaller(proxyConfig); corepackInstaller.setCorepackVersion(corepackVersion)
                .setCorepackDownloadRoot(resolvedCorepackDownloadRoot); Server server = MojoUtils.decryptServer(serverId, session, decrypter); if (null != server) { Map<String, String> httpHeaders = getHttpHeaders(server); nodeInstaller
                .setUserName(server.getUsername())
                .setPassword(server.getPassword())
                .setHttpHeaders(httpHeaders); corepackInstaller
                .setUserName(server.getUsername())
                .setPassword(server.getPassword())
                .setHttpHeaders(httpHeaders); } nodeInstaller.install(); corepackInstaller.install(); } private String getNodeDownloadRoot() { return nodeDownloadRoot; } private String getCorepackDownloadRoot() { return corepackDownloadRoot; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""install-node-and-corepack"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class InstallNodeAndCorepackMojo extends AbstractFrontendMojo { @Parameter(property = ""nodeDownloadRoot"", required = false)
    private String nodeDownloadRoot; @Parameter(property = ""corepackDownloadRoot"", required = false, defaultValue = CorepackInstaller.DEFAULT_COREPACK_DOWNLOAD_ROOT)
    private String corepackDownloadRoot; @Parameter(property=""nodeVersion"", required = true)
    private String nodeVersion; @Parameter(property = ""corepackVersion"", required = false, defaultValue = ""provided"")
    private String corepackVersion; @Parameter(property = ""serverId"", defaultValue = """")
    private String serverId; @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session; @Parameter(property = ""skip.installnodecorepack"", defaultValue = ""${ skip.installnodecorepack} "")
    private boolean skip; @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public void execute(FrontendPluginFactory factory) throws InstallationException { ProxyConfig proxyConfig = MojoUtils.getProxyConfig(session, decrypter); String resolvedNodeDownloadRoot = getNodeDownloadRoot(); String resolvedCorepackDownloadRoot = getCorepackDownloadRoot(); NodeInstaller nodeInstaller = factory.getNodeInstaller(proxyConfig); nodeInstaller.setNodeVersion(nodeVersion)
                .setNodeDownloadRoot(resolvedNodeDownloadRoot); if (""provided"".equals(corepackVersion)) { nodeInstaller.setNpmVersion(""provided""); } CorepackInstaller corepackInstaller = factory.getCorepackInstaller(proxyConfig); corepackInstaller.setCorepackVersion(corepackVersion)
                .setCorepackDownloadRoot(resolvedCorepackDownloadRoot); Server server = MojoUtils.decryptServer(serverId, session, decrypter); if (null != server) { Map<String, String> httpHeaders = getHttpHeaders(server); nodeInstaller
                .setUserName(server.getUsername())
                .setPassword(server.getPassword())
                .setHttpHeaders(httpHeaders); corepackInstaller
                .setUserName(server.getUsername())
                .setPassword(server.getPassword())
                .setHttpHeaders(httpHeaders); } nodeInstaller.install(); corepackInstaller.install(); } private String getNodeDownloadRoot() { return nodeDownloadRoot; } private String getCorepackDownloadRoot() { return corepackDownloadRoot; } } ","package com.github.eirslett.maven.plugins.frontend.mojo; 
import com.github.eirslett.maven.plugins.frontend.lib.CorepackInstaller; import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory; import com.github.eirslett.maven.plugins.frontend.lib.InstallationException; import com.github.eirslett.maven.plugins.frontend.lib.NodeInstaller; import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig; 
import java.util.Map; 
import org.apache.maven.execution.MavenSession; import org.apache.maven.plugins.annotations.Component; import org.apache.maven.plugins.annotations.LifecyclePhase; import org.apache.maven.plugins.annotations.Mojo; import org.apache.maven.plugins.annotations.Parameter; import org.apache.maven.settings.crypto.SettingsDecrypter; import org.apache.maven.settings.Server;  @Mojo(name=""install-node-and-corepack"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class InstallNodeAndCorepackMojo extends AbstractFrontendMojo {  /**
     * Where to download Node.js binary from. Defaults to https://nodejs.org/dist/
     */ @Parameter(property = ""nodeDownloadRoot"", required = false)
    private String nodeDownloadRoot;  /**
     * Where to download corepack binary from. Defaults to https://registry.npmjs.org/corepack/-/
     */ @Parameter(property = ""corepackDownloadRoot"", required = false, defaultValue = CorepackInstaller.DEFAULT_COREPACK_DOWNLOAD_ROOT)
    private String corepackDownloadRoot;  /**
     * The version of Node.js to install. IMPORTANT! Most Node.js version names start with 'v', for example 'v0.10.18'
     */ @Parameter(property=""nodeVersion"", required = true)
    private String nodeVersion;  /**
     * The version of corepack to install. Note that the version string can optionally be prefixed with
     * 'v' (i.e., both 'v1.2.3' and '1.2.3' are valid).
     *
     * If not provided, then the corepack version bundled with Node will be used.
     */ @Parameter(property = ""corepackVersion"", required = false, defaultValue = ""provided"")
    private String corepackVersion;  /**
     * Server Id for download username and password
     */ @Parameter(property = ""serverId"", defaultValue = """")
    private String serverId;  @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session;  /**
     * Skips execution of this mojo.
     */ @Parameter(property = ""skip.installnodecorepack"", defaultValue = ""${ skip.installnodecorepack} "")
    private boolean skip;  @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter;  @Override
    protected boolean skipExecution() { return this.skip; }  @Override
    public void execute(FrontendPluginFactory factory) throws InstallationException { ProxyConfig proxyConfig = MojoUtils.getProxyConfig(session, decrypter); String resolvedNodeDownloadRoot = getNodeDownloadRoot(); String resolvedCorepackDownloadRoot = getCorepackDownloadRoot();  // Setup the installers NodeInstaller nodeInstaller = factory.getNodeInstaller(proxyConfig); nodeInstaller.setNodeVersion(nodeVersion)
                .setNodeDownloadRoot(resolvedNodeDownloadRoot); if (""provided"".equals(corepackVersion)) { // This causes the node installer to copy over the whole // node_modules directory including the corepack module nodeInstaller.setNpmVersion(""provided""); } CorepackInstaller corepackInstaller = factory.getCorepackInstaller(proxyConfig); corepackInstaller.setCorepackVersion(corepackVersion)
                .setCorepackDownloadRoot(resolvedCorepackDownloadRoot);  // If pplicable, configure authentication details Server server = MojoUtils.decryptServer(serverId, session, decrypter); if (null != server) { Map<String, String> httpHeaders = getHttpHeaders(server); nodeInstaller
                .setUserName(server.getUsername())
                .setPassword(server.getPassword())
                .setHttpHeaders(httpHeaders); corepackInstaller
                .setUserName(server.getUsername())
                .setPassword(server.getPassword())
                .setHttpHeaders(httpHeaders); }  // Perform the installation nodeInstaller.install(); corepackInstaller.install(); }  private String getNodeDownloadRoot() { return nodeDownloadRoot; }  private String getCorepackDownloadRoot() { return corepackDownloadRoot; } }  "
frontend-maven-plugin/src/main/java/com/github/eirslett/maven/plugins/frontend/mojo/InstallNodeAndNpmMojo.java,"package com.github.eirslett.maven.plugins.frontend.mojo;

import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory;
import com.github.eirslett.maven.plugins.frontend.lib.InstallationException;
import com.github.eirslett.maven.plugins.frontend.lib.NPMInstaller;
import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig;

import java.util.Map;

import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.settings.crypto.SettingsDecrypter;
import org.apache.maven.settings.Server;

@Mojo(name=""install-node-and-npm"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class InstallNodeAndNpmMojo extends AbstractFrontendMojo {

    /**
     * Where to download Node.js binary from. Defaults to https://nodejs.org/dist/
     */
    @Parameter(property = ""nodeDownloadRoot"", required = false)
    private String nodeDownloadRoot;

    /**
     * Where to download NPM binary from. Defaults to https://registry.npmjs.org/npm/-/
     */
    @Parameter(property = ""npmDownloadRoot"", required = false, defaultValue = NPMInstaller.DEFAULT_NPM_DOWNLOAD_ROOT)
    private String npmDownloadRoot;

    /**
     * Where to download Node.js and NPM binaries from.
     *
     * @deprecated use {@link #nodeDownloadRoot} and {@link #npmDownloadRoot} instead, this configuration will be used only when no {@link #nodeDownloadRoot} or {@link #npmDownloadRoot} is specified.
     */
    @Parameter(property = ""downloadRoot"", required = false, defaultValue = """")
    @Deprecated
    private String downloadRoot;

    /**
     * The version of Node.js to install. IMPORTANT! Most Node.js version names start with 'v', for example 'v0.10.18'
     */
    @Parameter(property=""nodeVersion"", required = true)
    private String nodeVersion;

    /**
     * The version of NPM to install.
     */
    @Parameter(property = ""npmVersion"", required = false, defaultValue = ""provided"")
    private String npmVersion;

    /**
     * Server Id for download username and password
     */
    @Parameter(property = ""serverId"", defaultValue = """")
    private String serverId;

    @Parameter(property = ""session"", defaultValue = ""${session}"", readonly = true)
    private MavenSession session;

    /**
     * Skips execution of this mojo.
     */
    @Parameter(property = ""skip.installnodenpm"", defaultValue = ""${skip.installnodenpm}"")
    private boolean skip;

    @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter;

    @Override
    protected boolean skipExecution() {
        return this.skip;
    }

    @Override
    public void execute(FrontendPluginFactory factory) throws InstallationException {
        ProxyConfig proxyConfig = MojoUtils.getProxyConfig(session, decrypter);
        String nodeDownloadRoot = getNodeDownloadRoot();
        String npmDownloadRoot = getNpmDownloadRoot();
        Server server = MojoUtils.decryptServer(serverId, session, decrypter);
        if (null != server) {
            Map<String, String> httpHeaders = getHttpHeaders(server);
            factory.getNodeInstaller(proxyConfig)
                .setNodeVersion(nodeVersion)
                .setNodeDownloadRoot(nodeDownloadRoot)
                .setNpmVersion(npmVersion)
                .setUserName(server.getUsername())
                .setPassword(server.getPassword())
                .setHttpHeaders(httpHeaders)
                .install();
            factory.getNPMInstaller(proxyConfig)
                .setNodeVersion(nodeVersion)
                .setNpmVersion(npmVersion)
                .setNpmDownloadRoot(npmDownloadRoot)
                .setUserName(server.getUsername())
                .setPassword(server.getPassword())
                .setHttpHeaders(httpHeaders)
                .install();
        } else {
            factory.getNodeInstaller(proxyConfig)
                .setNodeVersion(nodeVersion)
                .setNodeDownloadRoot(nodeDownloadRoot)
                .setNpmVersion(npmVersion)
                .install();
            factory.getNPMInstaller(proxyConfig)
                .setNodeVersion(this.nodeVersion)
                .setNpmVersion(this.npmVersion)
                .setNpmDownloadRoot(npmDownloadRoot)
                .install();
        }
    }

    private String getNodeDownloadRoot() {
        if (downloadRoot != null && !"""".equals(downloadRoot) && nodeDownloadRoot == null) {
            return downloadRoot;
        }
        return nodeDownloadRoot;
    }

    private String getNpmDownloadRoot() {
        if (downloadRoot != null && !"""".equals(downloadRoot) && NPMInstaller.DEFAULT_NPM_DOWNLOAD_ROOT.equals(npmDownloadRoot)) {
            return downloadRoot;
        }
        return npmDownloadRoot;
    }
}
","package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""install-node-and-npm"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class InstallNodeAndNpmMojo extends AbstractFrontendMojo { @Parameter(property = ""nodeDownloadRoot"", required = false)
    private String nodeDownloadRoot; @Parameter(property = ""npmDownloadRoot"", required = false, defaultValue = NPMInstaller.DEFAULT_NPM_DOWNLOAD_ROOT)
    private String npmDownloadRoot; @Parameter(property = ""downloadRoot"", required = false, defaultValue = """")
    @Deprecated
    private String downloadRoot; @Parameter(property=""nodeVersion"", required = true)
    private String nodeVersion; @Parameter(property = ""npmVersion"", required = false, defaultValue = ""provided"")
    private String npmVersion; @Parameter(property = ""serverId"", defaultValue = """")
    private String serverId; @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session; @Parameter(property = ""skip.installnodenpm"", defaultValue = ""${ skip.installnodenpm} "")
    private boolean skip; @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public void execute(FrontendPluginFactory factory) throws InstallationException { ProxyConfig proxyConfig = MojoUtils.getProxyConfig(session, decrypter); String nodeDownloadRoot = getNodeDownloadRoot(); String npmDownloadRoot = getNpmDownloadRoot(); Server server = MojoUtils.decryptServer(serverId, session, decrypter); if (null != server) { Map<String, String> httpHeaders = getHttpHeaders(server); factory.getNodeInstaller(proxyConfig)
                .setNodeVersion(nodeVersion)
                .setNodeDownloadRoot(nodeDownloadRoot)
                .setNpmVersion(npmVersion)
                .setUserName(server.getUsername())
                .setPassword(server.getPassword())
                .setHttpHeaders(httpHeaders)
                .install(); factory.getNPMInstaller(proxyConfig)
                .setNodeVersion(nodeVersion)
                .setNpmVersion(npmVersion)
                .setNpmDownloadRoot(npmDownloadRoot)
                .setUserName(server.getUsername())
                .setPassword(server.getPassword())
                .setHttpHeaders(httpHeaders)
                .install(); } else { factory.getNodeInstaller(proxyConfig)
                .setNodeVersion(nodeVersion)
                .setNodeDownloadRoot(nodeDownloadRoot)
                .setNpmVersion(npmVersion)
                .install(); factory.getNPMInstaller(proxyConfig)
                .setNodeVersion(this.nodeVersion)
                .setNpmVersion(this.npmVersion)
                .setNpmDownloadRoot(npmDownloadRoot)
                .install(); } } private String getNodeDownloadRoot() { if (downloadRoot != null && !"""".equals(downloadRoot) && nodeDownloadRoot == null) { return downloadRoot; } return nodeDownloadRoot; } private String getNpmDownloadRoot() { if (downloadRoot != null && !"""".equals(downloadRoot) && NPMInstaller.DEFAULT_NPM_DOWNLOAD_ROOT.equals(npmDownloadRoot)) { return downloadRoot; } return npmDownloadRoot; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""install-node-and-npm"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class InstallNodeAndNpmMojo extends AbstractFrontendMojo { @Parameter(property = ""nodeDownloadRoot"", required = false)
    private String nodeDownloadRoot; @Parameter(property = ""npmDownloadRoot"", required = false, defaultValue = NPMInstaller.DEFAULT_NPM_DOWNLOAD_ROOT)
    private String npmDownloadRoot; @Parameter(property = ""downloadRoot"", required = false, defaultValue = """")
    @Deprecated
    private String downloadRoot; @Parameter(property=""nodeVersion"", required = true)
    private String nodeVersion; @Parameter(property = ""npmVersion"", required = false, defaultValue = ""provided"")
    private String npmVersion; @Parameter(property = ""serverId"", defaultValue = """")
    private String serverId; @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session; @Parameter(property = ""skip.installnodenpm"", defaultValue = ""${ skip.installnodenpm} "")
    private boolean skip; @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public void execute(FrontendPluginFactory factory) throws InstallationException { ProxyConfig proxyConfig = MojoUtils.getProxyConfig(session, decrypter); String nodeDownloadRoot = getNodeDownloadRoot(); String npmDownloadRoot = getNpmDownloadRoot(); Server server = MojoUtils.decryptServer(serverId, session, decrypter); if (null != server) { Map<String, String> httpHeaders = getHttpHeaders(server); factory.getNodeInstaller(proxyConfig)
                .setNodeVersion(nodeVersion)
                .setNodeDownloadRoot(nodeDownloadRoot)
                .setNpmVersion(npmVersion)
                .setUserName(server.getUsername())
                .setPassword(server.getPassword())
                .setHttpHeaders(httpHeaders)
                .install(); factory.getNPMInstaller(proxyConfig)
                .setNodeVersion(nodeVersion)
                .setNpmVersion(npmVersion)
                .setNpmDownloadRoot(npmDownloadRoot)
                .setUserName(server.getUsername())
                .setPassword(server.getPassword())
                .setHttpHeaders(httpHeaders)
                .install(); } else { factory.getNodeInstaller(proxyConfig)
                .setNodeVersion(nodeVersion)
                .setNodeDownloadRoot(nodeDownloadRoot)
                .setNpmVersion(npmVersion)
                .install(); factory.getNPMInstaller(proxyConfig)
                .setNodeVersion(this.nodeVersion)
                .setNpmVersion(this.npmVersion)
                .setNpmDownloadRoot(npmDownloadRoot)
                .install(); } } private String getNodeDownloadRoot() { if (downloadRoot != null && !"""".equals(downloadRoot) && nodeDownloadRoot == null) { return downloadRoot; } return nodeDownloadRoot; } private String getNpmDownloadRoot() { if (downloadRoot != null && !"""".equals(downloadRoot) && NPMInstaller.DEFAULT_NPM_DOWNLOAD_ROOT.equals(npmDownloadRoot)) { return downloadRoot; } return npmDownloadRoot; } } ","package com.github.eirslett.maven.plugins.frontend.mojo; 
import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory; import com.github.eirslett.maven.plugins.frontend.lib.InstallationException; import com.github.eirslett.maven.plugins.frontend.lib.NPMInstaller; import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig; 
import java.util.Map; 
import org.apache.maven.execution.MavenSession; import org.apache.maven.plugins.annotations.Component; import org.apache.maven.plugins.annotations.LifecyclePhase; import org.apache.maven.plugins.annotations.Mojo; import org.apache.maven.plugins.annotations.Parameter; import org.apache.maven.settings.crypto.SettingsDecrypter; import org.apache.maven.settings.Server;  @Mojo(name=""install-node-and-npm"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class InstallNodeAndNpmMojo extends AbstractFrontendMojo {  /**
     * Where to download Node.js binary from. Defaults to https://nodejs.org/dist/
     */ @Parameter(property = ""nodeDownloadRoot"", required = false)
    private String nodeDownloadRoot;  /**
     * Where to download NPM binary from. Defaults to https://registry.npmjs.org/npm/-/
     */ @Parameter(property = ""npmDownloadRoot"", required = false, defaultValue = NPMInstaller.DEFAULT_NPM_DOWNLOAD_ROOT)
    private String npmDownloadRoot;  /**
     * Where to download Node.js and NPM binaries from.
     *
     * @deprecated use {@link #nodeDownloadRoot} and {@link #npmDownloadRoot} instead, this configuration will be used only when no {@link #nodeDownloadRoot} or {@link #npmDownloadRoot} is specified.
     */ @Parameter(property = ""downloadRoot"", required = false, defaultValue = """")
    @Deprecated
    private String downloadRoot;  /**
     * The version of Node.js to install. IMPORTANT! Most Node.js version names start with 'v', for example 'v0.10.18'
     */ @Parameter(property=""nodeVersion"", required = true)
    private String nodeVersion;  /**
     * The version of NPM to install.
     */ @Parameter(property = ""npmVersion"", required = false, defaultValue = ""provided"")
    private String npmVersion;  /**
     * Server Id for download username and password
     */ @Parameter(property = ""serverId"", defaultValue = """")
    private String serverId;  @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session;  /**
     * Skips execution of this mojo.
     */ @Parameter(property = ""skip.installnodenpm"", defaultValue = ""${ skip.installnodenpm} "")
    private boolean skip;  @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter;  @Override
    protected boolean skipExecution() { return this.skip; }  @Override
    public void execute(FrontendPluginFactory factory) throws InstallationException { ProxyConfig proxyConfig = MojoUtils.getProxyConfig(session, decrypter); String nodeDownloadRoot = getNodeDownloadRoot(); String npmDownloadRoot = getNpmDownloadRoot(); Server server = MojoUtils.decryptServer(serverId, session, decrypter); if (null != server) { Map<String, String> httpHeaders = getHttpHeaders(server); factory.getNodeInstaller(proxyConfig)
                .setNodeVersion(nodeVersion)
                .setNodeDownloadRoot(nodeDownloadRoot)
                .setNpmVersion(npmVersion)
                .setUserName(server.getUsername())
                .setPassword(server.getPassword())
                .setHttpHeaders(httpHeaders)
                .install(); factory.getNPMInstaller(proxyConfig)
                .setNodeVersion(nodeVersion)
                .setNpmVersion(npmVersion)
                .setNpmDownloadRoot(npmDownloadRoot)
                .setUserName(server.getUsername())
                .setPassword(server.getPassword())
                .setHttpHeaders(httpHeaders)
                .install(); } else { factory.getNodeInstaller(proxyConfig)
                .setNodeVersion(nodeVersion)
                .setNodeDownloadRoot(nodeDownloadRoot)
                .setNpmVersion(npmVersion)
                .install(); factory.getNPMInstaller(proxyConfig)
                .setNodeVersion(this.nodeVersion)
                .setNpmVersion(this.npmVersion)
                .setNpmDownloadRoot(npmDownloadRoot)
                .install(); } }  private String getNodeDownloadRoot() { if (downloadRoot != null && !"""".equals(downloadRoot) && nodeDownloadRoot == null) { return downloadRoot; } return nodeDownloadRoot; }  private String getNpmDownloadRoot() { if (downloadRoot != null && !"""".equals(downloadRoot) && NPMInstaller.DEFAULT_NPM_DOWNLOAD_ROOT.equals(npmDownloadRoot)) { return downloadRoot; } return npmDownloadRoot; } }  "
frontend-maven-plugin/src/main/java/com/github/eirslett/maven/plugins/frontend/mojo/InstallNodeAndPnpmMojo.java,"package com.github.eirslett.maven.plugins.frontend.mojo;

import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory;
import com.github.eirslett.maven.plugins.frontend.lib.InstallationException;
import com.github.eirslett.maven.plugins.frontend.lib.PnpmInstaller;
import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig;

import java.util.Map;

import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.settings.crypto.SettingsDecrypter;
import org.apache.maven.settings.Server;

@Mojo(name=""install-node-and-pnpm"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class InstallNodeAndPnpmMojo extends AbstractFrontendMojo {

    /**
     * Where to download Node.js binary from. Defaults to https://nodejs.org/dist/
     */
    @Parameter(property = ""nodeDownloadRoot"", required = false)
    private String nodeDownloadRoot;

    /**
     * Where to download pnpm binary from. Defaults to https://registry.npmjs.org/pnpm/-/
     */
    @Parameter(property = ""pnpmDownloadRoot"", required = false, defaultValue = PnpmInstaller.DEFAULT_PNPM_DOWNLOAD_ROOT)
    private String pnpmDownloadRoot;

    /**
     * Where to download Node.js and pnpm binaries from.
     *
     * @deprecated use {@link #nodeDownloadRoot} and {@link #pnpmDownloadRoot} instead, this configuration will be used only when no {@link #nodeDownloadRoot} or {@link #pnpmDownloadRoot} is specified.
     */
    @Parameter(property = ""downloadRoot"", required = false, defaultValue = """")
    @Deprecated
    private String downloadRoot;

    /**
     * The version of Node.js to install. IMPORTANT! Most Node.js version names start with 'v', for example 'v0.10.18'
     */
    @Parameter(property=""nodeVersion"", required = true)
    private String nodeVersion;

    /**
     * The version of pnpm to install. Note that the version string can optionally be prefixed with
     * 'v' (i.e., both 'v1.2.3' and '1.2.3' are valid).
     */
    @Parameter(property = ""pnpmVersion"", required = true)
    private String pnpmVersion;

    /**
     * Server Id for download username and password
     */
    @Parameter(property = ""serverId"", defaultValue = """")
    private String serverId;

    @Parameter(property = ""session"", defaultValue = ""${session}"", readonly = true)
    private MavenSession session;

    /**
     * Skips execution of this mojo.
     */
    @Parameter(property = ""skip.installnodepnpm"", defaultValue = ""${skip.installnodepnpm}"")
    private boolean skip;

    @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter;

    @Override
    protected boolean skipExecution() {
        return this.skip;
    }

    @Override
    public void execute(FrontendPluginFactory factory) throws InstallationException {
        ProxyConfig proxyConfig = MojoUtils.getProxyConfig(session, decrypter);
        // Use different names to avoid confusion with fields `nodeDownloadRoot` and
        // `pnpmDownloadRoot`.
        //
        // TODO: Remove the `downloadRoot` config (with breaking change) to simplify download root
        // resolution.
        String resolvedNodeDownloadRoot = getNodeDownloadRoot();
        String resolvedPnpmDownloadRoot = getPnpmDownloadRoot();
        Server server = MojoUtils.decryptServer(serverId, session, decrypter);
        if (null != server) {
            Map<String, String> httpHeaders = getHttpHeaders(server);
            factory.getNodeInstaller(proxyConfig)
                .setNodeVersion(nodeVersion)
                .setNodeDownloadRoot(resolvedNodeDownloadRoot)
                .setUserName(server.getUsername())
                .setPassword(server.getPassword())
                .setHttpHeaders(httpHeaders)
                .install();
            factory.getPnpmInstaller(proxyConfig)
                .setPnpmVersion(pnpmVersion)
                .setPnpmDownloadRoot(resolvedPnpmDownloadRoot)
                .setUserName(server.getUsername())
                .setPassword(server.getPassword())
                .setHttpHeaders(httpHeaders)
                .install();
        } else {
            factory.getNodeInstaller(proxyConfig)
                .setNodeVersion(nodeVersion)
                .setNodeDownloadRoot(resolvedNodeDownloadRoot)
                .install();
            factory.getPnpmInstaller(proxyConfig)
                .setPnpmVersion(this.pnpmVersion)
                .setPnpmDownloadRoot(resolvedPnpmDownloadRoot)
                .install();
        }
    }

    private String getNodeDownloadRoot() {
        if (downloadRoot != null && !"""".equals(downloadRoot) && nodeDownloadRoot == null) {
            return downloadRoot;
        }
        return nodeDownloadRoot;
    }

    private String getPnpmDownloadRoot() {
        if (downloadRoot != null && !"""".equals(downloadRoot) && PnpmInstaller.DEFAULT_PNPM_DOWNLOAD_ROOT.equals(pnpmDownloadRoot)) {
            return downloadRoot;
        }
        return pnpmDownloadRoot;
    }
}
","package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""install-node-and-pnpm"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class InstallNodeAndPnpmMojo extends AbstractFrontendMojo { @Parameter(property = ""nodeDownloadRoot"", required = false)
    private String nodeDownloadRoot; @Parameter(property = ""pnpmDownloadRoot"", required = false, defaultValue = PnpmInstaller.DEFAULT_PNPM_DOWNLOAD_ROOT)
    private String pnpmDownloadRoot; @Parameter(property = ""downloadRoot"", required = false, defaultValue = """")
    @Deprecated
    private String downloadRoot; @Parameter(property=""nodeVersion"", required = true)
    private String nodeVersion; @Parameter(property = ""pnpmVersion"", required = true)
    private String pnpmVersion; @Parameter(property = ""serverId"", defaultValue = """")
    private String serverId; @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session; @Parameter(property = ""skip.installnodepnpm"", defaultValue = ""${ skip.installnodepnpm} "")
    private boolean skip; @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public void execute(FrontendPluginFactory factory) throws InstallationException { ProxyConfig proxyConfig = MojoUtils.getProxyConfig(session, decrypter); String resolvedNodeDownloadRoot = getNodeDownloadRoot(); String resolvedPnpmDownloadRoot = getPnpmDownloadRoot(); Server server = MojoUtils.decryptServer(serverId, session, decrypter); if (null != server) { Map<String, String> httpHeaders = getHttpHeaders(server); factory.getNodeInstaller(proxyConfig)
                .setNodeVersion(nodeVersion)
                .setNodeDownloadRoot(resolvedNodeDownloadRoot)
                .setUserName(server.getUsername())
                .setPassword(server.getPassword())
                .setHttpHeaders(httpHeaders)
                .install(); factory.getPnpmInstaller(proxyConfig)
                .setPnpmVersion(pnpmVersion)
                .setPnpmDownloadRoot(resolvedPnpmDownloadRoot)
                .setUserName(server.getUsername())
                .setPassword(server.getPassword())
                .setHttpHeaders(httpHeaders)
                .install(); } else { factory.getNodeInstaller(proxyConfig)
                .setNodeVersion(nodeVersion)
                .setNodeDownloadRoot(resolvedNodeDownloadRoot)
                .install(); factory.getPnpmInstaller(proxyConfig)
                .setPnpmVersion(this.pnpmVersion)
                .setPnpmDownloadRoot(resolvedPnpmDownloadRoot)
                .install(); } } private String getNodeDownloadRoot() { if (downloadRoot != null && !"""".equals(downloadRoot) && nodeDownloadRoot == null) { return downloadRoot; } return nodeDownloadRoot; } private String getPnpmDownloadRoot() { if (downloadRoot != null && !"""".equals(downloadRoot) && PnpmInstaller.DEFAULT_PNPM_DOWNLOAD_ROOT.equals(pnpmDownloadRoot)) { return downloadRoot; } return pnpmDownloadRoot; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""install-node-and-pnpm"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class InstallNodeAndPnpmMojo extends AbstractFrontendMojo { @Parameter(property = ""nodeDownloadRoot"", required = false)
    private String nodeDownloadRoot; @Parameter(property = ""pnpmDownloadRoot"", required = false, defaultValue = PnpmInstaller.DEFAULT_PNPM_DOWNLOAD_ROOT)
    private String pnpmDownloadRoot; @Parameter(property = ""downloadRoot"", required = false, defaultValue = """")
    @Deprecated
    private String downloadRoot; @Parameter(property=""nodeVersion"", required = true)
    private String nodeVersion; @Parameter(property = ""pnpmVersion"", required = true)
    private String pnpmVersion; @Parameter(property = ""serverId"", defaultValue = """")
    private String serverId; @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session; @Parameter(property = ""skip.installnodepnpm"", defaultValue = ""${ skip.installnodepnpm} "")
    private boolean skip; @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public void execute(FrontendPluginFactory factory) throws InstallationException { ProxyConfig proxyConfig = MojoUtils.getProxyConfig(session, decrypter); String resolvedNodeDownloadRoot = getNodeDownloadRoot(); String resolvedPnpmDownloadRoot = getPnpmDownloadRoot(); Server server = MojoUtils.decryptServer(serverId, session, decrypter); if (null != server) { Map<String, String> httpHeaders = getHttpHeaders(server); factory.getNodeInstaller(proxyConfig)
                .setNodeVersion(nodeVersion)
                .setNodeDownloadRoot(resolvedNodeDownloadRoot)
                .setUserName(server.getUsername())
                .setPassword(server.getPassword())
                .setHttpHeaders(httpHeaders)
                .install(); factory.getPnpmInstaller(proxyConfig)
                .setPnpmVersion(pnpmVersion)
                .setPnpmDownloadRoot(resolvedPnpmDownloadRoot)
                .setUserName(server.getUsername())
                .setPassword(server.getPassword())
                .setHttpHeaders(httpHeaders)
                .install(); } else { factory.getNodeInstaller(proxyConfig)
                .setNodeVersion(nodeVersion)
                .setNodeDownloadRoot(resolvedNodeDownloadRoot)
                .install(); factory.getPnpmInstaller(proxyConfig)
                .setPnpmVersion(this.pnpmVersion)
                .setPnpmDownloadRoot(resolvedPnpmDownloadRoot)
                .install(); } } private String getNodeDownloadRoot() { if (downloadRoot != null && !"""".equals(downloadRoot) && nodeDownloadRoot == null) { return downloadRoot; } return nodeDownloadRoot; } private String getPnpmDownloadRoot() { if (downloadRoot != null && !"""".equals(downloadRoot) && PnpmInstaller.DEFAULT_PNPM_DOWNLOAD_ROOT.equals(pnpmDownloadRoot)) { return downloadRoot; } return pnpmDownloadRoot; } } ","package com.github.eirslett.maven.plugins.frontend.mojo; 
import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory; import com.github.eirslett.maven.plugins.frontend.lib.InstallationException; import com.github.eirslett.maven.plugins.frontend.lib.PnpmInstaller; import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig; 
import java.util.Map; 
import org.apache.maven.execution.MavenSession; import org.apache.maven.plugins.annotations.Component; import org.apache.maven.plugins.annotations.LifecyclePhase; import org.apache.maven.plugins.annotations.Mojo; import org.apache.maven.plugins.annotations.Parameter; import org.apache.maven.settings.crypto.SettingsDecrypter; import org.apache.maven.settings.Server;  @Mojo(name=""install-node-and-pnpm"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class InstallNodeAndPnpmMojo extends AbstractFrontendMojo {  /**
     * Where to download Node.js binary from. Defaults to https://nodejs.org/dist/
     */ @Parameter(property = ""nodeDownloadRoot"", required = false)
    private String nodeDownloadRoot;  /**
     * Where to download pnpm binary from. Defaults to https://registry.npmjs.org/pnpm/-/
     */ @Parameter(property = ""pnpmDownloadRoot"", required = false, defaultValue = PnpmInstaller.DEFAULT_PNPM_DOWNLOAD_ROOT)
    private String pnpmDownloadRoot;  /**
     * Where to download Node.js and pnpm binaries from.
     *
     * @deprecated use {@link #nodeDownloadRoot} and {@link #pnpmDownloadRoot} instead, this configuration will be used only when no {@link #nodeDownloadRoot} or {@link #pnpmDownloadRoot} is specified.
     */ @Parameter(property = ""downloadRoot"", required = false, defaultValue = """")
    @Deprecated
    private String downloadRoot;  /**
     * The version of Node.js to install. IMPORTANT! Most Node.js version names start with 'v', for example 'v0.10.18'
     */ @Parameter(property=""nodeVersion"", required = true)
    private String nodeVersion;  /**
     * The version of pnpm to install. Note that the version string can optionally be prefixed with
     * 'v' (i.e., both 'v1.2.3' and '1.2.3' are valid).
     */ @Parameter(property = ""pnpmVersion"", required = true)
    private String pnpmVersion;  /**
     * Server Id for download username and password
     */ @Parameter(property = ""serverId"", defaultValue = """")
    private String serverId;  @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session;  /**
     * Skips execution of this mojo.
     */ @Parameter(property = ""skip.installnodepnpm"", defaultValue = ""${ skip.installnodepnpm} "")
    private boolean skip;  @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter;  @Override
    protected boolean skipExecution() { return this.skip; }  @Override
    public void execute(FrontendPluginFactory factory) throws InstallationException { ProxyConfig proxyConfig = MojoUtils.getProxyConfig(session, decrypter); // Use different names to avoid confusion with fields `nodeDownloadRoot` and // `pnpmDownloadRoot`. // // TODO: Remove the `downloadRoot` config (with breaking change) to simplify download root // resolution. String resolvedNodeDownloadRoot = getNodeDownloadRoot(); String resolvedPnpmDownloadRoot = getPnpmDownloadRoot(); Server server = MojoUtils.decryptServer(serverId, session, decrypter); if (null != server) { Map<String, String> httpHeaders = getHttpHeaders(server); factory.getNodeInstaller(proxyConfig)
                .setNodeVersion(nodeVersion)
                .setNodeDownloadRoot(resolvedNodeDownloadRoot)
                .setUserName(server.getUsername())
                .setPassword(server.getPassword())
                .setHttpHeaders(httpHeaders)
                .install(); factory.getPnpmInstaller(proxyConfig)
                .setPnpmVersion(pnpmVersion)
                .setPnpmDownloadRoot(resolvedPnpmDownloadRoot)
                .setUserName(server.getUsername())
                .setPassword(server.getPassword())
                .setHttpHeaders(httpHeaders)
                .install(); } else { factory.getNodeInstaller(proxyConfig)
                .setNodeVersion(nodeVersion)
                .setNodeDownloadRoot(resolvedNodeDownloadRoot)
                .install(); factory.getPnpmInstaller(proxyConfig)
                .setPnpmVersion(this.pnpmVersion)
                .setPnpmDownloadRoot(resolvedPnpmDownloadRoot)
                .install(); } }  private String getNodeDownloadRoot() { if (downloadRoot != null && !"""".equals(downloadRoot) && nodeDownloadRoot == null) { return downloadRoot; } return nodeDownloadRoot; }  private String getPnpmDownloadRoot() { if (downloadRoot != null && !"""".equals(downloadRoot) && PnpmInstaller.DEFAULT_PNPM_DOWNLOAD_ROOT.equals(pnpmDownloadRoot)) { return downloadRoot; } return pnpmDownloadRoot; } }  "
frontend-maven-plugin/src/main/java/com/github/eirslett/maven/plugins/frontend/mojo/InstallNodeAndYarnMojo.java,"package com.github.eirslett.maven.plugins.frontend.mojo;

import static com.github.eirslett.maven.plugins.frontend.mojo.YarnUtils.isYarnrcYamlFilePresent;

import java.util.Map;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.settings.Server;
import org.apache.maven.settings.crypto.SettingsDecrypter;

import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory;
import com.github.eirslett.maven.plugins.frontend.lib.InstallationException;
import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig;
import com.github.eirslett.maven.plugins.frontend.lib.YarnInstaller;

@Mojo(name = ""install-node-and-yarn"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class InstallNodeAndYarnMojo extends AbstractFrontendMojo {

    private static final String YARNRC_YAML_FILE_NAME = "".yarnrc.yml"";

    /**
     * Where to download Node.js binary from. Defaults to https://nodejs.org/dist/
     */
    @Parameter(property = ""nodeDownloadRoot"", required = false)
    private String nodeDownloadRoot;

    /**
     * Where to download Yarn binary from. Defaults to https://github.com/yarnpkg/yarn/releases/download/...
     */
    @Parameter(property = ""yarnDownloadRoot"", required = false,
        defaultValue = YarnInstaller.DEFAULT_YARN_DOWNLOAD_ROOT)
    private String yarnDownloadRoot;

    /**
     * The version of Node.js to install. IMPORTANT! Most Node.js version names start with 'v', for example
     * 'v0.10.18'
     */
    @Parameter(property = ""nodeVersion"", required = true)
    private String nodeVersion;

    /**
     * The version of Yarn to install. IMPORTANT! Most Yarn names start with 'v', for example 'v0.15.0'.
     */
    @Parameter(property = ""yarnVersion"", required = true)
    private String yarnVersion;

    /**
     * Server Id for download username and password
     */
    @Parameter(property = ""serverId"", defaultValue = """")
    private String serverId;

    @Parameter(property = ""session"", defaultValue = ""${session}"", readonly = true)
    private MavenSession session;

    /**
     * Skips execution of this mojo.
     */
    @Parameter(property = ""skip.installyarn"", alias = ""skip.installyarn"", defaultValue = ""${skip.installyarn}"")
    private boolean skip;

    @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter;

    @Override
    protected boolean skipExecution() {
        return this.skip;
    }

    @Override
    public void execute(FrontendPluginFactory factory) throws InstallationException {
        ProxyConfig proxyConfig = MojoUtils.getProxyConfig(this.session, this.decrypter);
        Server server = MojoUtils.decryptServer(this.serverId, this.session, this.decrypter);

        boolean isYarnYamlFilePresent = isYarnrcYamlFilePresent(this.session, this.workingDirectory);

        if (null != server) {
            Map<String, String> httpHeaders = getHttpHeaders(server);
            factory.getNodeInstaller(proxyConfig).setNodeDownloadRoot(this.nodeDownloadRoot)
                .setNodeVersion(this.nodeVersion).setUserName(server.getUsername())
                .setPassword(server.getPassword()).setHttpHeaders(httpHeaders).install();
            factory.getYarnInstaller(proxyConfig).setYarnDownloadRoot(this.yarnDownloadRoot)
                .setYarnVersion(this.yarnVersion).setUserName(server.getUsername())
                .setPassword(server.getPassword()).setHttpHeaders(httpHeaders)
                .setIsYarnBerry(isYarnYamlFilePresent).install();
        } else {
            factory.getNodeInstaller(proxyConfig).setNodeDownloadRoot(this.nodeDownloadRoot)
                .setNodeVersion(this.nodeVersion).install();
            factory.getYarnInstaller(proxyConfig).setYarnDownloadRoot(this.yarnDownloadRoot)
                .setYarnVersion(this.yarnVersion).setIsYarnBerry(isYarnYamlFilePresent).install();
        }
    }

}
","package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name = ""install-node-and-yarn"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class InstallNodeAndYarnMojo extends AbstractFrontendMojo { private static final String YARNRC_YAML_FILE_NAME = "".yarnrc.yml""; @Parameter(property = ""nodeDownloadRoot"", required = false)
    private String nodeDownloadRoot; @Parameter(property = ""yarnDownloadRoot"", required = false,
        defaultValue = YarnInstaller.DEFAULT_YARN_DOWNLOAD_ROOT)
    private String yarnDownloadRoot; @Parameter(property = ""nodeVersion"", required = true)
    private String nodeVersion; @Parameter(property = ""yarnVersion"", required = true)
    private String yarnVersion; @Parameter(property = ""serverId"", defaultValue = """")
    private String serverId; @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session; @Parameter(property = ""skip.installyarn"", alias = ""skip.installyarn"", defaultValue = ""${ skip.installyarn} "")
    private boolean skip; @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public void execute(FrontendPluginFactory factory) throws InstallationException { ProxyConfig proxyConfig = MojoUtils.getProxyConfig(this.session, this.decrypter); Server server = MojoUtils.decryptServer(this.serverId, this.session, this.decrypter); boolean isYarnYamlFilePresent = isYarnrcYamlFilePresent(this.session, this.workingDirectory); if (null != server) { Map<String, String> httpHeaders = getHttpHeaders(server); factory.getNodeInstaller(proxyConfig).setNodeDownloadRoot(this.nodeDownloadRoot)
                .setNodeVersion(this.nodeVersion).setUserName(server.getUsername())
                .setPassword(server.getPassword()).setHttpHeaders(httpHeaders).install(); factory.getYarnInstaller(proxyConfig).setYarnDownloadRoot(this.yarnDownloadRoot)
                .setYarnVersion(this.yarnVersion).setUserName(server.getUsername())
                .setPassword(server.getPassword()).setHttpHeaders(httpHeaders)
                .setIsYarnBerry(isYarnYamlFilePresent).install(); } else { factory.getNodeInstaller(proxyConfig).setNodeDownloadRoot(this.nodeDownloadRoot)
                .setNodeVersion(this.nodeVersion).install(); factory.getYarnInstaller(proxyConfig).setYarnDownloadRoot(this.yarnDownloadRoot)
                .setYarnVersion(this.yarnVersion).setIsYarnBerry(isYarnYamlFilePresent).install(); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name = ""install-node-and-yarn"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class InstallNodeAndYarnMojo extends AbstractFrontendMojo { private static final String YARNRC_YAML_FILE_NAME = "".yarnrc.yml""; @Parameter(property = ""nodeDownloadRoot"", required = false)
    private String nodeDownloadRoot; @Parameter(property = ""yarnDownloadRoot"", required = false,
        defaultValue = YarnInstaller.DEFAULT_YARN_DOWNLOAD_ROOT)
    private String yarnDownloadRoot; @Parameter(property = ""nodeVersion"", required = true)
    private String nodeVersion; @Parameter(property = ""yarnVersion"", required = true)
    private String yarnVersion; @Parameter(property = ""serverId"", defaultValue = """")
    private String serverId; @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session; @Parameter(property = ""skip.installyarn"", alias = ""skip.installyarn"", defaultValue = ""${ skip.installyarn} "")
    private boolean skip; @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public void execute(FrontendPluginFactory factory) throws InstallationException { ProxyConfig proxyConfig = MojoUtils.getProxyConfig(this.session, this.decrypter); Server server = MojoUtils.decryptServer(this.serverId, this.session, this.decrypter); boolean isYarnYamlFilePresent = isYarnrcYamlFilePresent(this.session, this.workingDirectory); if (null != server) { Map<String, String> httpHeaders = getHttpHeaders(server); factory.getNodeInstaller(proxyConfig).setNodeDownloadRoot(this.nodeDownloadRoot)
                .setNodeVersion(this.nodeVersion).setUserName(server.getUsername())
                .setPassword(server.getPassword()).setHttpHeaders(httpHeaders).install(); factory.getYarnInstaller(proxyConfig).setYarnDownloadRoot(this.yarnDownloadRoot)
                .setYarnVersion(this.yarnVersion).setUserName(server.getUsername())
                .setPassword(server.getPassword()).setHttpHeaders(httpHeaders)
                .setIsYarnBerry(isYarnYamlFilePresent).install(); } else { factory.getNodeInstaller(proxyConfig).setNodeDownloadRoot(this.nodeDownloadRoot)
                .setNodeVersion(this.nodeVersion).install(); factory.getYarnInstaller(proxyConfig).setYarnDownloadRoot(this.yarnDownloadRoot)
                .setYarnVersion(this.yarnVersion).setIsYarnBerry(isYarnYamlFilePresent).install(); } } } ","package com.github.eirslett.maven.plugins.frontend.mojo; 
import static com.github.eirslett.maven.plugins.frontend.mojo.YarnUtils.isYarnrcYamlFilePresent; 
import java.util.Map; import org.apache.maven.execution.MavenSession; import org.apache.maven.plugins.annotations.Component; import org.apache.maven.plugins.annotations.LifecyclePhase; import org.apache.maven.plugins.annotations.Mojo; import org.apache.maven.plugins.annotations.Parameter; import org.apache.maven.settings.Server; import org.apache.maven.settings.crypto.SettingsDecrypter; 
import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory; import com.github.eirslett.maven.plugins.frontend.lib.InstallationException; import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig; import com.github.eirslett.maven.plugins.frontend.lib.YarnInstaller;  @Mojo(name = ""install-node-and-yarn"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class InstallNodeAndYarnMojo extends AbstractFrontendMojo {  private static final String YARNRC_YAML_FILE_NAME = "".yarnrc.yml"";  /**
     * Where to download Node.js binary from. Defaults to https://nodejs.org/dist/
     */ @Parameter(property = ""nodeDownloadRoot"", required = false)
    private String nodeDownloadRoot;  /**
     * Where to download Yarn binary from. Defaults to https://github.com/yarnpkg/yarn/releases/download/...
     */ @Parameter(property = ""yarnDownloadRoot"", required = false,
        defaultValue = YarnInstaller.DEFAULT_YARN_DOWNLOAD_ROOT)
    private String yarnDownloadRoot;  /**
     * The version of Node.js to install. IMPORTANT! Most Node.js version names start with 'v', for example
     * 'v0.10.18'
     */ @Parameter(property = ""nodeVersion"", required = true)
    private String nodeVersion;  /**
     * The version of Yarn to install. IMPORTANT! Most Yarn names start with 'v', for example 'v0.15.0'.
     */ @Parameter(property = ""yarnVersion"", required = true)
    private String yarnVersion;  /**
     * Server Id for download username and password
     */ @Parameter(property = ""serverId"", defaultValue = """")
    private String serverId;  @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session;  /**
     * Skips execution of this mojo.
     */ @Parameter(property = ""skip.installyarn"", alias = ""skip.installyarn"", defaultValue = ""${ skip.installyarn} "")
    private boolean skip;  @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter;  @Override
    protected boolean skipExecution() { return this.skip; }  @Override
    public void execute(FrontendPluginFactory factory) throws InstallationException { ProxyConfig proxyConfig = MojoUtils.getProxyConfig(this.session, this.decrypter); Server server = MojoUtils.decryptServer(this.serverId, this.session, this.decrypter);  boolean isYarnYamlFilePresent = isYarnrcYamlFilePresent(this.session, this.workingDirectory);  if (null != server) { Map<String, String> httpHeaders = getHttpHeaders(server); factory.getNodeInstaller(proxyConfig).setNodeDownloadRoot(this.nodeDownloadRoot)
                .setNodeVersion(this.nodeVersion).setUserName(server.getUsername())
                .setPassword(server.getPassword()).setHttpHeaders(httpHeaders).install(); factory.getYarnInstaller(proxyConfig).setYarnDownloadRoot(this.yarnDownloadRoot)
                .setYarnVersion(this.yarnVersion).setUserName(server.getUsername())
                .setPassword(server.getPassword()).setHttpHeaders(httpHeaders)
                .setIsYarnBerry(isYarnYamlFilePresent).install(); } else { factory.getNodeInstaller(proxyConfig).setNodeDownloadRoot(this.nodeDownloadRoot)
                .setNodeVersion(this.nodeVersion).install(); factory.getYarnInstaller(proxyConfig).setYarnDownloadRoot(this.yarnDownloadRoot)
                .setYarnVersion(this.yarnVersion).setIsYarnBerry(isYarnYamlFilePresent).install(); } }  }  "
frontend-maven-plugin/src/main/java/com/github/eirslett/maven/plugins/frontend/mojo/JspmMojo.java,"package com.github.eirslett.maven.plugins.frontend.mojo;

import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory;
import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;

import java.io.File;

@Mojo(name=""jspm"",  defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public class JspmMojo extends AbstractFrontendMojo {

    /**
     * JSPM arguments. Default is ""install"".
     */
    @Parameter(defaultValue = ""install"", property = ""frontend.bower.arguments"", required = false)
    private String arguments;

    /**
     * Skips execution of this mojo.
     */
    @Parameter(property = ""skip.jspm"", defaultValue = ""${skip.jspm}"")
    private boolean skip;

    @Override
    protected boolean skipExecution() {
        return this.skip;
    }

    @Override
    protected synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException {
        factory.getJspmRunner().execute(arguments, environmentVariables);
    }

}
","package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""jspm"",  defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public class JspmMojo extends AbstractFrontendMojo { @Parameter(defaultValue = ""install"", property = ""frontend.bower.arguments"", required = false)
    private String arguments; @Parameter(property = ""skip.jspm"", defaultValue = ""${ skip.jspm} "")
    private boolean skip; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    protected synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { factory.getJspmRunner().execute(arguments, environmentVariables); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""jspm"",  defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public class JspmMojo extends AbstractFrontendMojo { @Parameter(defaultValue = ""install"", property = ""frontend.bower.arguments"", required = false)
    private String arguments; @Parameter(property = ""skip.jspm"", defaultValue = ""${ skip.jspm} "")
    private boolean skip; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    protected synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { factory.getJspmRunner().execute(arguments, environmentVariables); } } ","package com.github.eirslett.maven.plugins.frontend.mojo; 
import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory; import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException; import org.apache.maven.plugin.AbstractMojo; import org.apache.maven.plugin.MojoExecutionException; import org.apache.maven.plugin.MojoFailureException; import org.apache.maven.plugins.annotations.LifecyclePhase; import org.apache.maven.plugins.annotations.Mojo; import org.apache.maven.plugins.annotations.Parameter; 
import java.io.File;  @Mojo(name=""jspm"",  defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public class JspmMojo extends AbstractFrontendMojo {  /**
     * JSPM arguments. Default is ""install"".
     */ @Parameter(defaultValue = ""install"", property = ""frontend.bower.arguments"", required = false)
    private String arguments;  /**
     * Skips execution of this mojo.
     */ @Parameter(property = ""skip.jspm"", defaultValue = ""${ skip.jspm} "")
    private boolean skip;  @Override
    protected boolean skipExecution() { return this.skip; }  @Override
    protected synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { factory.getJspmRunner().execute(arguments, environmentVariables); }  }  "
frontend-maven-plugin/src/main/java/com/github/eirslett/maven/plugins/frontend/mojo/KarmaRunMojo.java,"package com.github.eirslett.maven.plugins.frontend.mojo;

import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory;
import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;


@Mojo(name=""karma"",  defaultPhase = LifecyclePhase.TEST, threadSafe = true)
public final class KarmaRunMojo extends AbstractFrontendMojo {

    /**
     * Path to your karma configuration file, relative to the working directory (default is ""karma.conf.js"")
     */
    @Parameter(defaultValue = ""karma.conf.js"", property = ""karmaConfPath"")
    private String karmaConfPath;

    /**
     * Skips execution of this mojo.
     */
    @Parameter(property = ""skip.karma"", defaultValue = ""${skip.karma}"")
    private boolean skip;

    @Override
    protected boolean skipExecution() {
        return this.skip;
    }

    @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException {
        factory.getKarmaRunner().execute(""start "" + karmaConfPath, environmentVariables);
    }
}
","package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""karma"",  defaultPhase = LifecyclePhase.TEST, threadSafe = true)
public final class KarmaRunMojo extends AbstractFrontendMojo { @Parameter(defaultValue = ""karma.conf.js"", property = ""karmaConfPath"")
    private String karmaConfPath; @Parameter(property = ""skip.karma"", defaultValue = ""${ skip.karma} "")
    private boolean skip; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { factory.getKarmaRunner().execute(""start "" + karmaConfPath, environmentVariables); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""karma"",  defaultPhase = LifecyclePhase.TEST, threadSafe = true)
public final class KarmaRunMojo extends AbstractFrontendMojo { @Parameter(defaultValue = ""karma.conf.js"", property = ""karmaConfPath"")
    private String karmaConfPath; @Parameter(property = ""skip.karma"", defaultValue = ""${ skip.karma} "")
    private boolean skip; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { factory.getKarmaRunner().execute(""start "" + karmaConfPath, environmentVariables); } } ","package com.github.eirslett.maven.plugins.frontend.mojo; 
import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory; import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException; import org.apache.maven.plugins.annotations.LifecyclePhase; import org.apache.maven.plugins.annotations.Mojo; import org.apache.maven.plugins.annotations.Parameter; 
 @Mojo(name=""karma"",  defaultPhase = LifecyclePhase.TEST, threadSafe = true)
public final class KarmaRunMojo extends AbstractFrontendMojo {   @Parameter(defaultValue = ""karma.conf.js"", property = ""karmaConfPath"")
    private String karmaConfPath; /**
     * Path to your karma configuration file, relative to the working directory (default is ""karma.conf.js"")
     */  @Parameter(property = ""skip.karma"", defaultValue = ""${ skip.karma} "")
    private boolean skip; /**
     * Skips execution of this mojo.
     */ @Override
    protected boolean skipExecution() { return this.skip; }  @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { factory.getKarmaRunner().execute(""start "" + karmaConfPath, environmentVariables); } }  "
frontend-maven-plugin/src/main/java/com/github/eirslett/maven/plugins/frontend/mojo/MojoUtils.java,"package com.github.eirslett.maven.plugins.frontend.mojo;

import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.settings.Proxy;
import org.apache.maven.settings.Server;
import org.apache.maven.settings.crypto.DefaultSettingsDecryptionRequest;
import org.apache.maven.settings.crypto.SettingsDecrypter;
import org.apache.maven.settings.crypto.SettingsDecryptionResult;
import org.codehaus.plexus.util.Scanner;
import org.codehaus.plexus.util.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.sonatype.plexus.build.incremental.BuildContext;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

class MojoUtils {

    private static final Logger LOGGER = LoggerFactory.getLogger(MojoUtils.class);

    static <E extends Throwable> MojoFailureException toMojoFailureException(E e) {
        String causeMessage = e.getCause() != null ? "": "" + e.getCause().getMessage() : """";
        return new MojoFailureException(e.getMessage() + causeMessage, e);
    }

    static ProxyConfig getProxyConfig(MavenSession mavenSession, SettingsDecrypter decrypter) {
        if (mavenSession == null ||
                mavenSession.getSettings() == null ||
                mavenSession.getSettings().getProxies() == null ||
                mavenSession.getSettings().getProxies().isEmpty()) {
            return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList());
        } else {
            final List<Proxy> mavenProxies = mavenSession.getSettings().getProxies();

            final List<ProxyConfig.Proxy> proxies = new ArrayList<ProxyConfig.Proxy>(mavenProxies.size());

            for (Proxy mavenProxy : mavenProxies) {
                if (mavenProxy.isActive()) {
                    mavenProxy = decryptProxy(mavenProxy, decrypter);
                    proxies.add(new ProxyConfig.Proxy(mavenProxy.getId(), mavenProxy.getProtocol(), mavenProxy.getHost(),
                            mavenProxy.getPort(), mavenProxy.getUsername(), mavenProxy.getPassword(), mavenProxy.getNonProxyHosts()));
                }
            }

            LOGGER.info(""Found proxies: {}"", proxies);
            return new ProxyConfig(proxies);
        }
    }

    private static Proxy decryptProxy(Proxy proxy, SettingsDecrypter decrypter) {
      synchronized (proxy) {
        final DefaultSettingsDecryptionRequest decryptionRequest = new DefaultSettingsDecryptionRequest(proxy);
        SettingsDecryptionResult decryptedResult = decrypter.decrypt(decryptionRequest);
        return decryptedResult.getProxy();
      }
    }

    static Server decryptServer(String serverId, MavenSession mavenSession, SettingsDecrypter decrypter) {
        if (StringUtils.isEmpty(serverId)) {
            return null;
        }
        Server server = mavenSession.getSettings().getServer(serverId);
        if (server != null) {
          synchronized (server) {
            final DefaultSettingsDecryptionRequest decryptionRequest = new DefaultSettingsDecryptionRequest(server);
            SettingsDecryptionResult decryptedResult = decrypter.decrypt(decryptionRequest);
            return decryptedResult.getServer();
          }
        } else {
            LOGGER.warn(""Could not find server '"" + serverId + ""' in settings.xml"");
            return null;
        }
    }

    static boolean shouldExecute(BuildContext buildContext, List<File> triggerfiles, File srcdir) {

    // If there is no buildContext, or this is not an incremental build, always execute.
    if (buildContext == null || !buildContext.isIncremental()) {
      return true;
    }

    if (triggerfiles != null) {
      for (File triggerfile : triggerfiles) {
        if (buildContext.hasDelta(triggerfile)) {
          return true;
        }
      }
    }

    if (srcdir == null) {
      return true;
    }

    // Check for changes in the srcdir
    Scanner scanner = buildContext.newScanner(srcdir);
    scanner.scan();
    String[] includedFiles = scanner.getIncludedFiles();
    return (includedFiles != null && includedFiles.length > 0);
  }
}
","package com.github.eirslett.maven.plugins.frontend.mojo; class MojoUtils { private static final Logger LOGGER = LoggerFactory.getLogger(MojoUtils.class); static <E extends Throwable> MojoFailureException toMojoFailureException(E e) { String causeMessage = e.getCause() != null ? "": "" + e.getCause().getMessage() : """"; return new MojoFailureException(e.getMessage() + causeMessage, e); } static ProxyConfig getProxyConfig(MavenSession mavenSession, SettingsDecrypter decrypter) { if (mavenSession == null ||
                mavenSession.getSettings() == null ||
                mavenSession.getSettings().getProxies() == null ||
                mavenSession.getSettings().getProxies().isEmpty()) { return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList()); } else { final List<Proxy> mavenProxies = mavenSession.getSettings().getProxies(); final List<ProxyConfig.Proxy> proxies = new ArrayList<ProxyConfig.Proxy>(mavenProxies.size()); for (Proxy mavenProxy : mavenProxies) { if (mavenProxy.isActive()) { mavenProxy = decryptProxy(mavenProxy, decrypter); proxies.add(new ProxyConfig.Proxy(mavenProxy.getId(), mavenProxy.getProtocol(), mavenProxy.getHost(),
                            mavenProxy.getPort(), mavenProxy.getUsername(), mavenProxy.getPassword(), mavenProxy.getNonProxyHosts())); } } LOGGER.info(""Found proxies: { } "", proxies); return new ProxyConfig(proxies); } } private static Proxy decryptProxy(Proxy proxy, SettingsDecrypter decrypter) { synchronized (proxy) { final DefaultSettingsDecryptionRequest decryptionRequest = new DefaultSettingsDecryptionRequest(proxy); SettingsDecryptionResult decryptedResult = decrypter.decrypt(decryptionRequest); return decryptedResult.getProxy(); } } static Server decryptServer(String serverId, MavenSession mavenSession, SettingsDecrypter decrypter) { if (StringUtils.isEmpty(serverId)) { return null; } Server server = mavenSession.getSettings().getServer(serverId); if (server != null) { synchronized (server) { final DefaultSettingsDecryptionRequest decryptionRequest = new DefaultSettingsDecryptionRequest(server); SettingsDecryptionResult decryptedResult = decrypter.decrypt(decryptionRequest); return decryptedResult.getServer(); } } else { return null; } } static boolean shouldExecute(BuildContext buildContext, List<File> triggerfiles, File srcdir) { if (buildContext == null || !buildContext.isIncremental()) { return true; } if (triggerfiles != null) { for (File triggerfile : triggerfiles) { if (buildContext.hasDelta(triggerfile)) { return true; } } } if (srcdir == null) { return true; } Scanner scanner = buildContext.newScanner(srcdir); scanner.scan(); String[] includedFiles = scanner.getIncludedFiles(); return (includedFiles != null && includedFiles.length > 0); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.mojo; class MojoUtils { private static final Logger LOGGER = LoggerFactory.getLogger(MojoUtils.class); static <E extends Throwable> MojoFailureException toMojoFailureException(E e) { String causeMessage = e.getCause() != null ? "": "" + e.getCause().getMessage() : """"; return new MojoFailureException(e.getMessage() + causeMessage, e); } static ProxyConfig getProxyConfig(MavenSession mavenSession, SettingsDecrypter decrypter) { if (mavenSession == null ||
                mavenSession.getSettings() == null ||
                mavenSession.getSettings().getProxies() == null ||
                mavenSession.getSettings().getProxies().isEmpty()) { return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList()); } else { <FILL_ME> final List<Proxy> mavenProxies = mavenSession.getSettings().getProxies(); final List<ProxyConfig.Proxy> proxies = new ArrayList<ProxyConfig.Proxy>(mavenProxies.size()); for (Proxy mavenProxy : mavenProxies) { if (mavenProxy.isActive()) { mavenProxy = decryptProxy(mavenProxy, decrypter); proxies.add(new ProxyConfig.Proxy(mavenProxy.getId(), mavenProxy.getProtocol(), mavenProxy.getHost(),
                            mavenProxy.getPort(), mavenProxy.getUsername(), mavenProxy.getPassword(), mavenProxy.getNonProxyHosts())); } } LOGGER.info(""Found proxies: { } "", proxies); return new ProxyConfig(proxies); } } private static Proxy decryptProxy(Proxy proxy, SettingsDecrypter decrypter) { synchronized (proxy) { final DefaultSettingsDecryptionRequest decryptionRequest = new DefaultSettingsDecryptionRequest(proxy); SettingsDecryptionResult decryptedResult = decrypter.decrypt(decryptionRequest); return decryptedResult.getProxy(); } } static Server decryptServer(String serverId, MavenSession mavenSession, SettingsDecrypter decrypter) { if (StringUtils.isEmpty(serverId)) { return null; } Server server = mavenSession.getSettings().getServer(serverId); if (server != null) { synchronized (server) { final DefaultSettingsDecryptionRequest decryptionRequest = new DefaultSettingsDecryptionRequest(server); SettingsDecryptionResult decryptedResult = decrypter.decrypt(decryptionRequest); return decryptedResult.getServer(); } } else { return null; } } static boolean shouldExecute(BuildContext buildContext, List<File> triggerfiles, File srcdir) { if (buildContext == null || !buildContext.isIncremental()) { return true; } if (triggerfiles != null) { for (File triggerfile : triggerfiles) { if (buildContext.hasDelta(triggerfile)) { return true; } } } if (srcdir == null) { return true; } Scanner scanner = buildContext.newScanner(srcdir); scanner.scan(); String[] includedFiles = scanner.getIncludedFiles(); return (includedFiles != null && includedFiles.length > 0); } } ","package com.github.eirslett.maven.plugins.frontend.mojo; 
import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig; import org.apache.maven.execution.MavenSession; import org.apache.maven.plugin.MojoFailureException; import org.apache.maven.settings.Proxy; import org.apache.maven.settings.Server; import org.apache.maven.settings.crypto.DefaultSettingsDecryptionRequest; import org.apache.maven.settings.crypto.SettingsDecrypter; import org.apache.maven.settings.crypto.SettingsDecryptionResult; import org.codehaus.plexus.util.Scanner; import org.codehaus.plexus.util.StringUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.sonatype.plexus.build.incremental.BuildContext; 
import java.io.File; import java.util.ArrayList; import java.util.Collections; import java.util.List;  class MojoUtils {  private static final Logger LOGGER = LoggerFactory.getLogger(MojoUtils.class);  static <E extends Throwable> MojoFailureException toMojoFailureException(E e) { String causeMessage = e.getCause() != null ? "": "" + e.getCause().getMessage() : """"; return new MojoFailureException(e.getMessage() + causeMessage, e); }  static ProxyConfig getProxyConfig(MavenSession mavenSession, SettingsDecrypter decrypter) { if (mavenSession == null ||
                mavenSession.getSettings() == null ||
                mavenSession.getSettings().getProxies() == null ||
                mavenSession.getSettings().getProxies().isEmpty()) { return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList()); } else { <FILL_ME> final List<Proxy> mavenProxies = mavenSession.getSettings().getProxies();  final List<ProxyConfig.Proxy> proxies = new ArrayList<ProxyConfig.Proxy>(mavenProxies.size());  for (Proxy mavenProxy : mavenProxies) { if (mavenProxy.isActive()) { mavenProxy = decryptProxy(mavenProxy, decrypter); proxies.add(new ProxyConfig.Proxy(mavenProxy.getId(), mavenProxy.getProtocol(), mavenProxy.getHost(),
                            mavenProxy.getPort(), mavenProxy.getUsername(), mavenProxy.getPassword(), mavenProxy.getNonProxyHosts())); } }  LOGGER.info(""Found proxies: { } "", proxies); return new ProxyConfig(proxies); } }  private static Proxy decryptProxy(Proxy proxy, SettingsDecrypter decrypter) { synchronized (proxy) { final DefaultSettingsDecryptionRequest decryptionRequest = new DefaultSettingsDecryptionRequest(proxy); SettingsDecryptionResult decryptedResult = decrypter.decrypt(decryptionRequest); return decryptedResult.getProxy(); } }  static Server decryptServer(String serverId, MavenSession mavenSession, SettingsDecrypter decrypter) { if (StringUtils.isEmpty(serverId)) { return null; } Server server = mavenSession.getSettings().getServer(serverId); if (server != null) { synchronized (server) { final DefaultSettingsDecryptionRequest decryptionRequest = new DefaultSettingsDecryptionRequest(server); SettingsDecryptionResult decryptedResult = decrypter.decrypt(decryptionRequest); return decryptedResult.getServer(); } } else { return null; } }  static boolean shouldExecute(BuildContext buildContext, List<File> triggerfiles, File srcdir) {  // If there is no buildContext, or this is not an incremental build, always execute. if (buildContext == null || !buildContext.isIncremental()) { return true; }  if (triggerfiles != null) { for (File triggerfile : triggerfiles) { if (buildContext.hasDelta(triggerfile)) { return true; } } }  if (srcdir == null) { return true; }  // Check for changes in the srcdir Scanner scanner = buildContext.newScanner(srcdir); scanner.scan(); String[] includedFiles = scanner.getIncludedFiles(); return (includedFiles != null && includedFiles.length > 0); } }  "
frontend-maven-plugin/src/main/java/com/github/eirslett/maven/plugins/frontend/mojo/NpmMojo.java,"package com.github.eirslett.maven.plugins.frontend.mojo;

import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory;
import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig;
import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.settings.crypto.SettingsDecrypter;
import org.sonatype.plexus.build.incremental.BuildContext;

import java.io.File;
import java.util.Collections;

@Mojo(name=""npm"",  defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class NpmMojo extends AbstractFrontendMojo {

    private static final String NPM_REGISTRY_URL = ""npmRegistryURL"";
    
    /**
     * npm arguments. Default is ""install"".
     */
    @Parameter(defaultValue = ""install"", property = ""frontend.npm.arguments"", required = false)
    private String arguments;

    @Parameter(property = ""frontend.npm.npmInheritsProxyConfigFromMaven"", required = false, defaultValue = ""true"")
    private boolean npmInheritsProxyConfigFromMaven;

    /**
     * Registry override, passed as the registry option during npm install if set.
     */
    @Parameter(property = NPM_REGISTRY_URL, required = false, defaultValue = """")
    private String npmRegistryURL;
    
    @Parameter(property = ""session"", defaultValue = ""${session}"", readonly = true)
    private MavenSession session;

    @Component
    private BuildContext buildContext;

    @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter;

    /**
     * Skips execution of this mojo.
     */
    @Parameter(property = ""skip.npm"", defaultValue = ""${skip.npm}"")
    private boolean skip;

    @Override
    protected boolean skipExecution() {
        return this.skip;
    }

    @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException {
        File packageJson = new File(workingDirectory, ""package.json"");
        if (buildContext == null || buildContext.hasDelta(packageJson) || !buildContext.isIncremental()) {
            ProxyConfig proxyConfig = getProxyConfig();
            factory.getNpmRunner(proxyConfig, getRegistryUrl()).execute(arguments, environmentVariables);
        } else {
            getLog().info(""Skipping npm install as package.json unchanged"");
        }
    }

    private ProxyConfig getProxyConfig() {
        if (npmInheritsProxyConfigFromMaven) {
            return MojoUtils.getProxyConfig(session, decrypter);
        } else {
            getLog().info(""npm not inheriting proxy config from Maven"");
            return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList());
        }
    }

    private String getRegistryUrl() {
        // check to see if overridden via `-D`, otherwise fallback to pom value
        return System.getProperty(NPM_REGISTRY_URL, npmRegistryURL);
    }
}
","package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""npm"",  defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class NpmMojo extends AbstractFrontendMojo { private static final String NPM_REGISTRY_URL = ""npmRegistryURL""; @Parameter(defaultValue = ""install"", property = ""frontend.npm.arguments"", required = false)
    private String arguments; @Parameter(property = ""frontend.npm.npmInheritsProxyConfigFromMaven"", required = false, defaultValue = ""true"")
    private boolean npmInheritsProxyConfigFromMaven; @Parameter(property = NPM_REGISTRY_URL, required = false, defaultValue = """")
    private String npmRegistryURL; @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session; @Component
    private BuildContext buildContext; @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter; @Parameter(property = ""skip.npm"", defaultValue = ""${ skip.npm} "")
    private boolean skip; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { File packageJson = new File(workingDirectory, ""package.json""); if (buildContext == null || buildContext.hasDelta(packageJson) || !buildContext.isIncremental()) { ProxyConfig proxyConfig = getProxyConfig(); factory.getNpmRunner(proxyConfig, getRegistryUrl()).execute(arguments, environmentVariables); } else { getLog().info(""Skipping npm install as package.json unchanged""); } } private ProxyConfig getProxyConfig() { if (npmInheritsProxyConfigFromMaven) { return MojoUtils.getProxyConfig(session, decrypter); } else { getLog().info(""npm not inheriting proxy config from Maven""); return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList()); } } private String getRegistryUrl() { return System.getProperty(NPM_REGISTRY_URL, npmRegistryURL); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""npm"",  defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class NpmMojo extends AbstractFrontendMojo { private static final String NPM_REGISTRY_URL = ""npmRegistryURL""; @Parameter(defaultValue = ""install"", property = ""frontend.npm.arguments"", required = false)
    private String arguments; @Parameter(property = ""frontend.npm.npmInheritsProxyConfigFromMaven"", required = false, defaultValue = ""true"")
    private boolean npmInheritsProxyConfigFromMaven; @Parameter(property = NPM_REGISTRY_URL, required = false, defaultValue = """")
    private String npmRegistryURL; @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session; @Component
    private BuildContext buildContext; @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter; @Parameter(property = ""skip.npm"", defaultValue = ""${ skip.npm} "")
    private boolean skip; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { File packageJson = new File(workingDirectory, ""package.json""); if (buildContext == null || buildContext.hasDelta(packageJson) || !buildContext.isIncremental()) { ProxyConfig proxyConfig = getProxyConfig(); factory.getNpmRunner(proxyConfig, getRegistryUrl()).execute(arguments, environmentVariables); } else { getLog().info(""Skipping npm install as package.json unchanged""); } } private ProxyConfig getProxyConfig() { if (npmInheritsProxyConfigFromMaven) { return MojoUtils.getProxyConfig(session, decrypter); } else { getLog().info(""npm not inheriting proxy config from Maven""); return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList()); } } private String getRegistryUrl() { return System.getProperty(NPM_REGISTRY_URL, npmRegistryURL); } } ","package com.github.eirslett.maven.plugins.frontend.mojo; 
import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory; import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig; import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException; import org.apache.maven.execution.MavenSession; import org.apache.maven.plugins.annotations.Component; import org.apache.maven.plugins.annotations.LifecyclePhase; import org.apache.maven.plugins.annotations.Mojo; import org.apache.maven.plugins.annotations.Parameter; import org.apache.maven.settings.crypto.SettingsDecrypter; import org.sonatype.plexus.build.incremental.BuildContext; 
import java.io.File; import java.util.Collections;  @Mojo(name=""npm"",  defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class NpmMojo extends AbstractFrontendMojo {  private static final String NPM_REGISTRY_URL = ""npmRegistryURL"";      /**
     * npm arguments. Default is ""install"".
     */ @Parameter(defaultValue = ""install"", property = ""frontend.npm.arguments"", required = false)
    private String arguments;  @Parameter(property = ""frontend.npm.npmInheritsProxyConfigFromMaven"", required = false, defaultValue = ""true"")
    private boolean npmInheritsProxyConfigFromMaven;  /**
     * Registry override, passed as the registry option during npm install if set.
     */ @Parameter(property = NPM_REGISTRY_URL, required = false, defaultValue = """")
    private String npmRegistryURL;      @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session;  @Component
    private BuildContext buildContext;  @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter;  /**
     * Skips execution of this mojo.
     */ @Parameter(property = ""skip.npm"", defaultValue = ""${ skip.npm} "")
    private boolean skip;  @Override
    protected boolean skipExecution() { return this.skip; }  @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { File packageJson = new File(workingDirectory, ""package.json""); if (buildContext == null || buildContext.hasDelta(packageJson) || !buildContext.isIncremental()) { ProxyConfig proxyConfig = getProxyConfig(); factory.getNpmRunner(proxyConfig, getRegistryUrl()).execute(arguments, environmentVariables); } else { getLog().info(""Skipping npm install as package.json unchanged""); } }  private ProxyConfig getProxyConfig() { if (npmInheritsProxyConfigFromMaven) { return MojoUtils.getProxyConfig(session, decrypter); } else { getLog().info(""npm not inheriting proxy config from Maven""); return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList()); } }  private String getRegistryUrl() { // check to see if overridden via `-D`, otherwise fallback to pom value return System.getProperty(NPM_REGISTRY_URL, npmRegistryURL); } }  "
frontend-maven-plugin/src/main/java/com/github/eirslett/maven/plugins/frontend/mojo/NpxMojo.java,"package com.github.eirslett.maven.plugins.frontend.mojo;

import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory;
import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig;
import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.settings.crypto.SettingsDecrypter;
import org.sonatype.plexus.build.incremental.BuildContext;

import java.io.File;
import java.util.Collections;

@Mojo(name=""npx"",  defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class NpxMojo extends AbstractFrontendMojo {

    private static final String NPM_REGISTRY_URL = ""npmRegistryURL"";
    
    /**
     * npm arguments. Default is ""install"".
     */
    @Parameter(defaultValue = ""install"", property = ""frontend.npx.arguments"", required = false)
    private String arguments;

    @Parameter(property = ""frontend.npx.npmInheritsProxyConfigFromMaven"", required = false, defaultValue = ""true"")
    private boolean npmInheritsProxyConfigFromMaven;

    /**
     * Registry override, passed as the registry option during npm install if set.
     */
    @Parameter(property = NPM_REGISTRY_URL, required = false, defaultValue = """")
    private String npmRegistryURL;
    
    @Parameter(property = ""session"", defaultValue = ""${session}"", readonly = true)
    private MavenSession session;

    @Component
    private BuildContext buildContext;

    @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter;

    /**
     * Skips execution of this mojo.
     */
    @Parameter(property = ""skip.npx"", defaultValue = ""${skip.npx}"")
    private boolean skip;

    @Override
    protected boolean skipExecution() {
        return this.skip;
    }

    @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException {
        File packageJson = new File(workingDirectory, ""package.json"");
        if (buildContext == null || buildContext.hasDelta(packageJson) || !buildContext.isIncremental()) {
            ProxyConfig proxyConfig = getProxyConfig();
            factory.getNpxRunner(proxyConfig, getRegistryUrl()).execute(arguments, environmentVariables);
        } else {
            getLog().info(""Skipping npm install as package.json unchanged"");
        }
    }

    private ProxyConfig getProxyConfig() {
        if (npmInheritsProxyConfigFromMaven) {
            return MojoUtils.getProxyConfig(session, decrypter);
        } else {
            getLog().info(""npm not inheriting proxy config from Maven"");
            return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList());
        }
    }

    private String getRegistryUrl() {
        // check to see if overridden via `-D`, otherwise fallback to pom value
        return System.getProperty(NPM_REGISTRY_URL, npmRegistryURL);
    }
}
","package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""npx"",  defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class NpxMojo extends AbstractFrontendMojo { private static final String NPM_REGISTRY_URL = ""npmRegistryURL""; @Parameter(defaultValue = ""install"", property = ""frontend.npx.arguments"", required = false)
    private String arguments; @Parameter(property = ""frontend.npx.npmInheritsProxyConfigFromMaven"", required = false, defaultValue = ""true"")
    private boolean npmInheritsProxyConfigFromMaven; @Parameter(property = NPM_REGISTRY_URL, required = false, defaultValue = """")
    private String npmRegistryURL; @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session; @Component
    private BuildContext buildContext; @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter; @Parameter(property = ""skip.npx"", defaultValue = ""${ skip.npx} "")
    private boolean skip; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { File packageJson = new File(workingDirectory, ""package.json""); if (buildContext == null || buildContext.hasDelta(packageJson) || !buildContext.isIncremental()) { ProxyConfig proxyConfig = getProxyConfig(); factory.getNpxRunner(proxyConfig, getRegistryUrl()).execute(arguments, environmentVariables); } else { getLog().info(""Skipping npm install as package.json unchanged""); } } private ProxyConfig getProxyConfig() { if (npmInheritsProxyConfigFromMaven) { return MojoUtils.getProxyConfig(session, decrypter); } else { getLog().info(""npm not inheriting proxy config from Maven""); return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList()); } } private String getRegistryUrl() { return System.getProperty(NPM_REGISTRY_URL, npmRegistryURL); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""npx"",  defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class NpxMojo extends AbstractFrontendMojo { private static final String NPM_REGISTRY_URL = ""npmRegistryURL""; @Parameter(defaultValue = ""install"", property = ""frontend.npx.arguments"", required = false)
    private String arguments; @Parameter(property = ""frontend.npx.npmInheritsProxyConfigFromMaven"", required = false, defaultValue = ""true"")
    private boolean npmInheritsProxyConfigFromMaven; @Parameter(property = NPM_REGISTRY_URL, required = false, defaultValue = """")
    private String npmRegistryURL; @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session; @Component
    private BuildContext buildContext; @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter; @Parameter(property = ""skip.npx"", defaultValue = ""${ skip.npx} "")
    private boolean skip; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { File packageJson = new File(workingDirectory, ""package.json""); if (buildContext == null || buildContext.hasDelta(packageJson) || !buildContext.isIncremental()) { ProxyConfig proxyConfig = getProxyConfig(); factory.getNpxRunner(proxyConfig, getRegistryUrl()).execute(arguments, environmentVariables); } else { getLog().info(""Skipping npm install as package.json unchanged""); } } private ProxyConfig getProxyConfig() { if (npmInheritsProxyConfigFromMaven) { return MojoUtils.getProxyConfig(session, decrypter); } else { getLog().info(""npm not inheriting proxy config from Maven""); return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList()); } } private String getRegistryUrl() { return System.getProperty(NPM_REGISTRY_URL, npmRegistryURL); } } ","package com.github.eirslett.maven.plugins.frontend.mojo; 
import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory; import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig; import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException; import org.apache.maven.execution.MavenSession; import org.apache.maven.plugins.annotations.Component; import org.apache.maven.plugins.annotations.LifecyclePhase; import org.apache.maven.plugins.annotations.Mojo; import org.apache.maven.plugins.annotations.Parameter; import org.apache.maven.settings.crypto.SettingsDecrypter; import org.sonatype.plexus.build.incremental.BuildContext; 
import java.io.File; import java.util.Collections;  @Mojo(name=""npx"",  defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class NpxMojo extends AbstractFrontendMojo {  private static final String NPM_REGISTRY_URL = ""npmRegistryURL"";      /**
     * npm arguments. Default is ""install"".
     */ @Parameter(defaultValue = ""install"", property = ""frontend.npx.arguments"", required = false)
    private String arguments;  @Parameter(property = ""frontend.npx.npmInheritsProxyConfigFromMaven"", required = false, defaultValue = ""true"")
    private boolean npmInheritsProxyConfigFromMaven;  /**
     * Registry override, passed as the registry option during npm install if set.
     */ @Parameter(property = NPM_REGISTRY_URL, required = false, defaultValue = """")
    private String npmRegistryURL;      @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session;  @Component
    private BuildContext buildContext;  @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter;  /**
     * Skips execution of this mojo.
     */ @Parameter(property = ""skip.npx"", defaultValue = ""${ skip.npx} "")
    private boolean skip;  @Override
    protected boolean skipExecution() { return this.skip; }  @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { File packageJson = new File(workingDirectory, ""package.json""); if (buildContext == null || buildContext.hasDelta(packageJson) || !buildContext.isIncremental()) { ProxyConfig proxyConfig = getProxyConfig(); factory.getNpxRunner(proxyConfig, getRegistryUrl()).execute(arguments, environmentVariables); } else { getLog().info(""Skipping npm install as package.json unchanged""); } }  private ProxyConfig getProxyConfig() { if (npmInheritsProxyConfigFromMaven) { return MojoUtils.getProxyConfig(session, decrypter); } else { getLog().info(""npm not inheriting proxy config from Maven""); return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList()); } }  private String getRegistryUrl() { // check to see if overridden via `-D`, otherwise fallback to pom value return System.getProperty(NPM_REGISTRY_URL, npmRegistryURL); } }  "
frontend-maven-plugin/src/main/java/com/github/eirslett/maven/plugins/frontend/mojo/PnpmMojo.java,"package com.github.eirslett.maven.plugins.frontend.mojo;

import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory;
import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig;
import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.settings.crypto.SettingsDecrypter;
import org.sonatype.plexus.build.incremental.BuildContext;

import java.io.File;
import java.util.Collections;

@Mojo(name=""pnpm"",  defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class PnpmMojo extends AbstractFrontendMojo {

    private static final String PNPM_REGISTRY_URL = ""npmRegistryURL"";

    /**
     * pnpm arguments. Default is ""install"".
     */
    @Parameter(defaultValue = ""install"", property = ""frontend.pnpm.arguments"", required = false)
    private String arguments;

    @Parameter(property = ""frontend.pnpm.pnpmInheritsProxyConfigFromMaven"", required = false, defaultValue = ""true"")
    private boolean pnpmInheritsProxyConfigFromMaven;

    /**
     * Registry override, passed as the registry option during pnpm install if set.
     */
    @Parameter(property = PNPM_REGISTRY_URL, required = false, defaultValue = """")
    private String pnpmRegistryURL;

    @Parameter(property = ""session"", defaultValue = ""${session}"", readonly = true)
    private MavenSession session;

    @Component
    private BuildContext buildContext;

    @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter;

    /**
     * Skips execution of this mojo.
     */
    @Parameter(property = ""skip.pnpm"", defaultValue = ""${skip.pnpm}"")
    private boolean skip;

    @Override
    protected boolean skipExecution() {
        return this.skip;
    }

    @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException {
        File packageJson = new File(workingDirectory, ""package.json"");
        if (buildContext == null || buildContext.hasDelta(packageJson) || !buildContext.isIncremental()) {
            ProxyConfig proxyConfig = getProxyConfig();
            factory.getPnpmRunner(proxyConfig, getRegistryUrl()).execute(arguments, environmentVariables);
        } else {
            getLog().info(""Skipping pnpm install as package.json unchanged"");
        }
    }

    private ProxyConfig getProxyConfig() {
        if (pnpmInheritsProxyConfigFromMaven) {
            return MojoUtils.getProxyConfig(session, decrypter);
        } else {
            getLog().info(""pnpm not inheriting proxy config from Maven"");
            return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList());
        }
    }

    private String getRegistryUrl() {
        // check to see if overridden via `-D`, otherwise fallback to pom value
        return System.getProperty(PNPM_REGISTRY_URL, pnpmRegistryURL);
    }
}
","package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""pnpm"",  defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class PnpmMojo extends AbstractFrontendMojo { private static final String PNPM_REGISTRY_URL = ""npmRegistryURL""; @Parameter(defaultValue = ""install"", property = ""frontend.pnpm.arguments"", required = false)
    private String arguments; @Parameter(property = ""frontend.pnpm.pnpmInheritsProxyConfigFromMaven"", required = false, defaultValue = ""true"")
    private boolean pnpmInheritsProxyConfigFromMaven; @Parameter(property = PNPM_REGISTRY_URL, required = false, defaultValue = """")
    private String pnpmRegistryURL; @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session; @Component
    private BuildContext buildContext; @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter; @Parameter(property = ""skip.pnpm"", defaultValue = ""${ skip.pnpm} "")
    private boolean skip; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { File packageJson = new File(workingDirectory, ""package.json""); if (buildContext == null || buildContext.hasDelta(packageJson) || !buildContext.isIncremental()) { ProxyConfig proxyConfig = getProxyConfig(); factory.getPnpmRunner(proxyConfig, getRegistryUrl()).execute(arguments, environmentVariables); } else { getLog().info(""Skipping pnpm install as package.json unchanged""); } } private ProxyConfig getProxyConfig() { if (pnpmInheritsProxyConfigFromMaven) { return MojoUtils.getProxyConfig(session, decrypter); } else { getLog().info(""pnpm not inheriting proxy config from Maven""); return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList()); } } private String getRegistryUrl() { return System.getProperty(PNPM_REGISTRY_URL, pnpmRegistryURL); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""pnpm"",  defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class PnpmMojo extends AbstractFrontendMojo { private static final String PNPM_REGISTRY_URL = ""npmRegistryURL""; @Parameter(defaultValue = ""install"", property = ""frontend.pnpm.arguments"", required = false)
    private String arguments; @Parameter(property = ""frontend.pnpm.pnpmInheritsProxyConfigFromMaven"", required = false, defaultValue = ""true"")
    private boolean pnpmInheritsProxyConfigFromMaven; @Parameter(property = PNPM_REGISTRY_URL, required = false, defaultValue = """")
    private String pnpmRegistryURL; @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session; @Component
    private BuildContext buildContext; @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter; @Parameter(property = ""skip.pnpm"", defaultValue = ""${ skip.pnpm} "")
    private boolean skip; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { File packageJson = new File(workingDirectory, ""package.json""); if (buildContext == null || buildContext.hasDelta(packageJson) || !buildContext.isIncremental()) { ProxyConfig proxyConfig = getProxyConfig(); factory.getPnpmRunner(proxyConfig, getRegistryUrl()).execute(arguments, environmentVariables); } else { getLog().info(""Skipping pnpm install as package.json unchanged""); } } private ProxyConfig getProxyConfig() { if (pnpmInheritsProxyConfigFromMaven) { return MojoUtils.getProxyConfig(session, decrypter); } else { getLog().info(""pnpm not inheriting proxy config from Maven""); return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList()); } } private String getRegistryUrl() { return System.getProperty(PNPM_REGISTRY_URL, pnpmRegistryURL); } } ","package com.github.eirslett.maven.plugins.frontend.mojo; 
import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory; import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig; import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException; import org.apache.maven.execution.MavenSession; import org.apache.maven.plugins.annotations.Component; import org.apache.maven.plugins.annotations.LifecyclePhase; import org.apache.maven.plugins.annotations.Mojo; import org.apache.maven.plugins.annotations.Parameter; import org.apache.maven.settings.crypto.SettingsDecrypter; import org.sonatype.plexus.build.incremental.BuildContext; 
import java.io.File; import java.util.Collections;  @Mojo(name=""pnpm"",  defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class PnpmMojo extends AbstractFrontendMojo {  private static final String PNPM_REGISTRY_URL = ""npmRegistryURL"";  /**
     * pnpm arguments. Default is ""install"".
     */ @Parameter(defaultValue = ""install"", property = ""frontend.pnpm.arguments"", required = false)
    private String arguments;  @Parameter(property = ""frontend.pnpm.pnpmInheritsProxyConfigFromMaven"", required = false, defaultValue = ""true"")
    private boolean pnpmInheritsProxyConfigFromMaven;  /**
     * Registry override, passed as the registry option during pnpm install if set.
     */ @Parameter(property = PNPM_REGISTRY_URL, required = false, defaultValue = """")
    private String pnpmRegistryURL;  @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session;  @Component
    private BuildContext buildContext;  @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter;  /**
     * Skips execution of this mojo.
     */ @Parameter(property = ""skip.pnpm"", defaultValue = ""${ skip.pnpm} "")
    private boolean skip;  @Override
    protected boolean skipExecution() { return this.skip; }  @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { File packageJson = new File(workingDirectory, ""package.json""); if (buildContext == null || buildContext.hasDelta(packageJson) || !buildContext.isIncremental()) { ProxyConfig proxyConfig = getProxyConfig(); factory.getPnpmRunner(proxyConfig, getRegistryUrl()).execute(arguments, environmentVariables); } else { getLog().info(""Skipping pnpm install as package.json unchanged""); } }  private ProxyConfig getProxyConfig() { if (pnpmInheritsProxyConfigFromMaven) { return MojoUtils.getProxyConfig(session, decrypter); } else { getLog().info(""pnpm not inheriting proxy config from Maven""); return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList()); } }  private String getRegistryUrl() { // check to see if overridden via `-D`, otherwise fallback to pom value return System.getProperty(PNPM_REGISTRY_URL, pnpmRegistryURL); } }  "
frontend-maven-plugin/src/main/java/com/github/eirslett/maven/plugins/frontend/mojo/RepositoryCacheResolver.java,"package com.github.eirslett.maven.plugins.frontend.mojo;

import com.github.eirslett.maven.plugins.frontend.lib.CacheDescriptor;
import com.github.eirslett.maven.plugins.frontend.lib.CacheResolver;
import org.eclipse.aether.RepositorySystemSession;
import org.eclipse.aether.artifact.DefaultArtifact;
import org.eclipse.aether.repository.LocalRepositoryManager;

import java.io.File;

public class RepositoryCacheResolver implements CacheResolver {

  private static final String GROUP_ID = ""com.github.eirslett"";
  private final RepositorySystemSession repositorySystemSession;

  public RepositoryCacheResolver(RepositorySystemSession repositorySystemSession) {
    this.repositorySystemSession = repositorySystemSession;
  }

  @Override
  public File resolve(CacheDescriptor cacheDescriptor) {
    LocalRepositoryManager manager = repositorySystemSession.getLocalRepositoryManager();
    File localArtifact = new File(
        manager.getRepository().getBasedir(),
        manager.getPathForLocalArtifact(createArtifact(cacheDescriptor))
    );
    return localArtifact;
  }

  private DefaultArtifact createArtifact(CacheDescriptor cacheDescriptor) {
    String version = cacheDescriptor.getVersion().replaceAll(""^v"", """");

    DefaultArtifact artifact;

    if (cacheDescriptor.getClassifier() == null) {
      artifact = new DefaultArtifact(
          GROUP_ID,
          cacheDescriptor.getName(),
          cacheDescriptor.getExtension(),
          version
      );
    } else {
      artifact = new DefaultArtifact(
          GROUP_ID,
          cacheDescriptor.getName(),
          cacheDescriptor.getClassifier(),
          cacheDescriptor.getExtension(),
          version
      );
    }
    return artifact;
  }
}
","package com.github.eirslett.maven.plugins.frontend.mojo; public class RepositoryCacheResolver implements CacheResolver { private static final String GROUP_ID = ""com.github.eirslett""; private final RepositorySystemSession repositorySystemSession; public RepositoryCacheResolver(RepositorySystemSession repositorySystemSession) { this.repositorySystemSession = repositorySystemSession; } @Override
  public File resolve(CacheDescriptor cacheDescriptor) { LocalRepositoryManager manager = repositorySystemSession.getLocalRepositoryManager(); File localArtifact = new File(
        manager.getRepository().getBasedir(),
        manager.getPathForLocalArtifact(createArtifact(cacheDescriptor))
    ); return localArtifact; } private DefaultArtifact createArtifact(CacheDescriptor cacheDescriptor) { String version = cacheDescriptor.getVersion().replaceAll(""^v"", """"); DefaultArtifact artifact; if (cacheDescriptor.getClassifier() == null) { artifact = new DefaultArtifact(
          GROUP_ID,
          cacheDescriptor.getName(),
          cacheDescriptor.getExtension(),
          version
      ); } else { artifact = new DefaultArtifact(
          GROUP_ID,
          cacheDescriptor.getName(),
          cacheDescriptor.getClassifier(),
          cacheDescriptor.getExtension(),
          version
      ); } return artifact; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.mojo; public class RepositoryCacheResolver implements CacheResolver { private static final String GROUP_ID = ""com.github.eirslett""; private final RepositorySystemSession repositorySystemSession; public RepositoryCacheResolver(RepositorySystemSession repositorySystemSession) { this.repositorySystemSession = repositorySystemSession; } @Override
  public File resolve(CacheDescriptor cacheDescriptor) { LocalRepositoryManager manager = repositorySystemSession.getLocalRepositoryManager(); File localArtifact = new File(
        manager.getRepository().getBasedir(),
        manager.getPathForLocalArtifact(createArtifact(cacheDescriptor))
    ); return localArtifact; } private DefaultArtifact createArtifact(CacheDescriptor cacheDescriptor) { String version = cacheDescriptor.getVersion().replaceAll(""^v"", """"); DefaultArtifact artifact; if (cacheDescriptor.getClassifier() == null) { artifact = new DefaultArtifact(
          GROUP_ID,
          cacheDescriptor.getName(),
          cacheDescriptor.getExtension(),
          version
      ); } else { artifact = new DefaultArtifact(
          GROUP_ID,
          cacheDescriptor.getName(),
          cacheDescriptor.getClassifier(),
          cacheDescriptor.getExtension(),
          version
      ); } return artifact; } } ","package com.github.eirslett.maven.plugins.frontend.mojo; 
import com.github.eirslett.maven.plugins.frontend.lib.CacheDescriptor; import com.github.eirslett.maven.plugins.frontend.lib.CacheResolver; import org.eclipse.aether.RepositorySystemSession; import org.eclipse.aether.artifact.DefaultArtifact; import org.eclipse.aether.repository.LocalRepositoryManager; 
import java.io.File;  public class RepositoryCacheResolver implements CacheResolver {  private static final String GROUP_ID = ""com.github.eirslett""; private final RepositorySystemSession repositorySystemSession;  public RepositoryCacheResolver(RepositorySystemSession repositorySystemSession) { this.repositorySystemSession = repositorySystemSession; }  @Override
  public File resolve(CacheDescriptor cacheDescriptor) { LocalRepositoryManager manager = repositorySystemSession.getLocalRepositoryManager(); File localArtifact = new File(
        manager.getRepository().getBasedir(),
        manager.getPathForLocalArtifact(createArtifact(cacheDescriptor))
    ); return localArtifact; }  private DefaultArtifact createArtifact(CacheDescriptor cacheDescriptor) { String version = cacheDescriptor.getVersion().replaceAll(""^v"", """");  DefaultArtifact artifact;  if (cacheDescriptor.getClassifier() == null) { artifact = new DefaultArtifact(
          GROUP_ID,
          cacheDescriptor.getName(),
          cacheDescriptor.getExtension(),
          version
      ); } else { artifact = new DefaultArtifact(
          GROUP_ID,
          cacheDescriptor.getName(),
          cacheDescriptor.getClassifier(),
          cacheDescriptor.getExtension(),
          version
      ); } return artifact; } }  "
frontend-maven-plugin/src/main/java/com/github/eirslett/maven/plugins/frontend/mojo/WebpackMojo.java,"package com.github.eirslett.maven.plugins.frontend.mojo;

import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory;
import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.sonatype.plexus.build.incremental.BuildContext;

import java.io.File;
import java.util.Arrays;
import java.util.List;

@Mojo(name=""webpack"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class WebpackMojo extends AbstractFrontendMojo {

    /**
     * Webpack arguments. Default is empty (runs just the ""webpack"" command).
     */
    @Parameter(property = ""frontend.webpack.arguments"")
    private String arguments;

    /**
     * Files that should be checked for changes, in addition to the srcdir files.
     * Defaults to webpack.config.js in the {@link #workingDirectory}.
     */
    @Parameter(property = ""triggerfiles"")
    private List<File> triggerfiles;

    /**
     * The directory containing front end files that will be processed by webpack.
     * If this is set then files in the directory will be checked for
     * modifications before running webpack.
     */
    @Parameter(property = ""srcdir"")
    private File srcdir;

    /**
     * The directory where front end files will be output by webpack. If this is
     * set then they will be refreshed so they correctly show as modified in
     * Eclipse.
     */
    @Parameter(property = ""outputdir"")
    private File outputdir;

    /**
     * Skips execution of this mojo.
     */
    @Parameter(property = ""skip.webpack"", defaultValue = ""${skip.webpack}"")
    private boolean skip;

    @Component
    private BuildContext buildContext;

    @Override
    protected boolean skipExecution() {
        return this.skip;
    }

    @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException {
        if (shouldExecute()) {
            factory.getWebpackRunner().execute(arguments, environmentVariables);

            if (outputdir != null) {
                getLog().info(""Refreshing files after webpack: "" + outputdir);
                buildContext.refresh(outputdir);
            }
        } else {
            getLog().info(""Skipping webpack as no modified files in "" + srcdir);
        }
    }

    private boolean shouldExecute() {
        if (triggerfiles == null || triggerfiles.isEmpty()) {
            triggerfiles = Arrays.asList(new File(workingDirectory, ""webpack.config.js""));
        }

        return MojoUtils.shouldExecute(buildContext, triggerfiles, srcdir);
    }

}
","package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""webpack"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class WebpackMojo extends AbstractFrontendMojo { @Parameter(property = ""frontend.webpack.arguments"")
    private String arguments; @Parameter(property = ""triggerfiles"")
    private List<File> triggerfiles; @Parameter(property = ""srcdir"")
    private File srcdir; @Parameter(property = ""outputdir"")
    private File outputdir; @Parameter(property = ""skip.webpack"", defaultValue = ""${ skip.webpack} "")
    private boolean skip; @Component
    private BuildContext buildContext; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { if (shouldExecute()) { factory.getWebpackRunner().execute(arguments, environmentVariables); if (outputdir != null) { getLog().info(""Refreshing files after webpack: "" + outputdir); buildContext.refresh(outputdir); } } else { getLog().info(""Skipping webpack as no modified files in "" + srcdir); } } private boolean shouldExecute() { if (triggerfiles == null || triggerfiles.isEmpty()) { triggerfiles = Arrays.asList(new File(workingDirectory, ""webpack.config.js"")); } return MojoUtils.shouldExecute(buildContext, triggerfiles, srcdir); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name=""webpack"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class WebpackMojo extends AbstractFrontendMojo { @Parameter(property = ""frontend.webpack.arguments"")
    private String arguments; @Parameter(property = ""triggerfiles"")
    private List<File> triggerfiles; @Parameter(property = ""srcdir"")
    private File srcdir; @Parameter(property = ""outputdir"")
    private File outputdir; @Parameter(property = ""skip.webpack"", defaultValue = ""${ skip.webpack} "")
    private boolean skip; @Component
    private BuildContext buildContext; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { if (shouldExecute()) { factory.getWebpackRunner().execute(arguments, environmentVariables); if (outputdir != null) { getLog().info(""Refreshing files after webpack: "" + outputdir); buildContext.refresh(outputdir); } } else { getLog().info(""Skipping webpack as no modified files in "" + srcdir); } } private boolean shouldExecute() { if (triggerfiles == null || triggerfiles.isEmpty()) { triggerfiles = Arrays.asList(new File(workingDirectory, ""webpack.config.js"")); } return MojoUtils.shouldExecute(buildContext, triggerfiles, srcdir); } } ","package com.github.eirslett.maven.plugins.frontend.mojo; 
import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory; import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException; import org.apache.maven.plugins.annotations.Component; import org.apache.maven.plugins.annotations.LifecyclePhase; import org.apache.maven.plugins.annotations.Mojo; import org.apache.maven.plugins.annotations.Parameter; import org.sonatype.plexus.build.incremental.BuildContext; 
import java.io.File; import java.util.Arrays; import java.util.List;  @Mojo(name=""webpack"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class WebpackMojo extends AbstractFrontendMojo {  /**
     * Webpack arguments. Default is empty (runs just the ""webpack"" command).
     */ @Parameter(property = ""frontend.webpack.arguments"")
    private String arguments;  /**
     * Files that should be checked for changes, in addition to the srcdir files.
     * Defaults to webpack.config.js in the {@link #workingDirectory}.
     */ @Parameter(property = ""triggerfiles"")
    private List<File> triggerfiles;  /**
     * The directory containing front end files that will be processed by webpack.
     * If this is set then files in the directory will be checked for
     * modifications before running webpack.
     */ @Parameter(property = ""srcdir"")
    private File srcdir;  /**
     * The directory where front end files will be output by webpack. If this is
     * set then they will be refreshed so they correctly show as modified in
     * Eclipse.
     */ @Parameter(property = ""outputdir"")
    private File outputdir;  /**
     * Skips execution of this mojo.
     */ @Parameter(property = ""skip.webpack"", defaultValue = ""${ skip.webpack} "")
    private boolean skip;  @Component
    private BuildContext buildContext;  @Override
    protected boolean skipExecution() { return this.skip; }  @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { if (shouldExecute()) { factory.getWebpackRunner().execute(arguments, environmentVariables);  if (outputdir != null) { getLog().info(""Refreshing files after webpack: "" + outputdir); buildContext.refresh(outputdir); } } else { getLog().info(""Skipping webpack as no modified files in "" + srcdir); } }  private boolean shouldExecute() { if (triggerfiles == null || triggerfiles.isEmpty()) { triggerfiles = Arrays.asList(new File(workingDirectory, ""webpack.config.js"")); }  return MojoUtils.shouldExecute(buildContext, triggerfiles, srcdir); }  }  "
frontend-maven-plugin/src/main/java/com/github/eirslett/maven/plugins/frontend/mojo/YarnMojo.java,"package com.github.eirslett.maven.plugins.frontend.mojo;

import static com.github.eirslett.maven.plugins.frontend.mojo.YarnUtils.isYarnrcYamlFilePresent;

import java.io.File;
import java.util.Collections;

import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.settings.crypto.SettingsDecrypter;
import org.sonatype.plexus.build.incremental.BuildContext;

import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory;
import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig;
import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException;

@Mojo(name = ""yarn"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class YarnMojo extends AbstractFrontendMojo {

    private static final String NPM_REGISTRY_URL = ""npmRegistryURL"";

    /**
     * npm arguments. Default is ""install"".
     */
    @Parameter(defaultValue = """", property = ""frontend.yarn.arguments"", required = false)
    private String arguments;

    @Parameter(property = ""frontend.yarn.yarnInheritsProxyConfigFromMaven"", required = false,
        defaultValue = ""true"")
    private boolean yarnInheritsProxyConfigFromMaven;

    /**
     * Registry override, passed as the registry option during npm install if set.
     */
    @Parameter(property = NPM_REGISTRY_URL, required = false, defaultValue = """")
    private String npmRegistryURL;

    @Parameter(property = ""session"", defaultValue = ""${session}"", readonly = true)
    private MavenSession session;

    @Component
    private BuildContext buildContext;

    @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter;

    /**
     * Skips execution of this mojo.
     */
    @Parameter(property = ""skip.yarn"", defaultValue = ""${skip.yarn}"")
    private boolean skip;

    @Override
    protected boolean skipExecution() {
        return this.skip;
    }

    @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException {
        File packageJson = new File(this.workingDirectory, ""package.json"");
        if (this.buildContext == null || this.buildContext.hasDelta(packageJson)
            || !this.buildContext.isIncremental()) {
            ProxyConfig proxyConfig = getProxyConfig();
            boolean isYarnBerry = isYarnrcYamlFilePresent(this.session, this.workingDirectory);
            factory.getYarnRunner(proxyConfig, getRegistryUrl(), isYarnBerry).execute(this.arguments,
                this.environmentVariables);
        } else {
            getLog().info(""Skipping yarn install as package.json unchanged"");
        }
    }

    private ProxyConfig getProxyConfig() {
        if (this.yarnInheritsProxyConfigFromMaven) {
            return MojoUtils.getProxyConfig(this.session, this.decrypter);
        } else {
            getLog().info(""yarn not inheriting proxy config from Maven"");
            return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList());
        }
    }

    private String getRegistryUrl() {
        // check to see if overridden via `-D`, otherwise fallback to pom value
        return System.getProperty(NPM_REGISTRY_URL, this.npmRegistryURL);
    }
}
","package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name = ""yarn"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class YarnMojo extends AbstractFrontendMojo { private static final String NPM_REGISTRY_URL = ""npmRegistryURL""; @Parameter(defaultValue = """", property = ""frontend.yarn.arguments"", required = false)
    private String arguments; @Parameter(property = ""frontend.yarn.yarnInheritsProxyConfigFromMaven"", required = false,
        defaultValue = ""true"")
    private boolean yarnInheritsProxyConfigFromMaven; @Parameter(property = NPM_REGISTRY_URL, required = false, defaultValue = """")
    private String npmRegistryURL; @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session; @Component
    private BuildContext buildContext; @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter; @Parameter(property = ""skip.yarn"", defaultValue = ""${ skip.yarn} "")
    private boolean skip; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { File packageJson = new File(this.workingDirectory, ""package.json""); if (this.buildContext == null || this.buildContext.hasDelta(packageJson)
            || !this.buildContext.isIncremental()) { ProxyConfig proxyConfig = getProxyConfig(); boolean isYarnBerry = isYarnrcYamlFilePresent(this.session, this.workingDirectory); factory.getYarnRunner(proxyConfig, getRegistryUrl(), isYarnBerry).execute(this.arguments,
                this.environmentVariables); } else { getLog().info(""Skipping yarn install as package.json unchanged""); } } private ProxyConfig getProxyConfig() { if (this.yarnInheritsProxyConfigFromMaven) { return MojoUtils.getProxyConfig(this.session, this.decrypter); } else { getLog().info(""yarn not inheriting proxy config from Maven""); return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList()); } } private String getRegistryUrl() { return System.getProperty(NPM_REGISTRY_URL, this.npmRegistryURL); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.mojo; @Mojo(name = ""yarn"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class YarnMojo extends AbstractFrontendMojo { private static final String NPM_REGISTRY_URL = ""npmRegistryURL""; @Parameter(defaultValue = """", property = ""frontend.yarn.arguments"", required = false)
    private String arguments; @Parameter(property = ""frontend.yarn.yarnInheritsProxyConfigFromMaven"", required = false,
        defaultValue = ""true"")
    private boolean yarnInheritsProxyConfigFromMaven; @Parameter(property = NPM_REGISTRY_URL, required = false, defaultValue = """")
    private String npmRegistryURL; @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session; @Component
    private BuildContext buildContext; @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter; @Parameter(property = ""skip.yarn"", defaultValue = ""${ skip.yarn} "")
    private boolean skip; @Override
    protected boolean skipExecution() { return this.skip; } @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { File packageJson = new File(this.workingDirectory, ""package.json""); if (this.buildContext == null || this.buildContext.hasDelta(packageJson)
            || !this.buildContext.isIncremental()) { ProxyConfig proxyConfig = getProxyConfig(); boolean isYarnBerry = isYarnrcYamlFilePresent(this.session, this.workingDirectory); factory.getYarnRunner(proxyConfig, getRegistryUrl(), isYarnBerry).execute(this.arguments,
                this.environmentVariables); } else { getLog().info(""Skipping yarn install as package.json unchanged""); } } private ProxyConfig getProxyConfig() { if (this.yarnInheritsProxyConfigFromMaven) { return MojoUtils.getProxyConfig(this.session, this.decrypter); } else { getLog().info(""yarn not inheriting proxy config from Maven""); return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList()); } } private String getRegistryUrl() { return System.getProperty(NPM_REGISTRY_URL, this.npmRegistryURL); } } ","package com.github.eirslett.maven.plugins.frontend.mojo; 
import static com.github.eirslett.maven.plugins.frontend.mojo.YarnUtils.isYarnrcYamlFilePresent; 
import java.io.File; import java.util.Collections; 
import org.apache.maven.execution.MavenSession; import org.apache.maven.plugins.annotations.Component; import org.apache.maven.plugins.annotations.LifecyclePhase; import org.apache.maven.plugins.annotations.Mojo; import org.apache.maven.plugins.annotations.Parameter; import org.apache.maven.settings.crypto.SettingsDecrypter; import org.sonatype.plexus.build.incremental.BuildContext; 
import com.github.eirslett.maven.plugins.frontend.lib.FrontendPluginFactory; import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig; import com.github.eirslett.maven.plugins.frontend.lib.TaskRunnerException;  @Mojo(name = ""yarn"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public final class YarnMojo extends AbstractFrontendMojo {  private static final String NPM_REGISTRY_URL = ""npmRegistryURL"";  /**
     * npm arguments. Default is ""install"".
     */ @Parameter(defaultValue = """", property = ""frontend.yarn.arguments"", required = false)
    private String arguments;  @Parameter(property = ""frontend.yarn.yarnInheritsProxyConfigFromMaven"", required = false,
        defaultValue = ""true"")
    private boolean yarnInheritsProxyConfigFromMaven;  /**
     * Registry override, passed as the registry option during npm install if set.
     */ @Parameter(property = NPM_REGISTRY_URL, required = false, defaultValue = """")
    private String npmRegistryURL;  @Parameter(property = ""session"", defaultValue = ""${ session} "", readonly = true)
    private MavenSession session;  @Component
    private BuildContext buildContext;  @Component(role = SettingsDecrypter.class)
    private SettingsDecrypter decrypter;  /**
     * Skips execution of this mojo.
     */ @Parameter(property = ""skip.yarn"", defaultValue = ""${ skip.yarn} "")
    private boolean skip;  @Override
    protected boolean skipExecution() { return this.skip; }  @Override
    public synchronized void execute(FrontendPluginFactory factory) throws TaskRunnerException { File packageJson = new File(this.workingDirectory, ""package.json""); if (this.buildContext == null || this.buildContext.hasDelta(packageJson)
            || !this.buildContext.isIncremental()) { ProxyConfig proxyConfig = getProxyConfig(); boolean isYarnBerry = isYarnrcYamlFilePresent(this.session, this.workingDirectory); factory.getYarnRunner(proxyConfig, getRegistryUrl(), isYarnBerry).execute(this.arguments,
                this.environmentVariables); } else { getLog().info(""Skipping yarn install as package.json unchanged""); } }  private ProxyConfig getProxyConfig() { if (this.yarnInheritsProxyConfigFromMaven) { return MojoUtils.getProxyConfig(this.session, this.decrypter); } else { getLog().info(""yarn not inheriting proxy config from Maven""); return new ProxyConfig(Collections.<ProxyConfig.Proxy>emptyList()); } }  private String getRegistryUrl() { // check to see if overridden via `-D`, otherwise fallback to pom value return System.getProperty(NPM_REGISTRY_URL, this.npmRegistryURL); } }  "
frontend-maven-plugin/src/main/java/com/github/eirslett/maven/plugins/frontend/mojo/YarnUtils.java,"package com.github.eirslett.maven.plugins.frontend.mojo;

import java.io.File;
import java.util.stream.Stream;

import org.apache.maven.execution.MavenSession;

public class YarnUtils {

    private static final String YARNRC_YAML_FILE_NAME = "".yarnrc.yml"";

    /**
     * Checks whether a .yarnrc.yml file exists at the project root
     * (in multi-module builds, it will be the Reactor project)
     *
     * @param session
     *        the current maven session
     * @param workingDirectory
     *        the configured working directory
     *
     * @return true if the .yarnrc.yml file exists, false otherwise
     */
    public static boolean isYarnrcYamlFilePresent(MavenSession session, File workingDirectory) {
        Stream<File> filesToCheck = Stream.of(
                new File(session.getCurrentProject().getBasedir(), YARNRC_YAML_FILE_NAME),
                new File(session.getRequest().getMultiModuleProjectDirectory(), YARNRC_YAML_FILE_NAME),
                new File(session.getExecutionRootDirectory(), YARNRC_YAML_FILE_NAME),
                new File(workingDirectory, YARNRC_YAML_FILE_NAME)
        );

        return filesToCheck
                .anyMatch(File::exists);
    }
}
","package com.github.eirslett.maven.plugins.frontend.mojo; public class YarnUtils { private static final String YARNRC_YAML_FILE_NAME = "".yarnrc.yml""; public static boolean isYarnrcYamlFilePresent(MavenSession session, File workingDirectory) { Stream<File> filesToCheck = Stream.of(
                new File(session.getCurrentProject().getBasedir(), YARNRC_YAML_FILE_NAME),
                new File(session.getRequest().getMultiModuleProjectDirectory(), YARNRC_YAML_FILE_NAME),
                new File(session.getExecutionRootDirectory(), YARNRC_YAML_FILE_NAME),
                new File(workingDirectory, YARNRC_YAML_FILE_NAME)
        ); return filesToCheck
                .anyMatch(File::exists); } }",0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.mojo; public class YarnUtils { private static final String YARNRC_YAML_FILE_NAME = "".yarnrc.yml""; public static boolean isYarnrcYamlFilePresent(MavenSession session, File workingDirectory) { Stream<File> filesToCheck = Stream.of(
                new File(session.getCurrentProject().getBasedir(), YARNRC_YAML_FILE_NAME),
                new File(session.getRequest().getMultiModuleProjectDirectory(), YARNRC_YAML_FILE_NAME),
                new File(session.getExecutionRootDirectory(), YARNRC_YAML_FILE_NAME),
                new File(workingDirectory, YARNRC_YAML_FILE_NAME)
        ); return filesToCheck
                .anyMatch(File::exists); } } ","package com.github.eirslett.maven.plugins.frontend.mojo; 
import java.io.File; import java.util.stream.Stream; 
import org.apache.maven.execution.MavenSession;  public class YarnUtils {  private static final String YARNRC_YAML_FILE_NAME = "".yarnrc.yml"";  /**
     * Checks whether a .yarnrc.yml file exists at the project root
     * (in multi-module builds, it will be the Reactor project)
     *
     * @param session
     *        the current maven session
     * @param workingDirectory
     *        the configured working directory
     *
     * @return true if the .yarnrc.yml file exists, false otherwise
     */ public static boolean isYarnrcYamlFilePresent(MavenSession session, File workingDirectory) { Stream<File> filesToCheck = Stream.of(
                new File(session.getCurrentProject().getBasedir(), YARNRC_YAML_FILE_NAME),
                new File(session.getRequest().getMultiModuleProjectDirectory(), YARNRC_YAML_FILE_NAME),
                new File(session.getExecutionRootDirectory(), YARNRC_YAML_FILE_NAME),
                new File(workingDirectory, YARNRC_YAML_FILE_NAME)
        );  return filesToCheck
                .anyMatch(File::exists); } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/ArchiveExtractor.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.AccessDeniedException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Enumeration;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import org.apache.commons.io.IOUtils;
import org.codehaus.plexus.util.FileUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

class ArchiveExtractionException extends Exception {

    ArchiveExtractionException(String message) {
        super(message);
    }

    ArchiveExtractionException(String message, Throwable cause) {
        super(message, cause);
    }
}

interface ArchiveExtractor {
    public void extract(String archive, String destinationDirectory) throws ArchiveExtractionException;
}

final class DefaultArchiveExtractor implements ArchiveExtractor {

    private static final Logger LOG = LoggerFactory.getLogger(DefaultArchiveExtractor.class);

    private void prepDestination(File path, boolean directory) throws IOException {
        if (directory) {
            path.mkdirs();
        } else {
            if (!path.getParentFile().exists()) {
                path.getParentFile().mkdirs();
            }
            if (!path.getParentFile().canWrite()) {
                throw new AccessDeniedException(
                        String.format(""Could not get write permissions for '%s'"", path.getParentFile().getAbsolutePath()));
            }
        }
    }

    @Override
    public void extract(String archive, String destinationDirectory) throws ArchiveExtractionException {
        final File archiveFile = new File(archive);

        try (FileInputStream fis = new FileInputStream(archiveFile)) {
            if (""msi"".equals(FileUtils.getExtension(archiveFile.getAbsolutePath()))) {
                String command = ""msiexec /a "" + archiveFile.getAbsolutePath() + "" /qn TARGETDIR=\""""
                        + destinationDirectory + ""\"""";
                Process child = Runtime.getRuntime().exec(command);
                try {
                    int result = child.waitFor();
                    if (result != 0) {
                        throw new ArchiveExtractionException(
                                ""Could not extract "" + archiveFile.getAbsolutePath() + ""; return code "" + result);
                    }
                } catch (InterruptedException e) {
                    throw new ArchiveExtractionException(
                            ""Unexpected interruption of while waiting for extraction process"", e);
                }
            } else if (""zip"".equals(FileUtils.getExtension(archiveFile.getAbsolutePath()))) {
                Path destinationPath = Paths.get(destinationDirectory).normalize();
                try (ZipFile zipFile = new ZipFile(archiveFile)) {
                    Enumeration<? extends ZipEntry> entries = zipFile.entries();
                    while (entries.hasMoreElements()) {
                        ZipEntry entry = entries.nextElement();
                        final Path destPath = destinationPath.resolve(entry.getName()).normalize();
                        if (!destPath.startsWith(destinationPath)) {
                            throw new RuntimeException(""Bad zip entry"");
                        }
                        prepDestination(destPath.toFile(), entry.isDirectory());
                        if (!entry.isDirectory()) {
                            InputStream in = null;
                            OutputStream out = null;
                            try {
                                in = zipFile.getInputStream(entry);
                                out = new BufferedOutputStream(Files.newOutputStream(destPath));
                                IOUtils.copy(in, out);
                            } finally {
                                IOUtils.closeQuietly(in);
                                IOUtils.closeQuietly(out);
                            }
                        }
                    }
                }
            } else {
                // TarArchiveInputStream can be constructed with a normal FileInputStream if
                // we ever need to extract regular '.tar' files.
                TarArchiveInputStream tarIn = null;
                try {
                    tarIn = new TarArchiveInputStream(new GzipCompressorInputStream(fis));

                    TarArchiveEntry tarEntry = tarIn.getNextTarEntry();
                    String canonicalDestinationDirectory = new File(destinationDirectory).getCanonicalPath();
                    while (tarEntry != null) {
                        // Create a file for this tarEntry
                        final File destPath = new File(destinationDirectory, tarEntry.getName());
                        prepDestination(destPath, tarEntry.isDirectory());

                        if (!startsWithPath(destPath.getCanonicalPath(), canonicalDestinationDirectory)) {
                            throw new IOException(
                                    ""Expanding "" + tarEntry.getName() + "" would create file outside of "" + canonicalDestinationDirectory
                            );
                        }

                        if (!tarEntry.isDirectory()) {
                            destPath.createNewFile();
                            boolean isExecutable = (tarEntry.getMode() & 0100) > 0;
                            destPath.setExecutable(isExecutable);

                            OutputStream out = null;
                            try {
                                out = new FileOutputStream(destPath);
                                IOUtils.copy(tarIn, out);
                            } finally {
                                IOUtils.closeQuietly(out);
                            }
                        }
                        tarEntry = tarIn.getNextTarEntry();
                    }
                } finally {
                    IOUtils.closeQuietly(tarIn);
                }
            }
        } catch (IOException e) {
            throw new ArchiveExtractionException(""Could not extract archive: '""
                    + archive
                    + ""'"", e);
        }
    }

    /**
     * Do multiple file system checks that should enable the plugin to work on any file system
     * whether or not it's case sensitive or not.
     *
     * @param destPath
     * @param destDir
     * @return
     */
    private boolean startsWithPath(String destPath, String destDir) {
        if (destPath.startsWith(destDir)) {
            return true;
        } else if (destDir.length() > destPath.length()) {
            return false;
        } else {
            if (new File(destPath).exists() && !(new File(destPath.toLowerCase()).exists())) {
                return false;
            }

            return destPath.toLowerCase().startsWith(destDir.toLowerCase());
        }
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; class ArchiveExtractionException extends Exception { ArchiveExtractionException(String message) { super(message); } ArchiveExtractionException(String message, Throwable cause) { super(message, cause); } } interface ArchiveExtractor { public void extract(String archive, String destinationDirectory) throws ArchiveExtractionException; } final class DefaultArchiveExtractor implements ArchiveExtractor { private static final Logger LOG = LoggerFactory.getLogger(DefaultArchiveExtractor.class); private void prepDestination(File path, boolean directory) throws IOException { if (directory) { path.mkdirs(); } else { if (!path.getParentFile().exists()) { path.getParentFile().mkdirs(); } if (!path.getParentFile().canWrite()) { throw new AccessDeniedException(
                        String.format(""Could not get write permissions for '%s'"", path.getParentFile().getAbsolutePath())); } } } @Override
    public void extract(String archive, String destinationDirectory) throws ArchiveExtractionException { final File archiveFile = new File(archive); try (FileInputStream fis = new FileInputStream(archiveFile)) { if (""msi"".equals(FileUtils.getExtension(archiveFile.getAbsolutePath()))) { String command = ""msiexec /a "" + archiveFile.getAbsolutePath() + "" /qn TARGETDIR=\""""
                        + destinationDirectory + ""\""""; Process child = Runtime.getRuntime().exec(command); try { int result = child.waitFor(); if (result != 0) { throw new ArchiveExtractionException(
                                ""Could not extract "" + archiveFile.getAbsolutePath() + ""; return code "" + result); } } catch (InterruptedException e) { throw new ArchiveExtractionException(
                            ""Unexpected interruption of while waiting for extraction process"", e); } } else if (""zip"".equals(FileUtils.getExtension(archiveFile.getAbsolutePath()))) { Path destinationPath = Paths.get(destinationDirectory).normalize(); try (ZipFile zipFile = new ZipFile(archiveFile)) { Enumeration<? extends ZipEntry> entries = zipFile.entries(); while (entries.hasMoreElements()) { ZipEntry entry = entries.nextElement(); final Path destPath = destinationPath.resolve(entry.getName()).normalize(); if (!destPath.startsWith(destinationPath)) { throw new RuntimeException(""Bad zip entry""); } prepDestination(destPath.toFile(), entry.isDirectory()); if (!entry.isDirectory()) { InputStream in = null; OutputStream out = null; try { in = zipFile.getInputStream(entry); out = new BufferedOutputStream(Files.newOutputStream(destPath)); IOUtils.copy(in, out); } finally { IOUtils.closeQuietly(in); IOUtils.closeQuietly(out); } } } } } else { TarArchiveInputStream tarIn = null; try { tarIn = new TarArchiveInputStream(new GzipCompressorInputStream(fis)); TarArchiveEntry tarEntry = tarIn.getNextTarEntry(); String canonicalDestinationDirectory = new File(destinationDirectory).getCanonicalPath(); while (tarEntry != null) { final File destPath = new File(destinationDirectory, tarEntry.getName()); prepDestination(destPath, tarEntry.isDirectory()); if (!startsWithPath(destPath.getCanonicalPath(), canonicalDestinationDirectory)) { throw new IOException(
                                    ""Expanding "" + tarEntry.getName() + "" would create file outside of "" + canonicalDestinationDirectory
                            ); } if (!tarEntry.isDirectory()) { destPath.createNewFile(); boolean isExecutable = (tarEntry.getMode() & 0100) > 0; destPath.setExecutable(isExecutable); OutputStream out = null; try { out = new FileOutputStream(destPath); IOUtils.copy(tarIn, out); } finally { IOUtils.closeQuietly(out); } } tarEntry = tarIn.getNextTarEntry(); } } finally { IOUtils.closeQuietly(tarIn); } } } catch (IOException e) { throw new ArchiveExtractionException(""Could not extract archive: '""
                    + archive
                    + ""'"", e); } } private boolean startsWithPath(String destPath, String destDir) { if (destPath.startsWith(destDir)) { return true; } else if (destDir.length() > destPath.length()) { return false; } else { if (new File(destPath).exists() && !(new File(destPath.toLowerCase()).exists())) { return false; } return destPath.toLowerCase().startsWith(destDir.toLowerCase()); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; class ArchiveExtractionException extends Exception { ArchiveExtractionException(String message) { super(message); } ArchiveExtractionException(String message, Throwable cause) { super(message, cause); } } interface ArchiveExtractor { public void extract(String archive, String destinationDirectory) throws ArchiveExtractionException; } final class DefaultArchiveExtractor implements ArchiveExtractor { private static final Logger LOG = LoggerFactory.getLogger(DefaultArchiveExtractor.class); private void prepDestination(File path, boolean directory) throws IOException { if (directory) { path.mkdirs(); } else { if (!path.getParentFile().exists()) { path.getParentFile().mkdirs(); } if (!path.getParentFile().canWrite()) { throw new AccessDeniedException(
                        String.format(""Could not get write permissions for '%s'"", path.getParentFile().getAbsolutePath())); } } } @Override
    public void extract(String archive, String destinationDirectory) throws ArchiveExtractionException { final File archiveFile = new File(archive); try (FileInputStream fis = new FileInputStream(archiveFile)) { if (""msi"".equals(FileUtils.getExtension(archiveFile.getAbsolutePath()))) { String command = ""msiexec /a "" + archiveFile.getAbsolutePath() + "" /qn TARGETDIR=\""""
                        + destinationDirectory + ""\""""; Process child = Runtime.getRuntime().exec(command); try { int result = child.waitFor(); if (result != 0) { throw new ArchiveExtractionException(
                                ""Could not extract "" + archiveFile.getAbsolutePath() + ""; return code "" + result); } } catch (InterruptedException e) { throw new ArchiveExtractionException(
                            ""Unexpected interruption of while waiting for extraction process"", e); } } else if (""zip"".equals(FileUtils.getExtension(archiveFile.getAbsolutePath()))) { Path destinationPath = Paths.get(destinationDirectory).normalize(); try (ZipFile zipFile = new ZipFile(archiveFile)) { Enumeration<? extends ZipEntry> entries = zipFile.entries(); while (entries.hasMoreElements()) { ZipEntry entry = entries.nextElement(); final Path destPath = destinationPath.resolve(entry.getName()).normalize(); if (!destPath.startsWith(destinationPath)) { throw new RuntimeException(""Bad zip entry""); } prepDestination(destPath.toFile(), entry.isDirectory()); if (!entry.isDirectory()) { InputStream in = null; OutputStream out = null; try { in = zipFile.getInputStream(entry); out = new BufferedOutputStream(Files.newOutputStream(destPath)); IOUtils.copy(in, out); } finally { IOUtils.closeQuietly(in); IOUtils.closeQuietly(out); } } } } } else { TarArchiveInputStream tarIn = null; try { tarIn = new TarArchiveInputStream(new GzipCompressorInputStream(fis)); TarArchiveEntry tarEntry = tarIn.getNextTarEntry(); String canonicalDestinationDirectory = new File(destinationDirectory).getCanonicalPath(); while (tarEntry != null) { final File destPath = new File(destinationDirectory, tarEntry.getName()); prepDestination(destPath, tarEntry.isDirectory()); if (!startsWithPath(destPath.getCanonicalPath(), canonicalDestinationDirectory)) { throw new IOException(
                                    ""Expanding "" + tarEntry.getName() + "" would create file outside of "" + canonicalDestinationDirectory
                            ); } if (!tarEntry.isDirectory()) { destPath.createNewFile(); boolean isExecutable = (tarEntry.getMode() & 0100) > 0; destPath.setExecutable(isExecutable); OutputStream out = null; try { out = new FileOutputStream(destPath); IOUtils.copy(tarIn, out); } finally { IOUtils.closeQuietly(out); } } tarEntry = tarIn.getNextTarEntry(); } } finally { IOUtils.closeQuietly(tarIn); } } } catch (IOException e) { throw new ArchiveExtractionException(""Could not extract archive: '""
                    + archive
                    + ""'"", e); } } private boolean startsWithPath(String destPath, String destDir) { if (destPath.startsWith(destDir)) { return true; } else if (destDir.length() > destPath.length()) { return false; } else { if (new File(destPath).exists() && !(new File(destPath.toLowerCase()).exists())) { return false; } return destPath.toLowerCase().startsWith(destDir.toLowerCase()); } } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import org.apache.commons.compress.archivers.tar.TarArchiveEntry; import org.apache.commons.compress.archivers.tar.TarArchiveInputStream; import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream; 
import java.io.BufferedOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.nio.file.AccessDeniedException; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.util.Enumeration; import java.util.zip.ZipEntry; import java.util.zip.ZipFile; 
import org.apache.commons.io.IOUtils; import org.codehaus.plexus.util.FileUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  class ArchiveExtractionException extends Exception {  ArchiveExtractionException(String message) { super(message); }  ArchiveExtractionException(String message, Throwable cause) { super(message, cause); } }  interface ArchiveExtractor { public void extract(String archive, String destinationDirectory) throws ArchiveExtractionException; }  final class DefaultArchiveExtractor implements ArchiveExtractor {  private static final Logger LOG = LoggerFactory.getLogger(DefaultArchiveExtractor.class);  private void prepDestination(File path, boolean directory) throws IOException { if (directory) { path.mkdirs(); } else { if (!path.getParentFile().exists()) { path.getParentFile().mkdirs(); } if (!path.getParentFile().canWrite()) { throw new AccessDeniedException(
                        String.format(""Could not get write permissions for '%s'"", path.getParentFile().getAbsolutePath())); } } }  @Override
    public void extract(String archive, String destinationDirectory) throws ArchiveExtractionException { final File archiveFile = new File(archive);  try (FileInputStream fis = new FileInputStream(archiveFile)) { if (""msi"".equals(FileUtils.getExtension(archiveFile.getAbsolutePath()))) { String command = ""msiexec /a "" + archiveFile.getAbsolutePath() + "" /qn TARGETDIR=\""""
                        + destinationDirectory + ""\""""; Process child = Runtime.getRuntime().exec(command); try { int result = child.waitFor(); if (result != 0) { throw new ArchiveExtractionException(
                                ""Could not extract "" + archiveFile.getAbsolutePath() + ""; return code "" + result); } } catch (InterruptedException e) { throw new ArchiveExtractionException(
                            ""Unexpected interruption of while waiting for extraction process"", e); } } else if (""zip"".equals(FileUtils.getExtension(archiveFile.getAbsolutePath()))) { Path destinationPath = Paths.get(destinationDirectory).normalize(); try (ZipFile zipFile = new ZipFile(archiveFile)) { Enumeration<? extends ZipEntry> entries = zipFile.entries(); while (entries.hasMoreElements()) { ZipEntry entry = entries.nextElement(); final Path destPath = destinationPath.resolve(entry.getName()).normalize(); if (!destPath.startsWith(destinationPath)) { throw new RuntimeException(""Bad zip entry""); } prepDestination(destPath.toFile(), entry.isDirectory()); if (!entry.isDirectory()) { InputStream in = null; OutputStream out = null; try { in = zipFile.getInputStream(entry); out = new BufferedOutputStream(Files.newOutputStream(destPath)); IOUtils.copy(in, out); } finally { IOUtils.closeQuietly(in); IOUtils.closeQuietly(out); } } } } } else { // TarArchiveInputStream can be constructed with a normal FileInputStream if // we ever need to extract regular '.tar' files. TarArchiveInputStream tarIn = null; try { tarIn = new TarArchiveInputStream(new GzipCompressorInputStream(fis));  TarArchiveEntry tarEntry = tarIn.getNextTarEntry(); String canonicalDestinationDirectory = new File(destinationDirectory).getCanonicalPath(); while (tarEntry != null) { // Create a file for this tarEntry final File destPath = new File(destinationDirectory, tarEntry.getName()); prepDestination(destPath, tarEntry.isDirectory());  if (!startsWithPath(destPath.getCanonicalPath(), canonicalDestinationDirectory)) { throw new IOException(
                                    ""Expanding "" + tarEntry.getName() + "" would create file outside of "" + canonicalDestinationDirectory
                            ); }  if (!tarEntry.isDirectory()) { destPath.createNewFile(); boolean isExecutable = (tarEntry.getMode() & 0100) > 0; destPath.setExecutable(isExecutable);  OutputStream out = null; try { out = new FileOutputStream(destPath); IOUtils.copy(tarIn, out); } finally { IOUtils.closeQuietly(out); } } tarEntry = tarIn.getNextTarEntry(); } } finally { IOUtils.closeQuietly(tarIn); } } } catch (IOException e) { throw new ArchiveExtractionException(""Could not extract archive: '""
                    + archive
                    + ""'"", e); } }  /**
     * Do multiple file system checks that should enable the plugin to work on any file system
     * whether or not it's case sensitive or not.
     *
     * @param destPath
     * @param destDir
     * @return
     */ private boolean startsWithPath(String destPath, String destDir) { if (destPath.startsWith(destDir)) { return true; } else if (destDir.length() > destPath.length()) { return false; } else { if (new File(destPath).exists() && !(new File(destPath.toLowerCase()).exists())) { return false; }  return destPath.toLowerCase().startsWith(destDir.toLowerCase()); } } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/ArgumentsParser.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

class ArgumentsParser {

    private final List<String> additionalArguments;

    ArgumentsParser() {
        this(Collections.<String>emptyList());
    }

    ArgumentsParser(List<String> additionalArguments) {
        this.additionalArguments = additionalArguments;
    }

    /**
     * Parses a given string of arguments, splitting it by characters that are whitespaces according to {@link Character#isWhitespace(char)}.
     * <p>
     * This method respects quoted arguments. Meaning that whitespaces appearing phrases that are enclosed by an opening
     * single or double quote and a closing single or double quote or the end of the string will not be considered.
     * <p>
     * All characters excluding whitespaces considered for splitting stay in place.
     * <p>
     * Examples:
     * ""foo bar"" will be split to [""foo"", ""bar""]
     * ""foo \""bar foobar\"""" will be split to [""foo"", ""\""bar foobar\""""]
     * ""foo 'bar"" will be split to [""foo"", ""'bar""]
     *
     * @param args a string of arguments
     * @return an mutable copy of the list of all arguments
     */
    List<String> parse(String args) {
        if (args == null || ""null"".equals(args) || args.isEmpty()) {
            return Collections.emptyList();
        }

        final List<String> arguments = new LinkedList<>();
        final StringBuilder argumentBuilder = new StringBuilder();
        Character quote = null;

        for (int i = 0, l = args.length(); i < l; i++) {
            char c = args.charAt(i);

            if (Character.isWhitespace(c) && quote == null) {
                addArgument(argumentBuilder, arguments);
                continue;
            } else if (c == '""' || c == '\'') {
                // explicit boxing allows us to use object caching of the Character class
                Character currentQuote = Character.valueOf(c);
                if (quote == null) {
                    quote = currentQuote;
                } else if (quote.equals(currentQuote)){
                    quote = null;
                } // else
                // we ignore the case when a quoted argument contains the other kind of quote
            }

            argumentBuilder.append(c);
        }

        addArgument(argumentBuilder, arguments);

        for (String argument : this.additionalArguments) {
            if (!arguments.contains(argument)) {
                arguments.add(argument);
            }
        }

        return new ArrayList<>(arguments);
    }

    private static void addArgument(StringBuilder argumentBuilder, List<String> arguments) {
        if (argumentBuilder.length() > 0) {
            String argument = argumentBuilder.toString();
            arguments.add(argument);
            argumentBuilder.setLength(0);
        }
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; class ArgumentsParser { private final List<String> additionalArguments; ArgumentsParser() { this(Collections.<String>emptyList()); } ArgumentsParser(List<String> additionalArguments) { this.additionalArguments = additionalArguments; } List<String> parse(String args) { if (args == null || ""null"".equals(args) || args.isEmpty()) { return Collections.emptyList(); } final List<String> arguments = new LinkedList<>(); final StringBuilder argumentBuilder = new StringBuilder(); Character quote = null; for (int i = 0, l = args.length(); i < l; i++) { char c = args.charAt(i); if (Character.isWhitespace(c) && quote == null) { addArgument(argumentBuilder, arguments); continue; } else if (c == '""' || c == '\'') { Character currentQuote = Character.valueOf(c); if (quote == null) { quote = currentQuote; } else if (quote.equals(currentQuote)){ quote = null; } } argumentBuilder.append(c); } addArgument(argumentBuilder, arguments); for (String argument : this.additionalArguments) { if (!arguments.contains(argument)) { arguments.add(argument); } } return new ArrayList<>(arguments); } private static void addArgument(StringBuilder argumentBuilder, List<String> arguments) { if (argumentBuilder.length() > 0) { String argument = argumentBuilder.toString(); arguments.add(argument); argumentBuilder.setLength(0); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; class ArgumentsParser { private final List<String> additionalArguments; ArgumentsParser() { this(Collections.<String>emptyList()); } ArgumentsParser(List<String> additionalArguments) { this.additionalArguments = additionalArguments; } List<String> parse(String args) { if (args == null || ""null"".equals(args) || args.isEmpty()) { return Collections.emptyList(); } final List<String> arguments = new LinkedList<>(); final StringBuilder argumentBuilder = new StringBuilder(); Character quote = null; for (int i = 0, l = args.length(); i < l; i++) { char c = args.charAt(i); if (Character.isWhitespace(c) && quote == null) { addArgument(argumentBuilder, arguments); continue; } else if (c == '""' || c == '\'') { Character currentQuote = Character.valueOf(c); if (quote == null) { quote = currentQuote; } else if (quote.equals(currentQuote)){ quote = null; } } argumentBuilder.append(c); } addArgument(argumentBuilder, arguments); for (String argument : this.additionalArguments) { if (!arguments.contains(argument)) { arguments.add(argument); } } return new ArrayList<>(arguments); } private static void addArgument(StringBuilder argumentBuilder, List<String> arguments) { if (argumentBuilder.length() > 0) { String argument = argumentBuilder.toString(); arguments.add(argument); argumentBuilder.setLength(0); } } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import java.util.ArrayList; import java.util.Collections; import java.util.LinkedList; import java.util.List;  class ArgumentsParser {  private final List<String> additionalArguments;  ArgumentsParser() { this(Collections.<String>emptyList()); }  ArgumentsParser(List<String> additionalArguments) { this.additionalArguments = additionalArguments; }  /**
     * Parses a given string of arguments, splitting it by characters that are whitespaces according to {@link Character#isWhitespace(char)}.
     * <p>
     * This method respects quoted arguments. Meaning that whitespaces appearing phrases that are enclosed by an opening
     * single or double quote and a closing single or double quote or the end of the string will not be considered.
     * <p>
     * All characters excluding whitespaces considered for splitting stay in place.
     * <p>
     * Examples:
     * ""foo bar"" will be split to [""foo"", ""bar""]
     * ""foo \""bar foobar\"""" will be split to [""foo"", ""\""bar foobar\""""]
     * ""foo 'bar"" will be split to [""foo"", ""'bar""]
     *
     * @param args a string of arguments
     * @return an mutable copy of the list of all arguments
     */ List<String> parse(String args) { if (args == null || ""null"".equals(args) || args.isEmpty()) { return Collections.emptyList(); }  final List<String> arguments = new LinkedList<>(); final StringBuilder argumentBuilder = new StringBuilder(); Character quote = null;  for (int i = 0, l = args.length(); i < l; i++) { char c = args.charAt(i);  if (Character.isWhitespace(c) && quote == null) { addArgument(argumentBuilder, arguments); continue; } else if (c == '""' || c == '\'') { // explicit boxing allows us to use object caching of the Character class Character currentQuote = Character.valueOf(c); if (quote == null) { quote = currentQuote; } else if (quote.equals(currentQuote)){ quote = null; } // else // we ignore the case when a quoted argument contains the other kind of quote }  argumentBuilder.append(c); }  addArgument(argumentBuilder, arguments);  for (String argument : this.additionalArguments) { if (!arguments.contains(argument)) { arguments.add(argument); } }  return new ArrayList<>(arguments); }  private static void addArgument(StringBuilder argumentBuilder, List<String> arguments) { if (argumentBuilder.length() > 0) { String argument = argumentBuilder.toString(); arguments.add(argument); argumentBuilder.setLength(0); } } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/BowerRunner.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import java.util.ArrayList;
import java.util.List;

public interface BowerRunner extends NodeTaskRunner {}

final class DefaultBowerRunner extends NodeTaskExecutor implements BowerRunner {

    private static final String TASK_LOCATION = ""node_modules/bower/bin/bower"";

    DefaultBowerRunner(NodeExecutorConfig config, ProxyConfig proxyConfig) {
        super(config, TASK_LOCATION, buildArguments(proxyConfig));
    }

    private static List<String> buildArguments(ProxyConfig proxyConfig) {
        List<String> arguments = new ArrayList<String>();

        if (!proxyConfig.isEmpty()) {
            ProxyConfig.Proxy secureProxy = proxyConfig.getSecureProxy();
            if (secureProxy != null){
                arguments.add(""--config.https-proxy="" + secureProxy.getUri().toString());
            }

            ProxyConfig.Proxy insecureProxy = proxyConfig.getInsecureProxy();
            if (insecureProxy != null) {
                arguments.add(""--config.proxy="" + insecureProxy.getUri().toString());
            }
        }
        return arguments;
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public interface BowerRunner extends NodeTaskRunner { } final class DefaultBowerRunner extends NodeTaskExecutor implements BowerRunner { private static final String TASK_LOCATION = ""node_modules/bower/bin/bower""; DefaultBowerRunner(NodeExecutorConfig config, ProxyConfig proxyConfig) { super(config, TASK_LOCATION, buildArguments(proxyConfig)); } private static List<String> buildArguments(ProxyConfig proxyConfig) { List<String> arguments = new ArrayList<String>(); if (!proxyConfig.isEmpty()) { ProxyConfig.Proxy secureProxy = proxyConfig.getSecureProxy(); if (secureProxy != null){ arguments.add(""--config.https-proxy="" + secureProxy.getUri().toString()); } ProxyConfig.Proxy insecureProxy = proxyConfig.getInsecureProxy(); if (insecureProxy != null) { arguments.add(""--config.proxy="" + insecureProxy.getUri().toString()); } } return arguments; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public interface BowerRunner extends NodeTaskRunner { } final class DefaultBowerRunner extends NodeTaskExecutor implements BowerRunner { private static final String TASK_LOCATION = ""node_modules/bower/bin/bower""; DefaultBowerRunner(NodeExecutorConfig config, ProxyConfig proxyConfig) { super(config, TASK_LOCATION, buildArguments(proxyConfig)); } private static List<String> buildArguments(ProxyConfig proxyConfig) { List<String> arguments = new ArrayList<String>(); if (!proxyConfig.isEmpty()) { ProxyConfig.Proxy secureProxy = proxyConfig.getSecureProxy(); if (secureProxy != null){ arguments.add(""--config.https-proxy="" + secureProxy.getUri().toString()); } ProxyConfig.Proxy insecureProxy = proxyConfig.getInsecureProxy(); if (insecureProxy != null) { arguments.add(""--config.proxy="" + insecureProxy.getUri().toString()); } } return arguments; } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import java.util.ArrayList; import java.util.List;  public interface BowerRunner extends NodeTaskRunner { }  final class DefaultBowerRunner extends NodeTaskExecutor implements BowerRunner {  private static final String TASK_LOCATION = ""node_modules/bower/bin/bower"";  DefaultBowerRunner(NodeExecutorConfig config, ProxyConfig proxyConfig) { super(config, TASK_LOCATION, buildArguments(proxyConfig)); }  private static List<String> buildArguments(ProxyConfig proxyConfig) { List<String> arguments = new ArrayList<String>();  if (!proxyConfig.isEmpty()) { ProxyConfig.Proxy secureProxy = proxyConfig.getSecureProxy(); if (secureProxy != null){ arguments.add(""--config.https-proxy="" + secureProxy.getUri().toString()); }  ProxyConfig.Proxy insecureProxy = proxyConfig.getInsecureProxy(); if (insecureProxy != null) { arguments.add(""--config.proxy="" + insecureProxy.getUri().toString()); } } return arguments; } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/BunExecutor.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import org.slf4j.Logger;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

final class BunExecutor {
    private final ProcessExecutor executor;

    public BunExecutor(BunExecutorConfig config, List<String> arguments, Map<String, String> additionalEnvironment) {
        final String bun = config.getBunPath().getAbsolutePath();
        List<String> localPaths = new ArrayList<String>();
        localPaths.add(config.getBunPath().getParent());
        this.executor = new ProcessExecutor(
                config.getWorkingDirectory(),
                localPaths,
                Utils.prepend(bun, arguments),
                config.getPlatform(),
                additionalEnvironment);
    }

    public String executeAndGetResult(final Logger logger) throws ProcessExecutionException {
        return executor.executeAndGetResult(logger);
    }

    public int executeAndRedirectOutput(final Logger logger) throws ProcessExecutionException {
        return executor.executeAndRedirectOutput(logger);
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; final class BunExecutor { private final ProcessExecutor executor; public BunExecutor(BunExecutorConfig config, List<String> arguments, Map<String, String> additionalEnvironment) { final String bun = config.getBunPath().getAbsolutePath(); List<String> localPaths = new ArrayList<String>(); localPaths.add(config.getBunPath().getParent()); this.executor = new ProcessExecutor(
                config.getWorkingDirectory(),
                localPaths,
                Utils.prepend(bun, arguments),
                config.getPlatform(),
                additionalEnvironment); } public String executeAndGetResult(final Logger logger) throws ProcessExecutionException { return executor.executeAndGetResult(logger); } public int executeAndRedirectOutput(final Logger logger) throws ProcessExecutionException { return executor.executeAndRedirectOutput(logger); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; final class BunExecutor { private final ProcessExecutor executor; public BunExecutor(BunExecutorConfig config, List<String> arguments, Map<String, String> additionalEnvironment) { final String bun = config.getBunPath().getAbsolutePath(); List<String> localPaths = new ArrayList<String>(); localPaths.add(config.getBunPath().getParent()); this.executor = new ProcessExecutor(
                config.getWorkingDirectory(),
                localPaths,
                Utils.prepend(bun, arguments),
                config.getPlatform(),
                additionalEnvironment); } public String executeAndGetResult(final Logger logger) throws ProcessExecutionException { return executor.executeAndGetResult(logger); } public int executeAndRedirectOutput(final Logger logger) throws ProcessExecutionException { return executor.executeAndRedirectOutput(logger); } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import org.slf4j.Logger; 
import java.util.ArrayList; import java.util.List; import java.util.Map;  final class BunExecutor { private final ProcessExecutor executor;  public BunExecutor(BunExecutorConfig config, List<String> arguments, Map<String, String> additionalEnvironment) { final String bun = config.getBunPath().getAbsolutePath(); List<String> localPaths = new ArrayList<String>(); localPaths.add(config.getBunPath().getParent()); this.executor = new ProcessExecutor(
                config.getWorkingDirectory(),
                localPaths,
                Utils.prepend(bun, arguments),
                config.getPlatform(),
                additionalEnvironment); }  public String executeAndGetResult(final Logger logger) throws ProcessExecutionException { return executor.executeAndGetResult(logger); }  public int executeAndRedirectOutput(final Logger logger) throws ProcessExecutionException { return executor.executeAndRedirectOutput(logger); } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/BunExecutorConfig.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import java.io.File;

public interface BunExecutorConfig {

    File getNodePath();

    File getBunPath();

    File getWorkingDirectory();

    Platform getPlatform();
}

final class InstallBunExecutorConfig implements BunExecutorConfig {

    public static final String BUN_WINDOWS = BunInstaller.INSTALL_PATH.replaceAll(""/"", ""\\\\"") + ""\\bun.exe"";
    public static final String BUN_DEFAULT = BunInstaller.INSTALL_PATH + ""/bun"";

    private File nodePath;

    private final InstallConfig installConfig;

    public InstallBunExecutorConfig(InstallConfig installConfig) {
        this.installConfig = installConfig;
        nodePath = new InstallNodeExecutorConfig(installConfig).getNodePath();
    }

    @Override
    public File getNodePath() {
        return nodePath;
    }

    @Override
    public File getBunPath() {
        String bunExecutable = getPlatform().isWindows() ? BUN_WINDOWS : BUN_DEFAULT;
        return new File(installConfig.getInstallDirectory() + bunExecutable);
    }

    @Override
    public File getWorkingDirectory() {
        return installConfig.getWorkingDirectory();
    }

    @Override
    public Platform getPlatform() {
        return installConfig.getPlatform();
    }
}","package com.github.eirslett.maven.plugins.frontend.lib; public interface BunExecutorConfig { File getNodePath(); File getBunPath(); File getWorkingDirectory(); Platform getPlatform(); } final class InstallBunExecutorConfig implements BunExecutorConfig { public static final String BUN_WINDOWS = BunInstaller.INSTALL_PATH.replaceAll(""/"", ""\\\\"") + ""\\bun.exe""; public static final String BUN_DEFAULT = BunInstaller.INSTALL_PATH + ""/bun""; private File nodePath; private final InstallConfig installConfig; public InstallBunExecutorConfig(InstallConfig installConfig) { this.installConfig = installConfig; nodePath = new InstallNodeExecutorConfig(installConfig).getNodePath(); } @Override
    public File getNodePath() { return nodePath; } @Override
    public File getBunPath() { String bunExecutable = getPlatform().isWindows() ? BUN_WINDOWS : BUN_DEFAULT; return new File(installConfig.getInstallDirectory() + bunExecutable); } @Override
    public File getWorkingDirectory() { return installConfig.getWorkingDirectory(); } @Override
    public Platform getPlatform() { return installConfig.getPlatform(); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public interface BunExecutorConfig { File getNodePath(); File getBunPath(); File getWorkingDirectory(); Platform getPlatform(); } final class InstallBunExecutorConfig implements BunExecutorConfig { public static final String BUN_WINDOWS = BunInstaller.INSTALL_PATH.replaceAll(""/"", ""\\\\"") + ""\\bun.exe""; public static final String BUN_DEFAULT = BunInstaller.INSTALL_PATH + ""/bun""; private File nodePath; private final InstallConfig installConfig; public InstallBunExecutorConfig(InstallConfig installConfig) { this.installConfig = installConfig; nodePath = new InstallNodeExecutorConfig(installConfig).getNodePath(); } @Override
    public File getNodePath() { return nodePath; } @Override
    public File getBunPath() { String bunExecutable = getPlatform().isWindows() ? BUN_WINDOWS : BUN_DEFAULT; return new File(installConfig.getInstallDirectory() + bunExecutable); } @Override
    public File getWorkingDirectory() { return installConfig.getWorkingDirectory(); } @Override
    public Platform getPlatform() { return installConfig.getPlatform(); } }","package com.github.eirslett.maven.plugins.frontend.lib; 
import java.io.File;  public interface BunExecutorConfig {  File getNodePath();  File getBunPath();  File getWorkingDirectory();  Platform getPlatform(); }  final class InstallBunExecutorConfig implements BunExecutorConfig {  public static final String BUN_WINDOWS = BunInstaller.INSTALL_PATH.replaceAll(""/"", ""\\\\"") + ""\\bun.exe""; public static final String BUN_DEFAULT = BunInstaller.INSTALL_PATH + ""/bun"";  private File nodePath;  private final InstallConfig installConfig;  public InstallBunExecutorConfig(InstallConfig installConfig) { this.installConfig = installConfig; nodePath = new InstallNodeExecutorConfig(installConfig).getNodePath(); }  @Override
    public File getNodePath() { return nodePath; }  @Override
    public File getBunPath() { String bunExecutable = getPlatform().isWindows() ? BUN_WINDOWS : BUN_DEFAULT; return new File(installConfig.getInstallDirectory() + bunExecutable); }  @Override
    public File getWorkingDirectory() { return installConfig.getWorkingDirectory(); }  @Override
    public Platform getPlatform() { return installConfig.getPlatform(); } }"
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/BunInstaller.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import org.apache.commons.io.FileUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.EOFException;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.util.Arrays;
import java.util.Map;

public class BunInstaller {

    public static final String INSTALL_PATH = ""/bun"";

    public static final String DEFAULT_BUN_DOWNLOAD_ROOT =
            ""https://github.com/oven-sh/bun/releases/download/"";
    private static final Object LOCK = new Object();

    private String bunVersion, userName, password;

    private Map<String, String> httpHeaders;
    
    private final Logger logger;

    private final InstallConfig config;

    private final ArchiveExtractor archiveExtractor;

    private final FileDownloader fileDownloader;

    BunInstaller(InstallConfig config, ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) {
        this.logger = LoggerFactory.getLogger(getClass());
        this.config = config;
        this.archiveExtractor = archiveExtractor;
        this.fileDownloader = fileDownloader;
    }

    public BunInstaller setBunVersion(String bunVersion) {
        this.bunVersion = bunVersion;
        return this;
    }

    public BunInstaller setUserName(String userName) {
        this.userName = userName;
        return this;
    }

    public BunInstaller setPassword(String password) {
        this.password = password;
        return this;
    }

    public BunInstaller setHttpHeaders(Map<String, String> httpHeaders) {
        this.httpHeaders = httpHeaders;
        return this;
    }
    
    public void install() throws InstallationException {
        // use static lock object for a synchronized block
        synchronized (LOCK) {
            if (!bunIsAlreadyInstalled()) {
                if (!this.bunVersion.startsWith(""v"")) {
                    this.logger.warn(""Bun version does not start with naming convention 'v'."");
                }
                installBunDefault();
            }
        }
    }

    private boolean bunIsAlreadyInstalled() {
        try {
            BunExecutorConfig executorConfig = new InstallBunExecutorConfig(config);
            File bunFile = executorConfig.getBunPath();
            if (bunFile.exists()) {
                final String version =
                        new BunExecutor(executorConfig, Arrays.asList(""--version""), null).executeAndGetResult(logger);

                if (version.equals(this.bunVersion.replaceFirst(""^v"", """"))) {
                    this.logger.info(""Bun {} is already installed."", version);
                    return true;
                } else {
                    this.logger.info(""Bun {} was installed, but we need version {}"", version,
                            this.bunVersion);
                    return false;
                }
            } else {
                return false;
            }
        } catch (ProcessExecutionException e) {
            this.logger.warn(""Unable to determine current bun version: {}"", e.getMessage());
            return false;
        }
    }

    private void installBunDefault() throws InstallationException {
        try {

            logger.info(""Installing Bun version {}"", bunVersion);

            String downloadUrl = createDownloadUrl();

            CacheDescriptor cacheDescriptor = new CacheDescriptor(""bun"", this.bunVersion,
                    ""zip"");

            File archive = this.config.getCacheResolver().resolve(cacheDescriptor);

            downloadFileIfMissing(downloadUrl, archive, this.userName, this.password, this.httpHeaders);

            File installDirectory = getInstallDirectory();

            // We need to delete the existing bun directory first so we clean out any old files, and
            // so we can rename the package directory below.
            File bunExtractDirectory = new File(installDirectory, createBunTargetArchitecturePath());
            try {
                if (bunExtractDirectory.isDirectory()) {
                    FileUtils.deleteDirectory(bunExtractDirectory);
                }
            } catch (IOException e) {
                logger.warn(""Failed to delete existing Bun installation."");
            }

            try {
                extractFile(archive, installDirectory);
            } catch (ArchiveExtractionException e) {
                if (e.getCause() instanceof EOFException) {
                    this.logger.error(""The archive file {} is corrupted and will be deleted. ""
                            + ""Please try the build again."", archive.getPath());
                    archive.delete();
                }
                throw e;
            }

            // Search for the bun binary
            String bunExecutable = this.config.getPlatform().isWindows()  ? ""bun.exe"" : ""bun"";
            File bunBinary =
                    new File(installDirectory, File.separator + createBunTargetArchitecturePath() + File.separator + bunExecutable);
            if (!bunBinary.exists()) {
                throw new FileNotFoundException(
                        ""Could not find the downloaded bun binary in "" + bunBinary);
            } else {
                File destinationDirectory = new File(getInstallDirectory(), BunInstaller.INSTALL_PATH);
                if (!destinationDirectory.exists()) {
                    this.logger.info(""Creating destination directory {}"", destinationDirectory);
                    destinationDirectory.mkdirs();
                }

                File destination = new File(destinationDirectory, bunExecutable);
                this.logger.info(""Copying bun binary from {} to {}"", bunBinary, destination);
                if (destination.exists() && !destination.delete()) {
                    throw new InstallationException(""Could not install Bun: Was not allowed to delete "" + destination);
                }
                try {
                    Files.move(bunBinary.toPath(), destination.toPath(), StandardCopyOption.REPLACE_EXISTING);
                } catch (IOException e) {
                    throw new InstallationException(""Could not install Bun: Was not allowed to rename ""
                            + bunBinary + "" to "" + destination);
                }

                if (!destination.setExecutable(true, false)) {
                    throw new InstallationException(
                            ""Could not install Bun: Was not allowed to make "" + destination + "" executable."");
                }
                FileUtils.deleteDirectory(bunExtractDirectory);

                this.logger.info(""Installed bun locally."");
            }
        } catch (IOException e) {
            throw new InstallationException(""Could not install bun"", e);
        } catch (DownloadException e) {
            throw new InstallationException(""Could not download bun"", e);
        } catch (ArchiveExtractionException e) {
            throw new InstallationException(""Could not extract the bun archive"", e);
        }
    }

    private String createDownloadUrl() {
        String downloadUrl = String.format(""%sbun-%s"", DEFAULT_BUN_DOWNLOAD_ROOT, bunVersion);
        String extension = ""zip"";
        String fileending = String.format(""%s.%s"", createBunTargetArchitecturePath(), extension);

        downloadUrl += fileending;
        return downloadUrl;
    }

    private String createBunTargetArchitecturePath() {
        OS os = OS.guess();
        Architecture architecture = Architecture.guess();
        String destOs = os.equals(OS.Linux) ? ""linux"" : os.equals(OS.Mac) ? ""darwin"" : os.equals(OS.Windows) ? ""windows"" : null;
        String destArc = architecture.equals(Architecture.x64) ? ""x64"" : architecture.equals(
                Architecture.arm64) ? ""aarch64"" : null;
        return String.format(""%s-%s-%s"", INSTALL_PATH, destOs, destArc);
    }

    private File getInstallDirectory() {
        File installDirectory = new File(this.config.getInstallDirectory(), ""/"");
        if (!installDirectory.exists()) {
            this.logger.info(""Creating install directory {}"", installDirectory);
            installDirectory.mkdirs();
        }
        return installDirectory;
    }

    private void extractFile(File archive, File destinationDirectory) throws ArchiveExtractionException {
        this.logger.info(""Unpacking {} into {}"", archive, destinationDirectory);
        this.archiveExtractor.extract(archive.getPath(), destinationDirectory.getPath());
    }

    private void downloadFileIfMissing(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
            throws DownloadException {
        if (!destination.exists()) {
            downloadFile(downloadUrl, destination, userName, password, httpHeaders);
        }
    }

    private void downloadFile(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
            throws DownloadException {
        this.logger.info(""Downloading {} to {}"", downloadUrl, destination);
        this.fileDownloader.download(downloadUrl, destination.getPath(), userName, password, httpHeaders);
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public class BunInstaller { public static final String INSTALL_PATH = ""/bun""; private static final Object LOCK = new Object(); private String bunVersion, userName, password; private Map<String, String> httpHeaders; private final Logger logger; private final InstallConfig config; private final ArchiveExtractor archiveExtractor; private final FileDownloader fileDownloader; BunInstaller(InstallConfig config, ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) { this.logger = LoggerFactory.getLogger(getClass()); this.config = config; this.archiveExtractor = archiveExtractor; this.fileDownloader = fileDownloader; } public BunInstaller setBunVersion(String bunVersion) { this.bunVersion = bunVersion; return this; } public BunInstaller setUserName(String userName) { this.userName = userName; return this; } public BunInstaller setPassword(String password) { this.password = password; return this; } public BunInstaller setHttpHeaders(Map<String, String> httpHeaders) { this.httpHeaders = httpHeaders; return this; } public void install() throws InstallationException { synchronized (LOCK) { if (!bunIsAlreadyInstalled()) { if (!this.bunVersion.startsWith(""v"")) { } installBunDefault(); } } } private boolean bunIsAlreadyInstalled() { try { BunExecutorConfig executorConfig = new InstallBunExecutorConfig(config); File bunFile = executorConfig.getBunPath(); if (bunFile.exists()) { final String version =
                        new BunExecutor(executorConfig, Arrays.asList(""--version""), null).executeAndGetResult(logger); if (version.equals(this.bunVersion.replaceFirst(""^v"", """"))) { this.logger.info(""Bun { } is already installed."", version); return true; } else { this.logger.info(""Bun { } was installed, but we need version { } "", version,
                            this.bunVersion); return false; } } else { return false; } } catch (ProcessExecutionException e) { this.logger.warn(""Unable to determine current bun version: { } "", e.getMessage()); return false; } } private void installBunDefault() throws InstallationException { try { logger.info(""Installing Bun version { } "", bunVersion); String downloadUrl = createDownloadUrl(); CacheDescriptor cacheDescriptor = new CacheDescriptor(""bun"", this.bunVersion,
                    ""zip""); File archive = this.config.getCacheResolver().resolve(cacheDescriptor); downloadFileIfMissing(downloadUrl, archive, this.userName, this.password, this.httpHeaders); File installDirectory = getInstallDirectory(); File bunExtractDirectory = new File(installDirectory, createBunTargetArchitecturePath()); try { if (bunExtractDirectory.isDirectory()) { FileUtils.deleteDirectory(bunExtractDirectory); } } catch (IOException e) { } try { extractFile(archive, installDirectory); } catch (ArchiveExtractionException e) { if (e.getCause() instanceof EOFException) { this.logger.error(""The archive file { } is corrupted and will be deleted. ""
                            + ""Please try the build again."", archive.getPath()); archive.delete(); } throw e; } String bunExecutable = this.config.getPlatform().isWindows()  ? ""bun.exe"" : ""bun""; File bunBinary =
                    new File(installDirectory, File.separator + createBunTargetArchitecturePath() + File.separator + bunExecutable); if (!bunBinary.exists()) { throw new FileNotFoundException(
                        ""Could not find the downloaded bun binary in "" + bunBinary); } else { File destinationDirectory = new File(getInstallDirectory(), BunInstaller.INSTALL_PATH); if (!destinationDirectory.exists()) { this.logger.info(""Creating destination directory { } "", destinationDirectory); destinationDirectory.mkdirs(); } File destination = new File(destinationDirectory, bunExecutable); this.logger.info(""Copying bun binary from { } to { } "", bunBinary, destination); if (destination.exists() && !destination.delete()) { throw new InstallationException(""Could not install Bun: Was not allowed to delete "" + destination); } try { Files.move(bunBinary.toPath(), destination.toPath(), StandardCopyOption.REPLACE_EXISTING); } catch (IOException e) { throw new InstallationException(""Could not install Bun: Was not allowed to rename ""
                            + bunBinary + "" to "" + destination); } if (!destination.setExecutable(true, false)) { throw new InstallationException(
                            ""Could not install Bun: Was not allowed to make "" + destination + "" executable.""); } FileUtils.deleteDirectory(bunExtractDirectory); } } catch (IOException e) { throw new InstallationException(""Could not install bun"", e); } catch (DownloadException e) { throw new InstallationException(""Could not download bun"", e); } catch (ArchiveExtractionException e) { throw new InstallationException(""Could not extract the bun archive"", e); } } private String createDownloadUrl() { String downloadUrl = String.format(""%sbun-%s"", DEFAULT_BUN_DOWNLOAD_ROOT, bunVersion); String extension = ""zip""; String fileending = String.format(""%s.%s"", createBunTargetArchitecturePath(), extension); downloadUrl += fileending; return downloadUrl; } private String createBunTargetArchitecturePath() { OS os = OS.guess(); Architecture architecture = Architecture.guess(); String destOs = os.equals(OS.Linux) ? ""linux"" : os.equals(OS.Mac) ? ""darwin"" : os.equals(OS.Windows) ? ""windows"" : null; String destArc = architecture.equals(Architecture.x64) ? ""x64"" : architecture.equals(
                Architecture.arm64) ? ""aarch64"" : null; return String.format(""%s-%s-%s"", INSTALL_PATH, destOs, destArc); } private File getInstallDirectory() { File installDirectory = new File(this.config.getInstallDirectory(), ""/""); if (!installDirectory.exists()) { this.logger.info(""Creating install directory { } "", installDirectory); installDirectory.mkdirs(); } return installDirectory; } private void extractFile(File archive, File destinationDirectory) throws ArchiveExtractionException { this.logger.info(""Unpacking { } into { } "", archive, destinationDirectory); this.archiveExtractor.extract(archive.getPath(), destinationDirectory.getPath()); } private void downloadFileIfMissing(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
            throws DownloadException { if (!destination.exists()) { downloadFile(downloadUrl, destination, userName, password, httpHeaders); } } private void downloadFile(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
            throws DownloadException { this.logger.info(""Downloading { } to { } "", downloadUrl, destination); this.fileDownloader.download(downloadUrl, destination.getPath(), userName, password, httpHeaders); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public class BunInstaller { public static final String INSTALL_PATH = ""/bun""; private static final Object LOCK = new Object(); private String bunVersion, userName, password; private Map<String, String> httpHeaders; private final Logger logger; private final InstallConfig config; private final ArchiveExtractor archiveExtractor; private final FileDownloader fileDownloader; BunInstaller(InstallConfig config, ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) { this.logger = LoggerFactory.getLogger(getClass()); this.config = config; this.archiveExtractor = archiveExtractor; this.fileDownloader = fileDownloader; } public BunInstaller setBunVersion(String bunVersion) { this.bunVersion = bunVersion; return this; } public BunInstaller setUserName(String userName) { this.userName = userName; return this; } public BunInstaller setPassword(String password) { this.password = password; return this; } public BunInstaller setHttpHeaders(Map<String, String> httpHeaders) { this.httpHeaders = httpHeaders; return this; } public void install() throws InstallationException { synchronized (LOCK) { if (!bunIsAlreadyInstalled()) { if (!this.bunVersion.startsWith(""v"")) { <FILL_ME> } installBunDefault(); } } } private boolean bunIsAlreadyInstalled() { try { BunExecutorConfig executorConfig = new InstallBunExecutorConfig(config); File bunFile = executorConfig.getBunPath(); if (bunFile.exists()) { final String version =
                        new BunExecutor(executorConfig, Arrays.asList(""--version""), null).executeAndGetResult(logger); if (version.equals(this.bunVersion.replaceFirst(""^v"", """"))) { this.logger.info(""Bun { } is already installed."", version); return true; } else { this.logger.info(""Bun { } was installed, but we need version { } "", version,
                            this.bunVersion); return false; } } else { return false; } } catch (ProcessExecutionException e) { this.logger.warn(""Unable to determine current bun version: { } "", e.getMessage()); return false; } } private void installBunDefault() throws InstallationException { try { logger.info(""Installing Bun version { } "", bunVersion); String downloadUrl = createDownloadUrl(); CacheDescriptor cacheDescriptor = new CacheDescriptor(""bun"", this.bunVersion,
                    ""zip""); File archive = this.config.getCacheResolver().resolve(cacheDescriptor); downloadFileIfMissing(downloadUrl, archive, this.userName, this.password, this.httpHeaders); File installDirectory = getInstallDirectory(); File bunExtractDirectory = new File(installDirectory, createBunTargetArchitecturePath()); try { if (bunExtractDirectory.isDirectory()) { FileUtils.deleteDirectory(bunExtractDirectory); <FILL_ME> } } catch (IOException e) { <FILL_ME> } try { extractFile(archive, installDirectory); } catch (ArchiveExtractionException e) { if (e.getCause() instanceof EOFException) { this.logger.error(""The archive file { } is corrupted and will be deleted. ""
                            + ""Please try the build again."", archive.getPath()); archive.delete(); } throw e; } String bunExecutable = this.config.getPlatform().isWindows()  ? ""bun.exe"" : ""bun""; File bunBinary =
                    new File(installDirectory, File.separator + createBunTargetArchitecturePath() + File.separator + bunExecutable); if (!bunBinary.exists()) { throw new FileNotFoundException(
                        ""Could not find the downloaded bun binary in "" + bunBinary); } else { File destinationDirectory = new File(getInstallDirectory(), BunInstaller.INSTALL_PATH); if (!destinationDirectory.exists()) { this.logger.info(""Creating destination directory { } "", destinationDirectory); destinationDirectory.mkdirs(); } File destination = new File(destinationDirectory, bunExecutable); this.logger.info(""Copying bun binary from { } to { } "", bunBinary, destination); if (destination.exists() && !destination.delete()) { throw new InstallationException(""Could not install Bun: Was not allowed to delete "" + destination); } try { Files.move(bunBinary.toPath(), destination.toPath(), StandardCopyOption.REPLACE_EXISTING); } catch (IOException e) { throw new InstallationException(""Could not install Bun: Was not allowed to rename ""
                            + bunBinary + "" to "" + destination); } if (!destination.setExecutable(true, false)) { throw new InstallationException(
                            ""Could not install Bun: Was not allowed to make "" + destination + "" executable.""); } FileUtils.deleteDirectory(bunExtractDirectory); } } catch (IOException e) { throw new InstallationException(""Could not install bun"", e); } catch (DownloadException e) { throw new InstallationException(""Could not download bun"", e); } catch (ArchiveExtractionException e) { throw new InstallationException(""Could not extract the bun archive"", e); } } private String createDownloadUrl() { String downloadUrl = String.format(""%sbun-%s"", DEFAULT_BUN_DOWNLOAD_ROOT, bunVersion); String extension = ""zip""; String fileending = String.format(""%s.%s"", createBunTargetArchitecturePath(), extension); downloadUrl += fileending; return downloadUrl; } private String createBunTargetArchitecturePath() { OS os = OS.guess(); Architecture architecture = Architecture.guess(); String destOs = os.equals(OS.Linux) ? ""linux"" : os.equals(OS.Mac) ? ""darwin"" : os.equals(OS.Windows) ? ""windows"" : null; String destArc = architecture.equals(Architecture.x64) ? ""x64"" : architecture.equals(
                Architecture.arm64) ? ""aarch64"" : null; return String.format(""%s-%s-%s"", INSTALL_PATH, destOs, destArc); } private File getInstallDirectory() { File installDirectory = new File(this.config.getInstallDirectory(), ""/""); if (!installDirectory.exists()) { this.logger.info(""Creating install directory { } "", installDirectory); installDirectory.mkdirs(); } return installDirectory; } private void extractFile(File archive, File destinationDirectory) throws ArchiveExtractionException { this.logger.info(""Unpacking { } into { } "", archive, destinationDirectory); this.archiveExtractor.extract(archive.getPath(), destinationDirectory.getPath()); } private void downloadFileIfMissing(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
            throws DownloadException { if (!destination.exists()) { downloadFile(downloadUrl, destination, userName, password, httpHeaders); } } private void downloadFile(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
            throws DownloadException { this.logger.info(""Downloading { } to { } "", downloadUrl, destination); this.fileDownloader.download(downloadUrl, destination.getPath(), userName, password, httpHeaders); } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import org.apache.commons.io.FileUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory; 
import java.io.EOFException; import java.io.File; import java.io.FileNotFoundException; import java.io.IOException; import java.nio.file.Files; import java.nio.file.StandardCopyOption; import java.util.Arrays; import java.util.Map;  public class BunInstaller {  public static final String INSTALL_PATH = ""/bun"";  //github.com/oven-sh/bun/releases/download/""; private static final Object LOCK = new Object();  private String bunVersion, userName, password;  private Map<String, String> httpHeaders;      private final Logger logger;  private final InstallConfig config;  private final ArchiveExtractor archiveExtractor;  private final FileDownloader fileDownloader;  BunInstaller(InstallConfig config, ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) { this.logger = LoggerFactory.getLogger(getClass()); this.config = config; this.archiveExtractor = archiveExtractor; this.fileDownloader = fileDownloader; }  public BunInstaller setBunVersion(String bunVersion) { this.bunVersion = bunVersion; return this; }  public BunInstaller setUserName(String userName) { this.userName = userName; return this; }  public BunInstaller setPassword(String password) { this.password = password; return this; }  public BunInstaller setHttpHeaders(Map<String, String> httpHeaders) { this.httpHeaders = httpHeaders; return this; }      public void install() throws InstallationException { // use static lock object for a synchronized block synchronized (LOCK) { if (!bunIsAlreadyInstalled()) { if (!this.bunVersion.startsWith(""v"")) { <FILL_ME> } installBunDefault(); } } }  private boolean bunIsAlreadyInstalled() { try { BunExecutorConfig executorConfig = new InstallBunExecutorConfig(config); File bunFile = executorConfig.getBunPath(); if (bunFile.exists()) { final String version =
                        new BunExecutor(executorConfig, Arrays.asList(""--version""), null).executeAndGetResult(logger);  if (version.equals(this.bunVersion.replaceFirst(""^v"", """"))) { this.logger.info(""Bun { } is already installed."", version); return true; } else { this.logger.info(""Bun { } was installed, but we need version { } "", version,
                            this.bunVersion); return false; } } else { return false; } } catch (ProcessExecutionException e) { this.logger.warn(""Unable to determine current bun version: { } "", e.getMessage()); return false; } }  private void installBunDefault() throws InstallationException { try {  logger.info(""Installing Bun version { } "", bunVersion);  String downloadUrl = createDownloadUrl();  CacheDescriptor cacheDescriptor = new CacheDescriptor(""bun"", this.bunVersion,
                    ""zip"");  File archive = this.config.getCacheResolver().resolve(cacheDescriptor);  downloadFileIfMissing(downloadUrl, archive, this.userName, this.password, this.httpHeaders);  File installDirectory = getInstallDirectory();  // We need to delete the existing bun directory first so we clean out any old files, and // so we can rename the package directory below. File bunExtractDirectory = new File(installDirectory, createBunTargetArchitecturePath()); try { if (bunExtractDirectory.isDirectory()) { FileUtils.deleteDirectory(bunExtractDirectory); <FILL_ME> } } catch (IOException e) { <FILL_ME> }  try { extractFile(archive, installDirectory); } catch (ArchiveExtractionException e) { if (e.getCause() instanceof EOFException) { this.logger.error(""The archive file { } is corrupted and will be deleted. ""
                            + ""Please try the build again."", archive.getPath()); archive.delete(); } throw e; }  // Search for the bun binary String bunExecutable = this.config.getPlatform().isWindows()  ? ""bun.exe"" : ""bun""; File bunBinary =
                    new File(installDirectory, File.separator + createBunTargetArchitecturePath() + File.separator + bunExecutable); if (!bunBinary.exists()) { throw new FileNotFoundException(
                        ""Could not find the downloaded bun binary in "" + bunBinary); } else { File destinationDirectory = new File(getInstallDirectory(), BunInstaller.INSTALL_PATH); if (!destinationDirectory.exists()) { this.logger.info(""Creating destination directory { } "", destinationDirectory); destinationDirectory.mkdirs(); }  File destination = new File(destinationDirectory, bunExecutable); this.logger.info(""Copying bun binary from { } to { } "", bunBinary, destination); if (destination.exists() && !destination.delete()) { throw new InstallationException(""Could not install Bun: Was not allowed to delete "" + destination); } try { Files.move(bunBinary.toPath(), destination.toPath(), StandardCopyOption.REPLACE_EXISTING); } catch (IOException e) { throw new InstallationException(""Could not install Bun: Was not allowed to rename ""
                            + bunBinary + "" to "" + destination); }  if (!destination.setExecutable(true, false)) { throw new InstallationException(
                            ""Could not install Bun: Was not allowed to make "" + destination + "" executable.""); } FileUtils.deleteDirectory(bunExtractDirectory);  } } catch (IOException e) { throw new InstallationException(""Could not install bun"", e); } catch (DownloadException e) { throw new InstallationException(""Could not download bun"", e); } catch (ArchiveExtractionException e) { throw new InstallationException(""Could not extract the bun archive"", e); } }  private String createDownloadUrl() { String downloadUrl = String.format(""%sbun-%s"", DEFAULT_BUN_DOWNLOAD_ROOT, bunVersion); String extension = ""zip""; String fileending = String.format(""%s.%s"", createBunTargetArchitecturePath(), extension);  downloadUrl += fileending; return downloadUrl; }  private String createBunTargetArchitecturePath() { OS os = OS.guess(); Architecture architecture = Architecture.guess(); String destOs = os.equals(OS.Linux) ? ""linux"" : os.equals(OS.Mac) ? ""darwin"" : os.equals(OS.Windows) ? ""windows"" : null; String destArc = architecture.equals(Architecture.x64) ? ""x64"" : architecture.equals(
                Architecture.arm64) ? ""aarch64"" : null; return String.format(""%s-%s-%s"", INSTALL_PATH, destOs, destArc); }  private File getInstallDirectory() { File installDirectory = new File(this.config.getInstallDirectory(), ""/""); if (!installDirectory.exists()) { this.logger.info(""Creating install directory { } "", installDirectory); installDirectory.mkdirs(); } return installDirectory; }  private void extractFile(File archive, File destinationDirectory) throws ArchiveExtractionException { this.logger.info(""Unpacking { } into { } "", archive, destinationDirectory); this.archiveExtractor.extract(archive.getPath(), destinationDirectory.getPath()); }  private void downloadFileIfMissing(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
            throws DownloadException { if (!destination.exists()) { downloadFile(downloadUrl, destination, userName, password, httpHeaders); } }  private void downloadFile(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
            throws DownloadException { this.logger.info(""Downloading { } to { } "", downloadUrl, destination); this.fileDownloader.download(downloadUrl, destination.getPath(), userName, password, httpHeaders); } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/BunRunner.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig.Proxy;

import java.util.ArrayList;
import java.util.List;

public interface BunRunner extends NodeTaskRunner {
}

final class DefaultBunRunner extends BunTaskExecutor implements BunRunner {

    private static final String TASK_NAME = ""bun"";

    public DefaultBunRunner(BunExecutorConfig config, ProxyConfig proxyConfig, String npmRegistryURL) {
        super(config, TASK_NAME, config.getBunPath().getAbsolutePath(),
                buildArguments(proxyConfig, npmRegistryURL));
    }

    private static List<String> buildArguments(ProxyConfig proxyConfig, String npmRegistryURL) {
        List<String> arguments = new ArrayList<>();

        if (npmRegistryURL != null && !npmRegistryURL.isEmpty()) {
            arguments.add(""--registry="" + npmRegistryURL);
        }

        if (!proxyConfig.isEmpty()) {
            Proxy proxy = null;
            if (npmRegistryURL != null && !npmRegistryURL.isEmpty()) {
                proxy = proxyConfig.getProxyForUrl(npmRegistryURL);
            }

            if (proxy == null) {
                proxy = proxyConfig.getSecureProxy();
            }

            if (proxy == null) {
                proxy = proxyConfig.getInsecureProxy();
            }

            arguments.add(""--https-proxy="" + proxy.getUri().toString());
            arguments.add(""--proxy="" + proxy.getUri().toString());
        }

        return arguments;
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public interface BunRunner extends NodeTaskRunner { } final class DefaultBunRunner extends BunTaskExecutor implements BunRunner { private static final String TASK_NAME = ""bun""; public DefaultBunRunner(BunExecutorConfig config, ProxyConfig proxyConfig, String npmRegistryURL) { super(config, TASK_NAME, config.getBunPath().getAbsolutePath(),
                buildArguments(proxyConfig, npmRegistryURL)); } private static List<String> buildArguments(ProxyConfig proxyConfig, String npmRegistryURL) { List<String> arguments = new ArrayList<>(); if (npmRegistryURL != null && !npmRegistryURL.isEmpty()) { arguments.add(""--registry="" + npmRegistryURL); } if (!proxyConfig.isEmpty()) { Proxy proxy = null; if (npmRegistryURL != null && !npmRegistryURL.isEmpty()) { proxy = proxyConfig.getProxyForUrl(npmRegistryURL); } if (proxy == null) { proxy = proxyConfig.getSecureProxy(); } if (proxy == null) { proxy = proxyConfig.getInsecureProxy(); } arguments.add(""--https-proxy="" + proxy.getUri().toString()); arguments.add(""--proxy="" + proxy.getUri().toString()); } return arguments; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public interface BunRunner extends NodeTaskRunner { } final class DefaultBunRunner extends BunTaskExecutor implements BunRunner { private static final String TASK_NAME = ""bun""; public DefaultBunRunner(BunExecutorConfig config, ProxyConfig proxyConfig, String npmRegistryURL) { super(config, TASK_NAME, config.getBunPath().getAbsolutePath(),
                buildArguments(proxyConfig, npmRegistryURL)); } private static List<String> buildArguments(ProxyConfig proxyConfig, String npmRegistryURL) { List<String> arguments = new ArrayList<>(); if (npmRegistryURL != null && !npmRegistryURL.isEmpty()) { arguments.add(""--registry="" + npmRegistryURL); } if (!proxyConfig.isEmpty()) { Proxy proxy = null; if (npmRegistryURL != null && !npmRegistryURL.isEmpty()) { proxy = proxyConfig.getProxyForUrl(npmRegistryURL); } if (proxy == null) { proxy = proxyConfig.getSecureProxy(); } if (proxy == null) { proxy = proxyConfig.getInsecureProxy(); } arguments.add(""--https-proxy="" + proxy.getUri().toString()); arguments.add(""--proxy="" + proxy.getUri().toString()); } return arguments; } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig.Proxy; 
import java.util.ArrayList; import java.util.List;  public interface BunRunner extends NodeTaskRunner { }  final class DefaultBunRunner extends BunTaskExecutor implements BunRunner {  private static final String TASK_NAME = ""bun"";  public DefaultBunRunner(BunExecutorConfig config, ProxyConfig proxyConfig, String npmRegistryURL) { super(config, TASK_NAME, config.getBunPath().getAbsolutePath(),
                buildArguments(proxyConfig, npmRegistryURL)); }  private static List<String> buildArguments(ProxyConfig proxyConfig, String npmRegistryURL) { List<String> arguments = new ArrayList<>();  if (npmRegistryURL != null && !npmRegistryURL.isEmpty()) { arguments.add(""--registry="" + npmRegistryURL); }  if (!proxyConfig.isEmpty()) { Proxy proxy = null; if (npmRegistryURL != null && !npmRegistryURL.isEmpty()) { proxy = proxyConfig.getProxyForUrl(npmRegistryURL); }  if (proxy == null) { proxy = proxyConfig.getSecureProxy(); }  if (proxy == null) { proxy = proxyConfig.getInsecureProxy(); }  arguments.add(""--https-proxy="" + proxy.getUri().toString()); arguments.add(""--proxy="" + proxy.getUri().toString()); }  return arguments; } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/BunTaskExecutor.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import static com.github.eirslett.maven.plugins.frontend.lib.Utils.implode;

abstract class BunTaskExecutor {
    private static final String DS = ""//"";

    private static final String AT = ""@"";

    private final Logger logger;

    private final String taskName;

    private final ArgumentsParser argumentsParser;

    private final BunExecutorConfig config;

    public BunTaskExecutor(BunExecutorConfig config, String taskLocation) {
        this(config, taskLocation, Collections.emptyList());
    }

    public BunTaskExecutor(BunExecutorConfig config, String taskName, String taskLocation) {
        this(config, taskName, taskLocation, Collections.emptyList());
    }

    public BunTaskExecutor(BunExecutorConfig config, String taskLocation,
                           List<String> additionalArguments) {
        this(config, getTaskNameFromLocation(taskLocation), taskLocation, additionalArguments);
    }

    public BunTaskExecutor(BunExecutorConfig config, String taskName, String taskLocation,
                           List<String> additionalArguments) {
        logger = LoggerFactory.getLogger(getClass());
        this.config = config;
        this.taskName = taskName;
        this.argumentsParser = new ArgumentsParser(additionalArguments);
    }

    private static String getTaskNameFromLocation(String taskLocation) {
        return taskLocation.replaceAll(""^.*/([^/]+)(?:\\.js)?$"", ""$1"");
    }

    public final void execute(String args, Map<String, String> environment) throws TaskRunnerException {
        final List<String> arguments = getArguments(args);
        logger.info(""Running "" + taskToString(taskName, arguments) + "" in "" + config.getWorkingDirectory());

        try {
            final int result =
                    new BunExecutor(config, arguments, environment).executeAndRedirectOutput(logger);
            if (result != 0) {
                throw new TaskRunnerException(
                        taskToString(taskName, arguments) + "" failed. (error code "" + result + "")"");
            }
        } catch (ProcessExecutionException e) {
            throw new TaskRunnerException(taskToString(taskName, arguments) + "" failed."", e);
        }
    }

    private List<String> getArguments(String args) {
        return argumentsParser.parse(args);
    }

    private static String taskToString(String taskName, List<String> arguments) {
        List<String> clonedArguments = new ArrayList<>(arguments);
        for (int i = 0; i < clonedArguments.size(); i++) {
            final String s = clonedArguments.get(i);
            final boolean maskMavenProxyPassword = s.contains(""proxy="");
            if (maskMavenProxyPassword) {
                final String bestEffortMaskedPassword = maskPassword(s);
                clonedArguments.set(i, bestEffortMaskedPassword);
            }
        }
        return ""'"" + taskName + "" "" + implode("" "", clonedArguments) + ""'"";
    }

    private static String maskPassword(String proxyString) {
        String retVal = proxyString;
        if (proxyString != null && !"""".equals(proxyString.trim())) {
            boolean hasSchemeDefined = proxyString.contains(""http:"") || proxyString.contains(""https:"");
            boolean hasProtocolDefined = proxyString.contains(DS);
            boolean hasAtCharacterDefined = proxyString.contains(AT);
            if (hasSchemeDefined && hasProtocolDefined && hasAtCharacterDefined) {
                final int firstDoubleSlashIndex = proxyString.indexOf(DS);
                final int lastAtCharIndex = proxyString.lastIndexOf(AT);
                boolean hasPossibleURIUserInfo = firstDoubleSlashIndex < lastAtCharIndex;
                if (hasPossibleURIUserInfo) {
                    final String userInfo =
                            proxyString.substring(firstDoubleSlashIndex + DS.length(), lastAtCharIndex);
                    final String[] userParts = userInfo.split("":"");
                    if (userParts.length > 0) {
                        final int startOfUserNameIndex = firstDoubleSlashIndex + DS.length();
                        final int firstColonInUsernameOrEndOfUserNameIndex =
                                startOfUserNameIndex + userParts[0].length();
                        final String leftPart =
                                proxyString.substring(0, firstColonInUsernameOrEndOfUserNameIndex);
                        final String rightPart = proxyString.substring(lastAtCharIndex);
                        retVal = leftPart + "":***"" + rightPart;
                    }
                }
            }
        }
        return retVal;
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; abstract class BunTaskExecutor { private static final String AT = ""@""; private final Logger logger; private final String taskName; private final ArgumentsParser argumentsParser; private final BunExecutorConfig config; public BunTaskExecutor(BunExecutorConfig config, String taskLocation) { this(config, taskLocation, Collections.emptyList()); } public BunTaskExecutor(BunExecutorConfig config, String taskName, String taskLocation) { this(config, taskName, taskLocation, Collections.emptyList()); } public BunTaskExecutor(BunExecutorConfig config, String taskLocation,
                           List<String> additionalArguments) { this(config, getTaskNameFromLocation(taskLocation), taskLocation, additionalArguments); } public BunTaskExecutor(BunExecutorConfig config, String taskName, String taskLocation,
                           List<String> additionalArguments) { logger = LoggerFactory.getLogger(getClass()); this.config = config; this.taskName = taskName; this.argumentsParser = new ArgumentsParser(additionalArguments); } private static String getTaskNameFromLocation(String taskLocation) { return taskLocation.replaceAll(""^.*/([^/]+)(?:\\.js)?$"", ""$1""); } public final void execute(String args, Map<String, String> environment) throws TaskRunnerException { final List<String> arguments = getArguments(args); try { final int result =
                    new BunExecutor(config, arguments, environment).executeAndRedirectOutput(logger); if (result != 0) { throw new TaskRunnerException(
                        taskToString(taskName, arguments) + "" failed. (error code "" + result + "")""); } } catch (ProcessExecutionException e) { throw new TaskRunnerException(taskToString(taskName, arguments) + "" failed."", e); } } private List<String> getArguments(String args) { return argumentsParser.parse(args); } private static String taskToString(String taskName, List<String> arguments) { List<String> clonedArguments = new ArrayList<>(arguments); for (int i = 0; i < clonedArguments.size(); i++) { final String s = clonedArguments.get(i); final boolean maskMavenProxyPassword = s.contains(""proxy=""); if (maskMavenProxyPassword) { final String bestEffortMaskedPassword = maskPassword(s); clonedArguments.set(i, bestEffortMaskedPassword); } } return ""'"" + taskName + "" "" + implode("" "", clonedArguments) + ""'""; } private static String maskPassword(String proxyString) { String retVal = proxyString; if (proxyString != null && !"""".equals(proxyString.trim())) { boolean hasSchemeDefined = proxyString.contains(""http:"") || proxyString.contains(""https:""); boolean hasProtocolDefined = proxyString.contains(DS); boolean hasAtCharacterDefined = proxyString.contains(AT); if (hasSchemeDefined && hasProtocolDefined && hasAtCharacterDefined) { final int firstDoubleSlashIndex = proxyString.indexOf(DS); final int lastAtCharIndex = proxyString.lastIndexOf(AT); boolean hasPossibleURIUserInfo = firstDoubleSlashIndex < lastAtCharIndex; if (hasPossibleURIUserInfo) { final String userInfo =
                            proxyString.substring(firstDoubleSlashIndex + DS.length(), lastAtCharIndex); final String[] userParts = userInfo.split("":""); if (userParts.length > 0) { final int startOfUserNameIndex = firstDoubleSlashIndex + DS.length(); final int firstColonInUsernameOrEndOfUserNameIndex =
                                startOfUserNameIndex + userParts[0].length(); final String leftPart =
                                proxyString.substring(0, firstColonInUsernameOrEndOfUserNameIndex); final String rightPart = proxyString.substring(lastAtCharIndex); retVal = leftPart + "":***"" + rightPart; } } } } return retVal; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; abstract class BunTaskExecutor { private static final String AT = ""@""; private final Logger logger; private final String taskName; private final ArgumentsParser argumentsParser; private final BunExecutorConfig config; public BunTaskExecutor(BunExecutorConfig config, String taskLocation) { this(config, taskLocation, Collections.emptyList()); } public BunTaskExecutor(BunExecutorConfig config, String taskName, String taskLocation) { this(config, taskName, taskLocation, Collections.emptyList()); } public BunTaskExecutor(BunExecutorConfig config, String taskLocation,
                           List<String> additionalArguments) { this(config, getTaskNameFromLocation(taskLocation), taskLocation, additionalArguments); } public BunTaskExecutor(BunExecutorConfig config, String taskName, String taskLocation,
                           List<String> additionalArguments) { logger = LoggerFactory.getLogger(getClass()); this.config = config; this.taskName = taskName; this.argumentsParser = new ArgumentsParser(additionalArguments); } private static String getTaskNameFromLocation(String taskLocation) { return taskLocation.replaceAll(""^.*/([^/]+)(?:\\.js)?$"", ""$1""); } public final void execute(String args, Map<String, String> environment) throws TaskRunnerException { final List<String> arguments = getArguments(args); <FILL_ME> try { final int result =
                    new BunExecutor(config, arguments, environment).executeAndRedirectOutput(logger); if (result != 0) { throw new TaskRunnerException(
                        taskToString(taskName, arguments) + "" failed. (error code "" + result + "")""); } } catch (ProcessExecutionException e) { throw new TaskRunnerException(taskToString(taskName, arguments) + "" failed."", e); } } private List<String> getArguments(String args) { return argumentsParser.parse(args); } private static String taskToString(String taskName, List<String> arguments) { List<String> clonedArguments = new ArrayList<>(arguments); for (int i = 0; i < clonedArguments.size(); i++) { final String s = clonedArguments.get(i); final boolean maskMavenProxyPassword = s.contains(""proxy=""); if (maskMavenProxyPassword) { final String bestEffortMaskedPassword = maskPassword(s); clonedArguments.set(i, bestEffortMaskedPassword); } } return ""'"" + taskName + "" "" + implode("" "", clonedArguments) + ""'""; } private static String maskPassword(String proxyString) { String retVal = proxyString; if (proxyString != null && !"""".equals(proxyString.trim())) { boolean hasSchemeDefined = proxyString.contains(""http:"") || proxyString.contains(""https:""); boolean hasProtocolDefined = proxyString.contains(DS); boolean hasAtCharacterDefined = proxyString.contains(AT); if (hasSchemeDefined && hasProtocolDefined && hasAtCharacterDefined) { final int firstDoubleSlashIndex = proxyString.indexOf(DS); final int lastAtCharIndex = proxyString.lastIndexOf(AT); boolean hasPossibleURIUserInfo = firstDoubleSlashIndex < lastAtCharIndex; if (hasPossibleURIUserInfo) { final String userInfo =
                            proxyString.substring(firstDoubleSlashIndex + DS.length(), lastAtCharIndex); final String[] userParts = userInfo.split("":""); if (userParts.length > 0) { final int startOfUserNameIndex = firstDoubleSlashIndex + DS.length(); final int firstColonInUsernameOrEndOfUserNameIndex =
                                startOfUserNameIndex + userParts[0].length(); final String leftPart =
                                proxyString.substring(0, firstColonInUsernameOrEndOfUserNameIndex); final String rightPart = proxyString.substring(lastAtCharIndex); retVal = leftPart + "":***"" + rightPart; } } } } return retVal; } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import org.slf4j.Logger; import org.slf4j.LoggerFactory; 
import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Map; 
import static com.github.eirslett.maven.plugins.frontend.lib.Utils.implode;  abstract class BunTaskExecutor { //"";  private static final String AT = ""@"";  private final Logger logger;  private final String taskName;  private final ArgumentsParser argumentsParser;  private final BunExecutorConfig config;  public BunTaskExecutor(BunExecutorConfig config, String taskLocation) { this(config, taskLocation, Collections.emptyList()); }  public BunTaskExecutor(BunExecutorConfig config, String taskName, String taskLocation) { this(config, taskName, taskLocation, Collections.emptyList()); }  public BunTaskExecutor(BunExecutorConfig config, String taskLocation,
                           List<String> additionalArguments) { this(config, getTaskNameFromLocation(taskLocation), taskLocation, additionalArguments); }  public BunTaskExecutor(BunExecutorConfig config, String taskName, String taskLocation,
                           List<String> additionalArguments) { logger = LoggerFactory.getLogger(getClass()); this.config = config; this.taskName = taskName; this.argumentsParser = new ArgumentsParser(additionalArguments); }  private static String getTaskNameFromLocation(String taskLocation) { return taskLocation.replaceAll(""^.*/([^/]+)(?:\\.js)?$"", ""$1""); }  public final void execute(String args, Map<String, String> environment) throws TaskRunnerException { final List<String> arguments = getArguments(args); <FILL_ME>  try { final int result =
                    new BunExecutor(config, arguments, environment).executeAndRedirectOutput(logger); if (result != 0) { throw new TaskRunnerException(
                        taskToString(taskName, arguments) + "" failed. (error code "" + result + "")""); } } catch (ProcessExecutionException e) { throw new TaskRunnerException(taskToString(taskName, arguments) + "" failed."", e); } }  private List<String> getArguments(String args) { return argumentsParser.parse(args); }  private static String taskToString(String taskName, List<String> arguments) { List<String> clonedArguments = new ArrayList<>(arguments); for (int i = 0; i < clonedArguments.size(); i++) { final String s = clonedArguments.get(i); final boolean maskMavenProxyPassword = s.contains(""proxy=""); if (maskMavenProxyPassword) { final String bestEffortMaskedPassword = maskPassword(s); clonedArguments.set(i, bestEffortMaskedPassword); } } return ""'"" + taskName + "" "" + implode("" "", clonedArguments) + ""'""; }  private static String maskPassword(String proxyString) { String retVal = proxyString; if (proxyString != null && !"""".equals(proxyString.trim())) { boolean hasSchemeDefined = proxyString.contains(""http:"") || proxyString.contains(""https:""); boolean hasProtocolDefined = proxyString.contains(DS); boolean hasAtCharacterDefined = proxyString.contains(AT); if (hasSchemeDefined && hasProtocolDefined && hasAtCharacterDefined) { final int firstDoubleSlashIndex = proxyString.indexOf(DS); final int lastAtCharIndex = proxyString.lastIndexOf(AT); boolean hasPossibleURIUserInfo = firstDoubleSlashIndex < lastAtCharIndex; if (hasPossibleURIUserInfo) { final String userInfo =
                            proxyString.substring(firstDoubleSlashIndex + DS.length(), lastAtCharIndex); final String[] userParts = userInfo.split("":""); if (userParts.length > 0) { final int startOfUserNameIndex = firstDoubleSlashIndex + DS.length(); final int firstColonInUsernameOrEndOfUserNameIndex =
                                startOfUserNameIndex + userParts[0].length(); final String leftPart =
                                proxyString.substring(0, firstColonInUsernameOrEndOfUserNameIndex); final String rightPart = proxyString.substring(lastAtCharIndex); retVal = leftPart + "":***"" + rightPart; } } } } return retVal; } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/CacheDescriptor.java,"package com.github.eirslett.maven.plugins.frontend.lib;

public class CacheDescriptor {

  private final String name;
  private final String version;
  private final String classifier;
  private final String extension;

  public CacheDescriptor(String name, String version, String extension) {
    this(name, version, null, extension);
  }

  public CacheDescriptor(String name, String version, String classifier, String extension) {
    this.name = name;
    this.version = version;
    this.classifier = classifier;
    this.extension = extension;
  }

  public String getName() {
    return name;
  }

  public String getVersion() {
    return version;
  }

  public String getClassifier() {
    return classifier;
  }

  public String getExtension() {
    return extension;
  }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public class CacheDescriptor { private final String name; private final String version; private final String classifier; private final String extension; public CacheDescriptor(String name, String version, String extension) { this(name, version, null, extension); } public CacheDescriptor(String name, String version, String classifier, String extension) { this.name = name; this.version = version; this.classifier = classifier; this.extension = extension; } public String getName() { return name; } public String getVersion() { return version; } public String getClassifier() { return classifier; } public String getExtension() { return extension; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public class CacheDescriptor { private final String name; private final String version; private final String classifier; private final String extension; public CacheDescriptor(String name, String version, String extension) { this(name, version, null, extension); } public CacheDescriptor(String name, String version, String classifier, String extension) { this.name = name; this.version = version; this.classifier = classifier; this.extension = extension; } public String getName() { return name; } public String getVersion() { return version; } public String getClassifier() { return classifier; } public String getExtension() { return extension; } } ","package com.github.eirslett.maven.plugins.frontend.lib;  public class CacheDescriptor {  private final String name; private final String version; private final String classifier; private final String extension;  public CacheDescriptor(String name, String version, String extension) { this(name, version, null, extension); }  public CacheDescriptor(String name, String version, String classifier, String extension) { this.name = name; this.version = version; this.classifier = classifier; this.extension = extension; }  public String getName() { return name; }  public String getVersion() { return version; }  public String getClassifier() { return classifier; }  public String getExtension() { return extension; } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/CacheResolver.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import java.io.File;

public interface CacheResolver {
  File resolve(CacheDescriptor cacheDescriptor);
}
",package com.github.eirslett.maven.plugins.frontend.lib; public interface CacheResolver { File resolve(CacheDescriptor cacheDescriptor); },0 0 0 0 0,package com.github.eirslett.maven.plugins.frontend.lib; public interface CacheResolver { File resolve(CacheDescriptor cacheDescriptor); } ,"package com.github.eirslett.maven.plugins.frontend.lib; 
import java.io.File;  public interface CacheResolver { File resolve(CacheDescriptor cacheDescriptor); }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/CorepackInstaller.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.commons.io.FileUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;

public class CorepackInstaller {

    private static final String VERSION = ""version"";

    public static final String DEFAULT_COREPACK_DOWNLOAD_ROOT = ""https://registry.npmjs.org/corepack/-/"";

    private static final Object LOCK = new Object();

    private String corepackVersion, corepackDownloadRoot, userName, password;

    private Map<String, String> httpHeaders;
    
    private final Logger logger;

    private final InstallConfig config;

    private final ArchiveExtractor archiveExtractor;

    private final FileDownloader fileDownloader;

    CorepackInstaller(InstallConfig config, ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) {
        this.logger = LoggerFactory.getLogger(getClass());
        this.config = config;
        this.archiveExtractor = archiveExtractor;
        this.fileDownloader = fileDownloader;
    }

    public CorepackInstaller setNodeVersion(String nodeVersion) {
        return this;
    }

    public CorepackInstaller setCorepackVersion(String corepackVersion) {
        this.corepackVersion = corepackVersion;
        return this;
    }

    public CorepackInstaller setCorepackDownloadRoot(String corepackDownloadRoot) {
        this.corepackDownloadRoot = corepackDownloadRoot;
        return this;
    }

    public CorepackInstaller setUserName(String userName) {
        this.userName = userName;
        return this;
    }

    public CorepackInstaller setPassword(String password) {
        this.password = password;
        return this;
    }

    public CorepackInstaller setHttpHeaders(Map<String, String> httpHeaders) {
        this.httpHeaders = httpHeaders;
        return this;
    }

    public void install() throws InstallationException {
        // use static lock object for a synchronized block
        synchronized (LOCK) {
            if (this.corepackDownloadRoot == null || this.corepackDownloadRoot.isEmpty()) {
                this.corepackDownloadRoot = DEFAULT_COREPACK_DOWNLOAD_ROOT;
            }
            if (!corepackIsAlreadyInstalled()) {
                installCorepack();
            }

            if (this.config.getPlatform().isWindows()) {
                linkExecutableWindows();
            } else {
                linkExecutable();
            }
        }
    }

    private boolean corepackIsAlreadyInstalled() {
        try {
            final File corepackPackageJson = new File(
                this.config.getInstallDirectory() + Utils.normalize(""/node/node_modules/corepack/package.json""));
            if (corepackPackageJson.exists()) {
                if (""provided"".equals(this.corepackVersion)) {
                    // Since we don't know which version it should be, we must assume that we have
                    // correctly setup the packaged version
                    return true;
                }
                HashMap<String, Object> data = new ObjectMapper().readValue(corepackPackageJson, HashMap.class);
                if (data.containsKey(VERSION)) {
                    final String foundCorepackVersion = data.get(VERSION).toString();
                    if (foundCorepackVersion.equals(this.corepackVersion.replaceFirst(""^v"", """"))) {
                        this.logger.info(""corepack {} is already installed."", foundCorepackVersion);
                        return true;
                    } else {
                        this.logger.info(""corepack {} was installed, but we need version {}"", foundCorepackVersion,
                            this.corepackVersion);
                        return false;
                    }
                } else {
                    this.logger.info(""Could not read corepack version from package.json"");
                    return false;
                }
            } else {
                return false;
            }
        } catch (IOException ex) {
            throw new RuntimeException(""Could not read package.json"", ex);
        }
    }

    private void installCorepack() throws InstallationException {
        try {
            this.logger.info(""Installing corepack version {}"", this.corepackVersion);
            String corepackVersionClean = this.corepackVersion.replaceFirst(""^v(?=[0-9]+)"", """");
            final String downloadUrl = this.corepackDownloadRoot + ""corepack-"" + corepackVersionClean + "".tgz"";

            CacheDescriptor cacheDescriptor = new CacheDescriptor(""corepack"", corepackVersionClean, ""tar.gz"");

            File archive = this.config.getCacheResolver().resolve(cacheDescriptor);

            downloadFileIfMissing(downloadUrl, archive, this.userName, this.password, this.httpHeaders);

            File installDirectory = getNodeInstallDirectory();
            File nodeModulesDirectory = new File(installDirectory, ""node_modules"");

            // We need to delete the existing corepack directory first so we clean out any old files, and
            // so we can rename the package directory below.
            File oldDirectory = new File(installDirectory, ""corepack"");
            File corepackDirectory = new File(nodeModulesDirectory, ""corepack"");
            try {
                if (oldDirectory.isDirectory()) {
                    FileUtils.deleteDirectory(oldDirectory);
                }
                FileUtils.deleteDirectory(corepackDirectory);
            } catch (IOException e) {
                this.logger.warn(""Failed to delete existing corepack installation."");
            }

            File packageDirectory = new File(nodeModulesDirectory, ""package"");
            try {
                extractFile(archive, nodeModulesDirectory);
            } catch (ArchiveExtractionException e) {
                if (e.getCause() instanceof EOFException) {
                    // https://github.com/eirslett/frontend-maven-plugin/issues/794
                    // The downloading was probably interrupted and archive file is incomplete:
                    // delete it to retry from scratch
                    this.logger.error(""The archive file {} is corrupted and will be deleted. ""
                            + ""Please try the build again."", archive.getPath());
                    archive.delete();
                    if (packageDirectory.exists()) {
                        FileUtils.deleteDirectory(packageDirectory);
                    }
                }

                throw e;
            }

            // handles difference between old and new download root (nodejs.org/dist/npm and
            // registry.npmjs.org)
            // see https://github.com/eirslett/frontend-maven-plugin/issues/65#issuecomment-52024254
            if (packageDirectory.exists() && !corepackDirectory.exists()) {
                if (!packageDirectory.renameTo(corepackDirectory)) {
                    this.logger.warn(""Cannot rename corepack directory, making a copy."");
                    FileUtils.copyDirectory(packageDirectory, corepackDirectory);
                }
            }

            this.logger.info(""Installed corepack locally."");

        } catch (DownloadException e) {
            throw new InstallationException(""Could not download corepack"", e);
        } catch (ArchiveExtractionException e) {
            throw new InstallationException(""Could not extract the corepack archive"", e);
        } catch (IOException e) {
            throw new InstallationException(""Could not copy corepack"", e);
        }
    }

    private void linkExecutable() throws InstallationException{
        File nodeInstallDirectory = getNodeInstallDirectory();
        File corepackExecutable = new File(nodeInstallDirectory, ""corepack"");

        if (corepackExecutable.exists()) {
            this.logger.info(""Existing corepack executable found, skipping linking."");
            return;
        }

        NodeExecutorConfig executorConfig = new InstallNodeExecutorConfig(this.config);
        File corepackJsExecutable = executorConfig.getCorepackPath();

        if (!corepackJsExecutable.exists()) {
            throw new InstallationException(""Could not link to corepack executable, no corepack installation found."");
        }

        this.logger.info(""No corepack executable found, creating symbolic link to {}."", corepackJsExecutable.toPath());

        try {
            Files.createSymbolicLink(corepackExecutable.toPath(), corepackJsExecutable.toPath());
        } catch (IOException e) {
            throw new InstallationException(""Could not create symbolic link for corepack executable."", e);
        }
    }

    private void linkExecutableWindows() throws InstallationException{
        File nodeInstallDirectory = getNodeInstallDirectory();
        File corepackExecutable = new File(nodeInstallDirectory, ""corepack.cmd"");

        if (corepackExecutable.exists()) {
            this.logger.info(""Existing corepack executable found, skipping linking."");
            return;
        }

        NodeExecutorConfig executorConfig = new InstallNodeExecutorConfig(this.config);
        File corepackJsExecutable = executorConfig.getCorepackPath();

        if (!corepackJsExecutable.exists()) {
            throw new InstallationException(""Could not link to corepack executable, no corepack installation found."");
        }

        this.logger.info(""No corepack executable found, creating proxy script to {}."", corepackJsExecutable.toPath());

        Path nodePath = executorConfig.getNodePath().toPath();
        Path relativeNodePath = nodeInstallDirectory.toPath().relativize(nodePath);
        Path relativeCorepackPath = nodeInstallDirectory.toPath().relativize(corepackJsExecutable.toPath());

        // Create a script that will proxy any commands passed into it to the corepack executable.
        String scriptContents = new StringBuilder()
                .append("":: Created by frontend-maven-plugin, please don't edit manually.\r\n"")
                .append(""@ECHO OFF\r\n"")
                .append(""\r\n"")
                .append(""SETLOCAL\r\n"")
                .append(""\r\n"")
                .append(String.format(""SET \""NODE_EXE=%%~dp0\\%s\""\r\n"", relativeNodePath))
                .append(String.format(""SET \""COREPACK_CLI_JS=%%~dp0\\%s\""\r\n"", relativeCorepackPath))
                .append(""\r\n"")
                .append(""\""%NODE_EXE%\"" \""%COREPACK_CLI_JS%\"" %*"")
                .toString();

        try {
            BufferedWriter writer = new BufferedWriter(new FileWriter(corepackExecutable));
            writer.write(scriptContents);
            writer.close();
        } catch (IOException e) {
            throw new InstallationException(""Could not create proxy script for corepack executable."", e);
        }
    }

    private File getNodeInstallDirectory() {
        File installDirectory = new File(this.config.getInstallDirectory(), NodeInstaller.INSTALL_PATH);
        if (!installDirectory.exists()) {
            this.logger.debug(""Creating install directory {}"", installDirectory);
            installDirectory.mkdirs();
        }
        return installDirectory;
    }

    private void extractFile(File archive, File destinationDirectory) throws ArchiveExtractionException {
        this.logger.info(""Unpacking {} into {}"", archive, destinationDirectory);
        this.archiveExtractor.extract(archive.getPath(), destinationDirectory.getPath());
    }

    private void downloadFileIfMissing(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException {
        if (!destination.exists()) {
            downloadFile(downloadUrl, destination, userName, password, httpHeaders);
        }
    }

    private void downloadFile(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException {
        this.logger.info(""Downloading {} to {}"", downloadUrl, destination);
        this.fileDownloader.download(downloadUrl, destination.getPath(), userName, password, httpHeaders);
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public class CorepackInstaller { private static final String VERSION = ""version""; private static final Object LOCK = new Object(); private String corepackVersion, corepackDownloadRoot, userName, password; private Map<String, String> httpHeaders; private final Logger logger; private final InstallConfig config; private final ArchiveExtractor archiveExtractor; private final FileDownloader fileDownloader; CorepackInstaller(InstallConfig config, ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) { this.logger = LoggerFactory.getLogger(getClass()); this.config = config; this.archiveExtractor = archiveExtractor; this.fileDownloader = fileDownloader; } public CorepackInstaller setNodeVersion(String nodeVersion) { return this; } public CorepackInstaller setCorepackVersion(String corepackVersion) { this.corepackVersion = corepackVersion; return this; } public CorepackInstaller setCorepackDownloadRoot(String corepackDownloadRoot) { this.corepackDownloadRoot = corepackDownloadRoot; return this; } public CorepackInstaller setUserName(String userName) { this.userName = userName; return this; } public CorepackInstaller setPassword(String password) { this.password = password; return this; } public CorepackInstaller setHttpHeaders(Map<String, String> httpHeaders) { this.httpHeaders = httpHeaders; return this; } public void install() throws InstallationException { synchronized (LOCK) { if (this.corepackDownloadRoot == null || this.corepackDownloadRoot.isEmpty()) { this.corepackDownloadRoot = DEFAULT_COREPACK_DOWNLOAD_ROOT; } if (!corepackIsAlreadyInstalled()) { installCorepack(); } if (this.config.getPlatform().isWindows()) { linkExecutableWindows(); } else { linkExecutable(); } } } private boolean corepackIsAlreadyInstalled() { try { final File corepackPackageJson = new File(
                this.config.getInstallDirectory() + Utils.normalize(""/node/node_modules/corepack/package.json"")); if (corepackPackageJson.exists()) { if (""provided"".equals(this.corepackVersion)) { return true; } HashMap<String, Object> data = new ObjectMapper().readValue(corepackPackageJson, HashMap.class); if (data.containsKey(VERSION)) { final String foundCorepackVersion = data.get(VERSION).toString(); if (foundCorepackVersion.equals(this.corepackVersion.replaceFirst(""^v"", """"))) { this.logger.info(""corepack { } is already installed."", foundCorepackVersion); return true; } else { this.logger.info(""corepack { } was installed, but we need version { } "", foundCorepackVersion,
                            this.corepackVersion); return false; } } else { return false; } } else { return false; } } catch (IOException ex) { throw new RuntimeException(""Could not read package.json"", ex); } } private void installCorepack() throws InstallationException { try { this.logger.info(""Installing corepack version { } "", this.corepackVersion); String corepackVersionClean = this.corepackVersion.replaceFirst(""^v(?=[0-9]+)"", """"); final String downloadUrl = this.corepackDownloadRoot + ""corepack-"" + corepackVersionClean + "".tgz""; CacheDescriptor cacheDescriptor = new CacheDescriptor(""corepack"", corepackVersionClean, ""tar.gz""); File archive = this.config.getCacheResolver().resolve(cacheDescriptor); downloadFileIfMissing(downloadUrl, archive, this.userName, this.password, this.httpHeaders); File installDirectory = getNodeInstallDirectory(); File nodeModulesDirectory = new File(installDirectory, ""node_modules""); File oldDirectory = new File(installDirectory, ""corepack""); File corepackDirectory = new File(nodeModulesDirectory, ""corepack""); try { if (oldDirectory.isDirectory()) { FileUtils.deleteDirectory(oldDirectory); } FileUtils.deleteDirectory(corepackDirectory); } catch (IOException e) { } File packageDirectory = new File(nodeModulesDirectory, ""package""); try { extractFile(archive, nodeModulesDirectory); } catch (ArchiveExtractionException e) { if (e.getCause() instanceof EOFException) { this.logger.error(""The archive file { } is corrupted and will be deleted. ""
                            + ""Please try the build again."", archive.getPath()); archive.delete(); if (packageDirectory.exists()) { FileUtils.deleteDirectory(packageDirectory); } } throw e; } if (packageDirectory.exists() && !corepackDirectory.exists()) { if (!packageDirectory.renameTo(corepackDirectory)) { FileUtils.copyDirectory(packageDirectory, corepackDirectory); } } } catch (DownloadException e) { throw new InstallationException(""Could not download corepack"", e); } catch (ArchiveExtractionException e) { throw new InstallationException(""Could not extract the corepack archive"", e); } catch (IOException e) { throw new InstallationException(""Could not copy corepack"", e); } } private void linkExecutable() throws InstallationException{ File nodeInstallDirectory = getNodeInstallDirectory(); File corepackExecutable = new File(nodeInstallDirectory, ""corepack""); if (corepackExecutable.exists()) { return; } NodeExecutorConfig executorConfig = new InstallNodeExecutorConfig(this.config); File corepackJsExecutable = executorConfig.getCorepackPath(); if (!corepackJsExecutable.exists()) { throw new InstallationException(""Could not link to corepack executable, no corepack installation found.""); } this.logger.info(""No corepack executable found, creating symbolic link to { } ."", corepackJsExecutable.toPath()); try { Files.createSymbolicLink(corepackExecutable.toPath(), corepackJsExecutable.toPath()); } catch (IOException e) { throw new InstallationException(""Could not create symbolic link for corepack executable."", e); } } private void linkExecutableWindows() throws InstallationException{ File nodeInstallDirectory = getNodeInstallDirectory(); File corepackExecutable = new File(nodeInstallDirectory, ""corepack.cmd""); if (corepackExecutable.exists()) { return; } NodeExecutorConfig executorConfig = new InstallNodeExecutorConfig(this.config); File corepackJsExecutable = executorConfig.getCorepackPath(); if (!corepackJsExecutable.exists()) { throw new InstallationException(""Could not link to corepack executable, no corepack installation found.""); } this.logger.info(""No corepack executable found, creating proxy script to { } ."", corepackJsExecutable.toPath()); Path nodePath = executorConfig.getNodePath().toPath(); Path relativeNodePath = nodeInstallDirectory.toPath().relativize(nodePath); Path relativeCorepackPath = nodeInstallDirectory.toPath().relativize(corepackJsExecutable.toPath()); String scriptContents = new StringBuilder()
                .append("":: Created by frontend-maven-plugin, please don't edit manually.\r\n"")
                .append(""@ECHO OFF\r\n"")
                .append(""\r\n"")
                .append(""SETLOCAL\r\n"")
                .append(""\r\n"")
                .append(String.format(""SET \""NODE_EXE=%%~dp0\\%s\""\r\n"", relativeNodePath))
                .append(String.format(""SET \""COREPACK_CLI_JS=%%~dp0\\%s\""\r\n"", relativeCorepackPath))
                .append(""\r\n"")
                .append(""\""%NODE_EXE%\"" \""%COREPACK_CLI_JS%\"" %*"")
                .toString(); try { BufferedWriter writer = new BufferedWriter(new FileWriter(corepackExecutable)); writer.write(scriptContents); writer.close(); } catch (IOException e) { throw new InstallationException(""Could not create proxy script for corepack executable."", e); } } private File getNodeInstallDirectory() { File installDirectory = new File(this.config.getInstallDirectory(), NodeInstaller.INSTALL_PATH); if (!installDirectory.exists()) { this.logger.debug(""Creating install directory { } "", installDirectory); installDirectory.mkdirs(); } return installDirectory; } private void extractFile(File archive, File destinationDirectory) throws ArchiveExtractionException { this.logger.info(""Unpacking { } into { } "", archive, destinationDirectory); this.archiveExtractor.extract(archive.getPath(), destinationDirectory.getPath()); } private void downloadFileIfMissing(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException { if (!destination.exists()) { downloadFile(downloadUrl, destination, userName, password, httpHeaders); } } private void downloadFile(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException { this.logger.info(""Downloading { } to { } "", downloadUrl, destination); this.fileDownloader.download(downloadUrl, destination.getPath(), userName, password, httpHeaders); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public class CorepackInstaller { private static final String VERSION = ""version""; private static final Object LOCK = new Object(); private String corepackVersion, corepackDownloadRoot, userName, password; private Map<String, String> httpHeaders; private final Logger logger; private final InstallConfig config; private final ArchiveExtractor archiveExtractor; private final FileDownloader fileDownloader; CorepackInstaller(InstallConfig config, ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) { this.logger = LoggerFactory.getLogger(getClass()); this.config = config; this.archiveExtractor = archiveExtractor; this.fileDownloader = fileDownloader; } <FILL_ME> public CorepackInstaller setNodeVersion(String nodeVersion) { return this; } public CorepackInstaller setCorepackVersion(String corepackVersion) { this.corepackVersion = corepackVersion; return this; } public CorepackInstaller setCorepackDownloadRoot(String corepackDownloadRoot) { this.corepackDownloadRoot = corepackDownloadRoot; return this; } public CorepackInstaller setUserName(String userName) { this.userName = userName; return this; } public CorepackInstaller setPassword(String password) { this.password = password; return this; } public CorepackInstaller setHttpHeaders(Map<String, String> httpHeaders) { this.httpHeaders = httpHeaders; return this; } public void install() throws InstallationException { synchronized (LOCK) { if (this.corepackDownloadRoot == null || this.corepackDownloadRoot.isEmpty()) { this.corepackDownloadRoot = DEFAULT_COREPACK_DOWNLOAD_ROOT; } if (!corepackIsAlreadyInstalled()) { installCorepack(); } if (this.config.getPlatform().isWindows()) { linkExecutableWindows(); } else { <FILL_ME> linkExecutable(); } } } private boolean corepackIsAlreadyInstalled() { try { final File corepackPackageJson = new File(
                this.config.getInstallDirectory() + Utils.normalize(""/node/node_modules/corepack/package.json"")); if (corepackPackageJson.exists()) { if (""provided"".equals(this.corepackVersion)) { return true; } HashMap<String, Object> data = new ObjectMapper().readValue(corepackPackageJson, HashMap.class); if (data.containsKey(VERSION)) { final String foundCorepackVersion = data.get(VERSION).toString(); if (foundCorepackVersion.equals(this.corepackVersion.replaceFirst(""^v"", """"))) { this.logger.info(""corepack { } is already installed."", foundCorepackVersion); return true; } else { this.logger.info(""corepack { } was installed, but we need version { } "", foundCorepackVersion,
                            this.corepackVersion); return false; } } else { return false; } } else { return false; } } catch (IOException ex) { throw new RuntimeException(""Could not read package.json"", ex); } } private void installCorepack() throws InstallationException { try { this.logger.info(""Installing corepack version { } "", this.corepackVersion); String corepackVersionClean = this.corepackVersion.replaceFirst(""^v(?=[0-9]+)"", """"); final String downloadUrl = this.corepackDownloadRoot + ""corepack-"" + corepackVersionClean + "".tgz""; CacheDescriptor cacheDescriptor = new CacheDescriptor(""corepack"", corepackVersionClean, ""tar.gz""); File archive = this.config.getCacheResolver().resolve(cacheDescriptor); downloadFileIfMissing(downloadUrl, archive, this.userName, this.password, this.httpHeaders); File installDirectory = getNodeInstallDirectory(); File nodeModulesDirectory = new File(installDirectory, ""node_modules""); File oldDirectory = new File(installDirectory, ""corepack""); File corepackDirectory = new File(nodeModulesDirectory, ""corepack""); try { if (oldDirectory.isDirectory()) { FileUtils.deleteDirectory(oldDirectory); } FileUtils.deleteDirectory(corepackDirectory); } catch (IOException e) { <FILL_ME> } File packageDirectory = new File(nodeModulesDirectory, ""package""); try { extractFile(archive, nodeModulesDirectory); } catch (ArchiveExtractionException e) { if (e.getCause() instanceof EOFException) { this.logger.error(""The archive file { } is corrupted and will be deleted. ""
                            + ""Please try the build again."", archive.getPath()); archive.delete(); if (packageDirectory.exists()) { FileUtils.deleteDirectory(packageDirectory); } } throw e; } if (packageDirectory.exists() && !corepackDirectory.exists()) { if (!packageDirectory.renameTo(corepackDirectory)) { <FILL_ME> FileUtils.copyDirectory(packageDirectory, corepackDirectory); } } } catch (DownloadException e) { throw new InstallationException(""Could not download corepack"", e); } catch (ArchiveExtractionException e) { throw new InstallationException(""Could not extract the corepack archive"", e); } catch (IOException e) { throw new InstallationException(""Could not copy corepack"", e); } } private void linkExecutable() throws InstallationException{ File nodeInstallDirectory = getNodeInstallDirectory(); File corepackExecutable = new File(nodeInstallDirectory, ""corepack""); if (corepackExecutable.exists()) { <FILL_ME> <FILL_ME> return; } NodeExecutorConfig executorConfig = new InstallNodeExecutorConfig(this.config); File corepackJsExecutable = executorConfig.getCorepackPath(); if (!corepackJsExecutable.exists()) { throw new InstallationException(""Could not link to corepack executable, no corepack installation found.""); } this.logger.info(""No corepack executable found, creating symbolic link to { } ."", corepackJsExecutable.toPath()); try { Files.createSymbolicLink(corepackExecutable.toPath(), corepackJsExecutable.toPath()); } catch (IOException e) { throw new InstallationException(""Could not create symbolic link for corepack executable."", e); } } private void linkExecutableWindows() throws InstallationException{ File nodeInstallDirectory = getNodeInstallDirectory(); File corepackExecutable = new File(nodeInstallDirectory, ""corepack.cmd""); if (corepackExecutable.exists()) { return; } NodeExecutorConfig executorConfig = new InstallNodeExecutorConfig(this.config); File corepackJsExecutable = executorConfig.getCorepackPath(); if (!corepackJsExecutable.exists()) { throw new InstallationException(""Could not link to corepack executable, no corepack installation found.""); } this.logger.info(""No corepack executable found, creating proxy script to { } ."", corepackJsExecutable.toPath()); Path nodePath = executorConfig.getNodePath().toPath(); Path relativeNodePath = nodeInstallDirectory.toPath().relativize(nodePath); Path relativeCorepackPath = nodeInstallDirectory.toPath().relativize(corepackJsExecutable.toPath()); String scriptContents = new StringBuilder()
                .append("":: Created by frontend-maven-plugin, please don't edit manually.\r\n"")
                .append(""@ECHO OFF\r\n"")
                .append(""\r\n"")
                .append(""SETLOCAL\r\n"")
                .append(""\r\n"")
                .append(String.format(""SET \""NODE_EXE=%%~dp0\\%s\""\r\n"", relativeNodePath))
                .append(String.format(""SET \""COREPACK_CLI_JS=%%~dp0\\%s\""\r\n"", relativeCorepackPath))
                .append(""\r\n"")
                .append(""\""%NODE_EXE%\"" \""%COREPACK_CLI_JS%\"" %*"")
                .toString(); try { BufferedWriter writer = new BufferedWriter(new FileWriter(corepackExecutable)); writer.write(scriptContents); writer.close(); } catch (IOException e) { throw new InstallationException(""Could not create proxy script for corepack executable."", e); } } private File getNodeInstallDirectory() { File installDirectory = new File(this.config.getInstallDirectory(), NodeInstaller.INSTALL_PATH); if (!installDirectory.exists()) { this.logger.debug(""Creating install directory { } "", installDirectory); installDirectory.mkdirs(); } return installDirectory; } private void extractFile(File archive, File destinationDirectory) throws ArchiveExtractionException { this.logger.info(""Unpacking { } into { } "", archive, destinationDirectory); this.archiveExtractor.extract(archive.getPath(), destinationDirectory.getPath()); } private void downloadFileIfMissing(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException { if (!destination.exists()) { downloadFile(downloadUrl, destination, userName, password, httpHeaders); } } private void downloadFile(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException { this.logger.info(""Downloading { } to { } "", downloadUrl, destination); this.fileDownloader.download(downloadUrl, destination.getPath(), userName, password, httpHeaders); } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import com.fasterxml.jackson.databind.ObjectMapper; import org.apache.commons.io.FileUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory; 
import java.io.*; import java.nio.file.Files; import java.nio.file.Path; import java.util.HashMap; import java.util.Map;  public class CorepackInstaller {  private static final String VERSION = ""version"";  //registry.npmjs.org/corepack/-/"";  private static final Object LOCK = new Object();  private String corepackVersion, corepackDownloadRoot, userName, password;  private Map<String, String> httpHeaders;      private final Logger logger;  private final InstallConfig config;  private final ArchiveExtractor archiveExtractor;  private final FileDownloader fileDownloader;  CorepackInstaller(InstallConfig config, ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) { this.logger = LoggerFactory.getLogger(getClass()); this.config = config; this.archiveExtractor = archiveExtractor; this.fileDownloader = fileDownloader; } <FILL_ME>  public CorepackInstaller setNodeVersion(String nodeVersion) { return this; }  public CorepackInstaller setCorepackVersion(String corepackVersion) { this.corepackVersion = corepackVersion; return this; }  public CorepackInstaller setCorepackDownloadRoot(String corepackDownloadRoot) { this.corepackDownloadRoot = corepackDownloadRoot; return this; }  public CorepackInstaller setUserName(String userName) { this.userName = userName; return this; }  public CorepackInstaller setPassword(String password) { this.password = password; return this; }  public CorepackInstaller setHttpHeaders(Map<String, String> httpHeaders) { this.httpHeaders = httpHeaders; return this; }  public void install() throws InstallationException { // use static lock object for a synchronized block synchronized (LOCK) { if (this.corepackDownloadRoot == null || this.corepackDownloadRoot.isEmpty()) { this.corepackDownloadRoot = DEFAULT_COREPACK_DOWNLOAD_ROOT; } if (!corepackIsAlreadyInstalled()) { installCorepack(); }  if (this.config.getPlatform().isWindows()) { linkExecutableWindows(); } else { <FILL_ME> linkExecutable(); } } }  private boolean corepackIsAlreadyInstalled() { try { final File corepackPackageJson = new File(
                this.config.getInstallDirectory() + Utils.normalize(""/node/node_modules/corepack/package.json"")); if (corepackPackageJson.exists()) { if (""provided"".equals(this.corepackVersion)) { // Since we don't know which version it should be, we must assume that we have // correctly setup the packaged version return true; } HashMap<String, Object> data = new ObjectMapper().readValue(corepackPackageJson, HashMap.class); if (data.containsKey(VERSION)) { final String foundCorepackVersion = data.get(VERSION).toString(); if (foundCorepackVersion.equals(this.corepackVersion.replaceFirst(""^v"", """"))) { this.logger.info(""corepack { } is already installed."", foundCorepackVersion); return true; } else { this.logger.info(""corepack { } was installed, but we need version { } "", foundCorepackVersion,
                            this.corepackVersion); return false; } } else { return false; } } else { return false; } } catch (IOException ex) { throw new RuntimeException(""Could not read package.json"", ex); } }  private void installCorepack() throws InstallationException { try { this.logger.info(""Installing corepack version { } "", this.corepackVersion); String corepackVersionClean = this.corepackVersion.replaceFirst(""^v(?=[0-9]+)"", """"); final String downloadUrl = this.corepackDownloadRoot + ""corepack-"" + corepackVersionClean + "".tgz"";  CacheDescriptor cacheDescriptor = new CacheDescriptor(""corepack"", corepackVersionClean, ""tar.gz"");  File archive = this.config.getCacheResolver().resolve(cacheDescriptor);  downloadFileIfMissing(downloadUrl, archive, this.userName, this.password, this.httpHeaders);  File installDirectory = getNodeInstallDirectory(); File nodeModulesDirectory = new File(installDirectory, ""node_modules"");  // We need to delete the existing corepack directory first so we clean out any old files, and // so we can rename the package directory below. File oldDirectory = new File(installDirectory, ""corepack""); File corepackDirectory = new File(nodeModulesDirectory, ""corepack""); try { if (oldDirectory.isDirectory()) { FileUtils.deleteDirectory(oldDirectory); } FileUtils.deleteDirectory(corepackDirectory); } catch (IOException e) { <FILL_ME> }  File packageDirectory = new File(nodeModulesDirectory, ""package""); try { extractFile(archive, nodeModulesDirectory); } catch (ArchiveExtractionException e) { if (e.getCause() instanceof EOFException) { // https://github.com/eirslett/frontend-maven-plugin/issues/794 // The downloading was probably interrupted and archive file is incomplete: // delete it to retry from scratch this.logger.error(""The archive file { } is corrupted and will be deleted. ""
                            + ""Please try the build again."", archive.getPath()); archive.delete(); if (packageDirectory.exists()) { FileUtils.deleteDirectory(packageDirectory); } }  throw e; }  // handles difference between old and new download root (nodejs.org/dist/npm and // registry.npmjs.org) // see https://github.com/eirslett/frontend-maven-plugin/issues/65#issuecomment-52024254 if (packageDirectory.exists() && !corepackDirectory.exists()) { if (!packageDirectory.renameTo(corepackDirectory)) { <FILL_ME> FileUtils.copyDirectory(packageDirectory, corepackDirectory); } }   } catch (DownloadException e) { throw new InstallationException(""Could not download corepack"", e); } catch (ArchiveExtractionException e) { throw new InstallationException(""Could not extract the corepack archive"", e); } catch (IOException e) { throw new InstallationException(""Could not copy corepack"", e); } }  private void linkExecutable() throws InstallationException{ File nodeInstallDirectory = getNodeInstallDirectory(); File corepackExecutable = new File(nodeInstallDirectory, ""corepack"");  if (corepackExecutable.exists()) { <FILL_ME> <FILL_ME> return; }  NodeExecutorConfig executorConfig = new InstallNodeExecutorConfig(this.config); File corepackJsExecutable = executorConfig.getCorepackPath();  if (!corepackJsExecutable.exists()) { throw new InstallationException(""Could not link to corepack executable, no corepack installation found.""); }  this.logger.info(""No corepack executable found, creating symbolic link to { } ."", corepackJsExecutable.toPath());  try { Files.createSymbolicLink(corepackExecutable.toPath(), corepackJsExecutable.toPath()); } catch (IOException e) { throw new InstallationException(""Could not create symbolic link for corepack executable."", e); } }  private void linkExecutableWindows() throws InstallationException{ File nodeInstallDirectory = getNodeInstallDirectory(); File corepackExecutable = new File(nodeInstallDirectory, ""corepack.cmd"");  if (corepackExecutable.exists()) { return; }  NodeExecutorConfig executorConfig = new InstallNodeExecutorConfig(this.config); File corepackJsExecutable = executorConfig.getCorepackPath();  if (!corepackJsExecutable.exists()) { throw new InstallationException(""Could not link to corepack executable, no corepack installation found.""); }  this.logger.info(""No corepack executable found, creating proxy script to { } ."", corepackJsExecutable.toPath());  Path nodePath = executorConfig.getNodePath().toPath(); Path relativeNodePath = nodeInstallDirectory.toPath().relativize(nodePath); Path relativeCorepackPath = nodeInstallDirectory.toPath().relativize(corepackJsExecutable.toPath());  // Create a script that will proxy any commands passed into it to the corepack executable. String scriptContents = new StringBuilder()
                .append("":: Created by frontend-maven-plugin, please don't edit manually.\r\n"")
                .append(""@ECHO OFF\r\n"")
                .append(""\r\n"")
                .append(""SETLOCAL\r\n"")
                .append(""\r\n"")
                .append(String.format(""SET \""NODE_EXE=%%~dp0\\%s\""\r\n"", relativeNodePath))
                .append(String.format(""SET \""COREPACK_CLI_JS=%%~dp0\\%s\""\r\n"", relativeCorepackPath))
                .append(""\r\n"")
                .append(""\""%NODE_EXE%\"" \""%COREPACK_CLI_JS%\"" %*"")
                .toString();  try { BufferedWriter writer = new BufferedWriter(new FileWriter(corepackExecutable)); writer.write(scriptContents); writer.close(); } catch (IOException e) { throw new InstallationException(""Could not create proxy script for corepack executable."", e); } }  private File getNodeInstallDirectory() { File installDirectory = new File(this.config.getInstallDirectory(), NodeInstaller.INSTALL_PATH); if (!installDirectory.exists()) { this.logger.debug(""Creating install directory { } "", installDirectory); installDirectory.mkdirs(); } return installDirectory; }  private void extractFile(File archive, File destinationDirectory) throws ArchiveExtractionException { this.logger.info(""Unpacking { } into { } "", archive, destinationDirectory); this.archiveExtractor.extract(archive.getPath(), destinationDirectory.getPath()); }  private void downloadFileIfMissing(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException { if (!destination.exists()) { downloadFile(downloadUrl, destination, userName, password, httpHeaders); } }  private void downloadFile(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException { this.logger.info(""Downloading { } to { } "", downloadUrl, destination); this.fileDownloader.download(downloadUrl, destination.getPath(), userName, password, httpHeaders); } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/CorepackRunner.java,"package com.github.eirslett.maven.plugins.frontend.lib;

public interface CorepackRunner extends NodeTaskRunner {}

final class DefaultCorepackRunner extends NodeTaskExecutor implements CorepackRunner {
    static final String TASK_NAME = ""corepack"";

    public DefaultCorepackRunner(NodeExecutorConfig config) {
        super(config, TASK_NAME, config.getCorepackPath().getAbsolutePath());

        if (!config.getCorepackPath().exists()) {
            setTaskLocation(config.getCorepackPath().getAbsolutePath());
        }
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public interface CorepackRunner extends NodeTaskRunner { } final class DefaultCorepackRunner extends NodeTaskExecutor implements CorepackRunner { static final String TASK_NAME = ""corepack""; public DefaultCorepackRunner(NodeExecutorConfig config) { super(config, TASK_NAME, config.getCorepackPath().getAbsolutePath()); if (!config.getCorepackPath().exists()) { setTaskLocation(config.getCorepackPath().getAbsolutePath()); } } }",0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public interface CorepackRunner extends NodeTaskRunner { } final class DefaultCorepackRunner extends NodeTaskExecutor implements CorepackRunner { static final String TASK_NAME = ""corepack""; public DefaultCorepackRunner(NodeExecutorConfig config) { super(config, TASK_NAME, config.getCorepackPath().getAbsolutePath()); if (!config.getCorepackPath().exists()) { setTaskLocation(config.getCorepackPath().getAbsolutePath()); } } } ","package com.github.eirslett.maven.plugins.frontend.lib;  public interface CorepackRunner extends NodeTaskRunner { }  final class DefaultCorepackRunner extends NodeTaskExecutor implements CorepackRunner { static final String TASK_NAME = ""corepack"";  public DefaultCorepackRunner(NodeExecutorConfig config) { super(config, TASK_NAME, config.getCorepackPath().getAbsolutePath());  if (!config.getCorepackPath().exists()) { setTaskLocation(config.getCorepackPath().getAbsolutePath()); } } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/DirectoryCacheResolver.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import java.io.File;

public class DirectoryCacheResolver implements CacheResolver {

  private final File cacheDirectory;

  public DirectoryCacheResolver(File cacheDirectory) {
    this.cacheDirectory = cacheDirectory;
  }

  @Override
  public File resolve(CacheDescriptor cacheDescriptor) {
    if (!cacheDirectory.exists()) {
      cacheDirectory.mkdirs();
    }

    StringBuilder filename = new StringBuilder()
        .append(cacheDescriptor.getName())
        .append(""-"")
        .append(cacheDescriptor.getVersion());
    if (cacheDescriptor.getClassifier() != null) {
      filename.append(""-"").append(cacheDescriptor.getClassifier());
    }
    filename.append(""."").append(cacheDescriptor.getExtension());
    return new File(cacheDirectory, filename.toString());
  }

}
","package com.github.eirslett.maven.plugins.frontend.lib; public class DirectoryCacheResolver implements CacheResolver { private final File cacheDirectory; public DirectoryCacheResolver(File cacheDirectory) { this.cacheDirectory = cacheDirectory; } @Override
  public File resolve(CacheDescriptor cacheDescriptor) { if (!cacheDirectory.exists()) { cacheDirectory.mkdirs(); } StringBuilder filename = new StringBuilder()
        .append(cacheDescriptor.getName())
        .append(""-"")
        .append(cacheDescriptor.getVersion()); if (cacheDescriptor.getClassifier() != null) { filename.append(""-"").append(cacheDescriptor.getClassifier()); } filename.append(""."").append(cacheDescriptor.getExtension()); return new File(cacheDirectory, filename.toString()); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public class DirectoryCacheResolver implements CacheResolver { private final File cacheDirectory; public DirectoryCacheResolver(File cacheDirectory) { this.cacheDirectory = cacheDirectory; } @Override
  public File resolve(CacheDescriptor cacheDescriptor) { if (!cacheDirectory.exists()) { cacheDirectory.mkdirs(); } StringBuilder filename = new StringBuilder()
        .append(cacheDescriptor.getName())
        .append(""-"")
        .append(cacheDescriptor.getVersion()); if (cacheDescriptor.getClassifier() != null) { filename.append(""-"").append(cacheDescriptor.getClassifier()); } filename.append(""."").append(cacheDescriptor.getExtension()); return new File(cacheDirectory, filename.toString()); } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import java.io.File;  public class DirectoryCacheResolver implements CacheResolver {  private final File cacheDirectory;  public DirectoryCacheResolver(File cacheDirectory) { this.cacheDirectory = cacheDirectory; }  @Override
  public File resolve(CacheDescriptor cacheDescriptor) { if (!cacheDirectory.exists()) { cacheDirectory.mkdirs(); }  StringBuilder filename = new StringBuilder()
        .append(cacheDescriptor.getName())
        .append(""-"")
        .append(cacheDescriptor.getVersion()); if (cacheDescriptor.getClassifier() != null) { filename.append(""-"").append(cacheDescriptor.getClassifier()); } filename.append(""."").append(cacheDescriptor.getExtension()); return new File(cacheDirectory, filename.toString()); }  }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/EmberRunner.java,"package com.github.eirslett.maven.plugins.frontend.lib;

public interface EmberRunner extends NodeTaskRunner {}

final class DefaultEmberRunner extends NodeTaskExecutor implements EmberRunner {

    private static final String TASK_LOCATION = ""node_modules/ember-cli/bin/ember"";

    DefaultEmberRunner(NodeExecutorConfig config) {
        super(config, TASK_LOCATION);
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public interface EmberRunner extends NodeTaskRunner { } final class DefaultEmberRunner extends NodeTaskExecutor implements EmberRunner { private static final String TASK_LOCATION = ""node_modules/ember-cli/bin/ember""; DefaultEmberRunner(NodeExecutorConfig config) { super(config, TASK_LOCATION); } }",0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public interface EmberRunner extends NodeTaskRunner { } final class DefaultEmberRunner extends NodeTaskExecutor implements EmberRunner { private static final String TASK_LOCATION = ""node_modules/ember-cli/bin/ember""; DefaultEmberRunner(NodeExecutorConfig config) { super(config, TASK_LOCATION); } } ","package com.github.eirslett.maven.plugins.frontend.lib;  public interface EmberRunner extends NodeTaskRunner { }  final class DefaultEmberRunner extends NodeTaskExecutor implements EmberRunner {  private static final String TASK_LOCATION = ""node_modules/ember-cli/bin/ember"";  DefaultEmberRunner(NodeExecutorConfig config) { super(config, TASK_LOCATION); } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/FileDownloader.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.Map;

import org.apache.commons.io.IOUtils;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.http.HttpHost;
import org.apache.http.auth.AuthScope;
import org.apache.http.auth.UsernamePasswordCredentials;
import org.apache.http.client.AuthCache;
import org.apache.http.client.CredentialsProvider;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.protocol.HttpClientContext;
import org.apache.http.impl.auth.BasicScheme;
import org.apache.http.impl.client.BasicAuthCache;
import org.apache.http.impl.client.BasicCredentialsProvider;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.codehaus.plexus.util.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig.Proxy;

final class DownloadException extends Exception {
    public DownloadException(String message){
        super(message);
    }
    DownloadException(String message, Throwable cause) {
        super(message, cause);
    }
}

interface FileDownloader {
    void download(String downloadUrl, String destination, String userName, String password, Map<String, String> header) throws DownloadException;
}

final class DefaultFileDownloader implements FileDownloader {
    private static final Logger LOGGER = LoggerFactory.getLogger(FileDownloader.class);

    private final ProxyConfig proxyConfig;

    public DefaultFileDownloader(ProxyConfig proxyConfig){
        this.proxyConfig = proxyConfig;
    }

    @Override
    public void download(String downloadUrl, String destination, String userName, String password, Map<String, String> httpHeaders) throws DownloadException {
        // force tls to 1.2 since github removed weak cryptographic standards
        // https://blog.github.com/2018-02-02-weak-cryptographic-standards-removal-notice/
        System.setProperty(""https.protocols"", ""TLSv1.2"");
        String fixedDownloadUrl = downloadUrl;
        try {
            fixedDownloadUrl = FilenameUtils.separatorsToUnix(fixedDownloadUrl);
            URI downloadURI = new URI(fixedDownloadUrl);
            if (""file"".equalsIgnoreCase(downloadURI.getScheme())) {
                FileUtils.copyFile(new File(downloadURI), new File(destination));
            }
            else {
                CloseableHttpResponse response = execute(fixedDownloadUrl, userName, password, httpHeaders);
                int statusCode = response.getStatusLine().getStatusCode();
                if(statusCode != 200){
                    throw new DownloadException(""Got error code ""+ statusCode +"" from the server."");
                }
                
                byte[] data = IOUtils.toByteArray(response.getEntity().getContent());
                new File(FilenameUtils.getFullPathNoEndSeparator(destination)).mkdirs();
                FileUtils.writeByteArrayToFile(new File(destination), data);
            }
        } catch (IOException | URISyntaxException e) {
            throw new DownloadException(""Could not download "" + fixedDownloadUrl, e);
        }
    }

    private CloseableHttpResponse execute(String requestUrl, String userName, String password, Map<String, String> httpHeaders) throws IOException {
        final HttpGet request = new HttpGet(requestUrl);
        final CredentialsProvider credentialsProvider = new BasicCredentialsProvider();

        final Proxy proxy = proxyConfig.getProxyForUrl(requestUrl);
        if (proxy != null) {
            LOGGER.info(""Downloading via proxy "" + proxy.toString());

            final RequestConfig requestConfig = RequestConfig.custom()
                .setProxy(new HttpHost(proxy.host, proxy.port))
                .build();
            request.setConfig(requestConfig);

            if (proxy.useAuthentication()) {
                credentialsProvider.setCredentials(
                    new AuthScope(proxy.host, proxy.port),
                    new UsernamePasswordCredentials(proxy.username, proxy.password));
            }
        } else {
            LOGGER.info(""No proxy was configured, downloading directly"");
        }
        
        if (httpHeaders != null) {
            for (Map.Entry<String, String> header : httpHeaders.entrySet()) {
                LOGGER.info(""Using HTTP-Header ("" + header.getKey() + "") from settings.xml"");
                request.addHeader(header.getKey(), header.getValue());
            }
        }

        if (StringUtils.isNotEmpty(userName) && StringUtils.isNotEmpty(password)) {
            LOGGER.info(""Using credentials ("" + userName + "") from settings.xml"");
            // Auth target host
            URL targetUrl = new URL(requestUrl);
            credentialsProvider.setCredentials(
                new AuthScope(targetUrl.getHost(), targetUrl.getPort()),
                new UsernamePasswordCredentials(userName, password));
            final HttpClientContext localContext = makeLocalContext(targetUrl);

            return buildHttpClient(credentialsProvider)
                .execute(request, localContext);
        }

        return buildHttpClient(credentialsProvider).execute(request);
    }

    private HttpClientContext makeLocalContext(URL requestUrl) {
        // Auth target host
        HttpHost target = new HttpHost (requestUrl.getHost(), requestUrl.getPort(), requestUrl.getProtocol());
        // Create AuthCache instance
        AuthCache authCache = new BasicAuthCache();
        // Generate BASIC scheme object and add it to the local auth cache
        BasicScheme basicAuth = new BasicScheme();
        authCache.put(target, basicAuth);
        // Add AuthCache to the execution context
        HttpClientContext localContext = HttpClientContext.create();
        localContext.setAuthCache(authCache);
        return localContext;
    }

    private CloseableHttpClient buildHttpClient(CredentialsProvider credentialsProvider) {
        return HttpClients.custom()
                .disableContentCompression()
                .useSystemProperties()
                .setDefaultCredentialsProvider(credentialsProvider)
                .build();
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; final class DownloadException extends Exception { public DownloadException(String message){ super(message); } DownloadException(String message, Throwable cause) { super(message, cause); } } interface FileDownloader { void download(String downloadUrl, String destination, String userName, String password, Map<String, String> header) throws DownloadException; } final class DefaultFileDownloader implements FileDownloader { private static final Logger LOGGER = LoggerFactory.getLogger(FileDownloader.class); private final ProxyConfig proxyConfig; public DefaultFileDownloader(ProxyConfig proxyConfig){ this.proxyConfig = proxyConfig; } @Override
    public void download(String downloadUrl, String destination, String userName, String password, Map<String, String> httpHeaders) throws DownloadException { System.setProperty(""https.protocols"", ""TLSv1.2""); String fixedDownloadUrl = downloadUrl; try { fixedDownloadUrl = FilenameUtils.separatorsToUnix(fixedDownloadUrl); URI downloadURI = new URI(fixedDownloadUrl); if (""file"".equalsIgnoreCase(downloadURI.getScheme())) { FileUtils.copyFile(new File(downloadURI), new File(destination)); } else { CloseableHttpResponse response = execute(fixedDownloadUrl, userName, password, httpHeaders); int statusCode = response.getStatusLine().getStatusCode(); if(statusCode != 200){ throw new DownloadException(""Got error code ""+ statusCode +"" from the server.""); } byte[] data = IOUtils.toByteArray(response.getEntity().getContent()); new File(FilenameUtils.getFullPathNoEndSeparator(destination)).mkdirs(); FileUtils.writeByteArrayToFile(new File(destination), data); } } catch (IOException | URISyntaxException e) { throw new DownloadException(""Could not download "" + fixedDownloadUrl, e); } } private CloseableHttpResponse execute(String requestUrl, String userName, String password, Map<String, String> httpHeaders) throws IOException { final HttpGet request = new HttpGet(requestUrl); final CredentialsProvider credentialsProvider = new BasicCredentialsProvider(); final Proxy proxy = proxyConfig.getProxyForUrl(requestUrl); if (proxy != null) { final RequestConfig requestConfig = RequestConfig.custom()
                .setProxy(new HttpHost(proxy.host, proxy.port))
                .build(); request.setConfig(requestConfig); if (proxy.useAuthentication()) { credentialsProvider.setCredentials(
                    new AuthScope(proxy.host, proxy.port),
                    new UsernamePasswordCredentials(proxy.username, proxy.password)); } } else { } if (httpHeaders != null) { for (Map.Entry<String, String> header : httpHeaders.entrySet()) { request.addHeader(header.getKey(), header.getValue()); } } if (StringUtils.isNotEmpty(userName) && StringUtils.isNotEmpty(password)) { URL targetUrl = new URL(requestUrl); credentialsProvider.setCredentials(
                new AuthScope(targetUrl.getHost(), targetUrl.getPort()),
                new UsernamePasswordCredentials(userName, password)); final HttpClientContext localContext = makeLocalContext(targetUrl); return buildHttpClient(credentialsProvider)
                .execute(request, localContext); } return buildHttpClient(credentialsProvider).execute(request); } private HttpClientContext makeLocalContext(URL requestUrl) { HttpHost target = new HttpHost (requestUrl.getHost(), requestUrl.getPort(), requestUrl.getProtocol()); AuthCache authCache = new BasicAuthCache(); BasicScheme basicAuth = new BasicScheme(); authCache.put(target, basicAuth); HttpClientContext localContext = HttpClientContext.create(); localContext.setAuthCache(authCache); return localContext; } private CloseableHttpClient buildHttpClient(CredentialsProvider credentialsProvider) { return HttpClients.custom()
                .disableContentCompression()
                .useSystemProperties()
                .setDefaultCredentialsProvider(credentialsProvider)
                .build(); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; final class DownloadException extends Exception { public DownloadException(String message){ super(message); } DownloadException(String message, Throwable cause) { super(message, cause); } } interface FileDownloader { void download(String downloadUrl, String destination, String userName, String password, Map<String, String> header) throws DownloadException; } final class DefaultFileDownloader implements FileDownloader { private static final Logger LOGGER = LoggerFactory.getLogger(FileDownloader.class); private final ProxyConfig proxyConfig; public DefaultFileDownloader(ProxyConfig proxyConfig){ this.proxyConfig = proxyConfig; } @Override
    public void download(String downloadUrl, String destination, String userName, String password, Map<String, String> httpHeaders) throws DownloadException { System.setProperty(""https.protocols"", ""TLSv1.2""); String fixedDownloadUrl = downloadUrl; try { fixedDownloadUrl = FilenameUtils.separatorsToUnix(fixedDownloadUrl); URI downloadURI = new URI(fixedDownloadUrl); if (""file"".equalsIgnoreCase(downloadURI.getScheme())) { FileUtils.copyFile(new File(downloadURI), new File(destination)); } else { <FILL_ME> CloseableHttpResponse response = execute(fixedDownloadUrl, userName, password, httpHeaders); int statusCode = response.getStatusLine().getStatusCode(); if(statusCode != 200){ throw new DownloadException(""Got error code ""+ statusCode +"" from the server.""); } byte[] data = IOUtils.toByteArray(response.getEntity().getContent()); new File(FilenameUtils.getFullPathNoEndSeparator(destination)).mkdirs(); FileUtils.writeByteArrayToFile(new File(destination), data); } } catch (IOException | URISyntaxException e) { throw new DownloadException(""Could not download "" + fixedDownloadUrl, e); } } private CloseableHttpResponse execute(String requestUrl, String userName, String password, Map<String, String> httpHeaders) throws IOException { final HttpGet request = new HttpGet(requestUrl); final CredentialsProvider credentialsProvider = new BasicCredentialsProvider(); final Proxy proxy = proxyConfig.getProxyForUrl(requestUrl); if (proxy != null) { <FILL_ME> final RequestConfig requestConfig = RequestConfig.custom()
                .setProxy(new HttpHost(proxy.host, proxy.port))
                .build(); request.setConfig(requestConfig); if (proxy.useAuthentication()) { credentialsProvider.setCredentials(
                    new AuthScope(proxy.host, proxy.port),
                    new UsernamePasswordCredentials(proxy.username, proxy.password)); } } else { } if (httpHeaders != null) { for (Map.Entry<String, String> header : httpHeaders.entrySet()) { <FILL_ME> request.addHeader(header.getKey(), header.getValue()); } } if (StringUtils.isNotEmpty(userName) && StringUtils.isNotEmpty(password)) { <FILL_ME> URL targetUrl = new URL(requestUrl); credentialsProvider.setCredentials(
                new AuthScope(targetUrl.getHost(), targetUrl.getPort()),
                new UsernamePasswordCredentials(userName, password)); final HttpClientContext localContext = makeLocalContext(targetUrl); return buildHttpClient(credentialsProvider)
                .execute(request, localContext); } return buildHttpClient(credentialsProvider).execute(request); } private HttpClientContext makeLocalContext(URL requestUrl) { HttpHost target = new HttpHost (requestUrl.getHost(), requestUrl.getPort(), requestUrl.getProtocol()); AuthCache authCache = new BasicAuthCache(); BasicScheme basicAuth = new BasicScheme(); authCache.put(target, basicAuth); HttpClientContext localContext = HttpClientContext.create(); localContext.setAuthCache(authCache); return localContext; } private CloseableHttpClient buildHttpClient(CredentialsProvider credentialsProvider) { return HttpClients.custom()
                .disableContentCompression()
                .useSystemProperties()
                .setDefaultCredentialsProvider(credentialsProvider)
                .build(); } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import java.io.File; import java.io.IOException; import java.net.URI; import java.net.URISyntaxException; import java.net.URL; import java.util.Map; 
import org.apache.commons.io.IOUtils; import org.apache.commons.io.FileUtils; import org.apache.commons.io.FilenameUtils; import org.apache.http.HttpHost; import org.apache.http.auth.AuthScope; import org.apache.http.auth.UsernamePasswordCredentials; import org.apache.http.client.AuthCache; import org.apache.http.client.CredentialsProvider; import org.apache.http.client.config.RequestConfig; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.protocol.HttpClientContext; import org.apache.http.impl.auth.BasicScheme; import org.apache.http.impl.client.BasicAuthCache; import org.apache.http.impl.client.BasicCredentialsProvider; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.codehaus.plexus.util.StringUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory; 
import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig.Proxy;  final class DownloadException extends Exception { public DownloadException(String message){ super(message); } DownloadException(String message, Throwable cause) { super(message, cause); } }  interface FileDownloader { void download(String downloadUrl, String destination, String userName, String password, Map<String, String> header) throws DownloadException; }  final class DefaultFileDownloader implements FileDownloader { private static final Logger LOGGER = LoggerFactory.getLogger(FileDownloader.class);  private final ProxyConfig proxyConfig;  public DefaultFileDownloader(ProxyConfig proxyConfig){ this.proxyConfig = proxyConfig; }  @Override
    public void download(String downloadUrl, String destination, String userName, String password, Map<String, String> httpHeaders) throws DownloadException { // force tls to 1.2 since github removed weak cryptographic standards // https://blog.github.com/2018-02-02-weak-cryptographic-standards-removal-notice/ System.setProperty(""https.protocols"", ""TLSv1.2""); String fixedDownloadUrl = downloadUrl; try { fixedDownloadUrl = FilenameUtils.separatorsToUnix(fixedDownloadUrl); URI downloadURI = new URI(fixedDownloadUrl); if (""file"".equalsIgnoreCase(downloadURI.getScheme())) { FileUtils.copyFile(new File(downloadURI), new File(destination)); } else { <FILL_ME> CloseableHttpResponse response = execute(fixedDownloadUrl, userName, password, httpHeaders); int statusCode = response.getStatusLine().getStatusCode(); if(statusCode != 200){ throw new DownloadException(""Got error code ""+ statusCode +"" from the server.""); }                  byte[] data = IOUtils.toByteArray(response.getEntity().getContent()); new File(FilenameUtils.getFullPathNoEndSeparator(destination)).mkdirs(); FileUtils.writeByteArrayToFile(new File(destination), data); } } catch (IOException | URISyntaxException e) { throw new DownloadException(""Could not download "" + fixedDownloadUrl, e); } }  private CloseableHttpResponse execute(String requestUrl, String userName, String password, Map<String, String> httpHeaders) throws IOException { final HttpGet request = new HttpGet(requestUrl); final CredentialsProvider credentialsProvider = new BasicCredentialsProvider();  final Proxy proxy = proxyConfig.getProxyForUrl(requestUrl); if (proxy != null) { <FILL_ME>  final RequestConfig requestConfig = RequestConfig.custom()
                .setProxy(new HttpHost(proxy.host, proxy.port))
                .build(); request.setConfig(requestConfig);  if (proxy.useAuthentication()) { credentialsProvider.setCredentials(
                    new AuthScope(proxy.host, proxy.port),
                    new UsernamePasswordCredentials(proxy.username, proxy.password)); } } else { }          if (httpHeaders != null) { for (Map.Entry<String, String> header : httpHeaders.entrySet()) { <FILL_ME> request.addHeader(header.getKey(), header.getValue()); } }  if (StringUtils.isNotEmpty(userName) && StringUtils.isNotEmpty(password)) { <FILL_ME> // Auth target host URL targetUrl = new URL(requestUrl); credentialsProvider.setCredentials(
                new AuthScope(targetUrl.getHost(), targetUrl.getPort()),
                new UsernamePasswordCredentials(userName, password)); final HttpClientContext localContext = makeLocalContext(targetUrl);  return buildHttpClient(credentialsProvider)
                .execute(request, localContext); }  return buildHttpClient(credentialsProvider).execute(request); }  private HttpClientContext makeLocalContext(URL requestUrl) { // Auth target host HttpHost target = new HttpHost (requestUrl.getHost(), requestUrl.getPort(), requestUrl.getProtocol()); // Create AuthCache instance AuthCache authCache = new BasicAuthCache(); // Generate BASIC scheme object and add it to the local auth cache BasicScheme basicAuth = new BasicScheme(); authCache.put(target, basicAuth); // Add AuthCache to the execution context HttpClientContext localContext = HttpClientContext.create(); localContext.setAuthCache(authCache); return localContext; }  private CloseableHttpClient buildHttpClient(CredentialsProvider credentialsProvider) { return HttpClients.custom()
                .disableContentCompression()
                .useSystemProperties()
                .setDefaultCredentialsProvider(credentialsProvider)
                .build(); } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/FrontendException.java,"package com.github.eirslett.maven.plugins.frontend.lib;

public class FrontendException extends Exception {

  FrontendException(String message) {
    super(message);
  }

  FrontendException(String message, Throwable cause){
    super(message, cause);
  }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public class FrontendException extends Exception { FrontendException(String message) { super(message); } FrontendException(String message, Throwable cause){ super(message, cause); } }",0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public class FrontendException extends Exception { FrontendException(String message) { super(message); } FrontendException(String message, Throwable cause){ super(message, cause); } } ","package com.github.eirslett.maven.plugins.frontend.lib;  public class FrontendException extends Exception {  FrontendException(String message) { super(message); }  FrontendException(String message, Throwable cause){ super(message, cause); } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/FrontendPluginFactory.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import java.io.File;

public final class FrontendPluginFactory {

    private static final Platform defaultPlatform = Platform.guess();
    private static final String DEFAULT_CACHE_PATH = ""cache"";

    private final File workingDirectory;
    private final File installDirectory;
    private final CacheResolver cacheResolver;

    public FrontendPluginFactory(File workingDirectory, File installDirectory){
        this(workingDirectory, installDirectory, getDefaultCacheResolver(installDirectory));
    }

    public FrontendPluginFactory(File workingDirectory, File installDirectory, CacheResolver cacheResolver){
        this.workingDirectory = workingDirectory;
        this.installDirectory = installDirectory;
        this.cacheResolver = cacheResolver;
    }

    public BunInstaller getBunInstaller(ProxyConfig proxy) {
        return new BunInstaller(getInstallConfig(), new DefaultArchiveExtractor(), new DefaultFileDownloader(proxy));
    }
    public NodeInstaller getNodeInstaller(ProxyConfig proxy) {
        return new NodeInstaller(getInstallConfig(), new DefaultArchiveExtractor(), new DefaultFileDownloader(proxy));
    }

    public NPMInstaller getNPMInstaller(ProxyConfig proxy) {
        return new NPMInstaller(getInstallConfig(), new DefaultArchiveExtractor(), new DefaultFileDownloader(proxy));
    }

    public CorepackInstaller getCorepackInstaller(ProxyConfig proxy) {
        return new CorepackInstaller(getInstallConfig(), new DefaultArchiveExtractor(), new DefaultFileDownloader(proxy));
    }

    public PnpmInstaller getPnpmInstaller(ProxyConfig proxy) {
        return new PnpmInstaller(getInstallConfig(), new DefaultArchiveExtractor(), new DefaultFileDownloader(proxy));
    }

    public YarnInstaller getYarnInstaller(ProxyConfig proxy) {
        return new YarnInstaller(getInstallConfig(), new DefaultArchiveExtractor(), new DefaultFileDownloader(proxy));
    }

    public BowerRunner getBowerRunner(ProxyConfig proxy) {
        return new DefaultBowerRunner(getExecutorConfig(), proxy);
    }

    public BunRunner getBunRunner(ProxyConfig proxy, String npmRegistryURL) {
        return new DefaultBunRunner(new InstallBunExecutorConfig(getInstallConfig()), proxy, npmRegistryURL);
    }

    public JspmRunner getJspmRunner() {
        return new DefaultJspmRunner(getExecutorConfig());
    }

    public NpmRunner getNpmRunner(ProxyConfig proxy, String npmRegistryURL) {
        return new DefaultNpmRunner(getExecutorConfig(), proxy, npmRegistryURL);
    }

    public CorepackRunner getCorepackRunner() {
        return new DefaultCorepackRunner(getExecutorConfig());
    }

    public PnpmRunner getPnpmRunner(ProxyConfig proxyConfig, String npmRegistryUrl) {
        return new DefaultPnpmRunner(getExecutorConfig(), proxyConfig, npmRegistryUrl);
    }

    public NpxRunner getNpxRunner(ProxyConfig proxy, String npmRegistryURL) {
        return new DefaultNpxRunner(getExecutorConfig(), proxy, npmRegistryURL);
    }

    public YarnRunner getYarnRunner(ProxyConfig proxy, String npmRegistryURL, boolean isYarnBerry) {
        return new DefaultYarnRunner(new InstallYarnExecutorConfig(getInstallConfig(), isYarnBerry), proxy, npmRegistryURL);
    }

    public GruntRunner getGruntRunner(){
        return new DefaultGruntRunner(getExecutorConfig());
    }

    public EmberRunner getEmberRunner() {
        return new DefaultEmberRunner(getExecutorConfig());
    }

    public KarmaRunner getKarmaRunner(){
        return new DefaultKarmaRunner(getExecutorConfig());
    }

    public GulpRunner getGulpRunner(){
        return new DefaultGulpRunner(getExecutorConfig());
    }

    public WebpackRunner getWebpackRunner(){
        return new DefaultWebpackRunner(getExecutorConfig());
    }

    private NodeExecutorConfig getExecutorConfig() {
        return new InstallNodeExecutorConfig(getInstallConfig());
    }

    private InstallConfig getInstallConfig() {
        return new DefaultInstallConfig(installDirectory, workingDirectory, cacheResolver, defaultPlatform);
    }

    private static final CacheResolver getDefaultCacheResolver(File root) {
        return new DirectoryCacheResolver(new File(root, DEFAULT_CACHE_PATH));
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public final class FrontendPluginFactory { private static final Platform defaultPlatform = Platform.guess(); private static final String DEFAULT_CACHE_PATH = ""cache""; private final File workingDirectory; private final File installDirectory; private final CacheResolver cacheResolver; public FrontendPluginFactory(File workingDirectory, File installDirectory){ this(workingDirectory, installDirectory, getDefaultCacheResolver(installDirectory)); } public FrontendPluginFactory(File workingDirectory, File installDirectory, CacheResolver cacheResolver){ this.workingDirectory = workingDirectory; this.installDirectory = installDirectory; this.cacheResolver = cacheResolver; } public BunInstaller getBunInstaller(ProxyConfig proxy) { return new BunInstaller(getInstallConfig(), new DefaultArchiveExtractor(), new DefaultFileDownloader(proxy)); } public NodeInstaller getNodeInstaller(ProxyConfig proxy) { return new NodeInstaller(getInstallConfig(), new DefaultArchiveExtractor(), new DefaultFileDownloader(proxy)); } public NPMInstaller getNPMInstaller(ProxyConfig proxy) { return new NPMInstaller(getInstallConfig(), new DefaultArchiveExtractor(), new DefaultFileDownloader(proxy)); } public CorepackInstaller getCorepackInstaller(ProxyConfig proxy) { return new CorepackInstaller(getInstallConfig(), new DefaultArchiveExtractor(), new DefaultFileDownloader(proxy)); } public PnpmInstaller getPnpmInstaller(ProxyConfig proxy) { return new PnpmInstaller(getInstallConfig(), new DefaultArchiveExtractor(), new DefaultFileDownloader(proxy)); } public YarnInstaller getYarnInstaller(ProxyConfig proxy) { return new YarnInstaller(getInstallConfig(), new DefaultArchiveExtractor(), new DefaultFileDownloader(proxy)); } public BowerRunner getBowerRunner(ProxyConfig proxy) { return new DefaultBowerRunner(getExecutorConfig(), proxy); } public BunRunner getBunRunner(ProxyConfig proxy, String npmRegistryURL) { return new DefaultBunRunner(new InstallBunExecutorConfig(getInstallConfig()), proxy, npmRegistryURL); } public JspmRunner getJspmRunner() { return new DefaultJspmRunner(getExecutorConfig()); } public NpmRunner getNpmRunner(ProxyConfig proxy, String npmRegistryURL) { return new DefaultNpmRunner(getExecutorConfig(), proxy, npmRegistryURL); } public CorepackRunner getCorepackRunner() { return new DefaultCorepackRunner(getExecutorConfig()); } public PnpmRunner getPnpmRunner(ProxyConfig proxyConfig, String npmRegistryUrl) { return new DefaultPnpmRunner(getExecutorConfig(), proxyConfig, npmRegistryUrl); } public NpxRunner getNpxRunner(ProxyConfig proxy, String npmRegistryURL) { return new DefaultNpxRunner(getExecutorConfig(), proxy, npmRegistryURL); } public YarnRunner getYarnRunner(ProxyConfig proxy, String npmRegistryURL, boolean isYarnBerry) { return new DefaultYarnRunner(new InstallYarnExecutorConfig(getInstallConfig(), isYarnBerry), proxy, npmRegistryURL); } public GruntRunner getGruntRunner(){ return new DefaultGruntRunner(getExecutorConfig()); } public EmberRunner getEmberRunner() { return new DefaultEmberRunner(getExecutorConfig()); } public KarmaRunner getKarmaRunner(){ return new DefaultKarmaRunner(getExecutorConfig()); } public GulpRunner getGulpRunner(){ return new DefaultGulpRunner(getExecutorConfig()); } public WebpackRunner getWebpackRunner(){ return new DefaultWebpackRunner(getExecutorConfig()); } private NodeExecutorConfig getExecutorConfig() { return new InstallNodeExecutorConfig(getInstallConfig()); } private InstallConfig getInstallConfig() { return new DefaultInstallConfig(installDirectory, workingDirectory, cacheResolver, defaultPlatform); } private static final CacheResolver getDefaultCacheResolver(File root) { return new DirectoryCacheResolver(new File(root, DEFAULT_CACHE_PATH)); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public final class FrontendPluginFactory { private static final Platform defaultPlatform = Platform.guess(); private static final String DEFAULT_CACHE_PATH = ""cache""; private final File workingDirectory; private final File installDirectory; private final CacheResolver cacheResolver; public FrontendPluginFactory(File workingDirectory, File installDirectory){ this(workingDirectory, installDirectory, getDefaultCacheResolver(installDirectory)); } public FrontendPluginFactory(File workingDirectory, File installDirectory, CacheResolver cacheResolver){ this.workingDirectory = workingDirectory; this.installDirectory = installDirectory; this.cacheResolver = cacheResolver; } public BunInstaller getBunInstaller(ProxyConfig proxy) { return new BunInstaller(getInstallConfig(), new DefaultArchiveExtractor(), new DefaultFileDownloader(proxy)); } public NodeInstaller getNodeInstaller(ProxyConfig proxy) { return new NodeInstaller(getInstallConfig(), new DefaultArchiveExtractor(), new DefaultFileDownloader(proxy)); } public NPMInstaller getNPMInstaller(ProxyConfig proxy) { return new NPMInstaller(getInstallConfig(), new DefaultArchiveExtractor(), new DefaultFileDownloader(proxy)); } public CorepackInstaller getCorepackInstaller(ProxyConfig proxy) { return new CorepackInstaller(getInstallConfig(), new DefaultArchiveExtractor(), new DefaultFileDownloader(proxy)); } public PnpmInstaller getPnpmInstaller(ProxyConfig proxy) { return new PnpmInstaller(getInstallConfig(), new DefaultArchiveExtractor(), new DefaultFileDownloader(proxy)); } public YarnInstaller getYarnInstaller(ProxyConfig proxy) { return new YarnInstaller(getInstallConfig(), new DefaultArchiveExtractor(), new DefaultFileDownloader(proxy)); } public BowerRunner getBowerRunner(ProxyConfig proxy) { return new DefaultBowerRunner(getExecutorConfig(), proxy); } public BunRunner getBunRunner(ProxyConfig proxy, String npmRegistryURL) { return new DefaultBunRunner(new InstallBunExecutorConfig(getInstallConfig()), proxy, npmRegistryURL); } public JspmRunner getJspmRunner() { return new DefaultJspmRunner(getExecutorConfig()); } public NpmRunner getNpmRunner(ProxyConfig proxy, String npmRegistryURL) { return new DefaultNpmRunner(getExecutorConfig(), proxy, npmRegistryURL); } public CorepackRunner getCorepackRunner() { return new DefaultCorepackRunner(getExecutorConfig()); } public PnpmRunner getPnpmRunner(ProxyConfig proxyConfig, String npmRegistryUrl) { return new DefaultPnpmRunner(getExecutorConfig(), proxyConfig, npmRegistryUrl); } public NpxRunner getNpxRunner(ProxyConfig proxy, String npmRegistryURL) { return new DefaultNpxRunner(getExecutorConfig(), proxy, npmRegistryURL); } public YarnRunner getYarnRunner(ProxyConfig proxy, String npmRegistryURL, boolean isYarnBerry) { return new DefaultYarnRunner(new InstallYarnExecutorConfig(getInstallConfig(), isYarnBerry), proxy, npmRegistryURL); } public GruntRunner getGruntRunner(){ return new DefaultGruntRunner(getExecutorConfig()); } public EmberRunner getEmberRunner() { return new DefaultEmberRunner(getExecutorConfig()); } public KarmaRunner getKarmaRunner(){ return new DefaultKarmaRunner(getExecutorConfig()); } public GulpRunner getGulpRunner(){ return new DefaultGulpRunner(getExecutorConfig()); } public WebpackRunner getWebpackRunner(){ return new DefaultWebpackRunner(getExecutorConfig()); } private NodeExecutorConfig getExecutorConfig() { return new InstallNodeExecutorConfig(getInstallConfig()); } private InstallConfig getInstallConfig() { return new DefaultInstallConfig(installDirectory, workingDirectory, cacheResolver, defaultPlatform); } private static final CacheResolver getDefaultCacheResolver(File root) { return new DirectoryCacheResolver(new File(root, DEFAULT_CACHE_PATH)); } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import java.io.File;  public final class FrontendPluginFactory {  private static final Platform defaultPlatform = Platform.guess(); private static final String DEFAULT_CACHE_PATH = ""cache"";  private final File workingDirectory; private final File installDirectory; private final CacheResolver cacheResolver;  public FrontendPluginFactory(File workingDirectory, File installDirectory){ this(workingDirectory, installDirectory, getDefaultCacheResolver(installDirectory)); }  public FrontendPluginFactory(File workingDirectory, File installDirectory, CacheResolver cacheResolver){ this.workingDirectory = workingDirectory; this.installDirectory = installDirectory; this.cacheResolver = cacheResolver; }  public BunInstaller getBunInstaller(ProxyConfig proxy) { return new BunInstaller(getInstallConfig(), new DefaultArchiveExtractor(), new DefaultFileDownloader(proxy)); } public NodeInstaller getNodeInstaller(ProxyConfig proxy) { return new NodeInstaller(getInstallConfig(), new DefaultArchiveExtractor(), new DefaultFileDownloader(proxy)); }  public NPMInstaller getNPMInstaller(ProxyConfig proxy) { return new NPMInstaller(getInstallConfig(), new DefaultArchiveExtractor(), new DefaultFileDownloader(proxy)); }  public CorepackInstaller getCorepackInstaller(ProxyConfig proxy) { return new CorepackInstaller(getInstallConfig(), new DefaultArchiveExtractor(), new DefaultFileDownloader(proxy)); }  public PnpmInstaller getPnpmInstaller(ProxyConfig proxy) { return new PnpmInstaller(getInstallConfig(), new DefaultArchiveExtractor(), new DefaultFileDownloader(proxy)); }  public YarnInstaller getYarnInstaller(ProxyConfig proxy) { return new YarnInstaller(getInstallConfig(), new DefaultArchiveExtractor(), new DefaultFileDownloader(proxy)); }  public BowerRunner getBowerRunner(ProxyConfig proxy) { return new DefaultBowerRunner(getExecutorConfig(), proxy); }  public BunRunner getBunRunner(ProxyConfig proxy, String npmRegistryURL) { return new DefaultBunRunner(new InstallBunExecutorConfig(getInstallConfig()), proxy, npmRegistryURL); }  public JspmRunner getJspmRunner() { return new DefaultJspmRunner(getExecutorConfig()); }  public NpmRunner getNpmRunner(ProxyConfig proxy, String npmRegistryURL) { return new DefaultNpmRunner(getExecutorConfig(), proxy, npmRegistryURL); }  public CorepackRunner getCorepackRunner() { return new DefaultCorepackRunner(getExecutorConfig()); }  public PnpmRunner getPnpmRunner(ProxyConfig proxyConfig, String npmRegistryUrl) { return new DefaultPnpmRunner(getExecutorConfig(), proxyConfig, npmRegistryUrl); }  public NpxRunner getNpxRunner(ProxyConfig proxy, String npmRegistryURL) { return new DefaultNpxRunner(getExecutorConfig(), proxy, npmRegistryURL); }  public YarnRunner getYarnRunner(ProxyConfig proxy, String npmRegistryURL, boolean isYarnBerry) { return new DefaultYarnRunner(new InstallYarnExecutorConfig(getInstallConfig(), isYarnBerry), proxy, npmRegistryURL); }  public GruntRunner getGruntRunner(){ return new DefaultGruntRunner(getExecutorConfig()); }  public EmberRunner getEmberRunner() { return new DefaultEmberRunner(getExecutorConfig()); }  public KarmaRunner getKarmaRunner(){ return new DefaultKarmaRunner(getExecutorConfig()); }  public GulpRunner getGulpRunner(){ return new DefaultGulpRunner(getExecutorConfig()); }  public WebpackRunner getWebpackRunner(){ return new DefaultWebpackRunner(getExecutorConfig()); }  private NodeExecutorConfig getExecutorConfig() { return new InstallNodeExecutorConfig(getInstallConfig()); }  private InstallConfig getInstallConfig() { return new DefaultInstallConfig(installDirectory, workingDirectory, cacheResolver, defaultPlatform); }  private static final CacheResolver getDefaultCacheResolver(File root) { return new DirectoryCacheResolver(new File(root, DEFAULT_CACHE_PATH)); } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/GruntRunner.java,"package com.github.eirslett.maven.plugins.frontend.lib;

public interface GruntRunner extends NodeTaskRunner {}

final class DefaultGruntRunner extends NodeTaskExecutor implements GruntRunner {

    private static final String TASK_LOCATION = ""node_modules/grunt-cli/bin/grunt"";

    DefaultGruntRunner(NodeExecutorConfig config) {
        super(config, TASK_LOCATION);
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public interface GruntRunner extends NodeTaskRunner { } final class DefaultGruntRunner extends NodeTaskExecutor implements GruntRunner { private static final String TASK_LOCATION = ""node_modules/grunt-cli/bin/grunt""; DefaultGruntRunner(NodeExecutorConfig config) { super(config, TASK_LOCATION); } }",0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public interface GruntRunner extends NodeTaskRunner { } final class DefaultGruntRunner extends NodeTaskExecutor implements GruntRunner { private static final String TASK_LOCATION = ""node_modules/grunt-cli/bin/grunt""; DefaultGruntRunner(NodeExecutorConfig config) { super(config, TASK_LOCATION); } } ","package com.github.eirslett.maven.plugins.frontend.lib;  public interface GruntRunner extends NodeTaskRunner { }  final class DefaultGruntRunner extends NodeTaskExecutor implements GruntRunner {  private static final String TASK_LOCATION = ""node_modules/grunt-cli/bin/grunt"";  DefaultGruntRunner(NodeExecutorConfig config) { super(config, TASK_LOCATION); } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/GulpRunner.java,"package com.github.eirslett.maven.plugins.frontend.lib;

public interface GulpRunner  extends NodeTaskRunner {}

final class DefaultGulpRunner extends NodeTaskExecutor implements GulpRunner {
    private static final String TASK_LOCATION = ""node_modules/gulp/bin/gulp.js"";

    DefaultGulpRunner(NodeExecutorConfig config) {
        super(config, TASK_LOCATION);
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public interface GulpRunner  extends NodeTaskRunner { } final class DefaultGulpRunner extends NodeTaskExecutor implements GulpRunner { private static final String TASK_LOCATION = ""node_modules/gulp/bin/gulp.js""; DefaultGulpRunner(NodeExecutorConfig config) { super(config, TASK_LOCATION); } }",0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public interface GulpRunner  extends NodeTaskRunner { } final class DefaultGulpRunner extends NodeTaskExecutor implements GulpRunner { private static final String TASK_LOCATION = ""node_modules/gulp/bin/gulp.js""; DefaultGulpRunner(NodeExecutorConfig config) { super(config, TASK_LOCATION); } } ","package com.github.eirslett.maven.plugins.frontend.lib;  public interface GulpRunner  extends NodeTaskRunner { }  final class DefaultGulpRunner extends NodeTaskExecutor implements GulpRunner { private static final String TASK_LOCATION = ""node_modules/gulp/bin/gulp.js"";  DefaultGulpRunner(NodeExecutorConfig config) { super(config, TASK_LOCATION); } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/InstallConfig.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import java.io.File;

public interface InstallConfig {
  File getInstallDirectory();
  File getWorkingDirectory();
  CacheResolver getCacheResolver();
  Platform getPlatform();
}

final class DefaultInstallConfig implements InstallConfig {

  private final File installDirectory;
  private final File workingDirectory;
  private final CacheResolver cacheResolver;
  private final Platform platform;
  
  public DefaultInstallConfig(File installDirectory,
                              File workingDirectory,
                              CacheResolver cacheResolver,
                              Platform platform) {
    this.installDirectory = installDirectory;
    this.workingDirectory = workingDirectory;
    this.cacheResolver = cacheResolver;
    this.platform = platform;
  }

  @Override
  public File getInstallDirectory() {
    return this.installDirectory;
  }

  @Override
  public File getWorkingDirectory() {
    return this.workingDirectory;
  }
  
  public CacheResolver getCacheResolver() {
    return cacheResolver;
  }

  @Override
  public Platform getPlatform() {
    return this.platform;
  }

}","package com.github.eirslett.maven.plugins.frontend.lib; public interface InstallConfig { File getInstallDirectory(); File getWorkingDirectory(); CacheResolver getCacheResolver(); Platform getPlatform(); } final class DefaultInstallConfig implements InstallConfig { private final File installDirectory; private final File workingDirectory; private final CacheResolver cacheResolver; private final Platform platform; public DefaultInstallConfig(File installDirectory,
                              File workingDirectory,
                              CacheResolver cacheResolver,
                              Platform platform) { this.installDirectory = installDirectory; this.workingDirectory = workingDirectory; this.cacheResolver = cacheResolver; this.platform = platform; } @Override
  public File getInstallDirectory() { return this.installDirectory; } @Override
  public File getWorkingDirectory() { return this.workingDirectory; } public CacheResolver getCacheResolver() { return cacheResolver; } @Override
  public Platform getPlatform() { return this.platform; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public interface InstallConfig { File getInstallDirectory(); File getWorkingDirectory(); CacheResolver getCacheResolver(); Platform getPlatform(); } final class DefaultInstallConfig implements InstallConfig { private final File installDirectory; private final File workingDirectory; private final CacheResolver cacheResolver; private final Platform platform; public DefaultInstallConfig(File installDirectory,
                              File workingDirectory,
                              CacheResolver cacheResolver,
                              Platform platform) { this.installDirectory = installDirectory; this.workingDirectory = workingDirectory; this.cacheResolver = cacheResolver; this.platform = platform; } @Override
  public File getInstallDirectory() { return this.installDirectory; } @Override
  public File getWorkingDirectory() { return this.workingDirectory; } public CacheResolver getCacheResolver() { return cacheResolver; } @Override
  public Platform getPlatform() { return this.platform; } }","package com.github.eirslett.maven.plugins.frontend.lib; 
import java.io.File;  public interface InstallConfig { File getInstallDirectory(); File getWorkingDirectory(); CacheResolver getCacheResolver(); Platform getPlatform(); }  final class DefaultInstallConfig implements InstallConfig {  private final File installDirectory; private final File workingDirectory; private final CacheResolver cacheResolver; private final Platform platform;    public DefaultInstallConfig(File installDirectory,
                              File workingDirectory,
                              CacheResolver cacheResolver,
                              Platform platform) { this.installDirectory = installDirectory; this.workingDirectory = workingDirectory; this.cacheResolver = cacheResolver; this.platform = platform; }  @Override
  public File getInstallDirectory() { return this.installDirectory; }  @Override
  public File getWorkingDirectory() { return this.workingDirectory; }    public CacheResolver getCacheResolver() { return cacheResolver; }  @Override
  public Platform getPlatform() { return this.platform; }  }"
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/InstallationException.java,"package com.github.eirslett.maven.plugins.frontend.lib;

public final class InstallationException extends FrontendException {
    InstallationException(String message){
        super(message);
    }
    InstallationException(String message, Throwable cause){
        super(message, cause);
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public final class InstallationException extends FrontendException { InstallationException(String message){ super(message); } InstallationException(String message, Throwable cause){ super(message, cause); } }",0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public final class InstallationException extends FrontendException { InstallationException(String message){ super(message); } InstallationException(String message, Throwable cause){ super(message, cause); } } ","package com.github.eirslett.maven.plugins.frontend.lib;  public final class InstallationException extends FrontendException { InstallationException(String message){ super(message); } InstallationException(String message, Throwable cause){ super(message, cause); } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/JspmRunner.java,"package com.github.eirslett.maven.plugins.frontend.lib;

public interface JspmRunner extends NodeTaskRunner {}

final class DefaultJspmRunner extends NodeTaskExecutor implements JspmRunner {

    static final String TASK_LOCATION = ""node_modules/jspm/jspm.js"";

    DefaultJspmRunner(NodeExecutorConfig config) {
        super(config, TASK_LOCATION);
    }

}
","package com.github.eirslett.maven.plugins.frontend.lib; public interface JspmRunner extends NodeTaskRunner { } final class DefaultJspmRunner extends NodeTaskExecutor implements JspmRunner { static final String TASK_LOCATION = ""node_modules/jspm/jspm.js""; DefaultJspmRunner(NodeExecutorConfig config) { super(config, TASK_LOCATION); } }",0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public interface JspmRunner extends NodeTaskRunner { } final class DefaultJspmRunner extends NodeTaskExecutor implements JspmRunner { static final String TASK_LOCATION = ""node_modules/jspm/jspm.js""; DefaultJspmRunner(NodeExecutorConfig config) { super(config, TASK_LOCATION); } } ","package com.github.eirslett.maven.plugins.frontend.lib;  public interface JspmRunner extends NodeTaskRunner { }  final class DefaultJspmRunner extends NodeTaskExecutor implements JspmRunner {  static final String TASK_LOCATION = ""node_modules/jspm/jspm.js"";  DefaultJspmRunner(NodeExecutorConfig config) { super(config, TASK_LOCATION); }  }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/KarmaRunner.java,"package com.github.eirslett.maven.plugins.frontend.lib;

public interface KarmaRunner extends NodeTaskRunner {}

final class DefaultKarmaRunner extends NodeTaskExecutor implements KarmaRunner {

    static final String TASK_LOCATION = ""node_modules/karma/bin/karma"";

    DefaultKarmaRunner(NodeExecutorConfig config) {
        super(config, TASK_LOCATION);
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public interface KarmaRunner extends NodeTaskRunner { } final class DefaultKarmaRunner extends NodeTaskExecutor implements KarmaRunner { static final String TASK_LOCATION = ""node_modules/karma/bin/karma""; DefaultKarmaRunner(NodeExecutorConfig config) { super(config, TASK_LOCATION); } }",0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public interface KarmaRunner extends NodeTaskRunner { } final class DefaultKarmaRunner extends NodeTaskExecutor implements KarmaRunner { static final String TASK_LOCATION = ""node_modules/karma/bin/karma""; DefaultKarmaRunner(NodeExecutorConfig config) { super(config, TASK_LOCATION); } } ","package com.github.eirslett.maven.plugins.frontend.lib;  public interface KarmaRunner extends NodeTaskRunner { }  final class DefaultKarmaRunner extends NodeTaskExecutor implements KarmaRunner {  static final String TASK_LOCATION = ""node_modules/karma/bin/karma"";  DefaultKarmaRunner(NodeExecutorConfig config) { super(config, TASK_LOCATION); } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/NPMInstaller.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.EOFException;
import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import org.apache.commons.io.FileUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class NPMInstaller {

    private static final String VERSION = ""version"";

    public static final String DEFAULT_NPM_DOWNLOAD_ROOT = ""https://registry.npmjs.org/npm/-/"";

    private static final Object LOCK = new Object();

    private String nodeVersion, npmVersion, npmDownloadRoot, userName, password;

    private Map<String, String> httpHeaders;
    
    private final Logger logger;

    private final InstallConfig config;

    private final ArchiveExtractor archiveExtractor;

    private final FileDownloader fileDownloader;

    NPMInstaller(InstallConfig config, ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) {
        this.logger = LoggerFactory.getLogger(getClass());
        this.config = config;
        this.archiveExtractor = archiveExtractor;
        this.fileDownloader = fileDownloader;
    }

    public NPMInstaller setNodeVersion(String nodeVersion) {
        this.nodeVersion = nodeVersion;
        return this;
    }

    public NPMInstaller setNpmVersion(String npmVersion) {
        this.npmVersion = npmVersion;
        return this;
    }

    public NPMInstaller setNpmDownloadRoot(String npmDownloadRoot) {
        this.npmDownloadRoot = npmDownloadRoot;
        return this;
    }

    public NPMInstaller setUserName(String userName) {
        this.userName = userName;
        return this;
    }

    public NPMInstaller setPassword(String password) {
        this.password = password;
        return this;
    }

    public NPMInstaller setHttpHeaders(Map<String, String> httpHeaders) {
        this.httpHeaders = httpHeaders;
        return this;
    }

    private boolean npmProvided() throws InstallationException {
        if (""provided"".equals(this.npmVersion)) {
            if (Integer.parseInt(this.nodeVersion.replace(""v"", """").split(""[.]"")[0]) < 4) {
                throw new InstallationException(
                    ""NPM version is '"" + this.npmVersion + ""' but Node didn't include NPM prior to v4.0.0"");
            }
            return true;
        }
        return false;

    }

    public void install() throws InstallationException {
        // use static lock object for a synchronized block
        synchronized (LOCK) {
            if (this.npmDownloadRoot == null || this.npmDownloadRoot.isEmpty()) {
                this.npmDownloadRoot = DEFAULT_NPM_DOWNLOAD_ROOT;
            }
            if (!npmProvided() && !npmIsAlreadyInstalled()) {
                installNpm();
            }
            copyNpmScripts();
        }
    }

    private boolean npmIsAlreadyInstalled() {
        try {
            final File npmPackageJson = new File(
                this.config.getInstallDirectory() + Utils.normalize(""/node/node_modules/npm/package.json""));
            if (npmPackageJson.exists()) {
                HashMap<String, Object> data = new ObjectMapper().readValue(npmPackageJson, HashMap.class);
                if (data.containsKey(VERSION)) {
                    final String foundNpmVersion = data.get(VERSION).toString();
                    if (foundNpmVersion.equals(this.npmVersion)) {
                        this.logger.info(""NPM {} is already installed."", foundNpmVersion);
                        return true;
                    } else {
                        this.logger.info(""NPM {} was installed, but we need version {}"", foundNpmVersion,
                            this.npmVersion);
                        return false;
                    }
                } else {
                    this.logger.info(""Could not read NPM version from package.json"");
                    return false;
                }
            } else {
                return false;
            }
        } catch (IOException ex) {
            throw new RuntimeException(""Could not read package.json"", ex);
        }
    }

    private void installNpm() throws InstallationException {
        try {
            this.logger.info(""Installing npm version {}"", this.npmVersion);
            final String downloadUrl = this.npmDownloadRoot + ""npm-"" + this.npmVersion + "".tgz"";

            CacheDescriptor cacheDescriptor = new CacheDescriptor(""npm"", this.npmVersion, ""tar.gz"");

            File archive = this.config.getCacheResolver().resolve(cacheDescriptor);

            downloadFileIfMissing(downloadUrl, archive, this.userName, this.password, this.httpHeaders);

            File installDirectory = getNodeInstallDirectory();
            File nodeModulesDirectory = new File(installDirectory, ""node_modules"");

            // We need to delete the existing npm directory first so we clean out any old files, and
            // so we can rename the package directory below.
            File oldNpmDirectory = new File(installDirectory, ""npm"");
            File npmDirectory = new File(nodeModulesDirectory, ""npm"");
            try {
                if (oldNpmDirectory.isDirectory()) {
                    FileUtils.deleteDirectory(oldNpmDirectory);
                }
                FileUtils.deleteDirectory(npmDirectory);
            } catch (IOException e) {
                this.logger.warn(""Failed to delete existing NPM installation."");
            }

            File packageDirectory = new File(nodeModulesDirectory, ""package"");
            try {
                extractFile(archive, nodeModulesDirectory);
            } catch (ArchiveExtractionException e) {
                if (e.getCause() instanceof EOFException) {
                    // https://github.com/eirslett/frontend-maven-plugin/issues/794
                    // The downloading was probably interrupted and archive file is incomplete:
                    // delete it to retry from scratch
                    this.logger.error(""The archive file {} is corrupted and will be deleted. ""
                            + ""Please try the build again."", archive.getPath());
                    archive.delete();
                    if (packageDirectory.exists()) {
                        FileUtils.deleteDirectory(packageDirectory);
                    }
                }

                throw e;
            }

            // handles difference between old and new download root (nodejs.org/dist/npm and
            // registry.npmjs.org)
            // see https://github.com/eirslett/frontend-maven-plugin/issues/65#issuecomment-52024254
            if (packageDirectory.exists() && !npmDirectory.exists()) {
                if (!packageDirectory.renameTo(npmDirectory)) {
                    this.logger.warn(""Cannot rename NPM directory, making a copy."");
                    FileUtils.copyDirectory(packageDirectory, npmDirectory);
                }
            }

            this.logger.info(""Installed npm locally."");
        } catch (DownloadException e) {
            throw new InstallationException(""Could not download npm"", e);
        } catch (ArchiveExtractionException e) {
            throw new InstallationException(""Could not extract the npm archive"", e);
        } catch (IOException e) {
            throw new InstallationException(""Could not copy npm"", e);
        }
    }

    private void copyNpmScripts() throws InstallationException{
        File installDirectory = getNodeInstallDirectory();

        File nodeModulesDirectory = new File(installDirectory, ""node_modules"");
        File npmDirectory = new File(nodeModulesDirectory, ""npm"");
        // create a copy of the npm scripts next to the node executable
        for (String script : Arrays.asList(""npm"", ""npm.cmd"", ""npx"", ""npx.cmd"")) {
            File scriptFile = new File(npmDirectory, ""bin"" + File.separator + script);
            if (scriptFile.exists()) {
                File copy = new File(installDirectory, script);
                if (!copy.exists()) {
                    try
                    {
                        FileUtils.copyFile(scriptFile, copy);
                    }
                    catch (IOException e)
                    {
                        throw new InstallationException(""Could not copy npm"", e);
                    }
                    copy.setExecutable(true);
                }
            }
        }
    }

    private File getNodeInstallDirectory() {
        File installDirectory = new File(this.config.getInstallDirectory(), NodeInstaller.INSTALL_PATH);
        if (!installDirectory.exists()) {
            this.logger.debug(""Creating install directory {}"", installDirectory);
            installDirectory.mkdirs();
        }
        return installDirectory;
    }

    private void extractFile(File archive, File destinationDirectory) throws ArchiveExtractionException {
        this.logger.info(""Unpacking {} into {}"", archive, destinationDirectory);
        this.archiveExtractor.extract(archive.getPath(), destinationDirectory.getPath());
    }

    private void downloadFileIfMissing(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException {
        if (!destination.exists()) {
            downloadFile(downloadUrl, destination, userName, password, httpHeaders);
        }
    }

    private void downloadFile(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException {
        this.logger.info(""Downloading {} to {}"", downloadUrl, destination);
        this.fileDownloader.download(downloadUrl, destination.getPath(), userName, password, httpHeaders);
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public class NPMInstaller { private static final String VERSION = ""version""; private static final Object LOCK = new Object(); private String nodeVersion, npmVersion, npmDownloadRoot, userName, password; private Map<String, String> httpHeaders; private final Logger logger; private final InstallConfig config; private final ArchiveExtractor archiveExtractor; private final FileDownloader fileDownloader; NPMInstaller(InstallConfig config, ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) { this.logger = LoggerFactory.getLogger(getClass()); this.config = config; this.archiveExtractor = archiveExtractor; this.fileDownloader = fileDownloader; } public NPMInstaller setNodeVersion(String nodeVersion) { this.nodeVersion = nodeVersion; return this; } public NPMInstaller setNpmVersion(String npmVersion) { this.npmVersion = npmVersion; return this; } public NPMInstaller setNpmDownloadRoot(String npmDownloadRoot) { this.npmDownloadRoot = npmDownloadRoot; return this; } public NPMInstaller setUserName(String userName) { this.userName = userName; return this; } public NPMInstaller setPassword(String password) { this.password = password; return this; } public NPMInstaller setHttpHeaders(Map<String, String> httpHeaders) { this.httpHeaders = httpHeaders; return this; } private boolean npmProvided() throws InstallationException { if (""provided"".equals(this.npmVersion)) { if (Integer.parseInt(this.nodeVersion.replace(""v"", """").split(""[.]"")[0]) < 4) { throw new InstallationException(
                    ""NPM version is '"" + this.npmVersion + ""' but Node didn't include NPM prior to v4.0.0""); } return true; } return false; } public void install() throws InstallationException { synchronized (LOCK) { if (this.npmDownloadRoot == null || this.npmDownloadRoot.isEmpty()) { this.npmDownloadRoot = DEFAULT_NPM_DOWNLOAD_ROOT; } if (!npmProvided() && !npmIsAlreadyInstalled()) { installNpm(); } copyNpmScripts(); } } private boolean npmIsAlreadyInstalled() { try { final File npmPackageJson = new File(
                this.config.getInstallDirectory() + Utils.normalize(""/node/node_modules/npm/package.json"")); if (npmPackageJson.exists()) { HashMap<String, Object> data = new ObjectMapper().readValue(npmPackageJson, HashMap.class); if (data.containsKey(VERSION)) { final String foundNpmVersion = data.get(VERSION).toString(); if (foundNpmVersion.equals(this.npmVersion)) { this.logger.info(""NPM { } is already installed."", foundNpmVersion); return true; } else { this.logger.info(""NPM { } was installed, but we need version { } "", foundNpmVersion,
                            this.npmVersion); return false; } } else { return false; } } else { return false; } } catch (IOException ex) { throw new RuntimeException(""Could not read package.json"", ex); } } private void installNpm() throws InstallationException { try { this.logger.info(""Installing npm version { } "", this.npmVersion); final String downloadUrl = this.npmDownloadRoot + ""npm-"" + this.npmVersion + "".tgz""; CacheDescriptor cacheDescriptor = new CacheDescriptor(""npm"", this.npmVersion, ""tar.gz""); File archive = this.config.getCacheResolver().resolve(cacheDescriptor); downloadFileIfMissing(downloadUrl, archive, this.userName, this.password, this.httpHeaders); File installDirectory = getNodeInstallDirectory(); File nodeModulesDirectory = new File(installDirectory, ""node_modules""); File oldNpmDirectory = new File(installDirectory, ""npm""); File npmDirectory = new File(nodeModulesDirectory, ""npm""); try { if (oldNpmDirectory.isDirectory()) { FileUtils.deleteDirectory(oldNpmDirectory); } FileUtils.deleteDirectory(npmDirectory); } catch (IOException e) { } File packageDirectory = new File(nodeModulesDirectory, ""package""); try { extractFile(archive, nodeModulesDirectory); } catch (ArchiveExtractionException e) { if (e.getCause() instanceof EOFException) { this.logger.error(""The archive file { } is corrupted and will be deleted. ""
                            + ""Please try the build again."", archive.getPath()); archive.delete(); if (packageDirectory.exists()) { FileUtils.deleteDirectory(packageDirectory); } } throw e; } if (packageDirectory.exists() && !npmDirectory.exists()) { if (!packageDirectory.renameTo(npmDirectory)) { FileUtils.copyDirectory(packageDirectory, npmDirectory); } } } catch (DownloadException e) { throw new InstallationException(""Could not download npm"", e); } catch (ArchiveExtractionException e) { throw new InstallationException(""Could not extract the npm archive"", e); } catch (IOException e) { throw new InstallationException(""Could not copy npm"", e); } } private void copyNpmScripts() throws InstallationException{ File installDirectory = getNodeInstallDirectory(); File nodeModulesDirectory = new File(installDirectory, ""node_modules""); File npmDirectory = new File(nodeModulesDirectory, ""npm""); for (String script : Arrays.asList(""npm"", ""npm.cmd"", ""npx"", ""npx.cmd"")) { File scriptFile = new File(npmDirectory, ""bin"" + File.separator + script); if (scriptFile.exists()) { File copy = new File(installDirectory, script); if (!copy.exists()) { try
                    { FileUtils.copyFile(scriptFile, copy); } catch (IOException e)
                    { throw new InstallationException(""Could not copy npm"", e); } copy.setExecutable(true); } } } } private File getNodeInstallDirectory() { File installDirectory = new File(this.config.getInstallDirectory(), NodeInstaller.INSTALL_PATH); if (!installDirectory.exists()) { this.logger.debug(""Creating install directory { } "", installDirectory); installDirectory.mkdirs(); } return installDirectory; } private void extractFile(File archive, File destinationDirectory) throws ArchiveExtractionException { this.logger.info(""Unpacking { } into { } "", archive, destinationDirectory); this.archiveExtractor.extract(archive.getPath(), destinationDirectory.getPath()); } private void downloadFileIfMissing(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException { if (!destination.exists()) { downloadFile(downloadUrl, destination, userName, password, httpHeaders); } } private void downloadFile(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException { this.logger.info(""Downloading { } to { } "", downloadUrl, destination); this.fileDownloader.download(downloadUrl, destination.getPath(), userName, password, httpHeaders); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public class NPMInstaller { private static final String VERSION = ""version""; private static final Object LOCK = new Object(); private String nodeVersion, npmVersion, npmDownloadRoot, userName, password; private Map<String, String> httpHeaders; private final Logger logger; private final InstallConfig config; private final ArchiveExtractor archiveExtractor; private final FileDownloader fileDownloader; NPMInstaller(InstallConfig config, ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) { this.logger = LoggerFactory.getLogger(getClass()); this.config = config; this.archiveExtractor = archiveExtractor; this.fileDownloader = fileDownloader; } <FILL_ME> public NPMInstaller setNodeVersion(String nodeVersion) { this.nodeVersion = nodeVersion; return this; } public NPMInstaller setNpmVersion(String npmVersion) { this.npmVersion = npmVersion; return this; } public NPMInstaller setNpmDownloadRoot(String npmDownloadRoot) { this.npmDownloadRoot = npmDownloadRoot; return this; } public NPMInstaller setUserName(String userName) { this.userName = userName; return this; } public NPMInstaller setPassword(String password) { this.password = password; return this; } public NPMInstaller setHttpHeaders(Map<String, String> httpHeaders) { this.httpHeaders = httpHeaders; return this; } private boolean npmProvided() throws InstallationException { if (""provided"".equals(this.npmVersion)) { if (Integer.parseInt(this.nodeVersion.replace(""v"", """").split(""[.]"")[0]) < 4) { throw new InstallationException(
                    ""NPM version is '"" + this.npmVersion + ""' but Node didn't include NPM prior to v4.0.0""); } return true; } return false; } public void install() throws InstallationException { synchronized (LOCK) { if (this.npmDownloadRoot == null || this.npmDownloadRoot.isEmpty()) { this.npmDownloadRoot = DEFAULT_NPM_DOWNLOAD_ROOT; } if (!npmProvided() && !npmIsAlreadyInstalled()) { installNpm(); } copyNpmScripts(); } } private boolean npmIsAlreadyInstalled() { try { final File npmPackageJson = new File(
                this.config.getInstallDirectory() + Utils.normalize(""/node/node_modules/npm/package.json"")); if (npmPackageJson.exists()) { HashMap<String, Object> data = new ObjectMapper().readValue(npmPackageJson, HashMap.class); if (data.containsKey(VERSION)) { final String foundNpmVersion = data.get(VERSION).toString(); if (foundNpmVersion.equals(this.npmVersion)) { this.logger.info(""NPM { } is already installed."", foundNpmVersion); return true; } else { <FILL_ME> this.logger.info(""NPM { } was installed, but we need version { } "", foundNpmVersion,
                            this.npmVersion); return false; } } else { return false; } } else { return false; } } catch (IOException ex) { throw new RuntimeException(""Could not read package.json"", ex); } } private void installNpm() throws InstallationException { try { this.logger.info(""Installing npm version { } "", this.npmVersion); final String downloadUrl = this.npmDownloadRoot + ""npm-"" + this.npmVersion + "".tgz""; CacheDescriptor cacheDescriptor = new CacheDescriptor(""npm"", this.npmVersion, ""tar.gz""); File archive = this.config.getCacheResolver().resolve(cacheDescriptor); downloadFileIfMissing(downloadUrl, archive, this.userName, this.password, this.httpHeaders); File installDirectory = getNodeInstallDirectory(); File nodeModulesDirectory = new File(installDirectory, ""node_modules""); File oldNpmDirectory = new File(installDirectory, ""npm""); File npmDirectory = new File(nodeModulesDirectory, ""npm""); try { if (oldNpmDirectory.isDirectory()) { FileUtils.deleteDirectory(oldNpmDirectory); } FileUtils.deleteDirectory(npmDirectory); } catch (IOException e) { <FILL_ME> } File packageDirectory = new File(nodeModulesDirectory, ""package""); try { extractFile(archive, nodeModulesDirectory); } catch (ArchiveExtractionException e) { if (e.getCause() instanceof EOFException) { this.logger.error(""The archive file { } is corrupted and will be deleted. ""
                            + ""Please try the build again."", archive.getPath()); archive.delete(); if (packageDirectory.exists()) { FileUtils.deleteDirectory(packageDirectory); } } throw e; } if (packageDirectory.exists() && !npmDirectory.exists()) { if (!packageDirectory.renameTo(npmDirectory)) { <FILL_ME> FileUtils.copyDirectory(packageDirectory, npmDirectory); } } } catch (DownloadException e) { throw new InstallationException(""Could not download npm"", e); } catch (ArchiveExtractionException e) { throw new InstallationException(""Could not extract the npm archive"", e); } catch (IOException e) { throw new InstallationException(""Could not copy npm"", e); } } private void copyNpmScripts() throws InstallationException{ File installDirectory = getNodeInstallDirectory(); File nodeModulesDirectory = new File(installDirectory, ""node_modules""); File npmDirectory = new File(nodeModulesDirectory, ""npm""); for (String script : Arrays.asList(""npm"", ""npm.cmd"", ""npx"", ""npx.cmd"")) { File scriptFile = new File(npmDirectory, ""bin"" + File.separator + script); if (scriptFile.exists()) { File copy = new File(installDirectory, script); if (!copy.exists()) { try
                    { FileUtils.copyFile(scriptFile, copy); } catch (IOException e)
                    { throw new InstallationException(""Could not copy npm"", e); } copy.setExecutable(true); } } } } private File getNodeInstallDirectory() { File installDirectory = new File(this.config.getInstallDirectory(), NodeInstaller.INSTALL_PATH); if (!installDirectory.exists()) { this.logger.debug(""Creating install directory { } "", installDirectory); installDirectory.mkdirs(); } return installDirectory; } private void extractFile(File archive, File destinationDirectory) throws ArchiveExtractionException { this.logger.info(""Unpacking { } into { } "", archive, destinationDirectory); this.archiveExtractor.extract(archive.getPath(), destinationDirectory.getPath()); } private void downloadFileIfMissing(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException { if (!destination.exists()) { downloadFile(downloadUrl, destination, userName, password, httpHeaders); } } private void downloadFile(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException { this.logger.info(""Downloading { } to { } "", downloadUrl, destination); this.fileDownloader.download(downloadUrl, destination.getPath(), userName, password, httpHeaders); } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import com.fasterxml.jackson.databind.ObjectMapper; import java.io.EOFException; import java.io.File; import java.io.IOException; import java.util.Arrays; import java.util.HashMap; import java.util.Map; 
import org.apache.commons.io.FileUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class NPMInstaller {  private static final String VERSION = ""version"";  //registry.npmjs.org/npm/-/"";  private static final Object LOCK = new Object();  private String nodeVersion, npmVersion, npmDownloadRoot, userName, password;  private Map<String, String> httpHeaders;      private final Logger logger;  private final InstallConfig config;  private final ArchiveExtractor archiveExtractor;  private final FileDownloader fileDownloader;  NPMInstaller(InstallConfig config, ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) { this.logger = LoggerFactory.getLogger(getClass()); this.config = config; this.archiveExtractor = archiveExtractor; this.fileDownloader = fileDownloader; } <FILL_ME>  public NPMInstaller setNodeVersion(String nodeVersion) { this.nodeVersion = nodeVersion; return this; }  public NPMInstaller setNpmVersion(String npmVersion) { this.npmVersion = npmVersion; return this; }  public NPMInstaller setNpmDownloadRoot(String npmDownloadRoot) { this.npmDownloadRoot = npmDownloadRoot; return this; }  public NPMInstaller setUserName(String userName) { this.userName = userName; return this; }  public NPMInstaller setPassword(String password) { this.password = password; return this; }  public NPMInstaller setHttpHeaders(Map<String, String> httpHeaders) { this.httpHeaders = httpHeaders; return this; }  private boolean npmProvided() throws InstallationException { if (""provided"".equals(this.npmVersion)) { if (Integer.parseInt(this.nodeVersion.replace(""v"", """").split(""[.]"")[0]) < 4) { throw new InstallationException(
                    ""NPM version is '"" + this.npmVersion + ""' but Node didn't include NPM prior to v4.0.0""); } return true; } return false;  }  public void install() throws InstallationException { // use static lock object for a synchronized block synchronized (LOCK) { if (this.npmDownloadRoot == null || this.npmDownloadRoot.isEmpty()) { this.npmDownloadRoot = DEFAULT_NPM_DOWNLOAD_ROOT; } if (!npmProvided() && !npmIsAlreadyInstalled()) { installNpm(); } copyNpmScripts(); } }  private boolean npmIsAlreadyInstalled() { try { final File npmPackageJson = new File(
                this.config.getInstallDirectory() + Utils.normalize(""/node/node_modules/npm/package.json"")); if (npmPackageJson.exists()) { HashMap<String, Object> data = new ObjectMapper().readValue(npmPackageJson, HashMap.class); if (data.containsKey(VERSION)) { final String foundNpmVersion = data.get(VERSION).toString(); if (foundNpmVersion.equals(this.npmVersion)) { this.logger.info(""NPM { } is already installed."", foundNpmVersion); return true; } else { <FILL_ME> this.logger.info(""NPM { } was installed, but we need version { } "", foundNpmVersion,
                            this.npmVersion); return false; } } else { return false; } } else { return false; } } catch (IOException ex) { throw new RuntimeException(""Could not read package.json"", ex); } }  private void installNpm() throws InstallationException { try { this.logger.info(""Installing npm version { } "", this.npmVersion); final String downloadUrl = this.npmDownloadRoot + ""npm-"" + this.npmVersion + "".tgz"";  CacheDescriptor cacheDescriptor = new CacheDescriptor(""npm"", this.npmVersion, ""tar.gz"");  File archive = this.config.getCacheResolver().resolve(cacheDescriptor);  downloadFileIfMissing(downloadUrl, archive, this.userName, this.password, this.httpHeaders);  File installDirectory = getNodeInstallDirectory(); File nodeModulesDirectory = new File(installDirectory, ""node_modules"");  // We need to delete the existing npm directory first so we clean out any old files, and // so we can rename the package directory below. File oldNpmDirectory = new File(installDirectory, ""npm""); File npmDirectory = new File(nodeModulesDirectory, ""npm""); try { if (oldNpmDirectory.isDirectory()) { FileUtils.deleteDirectory(oldNpmDirectory); } FileUtils.deleteDirectory(npmDirectory); } catch (IOException e) { <FILL_ME> }  File packageDirectory = new File(nodeModulesDirectory, ""package""); try { extractFile(archive, nodeModulesDirectory); } catch (ArchiveExtractionException e) { if (e.getCause() instanceof EOFException) { // https://github.com/eirslett/frontend-maven-plugin/issues/794 // The downloading was probably interrupted and archive file is incomplete: // delete it to retry from scratch this.logger.error(""The archive file { } is corrupted and will be deleted. ""
                            + ""Please try the build again."", archive.getPath()); archive.delete(); if (packageDirectory.exists()) { FileUtils.deleteDirectory(packageDirectory); } }  throw e; }  // handles difference between old and new download root (nodejs.org/dist/npm and // registry.npmjs.org) // see https://github.com/eirslett/frontend-maven-plugin/issues/65#issuecomment-52024254 if (packageDirectory.exists() && !npmDirectory.exists()) { if (!packageDirectory.renameTo(npmDirectory)) { <FILL_ME> FileUtils.copyDirectory(packageDirectory, npmDirectory); } }  } catch (DownloadException e) { throw new InstallationException(""Could not download npm"", e); } catch (ArchiveExtractionException e) { throw new InstallationException(""Could not extract the npm archive"", e); } catch (IOException e) { throw new InstallationException(""Could not copy npm"", e); } }  private void copyNpmScripts() throws InstallationException{ File installDirectory = getNodeInstallDirectory();  File nodeModulesDirectory = new File(installDirectory, ""node_modules""); File npmDirectory = new File(nodeModulesDirectory, ""npm""); // create a copy of the npm scripts next to the node executable for (String script : Arrays.asList(""npm"", ""npm.cmd"", ""npx"", ""npx.cmd"")) { File scriptFile = new File(npmDirectory, ""bin"" + File.separator + script); if (scriptFile.exists()) { File copy = new File(installDirectory, script); if (!copy.exists()) { try
                    { FileUtils.copyFile(scriptFile, copy); } catch (IOException e)
                    { throw new InstallationException(""Could not copy npm"", e); } copy.setExecutable(true); } } } }  private File getNodeInstallDirectory() { File installDirectory = new File(this.config.getInstallDirectory(), NodeInstaller.INSTALL_PATH); if (!installDirectory.exists()) { this.logger.debug(""Creating install directory { } "", installDirectory); installDirectory.mkdirs(); } return installDirectory; }  private void extractFile(File archive, File destinationDirectory) throws ArchiveExtractionException { this.logger.info(""Unpacking { } into { } "", archive, destinationDirectory); this.archiveExtractor.extract(archive.getPath(), destinationDirectory.getPath()); }  private void downloadFileIfMissing(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException { if (!destination.exists()) { downloadFile(downloadUrl, destination, userName, password, httpHeaders); } }  private void downloadFile(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException { this.logger.info(""Downloading { } to { } "", downloadUrl, destination); this.fileDownloader.download(downloadUrl, destination.getPath(), userName, password, httpHeaders); } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/NodeExecutor.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;

final class NodeExecutor {
    private final ProcessExecutor executor;

    public NodeExecutor(NodeExecutorConfig config, List<String> arguments, Map<String, String> additionalEnvironment){
        final String node = config.getNodePath().getAbsolutePath();
        List<String> localPaths = new ArrayList<String>();
        localPaths.add(config.getNodePath().getParent());
        this.executor = new ProcessExecutor(
            config.getWorkingDirectory(),
            localPaths,
            Utils.prepend(node, arguments),
            config.getPlatform(),
            additionalEnvironment);
    }

    public String executeAndGetResult(final Logger logger) throws ProcessExecutionException {
        return executor.executeAndGetResult(logger);
    }

    public int executeAndRedirectOutput(final Logger logger) throws ProcessExecutionException {
        return executor.executeAndRedirectOutput(logger);
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; final class NodeExecutor { private final ProcessExecutor executor; public NodeExecutor(NodeExecutorConfig config, List<String> arguments, Map<String, String> additionalEnvironment){ final String node = config.getNodePath().getAbsolutePath(); List<String> localPaths = new ArrayList<String>(); localPaths.add(config.getNodePath().getParent()); this.executor = new ProcessExecutor(
            config.getWorkingDirectory(),
            localPaths,
            Utils.prepend(node, arguments),
            config.getPlatform(),
            additionalEnvironment); } public String executeAndGetResult(final Logger logger) throws ProcessExecutionException { return executor.executeAndGetResult(logger); } public int executeAndRedirectOutput(final Logger logger) throws ProcessExecutionException { return executor.executeAndRedirectOutput(logger); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; final class NodeExecutor { private final ProcessExecutor executor; public NodeExecutor(NodeExecutorConfig config, List<String> arguments, Map<String, String> additionalEnvironment){ final String node = config.getNodePath().getAbsolutePath(); List<String> localPaths = new ArrayList<String>(); localPaths.add(config.getNodePath().getParent()); this.executor = new ProcessExecutor(
            config.getWorkingDirectory(),
            localPaths,
            Utils.prepend(node, arguments),
            config.getPlatform(),
            additionalEnvironment); } public String executeAndGetResult(final Logger logger) throws ProcessExecutionException { return executor.executeAndGetResult(logger); } public int executeAndRedirectOutput(final Logger logger) throws ProcessExecutionException { return executor.executeAndRedirectOutput(logger); } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import java.util.ArrayList; import java.util.List; import java.util.Map; 
import org.slf4j.Logger;  final class NodeExecutor { private final ProcessExecutor executor;  public NodeExecutor(NodeExecutorConfig config, List<String> arguments, Map<String, String> additionalEnvironment){ final String node = config.getNodePath().getAbsolutePath(); List<String> localPaths = new ArrayList<String>(); localPaths.add(config.getNodePath().getParent()); this.executor = new ProcessExecutor(
            config.getWorkingDirectory(),
            localPaths,
            Utils.prepend(node, arguments),
            config.getPlatform(),
            additionalEnvironment); }  public String executeAndGetResult(final Logger logger) throws ProcessExecutionException { return executor.executeAndGetResult(logger); }  public int executeAndRedirectOutput(final Logger logger) throws ProcessExecutionException { return executor.executeAndRedirectOutput(logger); } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/NodeExecutorConfig.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import java.io.File;

public interface NodeExecutorConfig {
  File getNodePath();
  File getNpmPath();
  File getPnpmPath();
  File getPnpmCjsPath();
  File getCorepackPath();

  File getNpxPath();
  File getInstallDirectory();
  File getWorkingDirectory();
  Platform getPlatform();
}

final class InstallNodeExecutorConfig implements NodeExecutorConfig {

  private static final String NODE_WINDOWS = NodeInstaller.INSTALL_PATH.replaceAll(""/"", ""\\\\"") + ""\\node.exe"";
  private static final String NODE_DEFAULT = NodeInstaller.INSTALL_PATH + ""/node"";
  private static final String NPM = NodeInstaller.INSTALL_PATH + ""/node_modules/npm/bin/npm-cli.js"";
  private static final String PNPM = NodeInstaller.INSTALL_PATH + ""/node_modules/pnpm/bin/pnpm.js"";
  private static final String PNPM_CJS = NodeInstaller.INSTALL_PATH + ""/node_modules/pnpm/bin/pnpm.cjs"";
  private static final String COREPACK = NodeInstaller.INSTALL_PATH + ""/node_modules/corepack/dist/corepack.js"";
  private static final String NPX = NodeInstaller.INSTALL_PATH + ""/node_modules/npm/bin/npx-cli.js"";

  private final InstallConfig installConfig;

  public InstallNodeExecutorConfig(InstallConfig installConfig) {
    this.installConfig = installConfig;
  }

  @Override
  public File getNodePath() {
    String nodeExecutable = getPlatform().isWindows() ? NODE_WINDOWS : NODE_DEFAULT;
    return new File(installConfig.getInstallDirectory() + nodeExecutable);
  }

  @Override
  public File getNpmPath() {
    return new File(installConfig.getInstallDirectory() + Utils.normalize(NPM));
  }


  @Override
  public File getPnpmPath() {
    return new File(installConfig.getInstallDirectory() + Utils.normalize(PNPM));
  }

  @Override
  public File getPnpmCjsPath() {
    return new File(installConfig.getInstallDirectory() + Utils.normalize(PNPM_CJS));
  }

  @Override
  public File getCorepackPath() {
    return new File(installConfig.getInstallDirectory() + Utils.normalize(COREPACK));
  }

  @Override
  public File getNpxPath() {
    return new File(installConfig.getInstallDirectory() + Utils.normalize(NPX));
  }

  @Override
  public File getInstallDirectory() {
    return installConfig.getInstallDirectory();
  }
  
  @Override
  public File getWorkingDirectory() {
    return installConfig.getWorkingDirectory();
  }

  @Override
  public Platform getPlatform() {
    return installConfig.getPlatform();
  }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public interface NodeExecutorConfig { File getNodePath(); File getNpmPath(); File getPnpmPath(); File getPnpmCjsPath(); File getCorepackPath(); File getNpxPath(); File getInstallDirectory(); File getWorkingDirectory(); Platform getPlatform(); } final class InstallNodeExecutorConfig implements NodeExecutorConfig { private static final String NODE_WINDOWS = NodeInstaller.INSTALL_PATH.replaceAll(""/"", ""\\\\"") + ""\\node.exe""; private static final String NODE_DEFAULT = NodeInstaller.INSTALL_PATH + ""/node""; private static final String NPM = NodeInstaller.INSTALL_PATH + ""/node_modules/npm/bin/npm-cli.js""; private static final String PNPM = NodeInstaller.INSTALL_PATH + ""/node_modules/pnpm/bin/pnpm.js""; private static final String PNPM_CJS = NodeInstaller.INSTALL_PATH + ""/node_modules/pnpm/bin/pnpm.cjs""; private static final String COREPACK = NodeInstaller.INSTALL_PATH + ""/node_modules/corepack/dist/corepack.js""; private static final String NPX = NodeInstaller.INSTALL_PATH + ""/node_modules/npm/bin/npx-cli.js""; private final InstallConfig installConfig; public InstallNodeExecutorConfig(InstallConfig installConfig) { this.installConfig = installConfig; } @Override
  public File getNodePath() { String nodeExecutable = getPlatform().isWindows() ? NODE_WINDOWS : NODE_DEFAULT; return new File(installConfig.getInstallDirectory() + nodeExecutable); } @Override
  public File getNpmPath() { return new File(installConfig.getInstallDirectory() + Utils.normalize(NPM)); } @Override
  public File getPnpmPath() { return new File(installConfig.getInstallDirectory() + Utils.normalize(PNPM)); } @Override
  public File getPnpmCjsPath() { return new File(installConfig.getInstallDirectory() + Utils.normalize(PNPM_CJS)); } @Override
  public File getCorepackPath() { return new File(installConfig.getInstallDirectory() + Utils.normalize(COREPACK)); } @Override
  public File getNpxPath() { return new File(installConfig.getInstallDirectory() + Utils.normalize(NPX)); } @Override
  public File getInstallDirectory() { return installConfig.getInstallDirectory(); } @Override
  public File getWorkingDirectory() { return installConfig.getWorkingDirectory(); } @Override
  public Platform getPlatform() { return installConfig.getPlatform(); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public interface NodeExecutorConfig { File getNodePath(); File getNpmPath(); File getPnpmPath(); File getPnpmCjsPath(); File getCorepackPath(); File getNpxPath(); File getInstallDirectory(); File getWorkingDirectory(); Platform getPlatform(); } final class InstallNodeExecutorConfig implements NodeExecutorConfig { private static final String NODE_WINDOWS = NodeInstaller.INSTALL_PATH.replaceAll(""/"", ""\\\\"") + ""\\node.exe""; private static final String NODE_DEFAULT = NodeInstaller.INSTALL_PATH + ""/node""; private static final String NPM = NodeInstaller.INSTALL_PATH + ""/node_modules/npm/bin/npm-cli.js""; private static final String PNPM = NodeInstaller.INSTALL_PATH + ""/node_modules/pnpm/bin/pnpm.js""; private static final String PNPM_CJS = NodeInstaller.INSTALL_PATH + ""/node_modules/pnpm/bin/pnpm.cjs""; private static final String COREPACK = NodeInstaller.INSTALL_PATH + ""/node_modules/corepack/dist/corepack.js""; private static final String NPX = NodeInstaller.INSTALL_PATH + ""/node_modules/npm/bin/npx-cli.js""; private final InstallConfig installConfig; public InstallNodeExecutorConfig(InstallConfig installConfig) { this.installConfig = installConfig; } @Override
  public File getNodePath() { String nodeExecutable = getPlatform().isWindows() ? NODE_WINDOWS : NODE_DEFAULT; return new File(installConfig.getInstallDirectory() + nodeExecutable); } @Override
  public File getNpmPath() { return new File(installConfig.getInstallDirectory() + Utils.normalize(NPM)); } @Override
  public File getPnpmPath() { return new File(installConfig.getInstallDirectory() + Utils.normalize(PNPM)); } @Override
  public File getPnpmCjsPath() { return new File(installConfig.getInstallDirectory() + Utils.normalize(PNPM_CJS)); } @Override
  public File getCorepackPath() { return new File(installConfig.getInstallDirectory() + Utils.normalize(COREPACK)); } @Override
  public File getNpxPath() { return new File(installConfig.getInstallDirectory() + Utils.normalize(NPX)); } @Override
  public File getInstallDirectory() { return installConfig.getInstallDirectory(); } @Override
  public File getWorkingDirectory() { return installConfig.getWorkingDirectory(); } @Override
  public Platform getPlatform() { return installConfig.getPlatform(); } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import java.io.File;  public interface NodeExecutorConfig { File getNodePath(); File getNpmPath(); File getPnpmPath(); File getPnpmCjsPath(); File getCorepackPath();  File getNpxPath(); File getInstallDirectory(); File getWorkingDirectory(); Platform getPlatform(); }  final class InstallNodeExecutorConfig implements NodeExecutorConfig {  private static final String NODE_WINDOWS = NodeInstaller.INSTALL_PATH.replaceAll(""/"", ""\\\\"") + ""\\node.exe""; private static final String NODE_DEFAULT = NodeInstaller.INSTALL_PATH + ""/node""; private static final String NPM = NodeInstaller.INSTALL_PATH + ""/node_modules/npm/bin/npm-cli.js""; private static final String PNPM = NodeInstaller.INSTALL_PATH + ""/node_modules/pnpm/bin/pnpm.js""; private static final String PNPM_CJS = NodeInstaller.INSTALL_PATH + ""/node_modules/pnpm/bin/pnpm.cjs""; private static final String COREPACK = NodeInstaller.INSTALL_PATH + ""/node_modules/corepack/dist/corepack.js""; private static final String NPX = NodeInstaller.INSTALL_PATH + ""/node_modules/npm/bin/npx-cli.js"";  private final InstallConfig installConfig;  public InstallNodeExecutorConfig(InstallConfig installConfig) { this.installConfig = installConfig; }  @Override
  public File getNodePath() { String nodeExecutable = getPlatform().isWindows() ? NODE_WINDOWS : NODE_DEFAULT; return new File(installConfig.getInstallDirectory() + nodeExecutable); }  @Override
  public File getNpmPath() { return new File(installConfig.getInstallDirectory() + Utils.normalize(NPM)); } 
 @Override
  public File getPnpmPath() { return new File(installConfig.getInstallDirectory() + Utils.normalize(PNPM)); }  @Override
  public File getPnpmCjsPath() { return new File(installConfig.getInstallDirectory() + Utils.normalize(PNPM_CJS)); }  @Override
  public File getCorepackPath() { return new File(installConfig.getInstallDirectory() + Utils.normalize(COREPACK)); }  @Override
  public File getNpxPath() { return new File(installConfig.getInstallDirectory() + Utils.normalize(NPX)); }  @Override
  public File getInstallDirectory() { return installConfig.getInstallDirectory(); }  @Override
  public File getWorkingDirectory() { return installConfig.getWorkingDirectory(); }    @Override
  public Platform getPlatform() { return installConfig.getPlatform(); } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/NodeInstaller.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import java.io.EOFException;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.util.Arrays;
import java.util.Map;

import org.apache.commons.io.FileUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class NodeInstaller {

    public static final String INSTALL_PATH = ""/node"";

    private static final Object LOCK = new Object();

    private String npmVersion, nodeVersion, nodeDownloadRoot, userName, password;
    
    private Map<String, String> httpHeaders;

    private final Logger logger;

    private final InstallConfig config;

    private final ArchiveExtractor archiveExtractor;

    private final FileDownloader fileDownloader;

    NodeInstaller(InstallConfig config, ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) {
        this.logger = LoggerFactory.getLogger(getClass());
        this.config = config;
        this.archiveExtractor = archiveExtractor;
        this.fileDownloader = fileDownloader;
    }

    public NodeInstaller setNodeVersion(String nodeVersion) {
        this.nodeVersion = nodeVersion;
        return this;
    }

    public NodeInstaller setNodeDownloadRoot(String nodeDownloadRoot) {
        this.nodeDownloadRoot = nodeDownloadRoot;
        return this;
    }

    public NodeInstaller setNpmVersion(String npmVersion) {
        this.npmVersion = npmVersion;
        return this;
    }

    public NodeInstaller setUserName(String userName) {
        this.userName = userName;
        return this;
    }

    public NodeInstaller setPassword(String password) {
        this.password = password;
        return this;
    }
    
    public NodeInstaller setHttpHeaders(Map<String, String> httpHeaders) {
        this.httpHeaders = httpHeaders;
        return this;
    }

    private boolean npmProvided() throws InstallationException {
        if (this.npmVersion != null) {
            if (""provided"".equals(this.npmVersion)) {
                if (Integer.parseInt(this.nodeVersion.replace(""v"", """").split(""[.]"")[0]) < 4) {
                    throw new InstallationException(""NPM version is '"" + this.npmVersion
                        + ""' but Node didn't include NPM prior to v4.0.0"");
                }
                return true;
            }
            return false;
        }
        return false;
    }

    public void install() throws InstallationException {
        // use static lock object for a synchronized block
        synchronized (LOCK) {
            if (this.nodeDownloadRoot == null || this.nodeDownloadRoot.isEmpty()) {
                this.nodeDownloadRoot = this.config.getPlatform().getNodeDownloadRoot();
            }
            if (!nodeIsAlreadyInstalled()) {
                this.logger.info(""Installing node version {}"", this.nodeVersion);
                if (!this.nodeVersion.startsWith(""v"")) {
                    this.logger.warn(""Node version does not start with naming convention 'v'."");
                }
                if (this.config.getPlatform().isWindows()) {
                    if (npmProvided()) {
                        installNodeWithNpmForWindows();
                    } else {
                        installNodeForWindows();
                    }
                } else {
                    installNodeDefault();
                }
            }
        }
    }

    private boolean nodeIsAlreadyInstalled() {
        try {
            NodeExecutorConfig executorConfig = new InstallNodeExecutorConfig(this.config);
            File nodeFile = executorConfig.getNodePath();
            if (nodeFile.exists()) {
                final String version =
                    new NodeExecutor(executorConfig, Arrays.asList(""--version""), null).executeAndGetResult(logger);

                if (version.equals(this.nodeVersion)) {
                    this.logger.info(""Node {} is already installed."", version);
                    return true;
                } else {
                    this.logger.info(""Node {} was installed, but we need version {}"", version,
                        this.nodeVersion);
                    return false;
                }
            } else {
                return false;
            }
        } catch (ProcessExecutionException e) {
            this.logger.warn(""Unable to determine current node version: {}"", e.getMessage());
            return false;
        }
    }

    private void installNodeDefault() throws InstallationException {
        try {
            final String longNodeFilename =
                this.config.getPlatform().getLongNodeFilename(this.nodeVersion, false);
            String downloadUrl = this.nodeDownloadRoot
                + this.config.getPlatform().getNodeDownloadFilename(this.nodeVersion, false);
            String classifier = this.config.getPlatform().getNodeClassifier(this.nodeVersion);

            File tmpDirectory = getTempDirectory();

            CacheDescriptor cacheDescriptor = new CacheDescriptor(""node"", this.nodeVersion, classifier,
                this.config.getPlatform().getArchiveExtension());

            File archive = this.config.getCacheResolver().resolve(cacheDescriptor);

            downloadFileIfMissing(downloadUrl, archive, this.userName, this.password, this.httpHeaders);

            try {
                extractFile(archive, tmpDirectory);
            } catch (ArchiveExtractionException e) {
                if (e.getCause() instanceof EOFException) {
                    // https://github.com/eirslett/frontend-maven-plugin/issues/794
                    // The downloading was probably interrupted and archive file is incomplete:
                    // delete it to retry from scratch
                    this.logger.error(""The archive file {} is corrupted and will be deleted. ""
                            + ""Please try the build again."", archive.getPath());
                    archive.delete();
                    FileUtils.deleteDirectory(tmpDirectory);
                }

                throw e;
            }

            // Search for the node binary
            File nodeBinary =
                new File(tmpDirectory, longNodeFilename + File.separator + ""bin"" + File.separator + ""node"");
            if (!nodeBinary.exists()) {
                throw new FileNotFoundException(
                    ""Could not find the downloaded Node.js binary in "" + nodeBinary);
            } else {
                File destinationDirectory = getInstallDirectory();

                File destination = new File(destinationDirectory, ""node"");
                this.logger.info(""Copying node binary from {} to {}"", nodeBinary, destination);
                if (destination.exists() && !destination.delete()) {
                    throw new InstallationException(""Could not install Node: Was not allowed to delete "" + destination);
                }
                try {
                    Files.move(nodeBinary.toPath(), destination.toPath(), StandardCopyOption.REPLACE_EXISTING);
                } catch (IOException e) {
                    throw new InstallationException(""Could not install Node: Was not allowed to rename ""
                        + nodeBinary + "" to "" + destination);
                }

                if (!destination.setExecutable(true, false)) {
                    throw new InstallationException(
                        ""Could not install Node: Was not allowed to make "" + destination + "" executable."");
                }

                if (npmProvided()) {
                    File tmpNodeModulesDir = new File(tmpDirectory,
                        longNodeFilename + File.separator + ""lib"" + File.separator + ""node_modules"");
                    File nodeModulesDirectory = new File(destinationDirectory, ""node_modules"");
                    File npmDirectory = new File(nodeModulesDirectory, ""npm"");
                    FileUtils.copyDirectory(tmpNodeModulesDir, nodeModulesDirectory);
                    this.logger.info(""Extracting NPM"");
                    // create a copy of the npm scripts next to the node executable
                    for (String script : Arrays.asList(""npm"", ""npm.cmd"", ""npx"", ""npx.cmd"")) {
                        File scriptFile = new File(npmDirectory, ""bin"" + File.separator + script);
                        if (scriptFile.exists()) {
                            File copy = new File(destinationDirectory, script);
                            if (!copy.exists()) {
                                try
                                {
                                    FileUtils.copyFile(scriptFile, copy);
                                }
                                catch (IOException e)
                                {
                                    throw new InstallationException(""Could not copy npm"", e);
                                }
                                copy.setExecutable(true);
                            }
                        }
                    }
                }

                deleteTempDirectory(tmpDirectory);

                this.logger.info(""Installed node locally."");
            }
        } catch (IOException e) {
            throw new InstallationException(""Could not install Node"", e);
        } catch (DownloadException e) {
            throw new InstallationException(""Could not download Node.js"", e);
        } catch (ArchiveExtractionException e) {
            throw new InstallationException(""Could not extract the Node archive"", e);
        }
    }

    private void installNodeWithNpmForWindows() throws InstallationException {
        try {
            final String longNodeFilename =
                this.config.getPlatform().getLongNodeFilename(this.nodeVersion, true);
            String downloadUrl = this.nodeDownloadRoot
                + this.config.getPlatform().getNodeDownloadFilename(this.nodeVersion, true);
            String classifier = this.config.getPlatform().getNodeClassifier(this.nodeVersion);

            File tmpDirectory = getTempDirectory();

            CacheDescriptor cacheDescriptor = new CacheDescriptor(""node"", this.nodeVersion, classifier,
                this.config.getPlatform().getArchiveExtension());

            File archive = this.config.getCacheResolver().resolve(cacheDescriptor);

            downloadFileIfMissing(downloadUrl, archive, this.userName, this.password, this.httpHeaders);

            extractFile(archive, tmpDirectory);

            // Search for the node binary
            File nodeBinary = new File(tmpDirectory, longNodeFilename + File.separator + ""node.exe"");
            if (!nodeBinary.exists()) {
                throw new FileNotFoundException(
                    ""Could not find the downloaded Node.js binary in "" + nodeBinary);
            } else {
                File destinationDirectory = getInstallDirectory();

                File destination = new File(destinationDirectory, ""node.exe"");
                this.logger.info(""Copying node binary from {} to {}"", nodeBinary, destination);
                try {
                    Files.move(nodeBinary.toPath(), destination.toPath(), StandardCopyOption.REPLACE_EXISTING);
                } catch (IOException e) {
                    throw new InstallationException(""Could not install Node: Was not allowed to rename ""
                        + nodeBinary + "" to "" + destination);
                }

                if (""provided"".equals(this.npmVersion)) {
                    File tmpNodeModulesDir =
                        new File(tmpDirectory, longNodeFilename + File.separator + ""node_modules"");
                    File nodeModulesDirectory = new File(destinationDirectory, ""node_modules"");
                    FileUtils.copyDirectory(tmpNodeModulesDir, nodeModulesDirectory);
                }
                deleteTempDirectory(tmpDirectory);

                this.logger.info(""Installed node locally."");
            }
        } catch (IOException e) {
            throw new InstallationException(""Could not install Node"", e);
        } catch (DownloadException e) {
            throw new InstallationException(""Could not download Node.js"", e);
        } catch (ArchiveExtractionException e) {
            throw new InstallationException(""Could not extract the Node archive"", e);
        }

    }

    private void installNodeForWindows() throws InstallationException {
        final String downloadUrl = this.nodeDownloadRoot
            + this.config.getPlatform().getNodeDownloadFilename(this.nodeVersion, false);
        try {
            File destinationDirectory = getInstallDirectory();

            File destination = new File(destinationDirectory, ""node.exe"");

            String classifier = this.config.getPlatform().getNodeClassifier(this.nodeVersion);

            CacheDescriptor cacheDescriptor =
                new CacheDescriptor(""node"", this.nodeVersion, classifier, ""exe"");

            File binary = this.config.getCacheResolver().resolve(cacheDescriptor);

            downloadFileIfMissing(downloadUrl, binary, this.userName, this.password, this.httpHeaders);

            this.logger.info(""Copying node binary from {} to {}"", binary, destination);
            FileUtils.copyFile(binary, destination);

            this.logger.info(""Installed node locally."");
        } catch (DownloadException e) {
            throw new InstallationException(""Could not download Node.js from: "" + downloadUrl, e);
        } catch (IOException e) {
            throw new InstallationException(""Could not install Node.js"", e);
        }
    }

    private File getTempDirectory() {
        File tmpDirectory = new File(getInstallDirectory(), ""tmp"");
        if (!tmpDirectory.exists()) {
            this.logger.debug(""Creating temporary directory {}"", tmpDirectory);
            tmpDirectory.mkdirs();
        }
        return tmpDirectory;
    }

    private File getInstallDirectory() {
        File installDirectory = new File(this.config.getInstallDirectory(), INSTALL_PATH);
        if (!installDirectory.exists()) {
            this.logger.debug(""Creating install directory {}"", installDirectory);
            installDirectory.mkdirs();
        }
        return installDirectory;
    }

    private void deleteTempDirectory(File tmpDirectory) throws IOException {
        if (tmpDirectory != null && tmpDirectory.exists()) {
            this.logger.debug(""Deleting temporary directory {}"", tmpDirectory);
            FileUtils.deleteDirectory(tmpDirectory);
        }
    }

    private void extractFile(File archive, File destinationDirectory) throws ArchiveExtractionException {
        this.logger.info(""Unpacking {} into {}"", archive, destinationDirectory);
        this.archiveExtractor.extract(archive.getPath(), destinationDirectory.getPath());
    }

    private void downloadFileIfMissing(String downloadUrl, File destination, String userName, String password, 
            Map<String, String> httpHeaders) throws DownloadException {
        if (!destination.exists()) {
            downloadFile(downloadUrl, destination, userName, password, httpHeaders);
        }
    }

    private void downloadFile(String downloadUrl, File destination, String userName, String password, 
            Map<String, String> httpHeaders) throws DownloadException {
        this.logger.info(""Downloading {} to {}"", downloadUrl, destination);
        this.fileDownloader.download(downloadUrl, destination.getPath(), userName, password, httpHeaders);
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public class NodeInstaller { public static final String INSTALL_PATH = ""/node""; private static final Object LOCK = new Object(); private String npmVersion, nodeVersion, nodeDownloadRoot, userName, password; private Map<String, String> httpHeaders; private final Logger logger; private final InstallConfig config; private final ArchiveExtractor archiveExtractor; private final FileDownloader fileDownloader; NodeInstaller(InstallConfig config, ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) { this.logger = LoggerFactory.getLogger(getClass()); this.config = config; this.archiveExtractor = archiveExtractor; this.fileDownloader = fileDownloader; } public NodeInstaller setNodeVersion(String nodeVersion) { this.nodeVersion = nodeVersion; return this; } public NodeInstaller setNodeDownloadRoot(String nodeDownloadRoot) { this.nodeDownloadRoot = nodeDownloadRoot; return this; } public NodeInstaller setNpmVersion(String npmVersion) { this.npmVersion = npmVersion; return this; } public NodeInstaller setUserName(String userName) { this.userName = userName; return this; } public NodeInstaller setPassword(String password) { this.password = password; return this; } public NodeInstaller setHttpHeaders(Map<String, String> httpHeaders) { this.httpHeaders = httpHeaders; return this; } private boolean npmProvided() throws InstallationException { if (this.npmVersion != null) { if (""provided"".equals(this.npmVersion)) { if (Integer.parseInt(this.nodeVersion.replace(""v"", """").split(""[.]"")[0]) < 4) { throw new InstallationException(""NPM version is '"" + this.npmVersion
                        + ""' but Node didn't include NPM prior to v4.0.0""); } return true; } return false; } return false; } public void install() throws InstallationException { synchronized (LOCK) { if (this.nodeDownloadRoot == null || this.nodeDownloadRoot.isEmpty()) { this.nodeDownloadRoot = this.config.getPlatform().getNodeDownloadRoot(); } if (!nodeIsAlreadyInstalled()) { this.logger.info(""Installing node version { } "", this.nodeVersion); if (!this.nodeVersion.startsWith(""v"")) { } if (this.config.getPlatform().isWindows()) { if (npmProvided()) { installNodeWithNpmForWindows(); } else { installNodeForWindows(); } } else { installNodeDefault(); } } } } private boolean nodeIsAlreadyInstalled() { try { NodeExecutorConfig executorConfig = new InstallNodeExecutorConfig(this.config); File nodeFile = executorConfig.getNodePath(); if (nodeFile.exists()) { final String version =
                    new NodeExecutor(executorConfig, Arrays.asList(""--version""), null).executeAndGetResult(logger); if (version.equals(this.nodeVersion)) { this.logger.info(""Node { } is already installed."", version); return true; } else { this.logger.info(""Node { } was installed, but we need version { } "", version,
                        this.nodeVersion); return false; } } else { return false; } } catch (ProcessExecutionException e) { this.logger.warn(""Unable to determine current node version: { } "", e.getMessage()); return false; } } private void installNodeDefault() throws InstallationException { try { final String longNodeFilename =
                this.config.getPlatform().getLongNodeFilename(this.nodeVersion, false); String downloadUrl = this.nodeDownloadRoot
                + this.config.getPlatform().getNodeDownloadFilename(this.nodeVersion, false); String classifier = this.config.getPlatform().getNodeClassifier(this.nodeVersion); File tmpDirectory = getTempDirectory(); CacheDescriptor cacheDescriptor = new CacheDescriptor(""node"", this.nodeVersion, classifier,
                this.config.getPlatform().getArchiveExtension()); File archive = this.config.getCacheResolver().resolve(cacheDescriptor); downloadFileIfMissing(downloadUrl, archive, this.userName, this.password, this.httpHeaders); try { extractFile(archive, tmpDirectory); } catch (ArchiveExtractionException e) { if (e.getCause() instanceof EOFException) { this.logger.error(""The archive file { } is corrupted and will be deleted. ""
                            + ""Please try the build again."", archive.getPath()); archive.delete(); FileUtils.deleteDirectory(tmpDirectory); } throw e; } File nodeBinary =
                new File(tmpDirectory, longNodeFilename + File.separator + ""bin"" + File.separator + ""node""); if (!nodeBinary.exists()) { throw new FileNotFoundException(
                    ""Could not find the downloaded Node.js binary in "" + nodeBinary); } else { File destinationDirectory = getInstallDirectory(); File destination = new File(destinationDirectory, ""node""); this.logger.info(""Copying node binary from { } to { } "", nodeBinary, destination); if (destination.exists() && !destination.delete()) { throw new InstallationException(""Could not install Node: Was not allowed to delete "" + destination); } try { Files.move(nodeBinary.toPath(), destination.toPath(), StandardCopyOption.REPLACE_EXISTING); } catch (IOException e) { throw new InstallationException(""Could not install Node: Was not allowed to rename ""
                        + nodeBinary + "" to "" + destination); } if (!destination.setExecutable(true, false)) { throw new InstallationException(
                        ""Could not install Node: Was not allowed to make "" + destination + "" executable.""); } if (npmProvided()) { File tmpNodeModulesDir = new File(tmpDirectory,
                        longNodeFilename + File.separator + ""lib"" + File.separator + ""node_modules""); File nodeModulesDirectory = new File(destinationDirectory, ""node_modules""); File npmDirectory = new File(nodeModulesDirectory, ""npm""); FileUtils.copyDirectory(tmpNodeModulesDir, nodeModulesDirectory); for (String script : Arrays.asList(""npm"", ""npm.cmd"", ""npx"", ""npx.cmd"")) { File scriptFile = new File(npmDirectory, ""bin"" + File.separator + script); if (scriptFile.exists()) { File copy = new File(destinationDirectory, script); if (!copy.exists()) { try
                                { FileUtils.copyFile(scriptFile, copy); } catch (IOException e)
                                { throw new InstallationException(""Could not copy npm"", e); } copy.setExecutable(true); } } } } deleteTempDirectory(tmpDirectory); } } catch (IOException e) { throw new InstallationException(""Could not install Node"", e); } catch (DownloadException e) { throw new InstallationException(""Could not download Node.js"", e); } catch (ArchiveExtractionException e) { throw new InstallationException(""Could not extract the Node archive"", e); } } private void installNodeWithNpmForWindows() throws InstallationException { try { final String longNodeFilename =
                this.config.getPlatform().getLongNodeFilename(this.nodeVersion, true); String downloadUrl = this.nodeDownloadRoot
                + this.config.getPlatform().getNodeDownloadFilename(this.nodeVersion, true); String classifier = this.config.getPlatform().getNodeClassifier(this.nodeVersion); File tmpDirectory = getTempDirectory(); CacheDescriptor cacheDescriptor = new CacheDescriptor(""node"", this.nodeVersion, classifier,
                this.config.getPlatform().getArchiveExtension()); File archive = this.config.getCacheResolver().resolve(cacheDescriptor); downloadFileIfMissing(downloadUrl, archive, this.userName, this.password, this.httpHeaders); extractFile(archive, tmpDirectory); File nodeBinary = new File(tmpDirectory, longNodeFilename + File.separator + ""node.exe""); if (!nodeBinary.exists()) { throw new FileNotFoundException(
                    ""Could not find the downloaded Node.js binary in "" + nodeBinary); } else { File destinationDirectory = getInstallDirectory(); File destination = new File(destinationDirectory, ""node.exe""); this.logger.info(""Copying node binary from { } to { } "", nodeBinary, destination); try { Files.move(nodeBinary.toPath(), destination.toPath(), StandardCopyOption.REPLACE_EXISTING); } catch (IOException e) { throw new InstallationException(""Could not install Node: Was not allowed to rename ""
                        + nodeBinary + "" to "" + destination); } if (""provided"".equals(this.npmVersion)) { File tmpNodeModulesDir =
                        new File(tmpDirectory, longNodeFilename + File.separator + ""node_modules""); File nodeModulesDirectory = new File(destinationDirectory, ""node_modules""); FileUtils.copyDirectory(tmpNodeModulesDir, nodeModulesDirectory); } deleteTempDirectory(tmpDirectory); } } catch (IOException e) { throw new InstallationException(""Could not install Node"", e); } catch (DownloadException e) { throw new InstallationException(""Could not download Node.js"", e); } catch (ArchiveExtractionException e) { throw new InstallationException(""Could not extract the Node archive"", e); } } private void installNodeForWindows() throws InstallationException { final String downloadUrl = this.nodeDownloadRoot
            + this.config.getPlatform().getNodeDownloadFilename(this.nodeVersion, false); try { File destinationDirectory = getInstallDirectory(); File destination = new File(destinationDirectory, ""node.exe""); String classifier = this.config.getPlatform().getNodeClassifier(this.nodeVersion); CacheDescriptor cacheDescriptor =
                new CacheDescriptor(""node"", this.nodeVersion, classifier, ""exe""); File binary = this.config.getCacheResolver().resolve(cacheDescriptor); downloadFileIfMissing(downloadUrl, binary, this.userName, this.password, this.httpHeaders); this.logger.info(""Copying node binary from { } to { } "", binary, destination); FileUtils.copyFile(binary, destination); } catch (DownloadException e) { throw new InstallationException(""Could not download Node.js from: "" + downloadUrl, e); } catch (IOException e) { throw new InstallationException(""Could not install Node.js"", e); } } private File getTempDirectory() { File tmpDirectory = new File(getInstallDirectory(), ""tmp""); if (!tmpDirectory.exists()) { this.logger.debug(""Creating temporary directory { } "", tmpDirectory); tmpDirectory.mkdirs(); } return tmpDirectory; } private File getInstallDirectory() { File installDirectory = new File(this.config.getInstallDirectory(), INSTALL_PATH); if (!installDirectory.exists()) { this.logger.debug(""Creating install directory { } "", installDirectory); installDirectory.mkdirs(); } return installDirectory; } private void deleteTempDirectory(File tmpDirectory) throws IOException { if (tmpDirectory != null && tmpDirectory.exists()) { this.logger.debug(""Deleting temporary directory { } "", tmpDirectory); FileUtils.deleteDirectory(tmpDirectory); } } private void extractFile(File archive, File destinationDirectory) throws ArchiveExtractionException { this.logger.info(""Unpacking { } into { } "", archive, destinationDirectory); this.archiveExtractor.extract(archive.getPath(), destinationDirectory.getPath()); } private void downloadFileIfMissing(String downloadUrl, File destination, String userName, String password, 
            Map<String, String> httpHeaders) throws DownloadException { if (!destination.exists()) { downloadFile(downloadUrl, destination, userName, password, httpHeaders); } } private void downloadFile(String downloadUrl, File destination, String userName, String password, 
            Map<String, String> httpHeaders) throws DownloadException { this.logger.info(""Downloading { } to { } "", downloadUrl, destination); this.fileDownloader.download(downloadUrl, destination.getPath(), userName, password, httpHeaders); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public class NodeInstaller { public static final String INSTALL_PATH = ""/node""; private static final Object LOCK = new Object(); private String npmVersion, nodeVersion, nodeDownloadRoot, userName, password; private Map<String, String> httpHeaders; private final Logger logger; private final InstallConfig config; private final ArchiveExtractor archiveExtractor; private final FileDownloader fileDownloader; NodeInstaller(InstallConfig config, ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) { this.logger = LoggerFactory.getLogger(getClass()); this.config = config; this.archiveExtractor = archiveExtractor; this.fileDownloader = fileDownloader; } public NodeInstaller setNodeVersion(String nodeVersion) { this.nodeVersion = nodeVersion; return this; } public NodeInstaller setNodeDownloadRoot(String nodeDownloadRoot) { this.nodeDownloadRoot = nodeDownloadRoot; return this; } public NodeInstaller setNpmVersion(String npmVersion) { this.npmVersion = npmVersion; return this; } public NodeInstaller setUserName(String userName) { this.userName = userName; return this; } public NodeInstaller setPassword(String password) { this.password = password; return this; } public NodeInstaller setHttpHeaders(Map<String, String> httpHeaders) { this.httpHeaders = httpHeaders; return this; } private boolean npmProvided() throws InstallationException { if (this.npmVersion != null) { if (""provided"".equals(this.npmVersion)) { if (Integer.parseInt(this.nodeVersion.replace(""v"", """").split(""[.]"")[0]) < 4) { throw new InstallationException(""NPM version is '"" + this.npmVersion
                        + ""' but Node didn't include NPM prior to v4.0.0""); } return true; } return false; } return false; } public void install() throws InstallationException { synchronized (LOCK) { if (this.nodeDownloadRoot == null || this.nodeDownloadRoot.isEmpty()) { this.nodeDownloadRoot = this.config.getPlatform().getNodeDownloadRoot(); } if (!nodeIsAlreadyInstalled()) { this.logger.info(""Installing node version { } "", this.nodeVersion); if (!this.nodeVersion.startsWith(""v"")) { <FILL_ME> } if (this.config.getPlatform().isWindows()) { if (npmProvided()) { installNodeWithNpmForWindows(); } else { installNodeForWindows(); } } else { installNodeDefault(); } } } } private boolean nodeIsAlreadyInstalled() { try { NodeExecutorConfig executorConfig = new InstallNodeExecutorConfig(this.config); File nodeFile = executorConfig.getNodePath(); if (nodeFile.exists()) { final String version =
                    new NodeExecutor(executorConfig, Arrays.asList(""--version""), null).executeAndGetResult(logger); if (version.equals(this.nodeVersion)) { this.logger.info(""Node { } is already installed."", version); return true; } else { this.logger.info(""Node { } was installed, but we need version { } "", version,
                        this.nodeVersion); return false; } } else { return false; } } catch (ProcessExecutionException e) { this.logger.warn(""Unable to determine current node version: { } "", e.getMessage()); return false; } } private void installNodeDefault() throws InstallationException { try { final String longNodeFilename =
                this.config.getPlatform().getLongNodeFilename(this.nodeVersion, false); String downloadUrl = this.nodeDownloadRoot
                + this.config.getPlatform().getNodeDownloadFilename(this.nodeVersion, false); String classifier = this.config.getPlatform().getNodeClassifier(this.nodeVersion); File tmpDirectory = getTempDirectory(); CacheDescriptor cacheDescriptor = new CacheDescriptor(""node"", this.nodeVersion, classifier,
                this.config.getPlatform().getArchiveExtension()); File archive = this.config.getCacheResolver().resolve(cacheDescriptor); downloadFileIfMissing(downloadUrl, archive, this.userName, this.password, this.httpHeaders); try { extractFile(archive, tmpDirectory); } catch (ArchiveExtractionException e) { if (e.getCause() instanceof EOFException) { this.logger.error(""The archive file { } is corrupted and will be deleted. ""
                            + ""Please try the build again."", archive.getPath()); archive.delete(); FileUtils.deleteDirectory(tmpDirectory); } throw e; } File nodeBinary =
                new File(tmpDirectory, longNodeFilename + File.separator + ""bin"" + File.separator + ""node""); if (!nodeBinary.exists()) { throw new FileNotFoundException(
                    ""Could not find the downloaded Node.js binary in "" + nodeBinary); } else { File destinationDirectory = getInstallDirectory(); File destination = new File(destinationDirectory, ""node""); this.logger.info(""Copying node binary from { } to { } "", nodeBinary, destination); if (destination.exists() && !destination.delete()) { throw new InstallationException(""Could not install Node: Was not allowed to delete "" + destination); } try { Files.move(nodeBinary.toPath(), destination.toPath(), StandardCopyOption.REPLACE_EXISTING); } catch (IOException e) { throw new InstallationException(""Could not install Node: Was not allowed to rename ""
                        + nodeBinary + "" to "" + destination); } if (!destination.setExecutable(true, false)) { throw new InstallationException(
                        ""Could not install Node: Was not allowed to make "" + destination + "" executable.""); } if (npmProvided()) { File tmpNodeModulesDir = new File(tmpDirectory,
                        longNodeFilename + File.separator + ""lib"" + File.separator + ""node_modules""); File nodeModulesDirectory = new File(destinationDirectory, ""node_modules""); File npmDirectory = new File(nodeModulesDirectory, ""npm""); FileUtils.copyDirectory(tmpNodeModulesDir, nodeModulesDirectory); <FILL_ME> for (String script : Arrays.asList(""npm"", ""npm.cmd"", ""npx"", ""npx.cmd"")) { File scriptFile = new File(npmDirectory, ""bin"" + File.separator + script); if (scriptFile.exists()) { File copy = new File(destinationDirectory, script); if (!copy.exists()) { try
                                { FileUtils.copyFile(scriptFile, copy); } catch (IOException e)
                                { throw new InstallationException(""Could not copy npm"", e); } copy.setExecutable(true); } } } } deleteTempDirectory(tmpDirectory); <FILL_ME> <FILL_ME> } } catch (IOException e) { throw new InstallationException(""Could not install Node"", e); } catch (DownloadException e) { throw new InstallationException(""Could not download Node.js"", e); } catch (ArchiveExtractionException e) { throw new InstallationException(""Could not extract the Node archive"", e); } } private void installNodeWithNpmForWindows() throws InstallationException { try { final String longNodeFilename =
                this.config.getPlatform().getLongNodeFilename(this.nodeVersion, true); String downloadUrl = this.nodeDownloadRoot
                + this.config.getPlatform().getNodeDownloadFilename(this.nodeVersion, true); String classifier = this.config.getPlatform().getNodeClassifier(this.nodeVersion); File tmpDirectory = getTempDirectory(); CacheDescriptor cacheDescriptor = new CacheDescriptor(""node"", this.nodeVersion, classifier,
                this.config.getPlatform().getArchiveExtension()); File archive = this.config.getCacheResolver().resolve(cacheDescriptor); downloadFileIfMissing(downloadUrl, archive, this.userName, this.password, this.httpHeaders); extractFile(archive, tmpDirectory); File nodeBinary = new File(tmpDirectory, longNodeFilename + File.separator + ""node.exe""); if (!nodeBinary.exists()) { throw new FileNotFoundException(
                    ""Could not find the downloaded Node.js binary in "" + nodeBinary); } else { File destinationDirectory = getInstallDirectory(); File destination = new File(destinationDirectory, ""node.exe""); this.logger.info(""Copying node binary from { } to { } "", nodeBinary, destination); try { Files.move(nodeBinary.toPath(), destination.toPath(), StandardCopyOption.REPLACE_EXISTING); } catch (IOException e) { throw new InstallationException(""Could not install Node: Was not allowed to rename ""
                        + nodeBinary + "" to "" + destination); } if (""provided"".equals(this.npmVersion)) { File tmpNodeModulesDir =
                        new File(tmpDirectory, longNodeFilename + File.separator + ""node_modules""); File nodeModulesDirectory = new File(destinationDirectory, ""node_modules""); FileUtils.copyDirectory(tmpNodeModulesDir, nodeModulesDirectory); } deleteTempDirectory(tmpDirectory); } } catch (IOException e) { throw new InstallationException(""Could not install Node"", e); } catch (DownloadException e) { throw new InstallationException(""Could not download Node.js"", e); } catch (ArchiveExtractionException e) { throw new InstallationException(""Could not extract the Node archive"", e); } } private void installNodeForWindows() throws InstallationException { final String downloadUrl = this.nodeDownloadRoot
            + this.config.getPlatform().getNodeDownloadFilename(this.nodeVersion, false); try { File destinationDirectory = getInstallDirectory(); File destination = new File(destinationDirectory, ""node.exe""); String classifier = this.config.getPlatform().getNodeClassifier(this.nodeVersion); CacheDescriptor cacheDescriptor =
                new CacheDescriptor(""node"", this.nodeVersion, classifier, ""exe""); File binary = this.config.getCacheResolver().resolve(cacheDescriptor); downloadFileIfMissing(downloadUrl, binary, this.userName, this.password, this.httpHeaders); this.logger.info(""Copying node binary from { } to { } "", binary, destination); FileUtils.copyFile(binary, destination); <FILL_ME> } catch (DownloadException e) { throw new InstallationException(""Could not download Node.js from: "" + downloadUrl, e); } catch (IOException e) { throw new InstallationException(""Could not install Node.js"", e); } } private File getTempDirectory() { File tmpDirectory = new File(getInstallDirectory(), ""tmp""); if (!tmpDirectory.exists()) { this.logger.debug(""Creating temporary directory { } "", tmpDirectory); tmpDirectory.mkdirs(); } return tmpDirectory; } private File getInstallDirectory() { File installDirectory = new File(this.config.getInstallDirectory(), INSTALL_PATH); if (!installDirectory.exists()) { this.logger.debug(""Creating install directory { } "", installDirectory); installDirectory.mkdirs(); } return installDirectory; } private void deleteTempDirectory(File tmpDirectory) throws IOException { if (tmpDirectory != null && tmpDirectory.exists()) { this.logger.debug(""Deleting temporary directory { } "", tmpDirectory); FileUtils.deleteDirectory(tmpDirectory); } } private void extractFile(File archive, File destinationDirectory) throws ArchiveExtractionException { this.logger.info(""Unpacking { } into { } "", archive, destinationDirectory); this.archiveExtractor.extract(archive.getPath(), destinationDirectory.getPath()); } private void downloadFileIfMissing(String downloadUrl, File destination, String userName, String password, 
            Map<String, String> httpHeaders) throws DownloadException { if (!destination.exists()) { downloadFile(downloadUrl, destination, userName, password, httpHeaders); } } private void downloadFile(String downloadUrl, File destination, String userName, String password, 
            Map<String, String> httpHeaders) throws DownloadException { this.logger.info(""Downloading { } to { } "", downloadUrl, destination); this.fileDownloader.download(downloadUrl, destination.getPath(), userName, password, httpHeaders); } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import java.io.EOFException; import java.io.File; import java.io.FileNotFoundException; import java.io.IOException; import java.nio.file.Files; import java.nio.file.StandardCopyOption; import java.util.Arrays; import java.util.Map; 
import org.apache.commons.io.FileUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class NodeInstaller {  public static final String INSTALL_PATH = ""/node"";  private static final Object LOCK = new Object();  private String npmVersion, nodeVersion, nodeDownloadRoot, userName, password;      private Map<String, String> httpHeaders;  private final Logger logger;  private final InstallConfig config;  private final ArchiveExtractor archiveExtractor;  private final FileDownloader fileDownloader;  NodeInstaller(InstallConfig config, ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) { this.logger = LoggerFactory.getLogger(getClass()); this.config = config; this.archiveExtractor = archiveExtractor; this.fileDownloader = fileDownloader; }  public NodeInstaller setNodeVersion(String nodeVersion) { this.nodeVersion = nodeVersion; return this; }  public NodeInstaller setNodeDownloadRoot(String nodeDownloadRoot) { this.nodeDownloadRoot = nodeDownloadRoot; return this; }  public NodeInstaller setNpmVersion(String npmVersion) { this.npmVersion = npmVersion; return this; }  public NodeInstaller setUserName(String userName) { this.userName = userName; return this; }  public NodeInstaller setPassword(String password) { this.password = password; return this; }      public NodeInstaller setHttpHeaders(Map<String, String> httpHeaders) { this.httpHeaders = httpHeaders; return this; }  private boolean npmProvided() throws InstallationException { if (this.npmVersion != null) { if (""provided"".equals(this.npmVersion)) { if (Integer.parseInt(this.nodeVersion.replace(""v"", """").split(""[.]"")[0]) < 4) { throw new InstallationException(""NPM version is '"" + this.npmVersion
                        + ""' but Node didn't include NPM prior to v4.0.0""); } return true; } return false; } return false; }  public void install() throws InstallationException { // use static lock object for a synchronized block synchronized (LOCK) { if (this.nodeDownloadRoot == null || this.nodeDownloadRoot.isEmpty()) { this.nodeDownloadRoot = this.config.getPlatform().getNodeDownloadRoot(); } if (!nodeIsAlreadyInstalled()) { this.logger.info(""Installing node version { } "", this.nodeVersion); if (!this.nodeVersion.startsWith(""v"")) { <FILL_ME> } if (this.config.getPlatform().isWindows()) { if (npmProvided()) { installNodeWithNpmForWindows(); } else { installNodeForWindows(); } } else { installNodeDefault(); } } } }  private boolean nodeIsAlreadyInstalled() { try { NodeExecutorConfig executorConfig = new InstallNodeExecutorConfig(this.config); File nodeFile = executorConfig.getNodePath(); if (nodeFile.exists()) { final String version =
                    new NodeExecutor(executorConfig, Arrays.asList(""--version""), null).executeAndGetResult(logger);  if (version.equals(this.nodeVersion)) { this.logger.info(""Node { } is already installed."", version); return true; } else { this.logger.info(""Node { } was installed, but we need version { } "", version,
                        this.nodeVersion); return false; } } else { return false; } } catch (ProcessExecutionException e) { this.logger.warn(""Unable to determine current node version: { } "", e.getMessage()); return false; } }  private void installNodeDefault() throws InstallationException { try { final String longNodeFilename =
                this.config.getPlatform().getLongNodeFilename(this.nodeVersion, false); String downloadUrl = this.nodeDownloadRoot
                + this.config.getPlatform().getNodeDownloadFilename(this.nodeVersion, false); String classifier = this.config.getPlatform().getNodeClassifier(this.nodeVersion);  File tmpDirectory = getTempDirectory();  CacheDescriptor cacheDescriptor = new CacheDescriptor(""node"", this.nodeVersion, classifier,
                this.config.getPlatform().getArchiveExtension());  File archive = this.config.getCacheResolver().resolve(cacheDescriptor);  downloadFileIfMissing(downloadUrl, archive, this.userName, this.password, this.httpHeaders);  try { extractFile(archive, tmpDirectory); } catch (ArchiveExtractionException e) { if (e.getCause() instanceof EOFException) { // https://github.com/eirslett/frontend-maven-plugin/issues/794 // The downloading was probably interrupted and archive file is incomplete: // delete it to retry from scratch this.logger.error(""The archive file { } is corrupted and will be deleted. ""
                            + ""Please try the build again."", archive.getPath()); archive.delete(); FileUtils.deleteDirectory(tmpDirectory); }  throw e; }  // Search for the node binary File nodeBinary =
                new File(tmpDirectory, longNodeFilename + File.separator + ""bin"" + File.separator + ""node""); if (!nodeBinary.exists()) { throw new FileNotFoundException(
                    ""Could not find the downloaded Node.js binary in "" + nodeBinary); } else { File destinationDirectory = getInstallDirectory();  File destination = new File(destinationDirectory, ""node""); this.logger.info(""Copying node binary from { } to { } "", nodeBinary, destination); if (destination.exists() && !destination.delete()) { throw new InstallationException(""Could not install Node: Was not allowed to delete "" + destination); } try { Files.move(nodeBinary.toPath(), destination.toPath(), StandardCopyOption.REPLACE_EXISTING); } catch (IOException e) { throw new InstallationException(""Could not install Node: Was not allowed to rename ""
                        + nodeBinary + "" to "" + destination); }  if (!destination.setExecutable(true, false)) { throw new InstallationException(
                        ""Could not install Node: Was not allowed to make "" + destination + "" executable.""); }  if (npmProvided()) { File tmpNodeModulesDir = new File(tmpDirectory,
                        longNodeFilename + File.separator + ""lib"" + File.separator + ""node_modules""); File nodeModulesDirectory = new File(destinationDirectory, ""node_modules""); File npmDirectory = new File(nodeModulesDirectory, ""npm""); FileUtils.copyDirectory(tmpNodeModulesDir, nodeModulesDirectory); <FILL_ME> // create a copy of the npm scripts next to the node executable for (String script : Arrays.asList(""npm"", ""npm.cmd"", ""npx"", ""npx.cmd"")) { File scriptFile = new File(npmDirectory, ""bin"" + File.separator + script); if (scriptFile.exists()) { File copy = new File(destinationDirectory, script); if (!copy.exists()) { try
                                { FileUtils.copyFile(scriptFile, copy); } catch (IOException e)
                                { throw new InstallationException(""Could not copy npm"", e); } copy.setExecutable(true); } } } }  deleteTempDirectory(tmpDirectory); <FILL_ME> <FILL_ME>  } } catch (IOException e) { throw new InstallationException(""Could not install Node"", e); } catch (DownloadException e) { throw new InstallationException(""Could not download Node.js"", e); } catch (ArchiveExtractionException e) { throw new InstallationException(""Could not extract the Node archive"", e); } }  private void installNodeWithNpmForWindows() throws InstallationException { try { final String longNodeFilename =
                this.config.getPlatform().getLongNodeFilename(this.nodeVersion, true); String downloadUrl = this.nodeDownloadRoot
                + this.config.getPlatform().getNodeDownloadFilename(this.nodeVersion, true); String classifier = this.config.getPlatform().getNodeClassifier(this.nodeVersion);  File tmpDirectory = getTempDirectory();  CacheDescriptor cacheDescriptor = new CacheDescriptor(""node"", this.nodeVersion, classifier,
                this.config.getPlatform().getArchiveExtension());  File archive = this.config.getCacheResolver().resolve(cacheDescriptor);  downloadFileIfMissing(downloadUrl, archive, this.userName, this.password, this.httpHeaders);  extractFile(archive, tmpDirectory);  // Search for the node binary File nodeBinary = new File(tmpDirectory, longNodeFilename + File.separator + ""node.exe""); if (!nodeBinary.exists()) { throw new FileNotFoundException(
                    ""Could not find the downloaded Node.js binary in "" + nodeBinary); } else { File destinationDirectory = getInstallDirectory();  File destination = new File(destinationDirectory, ""node.exe""); this.logger.info(""Copying node binary from { } to { } "", nodeBinary, destination); try { Files.move(nodeBinary.toPath(), destination.toPath(), StandardCopyOption.REPLACE_EXISTING); } catch (IOException e) { throw new InstallationException(""Could not install Node: Was not allowed to rename ""
                        + nodeBinary + "" to "" + destination); }  if (""provided"".equals(this.npmVersion)) { File tmpNodeModulesDir =
                        new File(tmpDirectory, longNodeFilename + File.separator + ""node_modules""); File nodeModulesDirectory = new File(destinationDirectory, ""node_modules""); FileUtils.copyDirectory(tmpNodeModulesDir, nodeModulesDirectory); } deleteTempDirectory(tmpDirectory);  } } catch (IOException e) { throw new InstallationException(""Could not install Node"", e); } catch (DownloadException e) { throw new InstallationException(""Could not download Node.js"", e); } catch (ArchiveExtractionException e) { throw new InstallationException(""Could not extract the Node archive"", e); }  }  private void installNodeForWindows() throws InstallationException { final String downloadUrl = this.nodeDownloadRoot
            + this.config.getPlatform().getNodeDownloadFilename(this.nodeVersion, false); try { File destinationDirectory = getInstallDirectory();  File destination = new File(destinationDirectory, ""node.exe"");  String classifier = this.config.getPlatform().getNodeClassifier(this.nodeVersion);  CacheDescriptor cacheDescriptor =
                new CacheDescriptor(""node"", this.nodeVersion, classifier, ""exe"");  File binary = this.config.getCacheResolver().resolve(cacheDescriptor);  downloadFileIfMissing(downloadUrl, binary, this.userName, this.password, this.httpHeaders);  this.logger.info(""Copying node binary from { } to { } "", binary, destination); FileUtils.copyFile(binary, destination); <FILL_ME>  } catch (DownloadException e) { throw new InstallationException(""Could not download Node.js from: "" + downloadUrl, e); } catch (IOException e) { throw new InstallationException(""Could not install Node.js"", e); } }  private File getTempDirectory() { File tmpDirectory = new File(getInstallDirectory(), ""tmp""); if (!tmpDirectory.exists()) { this.logger.debug(""Creating temporary directory { } "", tmpDirectory); tmpDirectory.mkdirs(); } return tmpDirectory; }  private File getInstallDirectory() { File installDirectory = new File(this.config.getInstallDirectory(), INSTALL_PATH); if (!installDirectory.exists()) { this.logger.debug(""Creating install directory { } "", installDirectory); installDirectory.mkdirs(); } return installDirectory; }  private void deleteTempDirectory(File tmpDirectory) throws IOException { if (tmpDirectory != null && tmpDirectory.exists()) { this.logger.debug(""Deleting temporary directory { } "", tmpDirectory); FileUtils.deleteDirectory(tmpDirectory); } }  private void extractFile(File archive, File destinationDirectory) throws ArchiveExtractionException { this.logger.info(""Unpacking { } into { } "", archive, destinationDirectory); this.archiveExtractor.extract(archive.getPath(), destinationDirectory.getPath()); }  private void downloadFileIfMissing(String downloadUrl, File destination, String userName, String password, 
            Map<String, String> httpHeaders) throws DownloadException { if (!destination.exists()) { downloadFile(downloadUrl, destination, userName, password, httpHeaders); } }  private void downloadFile(String downloadUrl, File destination, String userName, String password, 
            Map<String, String> httpHeaders) throws DownloadException { this.logger.info(""Downloading { } to { } "", downloadUrl, destination); this.fileDownloader.download(downloadUrl, destination.getPath(), userName, password, httpHeaders); } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/NodeTaskExecutor.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import static com.github.eirslett.maven.plugins.frontend.lib.Utils.implode;
import static com.github.eirslett.maven.plugins.frontend.lib.Utils.normalize;
import static com.github.eirslett.maven.plugins.frontend.lib.Utils.prepend;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

abstract class NodeTaskExecutor {
    private static final String DS = ""//"";
    private static final String AT = ""@"";

    private final Logger logger;
    private final String taskName;
    private String taskLocation;
    private final ArgumentsParser argumentsParser;
    private final NodeExecutorConfig config;
    private final Map<String, String> proxy;

    public NodeTaskExecutor(NodeExecutorConfig config, String taskLocation) {
        this(config, taskLocation, Collections.<String>emptyList());
    }

    public NodeTaskExecutor(NodeExecutorConfig config, String taskName, String taskLocation) {
        this(config, taskName, taskLocation, Collections.<String>emptyList());
    }

    public NodeTaskExecutor(NodeExecutorConfig config, String taskLocation, List<String> additionalArguments) {
        this(config, getTaskNameFromLocation(taskLocation), taskLocation, additionalArguments);
    }

    public NodeTaskExecutor(NodeExecutorConfig config, String taskName, String taskLocation, List<String> additionalArguments) {
        this(config, taskName, taskLocation, additionalArguments, Collections.<String, String>emptyMap());
    }

    public NodeTaskExecutor(NodeExecutorConfig config, String taskName, String taskLocation, List<String> additionalArguments, Map<String, String> proxy) {
        this.logger = LoggerFactory.getLogger(getClass());
        this.config = config;
        this.taskName = taskName;
        this.taskLocation = taskLocation;
        this.argumentsParser = new ArgumentsParser(additionalArguments);
        this.proxy = proxy;
    }

    private static String getTaskNameFromLocation(String taskLocation) {
        return taskLocation.replaceAll(""^.*/([^/]+)(?:\\.js)?$"",""$1"");
    }


    public final void execute(String args, Map<String, String> environment) throws TaskRunnerException {
        final String absoluteTaskLocation = getAbsoluteTaskLocation();
        final List<String> arguments = getArguments(args);
        logger.info(""Running "" + taskToString(taskName, arguments) + "" in "" + config.getWorkingDirectory());

        try {
            Map<String, String> internalEnvironment = new HashMap<>();
            if (environment != null && !environment.isEmpty()) {
                internalEnvironment.putAll(environment);
            }
            if (!proxy.isEmpty()) {
                internalEnvironment.putAll(proxy);
            }
            final int result = new NodeExecutor(config, prepend(absoluteTaskLocation, arguments), internalEnvironment ).executeAndRedirectOutput(logger);
            if (result != 0) {
                throw new TaskRunnerException(taskToString(taskName, arguments) + "" failed. (error code "" + result + "")"");
            }
        } catch (ProcessExecutionException e) {
            throw new TaskRunnerException(taskToString(taskName, arguments) + "" failed."", e);
        }
    }

    private String getAbsoluteTaskLocation() {
        String location = normalize(taskLocation);
        if (Utils.isRelative(taskLocation)) {
            File taskFile = new File(config.getWorkingDirectory(), location);
            if (!taskFile.exists()) {
                taskFile = new File(config.getInstallDirectory(), location);
            }
            location = taskFile.getAbsolutePath();
        }
        return location;
    }



    private List<String> getArguments(String args) {
        return argumentsParser.parse(args);
    }

    private static String taskToString(String taskName, List<String> arguments) {
        List<String> clonedArguments = new ArrayList<String>(arguments);
        for (int i = 0; i < clonedArguments.size(); i++) {
            final String s = clonedArguments.get(i);
            final boolean maskMavenProxyPassword = s.contains(""proxy="");
            if (maskMavenProxyPassword) {
                final String bestEffortMaskedPassword = maskPassword(s);
                clonedArguments.set(i, bestEffortMaskedPassword);
            }
        }
        return ""'"" + taskName + "" "" + implode("" "", clonedArguments) + ""'"";
    }

    private static String maskPassword(String proxyString) {
        String retVal = proxyString;
        if (proxyString != null && !"""".equals(proxyString.trim())) {
            boolean hasSchemeDefined = proxyString.contains(""http:"") || proxyString.contains(""https:"");
            boolean hasProtocolDefined = proxyString.contains(DS);
            boolean hasAtCharacterDefined = proxyString.contains(AT);
            if (hasSchemeDefined && hasProtocolDefined && hasAtCharacterDefined) {
                final int firstDoubleSlashIndex = proxyString.indexOf(DS);
                final int lastAtCharIndex = proxyString.lastIndexOf(AT);
                boolean hasPossibleURIUserInfo = firstDoubleSlashIndex < lastAtCharIndex;
                if (hasPossibleURIUserInfo) {
                    final String userInfo = proxyString.substring(firstDoubleSlashIndex + DS.length(), lastAtCharIndex);
                    final String[] userParts = userInfo.split("":"");
                    if (userParts.length > 0) {
                        final int startOfUserNameIndex = firstDoubleSlashIndex + DS.length();
                        final int firstColonInUsernameOrEndOfUserNameIndex = startOfUserNameIndex + userParts[0].length();
                        final String leftPart = proxyString.substring(0, firstColonInUsernameOrEndOfUserNameIndex);
                        final String rightPart = proxyString.substring(lastAtCharIndex);
                        retVal = leftPart + "":***"" + rightPart;
                    }
                }
            }
        }
        return retVal;
    }

    public void setTaskLocation(String taskLocation) {
        this.taskLocation = taskLocation;
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; abstract class NodeTaskExecutor { private static final String AT = ""@""; private final Logger logger; private final String taskName; private String taskLocation; private final ArgumentsParser argumentsParser; private final NodeExecutorConfig config; private final Map<String, String> proxy; public NodeTaskExecutor(NodeExecutorConfig config, String taskLocation) { this(config, taskLocation, Collections.<String>emptyList()); } public NodeTaskExecutor(NodeExecutorConfig config, String taskName, String taskLocation) { this(config, taskName, taskLocation, Collections.<String>emptyList()); } public NodeTaskExecutor(NodeExecutorConfig config, String taskLocation, List<String> additionalArguments) { this(config, getTaskNameFromLocation(taskLocation), taskLocation, additionalArguments); } public NodeTaskExecutor(NodeExecutorConfig config, String taskName, String taskLocation, List<String> additionalArguments) { this(config, taskName, taskLocation, additionalArguments, Collections.<String, String>emptyMap()); } public NodeTaskExecutor(NodeExecutorConfig config, String taskName, String taskLocation, List<String> additionalArguments, Map<String, String> proxy) { this.logger = LoggerFactory.getLogger(getClass()); this.config = config; this.taskName = taskName; this.taskLocation = taskLocation; this.argumentsParser = new ArgumentsParser(additionalArguments); this.proxy = proxy; } private static String getTaskNameFromLocation(String taskLocation) { return taskLocation.replaceAll(""^.*/([^/]+)(?:\\.js)?$"",""$1""); } public final void execute(String args, Map<String, String> environment) throws TaskRunnerException { final String absoluteTaskLocation = getAbsoluteTaskLocation(); final List<String> arguments = getArguments(args); try { Map<String, String> internalEnvironment = new HashMap<>(); if (environment != null && !environment.isEmpty()) { internalEnvironment.putAll(environment); } if (!proxy.isEmpty()) { internalEnvironment.putAll(proxy); } final int result = new NodeExecutor(config, prepend(absoluteTaskLocation, arguments), internalEnvironment ).executeAndRedirectOutput(logger); if (result != 0) { throw new TaskRunnerException(taskToString(taskName, arguments) + "" failed. (error code "" + result + "")""); } } catch (ProcessExecutionException e) { throw new TaskRunnerException(taskToString(taskName, arguments) + "" failed."", e); } } private String getAbsoluteTaskLocation() { String location = normalize(taskLocation); if (Utils.isRelative(taskLocation)) { File taskFile = new File(config.getWorkingDirectory(), location); if (!taskFile.exists()) { taskFile = new File(config.getInstallDirectory(), location); } location = taskFile.getAbsolutePath(); } return location; } private List<String> getArguments(String args) { return argumentsParser.parse(args); } private static String taskToString(String taskName, List<String> arguments) { List<String> clonedArguments = new ArrayList<String>(arguments); for (int i = 0; i < clonedArguments.size(); i++) { final String s = clonedArguments.get(i); final boolean maskMavenProxyPassword = s.contains(""proxy=""); if (maskMavenProxyPassword) { final String bestEffortMaskedPassword = maskPassword(s); clonedArguments.set(i, bestEffortMaskedPassword); } } return ""'"" + taskName + "" "" + implode("" "", clonedArguments) + ""'""; } private static String maskPassword(String proxyString) { String retVal = proxyString; if (proxyString != null && !"""".equals(proxyString.trim())) { boolean hasSchemeDefined = proxyString.contains(""http:"") || proxyString.contains(""https:""); boolean hasProtocolDefined = proxyString.contains(DS); boolean hasAtCharacterDefined = proxyString.contains(AT); if (hasSchemeDefined && hasProtocolDefined && hasAtCharacterDefined) { final int firstDoubleSlashIndex = proxyString.indexOf(DS); final int lastAtCharIndex = proxyString.lastIndexOf(AT); boolean hasPossibleURIUserInfo = firstDoubleSlashIndex < lastAtCharIndex; if (hasPossibleURIUserInfo) { final String userInfo = proxyString.substring(firstDoubleSlashIndex + DS.length(), lastAtCharIndex); final String[] userParts = userInfo.split("":""); if (userParts.length > 0) { final int startOfUserNameIndex = firstDoubleSlashIndex + DS.length(); final int firstColonInUsernameOrEndOfUserNameIndex = startOfUserNameIndex + userParts[0].length(); final String leftPart = proxyString.substring(0, firstColonInUsernameOrEndOfUserNameIndex); final String rightPart = proxyString.substring(lastAtCharIndex); retVal = leftPart + "":***"" + rightPart; } } } } return retVal; } public void setTaskLocation(String taskLocation) { this.taskLocation = taskLocation; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; abstract class NodeTaskExecutor { private static final String AT = ""@""; private final Logger logger; private final String taskName; private String taskLocation; private final ArgumentsParser argumentsParser; private final NodeExecutorConfig config; private final Map<String, String> proxy; public NodeTaskExecutor(NodeExecutorConfig config, String taskLocation) { this(config, taskLocation, Collections.<String>emptyList()); } public NodeTaskExecutor(NodeExecutorConfig config, String taskName, String taskLocation) { this(config, taskName, taskLocation, Collections.<String>emptyList()); } public NodeTaskExecutor(NodeExecutorConfig config, String taskLocation, List<String> additionalArguments) { this(config, getTaskNameFromLocation(taskLocation), taskLocation, additionalArguments); } public NodeTaskExecutor(NodeExecutorConfig config, String taskName, String taskLocation, List<String> additionalArguments) { this(config, taskName, taskLocation, additionalArguments, Collections.<String, String>emptyMap()); } public NodeTaskExecutor(NodeExecutorConfig config, String taskName, String taskLocation, List<String> additionalArguments, Map<String, String> proxy) { this.logger = LoggerFactory.getLogger(getClass()); this.config = config; this.taskName = taskName; this.taskLocation = taskLocation; this.argumentsParser = new ArgumentsParser(additionalArguments); this.proxy = proxy; } private static String getTaskNameFromLocation(String taskLocation) { return taskLocation.replaceAll(""^.*/([^/]+)(?:\\.js)?$"",""$1""); } public final void execute(String args, Map<String, String> environment) throws TaskRunnerException { final String absoluteTaskLocation = getAbsoluteTaskLocation(); final List<String> arguments = getArguments(args); <FILL_ME> try { Map<String, String> internalEnvironment = new HashMap<>(); if (environment != null && !environment.isEmpty()) { internalEnvironment.putAll(environment); } if (!proxy.isEmpty()) { internalEnvironment.putAll(proxy); } final int result = new NodeExecutor(config, prepend(absoluteTaskLocation, arguments), internalEnvironment ).executeAndRedirectOutput(logger); if (result != 0) { throw new TaskRunnerException(taskToString(taskName, arguments) + "" failed. (error code "" + result + "")""); } } catch (ProcessExecutionException e) { throw new TaskRunnerException(taskToString(taskName, arguments) + "" failed."", e); } } private String getAbsoluteTaskLocation() { String location = normalize(taskLocation); if (Utils.isRelative(taskLocation)) { File taskFile = new File(config.getWorkingDirectory(), location); if (!taskFile.exists()) { taskFile = new File(config.getInstallDirectory(), location); } location = taskFile.getAbsolutePath(); } return location; } private List<String> getArguments(String args) { return argumentsParser.parse(args); } private static String taskToString(String taskName, List<String> arguments) { List<String> clonedArguments = new ArrayList<String>(arguments); for (int i = 0; i < clonedArguments.size(); i++) { final String s = clonedArguments.get(i); final boolean maskMavenProxyPassword = s.contains(""proxy=""); if (maskMavenProxyPassword) { final String bestEffortMaskedPassword = maskPassword(s); clonedArguments.set(i, bestEffortMaskedPassword); } } return ""'"" + taskName + "" "" + implode("" "", clonedArguments) + ""'""; } private static String maskPassword(String proxyString) { String retVal = proxyString; if (proxyString != null && !"""".equals(proxyString.trim())) { boolean hasSchemeDefined = proxyString.contains(""http:"") || proxyString.contains(""https:""); boolean hasProtocolDefined = proxyString.contains(DS); boolean hasAtCharacterDefined = proxyString.contains(AT); if (hasSchemeDefined && hasProtocolDefined && hasAtCharacterDefined) { final int firstDoubleSlashIndex = proxyString.indexOf(DS); final int lastAtCharIndex = proxyString.lastIndexOf(AT); boolean hasPossibleURIUserInfo = firstDoubleSlashIndex < lastAtCharIndex; if (hasPossibleURIUserInfo) { final String userInfo = proxyString.substring(firstDoubleSlashIndex + DS.length(), lastAtCharIndex); final String[] userParts = userInfo.split("":""); if (userParts.length > 0) { final int startOfUserNameIndex = firstDoubleSlashIndex + DS.length(); final int firstColonInUsernameOrEndOfUserNameIndex = startOfUserNameIndex + userParts[0].length(); final String leftPart = proxyString.substring(0, firstColonInUsernameOrEndOfUserNameIndex); final String rightPart = proxyString.substring(lastAtCharIndex); retVal = leftPart + "":***"" + rightPart; } } } } return retVal; } public void setTaskLocation(String taskLocation) { this.taskLocation = taskLocation; } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import static com.github.eirslett.maven.plugins.frontend.lib.Utils.implode; import static com.github.eirslett.maven.plugins.frontend.lib.Utils.normalize; import static com.github.eirslett.maven.plugins.frontend.lib.Utils.prepend; 
import java.io.File; import java.util.ArrayList; import java.util.Collections; import java.util.HashMap; import java.util.List; import java.util.Map; 
import org.slf4j.Logger; import org.slf4j.LoggerFactory;  abstract class NodeTaskExecutor { //""; private static final String AT = ""@"";  private final Logger logger; private final String taskName; private String taskLocation; private final ArgumentsParser argumentsParser; private final NodeExecutorConfig config; private final Map<String, String> proxy;  public NodeTaskExecutor(NodeExecutorConfig config, String taskLocation) { this(config, taskLocation, Collections.<String>emptyList()); }  public NodeTaskExecutor(NodeExecutorConfig config, String taskName, String taskLocation) { this(config, taskName, taskLocation, Collections.<String>emptyList()); }  public NodeTaskExecutor(NodeExecutorConfig config, String taskLocation, List<String> additionalArguments) { this(config, getTaskNameFromLocation(taskLocation), taskLocation, additionalArguments); }  public NodeTaskExecutor(NodeExecutorConfig config, String taskName, String taskLocation, List<String> additionalArguments) { this(config, taskName, taskLocation, additionalArguments, Collections.<String, String>emptyMap()); }  public NodeTaskExecutor(NodeExecutorConfig config, String taskName, String taskLocation, List<String> additionalArguments, Map<String, String> proxy) { this.logger = LoggerFactory.getLogger(getClass()); this.config = config; this.taskName = taskName; this.taskLocation = taskLocation; this.argumentsParser = new ArgumentsParser(additionalArguments); this.proxy = proxy; }  private static String getTaskNameFromLocation(String taskLocation) { return taskLocation.replaceAll(""^.*/([^/]+)(?:\\.js)?$"",""$1""); } 
 public final void execute(String args, Map<String, String> environment) throws TaskRunnerException { final String absoluteTaskLocation = getAbsoluteTaskLocation(); final List<String> arguments = getArguments(args); <FILL_ME>  try { Map<String, String> internalEnvironment = new HashMap<>(); if (environment != null && !environment.isEmpty()) { internalEnvironment.putAll(environment); } if (!proxy.isEmpty()) { internalEnvironment.putAll(proxy); } final int result = new NodeExecutor(config, prepend(absoluteTaskLocation, arguments), internalEnvironment ).executeAndRedirectOutput(logger); if (result != 0) { throw new TaskRunnerException(taskToString(taskName, arguments) + "" failed. (error code "" + result + "")""); } } catch (ProcessExecutionException e) { throw new TaskRunnerException(taskToString(taskName, arguments) + "" failed."", e); } }  private String getAbsoluteTaskLocation() { String location = normalize(taskLocation); if (Utils.isRelative(taskLocation)) { File taskFile = new File(config.getWorkingDirectory(), location); if (!taskFile.exists()) { taskFile = new File(config.getInstallDirectory(), location); } location = taskFile.getAbsolutePath(); } return location; }  private List<String> getArguments(String args) { return argumentsParser.parse(args); } 

 private static String taskToString(String taskName, List<String> arguments) { List<String> clonedArguments = new ArrayList<String>(arguments); for (int i = 0; i < clonedArguments.size(); i++) { final String s = clonedArguments.get(i); final boolean maskMavenProxyPassword = s.contains(""proxy=""); if (maskMavenProxyPassword) { final String bestEffortMaskedPassword = maskPassword(s); clonedArguments.set(i, bestEffortMaskedPassword); } } return ""'"" + taskName + "" "" + implode("" "", clonedArguments) + ""'""; }  private static String maskPassword(String proxyString) { String retVal = proxyString; if (proxyString != null && !"""".equals(proxyString.trim())) { boolean hasSchemeDefined = proxyString.contains(""http:"") || proxyString.contains(""https:""); boolean hasProtocolDefined = proxyString.contains(DS); boolean hasAtCharacterDefined = proxyString.contains(AT); if (hasSchemeDefined && hasProtocolDefined && hasAtCharacterDefined) { final int firstDoubleSlashIndex = proxyString.indexOf(DS); final int lastAtCharIndex = proxyString.lastIndexOf(AT); boolean hasPossibleURIUserInfo = firstDoubleSlashIndex < lastAtCharIndex; if (hasPossibleURIUserInfo) { final String userInfo = proxyString.substring(firstDoubleSlashIndex + DS.length(), lastAtCharIndex); final String[] userParts = userInfo.split("":""); if (userParts.length > 0) { final int startOfUserNameIndex = firstDoubleSlashIndex + DS.length(); final int firstColonInUsernameOrEndOfUserNameIndex = startOfUserNameIndex + userParts[0].length(); final String leftPart = proxyString.substring(0, firstColonInUsernameOrEndOfUserNameIndex); final String rightPart = proxyString.substring(lastAtCharIndex); retVal = leftPart + "":***"" + rightPart; } } } } return retVal; }  public void setTaskLocation(String taskLocation) { this.taskLocation = taskLocation; } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/NodeTaskRunner.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import java.util.Map;

interface NodeTaskRunner {
	void execute(String args, Map<String,String> environment) throws TaskRunnerException;
}
","package com.github.eirslett.maven.plugins.frontend.lib; interface NodeTaskRunner { void execute(String args, Map<String,String> environment) throws TaskRunnerException; }",0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; interface NodeTaskRunner { void execute(String args, Map<String,String> environment) throws TaskRunnerException; } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import java.util.Map;  interface NodeTaskRunner { void execute(String args, Map<String,String> environment) throws TaskRunnerException; }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/NpmRunner.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig.Proxy;

public interface NpmRunner extends NodeTaskRunner {}

final class DefaultNpmRunner extends NodeTaskExecutor implements NpmRunner {
    static final String TASK_NAME = ""npm"";

    public DefaultNpmRunner(NodeExecutorConfig config, ProxyConfig proxyConfig, String npmRegistryURL) {
        super(config, TASK_NAME, config.getNpmPath().getAbsolutePath(), buildArguments(proxyConfig, npmRegistryURL),
        		buildProxy(proxyConfig, npmRegistryURL));
    }

    // Visible for testing only.
    static List<String> buildArguments(ProxyConfig proxyConfig, String npmRegistryURL) {
        List<String> arguments = new ArrayList<String>();

        if(npmRegistryURL != null && !npmRegistryURL.isEmpty()){
            arguments.add (""--registry="" + npmRegistryURL);
        }

        if(!proxyConfig.isEmpty()){
            Proxy proxy = getProxyConfig(proxyConfig, npmRegistryURL);

            arguments.add(""--https-proxy="" + proxy.getUri().toString());
            arguments.add(""--proxy="" + proxy.getUri().toString());

            final String nonProxyHosts = proxy.getNonProxyHosts();
            if (nonProxyHosts != null && !nonProxyHosts.isEmpty()) {
                final String[] nonProxyHostList = nonProxyHosts.split(""\\|"");
                for (String nonProxyHost: nonProxyHostList) {
                    arguments.add(""--noproxy="" + nonProxyHost.replace(""*"", """"));
                }
            }
        }

        return arguments;
    }

    private static Map<String, String> buildProxy(ProxyConfig proxyConfig, String npmRegistryURL) {
        Map<String, String> proxyEnvironmentVariables = Collections.emptyMap();

        if(!proxyConfig.isEmpty()){
            Proxy proxy = getProxyConfig(proxyConfig, npmRegistryURL);
            proxyEnvironmentVariables = new HashMap<>();

            proxyEnvironmentVariables.put(""https_proxy"", proxy.getUri().toString());
            proxyEnvironmentVariables.put(""http_proxy"", proxy.getUri().toString());
        }

        return proxyEnvironmentVariables;
    }

	private static Proxy getProxyConfig(ProxyConfig proxyConfig, String npmRegistryURL) {
		Proxy proxy = null;
		if(npmRegistryURL != null && !npmRegistryURL.isEmpty()){
		    proxy = proxyConfig.getProxyForUrl(npmRegistryURL);
		}

		if(proxy == null){
		    proxy = proxyConfig.getSecureProxy();
		}

		if(proxy == null){
		    proxy = proxyConfig.getInsecureProxy();
		}
		return proxy;
	}
}
","package com.github.eirslett.maven.plugins.frontend.lib; public interface NpmRunner extends NodeTaskRunner { } final class DefaultNpmRunner extends NodeTaskExecutor implements NpmRunner { static final String TASK_NAME = ""npm""; public DefaultNpmRunner(NodeExecutorConfig config, ProxyConfig proxyConfig, String npmRegistryURL) { super(config, TASK_NAME, config.getNpmPath().getAbsolutePath(), buildArguments(proxyConfig, npmRegistryURL),
        		buildProxy(proxyConfig, npmRegistryURL)); } static List<String> buildArguments(ProxyConfig proxyConfig, String npmRegistryURL) { List<String> arguments = new ArrayList<String>(); if(npmRegistryURL != null && !npmRegistryURL.isEmpty()){ arguments.add (""--registry="" + npmRegistryURL); } if(!proxyConfig.isEmpty()){ Proxy proxy = getProxyConfig(proxyConfig, npmRegistryURL); arguments.add(""--https-proxy="" + proxy.getUri().toString()); arguments.add(""--proxy="" + proxy.getUri().toString()); final String nonProxyHosts = proxy.getNonProxyHosts(); if (nonProxyHosts != null && !nonProxyHosts.isEmpty()) { final String[] nonProxyHostList = nonProxyHosts.split(""\\|""); for (String nonProxyHost: nonProxyHostList) { arguments.add(""--noproxy="" + nonProxyHost.replace(""*"", """")); } } } return arguments; } private static Map<String, String> buildProxy(ProxyConfig proxyConfig, String npmRegistryURL) { Map<String, String> proxyEnvironmentVariables = Collections.emptyMap(); if(!proxyConfig.isEmpty()){ Proxy proxy = getProxyConfig(proxyConfig, npmRegistryURL); proxyEnvironmentVariables = new HashMap<>(); proxyEnvironmentVariables.put(""https_proxy"", proxy.getUri().toString()); proxyEnvironmentVariables.put(""http_proxy"", proxy.getUri().toString()); } return proxyEnvironmentVariables; } private static Proxy getProxyConfig(ProxyConfig proxyConfig, String npmRegistryURL) { Proxy proxy = null; if(npmRegistryURL != null && !npmRegistryURL.isEmpty()){ proxy = proxyConfig.getProxyForUrl(npmRegistryURL); } if(proxy == null){ proxy = proxyConfig.getSecureProxy(); } if(proxy == null){ proxy = proxyConfig.getInsecureProxy(); } return proxy; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public interface NpmRunner extends NodeTaskRunner { } final class DefaultNpmRunner extends NodeTaskExecutor implements NpmRunner { static final String TASK_NAME = ""npm""; public DefaultNpmRunner(NodeExecutorConfig config, ProxyConfig proxyConfig, String npmRegistryURL) { super(config, TASK_NAME, config.getNpmPath().getAbsolutePath(), buildArguments(proxyConfig, npmRegistryURL),
        		buildProxy(proxyConfig, npmRegistryURL)); } static List<String> buildArguments(ProxyConfig proxyConfig, String npmRegistryURL) { List<String> arguments = new ArrayList<String>(); if(npmRegistryURL != null && !npmRegistryURL.isEmpty()){ arguments.add (""--registry="" + npmRegistryURL); } if(!proxyConfig.isEmpty()){ Proxy proxy = getProxyConfig(proxyConfig, npmRegistryURL); arguments.add(""--https-proxy="" + proxy.getUri().toString()); arguments.add(""--proxy="" + proxy.getUri().toString()); final String nonProxyHosts = proxy.getNonProxyHosts(); if (nonProxyHosts != null && !nonProxyHosts.isEmpty()) { final String[] nonProxyHostList = nonProxyHosts.split(""\\|""); for (String nonProxyHost: nonProxyHostList) { arguments.add(""--noproxy="" + nonProxyHost.replace(""*"", """")); } } } return arguments; } private static Map<String, String> buildProxy(ProxyConfig proxyConfig, String npmRegistryURL) { Map<String, String> proxyEnvironmentVariables = Collections.emptyMap(); if(!proxyConfig.isEmpty()){ Proxy proxy = getProxyConfig(proxyConfig, npmRegistryURL); proxyEnvironmentVariables = new HashMap<>(); proxyEnvironmentVariables.put(""https_proxy"", proxy.getUri().toString()); proxyEnvironmentVariables.put(""http_proxy"", proxy.getUri().toString()); } return proxyEnvironmentVariables; } private static Proxy getProxyConfig(ProxyConfig proxyConfig, String npmRegistryURL) { Proxy proxy = null; if(npmRegistryURL != null && !npmRegistryURL.isEmpty()){ proxy = proxyConfig.getProxyForUrl(npmRegistryURL); } if(proxy == null){ proxy = proxyConfig.getSecureProxy(); } if(proxy == null){ proxy = proxyConfig.getInsecureProxy(); } return proxy; } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import java.util.ArrayList; import java.util.Collections; import java.util.HashMap; import java.util.List; import java.util.Map; 
import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig.Proxy;  public interface NpmRunner extends NodeTaskRunner { }  final class DefaultNpmRunner extends NodeTaskExecutor implements NpmRunner { static final String TASK_NAME = ""npm"";  public DefaultNpmRunner(NodeExecutorConfig config, ProxyConfig proxyConfig, String npmRegistryURL) { super(config, TASK_NAME, config.getNpmPath().getAbsolutePath(), buildArguments(proxyConfig, npmRegistryURL),
        		buildProxy(proxyConfig, npmRegistryURL)); }  // Visible for testing only. static List<String> buildArguments(ProxyConfig proxyConfig, String npmRegistryURL) { List<String> arguments = new ArrayList<String>();  if(npmRegistryURL != null && !npmRegistryURL.isEmpty()){ arguments.add (""--registry="" + npmRegistryURL); }  if(!proxyConfig.isEmpty()){ Proxy proxy = getProxyConfig(proxyConfig, npmRegistryURL);  arguments.add(""--https-proxy="" + proxy.getUri().toString()); arguments.add(""--proxy="" + proxy.getUri().toString());  final String nonProxyHosts = proxy.getNonProxyHosts(); if (nonProxyHosts != null && !nonProxyHosts.isEmpty()) { final String[] nonProxyHostList = nonProxyHosts.split(""\\|""); for (String nonProxyHost: nonProxyHostList) { arguments.add(""--noproxy="" + nonProxyHost.replace(""*"", """")); } } }  return arguments; }  private static Map<String, String> buildProxy(ProxyConfig proxyConfig, String npmRegistryURL) { Map<String, String> proxyEnvironmentVariables = Collections.emptyMap();  if(!proxyConfig.isEmpty()){ Proxy proxy = getProxyConfig(proxyConfig, npmRegistryURL); proxyEnvironmentVariables = new HashMap<>();  proxyEnvironmentVariables.put(""https_proxy"", proxy.getUri().toString()); proxyEnvironmentVariables.put(""http_proxy"", proxy.getUri().toString()); }  return proxyEnvironmentVariables; }  private static Proxy getProxyConfig(ProxyConfig proxyConfig, String npmRegistryURL) { Proxy proxy = null; if(npmRegistryURL != null && !npmRegistryURL.isEmpty()){ proxy = proxyConfig.getProxyForUrl(npmRegistryURL); }  if(proxy == null){ proxy = proxyConfig.getSecureProxy(); }  if(proxy == null){ proxy = proxyConfig.getInsecureProxy(); } return proxy; } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/NpxRunner.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig.Proxy;

import java.util.ArrayList;
import java.util.List;

public interface NpxRunner extends NodeTaskRunner {}

final class DefaultNpxRunner extends NodeTaskExecutor implements NpxRunner {
    static final String TASK_NAME = ""npx"";

    public DefaultNpxRunner(NodeExecutorConfig config, ProxyConfig proxyConfig, String npmRegistryURL) {
        super(config, TASK_NAME, config.getNpxPath().getAbsolutePath(), buildNpmArguments(proxyConfig, npmRegistryURL));
    }

    // Visible for testing only.
    /**
     * These are, in fact, npm arguments, that need to be split from the npx arguments by '--'.
     *
     * See an example:
     * npx some-package -- --registry=http://myspecialregisty.com
     */
    static List<String> buildNpmArguments(ProxyConfig proxyConfig, String npmRegistryURL) {
        List<String> arguments = new ArrayList<>();
               
        if(npmRegistryURL != null && !npmRegistryURL.isEmpty()){
            arguments.add (""--registry="" + npmRegistryURL);
        }

        if(!proxyConfig.isEmpty()){
            Proxy proxy = null;
            if(npmRegistryURL != null && !npmRegistryURL.isEmpty()){
                proxy = proxyConfig.getProxyForUrl(npmRegistryURL);
            }

            if(proxy == null){
                proxy = proxyConfig.getSecureProxy();
            }

            if(proxy == null){
                proxy = proxyConfig.getInsecureProxy();
            }

            arguments.add(""--https-proxy="" + proxy.getUri().toString());
            arguments.add(""--proxy="" + proxy.getUri().toString());
        }

        List<String> npmArguments;
        if (arguments.isEmpty()) {
            npmArguments = arguments;
        } else {
            npmArguments = new ArrayList<>();
            npmArguments.add(""--"");
            npmArguments.addAll(arguments);
        }
        
        return npmArguments;
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public interface NpxRunner extends NodeTaskRunner { } final class DefaultNpxRunner extends NodeTaskExecutor implements NpxRunner { static final String TASK_NAME = ""npx""; public DefaultNpxRunner(NodeExecutorConfig config, ProxyConfig proxyConfig, String npmRegistryURL) { super(config, TASK_NAME, config.getNpxPath().getAbsolutePath(), buildNpmArguments(proxyConfig, npmRegistryURL)); } static List<String> buildNpmArguments(ProxyConfig proxyConfig, String npmRegistryURL) { List<String> arguments = new ArrayList<>(); if(npmRegistryURL != null && !npmRegistryURL.isEmpty()){ arguments.add (""--registry="" + npmRegistryURL); } if(!proxyConfig.isEmpty()){ Proxy proxy = null; if(npmRegistryURL != null && !npmRegistryURL.isEmpty()){ proxy = proxyConfig.getProxyForUrl(npmRegistryURL); } if(proxy == null){ proxy = proxyConfig.getSecureProxy(); } if(proxy == null){ proxy = proxyConfig.getInsecureProxy(); } arguments.add(""--https-proxy="" + proxy.getUri().toString()); arguments.add(""--proxy="" + proxy.getUri().toString()); } List<String> npmArguments; if (arguments.isEmpty()) { npmArguments = arguments; } else { npmArguments = new ArrayList<>(); npmArguments.add(""--""); npmArguments.addAll(arguments); } return npmArguments; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public interface NpxRunner extends NodeTaskRunner { } final class DefaultNpxRunner extends NodeTaskExecutor implements NpxRunner { static final String TASK_NAME = ""npx""; public DefaultNpxRunner(NodeExecutorConfig config, ProxyConfig proxyConfig, String npmRegistryURL) { super(config, TASK_NAME, config.getNpxPath().getAbsolutePath(), buildNpmArguments(proxyConfig, npmRegistryURL)); } static List<String> buildNpmArguments(ProxyConfig proxyConfig, String npmRegistryURL) { List<String> arguments = new ArrayList<>(); if(npmRegistryURL != null && !npmRegistryURL.isEmpty()){ arguments.add (""--registry="" + npmRegistryURL); } if(!proxyConfig.isEmpty()){ Proxy proxy = null; if(npmRegistryURL != null && !npmRegistryURL.isEmpty()){ proxy = proxyConfig.getProxyForUrl(npmRegistryURL); } if(proxy == null){ proxy = proxyConfig.getSecureProxy(); } if(proxy == null){ proxy = proxyConfig.getInsecureProxy(); } arguments.add(""--https-proxy="" + proxy.getUri().toString()); arguments.add(""--proxy="" + proxy.getUri().toString()); } List<String> npmArguments; if (arguments.isEmpty()) { npmArguments = arguments; } else { npmArguments = new ArrayList<>(); npmArguments.add(""--""); npmArguments.addAll(arguments); } return npmArguments; } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig.Proxy; 
import java.util.ArrayList; import java.util.List;  public interface NpxRunner extends NodeTaskRunner { }  final class DefaultNpxRunner extends NodeTaskExecutor implements NpxRunner { static final String TASK_NAME = ""npx"";  public DefaultNpxRunner(NodeExecutorConfig config, ProxyConfig proxyConfig, String npmRegistryURL) { super(config, TASK_NAME, config.getNpxPath().getAbsolutePath(), buildNpmArguments(proxyConfig, npmRegistryURL)); }  // Visible for testing only. /**
     * These are, in fact, npm arguments, that need to be split from the npx arguments by '--'.
     *
     * See an example:
     * npx some-package -- --registry=http://myspecialregisty.com
     */ static List<String> buildNpmArguments(ProxyConfig proxyConfig, String npmRegistryURL) { List<String> arguments = new ArrayList<>();                 if(npmRegistryURL != null && !npmRegistryURL.isEmpty()){ arguments.add (""--registry="" + npmRegistryURL); }  if(!proxyConfig.isEmpty()){ Proxy proxy = null; if(npmRegistryURL != null && !npmRegistryURL.isEmpty()){ proxy = proxyConfig.getProxyForUrl(npmRegistryURL); }  if(proxy == null){ proxy = proxyConfig.getSecureProxy(); }  if(proxy == null){ proxy = proxyConfig.getInsecureProxy(); }  arguments.add(""--https-proxy="" + proxy.getUri().toString()); arguments.add(""--proxy="" + proxy.getUri().toString()); }  List<String> npmArguments; if (arguments.isEmpty()) { npmArguments = arguments; } else { npmArguments = new ArrayList<>(); npmArguments.add(""--""); npmArguments.addAll(arguments); }          return npmArguments; } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/Platform.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import java.io.File;
import java.util.function.Supplier;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

enum Architecture { x86, x64, ppc64le, s390x, arm64, armv7l, ppc, ppc64;
    public static Architecture guess(){
        String arch = System.getProperty(""os.arch"");
        String version = System.getProperty(""os.version"");

        if (arch.equals(""ppc64le"")) {
            return ppc64le;
        } else if (arch.equals(""aarch64"")) {
            return arm64;
        } else if (arch.equals(""s390x"")) {
                return s390x;
        } else if (arch.equals(""arm"")) {
        	if (version.contains(""v7"")) {
                return armv7l;
        	} else {
        		return arm64;
        	}
        } else if (arch.equals(""ppc64"")) {
            return ppc64;
        } else if (arch.equals(""ppc"")) {
            return ppc;
        } else {
            return arch.contains(""64"") ? x64 : x86;
        }
    }
}

enum OS { Windows, Mac, Linux, SunOS, AIX;

    public static OS guess() {
        final String osName = System.getProperty(""os.name"");
        return  osName.contains(""Windows"") ? OS.Windows :
                osName.contains(""Mac"") ? OS.Mac :
                        osName.contains(""SunOS"") ? OS.SunOS :
                            osName.toUpperCase().contains(""AIX"") ? OS.AIX :
                                OS.Linux;
    }

    public String getArchiveExtension(){
        if(this == OS.Windows){
          return ""zip"";
        } else {
          return ""tar.gz"";
        }
    }

    public String getCodename(){
        if(this == OS.Mac){
            return ""darwin"";
        } else if(this == OS.Windows){
            return ""win"";
        } else if(this == OS.SunOS){
            return ""sunos"";
        } else if(this == OS.AIX){
            return ""aix"";
        } else {
            return ""linux"";
        }
    }
}

class Platform {

    /**
     * Node.js supports Apple silicon since v16
     * https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V16.md#toolchain-and-compiler-upgrades
     */
    private static final int NODE_VERSION_THRESHOLD_MAC_ARM64 = 16;

    private final String nodeDownloadRoot;
    private final OS os;
    private final Architecture architecture;
    private final String classifier;

    public Platform() {
        this(OS.guess(), Architecture.guess());
    }

    public Platform(OS os, Architecture architecture) {
        this(""https://nodejs.org/dist/"", os, architecture, null);
    }

    public Platform(
        String nodeDownloadRoot,
        OS os,
        Architecture architecture,
        String classifier
    ) {
        this.nodeDownloadRoot = nodeDownloadRoot;
        this.os = os;
        this.architecture = architecture;
        this.classifier = classifier;
    }

    public static Platform guess() {
        return Platform.guess(OS.guess(), Architecture.guess(), Platform::CHECK_FOR_ALPINE);
    }

    // Default implementation
    public static Boolean CHECK_FOR_ALPINE() {
        return new File(""/etc/alpine-release"").exists();
    }

    public static Platform guess(OS os, Architecture architecture, Supplier<Boolean> checkForAlpine){
        // The default libc is glibc, but Alpine uses musl. When not default, the nodejs download
        // (and path within it) needs a classifier in the suffix (ex. -musl).
        // We know Alpine is in use if the release file exists, and this is the simplest check.
        if (os == OS.Linux && checkForAlpine.get()) {
            return new Platform(
                // Currently, musl is Experimental. The download root can be overridden with config
                // if this changes and there's not been an update to this project, yet.
                // See https://github.com/nodejs/node/blob/master/BUILDING.md#platform-list
                ""https://unofficial-builds.nodejs.org/download/release/"",
                os, architecture, ""musl"");
        }
        return new Platform(os, architecture);
    }

    public String getNodeDownloadRoot(){
        return nodeDownloadRoot;
    }

    public String getArchiveExtension(){
        return os.getArchiveExtension();
    }

    public String getCodename(){
        return os.getCodename();
    }

    public boolean isWindows(){
        return os == OS.Windows;
    }

    public boolean isMac(){
        return os == OS.Mac;
    }

    public String getLongNodeFilename(String nodeVersion, boolean archiveOnWindows) {
        if(isWindows() && !archiveOnWindows){
            return ""node.exe"";
        } else {
            return ""node-"" + nodeVersion + ""-"" + this.getNodeClassifier(nodeVersion);
        }
    }

    public String getNodeDownloadFilename(String nodeVersion, boolean archiveOnWindows) {
        if(isWindows() && !archiveOnWindows) {
            if(architecture == Architecture.x64){
                if (nodeVersion.startsWith(""v0."")) {
                    return nodeVersion+""/x64/node.exe"";
                } else {
                    return nodeVersion+""/win-x64/node.exe"";
                }
            } else {
                if (nodeVersion.startsWith(""v0."")) {
                	return nodeVersion + ""/node.exe"";
                } else {
                    return nodeVersion+""/win-x86/node.exe"";
                }
            }
        } else {
            return nodeVersion + ""/"" + getLongNodeFilename(nodeVersion, archiveOnWindows) + ""."" + os.getArchiveExtension();
        }
    }

    public String getNodeClassifier(String nodeVersion) {
        String result = getCodename() + ""-"" + resolveArchitecture(nodeVersion).name();
        return classifier != null ? result + ""-"" + classifier : result;
    }

    private Architecture resolveArchitecture(String nodeVersion) {
        if (isMac() && architecture == Architecture.arm64) {
            Integer nodeMajorVersion = getNodeMajorVersion(nodeVersion);
            if (nodeMajorVersion == null || nodeMajorVersion < NODE_VERSION_THRESHOLD_MAC_ARM64) {
                return Architecture.x64;
            }
        }

        return architecture;
    }

    static Integer getNodeMajorVersion(String nodeVersion) {
        Matcher matcher = Pattern.compile(""^v(\\d+)\\..*$"").matcher(nodeVersion);
        if (matcher.matches()) {
            return Integer.parseInt(matcher.group(1));
        } else {
            // malformed node version
            return null;
        }
    }

}
","package com.github.eirslett.maven.plugins.frontend.lib; enum Architecture { x86, x64, ppc64le, s390x, arm64, armv7l, ppc, ppc64; public static Architecture guess(){ String arch = System.getProperty(""os.arch""); String version = System.getProperty(""os.version""); if (arch.equals(""ppc64le"")) { return ppc64le; } else if (arch.equals(""aarch64"")) { return arm64; } else if (arch.equals(""s390x"")) { return s390x; } else if (arch.equals(""arm"")) { if (version.contains(""v7"")) { return armv7l; } else { return arm64; } } else if (arch.equals(""ppc64"")) { return ppc64; } else if (arch.equals(""ppc"")) { return ppc; } else { return arch.contains(""64"") ? x64 : x86; } } } enum OS { Windows, Mac, Linux, SunOS, AIX; public static OS guess() { final String osName = System.getProperty(""os.name""); return  osName.contains(""Windows"") ? OS.Windows :
                osName.contains(""Mac"") ? OS.Mac :
                        osName.contains(""SunOS"") ? OS.SunOS :
                            osName.toUpperCase().contains(""AIX"") ? OS.AIX :
                                OS.Linux; } public String getArchiveExtension(){ if(this == OS.Windows){ return ""zip""; } else { return ""tar.gz""; } } public String getCodename(){ if(this == OS.Mac){ return ""darwin""; } else if(this == OS.Windows){ return ""win""; } else if(this == OS.SunOS){ return ""sunos""; } else if(this == OS.AIX){ return ""aix""; } else { return ""linux""; } } } class Platform { private static final int NODE_VERSION_THRESHOLD_MAC_ARM64 = 16; private final String nodeDownloadRoot; private final OS os; private final Architecture architecture; private final String classifier; public Platform() { this(OS.guess(), Architecture.guess()); } public Platform(OS os, Architecture architecture) { } public Platform(
        String nodeDownloadRoot,
        OS os,
        Architecture architecture,
        String classifier
    ) { this.nodeDownloadRoot = nodeDownloadRoot; this.os = os; this.architecture = architecture; this.classifier = classifier; } public static Platform guess() { return Platform.guess(OS.guess(), Architecture.guess(), Platform::CHECK_FOR_ALPINE); } public static Boolean CHECK_FOR_ALPINE() { return new File(""/etc/alpine-release"").exists(); } public static Platform guess(OS os, Architecture architecture, Supplier<Boolean> checkForAlpine){ if (os == OS.Linux && checkForAlpine.get()) { os, architecture, ""musl""); } return new Platform(os, architecture); } public String getNodeDownloadRoot(){ return nodeDownloadRoot; } public String getArchiveExtension(){ return os.getArchiveExtension(); } public String getCodename(){ return os.getCodename(); } public boolean isWindows(){ return os == OS.Windows; } public boolean isMac(){ return os == OS.Mac; } public String getLongNodeFilename(String nodeVersion, boolean archiveOnWindows) { if(isWindows() && !archiveOnWindows){ return ""node.exe""; } else { return ""node-"" + nodeVersion + ""-"" + this.getNodeClassifier(nodeVersion); } } public String getNodeDownloadFilename(String nodeVersion, boolean archiveOnWindows) { if(isWindows() && !archiveOnWindows) { if(architecture == Architecture.x64){ if (nodeVersion.startsWith(""v0."")) { return nodeVersion+""/x64/node.exe""; } else { return nodeVersion+""/win-x64/node.exe""; } } else { if (nodeVersion.startsWith(""v0."")) { return nodeVersion + ""/node.exe""; } else { return nodeVersion+""/win-x86/node.exe""; } } } else { return nodeVersion + ""/"" + getLongNodeFilename(nodeVersion, archiveOnWindows) + ""."" + os.getArchiveExtension(); } } public String getNodeClassifier(String nodeVersion) { String result = getCodename() + ""-"" + resolveArchitecture(nodeVersion).name(); return classifier != null ? result + ""-"" + classifier : result; } private Architecture resolveArchitecture(String nodeVersion) { if (isMac() && architecture == Architecture.arm64) { Integer nodeMajorVersion = getNodeMajorVersion(nodeVersion); if (nodeMajorVersion == null || nodeMajorVersion < NODE_VERSION_THRESHOLD_MAC_ARM64) { return Architecture.x64; } } return architecture; } static Integer getNodeMajorVersion(String nodeVersion) { Matcher matcher = Pattern.compile(""^v(\\d+)\\..*$"").matcher(nodeVersion); if (matcher.matches()) { return Integer.parseInt(matcher.group(1)); } else { return null; } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; enum Architecture { x86, x64, ppc64le, s390x, arm64, armv7l, ppc, ppc64; public static Architecture guess(){ String arch = System.getProperty(""os.arch""); String version = System.getProperty(""os.version""); if (arch.equals(""ppc64le"")) { return ppc64le; } else if (arch.equals(""aarch64"")) { return arm64; } else if (arch.equals(""s390x"")) { return s390x; } else if (arch.equals(""arm"")) { if (version.contains(""v7"")) { return armv7l; } else { return arm64; } } else if (arch.equals(""ppc64"")) { return ppc64; } else if (arch.equals(""ppc"")) { return ppc; } else { return arch.contains(""64"") ? x64 : x86; } } } enum OS { Windows, Mac, Linux, SunOS, AIX; public static OS guess() { final String osName = System.getProperty(""os.name""); return  osName.contains(""Windows"") ? OS.Windows :
                osName.contains(""Mac"") ? OS.Mac :
                        osName.contains(""SunOS"") ? OS.SunOS :
                            osName.toUpperCase().contains(""AIX"") ? OS.AIX :
                                OS.Linux; } public String getArchiveExtension(){ if(this == OS.Windows){ return ""zip""; } else { return ""tar.gz""; } } public String getCodename(){ if(this == OS.Mac){ return ""darwin""; } else if(this == OS.Windows){ return ""win""; } else if(this == OS.SunOS){ return ""sunos""; } else if(this == OS.AIX){ return ""aix""; } else { return ""linux""; } } } class Platform { private static final int NODE_VERSION_THRESHOLD_MAC_ARM64 = 16; private final String nodeDownloadRoot; private final OS os; private final Architecture architecture; private final String classifier; public Platform() { this(OS.guess(), Architecture.guess()); } public Platform(OS os, Architecture architecture) { } public Platform(
        String nodeDownloadRoot,
        OS os,
        Architecture architecture,
        String classifier
    ) { this.nodeDownloadRoot = nodeDownloadRoot; this.os = os; this.architecture = architecture; this.classifier = classifier; } public static Platform guess() { return Platform.guess(OS.guess(), Architecture.guess(), Platform::CHECK_FOR_ALPINE); } public static Boolean CHECK_FOR_ALPINE() { return new File(""/etc/alpine-release"").exists(); } public static Platform guess(OS os, Architecture architecture, Supplier<Boolean> checkForAlpine){ if (os == OS.Linux && checkForAlpine.get()) { os, architecture, ""musl""); } return new Platform(os, architecture); } public String getNodeDownloadRoot(){ return nodeDownloadRoot; } public String getArchiveExtension(){ return os.getArchiveExtension(); } public String getCodename(){ return os.getCodename(); } public boolean isWindows(){ return os == OS.Windows; } public boolean isMac(){ return os == OS.Mac; } public String getLongNodeFilename(String nodeVersion, boolean archiveOnWindows) { if(isWindows() && !archiveOnWindows){ return ""node.exe""; } else { return ""node-"" + nodeVersion + ""-"" + this.getNodeClassifier(nodeVersion); } } public String getNodeDownloadFilename(String nodeVersion, boolean archiveOnWindows) { if(isWindows() && !archiveOnWindows) { if(architecture == Architecture.x64){ if (nodeVersion.startsWith(""v0."")) { return nodeVersion+""/x64/node.exe""; } else { return nodeVersion+""/win-x64/node.exe""; } } else { if (nodeVersion.startsWith(""v0."")) { return nodeVersion + ""/node.exe""; } else { return nodeVersion+""/win-x86/node.exe""; } } } else { return nodeVersion + ""/"" + getLongNodeFilename(nodeVersion, archiveOnWindows) + ""."" + os.getArchiveExtension(); } } public String getNodeClassifier(String nodeVersion) { String result = getCodename() + ""-"" + resolveArchitecture(nodeVersion).name(); return classifier != null ? result + ""-"" + classifier : result; } private Architecture resolveArchitecture(String nodeVersion) { if (isMac() && architecture == Architecture.arm64) { Integer nodeMajorVersion = getNodeMajorVersion(nodeVersion); if (nodeMajorVersion == null || nodeMajorVersion < NODE_VERSION_THRESHOLD_MAC_ARM64) { return Architecture.x64; } } return architecture; } static Integer getNodeMajorVersion(String nodeVersion) { Matcher matcher = Pattern.compile(""^v(\\d+)\\..*$"").matcher(nodeVersion); if (matcher.matches()) { return Integer.parseInt(matcher.group(1)); } else { return null; } } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import java.io.File; import java.util.function.Supplier; import java.util.regex.Matcher; import java.util.regex.Pattern;  enum Architecture { x86, x64, ppc64le, s390x, arm64, armv7l, ppc, ppc64; public static Architecture guess(){ String arch = System.getProperty(""os.arch""); String version = System.getProperty(""os.version"");  if (arch.equals(""ppc64le"")) { return ppc64le; } else if (arch.equals(""aarch64"")) { return arm64; } else if (arch.equals(""s390x"")) { return s390x; } else if (arch.equals(""arm"")) { if (version.contains(""v7"")) { return armv7l; } else { return arm64; } } else if (arch.equals(""ppc64"")) { return ppc64; } else if (arch.equals(""ppc"")) { return ppc; } else { return arch.contains(""64"") ? x64 : x86; } } }  enum OS { Windows, Mac, Linux, SunOS, AIX;  public static OS guess() { final String osName = System.getProperty(""os.name""); return  osName.contains(""Windows"") ? OS.Windows :
                osName.contains(""Mac"") ? OS.Mac :
                        osName.contains(""SunOS"") ? OS.SunOS :
                            osName.toUpperCase().contains(""AIX"") ? OS.AIX :
                                OS.Linux; }  public String getArchiveExtension(){ if(this == OS.Windows){ return ""zip""; } else { return ""tar.gz""; } }  public String getCodename(){ if(this == OS.Mac){ return ""darwin""; } else if(this == OS.Windows){ return ""win""; } else if(this == OS.SunOS){ return ""sunos""; } else if(this == OS.AIX){ return ""aix""; } else { return ""linux""; } } }  class Platform {  /**
     * Node.js supports Apple silicon since v16
     * https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V16.md#toolchain-and-compiler-upgrades
     */ private static final int NODE_VERSION_THRESHOLD_MAC_ARM64 = 16;  private final String nodeDownloadRoot; private final OS os; private final Architecture architecture; private final String classifier;  public Platform() { this(OS.guess(), Architecture.guess()); }  public Platform(OS os, Architecture architecture) { //nodejs.org/dist/"", os, architecture, null); }  public Platform(
        String nodeDownloadRoot,
        OS os,
        Architecture architecture,
        String classifier
    ) { this.nodeDownloadRoot = nodeDownloadRoot; this.os = os; this.architecture = architecture; this.classifier = classifier; }  public static Platform guess() { return Platform.guess(OS.guess(), Architecture.guess(), Platform::CHECK_FOR_ALPINE); }  // Default implementation public static Boolean CHECK_FOR_ALPINE() { return new File(""/etc/alpine-release"").exists(); }  public static Platform guess(OS os, Architecture architecture, Supplier<Boolean> checkForAlpine){ // The default libc is glibc, but Alpine uses musl. When not default, the nodejs download // (and path within it) needs a classifier in the suffix (ex. -musl). // We know Alpine is in use if the release file exists, and this is the simplest check. if (os == OS.Linux && checkForAlpine.get()) { // Currently, musl is Experimental. The download root can be overridden with config // if this changes and there's not been an update to this project, yet. // See https://github.com/nodejs/node/blob/master/BUILDING.md#platform-list //unofficial-builds.nodejs.org/download/release/"", os, architecture, ""musl""); } return new Platform(os, architecture); }  public String getNodeDownloadRoot(){ return nodeDownloadRoot; }  public String getArchiveExtension(){ return os.getArchiveExtension(); }  public String getCodename(){ return os.getCodename(); }  public boolean isWindows(){ return os == OS.Windows; }  public boolean isMac(){ return os == OS.Mac; }  public String getLongNodeFilename(String nodeVersion, boolean archiveOnWindows) { if(isWindows() && !archiveOnWindows){ return ""node.exe""; } else { return ""node-"" + nodeVersion + ""-"" + this.getNodeClassifier(nodeVersion); } }  public String getNodeDownloadFilename(String nodeVersion, boolean archiveOnWindows) { if(isWindows() && !archiveOnWindows) { if(architecture == Architecture.x64){ if (nodeVersion.startsWith(""v0."")) { return nodeVersion+""/x64/node.exe""; } else { return nodeVersion+""/win-x64/node.exe""; } } else { if (nodeVersion.startsWith(""v0."")) { return nodeVersion + ""/node.exe""; } else { return nodeVersion+""/win-x86/node.exe""; } } } else { return nodeVersion + ""/"" + getLongNodeFilename(nodeVersion, archiveOnWindows) + ""."" + os.getArchiveExtension(); } }  public String getNodeClassifier(String nodeVersion) { String result = getCodename() + ""-"" + resolveArchitecture(nodeVersion).name(); return classifier != null ? result + ""-"" + classifier : result; }  private Architecture resolveArchitecture(String nodeVersion) { if (isMac() && architecture == Architecture.arm64) { Integer nodeMajorVersion = getNodeMajorVersion(nodeVersion); if (nodeMajorVersion == null || nodeMajorVersion < NODE_VERSION_THRESHOLD_MAC_ARM64) { return Architecture.x64; } }  return architecture; }  static Integer getNodeMajorVersion(String nodeVersion) { Matcher matcher = Pattern.compile(""^v(\\d+)\\..*$"").matcher(nodeVersion); if (matcher.matches()) { return Integer.parseInt(matcher.group(1)); } else { // malformed node version return null; } }  }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/PnpmInstaller.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.commons.io.FileUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;

public class PnpmInstaller {

    private static final String VERSION = ""version"";

    public static final String DEFAULT_PNPM_DOWNLOAD_ROOT = ""https://registry.npmjs.org/pnpm/-/"";

    private static final Object LOCK = new Object();

    private String pnpmVersion, pnpmDownloadRoot, userName, password;
    
    private Map<String, String> httpHeaders;

    private final Logger logger;

    private final InstallConfig config;

    private final ArchiveExtractor archiveExtractor;

    private final FileDownloader fileDownloader;

    PnpmInstaller(InstallConfig config, ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) {
        this.logger = LoggerFactory.getLogger(getClass());
        this.config = config;
        this.archiveExtractor = archiveExtractor;
        this.fileDownloader = fileDownloader;
    }

    public PnpmInstaller setNodeVersion(String nodeVersion) {
        return this;
    }

    public PnpmInstaller setPnpmVersion(String pnpmVersion) {
        this.pnpmVersion = pnpmVersion;
        return this;
    }

    public PnpmInstaller setPnpmDownloadRoot(String pnpmDownloadRoot) {
        this.pnpmDownloadRoot = pnpmDownloadRoot;
        return this;
    }

    public PnpmInstaller setUserName(String userName) {
        this.userName = userName;
        return this;
    }

    public PnpmInstaller setPassword(String password) {
        this.password = password;
        return this;
    }

    public PnpmInstaller setHttpHeaders(Map<String, String> httpHeaders) {
        this.httpHeaders = httpHeaders;
        return this;
    }

    public void install() throws InstallationException {
        // use static lock object for a synchronized block
        synchronized (LOCK) {
            if (this.pnpmDownloadRoot == null || this.pnpmDownloadRoot.isEmpty()) {
                this.pnpmDownloadRoot = DEFAULT_PNPM_DOWNLOAD_ROOT;
            }
            if (!pnpmIsAlreadyInstalled()) {
                installPnpm();
            }

            if (this.config.getPlatform().isWindows()) {
                linkExecutableWindows();
            } else {
                linkExecutable();
            }
        }
    }

    private boolean pnpmIsAlreadyInstalled() {
        try {
            final File pnpmPackageJson = new File(
                this.config.getInstallDirectory() + Utils.normalize(""/node/node_modules/pnpm/package.json""));
            if (pnpmPackageJson.exists()) {
                HashMap<String, Object> data = new ObjectMapper().readValue(pnpmPackageJson, HashMap.class);
                if (data.containsKey(VERSION)) {
                    final String foundPnpmVersion = data.get(VERSION).toString();
                    if (foundPnpmVersion.equals(this.pnpmVersion.replaceFirst(""^v"", """"))) {
                        this.logger.info(""PNPM {} is already installed."", foundPnpmVersion);
                        return true;
                    } else {
                        this.logger.info(""PNPM {} was installed, but we need version {}"", foundPnpmVersion,
                            this.pnpmVersion);
                        return false;
                    }
                } else {
                    this.logger.info(""Could not read PNPM version from package.json"");
                    return false;
                }
            } else {
                return false;
            }
        } catch (IOException ex) {
            throw new RuntimeException(""Could not read package.json"", ex);
        }
    }

    private void installPnpm() throws InstallationException {
        try {
            this.logger.info(""Installing pnpm version {}"", this.pnpmVersion);
            String pnpmVersionClean = this.pnpmVersion.replaceFirst(""^v(?=[0-9]+)"", """");
            final String downloadUrl = this.pnpmDownloadRoot + ""pnpm-"" + pnpmVersionClean + "".tgz"";

            CacheDescriptor cacheDescriptor = new CacheDescriptor(""pnpm"", pnpmVersionClean, ""tar.gz"");

            File archive = this.config.getCacheResolver().resolve(cacheDescriptor);

            downloadFileIfMissing(downloadUrl, archive, this.userName, this.password, httpHeaders);

            File installDirectory = getNodeInstallDirectory();
            File nodeModulesDirectory = new File(installDirectory, ""node_modules"");

            // We need to delete the existing pnpm directory first so we clean out any old files, and
            // so we can rename the package directory below.
            File oldNpmDirectory = new File(installDirectory, ""pnpm"");
            File pnpmDirectory = new File(nodeModulesDirectory, ""pnpm"");
            try {
                if (oldNpmDirectory.isDirectory()) {
                    FileUtils.deleteDirectory(oldNpmDirectory);
                }
                FileUtils.deleteDirectory(pnpmDirectory);
            } catch (IOException e) {
                this.logger.warn(""Failed to delete existing PNPM installation."");
            }

            File packageDirectory = new File(nodeModulesDirectory, ""package"");
            try {
                extractFile(archive, nodeModulesDirectory);
            } catch (ArchiveExtractionException e) {
                if (e.getCause() instanceof EOFException) {
                    // https://github.com/eirslett/frontend-maven-plugin/issues/794
                    // The downloading was probably interrupted and archive file is incomplete:
                    // delete it to retry from scratch
                    this.logger.error(""The archive file {} is corrupted and will be deleted. ""
                            + ""Please try the build again."", archive.getPath());
                    archive.delete();
                    if (packageDirectory.exists()) {
                        FileUtils.deleteDirectory(packageDirectory);
                    }
                }

                throw e;
            }

            // handles difference between old and new download root (nodejs.org/dist/npm and
            // registry.npmjs.org)
            // see https://github.com/eirslett/frontend-maven-plugin/issues/65#issuecomment-52024254
            if (packageDirectory.exists() && !pnpmDirectory.exists()) {
                if (!packageDirectory.renameTo(pnpmDirectory)) {
                    this.logger.warn(""Cannot rename PNPM directory, making a copy."");
                    FileUtils.copyDirectory(packageDirectory, pnpmDirectory);
                }
            }

            this.logger.info(""Installed pnpm locally."");

        } catch (DownloadException e) {
            throw new InstallationException(""Could not download pnpm"", e);
        } catch (ArchiveExtractionException e) {
            throw new InstallationException(""Could not extract the pnpm archive"", e);
        } catch (IOException e) {
            throw new InstallationException(""Could not copy pnpm"", e);
        }
    }

    private void linkExecutable() throws InstallationException{
        File nodeInstallDirectory = getNodeInstallDirectory();
        File pnpmExecutable = new File(nodeInstallDirectory, ""pnpm"");

        if (pnpmExecutable.exists()) {
            this.logger.info(""Existing pnpm executable found, skipping linking."");
            return;
        }

        NodeExecutorConfig executorConfig = new InstallNodeExecutorConfig(this.config);
        File pnpmJsExecutable = executorConfig.getPnpmCjsPath();

        if (!pnpmJsExecutable.exists()) {
            throw new InstallationException(""Could not link to pnpm executable, no pnpm installation found."");
        }

        this.logger.info(""No pnpm executable found, creating symbolic link to {}."", pnpmJsExecutable.toPath());

        try {
            Files.createSymbolicLink(pnpmExecutable.toPath(), pnpmJsExecutable.toPath());
        } catch (IOException e) {
            throw new InstallationException(""Could not create symbolic link for pnpm executable."", e);
        }
    }

    private void linkExecutableWindows() throws InstallationException{
        File nodeInstallDirectory = getNodeInstallDirectory();
        File pnpmExecutable = new File(nodeInstallDirectory, ""pnpm.cmd"");

        if (pnpmExecutable.exists()) {
            this.logger.info(""Existing pnpm executable found, skipping linking."");
            return;
        }

        NodeExecutorConfig executorConfig = new InstallNodeExecutorConfig(this.config);
        File pnpmJsExecutable = executorConfig.getPnpmCjsPath();

        if (!pnpmJsExecutable.exists()) {
            throw new InstallationException(""Could not link to pnpm executable, no pnpm installation found."");
        }

        this.logger.info(""No pnpm executable found, creating proxy script to {}."", pnpmJsExecutable.toPath());

        Path nodePath = executorConfig.getNodePath().toPath();
        Path relativeNodePath = nodeInstallDirectory.toPath().relativize(nodePath);
        Path relativePnpmPath = nodeInstallDirectory.toPath().relativize(pnpmJsExecutable.toPath());

        // Create a script that will proxy any commands passed into it to the pnpm executable.
        String scriptContents = new StringBuilder()
                .append("":: Created by frontend-maven-plugin, please don't edit manually.\r\n"")
                .append(""@ECHO OFF\r\n"")
                .append(""\r\n"")
                .append(""SETLOCAL\r\n"")
                .append(""\r\n"")
                .append(String.format(""SET \""NODE_EXE=%%~dp0\\%s\""\r\n"", relativeNodePath))
                .append(String.format(""SET \""PNPM_CLI_JS=%%~dp0\\%s\""\r\n"", relativePnpmPath))
                .append(""\r\n"")
                .append(""\""%NODE_EXE%\"" \""%PNPM_CLI_JS%\"" %*"")
                .toString();

        try {
            BufferedWriter writer = new BufferedWriter(new FileWriter(pnpmExecutable));
            writer.write(scriptContents);
            writer.close();
        } catch (IOException e) {
            throw new InstallationException(""Could not create proxy script for pnpm executable."", e);
        }
    }

    private File getNodeInstallDirectory() {
        File installDirectory = new File(this.config.getInstallDirectory(), NodeInstaller.INSTALL_PATH);
        if (!installDirectory.exists()) {
            this.logger.debug(""Creating install directory {}"", installDirectory);
            installDirectory.mkdirs();
        }
        return installDirectory;
    }

    private void extractFile(File archive, File destinationDirectory) throws ArchiveExtractionException {
        this.logger.info(""Unpacking {} into {}"", archive, destinationDirectory);
        this.archiveExtractor.extract(archive.getPath(), destinationDirectory.getPath());
    }

    private void downloadFileIfMissing(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException {
        if (!destination.exists()) {
            downloadFile(downloadUrl, destination, userName, password, httpHeaders);
        }
    }

    private void downloadFile(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException {
        this.logger.info(""Downloading {} to {}"", downloadUrl, destination);
        this.fileDownloader.download(downloadUrl, destination.getPath(), userName, password, httpHeaders);
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public class PnpmInstaller { private static final String VERSION = ""version""; private static final Object LOCK = new Object(); private String pnpmVersion, pnpmDownloadRoot, userName, password; private Map<String, String> httpHeaders; private final Logger logger; private final InstallConfig config; private final ArchiveExtractor archiveExtractor; private final FileDownloader fileDownloader; PnpmInstaller(InstallConfig config, ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) { this.logger = LoggerFactory.getLogger(getClass()); this.config = config; this.archiveExtractor = archiveExtractor; this.fileDownloader = fileDownloader; } public PnpmInstaller setNodeVersion(String nodeVersion) { return this; } public PnpmInstaller setPnpmVersion(String pnpmVersion) { this.pnpmVersion = pnpmVersion; return this; } public PnpmInstaller setPnpmDownloadRoot(String pnpmDownloadRoot) { this.pnpmDownloadRoot = pnpmDownloadRoot; return this; } public PnpmInstaller setUserName(String userName) { this.userName = userName; return this; } public PnpmInstaller setPassword(String password) { this.password = password; return this; } public PnpmInstaller setHttpHeaders(Map<String, String> httpHeaders) { this.httpHeaders = httpHeaders; return this; } public void install() throws InstallationException { synchronized (LOCK) { if (this.pnpmDownloadRoot == null || this.pnpmDownloadRoot.isEmpty()) { this.pnpmDownloadRoot = DEFAULT_PNPM_DOWNLOAD_ROOT; } if (!pnpmIsAlreadyInstalled()) { installPnpm(); } if (this.config.getPlatform().isWindows()) { linkExecutableWindows(); } else { linkExecutable(); } } } private boolean pnpmIsAlreadyInstalled() { try { final File pnpmPackageJson = new File(
                this.config.getInstallDirectory() + Utils.normalize(""/node/node_modules/pnpm/package.json"")); if (pnpmPackageJson.exists()) { HashMap<String, Object> data = new ObjectMapper().readValue(pnpmPackageJson, HashMap.class); if (data.containsKey(VERSION)) { final String foundPnpmVersion = data.get(VERSION).toString(); if (foundPnpmVersion.equals(this.pnpmVersion.replaceFirst(""^v"", """"))) { this.logger.info(""PNPM { } is already installed."", foundPnpmVersion); return true; } else { this.logger.info(""PNPM { } was installed, but we need version { } "", foundPnpmVersion,
                            this.pnpmVersion); return false; } } else { return false; } } else { return false; } } catch (IOException ex) { throw new RuntimeException(""Could not read package.json"", ex); } } private void installPnpm() throws InstallationException { try { this.logger.info(""Installing pnpm version { } "", this.pnpmVersion); String pnpmVersionClean = this.pnpmVersion.replaceFirst(""^v(?=[0-9]+)"", """"); final String downloadUrl = this.pnpmDownloadRoot + ""pnpm-"" + pnpmVersionClean + "".tgz""; CacheDescriptor cacheDescriptor = new CacheDescriptor(""pnpm"", pnpmVersionClean, ""tar.gz""); File archive = this.config.getCacheResolver().resolve(cacheDescriptor); downloadFileIfMissing(downloadUrl, archive, this.userName, this.password, httpHeaders); File installDirectory = getNodeInstallDirectory(); File nodeModulesDirectory = new File(installDirectory, ""node_modules""); File oldNpmDirectory = new File(installDirectory, ""pnpm""); File pnpmDirectory = new File(nodeModulesDirectory, ""pnpm""); try { if (oldNpmDirectory.isDirectory()) { FileUtils.deleteDirectory(oldNpmDirectory); } FileUtils.deleteDirectory(pnpmDirectory); } catch (IOException e) { } File packageDirectory = new File(nodeModulesDirectory, ""package""); try { extractFile(archive, nodeModulesDirectory); } catch (ArchiveExtractionException e) { if (e.getCause() instanceof EOFException) { this.logger.error(""The archive file { } is corrupted and will be deleted. ""
                            + ""Please try the build again."", archive.getPath()); archive.delete(); if (packageDirectory.exists()) { FileUtils.deleteDirectory(packageDirectory); } } throw e; } if (packageDirectory.exists() && !pnpmDirectory.exists()) { if (!packageDirectory.renameTo(pnpmDirectory)) { FileUtils.copyDirectory(packageDirectory, pnpmDirectory); } } } catch (DownloadException e) { throw new InstallationException(""Could not download pnpm"", e); } catch (ArchiveExtractionException e) { throw new InstallationException(""Could not extract the pnpm archive"", e); } catch (IOException e) { throw new InstallationException(""Could not copy pnpm"", e); } } private void linkExecutable() throws InstallationException{ File nodeInstallDirectory = getNodeInstallDirectory(); File pnpmExecutable = new File(nodeInstallDirectory, ""pnpm""); if (pnpmExecutable.exists()) { return; } NodeExecutorConfig executorConfig = new InstallNodeExecutorConfig(this.config); File pnpmJsExecutable = executorConfig.getPnpmCjsPath(); if (!pnpmJsExecutable.exists()) { throw new InstallationException(""Could not link to pnpm executable, no pnpm installation found.""); } this.logger.info(""No pnpm executable found, creating symbolic link to { } ."", pnpmJsExecutable.toPath()); try { Files.createSymbolicLink(pnpmExecutable.toPath(), pnpmJsExecutable.toPath()); } catch (IOException e) { throw new InstallationException(""Could not create symbolic link for pnpm executable."", e); } } private void linkExecutableWindows() throws InstallationException{ File nodeInstallDirectory = getNodeInstallDirectory(); File pnpmExecutable = new File(nodeInstallDirectory, ""pnpm.cmd""); if (pnpmExecutable.exists()) { return; } NodeExecutorConfig executorConfig = new InstallNodeExecutorConfig(this.config); File pnpmJsExecutable = executorConfig.getPnpmCjsPath(); if (!pnpmJsExecutable.exists()) { throw new InstallationException(""Could not link to pnpm executable, no pnpm installation found.""); } this.logger.info(""No pnpm executable found, creating proxy script to { } ."", pnpmJsExecutable.toPath()); Path nodePath = executorConfig.getNodePath().toPath(); Path relativeNodePath = nodeInstallDirectory.toPath().relativize(nodePath); Path relativePnpmPath = nodeInstallDirectory.toPath().relativize(pnpmJsExecutable.toPath()); String scriptContents = new StringBuilder()
                .append("":: Created by frontend-maven-plugin, please don't edit manually.\r\n"")
                .append(""@ECHO OFF\r\n"")
                .append(""\r\n"")
                .append(""SETLOCAL\r\n"")
                .append(""\r\n"")
                .append(String.format(""SET \""NODE_EXE=%%~dp0\\%s\""\r\n"", relativeNodePath))
                .append(String.format(""SET \""PNPM_CLI_JS=%%~dp0\\%s\""\r\n"", relativePnpmPath))
                .append(""\r\n"")
                .append(""\""%NODE_EXE%\"" \""%PNPM_CLI_JS%\"" %*"")
                .toString(); try { BufferedWriter writer = new BufferedWriter(new FileWriter(pnpmExecutable)); writer.write(scriptContents); writer.close(); } catch (IOException e) { throw new InstallationException(""Could not create proxy script for pnpm executable."", e); } } private File getNodeInstallDirectory() { File installDirectory = new File(this.config.getInstallDirectory(), NodeInstaller.INSTALL_PATH); if (!installDirectory.exists()) { this.logger.debug(""Creating install directory { } "", installDirectory); installDirectory.mkdirs(); } return installDirectory; } private void extractFile(File archive, File destinationDirectory) throws ArchiveExtractionException { this.logger.info(""Unpacking { } into { } "", archive, destinationDirectory); this.archiveExtractor.extract(archive.getPath(), destinationDirectory.getPath()); } private void downloadFileIfMissing(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException { if (!destination.exists()) { downloadFile(downloadUrl, destination, userName, password, httpHeaders); } } private void downloadFile(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException { this.logger.info(""Downloading { } to { } "", downloadUrl, destination); this.fileDownloader.download(downloadUrl, destination.getPath(), userName, password, httpHeaders); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public class PnpmInstaller { private static final String VERSION = ""version""; private static final Object LOCK = new Object(); private String pnpmVersion, pnpmDownloadRoot, userName, password; private Map<String, String> httpHeaders; private final Logger logger; private final InstallConfig config; private final ArchiveExtractor archiveExtractor; private final FileDownloader fileDownloader; PnpmInstaller(InstallConfig config, ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) { this.logger = LoggerFactory.getLogger(getClass()); this.config = config; this.archiveExtractor = archiveExtractor; this.fileDownloader = fileDownloader; } <FILL_ME> public PnpmInstaller setNodeVersion(String nodeVersion) { return this; } public PnpmInstaller setPnpmVersion(String pnpmVersion) { this.pnpmVersion = pnpmVersion; return this; } public PnpmInstaller setPnpmDownloadRoot(String pnpmDownloadRoot) { this.pnpmDownloadRoot = pnpmDownloadRoot; return this; } public PnpmInstaller setUserName(String userName) { this.userName = userName; return this; } public PnpmInstaller setPassword(String password) { this.password = password; return this; } public PnpmInstaller setHttpHeaders(Map<String, String> httpHeaders) { this.httpHeaders = httpHeaders; return this; } public void install() throws InstallationException { synchronized (LOCK) { if (this.pnpmDownloadRoot == null || this.pnpmDownloadRoot.isEmpty()) { this.pnpmDownloadRoot = DEFAULT_PNPM_DOWNLOAD_ROOT; } if (!pnpmIsAlreadyInstalled()) { installPnpm(); } if (this.config.getPlatform().isWindows()) { linkExecutableWindows(); } else { <FILL_ME> linkExecutable(); } } } private boolean pnpmIsAlreadyInstalled() { try { final File pnpmPackageJson = new File(
                this.config.getInstallDirectory() + Utils.normalize(""/node/node_modules/pnpm/package.json"")); if (pnpmPackageJson.exists()) { HashMap<String, Object> data = new ObjectMapper().readValue(pnpmPackageJson, HashMap.class); if (data.containsKey(VERSION)) { final String foundPnpmVersion = data.get(VERSION).toString(); if (foundPnpmVersion.equals(this.pnpmVersion.replaceFirst(""^v"", """"))) { this.logger.info(""PNPM { } is already installed."", foundPnpmVersion); return true; } else { this.logger.info(""PNPM { } was installed, but we need version { } "", foundPnpmVersion,
                            this.pnpmVersion); return false; } } else { return false; } } else { return false; } } catch (IOException ex) { throw new RuntimeException(""Could not read package.json"", ex); } } private void installPnpm() throws InstallationException { try { this.logger.info(""Installing pnpm version { } "", this.pnpmVersion); String pnpmVersionClean = this.pnpmVersion.replaceFirst(""^v(?=[0-9]+)"", """"); final String downloadUrl = this.pnpmDownloadRoot + ""pnpm-"" + pnpmVersionClean + "".tgz""; CacheDescriptor cacheDescriptor = new CacheDescriptor(""pnpm"", pnpmVersionClean, ""tar.gz""); File archive = this.config.getCacheResolver().resolve(cacheDescriptor); downloadFileIfMissing(downloadUrl, archive, this.userName, this.password, httpHeaders); File installDirectory = getNodeInstallDirectory(); File nodeModulesDirectory = new File(installDirectory, ""node_modules""); File oldNpmDirectory = new File(installDirectory, ""pnpm""); File pnpmDirectory = new File(nodeModulesDirectory, ""pnpm""); try { if (oldNpmDirectory.isDirectory()) { FileUtils.deleteDirectory(oldNpmDirectory); } FileUtils.deleteDirectory(pnpmDirectory); } catch (IOException e) { <FILL_ME> } File packageDirectory = new File(nodeModulesDirectory, ""package""); try { extractFile(archive, nodeModulesDirectory); } catch (ArchiveExtractionException e) { if (e.getCause() instanceof EOFException) { this.logger.error(""The archive file { } is corrupted and will be deleted. ""
                            + ""Please try the build again."", archive.getPath()); archive.delete(); if (packageDirectory.exists()) { FileUtils.deleteDirectory(packageDirectory); } } throw e; } if (packageDirectory.exists() && !pnpmDirectory.exists()) { if (!packageDirectory.renameTo(pnpmDirectory)) { <FILL_ME> FileUtils.copyDirectory(packageDirectory, pnpmDirectory); } } } catch (DownloadException e) { throw new InstallationException(""Could not download pnpm"", e); } catch (ArchiveExtractionException e) { throw new InstallationException(""Could not extract the pnpm archive"", e); } catch (IOException e) { throw new InstallationException(""Could not copy pnpm"", e); } } private void linkExecutable() throws InstallationException{ File nodeInstallDirectory = getNodeInstallDirectory(); File pnpmExecutable = new File(nodeInstallDirectory, ""pnpm""); if (pnpmExecutable.exists()) { <FILL_ME> <FILL_ME> return; } NodeExecutorConfig executorConfig = new InstallNodeExecutorConfig(this.config); File pnpmJsExecutable = executorConfig.getPnpmCjsPath(); if (!pnpmJsExecutable.exists()) { throw new InstallationException(""Could not link to pnpm executable, no pnpm installation found.""); } this.logger.info(""No pnpm executable found, creating symbolic link to { } ."", pnpmJsExecutable.toPath()); try { Files.createSymbolicLink(pnpmExecutable.toPath(), pnpmJsExecutable.toPath()); } catch (IOException e) { throw new InstallationException(""Could not create symbolic link for pnpm executable."", e); } } private void linkExecutableWindows() throws InstallationException{ File nodeInstallDirectory = getNodeInstallDirectory(); File pnpmExecutable = new File(nodeInstallDirectory, ""pnpm.cmd""); if (pnpmExecutable.exists()) { return; } NodeExecutorConfig executorConfig = new InstallNodeExecutorConfig(this.config); File pnpmJsExecutable = executorConfig.getPnpmCjsPath(); if (!pnpmJsExecutable.exists()) { throw new InstallationException(""Could not link to pnpm executable, no pnpm installation found.""); } this.logger.info(""No pnpm executable found, creating proxy script to { } ."", pnpmJsExecutable.toPath()); Path nodePath = executorConfig.getNodePath().toPath(); Path relativeNodePath = nodeInstallDirectory.toPath().relativize(nodePath); Path relativePnpmPath = nodeInstallDirectory.toPath().relativize(pnpmJsExecutable.toPath()); String scriptContents = new StringBuilder()
                .append("":: Created by frontend-maven-plugin, please don't edit manually.\r\n"")
                .append(""@ECHO OFF\r\n"")
                .append(""\r\n"")
                .append(""SETLOCAL\r\n"")
                .append(""\r\n"")
                .append(String.format(""SET \""NODE_EXE=%%~dp0\\%s\""\r\n"", relativeNodePath))
                .append(String.format(""SET \""PNPM_CLI_JS=%%~dp0\\%s\""\r\n"", relativePnpmPath))
                .append(""\r\n"")
                .append(""\""%NODE_EXE%\"" \""%PNPM_CLI_JS%\"" %*"")
                .toString(); try { BufferedWriter writer = new BufferedWriter(new FileWriter(pnpmExecutable)); writer.write(scriptContents); writer.close(); } catch (IOException e) { throw new InstallationException(""Could not create proxy script for pnpm executable."", e); } } private File getNodeInstallDirectory() { File installDirectory = new File(this.config.getInstallDirectory(), NodeInstaller.INSTALL_PATH); if (!installDirectory.exists()) { this.logger.debug(""Creating install directory { } "", installDirectory); installDirectory.mkdirs(); } return installDirectory; } private void extractFile(File archive, File destinationDirectory) throws ArchiveExtractionException { this.logger.info(""Unpacking { } into { } "", archive, destinationDirectory); this.archiveExtractor.extract(archive.getPath(), destinationDirectory.getPath()); } private void downloadFileIfMissing(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException { if (!destination.exists()) { downloadFile(downloadUrl, destination, userName, password, httpHeaders); } } private void downloadFile(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException { this.logger.info(""Downloading { } to { } "", downloadUrl, destination); this.fileDownloader.download(downloadUrl, destination.getPath(), userName, password, httpHeaders); } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import com.fasterxml.jackson.databind.ObjectMapper; import org.apache.commons.io.FileUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory; 
import java.io.*; import java.nio.file.Files; import java.nio.file.Path; import java.util.HashMap; import java.util.Map;  public class PnpmInstaller {  private static final String VERSION = ""version"";  //registry.npmjs.org/pnpm/-/"";  private static final Object LOCK = new Object();  private String pnpmVersion, pnpmDownloadRoot, userName, password;      private Map<String, String> httpHeaders;  private final Logger logger;  private final InstallConfig config;  private final ArchiveExtractor archiveExtractor;  private final FileDownloader fileDownloader;  PnpmInstaller(InstallConfig config, ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) { this.logger = LoggerFactory.getLogger(getClass()); this.config = config; this.archiveExtractor = archiveExtractor; this.fileDownloader = fileDownloader; } <FILL_ME>  public PnpmInstaller setNodeVersion(String nodeVersion) { return this; }  public PnpmInstaller setPnpmVersion(String pnpmVersion) { this.pnpmVersion = pnpmVersion; return this; }  public PnpmInstaller setPnpmDownloadRoot(String pnpmDownloadRoot) { this.pnpmDownloadRoot = pnpmDownloadRoot; return this; }  public PnpmInstaller setUserName(String userName) { this.userName = userName; return this; }  public PnpmInstaller setPassword(String password) { this.password = password; return this; }  public PnpmInstaller setHttpHeaders(Map<String, String> httpHeaders) { this.httpHeaders = httpHeaders; return this; }  public void install() throws InstallationException { // use static lock object for a synchronized block synchronized (LOCK) { if (this.pnpmDownloadRoot == null || this.pnpmDownloadRoot.isEmpty()) { this.pnpmDownloadRoot = DEFAULT_PNPM_DOWNLOAD_ROOT; } if (!pnpmIsAlreadyInstalled()) { installPnpm(); }  if (this.config.getPlatform().isWindows()) { linkExecutableWindows(); } else { <FILL_ME> linkExecutable(); } } }  private boolean pnpmIsAlreadyInstalled() { try { final File pnpmPackageJson = new File(
                this.config.getInstallDirectory() + Utils.normalize(""/node/node_modules/pnpm/package.json"")); if (pnpmPackageJson.exists()) { HashMap<String, Object> data = new ObjectMapper().readValue(pnpmPackageJson, HashMap.class); if (data.containsKey(VERSION)) { final String foundPnpmVersion = data.get(VERSION).toString(); if (foundPnpmVersion.equals(this.pnpmVersion.replaceFirst(""^v"", """"))) { this.logger.info(""PNPM { } is already installed."", foundPnpmVersion); return true; } else { this.logger.info(""PNPM { } was installed, but we need version { } "", foundPnpmVersion,
                            this.pnpmVersion); return false; } } else { return false; } } else { return false; } } catch (IOException ex) { throw new RuntimeException(""Could not read package.json"", ex); } }  private void installPnpm() throws InstallationException { try { this.logger.info(""Installing pnpm version { } "", this.pnpmVersion); String pnpmVersionClean = this.pnpmVersion.replaceFirst(""^v(?=[0-9]+)"", """"); final String downloadUrl = this.pnpmDownloadRoot + ""pnpm-"" + pnpmVersionClean + "".tgz"";  CacheDescriptor cacheDescriptor = new CacheDescriptor(""pnpm"", pnpmVersionClean, ""tar.gz"");  File archive = this.config.getCacheResolver().resolve(cacheDescriptor);  downloadFileIfMissing(downloadUrl, archive, this.userName, this.password, httpHeaders);  File installDirectory = getNodeInstallDirectory(); File nodeModulesDirectory = new File(installDirectory, ""node_modules"");  // We need to delete the existing pnpm directory first so we clean out any old files, and // so we can rename the package directory below. File oldNpmDirectory = new File(installDirectory, ""pnpm""); File pnpmDirectory = new File(nodeModulesDirectory, ""pnpm""); try { if (oldNpmDirectory.isDirectory()) { FileUtils.deleteDirectory(oldNpmDirectory); } FileUtils.deleteDirectory(pnpmDirectory); } catch (IOException e) { <FILL_ME> }  File packageDirectory = new File(nodeModulesDirectory, ""package""); try { extractFile(archive, nodeModulesDirectory); } catch (ArchiveExtractionException e) { if (e.getCause() instanceof EOFException) { // https://github.com/eirslett/frontend-maven-plugin/issues/794 // The downloading was probably interrupted and archive file is incomplete: // delete it to retry from scratch this.logger.error(""The archive file { } is corrupted and will be deleted. ""
                            + ""Please try the build again."", archive.getPath()); archive.delete(); if (packageDirectory.exists()) { FileUtils.deleteDirectory(packageDirectory); } }  throw e; }  // handles difference between old and new download root (nodejs.org/dist/npm and // registry.npmjs.org) // see https://github.com/eirslett/frontend-maven-plugin/issues/65#issuecomment-52024254 if (packageDirectory.exists() && !pnpmDirectory.exists()) { if (!packageDirectory.renameTo(pnpmDirectory)) { <FILL_ME> FileUtils.copyDirectory(packageDirectory, pnpmDirectory); } }   } catch (DownloadException e) { throw new InstallationException(""Could not download pnpm"", e); } catch (ArchiveExtractionException e) { throw new InstallationException(""Could not extract the pnpm archive"", e); } catch (IOException e) { throw new InstallationException(""Could not copy pnpm"", e); } }  private void linkExecutable() throws InstallationException{ File nodeInstallDirectory = getNodeInstallDirectory(); File pnpmExecutable = new File(nodeInstallDirectory, ""pnpm"");  if (pnpmExecutable.exists()) { <FILL_ME> <FILL_ME> return; }  NodeExecutorConfig executorConfig = new InstallNodeExecutorConfig(this.config); File pnpmJsExecutable = executorConfig.getPnpmCjsPath();  if (!pnpmJsExecutable.exists()) { throw new InstallationException(""Could not link to pnpm executable, no pnpm installation found.""); }  this.logger.info(""No pnpm executable found, creating symbolic link to { } ."", pnpmJsExecutable.toPath());  try { Files.createSymbolicLink(pnpmExecutable.toPath(), pnpmJsExecutable.toPath()); } catch (IOException e) { throw new InstallationException(""Could not create symbolic link for pnpm executable."", e); } }  private void linkExecutableWindows() throws InstallationException{ File nodeInstallDirectory = getNodeInstallDirectory(); File pnpmExecutable = new File(nodeInstallDirectory, ""pnpm.cmd"");  if (pnpmExecutable.exists()) { return; }  NodeExecutorConfig executorConfig = new InstallNodeExecutorConfig(this.config); File pnpmJsExecutable = executorConfig.getPnpmCjsPath();  if (!pnpmJsExecutable.exists()) { throw new InstallationException(""Could not link to pnpm executable, no pnpm installation found.""); }  this.logger.info(""No pnpm executable found, creating proxy script to { } ."", pnpmJsExecutable.toPath());  Path nodePath = executorConfig.getNodePath().toPath(); Path relativeNodePath = nodeInstallDirectory.toPath().relativize(nodePath); Path relativePnpmPath = nodeInstallDirectory.toPath().relativize(pnpmJsExecutable.toPath());  // Create a script that will proxy any commands passed into it to the pnpm executable. String scriptContents = new StringBuilder()
                .append("":: Created by frontend-maven-plugin, please don't edit manually.\r\n"")
                .append(""@ECHO OFF\r\n"")
                .append(""\r\n"")
                .append(""SETLOCAL\r\n"")
                .append(""\r\n"")
                .append(String.format(""SET \""NODE_EXE=%%~dp0\\%s\""\r\n"", relativeNodePath))
                .append(String.format(""SET \""PNPM_CLI_JS=%%~dp0\\%s\""\r\n"", relativePnpmPath))
                .append(""\r\n"")
                .append(""\""%NODE_EXE%\"" \""%PNPM_CLI_JS%\"" %*"")
                .toString();  try { BufferedWriter writer = new BufferedWriter(new FileWriter(pnpmExecutable)); writer.write(scriptContents); writer.close(); } catch (IOException e) { throw new InstallationException(""Could not create proxy script for pnpm executable."", e); } }  private File getNodeInstallDirectory() { File installDirectory = new File(this.config.getInstallDirectory(), NodeInstaller.INSTALL_PATH); if (!installDirectory.exists()) { this.logger.debug(""Creating install directory { } "", installDirectory); installDirectory.mkdirs(); } return installDirectory; }  private void extractFile(File archive, File destinationDirectory) throws ArchiveExtractionException { this.logger.info(""Unpacking { } into { } "", archive, destinationDirectory); this.archiveExtractor.extract(archive.getPath(), destinationDirectory.getPath()); }  private void downloadFileIfMissing(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException { if (!destination.exists()) { downloadFile(downloadUrl, destination, userName, password, httpHeaders); } }  private void downloadFile(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException { this.logger.info(""Downloading { } to { } "", downloadUrl, destination); this.fileDownloader.download(downloadUrl, destination.getPath(), userName, password, httpHeaders); } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/PnpmRunner.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig.Proxy;

import java.util.ArrayList;
import java.util.List;

public interface PnpmRunner extends NodeTaskRunner {}

final class DefaultPnpmRunner extends NodeTaskExecutor implements PnpmRunner {
    static final String TASK_NAME = ""pnpm"";

    public DefaultPnpmRunner(NodeExecutorConfig config, ProxyConfig proxyConfig, String npmRegistryURL) {
        super(config, TASK_NAME, config.getPnpmPath().getAbsolutePath(), buildArguments(proxyConfig, npmRegistryURL));

        if (!config.getPnpmPath().exists() && config.getPnpmCjsPath().exists()) {
            setTaskLocation(config.getPnpmCjsPath().getAbsolutePath());
        }
    }

    // Visible for testing only.
    static List<String> buildArguments(ProxyConfig proxyConfig, String npmRegistryURL) {
        List<String> arguments = new ArrayList<String>();
               
        if(npmRegistryURL != null && !npmRegistryURL.isEmpty()){
            arguments.add (""--registry="" + npmRegistryURL);
        }

        if(!proxyConfig.isEmpty()){
            Proxy proxy = null;
            if(npmRegistryURL != null && !npmRegistryURL.isEmpty()){
                proxy = proxyConfig.getProxyForUrl(npmRegistryURL);
            }

            if(proxy == null){
                proxy = proxyConfig.getSecureProxy();
            }

            if(proxy == null){
                proxy = proxyConfig.getInsecureProxy();
            }

            arguments.add(""--https-proxy="" + proxy.getUri().toString());
            arguments.add(""--proxy="" + proxy.getUri().toString());

            final String nonProxyHosts = proxy.getNonProxyHosts();
            if (nonProxyHosts != null && !nonProxyHosts.isEmpty()) {
                arguments.add(""--noproxy="" + nonProxyHosts.replace('|',','));
            }
        }
        
        return arguments;
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public interface PnpmRunner extends NodeTaskRunner { } final class DefaultPnpmRunner extends NodeTaskExecutor implements PnpmRunner { static final String TASK_NAME = ""pnpm""; public DefaultPnpmRunner(NodeExecutorConfig config, ProxyConfig proxyConfig, String npmRegistryURL) { super(config, TASK_NAME, config.getPnpmPath().getAbsolutePath(), buildArguments(proxyConfig, npmRegistryURL)); if (!config.getPnpmPath().exists() && config.getPnpmCjsPath().exists()) { setTaskLocation(config.getPnpmCjsPath().getAbsolutePath()); } } static List<String> buildArguments(ProxyConfig proxyConfig, String npmRegistryURL) { List<String> arguments = new ArrayList<String>(); if(npmRegistryURL != null && !npmRegistryURL.isEmpty()){ arguments.add (""--registry="" + npmRegistryURL); } if(!proxyConfig.isEmpty()){ Proxy proxy = null; if(npmRegistryURL != null && !npmRegistryURL.isEmpty()){ proxy = proxyConfig.getProxyForUrl(npmRegistryURL); } if(proxy == null){ proxy = proxyConfig.getSecureProxy(); } if(proxy == null){ proxy = proxyConfig.getInsecureProxy(); } arguments.add(""--https-proxy="" + proxy.getUri().toString()); arguments.add(""--proxy="" + proxy.getUri().toString()); final String nonProxyHosts = proxy.getNonProxyHosts(); if (nonProxyHosts != null && !nonProxyHosts.isEmpty()) { arguments.add(""--noproxy="" + nonProxyHosts.replace('|',',')); } } return arguments; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public interface PnpmRunner extends NodeTaskRunner { } final class DefaultPnpmRunner extends NodeTaskExecutor implements PnpmRunner { static final String TASK_NAME = ""pnpm""; public DefaultPnpmRunner(NodeExecutorConfig config, ProxyConfig proxyConfig, String npmRegistryURL) { super(config, TASK_NAME, config.getPnpmPath().getAbsolutePath(), buildArguments(proxyConfig, npmRegistryURL)); if (!config.getPnpmPath().exists() && config.getPnpmCjsPath().exists()) { setTaskLocation(config.getPnpmCjsPath().getAbsolutePath()); } } static List<String> buildArguments(ProxyConfig proxyConfig, String npmRegistryURL) { List<String> arguments = new ArrayList<String>(); if(npmRegistryURL != null && !npmRegistryURL.isEmpty()){ arguments.add (""--registry="" + npmRegistryURL); } if(!proxyConfig.isEmpty()){ Proxy proxy = null; if(npmRegistryURL != null && !npmRegistryURL.isEmpty()){ proxy = proxyConfig.getProxyForUrl(npmRegistryURL); } if(proxy == null){ proxy = proxyConfig.getSecureProxy(); } if(proxy == null){ proxy = proxyConfig.getInsecureProxy(); } arguments.add(""--https-proxy="" + proxy.getUri().toString()); arguments.add(""--proxy="" + proxy.getUri().toString()); final String nonProxyHosts = proxy.getNonProxyHosts(); if (nonProxyHosts != null && !nonProxyHosts.isEmpty()) { arguments.add(""--noproxy="" + nonProxyHosts.replace('|',',')); } } return arguments; } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig.Proxy; 
import java.util.ArrayList; import java.util.List;  public interface PnpmRunner extends NodeTaskRunner { }  final class DefaultPnpmRunner extends NodeTaskExecutor implements PnpmRunner { static final String TASK_NAME = ""pnpm"";  public DefaultPnpmRunner(NodeExecutorConfig config, ProxyConfig proxyConfig, String npmRegistryURL) { super(config, TASK_NAME, config.getPnpmPath().getAbsolutePath(), buildArguments(proxyConfig, npmRegistryURL));  if (!config.getPnpmPath().exists() && config.getPnpmCjsPath().exists()) { setTaskLocation(config.getPnpmCjsPath().getAbsolutePath()); } }  // Visible for testing only. static List<String> buildArguments(ProxyConfig proxyConfig, String npmRegistryURL) { List<String> arguments = new ArrayList<String>();                 if(npmRegistryURL != null && !npmRegistryURL.isEmpty()){ arguments.add (""--registry="" + npmRegistryURL); }  if(!proxyConfig.isEmpty()){ Proxy proxy = null; if(npmRegistryURL != null && !npmRegistryURL.isEmpty()){ proxy = proxyConfig.getProxyForUrl(npmRegistryURL); }  if(proxy == null){ proxy = proxyConfig.getSecureProxy(); }  if(proxy == null){ proxy = proxyConfig.getInsecureProxy(); }  arguments.add(""--https-proxy="" + proxy.getUri().toString()); arguments.add(""--proxy="" + proxy.getUri().toString());  final String nonProxyHosts = proxy.getNonProxyHosts(); if (nonProxyHosts != null && !nonProxyHosts.isEmpty()) { arguments.add(""--noproxy="" + nonProxyHosts.replace('|',',')); } }          return arguments; } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/ProcessExecutor.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.exec.CommandLine;
import org.apache.commons.exec.DefaultExecutor;
import org.apache.commons.exec.ExecuteException;
import org.apache.commons.exec.ExecuteStreamHandler;
import org.apache.commons.exec.ExecuteWatchdog;
import org.apache.commons.exec.Executor;
import org.apache.commons.exec.LogOutputStream;
import org.apache.commons.exec.PumpStreamHandler;
import org.apache.commons.exec.ShutdownHookProcessDestroyer;
import org.slf4j.Logger;

final class ProcessExecutionException extends Exception {
    private static final long serialVersionUID = 1L;

    public ProcessExecutionException(String message) {
        super(message);
    }
    public ProcessExecutionException(Throwable cause) {
        super(cause);
    }
}

final class ProcessExecutor {
    private final static String PATH_ENV_VAR = ""PATH"";

    private final Map<String, String> environment;
    private CommandLine commandLine;
    private final Executor executor;

    public ProcessExecutor(File workingDirectory, List<String> paths, List<String> command, Platform platform, Map<String, String> additionalEnvironment){
        this(workingDirectory, paths, command, platform, additionalEnvironment, 0);
    }

    public ProcessExecutor(File workingDirectory, List<String> paths, List<String> command, Platform platform, Map<String, String> additionalEnvironment, long timeoutInSeconds) {
        this.environment = createEnvironment(paths, platform, additionalEnvironment);
        this.commandLine = createCommandLine(command);
        this.executor = createExecutor(workingDirectory, timeoutInSeconds);
    }

    public String executeAndGetResult(final Logger logger) throws ProcessExecutionException {
        ByteArrayOutputStream stdout = new ByteArrayOutputStream();
        ByteArrayOutputStream stderr = new ByteArrayOutputStream();

        int exitValue = execute(logger, stdout, stderr);
        if (exitValue == 0) {
            return stdout.toString().trim();
        } else {
            throw new ProcessExecutionException(stdout + "" "" + stderr);
        }
    }

    public int executeAndRedirectOutput(final Logger logger) throws ProcessExecutionException {
        OutputStream stdout = new LoggerOutputStream(logger, 0);
        return execute(logger, stdout, stdout);
    }

    private int execute(final Logger logger, final OutputStream stdout, final OutputStream stderr)
            throws ProcessExecutionException {
        logger.debug(""Executing command line {}"", commandLine);
        try {
            ExecuteStreamHandler streamHandler = new PumpStreamHandler(stdout, stderr);
            executor.setStreamHandler(streamHandler);

            int exitValue = executor.execute(commandLine, environment);
            logger.debug(""Exit value {}"", exitValue);

            return exitValue;
        } catch (ExecuteException e) {
            if (executor.getWatchdog() != null && executor.getWatchdog().killedProcess()) {
                throw new ProcessExecutionException(""Process killed after timeout"");
            }
            throw new ProcessExecutionException(e);
        } catch (IOException e) {
            throw new ProcessExecutionException(e);
        }
    }

    private CommandLine createCommandLine(List<String> command) {
        CommandLine commmandLine = new CommandLine(command.get(0));

        for (int i = 1;i < command.size();i++) {
            String argument = command.get(i);
            commmandLine.addArgument(argument, false);
        }

        return commmandLine;
    }

    private Map<String, String> createEnvironment(final List<String> paths, final Platform platform, final Map<String, String> additionalEnvironment) {
        final Map<String, String> environment = new HashMap<>(System.getenv());

        if (additionalEnvironment != null) {
            environment.putAll(additionalEnvironment);
        }

        if (platform.isWindows()) {
            for (final Map.Entry<String, String> entry : environment.entrySet()) {
                final String pathName = entry.getKey();
                if (PATH_ENV_VAR.equalsIgnoreCase(pathName)) {
                    final String pathValue = entry.getValue();
                    environment.put(pathName, extendPathVariable(pathValue, paths));
                }
            }
        } else {
            final String pathValue = environment.get(PATH_ENV_VAR);
            environment.put(PATH_ENV_VAR, extendPathVariable(pathValue, paths));
        }

        return environment;
    }

    private String extendPathVariable(final String existingValue, final List<String> paths) {
        final StringBuilder pathBuilder = new StringBuilder();
        for (final String path : paths) {
            pathBuilder.append(path).append(File.pathSeparator);
        }
        if (existingValue != null) {
            pathBuilder.append(existingValue).append(File.pathSeparator);
        }
        return pathBuilder.toString();
    }

    private Executor createExecutor(File workingDirectory, long timeoutInSeconds) {
        DefaultExecutor executor = new DefaultExecutor();
        executor.setWorkingDirectory(workingDirectory);
        executor.setProcessDestroyer(new ShutdownHookProcessDestroyer());   // Fixes #41

        if (timeoutInSeconds > 0) {
            executor.setWatchdog(new ExecuteWatchdog(timeoutInSeconds * 1000));
        }

        return executor;
    }

    private static class LoggerOutputStream extends LogOutputStream {
        private final Logger logger;

        LoggerOutputStream(Logger logger, int logLevel) {
            super(logLevel);
            this.logger = logger;
        }

        @Override
        public final void flush() {
            // buffer processing on close() only
        }

        @Override
        protected void processLine(final String line, final int logLevel) {
            logger.info(line);
        }
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; final class ProcessExecutionException extends Exception { private static final long serialVersionUID = 1L; public ProcessExecutionException(String message) { super(message); } public ProcessExecutionException(Throwable cause) { super(cause); } } final class ProcessExecutor { private final static String PATH_ENV_VAR = ""PATH""; private final Map<String, String> environment; private CommandLine commandLine; private final Executor executor; public ProcessExecutor(File workingDirectory, List<String> paths, List<String> command, Platform platform, Map<String, String> additionalEnvironment){ this(workingDirectory, paths, command, platform, additionalEnvironment, 0); } public ProcessExecutor(File workingDirectory, List<String> paths, List<String> command, Platform platform, Map<String, String> additionalEnvironment, long timeoutInSeconds) { this.environment = createEnvironment(paths, platform, additionalEnvironment); this.commandLine = createCommandLine(command); this.executor = createExecutor(workingDirectory, timeoutInSeconds); } public String executeAndGetResult(final Logger logger) throws ProcessExecutionException { ByteArrayOutputStream stdout = new ByteArrayOutputStream(); ByteArrayOutputStream stderr = new ByteArrayOutputStream(); int exitValue = execute(logger, stdout, stderr); if (exitValue == 0) { return stdout.toString().trim(); } else { throw new ProcessExecutionException(stdout + "" "" + stderr); } } public int executeAndRedirectOutput(final Logger logger) throws ProcessExecutionException { OutputStream stdout = new LoggerOutputStream(logger, 0); return execute(logger, stdout, stdout); } private int execute(final Logger logger, final OutputStream stdout, final OutputStream stderr)
            throws ProcessExecutionException { logger.debug(""Executing command line { } "", commandLine); try { ExecuteStreamHandler streamHandler = new PumpStreamHandler(stdout, stderr); executor.setStreamHandler(streamHandler); int exitValue = executor.execute(commandLine, environment); logger.debug(""Exit value { } "", exitValue); return exitValue; } catch (ExecuteException e) { if (executor.getWatchdog() != null && executor.getWatchdog().killedProcess()) { throw new ProcessExecutionException(""Process killed after timeout""); } throw new ProcessExecutionException(e); } catch (IOException e) { throw new ProcessExecutionException(e); } } private CommandLine createCommandLine(List<String> command) { CommandLine commmandLine = new CommandLine(command.get(0)); for (int i = 1; i < command.size(); i++) { String argument = command.get(i); commmandLine.addArgument(argument, false); } return commmandLine; } private Map<String, String> createEnvironment(final List<String> paths, final Platform platform, final Map<String, String> additionalEnvironment) { final Map<String, String> environment = new HashMap<>(System.getenv()); if (additionalEnvironment != null) { environment.putAll(additionalEnvironment); } if (platform.isWindows()) { for (final Map.Entry<String, String> entry : environment.entrySet()) { final String pathName = entry.getKey(); if (PATH_ENV_VAR.equalsIgnoreCase(pathName)) { final String pathValue = entry.getValue(); environment.put(pathName, extendPathVariable(pathValue, paths)); } } } else { final String pathValue = environment.get(PATH_ENV_VAR); environment.put(PATH_ENV_VAR, extendPathVariable(pathValue, paths)); } return environment; } private String extendPathVariable(final String existingValue, final List<String> paths) { final StringBuilder pathBuilder = new StringBuilder(); for (final String path : paths) { pathBuilder.append(path).append(File.pathSeparator); } if (existingValue != null) { pathBuilder.append(existingValue).append(File.pathSeparator); } return pathBuilder.toString(); } private Executor createExecutor(File workingDirectory, long timeoutInSeconds) { DefaultExecutor executor = new DefaultExecutor(); executor.setWorkingDirectory(workingDirectory); executor.setProcessDestroyer(new ShutdownHookProcessDestroyer()); if (timeoutInSeconds > 0) { executor.setWatchdog(new ExecuteWatchdog(timeoutInSeconds * 1000)); } return executor; } private static class LoggerOutputStream extends LogOutputStream { private final Logger logger; LoggerOutputStream(Logger logger, int logLevel) { super(logLevel); this.logger = logger; } @Override
        public final void flush() { } @Override
        protected void processLine(final String line, final int logLevel) { } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; final class ProcessExecutionException extends Exception { private static final long serialVersionUID = 1L; public ProcessExecutionException(String message) { super(message); } public ProcessExecutionException(Throwable cause) { super(cause); } } final class ProcessExecutor { private final static String PATH_ENV_VAR = ""PATH""; private final Map<String, String> environment; private CommandLine commandLine; private final Executor executor; public ProcessExecutor(File workingDirectory, List<String> paths, List<String> command, Platform platform, Map<String, String> additionalEnvironment){ this(workingDirectory, paths, command, platform, additionalEnvironment, 0); } public ProcessExecutor(File workingDirectory, List<String> paths, List<String> command, Platform platform, Map<String, String> additionalEnvironment, long timeoutInSeconds) { this.environment = createEnvironment(paths, platform, additionalEnvironment); this.commandLine = createCommandLine(command); this.executor = createExecutor(workingDirectory, timeoutInSeconds); } public String executeAndGetResult(final Logger logger) throws ProcessExecutionException { ByteArrayOutputStream stdout = new ByteArrayOutputStream(); ByteArrayOutputStream stderr = new ByteArrayOutputStream(); int exitValue = execute(logger, stdout, stderr); if (exitValue == 0) { return stdout.toString().trim(); } else { throw new ProcessExecutionException(stdout + "" "" + stderr); } } public int executeAndRedirectOutput(final Logger logger) throws ProcessExecutionException { OutputStream stdout = new LoggerOutputStream(logger, 0); return execute(logger, stdout, stdout); } private int execute(final Logger logger, final OutputStream stdout, final OutputStream stderr)
            throws ProcessExecutionException { logger.debug(""Executing command line { } "", commandLine); try { ExecuteStreamHandler streamHandler = new PumpStreamHandler(stdout, stderr); executor.setStreamHandler(streamHandler); int exitValue = executor.execute(commandLine, environment); logger.debug(""Exit value { } "", exitValue); return exitValue; } catch (ExecuteException e) { if (executor.getWatchdog() != null && executor.getWatchdog().killedProcess()) { throw new ProcessExecutionException(""Process killed after timeout""); } throw new ProcessExecutionException(e); } catch (IOException e) { throw new ProcessExecutionException(e); } } private CommandLine createCommandLine(List<String> command) { CommandLine commmandLine = new CommandLine(command.get(0)); for (int i = 1; i < command.size(); i++) { String argument = command.get(i); commmandLine.addArgument(argument, false); } return commmandLine; } private Map<String, String> createEnvironment(final List<String> paths, final Platform platform, final Map<String, String> additionalEnvironment) { final Map<String, String> environment = new HashMap<>(System.getenv()); if (additionalEnvironment != null) { environment.putAll(additionalEnvironment); } if (platform.isWindows()) { for (final Map.Entry<String, String> entry : environment.entrySet()) { final String pathName = entry.getKey(); if (PATH_ENV_VAR.equalsIgnoreCase(pathName)) { final String pathValue = entry.getValue(); environment.put(pathName, extendPathVariable(pathValue, paths)); } } } else { final String pathValue = environment.get(PATH_ENV_VAR); environment.put(PATH_ENV_VAR, extendPathVariable(pathValue, paths)); } return environment; } private String extendPathVariable(final String existingValue, final List<String> paths) { final StringBuilder pathBuilder = new StringBuilder(); for (final String path : paths) { pathBuilder.append(path).append(File.pathSeparator); } if (existingValue != null) { pathBuilder.append(existingValue).append(File.pathSeparator); } return pathBuilder.toString(); } private Executor createExecutor(File workingDirectory, long timeoutInSeconds) { DefaultExecutor executor = new DefaultExecutor(); executor.setWorkingDirectory(workingDirectory); executor.setProcessDestroyer(new ShutdownHookProcessDestroyer()); if (timeoutInSeconds > 0) { executor.setWatchdog(new ExecuteWatchdog(timeoutInSeconds * 1000)); } return executor; } private static class LoggerOutputStream extends LogOutputStream { private final Logger logger; LoggerOutputStream(Logger logger, int logLevel) { super(logLevel); this.logger = logger; } @Override
        public final void flush() { } @Override
        protected void processLine(final String line, final int logLevel) { <FILL_ME> } } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import java.io.ByteArrayOutputStream; import java.io.File; import java.io.IOException; import java.io.OutputStream; import java.util.HashMap; import java.util.List; import java.util.Map; 
import org.apache.commons.exec.CommandLine; import org.apache.commons.exec.DefaultExecutor; import org.apache.commons.exec.ExecuteException; import org.apache.commons.exec.ExecuteStreamHandler; import org.apache.commons.exec.ExecuteWatchdog; import org.apache.commons.exec.Executor; import org.apache.commons.exec.LogOutputStream; import org.apache.commons.exec.PumpStreamHandler; import org.apache.commons.exec.ShutdownHookProcessDestroyer; import org.slf4j.Logger;  final class ProcessExecutionException extends Exception { private static final long serialVersionUID = 1L;  public ProcessExecutionException(String message) { super(message); } public ProcessExecutionException(Throwable cause) { super(cause); } }  final class ProcessExecutor { private final static String PATH_ENV_VAR = ""PATH"";  private final Map<String, String> environment; private CommandLine commandLine; private final Executor executor;  public ProcessExecutor(File workingDirectory, List<String> paths, List<String> command, Platform platform, Map<String, String> additionalEnvironment){ this(workingDirectory, paths, command, platform, additionalEnvironment, 0); }  public ProcessExecutor(File workingDirectory, List<String> paths, List<String> command, Platform platform, Map<String, String> additionalEnvironment, long timeoutInSeconds) { this.environment = createEnvironment(paths, platform, additionalEnvironment); this.commandLine = createCommandLine(command); this.executor = createExecutor(workingDirectory, timeoutInSeconds); }  public String executeAndGetResult(final Logger logger) throws ProcessExecutionException { ByteArrayOutputStream stdout = new ByteArrayOutputStream(); ByteArrayOutputStream stderr = new ByteArrayOutputStream();  int exitValue = execute(logger, stdout, stderr); if (exitValue == 0) { return stdout.toString().trim(); } else { throw new ProcessExecutionException(stdout + "" "" + stderr); } }  public int executeAndRedirectOutput(final Logger logger) throws ProcessExecutionException { OutputStream stdout = new LoggerOutputStream(logger, 0); return execute(logger, stdout, stdout); }  private int execute(final Logger logger, final OutputStream stdout, final OutputStream stderr)
            throws ProcessExecutionException { logger.debug(""Executing command line { } "", commandLine); try { ExecuteStreamHandler streamHandler = new PumpStreamHandler(stdout, stderr); executor.setStreamHandler(streamHandler);  int exitValue = executor.execute(commandLine, environment); logger.debug(""Exit value { } "", exitValue);  return exitValue; } catch (ExecuteException e) { if (executor.getWatchdog() != null && executor.getWatchdog().killedProcess()) { throw new ProcessExecutionException(""Process killed after timeout""); } throw new ProcessExecutionException(e); } catch (IOException e) { throw new ProcessExecutionException(e); } }  private CommandLine createCommandLine(List<String> command) { CommandLine commmandLine = new CommandLine(command.get(0));  for (int i = 1; i < command.size(); i++) { String argument = command.get(i); commmandLine.addArgument(argument, false); }  return commmandLine; }  private Map<String, String> createEnvironment(final List<String> paths, final Platform platform, final Map<String, String> additionalEnvironment) { final Map<String, String> environment = new HashMap<>(System.getenv());  if (additionalEnvironment != null) { environment.putAll(additionalEnvironment); }  if (platform.isWindows()) { for (final Map.Entry<String, String> entry : environment.entrySet()) { final String pathName = entry.getKey(); if (PATH_ENV_VAR.equalsIgnoreCase(pathName)) { final String pathValue = entry.getValue(); environment.put(pathName, extendPathVariable(pathValue, paths)); } } } else { final String pathValue = environment.get(PATH_ENV_VAR); environment.put(PATH_ENV_VAR, extendPathVariable(pathValue, paths)); }  return environment; }  private String extendPathVariable(final String existingValue, final List<String> paths) { final StringBuilder pathBuilder = new StringBuilder(); for (final String path : paths) { pathBuilder.append(path).append(File.pathSeparator); } if (existingValue != null) { pathBuilder.append(existingValue).append(File.pathSeparator); } return pathBuilder.toString(); }  private Executor createExecutor(File workingDirectory, long timeoutInSeconds) { DefaultExecutor executor = new DefaultExecutor(); executor.setWorkingDirectory(workingDirectory); executor.setProcessDestroyer(new ShutdownHookProcessDestroyer()); // Fixes #41  if (timeoutInSeconds > 0) { executor.setWatchdog(new ExecuteWatchdog(timeoutInSeconds * 1000)); }  return executor; }  private static class LoggerOutputStream extends LogOutputStream { private final Logger logger;  LoggerOutputStream(Logger logger, int logLevel) { super(logLevel); this.logger = logger; }  @Override
        public final void flush() { // buffer processing on close() only }  @Override
        protected void processLine(final String line, final int logLevel) { <FILL_ME> } } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/ProxyConfig.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.List;
import java.util.StringTokenizer;

public class ProxyConfig {

    private static final Logger LOGGER = LoggerFactory.getLogger(ProxyConfig.class);

    private final List<Proxy> proxies;

    public ProxyConfig(List<Proxy> proxies) {
        this.proxies = proxies;
    }

    public boolean isEmpty() {
        return proxies.isEmpty();
    }

    public Proxy getProxyForUrl(String requestUrl) {
        if (proxies.isEmpty()) {
            LOGGER.info(""No proxies configured"");
            return null;
        }
        final URI uri = URI.create(requestUrl);
        for (Proxy proxy : proxies) {
            if (!proxy.isNonProxyHost(uri.getHost())) {
                return proxy;
            }
        }
        LOGGER.info(""Could not find matching proxy for host: {}"", uri.getHost());
        return null;
    }

    public Proxy getSecureProxy() {
        for (Proxy proxy : proxies) {
            if (proxy.isSecure()) {
                return proxy;
            }
        }
        return null;
    }

    public Proxy getInsecureProxy() {
        for (Proxy proxy : proxies) {
            if (!proxy.isSecure()) {
                return proxy;
            }
        }
        return null;
    }

    public static class Proxy {
        public final String id;
        public final String protocol;
        public final String host;
        public final int port;
        public final String username;
        public final String password;

        public final String nonProxyHosts;

        public Proxy(String id, String protocol, String host, int port, String username, String password, String nonProxyHosts) {
            this.host = host;
            this.id = id;
            this.protocol = protocol;
            this.port = port;
            this.username = username;
            this.password = password;
            this.nonProxyHosts = nonProxyHosts;
        }

        public boolean useAuthentication(){
            return username != null && !username.isEmpty();
        }

        public URI getUri() {
            String authentication = useAuthentication() ? username + "":"" + password : null;
            try {
                // Proxies should be schemed with http, even if the protocol is https
                return new URI(""http"", authentication, host, port, null, null, null);
            } catch (URISyntaxException e) {
                throw new ProxyConfigException(""Invalid proxy settings"", e);
            }
        }

        public boolean isSecure(){
            return ""https"".equals(protocol);
        }

        public boolean isNonProxyHost(String host) {
            if (host != null && nonProxyHosts != null && nonProxyHosts.length() > 0) {
                for (StringTokenizer tokenizer = new StringTokenizer(nonProxyHosts, ""|""); tokenizer.hasMoreTokens(); ) {
                    String pattern = tokenizer.nextToken();
                    pattern = pattern.replace(""."", ""\\."").replace(""*"", "".*"");
                    if (host.matches(pattern)) {
                        return true;
                    }
                }
            }

            return false;
        }

        /**
         * As per https://docs.npmjs.com/misc/config#noproxy , npm expects a comma (`,`) separated list but
         * maven settings.xml usually specifies the no proxy hosts as a bar (`|`) separated list (see
         * http://maven.apache.org/guides/mini/guide-proxies.html) .
         *
         * We could do the conversion here but npm seems to accept the bar separated list regardless
         * of what the documentation says so we do no conversion for now.
         * @return
         */
        public String getNonProxyHosts() {
            return nonProxyHosts;
        }

        @Override
        public String toString() {
            return id + ""{"" +
                    ""protocol='"" + protocol + '\'' +
                    "", host='"" + host + '\'' +
                    "", port="" + port +
                    "", nonProxyHosts='"" + nonProxyHosts + '\'' +
                    (useAuthentication()? "", with username/passport authentication"" : """") +
                    '}';
        }
    }

    static class ProxyConfigException extends RuntimeException {

        private ProxyConfigException(String message, Exception cause) {
            super(message, cause);
        }

    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public class ProxyConfig { private static final Logger LOGGER = LoggerFactory.getLogger(ProxyConfig.class); private final List<Proxy> proxies; public ProxyConfig(List<Proxy> proxies) { this.proxies = proxies; } public boolean isEmpty() { return proxies.isEmpty(); } public Proxy getProxyForUrl(String requestUrl) { if (proxies.isEmpty()) { return null; } final URI uri = URI.create(requestUrl); for (Proxy proxy : proxies) { if (!proxy.isNonProxyHost(uri.getHost())) { return proxy; } } LOGGER.info(""Could not find matching proxy for host: { } "", uri.getHost()); return null; } public Proxy getSecureProxy() { for (Proxy proxy : proxies) { if (proxy.isSecure()) { return proxy; } } return null; } public Proxy getInsecureProxy() { for (Proxy proxy : proxies) { if (!proxy.isSecure()) { return proxy; } } return null; } public static class Proxy { public final String id; public final String protocol; public final String host; public final int port; public final String username; public final String password; public final String nonProxyHosts; public Proxy(String id, String protocol, String host, int port, String username, String password, String nonProxyHosts) { this.host = host; this.id = id; this.protocol = protocol; this.port = port; this.username = username; this.password = password; this.nonProxyHosts = nonProxyHosts; } public boolean useAuthentication(){ return username != null && !username.isEmpty(); } public URI getUri() { String authentication = useAuthentication() ? username + "":"" + password : null; try { return new URI(""http"", authentication, host, port, null, null, null); } catch (URISyntaxException e) { throw new ProxyConfigException(""Invalid proxy settings"", e); } } public boolean isSecure(){ return ""https"".equals(protocol); } public boolean isNonProxyHost(String host) { if (host != null && nonProxyHosts != null && nonProxyHosts.length() > 0) { for (StringTokenizer tokenizer = new StringTokenizer(nonProxyHosts, ""|""); tokenizer.hasMoreTokens(); ) { String pattern = tokenizer.nextToken(); pattern = pattern.replace(""."", ""\\."").replace(""*"", "".*""); if (host.matches(pattern)) { return true; } } } return false; } public String getNonProxyHosts() { return nonProxyHosts; } @Override
        public String toString() { return id + ""{ "" +
                    ""protocol='"" + protocol + '\'' +
                    "", host='"" + host + '\'' +
                    "", port="" + port +
                    "", nonProxyHosts='"" + nonProxyHosts + '\'' +
                    (useAuthentication()? "", with username/passport authentication"" : """") +
                    '} '; } } static class ProxyConfigException extends RuntimeException { private ProxyConfigException(String message, Exception cause) { super(message, cause); } } }",0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public class ProxyConfig { private static final Logger LOGGER = LoggerFactory.getLogger(ProxyConfig.class); private final List<Proxy> proxies; public ProxyConfig(List<Proxy> proxies) { this.proxies = proxies; } public boolean isEmpty() { return proxies.isEmpty(); } public Proxy getProxyForUrl(String requestUrl) { if (proxies.isEmpty()) { <FILL_ME> return null; } final URI uri = URI.create(requestUrl); for (Proxy proxy : proxies) { if (!proxy.isNonProxyHost(uri.getHost())) { return proxy; } } LOGGER.info(""Could not find matching proxy for host: { } "", uri.getHost()); return null; } public Proxy getSecureProxy() { for (Proxy proxy : proxies) { if (proxy.isSecure()) { return proxy; } } return null; } public Proxy getInsecureProxy() { for (Proxy proxy : proxies) { if (!proxy.isSecure()) { return proxy; } } return null; } public static class Proxy { public final String id; public final String protocol; public final String host; public final int port; public final String username; public final String password; public final String nonProxyHosts; public Proxy(String id, String protocol, String host, int port, String username, String password, String nonProxyHosts) { this.host = host; this.id = id; this.protocol = protocol; this.port = port; this.username = username; this.password = password; this.nonProxyHosts = nonProxyHosts; } public boolean useAuthentication(){ return username != null && !username.isEmpty(); } public URI getUri() { String authentication = useAuthentication() ? username + "":"" + password : null; try { return new URI(""http"", authentication, host, port, null, null, null); } catch (URISyntaxException e) { throw new ProxyConfigException(""Invalid proxy settings"", e); } } public boolean isSecure(){ return ""https"".equals(protocol); } public boolean isNonProxyHost(String host) { if (host != null && nonProxyHosts != null && nonProxyHosts.length() > 0) { for (StringTokenizer tokenizer = new StringTokenizer(nonProxyHosts, ""|""); tokenizer.hasMoreTokens(); ) { String pattern = tokenizer.nextToken(); pattern = pattern.replace(""."", ""\\."").replace(""*"", "".*""); if (host.matches(pattern)) { return true; } } } return false; } public String getNonProxyHosts() { return nonProxyHosts; } @Override
        public String toString() { return id + ""{ "" +
                    ""protocol='"" + protocol + '\'' +
                    "", host='"" + host + '\'' +
                    "", port="" + port +
                    "", nonProxyHosts='"" + nonProxyHosts + '\'' +
                    (useAuthentication()? "", with username/passport authentication"" : """") +
                    '} '; } } static class ProxyConfigException extends RuntimeException { private ProxyConfigException(String message, Exception cause) { super(message, cause); } } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import org.slf4j.Logger; import org.slf4j.LoggerFactory; 
import java.net.URI; import java.net.URISyntaxException; import java.util.List; import java.util.StringTokenizer;  public class ProxyConfig {  private static final Logger LOGGER = LoggerFactory.getLogger(ProxyConfig.class);  private final List<Proxy> proxies;  public ProxyConfig(List<Proxy> proxies) { this.proxies = proxies; }  public boolean isEmpty() { return proxies.isEmpty(); }  public Proxy getProxyForUrl(String requestUrl) { if (proxies.isEmpty()) { <FILL_ME> return null; } final URI uri = URI.create(requestUrl); for (Proxy proxy : proxies) { if (!proxy.isNonProxyHost(uri.getHost())) { return proxy; } } LOGGER.info(""Could not find matching proxy for host: { } "", uri.getHost()); return null; }  public Proxy getSecureProxy() { for (Proxy proxy : proxies) { if (proxy.isSecure()) { return proxy; } } return null; }  public Proxy getInsecureProxy() { for (Proxy proxy : proxies) { if (!proxy.isSecure()) { return proxy; } } return null; }  public static class Proxy { public final String id; public final String protocol; public final String host; public final int port; public final String username; public final String password;  public final String nonProxyHosts;  public Proxy(String id, String protocol, String host, int port, String username, String password, String nonProxyHosts) { this.host = host; this.id = id; this.protocol = protocol; this.port = port; this.username = username; this.password = password; this.nonProxyHosts = nonProxyHosts; }  public boolean useAuthentication(){ return username != null && !username.isEmpty(); }  public URI getUri() { String authentication = useAuthentication() ? username + "":"" + password : null; try { // Proxies should be schemed with http, even if the protocol is https return new URI(""http"", authentication, host, port, null, null, null); } catch (URISyntaxException e) { throw new ProxyConfigException(""Invalid proxy settings"", e); } }  public boolean isSecure(){ return ""https"".equals(protocol); }  public boolean isNonProxyHost(String host) { if (host != null && nonProxyHosts != null && nonProxyHosts.length() > 0) { for (StringTokenizer tokenizer = new StringTokenizer(nonProxyHosts, ""|""); tokenizer.hasMoreTokens(); ) { String pattern = tokenizer.nextToken(); pattern = pattern.replace(""."", ""\\."").replace(""*"", "".*""); if (host.matches(pattern)) { return true; } } }  return false; }  /**
         * As per https://docs.npmjs.com/misc/config#noproxy , npm expects a comma (`,`) separated list but
         * maven settings.xml usually specifies the no proxy hosts as a bar (`|`) separated list (see
         * http://maven.apache.org/guides/mini/guide-proxies.html) .
         *
         * We could do the conversion here but npm seems to accept the bar separated list regardless
         * of what the documentation says so we do no conversion for now.
         * @return
         */ public String getNonProxyHosts() { return nonProxyHosts; }  @Override
        public String toString() { return id + ""{ "" +
                    ""protocol='"" + protocol + '\'' +
                    "", host='"" + host + '\'' +
                    "", port="" + port +
                    "", nonProxyHosts='"" + nonProxyHosts + '\'' +
                    (useAuthentication()? "", with username/passport authentication"" : """") +
                    '} '; } }  static class ProxyConfigException extends RuntimeException {  private ProxyConfigException(String message, Exception cause) { super(message, cause); }  } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/TaskRunnerException.java,"package com.github.eirslett.maven.plugins.frontend.lib;

public class TaskRunnerException extends FrontendException {
    TaskRunnerException(String message) {
        super(message);
    }

    TaskRunnerException(String message, Throwable cause){
        super(message, cause);
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public class TaskRunnerException extends FrontendException { TaskRunnerException(String message) { super(message); } TaskRunnerException(String message, Throwable cause){ super(message, cause); } }",0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public class TaskRunnerException extends FrontendException { TaskRunnerException(String message) { super(message); } TaskRunnerException(String message, Throwable cause){ super(message, cause); } } ","package com.github.eirslett.maven.plugins.frontend.lib;  public class TaskRunnerException extends FrontendException { TaskRunnerException(String message) { super(message); }  TaskRunnerException(String message, Throwable cause){ super(message, cause); } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/Utils.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

final class Utils {
    public static List<String> merge(List<String> first, List<String> second) {
        ArrayList<String> result = new ArrayList<String>(first);
        result.addAll(second);
        return result;
    }

    public static List<String> prepend(String first, List<String> list){
        return merge(Arrays.asList(first), list);
    }

    public static String normalize(String path){
        return path.replace(""/"", File.separator);
    }

    public static String implode(String separator, List<String> elements){
        StringBuffer s = new StringBuffer();
        for(int i = 0; i < elements.size(); i++){
            if(i > 0){
                s.append("" "");
            }
            s.append(elements.get(i));
        }
        return s.toString();
    }

    public static boolean isRelative(String path) {
        return !path.startsWith(""/"") && !path.startsWith(""file:"") && !path.matches(""^[a-zA-Z]:\\\\.*"");
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; final class Utils { public static List<String> merge(List<String> first, List<String> second) { ArrayList<String> result = new ArrayList<String>(first); result.addAll(second); return result; } public static List<String> prepend(String first, List<String> list){ return merge(Arrays.asList(first), list); } public static String normalize(String path){ return path.replace(""/"", File.separator); } public static String implode(String separator, List<String> elements){ StringBuffer s = new StringBuffer(); for(int i = 0; i < elements.size(); i++){ if(i > 0){ s.append("" ""); } s.append(elements.get(i)); } return s.toString(); } public static boolean isRelative(String path) { return !path.startsWith(""/"") && !path.startsWith(""file:"") && !path.matches(""^[a-zA-Z]:\\\\.*""); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; final class Utils { public static List<String> merge(List<String> first, List<String> second) { ArrayList<String> result = new ArrayList<String>(first); result.addAll(second); return result; } public static List<String> prepend(String first, List<String> list){ return merge(Arrays.asList(first), list); } public static String normalize(String path){ return path.replace(""/"", File.separator); } public static String implode(String separator, List<String> elements){ StringBuffer s = new StringBuffer(); for(int i = 0; i < elements.size(); i++){ if(i > 0){ s.append("" ""); } s.append(elements.get(i)); } return s.toString(); } public static boolean isRelative(String path) { return !path.startsWith(""/"") && !path.startsWith(""file:"") && !path.matches(""^[a-zA-Z]:\\\\.*""); } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import java.io.File; import java.util.ArrayList; import java.util.Arrays; import java.util.List;  final class Utils { public static List<String> merge(List<String> first, List<String> second) { ArrayList<String> result = new ArrayList<String>(first); result.addAll(second); return result; }  public static List<String> prepend(String first, List<String> list){ return merge(Arrays.asList(first), list); }  public static String normalize(String path){ return path.replace(""/"", File.separator); }  public static String implode(String separator, List<String> elements){ StringBuffer s = new StringBuffer(); for(int i = 0; i < elements.size(); i++){ if(i > 0){ s.append("" ""); } s.append(elements.get(i)); } return s.toString(); }  public static boolean isRelative(String path) { return !path.startsWith(""/"") && !path.startsWith(""file:"") && !path.matches(""^[a-zA-Z]:\\\\.*""); } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/WebpackRunner.java,"package com.github.eirslett.maven.plugins.frontend.lib;

public interface WebpackRunner extends NodeTaskRunner {}

final class DefaultWebpackRunner extends NodeTaskExecutor implements WebpackRunner {

    private static final String TASK_LOCATION = ""node_modules/webpack/bin/webpack.js"";

    DefaultWebpackRunner(NodeExecutorConfig config) {
        super(config, TASK_LOCATION);
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public interface WebpackRunner extends NodeTaskRunner { } final class DefaultWebpackRunner extends NodeTaskExecutor implements WebpackRunner { private static final String TASK_LOCATION = ""node_modules/webpack/bin/webpack.js""; DefaultWebpackRunner(NodeExecutorConfig config) { super(config, TASK_LOCATION); } }",0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public interface WebpackRunner extends NodeTaskRunner { } final class DefaultWebpackRunner extends NodeTaskExecutor implements WebpackRunner { private static final String TASK_LOCATION = ""node_modules/webpack/bin/webpack.js""; DefaultWebpackRunner(NodeExecutorConfig config) { super(config, TASK_LOCATION); } } ","package com.github.eirslett.maven.plugins.frontend.lib;  public interface WebpackRunner extends NodeTaskRunner { }  final class DefaultWebpackRunner extends NodeTaskExecutor implements WebpackRunner {  private static final String TASK_LOCATION = ""node_modules/webpack/bin/webpack.js"";  DefaultWebpackRunner(NodeExecutorConfig config) { super(config, TASK_LOCATION); } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/YarnExecutor.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;

final class YarnExecutor {

    private final ProcessExecutor executor;

    public YarnExecutor(YarnExecutorConfig config, List<String> arguments,
        Map<String, String> additionalEnvironment) {
        final String yarn = config.getYarnPath().getAbsolutePath();
        List<String> localPaths = new ArrayList<>();
        localPaths.add(config.getYarnPath().getParent());
        localPaths.add(config.getNodePath().getParent());
        executor = new ProcessExecutor(config.getWorkingDirectory(), localPaths,
            Utils.prepend(yarn, arguments), config.getPlatform(), additionalEnvironment);
    }

    public String executeAndGetResult(final Logger logger) throws ProcessExecutionException {
        return executor.executeAndGetResult(logger);
    }

    public int executeAndRedirectOutput(final Logger logger) throws ProcessExecutionException {
        return executor.executeAndRedirectOutput(logger);
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; final class YarnExecutor { private final ProcessExecutor executor; public YarnExecutor(YarnExecutorConfig config, List<String> arguments,
        Map<String, String> additionalEnvironment) { final String yarn = config.getYarnPath().getAbsolutePath(); List<String> localPaths = new ArrayList<>(); localPaths.add(config.getYarnPath().getParent()); localPaths.add(config.getNodePath().getParent()); executor = new ProcessExecutor(config.getWorkingDirectory(), localPaths,
            Utils.prepend(yarn, arguments), config.getPlatform(), additionalEnvironment); } public String executeAndGetResult(final Logger logger) throws ProcessExecutionException { return executor.executeAndGetResult(logger); } public int executeAndRedirectOutput(final Logger logger) throws ProcessExecutionException { return executor.executeAndRedirectOutput(logger); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; final class YarnExecutor { private final ProcessExecutor executor; public YarnExecutor(YarnExecutorConfig config, List<String> arguments,
        Map<String, String> additionalEnvironment) { final String yarn = config.getYarnPath().getAbsolutePath(); List<String> localPaths = new ArrayList<>(); localPaths.add(config.getYarnPath().getParent()); localPaths.add(config.getNodePath().getParent()); executor = new ProcessExecutor(config.getWorkingDirectory(), localPaths,
            Utils.prepend(yarn, arguments), config.getPlatform(), additionalEnvironment); } public String executeAndGetResult(final Logger logger) throws ProcessExecutionException { return executor.executeAndGetResult(logger); } public int executeAndRedirectOutput(final Logger logger) throws ProcessExecutionException { return executor.executeAndRedirectOutput(logger); } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import java.util.ArrayList; import java.util.List; import java.util.Map; 
import org.slf4j.Logger;  final class YarnExecutor {  private final ProcessExecutor executor;  public YarnExecutor(YarnExecutorConfig config, List<String> arguments,
        Map<String, String> additionalEnvironment) { final String yarn = config.getYarnPath().getAbsolutePath(); List<String> localPaths = new ArrayList<>(); localPaths.add(config.getYarnPath().getParent()); localPaths.add(config.getNodePath().getParent()); executor = new ProcessExecutor(config.getWorkingDirectory(), localPaths,
            Utils.prepend(yarn, arguments), config.getPlatform(), additionalEnvironment); }  public String executeAndGetResult(final Logger logger) throws ProcessExecutionException { return executor.executeAndGetResult(logger); }  public int executeAndRedirectOutput(final Logger logger) throws ProcessExecutionException { return executor.executeAndRedirectOutput(logger); } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/YarnExecutorConfig.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import java.io.File;

public interface YarnExecutorConfig {

    File getNodePath();

    File getYarnPath();

    File getWorkingDirectory();

    Platform getPlatform();

    boolean isYarnBerry();
}

final class InstallYarnExecutorConfig implements YarnExecutorConfig {

    private static final String YARN_WINDOWS =
        YarnInstaller.INSTALL_PATH.concat(""/dist/bin/yarn.cmd"").replaceAll(""/"", ""\\\\"");

    private static final String YARN_DEFAULT = YarnInstaller.INSTALL_PATH + ""/dist/bin/yarn"";

    private final File nodePath;

    private final InstallConfig installConfig;

    private final boolean isYarnBerry;

    public InstallYarnExecutorConfig(InstallConfig installConfig, final boolean isYarnBerry) {
        this.installConfig = installConfig;
        nodePath = new InstallNodeExecutorConfig(installConfig).getNodePath();
        this.isYarnBerry = isYarnBerry;
    }

    @Override
    public File getNodePath() {
        return nodePath;
    }

    @Override
    public File getYarnPath() {
        String yarnExecutable = getPlatform().isWindows() ? YARN_WINDOWS : YARN_DEFAULT;
        return new File(installConfig.getInstallDirectory() + yarnExecutable);
    }

    @Override
    public File getWorkingDirectory() {
        return installConfig.getWorkingDirectory();
    }

    @Override
    public Platform getPlatform() {
        return installConfig.getPlatform();
    }

    @Override
    public boolean isYarnBerry() {
        return isYarnBerry;
    }
}","package com.github.eirslett.maven.plugins.frontend.lib; public interface YarnExecutorConfig { File getNodePath(); File getYarnPath(); File getWorkingDirectory(); Platform getPlatform(); boolean isYarnBerry(); } final class InstallYarnExecutorConfig implements YarnExecutorConfig { private static final String YARN_WINDOWS =
        YarnInstaller.INSTALL_PATH.concat(""/dist/bin/yarn.cmd"").replaceAll(""/"", ""\\\\""); private static final String YARN_DEFAULT = YarnInstaller.INSTALL_PATH + ""/dist/bin/yarn""; private final File nodePath; private final InstallConfig installConfig; private final boolean isYarnBerry; public InstallYarnExecutorConfig(InstallConfig installConfig, final boolean isYarnBerry) { this.installConfig = installConfig; nodePath = new InstallNodeExecutorConfig(installConfig).getNodePath(); this.isYarnBerry = isYarnBerry; } @Override
    public File getNodePath() { return nodePath; } @Override
    public File getYarnPath() { String yarnExecutable = getPlatform().isWindows() ? YARN_WINDOWS : YARN_DEFAULT; return new File(installConfig.getInstallDirectory() + yarnExecutable); } @Override
    public File getWorkingDirectory() { return installConfig.getWorkingDirectory(); } @Override
    public Platform getPlatform() { return installConfig.getPlatform(); } @Override
    public boolean isYarnBerry() { return isYarnBerry; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public interface YarnExecutorConfig { File getNodePath(); File getYarnPath(); File getWorkingDirectory(); Platform getPlatform(); boolean isYarnBerry(); } final class InstallYarnExecutorConfig implements YarnExecutorConfig { private static final String YARN_WINDOWS =
        YarnInstaller.INSTALL_PATH.concat(""/dist/bin/yarn.cmd"").replaceAll(""/"", ""\\\\""); private static final String YARN_DEFAULT = YarnInstaller.INSTALL_PATH + ""/dist/bin/yarn""; private final File nodePath; private final InstallConfig installConfig; private final boolean isYarnBerry; public InstallYarnExecutorConfig(InstallConfig installConfig, final boolean isYarnBerry) { this.installConfig = installConfig; nodePath = new InstallNodeExecutorConfig(installConfig).getNodePath(); this.isYarnBerry = isYarnBerry; } @Override
    public File getNodePath() { return nodePath; } @Override
    public File getYarnPath() { String yarnExecutable = getPlatform().isWindows() ? YARN_WINDOWS : YARN_DEFAULT; return new File(installConfig.getInstallDirectory() + yarnExecutable); } @Override
    public File getWorkingDirectory() { return installConfig.getWorkingDirectory(); } @Override
    public Platform getPlatform() { return installConfig.getPlatform(); } @Override
    public boolean isYarnBerry() { return isYarnBerry; } }","package com.github.eirslett.maven.plugins.frontend.lib; 
import java.io.File;  public interface YarnExecutorConfig {  File getNodePath();  File getYarnPath();  File getWorkingDirectory();  Platform getPlatform();  boolean isYarnBerry(); }  final class InstallYarnExecutorConfig implements YarnExecutorConfig {  private static final String YARN_WINDOWS =
        YarnInstaller.INSTALL_PATH.concat(""/dist/bin/yarn.cmd"").replaceAll(""/"", ""\\\\"");  private static final String YARN_DEFAULT = YarnInstaller.INSTALL_PATH + ""/dist/bin/yarn"";  private final File nodePath;  private final InstallConfig installConfig;  private final boolean isYarnBerry;  public InstallYarnExecutorConfig(InstallConfig installConfig, final boolean isYarnBerry) { this.installConfig = installConfig; nodePath = new InstallNodeExecutorConfig(installConfig).getNodePath(); this.isYarnBerry = isYarnBerry; }  @Override
    public File getNodePath() { return nodePath; }  @Override
    public File getYarnPath() { String yarnExecutable = getPlatform().isWindows() ? YARN_WINDOWS : YARN_DEFAULT; return new File(installConfig.getInstallDirectory() + yarnExecutable); }  @Override
    public File getWorkingDirectory() { return installConfig.getWorkingDirectory(); }  @Override
    public Platform getPlatform() { return installConfig.getPlatform(); }  @Override
    public boolean isYarnBerry() { return isYarnBerry; } }"
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/YarnInstaller.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import java.io.EOFException;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Arrays;
import java.util.Map;

import org.apache.commons.io.FileUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class YarnInstaller {

    public static final String INSTALL_PATH = ""/node/yarn"";

    public static final String DEFAULT_YARN_DOWNLOAD_ROOT =
        ""https://github.com/yarnpkg/yarn/releases/download/"";

    private static final Object LOCK = new Object();

    private static final String YARN_ROOT_DIRECTORY = ""dist"";

    private String yarnVersion, yarnDownloadRoot, userName, password;
    
    private Map<String, String> httpHeaders;

    private boolean isYarnBerry;

    private final Logger logger;

    private final InstallConfig config;

    private final ArchiveExtractor archiveExtractor;

    private final FileDownloader fileDownloader;

    YarnInstaller(InstallConfig config, ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) {
        logger = LoggerFactory.getLogger(getClass());
        this.config = config;
        this.archiveExtractor = archiveExtractor;
        this.fileDownloader = fileDownloader;
    }

    public YarnInstaller setYarnVersion(String yarnVersion) {
        this.yarnVersion = yarnVersion;
        return this;
    }

    public YarnInstaller setIsYarnBerry(boolean isYarnBerry) {
        this.isYarnBerry = isYarnBerry;
        return this;
    }

    public YarnInstaller setYarnDownloadRoot(String yarnDownloadRoot) {
        this.yarnDownloadRoot = yarnDownloadRoot;
        return this;
    }

    public YarnInstaller setUserName(String userName) {
        this.userName = userName;
        return this;
    }

    public YarnInstaller setPassword(String password) {
        this.password = password;
        return this;
    }

    public YarnInstaller setHttpHeaders(Map<String, String> httpHeaders) {
        this.httpHeaders = httpHeaders;
        return this;
    }

    public void install() throws InstallationException {
        // use static lock object for a synchronized block
        synchronized (LOCK) {
            if (yarnDownloadRoot == null || yarnDownloadRoot.isEmpty()) {
                yarnDownloadRoot = DEFAULT_YARN_DOWNLOAD_ROOT;
            }
            if (!yarnIsAlreadyInstalled()) {
                if (!yarnVersion.startsWith(""v"")) {
                    throw new InstallationException(""Yarn version has to start with prefix 'v'."");
                }
                installYarn();
            }
        }
    }

    private boolean yarnIsAlreadyInstalled() {
        try {
            YarnExecutorConfig executorConfig = new InstallYarnExecutorConfig(config, isYarnBerry);
            File nodeFile = executorConfig.getYarnPath();
            if (nodeFile.exists()) {
                final String version =
                    new YarnExecutor(executorConfig, Arrays.asList(""--version""), null).executeAndGetResult(logger).trim();

                if (version.equals(yarnVersion.replaceFirst(""^v"", """"))) {
                    logger.info(""Yarn {} is already installed."", version);
                    return true;
                } else {
                    if (isYarnBerry && Integer.parseInt(version.split(""\\."")[0]) > 1) {
                        logger.info(""Yarn Berry {} is installed."", version);
                        return true;
                    } else{
                        logger.info(""Yarn {} was installed, but we need version {}"", version, yarnVersion);
                        return false;
                    }
                }
            } else {
                return false;
            }
        } catch (ProcessExecutionException e) {
            return false;
        }
    }

    private void installYarn() throws InstallationException {
        try {
            logger.info(""Installing Yarn version {}"", yarnVersion);
            String downloadUrl = yarnDownloadRoot + yarnVersion;
            String extension = ""tar.gz"";
            String fileending = ""/yarn-"" + yarnVersion + ""."" + extension;

            downloadUrl += fileending;

            CacheDescriptor cacheDescriptor = new CacheDescriptor(""yarn"", yarnVersion, extension);

            File archive = config.getCacheResolver().resolve(cacheDescriptor);

            downloadFileIfMissing(downloadUrl, archive, userName, password, httpHeaders);

            File installDirectory = getInstallDirectory();

            // We need to delete the existing yarn directory first so we clean out any old files, and
            // so we can rename the package directory below.
            try {
                if (installDirectory.isDirectory()) {
                    FileUtils.deleteDirectory(installDirectory);
                }
            } catch (IOException e) {
                logger.warn(""Failed to delete existing Yarn installation."");
            }

            try {
                extractFile(archive, installDirectory);
            } catch (ArchiveExtractionException e) {
                if (e.getCause() instanceof EOFException) {
                    // https://github.com/eirslett/frontend-maven-plugin/issues/794
                    // The downloading was probably interrupted and archive file is incomplete:
                    // delete it to retry from scratch
                    this.logger.error(""The archive file {} is corrupted and will be deleted. ""
                            + ""Please try the build again."", archive.getPath());
                    archive.delete();
                    if (installDirectory.exists()) {
                        FileUtils.deleteDirectory(installDirectory);
                    }
                }

                throw e;
            }

            ensureCorrectYarnRootDirectory(installDirectory, yarnVersion);

            logger.info(""Installed Yarn locally."");
        } catch (DownloadException e) {
            throw new InstallationException(""Could not download Yarn"", e);
        } catch (ArchiveExtractionException | IOException e) {
            throw new InstallationException(""Could not extract the Yarn archive"", e);
        }
    }

    private File getInstallDirectory() {
        File installDirectory = new File(config.getInstallDirectory(), INSTALL_PATH);
        if (!installDirectory.exists()) {
            logger.debug(""Creating install directory {}"", installDirectory);
            installDirectory.mkdirs();
        }
        return installDirectory;
    }

    private void extractFile(File archive, File destinationDirectory) throws ArchiveExtractionException {
        logger.info(""Unpacking {} into {}"", archive, destinationDirectory);
        archiveExtractor.extract(archive.getPath(), destinationDirectory.getPath());
    }

    private void ensureCorrectYarnRootDirectory(File installDirectory, String yarnVersion) throws IOException {
        File yarnRootDirectory = new File(installDirectory, YARN_ROOT_DIRECTORY);
        if (!yarnRootDirectory.exists()) {
            logger.debug(""Yarn root directory not found, checking for yarn-{}"", yarnVersion);
            // Handle renaming Yarn 1.X root to YARN_ROOT_DIRECTORY
            File yarnOneXDirectory = new File(installDirectory, ""yarn-"" + yarnVersion);
            if (yarnOneXDirectory.isDirectory()) {
                if (!yarnOneXDirectory.renameTo(yarnRootDirectory)) {
                    throw new IOException(""Could not rename versioned yarn root directory to "" + YARN_ROOT_DIRECTORY);
                }
            } else {
                throw new FileNotFoundException(""Could not find yarn distribution directory during extract"");
            }
        }
    }

    private void downloadFileIfMissing(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException {
        if (!destination.exists()) {
            downloadFile(downloadUrl, destination, userName, password, httpHeaders);
        }
    }

    private void downloadFile(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException {
        logger.info(""Downloading {} to {}"", downloadUrl, destination);
        fileDownloader.download(downloadUrl, destination.getPath(), userName, password, httpHeaders);
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public class YarnInstaller { public static final String INSTALL_PATH = ""/node/yarn""; private static final Object LOCK = new Object(); private static final String YARN_ROOT_DIRECTORY = ""dist""; private String yarnVersion, yarnDownloadRoot, userName, password; private Map<String, String> httpHeaders; private boolean isYarnBerry; private final Logger logger; private final InstallConfig config; private final ArchiveExtractor archiveExtractor; private final FileDownloader fileDownloader; YarnInstaller(InstallConfig config, ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) { logger = LoggerFactory.getLogger(getClass()); this.config = config; this.archiveExtractor = archiveExtractor; this.fileDownloader = fileDownloader; } public YarnInstaller setYarnVersion(String yarnVersion) { this.yarnVersion = yarnVersion; return this; } public YarnInstaller setIsYarnBerry(boolean isYarnBerry) { this.isYarnBerry = isYarnBerry; return this; } public YarnInstaller setYarnDownloadRoot(String yarnDownloadRoot) { this.yarnDownloadRoot = yarnDownloadRoot; return this; } public YarnInstaller setUserName(String userName) { this.userName = userName; return this; } public YarnInstaller setPassword(String password) { this.password = password; return this; } public YarnInstaller setHttpHeaders(Map<String, String> httpHeaders) { this.httpHeaders = httpHeaders; return this; } public void install() throws InstallationException { synchronized (LOCK) { if (yarnDownloadRoot == null || yarnDownloadRoot.isEmpty()) { yarnDownloadRoot = DEFAULT_YARN_DOWNLOAD_ROOT; } if (!yarnIsAlreadyInstalled()) { if (!yarnVersion.startsWith(""v"")) { throw new InstallationException(""Yarn version has to start with prefix 'v'.""); } installYarn(); } } } private boolean yarnIsAlreadyInstalled() { try { YarnExecutorConfig executorConfig = new InstallYarnExecutorConfig(config, isYarnBerry); File nodeFile = executorConfig.getYarnPath(); if (nodeFile.exists()) { final String version =
                    new YarnExecutor(executorConfig, Arrays.asList(""--version""), null).executeAndGetResult(logger).trim(); if (version.equals(yarnVersion.replaceFirst(""^v"", """"))) { logger.info(""Yarn { } is already installed."", version); return true; } else { if (isYarnBerry && Integer.parseInt(version.split(""\\."")[0]) > 1) { logger.info(""Yarn Berry { } is installed."", version); return true; } else{ logger.info(""Yarn { } was installed, but we need version { } "", version, yarnVersion); return false; } } } else { return false; } } catch (ProcessExecutionException e) { return false; } } private void installYarn() throws InstallationException { try { logger.info(""Installing Yarn version { } "", yarnVersion); String downloadUrl = yarnDownloadRoot + yarnVersion; String extension = ""tar.gz""; String fileending = ""/yarn-"" + yarnVersion + ""."" + extension; downloadUrl += fileending; CacheDescriptor cacheDescriptor = new CacheDescriptor(""yarn"", yarnVersion, extension); File archive = config.getCacheResolver().resolve(cacheDescriptor); downloadFileIfMissing(downloadUrl, archive, userName, password, httpHeaders); File installDirectory = getInstallDirectory(); try { if (installDirectory.isDirectory()) { FileUtils.deleteDirectory(installDirectory); } } catch (IOException e) { } try { extractFile(archive, installDirectory); } catch (ArchiveExtractionException e) { if (e.getCause() instanceof EOFException) { this.logger.error(""The archive file { } is corrupted and will be deleted. ""
                            + ""Please try the build again."", archive.getPath()); archive.delete(); if (installDirectory.exists()) { FileUtils.deleteDirectory(installDirectory); } } throw e; } ensureCorrectYarnRootDirectory(installDirectory, yarnVersion); } catch (DownloadException e) { throw new InstallationException(""Could not download Yarn"", e); } catch (ArchiveExtractionException | IOException e) { throw new InstallationException(""Could not extract the Yarn archive"", e); } } private File getInstallDirectory() { File installDirectory = new File(config.getInstallDirectory(), INSTALL_PATH); if (!installDirectory.exists()) { logger.debug(""Creating install directory { } "", installDirectory); installDirectory.mkdirs(); } return installDirectory; } private void extractFile(File archive, File destinationDirectory) throws ArchiveExtractionException { logger.info(""Unpacking { } into { } "", archive, destinationDirectory); archiveExtractor.extract(archive.getPath(), destinationDirectory.getPath()); } private void ensureCorrectYarnRootDirectory(File installDirectory, String yarnVersion) throws IOException { File yarnRootDirectory = new File(installDirectory, YARN_ROOT_DIRECTORY); if (!yarnRootDirectory.exists()) { logger.debug(""Yarn root directory not found, checking for yarn-{ } "", yarnVersion); File yarnOneXDirectory = new File(installDirectory, ""yarn-"" + yarnVersion); if (yarnOneXDirectory.isDirectory()) { if (!yarnOneXDirectory.renameTo(yarnRootDirectory)) { throw new IOException(""Could not rename versioned yarn root directory to "" + YARN_ROOT_DIRECTORY); } } else { throw new FileNotFoundException(""Could not find yarn distribution directory during extract""); } } } private void downloadFileIfMissing(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException { if (!destination.exists()) { downloadFile(downloadUrl, destination, userName, password, httpHeaders); } } private void downloadFile(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException { logger.info(""Downloading { } to { } "", downloadUrl, destination); fileDownloader.download(downloadUrl, destination.getPath(), userName, password, httpHeaders); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public class YarnInstaller { public static final String INSTALL_PATH = ""/node/yarn""; private static final Object LOCK = new Object(); private static final String YARN_ROOT_DIRECTORY = ""dist""; private String yarnVersion, yarnDownloadRoot, userName, password; private Map<String, String> httpHeaders; private boolean isYarnBerry; private final Logger logger; private final InstallConfig config; private final ArchiveExtractor archiveExtractor; private final FileDownloader fileDownloader; YarnInstaller(InstallConfig config, ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) { logger = LoggerFactory.getLogger(getClass()); this.config = config; this.archiveExtractor = archiveExtractor; this.fileDownloader = fileDownloader; } public YarnInstaller setYarnVersion(String yarnVersion) { this.yarnVersion = yarnVersion; return this; } public YarnInstaller setIsYarnBerry(boolean isYarnBerry) { this.isYarnBerry = isYarnBerry; return this; } public YarnInstaller setYarnDownloadRoot(String yarnDownloadRoot) { this.yarnDownloadRoot = yarnDownloadRoot; return this; } public YarnInstaller setUserName(String userName) { this.userName = userName; return this; } public YarnInstaller setPassword(String password) { this.password = password; return this; } public YarnInstaller setHttpHeaders(Map<String, String> httpHeaders) { this.httpHeaders = httpHeaders; return this; } public void install() throws InstallationException { synchronized (LOCK) { if (yarnDownloadRoot == null || yarnDownloadRoot.isEmpty()) { yarnDownloadRoot = DEFAULT_YARN_DOWNLOAD_ROOT; } if (!yarnIsAlreadyInstalled()) { if (!yarnVersion.startsWith(""v"")) { throw new InstallationException(""Yarn version has to start with prefix 'v'.""); } installYarn(); } } } private boolean yarnIsAlreadyInstalled() { try { YarnExecutorConfig executorConfig = new InstallYarnExecutorConfig(config, isYarnBerry); File nodeFile = executorConfig.getYarnPath(); if (nodeFile.exists()) { final String version =
                    new YarnExecutor(executorConfig, Arrays.asList(""--version""), null).executeAndGetResult(logger).trim(); if (version.equals(yarnVersion.replaceFirst(""^v"", """"))) { logger.info(""Yarn { } is already installed."", version); return true; } else { if (isYarnBerry && Integer.parseInt(version.split(""\\."")[0]) > 1) { logger.info(""Yarn Berry { } is installed."", version); return true; } else{ logger.info(""Yarn { } was installed, but we need version { } "", version, yarnVersion); return false; } } } else { return false; } } catch (ProcessExecutionException e) { return false; } } private void installYarn() throws InstallationException { try { logger.info(""Installing Yarn version { } "", yarnVersion); String downloadUrl = yarnDownloadRoot + yarnVersion; String extension = ""tar.gz""; String fileending = ""/yarn-"" + yarnVersion + ""."" + extension; downloadUrl += fileending; CacheDescriptor cacheDescriptor = new CacheDescriptor(""yarn"", yarnVersion, extension); File archive = config.getCacheResolver().resolve(cacheDescriptor); downloadFileIfMissing(downloadUrl, archive, userName, password, httpHeaders); File installDirectory = getInstallDirectory(); try { if (installDirectory.isDirectory()) { FileUtils.deleteDirectory(installDirectory); } } catch (IOException e) { <FILL_ME> } try { extractFile(archive, installDirectory); } catch (ArchiveExtractionException e) { if (e.getCause() instanceof EOFException) { this.logger.error(""The archive file { } is corrupted and will be deleted. ""
                            + ""Please try the build again."", archive.getPath()); archive.delete(); if (installDirectory.exists()) { FileUtils.deleteDirectory(installDirectory); } } throw e; } ensureCorrectYarnRootDirectory(installDirectory, yarnVersion); <FILL_ME> } catch (DownloadException e) { throw new InstallationException(""Could not download Yarn"", e); } catch (ArchiveExtractionException | IOException e) { throw new InstallationException(""Could not extract the Yarn archive"", e); } } private File getInstallDirectory() { File installDirectory = new File(config.getInstallDirectory(), INSTALL_PATH); if (!installDirectory.exists()) { logger.debug(""Creating install directory { } "", installDirectory); installDirectory.mkdirs(); } return installDirectory; } private void extractFile(File archive, File destinationDirectory) throws ArchiveExtractionException { logger.info(""Unpacking { } into { } "", archive, destinationDirectory); archiveExtractor.extract(archive.getPath(), destinationDirectory.getPath()); } private void ensureCorrectYarnRootDirectory(File installDirectory, String yarnVersion) throws IOException { File yarnRootDirectory = new File(installDirectory, YARN_ROOT_DIRECTORY); if (!yarnRootDirectory.exists()) { logger.debug(""Yarn root directory not found, checking for yarn-{ } "", yarnVersion); File yarnOneXDirectory = new File(installDirectory, ""yarn-"" + yarnVersion); if (yarnOneXDirectory.isDirectory()) { if (!yarnOneXDirectory.renameTo(yarnRootDirectory)) { throw new IOException(""Could not rename versioned yarn root directory to "" + YARN_ROOT_DIRECTORY); } } else { throw new FileNotFoundException(""Could not find yarn distribution directory during extract""); } } } private void downloadFileIfMissing(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException { if (!destination.exists()) { downloadFile(downloadUrl, destination, userName, password, httpHeaders); } } private void downloadFile(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException { logger.info(""Downloading { } to { } "", downloadUrl, destination); fileDownloader.download(downloadUrl, destination.getPath(), userName, password, httpHeaders); } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import java.io.EOFException; import java.io.File; import java.io.FileNotFoundException; import java.io.IOException; import java.util.Arrays; import java.util.Map; 
import org.apache.commons.io.FileUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class YarnInstaller {  public static final String INSTALL_PATH = ""/node/yarn"";  //github.com/yarnpkg/yarn/releases/download/"";  private static final Object LOCK = new Object();  private static final String YARN_ROOT_DIRECTORY = ""dist"";  private String yarnVersion, yarnDownloadRoot, userName, password;      private Map<String, String> httpHeaders;  private boolean isYarnBerry;  private final Logger logger;  private final InstallConfig config;  private final ArchiveExtractor archiveExtractor;  private final FileDownloader fileDownloader;  YarnInstaller(InstallConfig config, ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) { logger = LoggerFactory.getLogger(getClass()); this.config = config; this.archiveExtractor = archiveExtractor; this.fileDownloader = fileDownloader; }  public YarnInstaller setYarnVersion(String yarnVersion) { this.yarnVersion = yarnVersion; return this; }  public YarnInstaller setIsYarnBerry(boolean isYarnBerry) { this.isYarnBerry = isYarnBerry; return this; }  public YarnInstaller setYarnDownloadRoot(String yarnDownloadRoot) { this.yarnDownloadRoot = yarnDownloadRoot; return this; }  public YarnInstaller setUserName(String userName) { this.userName = userName; return this; }  public YarnInstaller setPassword(String password) { this.password = password; return this; }  public YarnInstaller setHttpHeaders(Map<String, String> httpHeaders) { this.httpHeaders = httpHeaders; return this; }  public void install() throws InstallationException { // use static lock object for a synchronized block synchronized (LOCK) { if (yarnDownloadRoot == null || yarnDownloadRoot.isEmpty()) { yarnDownloadRoot = DEFAULT_YARN_DOWNLOAD_ROOT; } if (!yarnIsAlreadyInstalled()) { if (!yarnVersion.startsWith(""v"")) { throw new InstallationException(""Yarn version has to start with prefix 'v'.""); } installYarn(); } } }  private boolean yarnIsAlreadyInstalled() { try { YarnExecutorConfig executorConfig = new InstallYarnExecutorConfig(config, isYarnBerry); File nodeFile = executorConfig.getYarnPath(); if (nodeFile.exists()) { final String version =
                    new YarnExecutor(executorConfig, Arrays.asList(""--version""), null).executeAndGetResult(logger).trim();  if (version.equals(yarnVersion.replaceFirst(""^v"", """"))) { logger.info(""Yarn { } is already installed."", version); return true; } else { if (isYarnBerry && Integer.parseInt(version.split(""\\."")[0]) > 1) { logger.info(""Yarn Berry { } is installed."", version); return true; } else{ logger.info(""Yarn { } was installed, but we need version { } "", version, yarnVersion); return false; } } } else { return false; } } catch (ProcessExecutionException e) { return false; } }  private void installYarn() throws InstallationException { try { logger.info(""Installing Yarn version { } "", yarnVersion); String downloadUrl = yarnDownloadRoot + yarnVersion; String extension = ""tar.gz""; String fileending = ""/yarn-"" + yarnVersion + ""."" + extension;  downloadUrl += fileending;  CacheDescriptor cacheDescriptor = new CacheDescriptor(""yarn"", yarnVersion, extension);  File archive = config.getCacheResolver().resolve(cacheDescriptor);  downloadFileIfMissing(downloadUrl, archive, userName, password, httpHeaders);  File installDirectory = getInstallDirectory();  // We need to delete the existing yarn directory first so we clean out any old files, and // so we can rename the package directory below. try { if (installDirectory.isDirectory()) { FileUtils.deleteDirectory(installDirectory); } } catch (IOException e) { <FILL_ME> }  try { extractFile(archive, installDirectory); } catch (ArchiveExtractionException e) { if (e.getCause() instanceof EOFException) { // https://github.com/eirslett/frontend-maven-plugin/issues/794 // The downloading was probably interrupted and archive file is incomplete: // delete it to retry from scratch this.logger.error(""The archive file { } is corrupted and will be deleted. ""
                            + ""Please try the build again."", archive.getPath()); archive.delete(); if (installDirectory.exists()) { FileUtils.deleteDirectory(installDirectory); } }  throw e; }  ensureCorrectYarnRootDirectory(installDirectory, yarnVersion); <FILL_ME>  } catch (DownloadException e) { throw new InstallationException(""Could not download Yarn"", e); } catch (ArchiveExtractionException | IOException e) { throw new InstallationException(""Could not extract the Yarn archive"", e); } }  private File getInstallDirectory() { File installDirectory = new File(config.getInstallDirectory(), INSTALL_PATH); if (!installDirectory.exists()) { logger.debug(""Creating install directory { } "", installDirectory); installDirectory.mkdirs(); } return installDirectory; }  private void extractFile(File archive, File destinationDirectory) throws ArchiveExtractionException { logger.info(""Unpacking { } into { } "", archive, destinationDirectory); archiveExtractor.extract(archive.getPath(), destinationDirectory.getPath()); }  private void ensureCorrectYarnRootDirectory(File installDirectory, String yarnVersion) throws IOException { File yarnRootDirectory = new File(installDirectory, YARN_ROOT_DIRECTORY); if (!yarnRootDirectory.exists()) { logger.debug(""Yarn root directory not found, checking for yarn-{ } "", yarnVersion); // Handle renaming Yarn 1.X root to YARN_ROOT_DIRECTORY File yarnOneXDirectory = new File(installDirectory, ""yarn-"" + yarnVersion); if (yarnOneXDirectory.isDirectory()) { if (!yarnOneXDirectory.renameTo(yarnRootDirectory)) { throw new IOException(""Could not rename versioned yarn root directory to "" + YARN_ROOT_DIRECTORY); } } else { throw new FileNotFoundException(""Could not find yarn distribution directory during extract""); } } }  private void downloadFileIfMissing(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException { if (!destination.exists()) { downloadFile(downloadUrl, destination, userName, password, httpHeaders); } }  private void downloadFile(String downloadUrl, File destination, String userName, String password, Map<String, String> httpHeaders)
        throws DownloadException { logger.info(""Downloading { } to { } "", downloadUrl, destination); fileDownloader.download(downloadUrl, destination.getPath(), userName, password, httpHeaders); } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/YarnRunner.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import java.util.ArrayList;
import java.util.List;

import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig.Proxy;

public interface YarnRunner extends NodeTaskRunner {
}

final class DefaultYarnRunner extends YarnTaskExecutor implements YarnRunner {

    private static final String TASK_NAME = ""yarn"";

    public DefaultYarnRunner(YarnExecutorConfig config, ProxyConfig proxyConfig, String npmRegistryURL) {
        super(config, TASK_NAME, config.getYarnPath().getAbsolutePath(),
            buildArguments(config, proxyConfig, npmRegistryURL));
    }

    private static List<String> buildArguments(final YarnExecutorConfig config, ProxyConfig proxyConfig,
            String npmRegistryURL) {
        List<String> arguments = new ArrayList<>();

        if (config.isYarnBerry()) {
            // Yarn berry does not support the additional arguments we try to set below.
            // Setting those results in failures during yarn execution.
            return arguments;
        }

        if (npmRegistryURL != null && !npmRegistryURL.isEmpty()) {
            arguments.add(""--registry="" + npmRegistryURL);
        }

        if (!proxyConfig.isEmpty()) {
            Proxy proxy = null;
            if (npmRegistryURL != null && !npmRegistryURL.isEmpty()) {
                proxy = proxyConfig.getProxyForUrl(npmRegistryURL);
            }

            if (proxy == null) {
                proxy = proxyConfig.getSecureProxy();
            }

            if (proxy == null) {
                proxy = proxyConfig.getInsecureProxy();
            }

            arguments.add(""--https-proxy="" + proxy.getUri().toString());
            arguments.add(""--proxy="" + proxy.getUri().toString());
        }

        return arguments;
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public interface YarnRunner extends NodeTaskRunner { } final class DefaultYarnRunner extends YarnTaskExecutor implements YarnRunner { private static final String TASK_NAME = ""yarn""; public DefaultYarnRunner(YarnExecutorConfig config, ProxyConfig proxyConfig, String npmRegistryURL) { super(config, TASK_NAME, config.getYarnPath().getAbsolutePath(),
            buildArguments(config, proxyConfig, npmRegistryURL)); } private static List<String> buildArguments(final YarnExecutorConfig config, ProxyConfig proxyConfig,
            String npmRegistryURL) { List<String> arguments = new ArrayList<>(); if (config.isYarnBerry()) { return arguments; } if (npmRegistryURL != null && !npmRegistryURL.isEmpty()) { arguments.add(""--registry="" + npmRegistryURL); } if (!proxyConfig.isEmpty()) { Proxy proxy = null; if (npmRegistryURL != null && !npmRegistryURL.isEmpty()) { proxy = proxyConfig.getProxyForUrl(npmRegistryURL); } if (proxy == null) { proxy = proxyConfig.getSecureProxy(); } if (proxy == null) { proxy = proxyConfig.getInsecureProxy(); } arguments.add(""--https-proxy="" + proxy.getUri().toString()); arguments.add(""--proxy="" + proxy.getUri().toString()); } return arguments; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public interface YarnRunner extends NodeTaskRunner { } final class DefaultYarnRunner extends YarnTaskExecutor implements YarnRunner { private static final String TASK_NAME = ""yarn""; public DefaultYarnRunner(YarnExecutorConfig config, ProxyConfig proxyConfig, String npmRegistryURL) { super(config, TASK_NAME, config.getYarnPath().getAbsolutePath(),
            buildArguments(config, proxyConfig, npmRegistryURL)); } private static List<String> buildArguments(final YarnExecutorConfig config, ProxyConfig proxyConfig,
            String npmRegistryURL) { List<String> arguments = new ArrayList<>(); if (config.isYarnBerry()) { return arguments; } if (npmRegistryURL != null && !npmRegistryURL.isEmpty()) { arguments.add(""--registry="" + npmRegistryURL); } if (!proxyConfig.isEmpty()) { Proxy proxy = null; if (npmRegistryURL != null && !npmRegistryURL.isEmpty()) { proxy = proxyConfig.getProxyForUrl(npmRegistryURL); } if (proxy == null) { proxy = proxyConfig.getSecureProxy(); } if (proxy == null) { proxy = proxyConfig.getInsecureProxy(); } arguments.add(""--https-proxy="" + proxy.getUri().toString()); arguments.add(""--proxy="" + proxy.getUri().toString()); } return arguments; } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import java.util.ArrayList; import java.util.List; 
import com.github.eirslett.maven.plugins.frontend.lib.ProxyConfig.Proxy;  public interface YarnRunner extends NodeTaskRunner { }  final class DefaultYarnRunner extends YarnTaskExecutor implements YarnRunner {  private static final String TASK_NAME = ""yarn"";  public DefaultYarnRunner(YarnExecutorConfig config, ProxyConfig proxyConfig, String npmRegistryURL) { super(config, TASK_NAME, config.getYarnPath().getAbsolutePath(),
            buildArguments(config, proxyConfig, npmRegistryURL)); }  private static List<String> buildArguments(final YarnExecutorConfig config, ProxyConfig proxyConfig,
            String npmRegistryURL) { List<String> arguments = new ArrayList<>();  if (config.isYarnBerry()) { // Yarn berry does not support the additional arguments we try to set below. // Setting those results in failures during yarn execution. return arguments; }  if (npmRegistryURL != null && !npmRegistryURL.isEmpty()) { arguments.add(""--registry="" + npmRegistryURL); }  if (!proxyConfig.isEmpty()) { Proxy proxy = null; if (npmRegistryURL != null && !npmRegistryURL.isEmpty()) { proxy = proxyConfig.getProxyForUrl(npmRegistryURL); }  if (proxy == null) { proxy = proxyConfig.getSecureProxy(); }  if (proxy == null) { proxy = proxyConfig.getInsecureProxy(); }  arguments.add(""--https-proxy="" + proxy.getUri().toString()); arguments.add(""--proxy="" + proxy.getUri().toString()); }  return arguments; } }  "
frontend-plugin-core/src/main/java/com/github/eirslett/maven/plugins/frontend/lib/YarnTaskExecutor.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import static com.github.eirslett.maven.plugins.frontend.lib.Utils.implode;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

abstract class YarnTaskExecutor {
    private static final String DS = ""//"";

    private static final String AT = ""@"";

    private final Logger logger;

    private final String taskName;

    private final ArgumentsParser argumentsParser;

    private final YarnExecutorConfig config;

    public YarnTaskExecutor(YarnExecutorConfig config, String taskLocation) {
        this(config, taskLocation, Collections.<String> emptyList());
    }

    public YarnTaskExecutor(YarnExecutorConfig config, String taskName, String taskLocation) {
        this(config, taskName, taskLocation, Collections.<String> emptyList());
    }

    public YarnTaskExecutor(YarnExecutorConfig config, String taskLocation,
        List<String> additionalArguments) {
        this(config, getTaskNameFromLocation(taskLocation), taskLocation, additionalArguments);
    }

    public YarnTaskExecutor(YarnExecutorConfig config, String taskName, String taskLocation,
        List<String> additionalArguments) {
        logger = LoggerFactory.getLogger(getClass());
        this.config = config;
        this.taskName = taskName;
        this.argumentsParser = new ArgumentsParser(additionalArguments);
    }

    private static String getTaskNameFromLocation(String taskLocation) {
        return taskLocation.replaceAll(""^.*/([^/]+)(?:\\.js)?$"", ""$1"");
    }

    public final void execute(String args, Map<String, String> environment) throws TaskRunnerException {
        final List<String> arguments = getArguments(args);
        logger.info(""Running "" + taskToString(taskName, arguments) + "" in "" + config.getWorkingDirectory());

        try {
            final int result =
                new YarnExecutor(config, arguments, environment).executeAndRedirectOutput(logger);
            if (result != 0) {
                throw new TaskRunnerException(
                    taskToString(taskName, arguments) + "" failed. (error code "" + result + "")"");
            }
        } catch (ProcessExecutionException e) {
            throw new TaskRunnerException(taskToString(taskName, arguments) + "" failed."", e);
        }
    }

    private List<String> getArguments(String args) {
        return argumentsParser.parse(args);
    }

    private static String taskToString(String taskName, List<String> arguments) {
        List<String> clonedArguments = new ArrayList<>(arguments);
        for (int i = 0; i < clonedArguments.size(); i++) {
            final String s = clonedArguments.get(i);
            final boolean maskMavenProxyPassword = s.contains(""proxy="");
            if (maskMavenProxyPassword) {
                final String bestEffortMaskedPassword = maskPassword(s);
                clonedArguments.set(i, bestEffortMaskedPassword);
            }
        }
        return ""'"" + taskName + "" "" + implode("" "", clonedArguments) + ""'"";
    }

    private static String maskPassword(String proxyString) {
        String retVal = proxyString;
        if (proxyString != null && !"""".equals(proxyString.trim())) {
            boolean hasSchemeDefined = proxyString.contains(""http:"") || proxyString.contains(""https:"");
            boolean hasProtocolDefined = proxyString.contains(DS);
            boolean hasAtCharacterDefined = proxyString.contains(AT);
            if (hasSchemeDefined && hasProtocolDefined && hasAtCharacterDefined) {
                final int firstDoubleSlashIndex = proxyString.indexOf(DS);
                final int lastAtCharIndex = proxyString.lastIndexOf(AT);
                boolean hasPossibleURIUserInfo = firstDoubleSlashIndex < lastAtCharIndex;
                if (hasPossibleURIUserInfo) {
                    final String userInfo =
                        proxyString.substring(firstDoubleSlashIndex + DS.length(), lastAtCharIndex);
                    final String[] userParts = userInfo.split("":"");
                    if (userParts.length > 0) {
                        final int startOfUserNameIndex = firstDoubleSlashIndex + DS.length();
                        final int firstColonInUsernameOrEndOfUserNameIndex =
                            startOfUserNameIndex + userParts[0].length();
                        final String leftPart =
                            proxyString.substring(0, firstColonInUsernameOrEndOfUserNameIndex);
                        final String rightPart = proxyString.substring(lastAtCharIndex);
                        retVal = leftPart + "":***"" + rightPart;
                    }
                }
            }
        }
        return retVal;
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; abstract class YarnTaskExecutor { private static final String AT = ""@""; private final Logger logger; private final String taskName; private final ArgumentsParser argumentsParser; private final YarnExecutorConfig config; public YarnTaskExecutor(YarnExecutorConfig config, String taskLocation) { this(config, taskLocation, Collections.<String> emptyList()); } public YarnTaskExecutor(YarnExecutorConfig config, String taskName, String taskLocation) { this(config, taskName, taskLocation, Collections.<String> emptyList()); } public YarnTaskExecutor(YarnExecutorConfig config, String taskLocation,
        List<String> additionalArguments) { this(config, getTaskNameFromLocation(taskLocation), taskLocation, additionalArguments); } public YarnTaskExecutor(YarnExecutorConfig config, String taskName, String taskLocation,
        List<String> additionalArguments) { logger = LoggerFactory.getLogger(getClass()); this.config = config; this.taskName = taskName; this.argumentsParser = new ArgumentsParser(additionalArguments); } private static String getTaskNameFromLocation(String taskLocation) { return taskLocation.replaceAll(""^.*/([^/]+)(?:\\.js)?$"", ""$1""); } public final void execute(String args, Map<String, String> environment) throws TaskRunnerException { final List<String> arguments = getArguments(args); try { final int result =
                new YarnExecutor(config, arguments, environment).executeAndRedirectOutput(logger); if (result != 0) { throw new TaskRunnerException(
                    taskToString(taskName, arguments) + "" failed. (error code "" + result + "")""); } } catch (ProcessExecutionException e) { throw new TaskRunnerException(taskToString(taskName, arguments) + "" failed."", e); } } private List<String> getArguments(String args) { return argumentsParser.parse(args); } private static String taskToString(String taskName, List<String> arguments) { List<String> clonedArguments = new ArrayList<>(arguments); for (int i = 0; i < clonedArguments.size(); i++) { final String s = clonedArguments.get(i); final boolean maskMavenProxyPassword = s.contains(""proxy=""); if (maskMavenProxyPassword) { final String bestEffortMaskedPassword = maskPassword(s); clonedArguments.set(i, bestEffortMaskedPassword); } } return ""'"" + taskName + "" "" + implode("" "", clonedArguments) + ""'""; } private static String maskPassword(String proxyString) { String retVal = proxyString; if (proxyString != null && !"""".equals(proxyString.trim())) { boolean hasSchemeDefined = proxyString.contains(""http:"") || proxyString.contains(""https:""); boolean hasProtocolDefined = proxyString.contains(DS); boolean hasAtCharacterDefined = proxyString.contains(AT); if (hasSchemeDefined && hasProtocolDefined && hasAtCharacterDefined) { final int firstDoubleSlashIndex = proxyString.indexOf(DS); final int lastAtCharIndex = proxyString.lastIndexOf(AT); boolean hasPossibleURIUserInfo = firstDoubleSlashIndex < lastAtCharIndex; if (hasPossibleURIUserInfo) { final String userInfo =
                        proxyString.substring(firstDoubleSlashIndex + DS.length(), lastAtCharIndex); final String[] userParts = userInfo.split("":""); if (userParts.length > 0) { final int startOfUserNameIndex = firstDoubleSlashIndex + DS.length(); final int firstColonInUsernameOrEndOfUserNameIndex =
                            startOfUserNameIndex + userParts[0].length(); final String leftPart =
                            proxyString.substring(0, firstColonInUsernameOrEndOfUserNameIndex); final String rightPart = proxyString.substring(lastAtCharIndex); retVal = leftPart + "":***"" + rightPart; } } } } return retVal; } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; abstract class YarnTaskExecutor { private static final String AT = ""@""; private final Logger logger; private final String taskName; private final ArgumentsParser argumentsParser; private final YarnExecutorConfig config; public YarnTaskExecutor(YarnExecutorConfig config, String taskLocation) { this(config, taskLocation, Collections.<String> emptyList()); } public YarnTaskExecutor(YarnExecutorConfig config, String taskName, String taskLocation) { this(config, taskName, taskLocation, Collections.<String> emptyList()); } public YarnTaskExecutor(YarnExecutorConfig config, String taskLocation,
        List<String> additionalArguments) { this(config, getTaskNameFromLocation(taskLocation), taskLocation, additionalArguments); } public YarnTaskExecutor(YarnExecutorConfig config, String taskName, String taskLocation,
        List<String> additionalArguments) { logger = LoggerFactory.getLogger(getClass()); this.config = config; this.taskName = taskName; this.argumentsParser = new ArgumentsParser(additionalArguments); } private static String getTaskNameFromLocation(String taskLocation) { return taskLocation.replaceAll(""^.*/([^/]+)(?:\\.js)?$"", ""$1""); } public final void execute(String args, Map<String, String> environment) throws TaskRunnerException { final List<String> arguments = getArguments(args); <FILL_ME> try { final int result =
                new YarnExecutor(config, arguments, environment).executeAndRedirectOutput(logger); if (result != 0) { throw new TaskRunnerException(
                    taskToString(taskName, arguments) + "" failed. (error code "" + result + "")""); } } catch (ProcessExecutionException e) { throw new TaskRunnerException(taskToString(taskName, arguments) + "" failed."", e); } } private List<String> getArguments(String args) { return argumentsParser.parse(args); } private static String taskToString(String taskName, List<String> arguments) { List<String> clonedArguments = new ArrayList<>(arguments); for (int i = 0; i < clonedArguments.size(); i++) { final String s = clonedArguments.get(i); final boolean maskMavenProxyPassword = s.contains(""proxy=""); if (maskMavenProxyPassword) { final String bestEffortMaskedPassword = maskPassword(s); clonedArguments.set(i, bestEffortMaskedPassword); } } return ""'"" + taskName + "" "" + implode("" "", clonedArguments) + ""'""; } private static String maskPassword(String proxyString) { String retVal = proxyString; if (proxyString != null && !"""".equals(proxyString.trim())) { boolean hasSchemeDefined = proxyString.contains(""http:"") || proxyString.contains(""https:""); boolean hasProtocolDefined = proxyString.contains(DS); boolean hasAtCharacterDefined = proxyString.contains(AT); if (hasSchemeDefined && hasProtocolDefined && hasAtCharacterDefined) { final int firstDoubleSlashIndex = proxyString.indexOf(DS); final int lastAtCharIndex = proxyString.lastIndexOf(AT); boolean hasPossibleURIUserInfo = firstDoubleSlashIndex < lastAtCharIndex; if (hasPossibleURIUserInfo) { final String userInfo =
                        proxyString.substring(firstDoubleSlashIndex + DS.length(), lastAtCharIndex); final String[] userParts = userInfo.split("":""); if (userParts.length > 0) { final int startOfUserNameIndex = firstDoubleSlashIndex + DS.length(); final int firstColonInUsernameOrEndOfUserNameIndex =
                            startOfUserNameIndex + userParts[0].length(); final String leftPart =
                            proxyString.substring(0, firstColonInUsernameOrEndOfUserNameIndex); final String rightPart = proxyString.substring(lastAtCharIndex); retVal = leftPart + "":***"" + rightPart; } } } } return retVal; } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import static com.github.eirslett.maven.plugins.frontend.lib.Utils.implode; 
import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.List; import java.util.Map; 
import org.slf4j.Logger; import org.slf4j.LoggerFactory;  abstract class YarnTaskExecutor { //"";  private static final String AT = ""@"";  private final Logger logger;  private final String taskName;  private final ArgumentsParser argumentsParser;  private final YarnExecutorConfig config;  public YarnTaskExecutor(YarnExecutorConfig config, String taskLocation) { this(config, taskLocation, Collections.<String> emptyList()); }  public YarnTaskExecutor(YarnExecutorConfig config, String taskName, String taskLocation) { this(config, taskName, taskLocation, Collections.<String> emptyList()); }  public YarnTaskExecutor(YarnExecutorConfig config, String taskLocation,
        List<String> additionalArguments) { this(config, getTaskNameFromLocation(taskLocation), taskLocation, additionalArguments); }  public YarnTaskExecutor(YarnExecutorConfig config, String taskName, String taskLocation,
        List<String> additionalArguments) { logger = LoggerFactory.getLogger(getClass()); this.config = config; this.taskName = taskName; this.argumentsParser = new ArgumentsParser(additionalArguments); }  private static String getTaskNameFromLocation(String taskLocation) { return taskLocation.replaceAll(""^.*/([^/]+)(?:\\.js)?$"", ""$1""); }  public final void execute(String args, Map<String, String> environment) throws TaskRunnerException { final List<String> arguments = getArguments(args); <FILL_ME>  try { final int result =
                new YarnExecutor(config, arguments, environment).executeAndRedirectOutput(logger); if (result != 0) { throw new TaskRunnerException(
                    taskToString(taskName, arguments) + "" failed. (error code "" + result + "")""); } } catch (ProcessExecutionException e) { throw new TaskRunnerException(taskToString(taskName, arguments) + "" failed."", e); } }  private List<String> getArguments(String args) { return argumentsParser.parse(args); }  private static String taskToString(String taskName, List<String> arguments) { List<String> clonedArguments = new ArrayList<>(arguments); for (int i = 0; i < clonedArguments.size(); i++) { final String s = clonedArguments.get(i); final boolean maskMavenProxyPassword = s.contains(""proxy=""); if (maskMavenProxyPassword) { final String bestEffortMaskedPassword = maskPassword(s); clonedArguments.set(i, bestEffortMaskedPassword); } } return ""'"" + taskName + "" "" + implode("" "", clonedArguments) + ""'""; }  private static String maskPassword(String proxyString) { String retVal = proxyString; if (proxyString != null && !"""".equals(proxyString.trim())) { boolean hasSchemeDefined = proxyString.contains(""http:"") || proxyString.contains(""https:""); boolean hasProtocolDefined = proxyString.contains(DS); boolean hasAtCharacterDefined = proxyString.contains(AT); if (hasSchemeDefined && hasProtocolDefined && hasAtCharacterDefined) { final int firstDoubleSlashIndex = proxyString.indexOf(DS); final int lastAtCharIndex = proxyString.lastIndexOf(AT); boolean hasPossibleURIUserInfo = firstDoubleSlashIndex < lastAtCharIndex; if (hasPossibleURIUserInfo) { final String userInfo =
                        proxyString.substring(firstDoubleSlashIndex + DS.length(), lastAtCharIndex); final String[] userParts = userInfo.split("":""); if (userParts.length > 0) { final int startOfUserNameIndex = firstDoubleSlashIndex + DS.length(); final int firstColonInUsernameOrEndOfUserNameIndex =
                            startOfUserNameIndex + userParts[0].length(); final String leftPart =
                            proxyString.substring(0, firstColonInUsernameOrEndOfUserNameIndex); final String rightPart = proxyString.substring(lastAtCharIndex); retVal = leftPart + "":***"" + rightPart; } } } } return retVal; } }  "
frontend-plugin-core/src/test/java/com/github/eirslett/maven/plugins/frontend/lib/ArgumentsParserTest.java,"package com.github.eirslett.maven.plugins.frontend.lib;


import org.junit.jupiter.api.Test;

import java.util.Arrays;

import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import static org.junit.jupiter.api.Assertions.assertEquals;


public class ArgumentsParserTest {

    @Test
    public void testNoArguments() {
        ArgumentsParser parser = new ArgumentsParser();

        assertEquals(0, parser.parse(null).size());
        assertEquals(0, parser.parse(""null"").size());
        assertEquals(0, parser.parse(String.valueOf("""")).size());
    }

    @Test
    public void testMultipleArgumentsNoQuotes() {
        ArgumentsParser parser = new ArgumentsParser();

        assertArrayEquals(new Object[] { ""foo"" }, parser.parse(""foo"").toArray());
        assertArrayEquals(new Object[] { ""foo"", ""bar"" }, parser.parse(""foo bar"").toArray());
        assertArrayEquals(new Object[] { ""foo"", ""bar"", ""foobar"" }, parser.parse(""foo bar foobar"").toArray());
    }

    @Test
    public void testMultipleArgumentsWithQuotes() {
        ArgumentsParser parser = new ArgumentsParser();

        assertArrayEquals(new Object[] { ""foo"", ""\""bar foobar\"""" }, parser.parse(""foo \""bar foobar\"""").toArray());
        assertArrayEquals(new Object[] { ""\""foo bar\"""", ""foobar"" }, parser.parse(""\""foo bar\"" foobar"").toArray());
        assertArrayEquals(new Object[] { ""foo"", ""'bar foobar'"" }, parser.parse(""foo 'bar foobar'"").toArray());
        assertArrayEquals(new Object[] { ""'foo bar'"", ""foobar"" }, parser.parse(""'foo bar' foobar"").toArray());
        // unclosed quotes
        assertArrayEquals(new Object[] { ""foo"", ""\""bar foobar"" }, parser.parse(""foo \""bar foobar"").toArray());
    }

    @Test
    public void testArgumentsWithMixedQuotes() {
        ArgumentsParser parser = new ArgumentsParser();

        assertArrayEquals(new Object[] { ""foo"", ""\""bar 'foo bar'\"""" }, parser.parse(""foo \""bar 'foo bar'\"""").toArray());
        assertArrayEquals(new Object[] { ""foo"", ""\""bar 'foo\"""", ""'bar "" }, parser.parse(""foo \""bar 'foo\"" 'bar "").toArray());
    }

    @Test
    public void repeatedArgumentsAreAccepted() {
        ArgumentsParser parser = new ArgumentsParser();

        assertArrayEquals(new Object[] { ""echo"", ""echo"" }, parser.parse(""echo echo"").toArray());
    }

    @Test
    public void testAdditionalArgumentsNoIntersection() {
        ArgumentsParser parser = new ArgumentsParser(Arrays.asList(""foo"", ""bar""));

        assertArrayEquals(new Object[] { ""foobar"", ""foo"", ""bar"" }, parser.parse(""foobar"").toArray());
    }

    @Test
    public void testAdditionalArgumentsWithIntersection() {
        ArgumentsParser parser = new ArgumentsParser(Arrays.asList(""foo"", ""foobar""));

        assertArrayEquals(new Object[] { ""bar"", ""foobar"", ""foo"" }, parser.parse(""bar foobar"").toArray());
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public class ArgumentsParserTest { @Test
    public void testNoArguments() { ArgumentsParser parser = new ArgumentsParser(); assertEquals(0, parser.parse(null).size()); assertEquals(0, parser.parse(""null"").size()); assertEquals(0, parser.parse(String.valueOf("""")).size()); } @Test
    public void testMultipleArgumentsNoQuotes() { ArgumentsParser parser = new ArgumentsParser(); assertArrayEquals(new Object[] { ""foo"" } , parser.parse(""foo"").toArray()); assertArrayEquals(new Object[] { ""foo"", ""bar"" } , parser.parse(""foo bar"").toArray()); assertArrayEquals(new Object[] { ""foo"", ""bar"", ""foobar"" } , parser.parse(""foo bar foobar"").toArray()); } @Test
    public void testMultipleArgumentsWithQuotes() { ArgumentsParser parser = new ArgumentsParser(); assertArrayEquals(new Object[] { ""foo"", ""\""bar foobar\"""" } , parser.parse(""foo \""bar foobar\"""").toArray()); assertArrayEquals(new Object[] { ""\""foo bar\"""", ""foobar"" } , parser.parse(""\""foo bar\"" foobar"").toArray()); assertArrayEquals(new Object[] { ""foo"", ""'bar foobar'"" } , parser.parse(""foo 'bar foobar'"").toArray()); assertArrayEquals(new Object[] { ""'foo bar'"", ""foobar"" } , parser.parse(""'foo bar' foobar"").toArray()); assertArrayEquals(new Object[] { ""foo"", ""\""bar foobar"" } , parser.parse(""foo \""bar foobar"").toArray()); } @Test
    public void testArgumentsWithMixedQuotes() { ArgumentsParser parser = new ArgumentsParser(); assertArrayEquals(new Object[] { ""foo"", ""\""bar 'foo bar'\"""" } , parser.parse(""foo \""bar 'foo bar'\"""").toArray()); assertArrayEquals(new Object[] { ""foo"", ""\""bar 'foo\"""", ""'bar "" } , parser.parse(""foo \""bar 'foo\"" 'bar "").toArray()); } @Test
    public void repeatedArgumentsAreAccepted() { ArgumentsParser parser = new ArgumentsParser(); assertArrayEquals(new Object[] { ""echo"", ""echo"" } , parser.parse(""echo echo"").toArray()); } @Test
    public void testAdditionalArgumentsNoIntersection() { ArgumentsParser parser = new ArgumentsParser(Arrays.asList(""foo"", ""bar"")); assertArrayEquals(new Object[] { ""foobar"", ""foo"", ""bar"" } , parser.parse(""foobar"").toArray()); } @Test
    public void testAdditionalArgumentsWithIntersection() { ArgumentsParser parser = new ArgumentsParser(Arrays.asList(""foo"", ""foobar"")); assertArrayEquals(new Object[] { ""bar"", ""foobar"", ""foo"" } , parser.parse(""bar foobar"").toArray()); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public class ArgumentsParserTest { @Test
    public void testNoArguments() { ArgumentsParser parser = new ArgumentsParser(); assertEquals(0, parser.parse(null).size()); assertEquals(0, parser.parse(""null"").size()); assertEquals(0, parser.parse(String.valueOf("""")).size()); } @Test
    public void testMultipleArgumentsNoQuotes() { ArgumentsParser parser = new ArgumentsParser(); assertArrayEquals(new Object[] { ""foo"" } , parser.parse(""foo"").toArray()); assertArrayEquals(new Object[] { ""foo"", ""bar"" } , parser.parse(""foo bar"").toArray()); assertArrayEquals(new Object[] { ""foo"", ""bar"", ""foobar"" } , parser.parse(""foo bar foobar"").toArray()); } @Test
    public void testMultipleArgumentsWithQuotes() { ArgumentsParser parser = new ArgumentsParser(); assertArrayEquals(new Object[] { ""foo"", ""\""bar foobar\"""" } , parser.parse(""foo \""bar foobar\"""").toArray()); assertArrayEquals(new Object[] { ""\""foo bar\"""", ""foobar"" } , parser.parse(""\""foo bar\"" foobar"").toArray()); assertArrayEquals(new Object[] { ""foo"", ""'bar foobar'"" } , parser.parse(""foo 'bar foobar'"").toArray()); assertArrayEquals(new Object[] { ""'foo bar'"", ""foobar"" } , parser.parse(""'foo bar' foobar"").toArray()); assertArrayEquals(new Object[] { ""foo"", ""\""bar foobar"" } , parser.parse(""foo \""bar foobar"").toArray()); } @Test
    public void testArgumentsWithMixedQuotes() { ArgumentsParser parser = new ArgumentsParser(); assertArrayEquals(new Object[] { ""foo"", ""\""bar 'foo bar'\"""" } , parser.parse(""foo \""bar 'foo bar'\"""").toArray()); assertArrayEquals(new Object[] { ""foo"", ""\""bar 'foo\"""", ""'bar "" } , parser.parse(""foo \""bar 'foo\"" 'bar "").toArray()); } @Test
    public void repeatedArgumentsAreAccepted() { ArgumentsParser parser = new ArgumentsParser(); assertArrayEquals(new Object[] { ""echo"", ""echo"" } , parser.parse(""echo echo"").toArray()); } @Test
    public void testAdditionalArgumentsNoIntersection() { ArgumentsParser parser = new ArgumentsParser(Arrays.asList(""foo"", ""bar"")); assertArrayEquals(new Object[] { ""foobar"", ""foo"", ""bar"" } , parser.parse(""foobar"").toArray()); } @Test
    public void testAdditionalArgumentsWithIntersection() { ArgumentsParser parser = new ArgumentsParser(Arrays.asList(""foo"", ""foobar"")); assertArrayEquals(new Object[] { ""bar"", ""foobar"", ""foo"" } , parser.parse(""bar foobar"").toArray()); } } ","package com.github.eirslett.maven.plugins.frontend.lib; 

import org.junit.jupiter.api.Test; 
import java.util.Arrays; 
import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertEquals; 
 public class ArgumentsParserTest {  @Test
    public void testNoArguments() { ArgumentsParser parser = new ArgumentsParser();  assertEquals(0, parser.parse(null).size()); assertEquals(0, parser.parse(""null"").size()); assertEquals(0, parser.parse(String.valueOf("""")).size()); }  @Test
    public void testMultipleArgumentsNoQuotes() { ArgumentsParser parser = new ArgumentsParser();  assertArrayEquals(new Object[] { ""foo"" } , parser.parse(""foo"").toArray()); assertArrayEquals(new Object[] { ""foo"", ""bar"" } , parser.parse(""foo bar"").toArray()); assertArrayEquals(new Object[] { ""foo"", ""bar"", ""foobar"" } , parser.parse(""foo bar foobar"").toArray()); }  @Test
    public void testMultipleArgumentsWithQuotes() { ArgumentsParser parser = new ArgumentsParser();  assertArrayEquals(new Object[] { ""foo"", ""\""bar foobar\"""" } , parser.parse(""foo \""bar foobar\"""").toArray()); assertArrayEquals(new Object[] { ""\""foo bar\"""", ""foobar"" } , parser.parse(""\""foo bar\"" foobar"").toArray()); assertArrayEquals(new Object[] { ""foo"", ""'bar foobar'"" } , parser.parse(""foo 'bar foobar'"").toArray()); assertArrayEquals(new Object[] { ""'foo bar'"", ""foobar"" } , parser.parse(""'foo bar' foobar"").toArray());  assertArrayEquals(new Object[] { ""foo"", ""\""bar foobar"" } , parser.parse(""foo \""bar foobar"").toArray()); } // unclosed quotes @Test
    public void testArgumentsWithMixedQuotes() { ArgumentsParser parser = new ArgumentsParser();  assertArrayEquals(new Object[] { ""foo"", ""\""bar 'foo bar'\"""" } , parser.parse(""foo \""bar 'foo bar'\"""").toArray()); assertArrayEquals(new Object[] { ""foo"", ""\""bar 'foo\"""", ""'bar "" } , parser.parse(""foo \""bar 'foo\"" 'bar "").toArray()); }  @Test
    public void repeatedArgumentsAreAccepted() { ArgumentsParser parser = new ArgumentsParser();  assertArrayEquals(new Object[] { ""echo"", ""echo"" } , parser.parse(""echo echo"").toArray()); }  @Test
    public void testAdditionalArgumentsNoIntersection() { ArgumentsParser parser = new ArgumentsParser(Arrays.asList(""foo"", ""bar""));  assertArrayEquals(new Object[] { ""foobar"", ""foo"", ""bar"" } , parser.parse(""foobar"").toArray()); }  @Test
    public void testAdditionalArgumentsWithIntersection() { ArgumentsParser parser = new ArgumentsParser(Arrays.asList(""foo"", ""foobar""));  assertArrayEquals(new Object[] { ""bar"", ""foobar"", ""foo"" } , parser.parse(""bar foobar"").toArray()); } }  "
frontend-plugin-core/src/test/java/com/github/eirslett/maven/plugins/frontend/lib/DefaultArchiveExtractorTest.java,"package com.github.eirslett.maven.plugins.frontend.lib;


import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

import static org.junit.jupiter.api.Assumptions.assumeTrue;


public class DefaultArchiveExtractorTest {

    private final String BAD_TAR = ""src/test/resources/bad.tgz"";
    private final String BAD_ZIP = ""src/test/resources/bad.zip""; // sample zip with zip slip vulnerability
    private final String GOOD_TAR = ""src/test/resources/good.tgz"";
    private final String GOOD_ZIP = ""src/test/resources/good.zip"";

    @TempDir
    public File temp;

    private ArchiveExtractor extractor;

    @BeforeEach
    public void setup() {
        extractor = new DefaultArchiveExtractor();
    }

    @Test
    public void extractGoodTarFile() throws Exception {
        extractor.extract(GOOD_TAR, temp.getPath());
    }

    @Test
    public void extractGoodTarFileSymlink() throws Exception {
        File destination = new File(temp.getPath() + ""/destination"");
        destination.mkdir();
        Path link = createSymlinkOrSkipTest(temp.toPath().resolve(""link""), destination.toPath());
        extractor.extract(GOOD_TAR, link.toString());
    }

    @Test
    public void extractBadTarFile() {
        Assertions.assertThrows(ArchiveExtractionException.class, () ->
                extractor.extract(BAD_TAR, temp.getPath()));
    }

    @Test
    public void extractGoodZipFile() throws Exception {
        assertGoodZipExtractedTo(temp);
    }

    @Test
    public void extractGoodZipFileWithRelTarget() throws Exception {
        assertGoodZipExtractedTo(createRelPath(temp));
    }

    @Test
    public void extractBadZipFile() {
        assertBadZipThrowsException(temp);
    }

    @Test
    public void extractBadZipFileWithRelTarget() throws Exception {
        assertBadZipThrowsException(createRelPath(temp));
    }

    @Test
    public void extractBadTarFileSymlink() {
        File destination = new File(temp + ""/destination"");
        destination.mkdir();
        Path link = createSymlinkOrSkipTest(destination.toPath().resolve(""link""), destination.toPath());
        Assertions.assertThrows(ArchiveExtractionException.class, () -> extractor.extract(BAD_TAR, link.toString()));
    }

    private void assertBadZipThrowsException(File targetDir) {
        Assertions.assertThrows(RuntimeException.class, () ->
                extractor.extract(BAD_ZIP, targetDir.getPath()));
    }

    private void assertGoodZipExtractedTo(File targetDir) throws Exception {
        extractor.extract(GOOD_ZIP, targetDir.getPath());
        String nameOfFileInZip = ""zip"";
        Assertions.assertTrue(new File(temp, nameOfFileInZip).isFile(), ""zip content not found in target directory"");
    }

    private static File createRelPath(File orig) throws IOException {
        orig = orig.getCanonicalFile();
        String dirName = orig.getName();
        File result = new File(orig, ""../"" + dirName);
        Assertions.assertNotEquals(orig, result); // ensure result is different from input
        Assertions.assertEquals(orig, result.getCanonicalFile()); // ensure result points to same dir
        return result;
    }

    private Path createSymlinkOrSkipTest(Path link, Path target) {
        try {
            return Files.createSymbolicLink(link, target);
        } catch (UnsupportedOperationException | IOException e) {
            assumeTrue(false, ""symlinks not supported"");
            return null;
        }
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public class DefaultArchiveExtractorTest { private final String BAD_TAR = ""src/test/resources/bad.tgz""; private final String BAD_ZIP = ""src/test/resources/bad.zip""; private final String GOOD_TAR = ""src/test/resources/good.tgz""; private final String GOOD_ZIP = ""src/test/resources/good.zip""; @TempDir
    public File temp; private ArchiveExtractor extractor; @BeforeEach
    public void setup() { extractor = new DefaultArchiveExtractor(); } @Test
    public void extractGoodTarFile() throws Exception { extractor.extract(GOOD_TAR, temp.getPath()); } @Test
    public void extractGoodTarFileSymlink() throws Exception { File destination = new File(temp.getPath() + ""/destination""); destination.mkdir(); Path link = createSymlinkOrSkipTest(temp.toPath().resolve(""link""), destination.toPath()); extractor.extract(GOOD_TAR, link.toString()); } @Test
    public void extractBadTarFile() { Assertions.assertThrows(ArchiveExtractionException.class, () ->
                extractor.extract(BAD_TAR, temp.getPath())); } @Test
    public void extractGoodZipFile() throws Exception { assertGoodZipExtractedTo(temp); } @Test
    public void extractGoodZipFileWithRelTarget() throws Exception { assertGoodZipExtractedTo(createRelPath(temp)); } @Test
    public void extractBadZipFile() { assertBadZipThrowsException(temp); } @Test
    public void extractBadZipFileWithRelTarget() throws Exception { assertBadZipThrowsException(createRelPath(temp)); } @Test
    public void extractBadTarFileSymlink() { File destination = new File(temp + ""/destination""); destination.mkdir(); Path link = createSymlinkOrSkipTest(destination.toPath().resolve(""link""), destination.toPath()); Assertions.assertThrows(ArchiveExtractionException.class, () -> extractor.extract(BAD_TAR, link.toString())); } private void assertBadZipThrowsException(File targetDir) { Assertions.assertThrows(RuntimeException.class, () ->
                extractor.extract(BAD_ZIP, targetDir.getPath())); } private void assertGoodZipExtractedTo(File targetDir) throws Exception { extractor.extract(GOOD_ZIP, targetDir.getPath()); String nameOfFileInZip = ""zip""; Assertions.assertTrue(new File(temp, nameOfFileInZip).isFile(), ""zip content not found in target directory""); } private static File createRelPath(File orig) throws IOException { orig = orig.getCanonicalFile(); String dirName = orig.getName(); File result = new File(orig, ""../"" + dirName); Assertions.assertNotEquals(orig, result); Assertions.assertEquals(orig, result.getCanonicalFile()); return result; } private Path createSymlinkOrSkipTest(Path link, Path target) { try { return Files.createSymbolicLink(link, target); } catch (UnsupportedOperationException | IOException e) { assumeTrue(false, ""symlinks not supported""); return null; } } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public class DefaultArchiveExtractorTest { private final String BAD_TAR = ""src/test/resources/bad.tgz""; private final String BAD_ZIP = ""src/test/resources/bad.zip""; private final String GOOD_TAR = ""src/test/resources/good.tgz""; private final String GOOD_ZIP = ""src/test/resources/good.zip""; @TempDir
    public File temp; private ArchiveExtractor extractor; @BeforeEach
    public void setup() { extractor = new DefaultArchiveExtractor(); } @Test
    public void extractGoodTarFile() throws Exception { extractor.extract(GOOD_TAR, temp.getPath()); } @Test
    public void extractGoodTarFileSymlink() throws Exception { File destination = new File(temp.getPath() + ""/destination""); destination.mkdir(); Path link = createSymlinkOrSkipTest(temp.toPath().resolve(""link""), destination.toPath()); extractor.extract(GOOD_TAR, link.toString()); } @Test
    public void extractBadTarFile() { Assertions.assertThrows(ArchiveExtractionException.class, () ->
                extractor.extract(BAD_TAR, temp.getPath())); } @Test
    public void extractGoodZipFile() throws Exception { assertGoodZipExtractedTo(temp); } @Test
    public void extractGoodZipFileWithRelTarget() throws Exception { assertGoodZipExtractedTo(createRelPath(temp)); } @Test
    public void extractBadZipFile() { assertBadZipThrowsException(temp); } @Test
    public void extractBadZipFileWithRelTarget() throws Exception { assertBadZipThrowsException(createRelPath(temp)); } @Test
    public void extractBadTarFileSymlink() { File destination = new File(temp + ""/destination""); destination.mkdir(); Path link = createSymlinkOrSkipTest(destination.toPath().resolve(""link""), destination.toPath()); Assertions.assertThrows(ArchiveExtractionException.class, () -> extractor.extract(BAD_TAR, link.toString())); } private void assertBadZipThrowsException(File targetDir) { Assertions.assertThrows(RuntimeException.class, () ->
                extractor.extract(BAD_ZIP, targetDir.getPath())); } private void assertGoodZipExtractedTo(File targetDir) throws Exception { extractor.extract(GOOD_ZIP, targetDir.getPath()); String nameOfFileInZip = ""zip""; Assertions.assertTrue(new File(temp, nameOfFileInZip).isFile(), ""zip content not found in target directory""); } private static File createRelPath(File orig) throws IOException { orig = orig.getCanonicalFile(); String dirName = orig.getName(); File result = new File(orig, ""../"" + dirName); Assertions.assertNotEquals(orig, result); Assertions.assertEquals(orig, result.getCanonicalFile()); return result; } private Path createSymlinkOrSkipTest(Path link, Path target) { try { return Files.createSymbolicLink(link, target); } catch (UnsupportedOperationException | IOException e) { assumeTrue(false, ""symlinks not supported""); return null; } } } ","package com.github.eirslett.maven.plugins.frontend.lib; 

import org.junit.jupiter.api.Assertions; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.io.TempDir; 
import java.io.File; import java.io.IOException; import java.nio.file.Files; import java.nio.file.Path; 
import static org.junit.jupiter.api.Assumptions.assumeTrue; 
 public class DefaultArchiveExtractorTest {  private final String BAD_TAR = ""src/test/resources/bad.tgz""; private final String BAD_ZIP = ""src/test/resources/bad.zip"";  private final String GOOD_TAR = ""src/test/resources/good.tgz""; private final String GOOD_ZIP = ""src/test/resources/good.zip""; // sample zip with zip slip vulnerability @TempDir
    public File temp;  private ArchiveExtractor extractor;  @BeforeEach
    public void setup() { extractor = new DefaultArchiveExtractor(); }  @Test
    public void extractGoodTarFile() throws Exception { extractor.extract(GOOD_TAR, temp.getPath()); }  @Test
    public void extractGoodTarFileSymlink() throws Exception { File destination = new File(temp.getPath() + ""/destination""); destination.mkdir(); Path link = createSymlinkOrSkipTest(temp.toPath().resolve(""link""), destination.toPath()); extractor.extract(GOOD_TAR, link.toString()); }  @Test
    public void extractBadTarFile() { Assertions.assertThrows(ArchiveExtractionException.class, () ->
                extractor.extract(BAD_TAR, temp.getPath())); }  @Test
    public void extractGoodZipFile() throws Exception { assertGoodZipExtractedTo(temp); }  @Test
    public void extractGoodZipFileWithRelTarget() throws Exception { assertGoodZipExtractedTo(createRelPath(temp)); }  @Test
    public void extractBadZipFile() { assertBadZipThrowsException(temp); }  @Test
    public void extractBadZipFileWithRelTarget() throws Exception { assertBadZipThrowsException(createRelPath(temp)); }  @Test
    public void extractBadTarFileSymlink() { File destination = new File(temp + ""/destination""); destination.mkdir(); Path link = createSymlinkOrSkipTest(destination.toPath().resolve(""link""), destination.toPath()); Assertions.assertThrows(ArchiveExtractionException.class, () -> extractor.extract(BAD_TAR, link.toString())); }  private void assertBadZipThrowsException(File targetDir) { Assertions.assertThrows(RuntimeException.class, () ->
                extractor.extract(BAD_ZIP, targetDir.getPath())); }  private void assertGoodZipExtractedTo(File targetDir) throws Exception { extractor.extract(GOOD_ZIP, targetDir.getPath()); String nameOfFileInZip = ""zip""; Assertions.assertTrue(new File(temp, nameOfFileInZip).isFile(), ""zip content not found in target directory""); }  private static File createRelPath(File orig) throws IOException { orig = orig.getCanonicalFile(); String dirName = orig.getName(); File result = new File(orig, ""../"" + dirName); Assertions.assertNotEquals(orig, result);  Assertions.assertEquals(orig, result.getCanonicalFile()); // ensure result is different from input return result; } // ensure result points to same dir private Path createSymlinkOrSkipTest(Path link, Path target) { try { return Files.createSymbolicLink(link, target); } catch (UnsupportedOperationException | IOException e) { assumeTrue(false, ""symlinks not supported""); return null; } } }  "
frontend-plugin-core/src/test/java/com/github/eirslett/maven/plugins/frontend/lib/DefaultNpmRunnerTest.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import org.hamcrest.CoreMatchers;
import org.junit.jupiter.api.Test;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.jupiter.api.Assertions.assertEquals;


public class DefaultNpmRunnerTest {

    private final String id = ""id"";
    private final String protocol = ""http"";
    private final String host = ""localhost"";
    private final int port = 8888;
    private final String username = ""someusername"";
    private final String password = ""somepassword"";
    private final String nonProxyHosts = ""www.google.ca|www.google.com|*.google.de"";
    private final String[] expectedNonProxyHosts = new String[] {""www.google.ca"",""www.google.com"","".google.de""};
    private final String registryUrl = ""www.npm.org"";
    private final String expectedUrl = ""http://someusername:somepassword@localhost:8888"";

    @Test
    public void buildArguments_basicTest() {
        List<String> strings = runBuildArguments(nonProxyHosts, registryUrl);

        assertThat(strings, CoreMatchers.hasItem(""--proxy="" + expectedUrl));
        assertThat(strings, CoreMatchers.hasItem(""--https-proxy="" + expectedUrl));
        for (String expectedNonProxyHost: expectedNonProxyHosts) {
            assertThat(strings, CoreMatchers.hasItem(""--noproxy="" + expectedNonProxyHost));
        }
        assertThat(strings, CoreMatchers.hasItem(""--registry="" + registryUrl));
        assertEquals(6, strings.size());
    }


    @Test
    public void buildArguments_emptyRegistryUrl() {
        List<String> strings = runBuildArguments(nonProxyHosts, """");

        assertThat(strings, CoreMatchers.hasItem(""--proxy="" + expectedUrl));
        assertThat(strings, CoreMatchers.hasItem(""--https-proxy="" + expectedUrl));
        for (String expectedNonProxyHost: expectedNonProxyHosts) {
            assertThat(strings, CoreMatchers.hasItem(""--noproxy="" + expectedNonProxyHost));
        }
        assertEquals(5, strings.size());
    }

    @Test
    public void buildArguments_nullRegistryUrl() {
        List<String> strings = runBuildArguments(nonProxyHosts, null);

        assertThat(strings, CoreMatchers.hasItem(""--proxy="" + expectedUrl));
        assertThat(strings, CoreMatchers.hasItem(""--https-proxy="" + expectedUrl));
        for (String expectedNonProxyHost: expectedNonProxyHosts) {
            assertThat(strings, CoreMatchers.hasItem(""--noproxy="" + expectedNonProxyHost));
        }
        assertEquals(5, strings.size());
    }

    @Test
    public void buildArguments_emptyNoProxy() {
        List<String> strings = runBuildArguments("""", """");

        assertThat(strings, CoreMatchers.hasItem(""--proxy="" + expectedUrl));
        assertThat(strings, CoreMatchers.hasItem(""--https-proxy="" + expectedUrl));
        assertEquals(2, strings.size());
    }

    @Test
    public void buildArguments_nullNoProxy() {
        List<String> strings = runBuildArguments(null, """");

        assertThat(strings, CoreMatchers.hasItem(""--proxy="" + expectedUrl));
        assertThat(strings, CoreMatchers.hasItem(""--https-proxy="" + expectedUrl));
        assertEquals(2, strings.size());
    }

    private List<String> runBuildArguments(String nonProxyHost, String registryUrl) {
        List<ProxyConfig.Proxy> proxyList = Stream.of(
                new ProxyConfig.Proxy(id, protocol, host, port, username, password, nonProxyHost)
        ).collect(Collectors.toList());

        return DefaultNpmRunner.buildArguments(new ProxyConfig(proxyList), registryUrl);
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public class DefaultNpmRunnerTest { private final String id = ""id""; private final String protocol = ""http""; private final String host = ""localhost""; private final int port = 8888; private final String username = ""someusername""; private final String password = ""somepassword""; private final String nonProxyHosts = ""www.google.ca|www.google.com|*.google.de""; private final String[] expectedNonProxyHosts = new String[] { ""www.google.ca"",""www.google.com"","".google.de""} ; private final String registryUrl = ""www.npm.org""; @Test
    public void buildArguments_basicTest() { List<String> strings = runBuildArguments(nonProxyHosts, registryUrl); assertThat(strings, CoreMatchers.hasItem(""--proxy="" + expectedUrl)); assertThat(strings, CoreMatchers.hasItem(""--https-proxy="" + expectedUrl)); for (String expectedNonProxyHost: expectedNonProxyHosts) { assertThat(strings, CoreMatchers.hasItem(""--noproxy="" + expectedNonProxyHost)); } assertThat(strings, CoreMatchers.hasItem(""--registry="" + registryUrl)); assertEquals(6, strings.size()); } @Test
    public void buildArguments_emptyRegistryUrl() { List<String> strings = runBuildArguments(nonProxyHosts, """"); assertThat(strings, CoreMatchers.hasItem(""--proxy="" + expectedUrl)); assertThat(strings, CoreMatchers.hasItem(""--https-proxy="" + expectedUrl)); for (String expectedNonProxyHost: expectedNonProxyHosts) { assertThat(strings, CoreMatchers.hasItem(""--noproxy="" + expectedNonProxyHost)); } assertEquals(5, strings.size()); } @Test
    public void buildArguments_nullRegistryUrl() { List<String> strings = runBuildArguments(nonProxyHosts, null); assertThat(strings, CoreMatchers.hasItem(""--proxy="" + expectedUrl)); assertThat(strings, CoreMatchers.hasItem(""--https-proxy="" + expectedUrl)); for (String expectedNonProxyHost: expectedNonProxyHosts) { assertThat(strings, CoreMatchers.hasItem(""--noproxy="" + expectedNonProxyHost)); } assertEquals(5, strings.size()); } @Test
    public void buildArguments_emptyNoProxy() { List<String> strings = runBuildArguments("""", """"); assertThat(strings, CoreMatchers.hasItem(""--proxy="" + expectedUrl)); assertThat(strings, CoreMatchers.hasItem(""--https-proxy="" + expectedUrl)); assertEquals(2, strings.size()); } @Test
    public void buildArguments_nullNoProxy() { List<String> strings = runBuildArguments(null, """"); assertThat(strings, CoreMatchers.hasItem(""--proxy="" + expectedUrl)); assertThat(strings, CoreMatchers.hasItem(""--https-proxy="" + expectedUrl)); assertEquals(2, strings.size()); } private List<String> runBuildArguments(String nonProxyHost, String registryUrl) { List<ProxyConfig.Proxy> proxyList = Stream.of(
                new ProxyConfig.Proxy(id, protocol, host, port, username, password, nonProxyHost)
        ).collect(Collectors.toList()); return DefaultNpmRunner.buildArguments(new ProxyConfig(proxyList), registryUrl); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public class DefaultNpmRunnerTest { private final String id = ""id""; private final String protocol = ""http""; private final String host = ""localhost""; private final int port = 8888; private final String username = ""someusername""; private final String password = ""somepassword""; private final String nonProxyHosts = ""www.google.ca|www.google.com|*.google.de""; private final String[] expectedNonProxyHosts = new String[] { ""www.google.ca"",""www.google.com"","".google.de""} ; private final String registryUrl = ""www.npm.org""; @Test
    public void buildArguments_basicTest() { List<String> strings = runBuildArguments(nonProxyHosts, registryUrl); assertThat(strings, CoreMatchers.hasItem(""--proxy="" + expectedUrl)); assertThat(strings, CoreMatchers.hasItem(""--https-proxy="" + expectedUrl)); for (String expectedNonProxyHost: expectedNonProxyHosts) { assertThat(strings, CoreMatchers.hasItem(""--noproxy="" + expectedNonProxyHost)); } assertThat(strings, CoreMatchers.hasItem(""--registry="" + registryUrl)); assertEquals(6, strings.size()); } @Test
    public void buildArguments_emptyRegistryUrl() { List<String> strings = runBuildArguments(nonProxyHosts, """"); assertThat(strings, CoreMatchers.hasItem(""--proxy="" + expectedUrl)); assertThat(strings, CoreMatchers.hasItem(""--https-proxy="" + expectedUrl)); for (String expectedNonProxyHost: expectedNonProxyHosts) { assertThat(strings, CoreMatchers.hasItem(""--noproxy="" + expectedNonProxyHost)); } assertEquals(5, strings.size()); } @Test
    public void buildArguments_nullRegistryUrl() { List<String> strings = runBuildArguments(nonProxyHosts, null); assertThat(strings, CoreMatchers.hasItem(""--proxy="" + expectedUrl)); assertThat(strings, CoreMatchers.hasItem(""--https-proxy="" + expectedUrl)); for (String expectedNonProxyHost: expectedNonProxyHosts) { assertThat(strings, CoreMatchers.hasItem(""--noproxy="" + expectedNonProxyHost)); } assertEquals(5, strings.size()); } @Test
    public void buildArguments_emptyNoProxy() { List<String> strings = runBuildArguments("""", """"); assertThat(strings, CoreMatchers.hasItem(""--proxy="" + expectedUrl)); assertThat(strings, CoreMatchers.hasItem(""--https-proxy="" + expectedUrl)); assertEquals(2, strings.size()); } @Test
    public void buildArguments_nullNoProxy() { List<String> strings = runBuildArguments(null, """"); assertThat(strings, CoreMatchers.hasItem(""--proxy="" + expectedUrl)); assertThat(strings, CoreMatchers.hasItem(""--https-proxy="" + expectedUrl)); assertEquals(2, strings.size()); } private List<String> runBuildArguments(String nonProxyHost, String registryUrl) { List<ProxyConfig.Proxy> proxyList = Stream.of(
                new ProxyConfig.Proxy(id, protocol, host, port, username, password, nonProxyHost)
        ).collect(Collectors.toList()); return DefaultNpmRunner.buildArguments(new ProxyConfig(proxyList), registryUrl); } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import org.hamcrest.CoreMatchers; import org.junit.jupiter.api.Test; 
import java.util.List; import java.util.stream.Collectors; import java.util.stream.Stream; 
import static org.hamcrest.MatcherAssert.assertThat; import static org.junit.jupiter.api.Assertions.assertEquals; 
 public class DefaultNpmRunnerTest {  private final String id = ""id""; private final String protocol = ""http""; private final String host = ""localhost""; private final int port = 8888; private final String username = ""someusername""; private final String password = ""somepassword""; private final String nonProxyHosts = ""www.google.ca|www.google.com|*.google.de""; private final String[] expectedNonProxyHosts = new String[] { ""www.google.ca"",""www.google.com"","".google.de""} ; private final String registryUrl = ""www.npm.org"";  //someusername:somepassword@localhost:8888""; @Test
    public void buildArguments_basicTest() { List<String> strings = runBuildArguments(nonProxyHosts, registryUrl);  assertThat(strings, CoreMatchers.hasItem(""--proxy="" + expectedUrl)); assertThat(strings, CoreMatchers.hasItem(""--https-proxy="" + expectedUrl)); for (String expectedNonProxyHost: expectedNonProxyHosts) { assertThat(strings, CoreMatchers.hasItem(""--noproxy="" + expectedNonProxyHost)); } assertThat(strings, CoreMatchers.hasItem(""--registry="" + registryUrl)); assertEquals(6, strings.size()); }  @Test
    public void buildArguments_emptyRegistryUrl() { List<String> strings = runBuildArguments(nonProxyHosts, """"); 
 assertThat(strings, CoreMatchers.hasItem(""--proxy="" + expectedUrl)); assertThat(strings, CoreMatchers.hasItem(""--https-proxy="" + expectedUrl)); for (String expectedNonProxyHost: expectedNonProxyHosts) { assertThat(strings, CoreMatchers.hasItem(""--noproxy="" + expectedNonProxyHost)); } assertEquals(5, strings.size()); }  @Test
    public void buildArguments_nullRegistryUrl() { List<String> strings = runBuildArguments(nonProxyHosts, null);  assertThat(strings, CoreMatchers.hasItem(""--proxy="" + expectedUrl)); assertThat(strings, CoreMatchers.hasItem(""--https-proxy="" + expectedUrl)); for (String expectedNonProxyHost: expectedNonProxyHosts) { assertThat(strings, CoreMatchers.hasItem(""--noproxy="" + expectedNonProxyHost)); } assertEquals(5, strings.size()); }  @Test
    public void buildArguments_emptyNoProxy() { List<String> strings = runBuildArguments("""", """");  assertThat(strings, CoreMatchers.hasItem(""--proxy="" + expectedUrl)); assertThat(strings, CoreMatchers.hasItem(""--https-proxy="" + expectedUrl)); assertEquals(2, strings.size()); }  @Test
    public void buildArguments_nullNoProxy() { List<String> strings = runBuildArguments(null, """");  assertThat(strings, CoreMatchers.hasItem(""--proxy="" + expectedUrl)); assertThat(strings, CoreMatchers.hasItem(""--https-proxy="" + expectedUrl)); assertEquals(2, strings.size()); }  private List<String> runBuildArguments(String nonProxyHost, String registryUrl) { List<ProxyConfig.Proxy> proxyList = Stream.of(
                new ProxyConfig.Proxy(id, protocol, host, port, username, password, nonProxyHost)
        ).collect(Collectors.toList());  return DefaultNpmRunner.buildArguments(new ProxyConfig(proxyList), registryUrl); } }  "
frontend-plugin-core/src/test/java/com/github/eirslett/maven/plugins/frontend/lib/DefaultNpxRunnerTest.java,"package com.github.eirslett.maven.plugins.frontend.lib;


import java.util.Collections;
import java.util.List;

import org.hamcrest.CoreMatchers;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import static org.hamcrest.MatcherAssert.assertThat;

public class DefaultNpxRunnerTest {

    private final String registryUrl = ""www.npm.org"";

    @Test
    public void buildArgument_basicTest() {
        List<String> arguments = DefaultNpxRunner.buildNpmArguments(new ProxyConfig(Collections.emptyList()), null);
        Assertions.assertEquals(0, arguments.size());
    }

    @Test
    public void buildArgument_withRegistryUrl() {
        List<String> arguments = DefaultNpxRunner.buildNpmArguments(new ProxyConfig(Collections.emptyList()), registryUrl);
        Assertions.assertEquals(2, arguments.size());
        assertThat(arguments, CoreMatchers.hasItems(""--"", ""--registry="" + registryUrl));
    }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public class DefaultNpxRunnerTest { private final String registryUrl = ""www.npm.org""; @Test
    public void buildArgument_basicTest() { List<String> arguments = DefaultNpxRunner.buildNpmArguments(new ProxyConfig(Collections.emptyList()), null); Assertions.assertEquals(0, arguments.size()); } @Test
    public void buildArgument_withRegistryUrl() { List<String> arguments = DefaultNpxRunner.buildNpmArguments(new ProxyConfig(Collections.emptyList()), registryUrl); Assertions.assertEquals(2, arguments.size()); assertThat(arguments, CoreMatchers.hasItems(""--"", ""--registry="" + registryUrl)); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public class DefaultNpxRunnerTest { private final String registryUrl = ""www.npm.org""; @Test
    public void buildArgument_basicTest() { List<String> arguments = DefaultNpxRunner.buildNpmArguments(new ProxyConfig(Collections.emptyList()), null); Assertions.assertEquals(0, arguments.size()); } @Test
    public void buildArgument_withRegistryUrl() { List<String> arguments = DefaultNpxRunner.buildNpmArguments(new ProxyConfig(Collections.emptyList()), registryUrl); Assertions.assertEquals(2, arguments.size()); assertThat(arguments, CoreMatchers.hasItems(""--"", ""--registry="" + registryUrl)); } } ","package com.github.eirslett.maven.plugins.frontend.lib; 

import java.util.Collections; import java.util.List; 
import org.hamcrest.CoreMatchers; import org.junit.jupiter.api.Assertions; import org.junit.jupiter.api.Test; 
import static org.hamcrest.MatcherAssert.assertThat;  public class DefaultNpxRunnerTest {  private final String registryUrl = ""www.npm.org"";  @Test
    public void buildArgument_basicTest() { List<String> arguments = DefaultNpxRunner.buildNpmArguments(new ProxyConfig(Collections.emptyList()), null); Assertions.assertEquals(0, arguments.size()); }  @Test
    public void buildArgument_withRegistryUrl() { List<String> arguments = DefaultNpxRunner.buildNpmArguments(new ProxyConfig(Collections.emptyList()), registryUrl); Assertions.assertEquals(2, arguments.size()); assertThat(arguments, CoreMatchers.hasItems(""--"", ""--registry="" + registryUrl)); } }  "
frontend-plugin-core/src/test/java/com/github/eirslett/maven/plugins/frontend/lib/PlatformTest.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import org.junit.jupiter.api.Test;
import java.util.function.Supplier;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class PlatformTest {

    private static final String NODE_VERSION_8 = ""v8.17.2"";
    private static final String NODE_VERSION_15 = ""v15.14.0"";
    private static final String NODE_VERSION_16 = ""v16.1.0"";

    @Test
    public void detect_win_doesntLookForAlpine() {
        // Throw if called
        Supplier<Boolean> checkForAlpine = () -> {
            throw new RuntimeException(""Shouldn't be called"");
        };

        Platform platform = Platform.guess(OS.Windows, Architecture.x86, () -> false);
        assertEquals(""win-x86"", platform.getNodeClassifier(NODE_VERSION_15));
    }

    @Test
    public void detect_arm_mac_download_x64_binary_node15() {
        Platform platform = Platform.guess(OS.Mac, Architecture.arm64, () -> false);
        assertEquals(""darwin-x64"", platform.getNodeClassifier(NODE_VERSION_15));
    }

    @Test
    public void detect_arm_mac_download_x64_binary_node16() {
        Platform platform = Platform.guess(OS.Mac, Architecture.arm64, () -> false);
        assertEquals(""darwin-arm64"", platform.getNodeClassifier(NODE_VERSION_16));
    }

    @Test
    public void detect_linux_notAlpine() throws Exception {
        Platform platform = Platform.guess(OS.Linux, Architecture.x86, () -> false);
        assertEquals(""linux-x86"", platform.getNodeClassifier(NODE_VERSION_15));
        assertEquals(""https://nodejs.org/dist/"", platform.getNodeDownloadRoot());
    }

    @Test
    public void detect_linux_alpine() throws Exception {
        Platform platform = Platform.guess(OS.Linux, Architecture.x86, () -> true);
        assertEquals(""linux-x86-musl"", platform.getNodeClassifier(NODE_VERSION_15));
        assertEquals(""https://unofficial-builds.nodejs.org/download/release/"",
                platform.getNodeDownloadRoot());
    }

    @Test
    public void detect_aix_ppc64() {
        Platform platform = Platform.guess(OS.AIX, Architecture.ppc64, () -> false);
        assertEquals(""aix-ppc64"", platform.getNodeClassifier(NODE_VERSION_15));
    }

    @Test
    public void getNodeMajorVersion() {
        assertEquals(Integer.valueOf(8), Platform.getNodeMajorVersion(NODE_VERSION_8));
        assertEquals(Integer.valueOf(15), Platform.getNodeMajorVersion(NODE_VERSION_15));
        assertEquals(Integer.valueOf(16), Platform.getNodeMajorVersion(NODE_VERSION_16));
    }

}
","package com.github.eirslett.maven.plugins.frontend.lib; public class PlatformTest { private static final String NODE_VERSION_8 = ""v8.17.2""; private static final String NODE_VERSION_15 = ""v15.14.0""; private static final String NODE_VERSION_16 = ""v16.1.0""; @Test
    public void detect_win_doesntLookForAlpine() { Supplier<Boolean> checkForAlpine = () -> { throw new RuntimeException(""Shouldn't be called""); } ; Platform platform = Platform.guess(OS.Windows, Architecture.x86, () -> false); assertEquals(""win-x86"", platform.getNodeClassifier(NODE_VERSION_15)); } @Test
    public void detect_arm_mac_download_x64_binary_node15() { Platform platform = Platform.guess(OS.Mac, Architecture.arm64, () -> false); assertEquals(""darwin-x64"", platform.getNodeClassifier(NODE_VERSION_15)); } @Test
    public void detect_arm_mac_download_x64_binary_node16() { Platform platform = Platform.guess(OS.Mac, Architecture.arm64, () -> false); assertEquals(""darwin-arm64"", platform.getNodeClassifier(NODE_VERSION_16)); } @Test
    public void detect_linux_notAlpine() throws Exception { Platform platform = Platform.guess(OS.Linux, Architecture.x86, () -> false); assertEquals(""linux-x86"", platform.getNodeClassifier(NODE_VERSION_15)); } @Test
    public void detect_linux_alpine() throws Exception { Platform platform = Platform.guess(OS.Linux, Architecture.x86, () -> true); assertEquals(""linux-x86-musl"", platform.getNodeClassifier(NODE_VERSION_15)); platform.getNodeDownloadRoot()); } @Test
    public void detect_aix_ppc64() { Platform platform = Platform.guess(OS.AIX, Architecture.ppc64, () -> false); assertEquals(""aix-ppc64"", platform.getNodeClassifier(NODE_VERSION_15)); } @Test
    public void getNodeMajorVersion() { assertEquals(Integer.valueOf(8), Platform.getNodeMajorVersion(NODE_VERSION_8)); assertEquals(Integer.valueOf(15), Platform.getNodeMajorVersion(NODE_VERSION_15)); assertEquals(Integer.valueOf(16), Platform.getNodeMajorVersion(NODE_VERSION_16)); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public class PlatformTest { private static final String NODE_VERSION_8 = ""v8.17.2""; private static final String NODE_VERSION_15 = ""v15.14.0""; private static final String NODE_VERSION_16 = ""v16.1.0""; @Test
    public void detect_win_doesntLookForAlpine() { Supplier<Boolean> checkForAlpine = () -> { throw new RuntimeException(""Shouldn't be called""); } ; Platform platform = Platform.guess(OS.Windows, Architecture.x86, () -> false); assertEquals(""win-x86"", platform.getNodeClassifier(NODE_VERSION_15)); } @Test
    public void detect_arm_mac_download_x64_binary_node15() { Platform platform = Platform.guess(OS.Mac, Architecture.arm64, () -> false); assertEquals(""darwin-x64"", platform.getNodeClassifier(NODE_VERSION_15)); } @Test
    public void detect_arm_mac_download_x64_binary_node16() { Platform platform = Platform.guess(OS.Mac, Architecture.arm64, () -> false); assertEquals(""darwin-arm64"", platform.getNodeClassifier(NODE_VERSION_16)); } @Test
    public void detect_linux_notAlpine() throws Exception { Platform platform = Platform.guess(OS.Linux, Architecture.x86, () -> false); assertEquals(""linux-x86"", platform.getNodeClassifier(NODE_VERSION_15)); } @Test
    public void detect_linux_alpine() throws Exception { Platform platform = Platform.guess(OS.Linux, Architecture.x86, () -> true); assertEquals(""linux-x86-musl"", platform.getNodeClassifier(NODE_VERSION_15)); platform.getNodeDownloadRoot()); } @Test
    public void detect_aix_ppc64() { Platform platform = Platform.guess(OS.AIX, Architecture.ppc64, () -> false); assertEquals(""aix-ppc64"", platform.getNodeClassifier(NODE_VERSION_15)); } @Test
    public void getNodeMajorVersion() { assertEquals(Integer.valueOf(8), Platform.getNodeMajorVersion(NODE_VERSION_8)); assertEquals(Integer.valueOf(15), Platform.getNodeMajorVersion(NODE_VERSION_15)); assertEquals(Integer.valueOf(16), Platform.getNodeMajorVersion(NODE_VERSION_16)); } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import org.junit.jupiter.api.Test; import java.util.function.Supplier; 
import static org.junit.jupiter.api.Assertions.assertEquals;  public class PlatformTest {  private static final String NODE_VERSION_8 = ""v8.17.2""; private static final String NODE_VERSION_15 = ""v15.14.0""; private static final String NODE_VERSION_16 = ""v16.1.0"";  @Test
    public void detect_win_doesntLookForAlpine() { // Throw if called Supplier<Boolean> checkForAlpine = () -> { throw new RuntimeException(""Shouldn't be called""); } ;  Platform platform = Platform.guess(OS.Windows, Architecture.x86, () -> false); assertEquals(""win-x86"", platform.getNodeClassifier(NODE_VERSION_15)); }  @Test
    public void detect_arm_mac_download_x64_binary_node15() { Platform platform = Platform.guess(OS.Mac, Architecture.arm64, () -> false); assertEquals(""darwin-x64"", platform.getNodeClassifier(NODE_VERSION_15)); }  @Test
    public void detect_arm_mac_download_x64_binary_node16() { Platform platform = Platform.guess(OS.Mac, Architecture.arm64, () -> false); assertEquals(""darwin-arm64"", platform.getNodeClassifier(NODE_VERSION_16)); }  @Test
    public void detect_linux_notAlpine() throws Exception { Platform platform = Platform.guess(OS.Linux, Architecture.x86, () -> false); assertEquals(""linux-x86"", platform.getNodeClassifier(NODE_VERSION_15)); //nodejs.org/dist/"", platform.getNodeDownloadRoot()); }  @Test
    public void detect_linux_alpine() throws Exception { Platform platform = Platform.guess(OS.Linux, Architecture.x86, () -> true); assertEquals(""linux-x86-musl"", platform.getNodeClassifier(NODE_VERSION_15)); //unofficial-builds.nodejs.org/download/release/"", platform.getNodeDownloadRoot()); }  @Test
    public void detect_aix_ppc64() { Platform platform = Platform.guess(OS.AIX, Architecture.ppc64, () -> false); assertEquals(""aix-ppc64"", platform.getNodeClassifier(NODE_VERSION_15)); }  @Test
    public void getNodeMajorVersion() { assertEquals(Integer.valueOf(8), Platform.getNodeMajorVersion(NODE_VERSION_8)); assertEquals(Integer.valueOf(15), Platform.getNodeMajorVersion(NODE_VERSION_15)); assertEquals(Integer.valueOf(16), Platform.getNodeMajorVersion(NODE_VERSION_16)); }  }  "
frontend-plugin-core/src/test/java/com/github/eirslett/maven/plugins/frontend/lib/UtilsTest.java,"package com.github.eirslett.maven.plugins.frontend.lib;

import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static java.util.Collections.singletonList;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class UtilsTest {

  @Test
  public void testImplode() {
    final String separator = ""Bar"";
    final List<String> elements = new ArrayList<>();

    assertEquals("""", Utils.implode(separator, elements));

    elements.add(""foo"");
    elements.add(""bar"");
    assertEquals(""foo bar"", Utils.implode(separator, elements));
  }

  @Test
  public void testIsRelative() {
    assertTrue(Utils.isRelative(""foo/bar""));

    assertFalse(Utils.isRelative(""/foo/bar""));
    assertFalse(Utils.isRelative(""file:foo/bar""));
    assertFalse(Utils.isRelative(""C:\\SYSTEM""));
  }

  @Test
  public void testMerge() {
    assertEquals(
            Arrays.asList(""foo"", ""bar""),
            Utils.merge(singletonList(""foo""), singletonList(""bar""))
    );
  }

  @Test
  public void testPrepend() {
    assertEquals(
            Arrays.asList(""foo"", ""bar""),
            Utils.prepend(""foo"", singletonList(""bar""))
    );
  }
}
","package com.github.eirslett.maven.plugins.frontend.lib; public class UtilsTest { @Test
  public void testImplode() { final String separator = ""Bar""; final List<String> elements = new ArrayList<>(); assertEquals("""", Utils.implode(separator, elements)); elements.add(""foo""); elements.add(""bar""); assertEquals(""foo bar"", Utils.implode(separator, elements)); } @Test
  public void testIsRelative() { assertTrue(Utils.isRelative(""foo/bar"")); assertFalse(Utils.isRelative(""/foo/bar"")); assertFalse(Utils.isRelative(""file:foo/bar"")); assertFalse(Utils.isRelative(""C:\\SYSTEM"")); } @Test
  public void testMerge() { assertEquals(
            Arrays.asList(""foo"", ""bar""),
            Utils.merge(singletonList(""foo""), singletonList(""bar""))
    ); } @Test
  public void testPrepend() { assertEquals(
            Arrays.asList(""foo"", ""bar""),
            Utils.prepend(""foo"", singletonList(""bar""))
    ); } }",0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,"package com.github.eirslett.maven.plugins.frontend.lib; public class UtilsTest { @Test
  public void testImplode() { final String separator = ""Bar""; final List<String> elements = new ArrayList<>(); assertEquals("""", Utils.implode(separator, elements)); elements.add(""foo""); elements.add(""bar""); assertEquals(""foo bar"", Utils.implode(separator, elements)); } @Test
  public void testIsRelative() { assertTrue(Utils.isRelative(""foo/bar"")); assertFalse(Utils.isRelative(""/foo/bar"")); assertFalse(Utils.isRelative(""file:foo/bar"")); assertFalse(Utils.isRelative(""C:\\SYSTEM"")); } @Test
  public void testMerge() { assertEquals(
            Arrays.asList(""foo"", ""bar""),
            Utils.merge(singletonList(""foo""), singletonList(""bar""))
    ); } @Test
  public void testPrepend() { assertEquals(
            Arrays.asList(""foo"", ""bar""),
            Utils.prepend(""foo"", singletonList(""bar""))
    ); } } ","package com.github.eirslett.maven.plugins.frontend.lib; 
import org.junit.jupiter.api.Test; 
import java.util.ArrayList; import java.util.Arrays; import java.util.List; 
import static java.util.Collections.singletonList; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertTrue;  public class UtilsTest {  @Test
  public void testImplode() { final String separator = ""Bar""; final List<String> elements = new ArrayList<>();  assertEquals("""", Utils.implode(separator, elements));  elements.add(""foo""); elements.add(""bar""); assertEquals(""foo bar"", Utils.implode(separator, elements)); }  @Test
  public void testIsRelative() { assertTrue(Utils.isRelative(""foo/bar""));  assertFalse(Utils.isRelative(""/foo/bar"")); assertFalse(Utils.isRelative(""file:foo/bar"")); assertFalse(Utils.isRelative(""C:\\SYSTEM"")); }  @Test
  public void testMerge() { assertEquals(
            Arrays.asList(""foo"", ""bar""),
            Utils.merge(singletonList(""foo""), singletonList(""bar""))
    ); }  @Test
  public void testPrepend() { assertEquals(
            Arrays.asList(""foo"", ""bar""),
            Utils.prepend(""foo"", singletonList(""bar""))
    ); } }  "
